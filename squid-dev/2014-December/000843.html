<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] support rotate=N option on access_log
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20support%20rotate%3DN%20option%20on%20access_log&In-Reply-To=%3C54A1482B.4090108%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000842.html">
   <LINK REL="Next"  HREF="000844.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] support rotate=N option on access_log</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20support%20rotate%3DN%20option%20on%20access_log&In-Reply-To=%3C54A1482B.4090108%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] support rotate=N option on access_log">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Dec 29 12:25:15 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000842.html">[squid-dev] I was wondering about session\connection ID.
</A></li>
        <LI>Next message: <A HREF="000844.html">[squid-dev] Build failed in Jenkins: 3.HEAD-amd64-centos-7 #247
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#843">[ date ]</a>
              <a href="thread.html#843">[ thread ]</a>
              <a href="subject.html#843">[ subject ]</a>
              <a href="author.html#843">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

This adds a rotate=N option to access_log directive to set per-log
what the retained log count will be. At present it is only used by the
stdio: logging module, which is also the only one to use
logfile_rotate directive.

If this option is absent (as will be the common case) the log rotation
defaults to using the value of logfile_rotate directive.

Also, add missing dump output of other access_log options if they
differ from the default.

The use-cases for this are:

1) Unix fifo logging requires all the stdio: module operations except
that the normal rotate/rename operation is NOT performed on the fifo
socket. It makes more sense to add this option whih can also meet ase
#2 than to create a whole new module just for fifo.

2) managing only some access_log files with a third-party log manager.
Those specific logs need rotate=0, but the Squid managed logs may
require non-0 values.

Amos
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUoUgqAAoJELJo5wb/XPRjJMAH+wTIHGx0L0QGFLzKf/CMUdtm
k2/qFN08Pr7tGvfEaKWMhYx7NqUrAULwWyWyjV18IqTM51zl9ANkoPRvgDzTCTOi
/krb5EPv/q7KfHGkBWh/asJ8echxvL5Xs7ub2vYXN8MQpkQteL1wWIVd6aJgJwJb
Uo0GxRgrDl8T59CcCbEDsf9JKzTfeSVAabxjvv01iPVRhXcBQ7WgujoInDBvboD2
ufNDsFBSMoLD4qLrFoE62X+JwpyYteniPKYTzCG08cdVTHCbdEx9xhRskACvaUot
Q/CuxAtV23jnmtWMT/M9rBjzDFcwFJc0MXzbADa/Z48O2ItVagZuoZ6KkWczNDg=
=8Lvv
-----END PGP SIGNATURE-----
-------------- next part --------------
=== modified file 'src/adaptation/icap/icap_log.cc'
--- src/adaptation/icap/icap_log.cc	2014-12-20 12:12:02 +0000
+++ src/adaptation/icap/icap_log.cc	2014-12-29 02:37:06 +0000
@@ -35,37 +35,37 @@
 }
 
 void
 icapLogClose()
 {
     CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log-&gt;next) {
         if (log-&gt;logfile) {
             logfileClose(log-&gt;logfile);
             log-&gt;logfile = NULL;
         }
     }
 }
 
 void
 icapLogRotate()
 {
     for (CustomLog* log = Config.Log.icaplogs; log; log = log-&gt;next) {
         if (log-&gt;logfile) {
-            logfileRotate(log-&gt;logfile);
+            logfileRotate(log-&gt;logfile, Config.Log.rotateNumber);
         }
     }
 }
 
 void icapLogLog(AccessLogEntry::Pointer &amp;al)
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
         ACLFilledChecklist checklist(NULL, al-&gt;adapted_request, NULL);
         if (al-&gt;reply) {
             checklist.reply = al-&gt;reply;
             HTTPMSGLOCK(checklist.reply);
         }
         accessLogLogTo(Config.Log.icaplogs, al, &amp;checklist);
     }
 }
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2014-12-20 12:12:02 +0000
+++ src/cache_cf.cc	2014-12-29 05:46:09 +0000
@@ -4079,63 +4079,66 @@
 
     /* determine configuration style */
 
     const char *filename = ConfigParser::NextToken();
     if (!filename) {
         self_destruct();
         return;
     }
 
     if (strcmp(filename, &quot;none&quot;) == 0) {
         cl-&gt;type = Log::Format::CLF_NONE;
         aclParseAclList(LegacyParser, &amp;cl-&gt;aclList, filename);
         while (*logs)
             logs = &amp;(*logs)-&gt;next;
         *logs = cl;
         return;
     }
 
     cl-&gt;filename = xstrdup(filename);
     cl-&gt;type = Log::Format::CLF_UNKNOWN;
+    cl-&gt;rotateCount = -1; // default: use global logfile_rotate setting.
 
     const char *token = ConfigParser::PeekAtToken();
     if (!token) { // style #1
         // no options to deal with
     } else if (!strchr(token, '=')) { // style #3
         // if logformat name is recognized,
         // pop the previewed token; Else it must be an ACL name
         if (setLogformat(cl, token, false))
             (void)ConfigParser::NextToken();
     } else { // style #4
         do {
             if (strncasecmp(token, &quot;on-error=&quot;, 9) == 0) {
                 if (strncasecmp(token+9, &quot;die&quot;, 3) == 0) {
                     cl-&gt;fatal = true;
                 } else if (strncasecmp(token+9, &quot;drop&quot;, 4) == 0) {
                     cl-&gt;fatal = false;
                 } else {
                     debugs(3, DBG_CRITICAL, &quot;Unknown value for on-error '&quot; &lt;&lt;
                            token &lt;&lt; &quot;' expected 'drop' or 'die'&quot;);
                     self_destruct();
                 }
             } else if (strncasecmp(token, &quot;buffer-size=&quot;, 12) == 0) {
                 parseBytesOptionValue(&amp;cl-&gt;bufferSize, B_BYTES_STR, token+12);
+            } else if (strncasecmp(token, &quot;rotate=&quot;, 7) == 0) {
+                cl-&gt;rotateCount = xatoi(token + 7);
             } else if (strncasecmp(token, &quot;logformat=&quot;, 10) == 0) {
                 setLogformat(cl, token+10, true);
             } else if (!strchr(token, '=')) {
                 // Do not pop the token; it must be an ACL name
                 break; // done with name=value options, now to ACLs
             } else {
                 debugs(3, DBG_CRITICAL, &quot;Unknown access_log option &quot; &lt;&lt; token);
                 self_destruct();
             }
             // Pop the token, it was a valid &quot;name=value&quot; option
             (void)ConfigParser::NextToken();
             // Get next with preview ConfigParser::NextToken call.
         } while ((token = ConfigParser::PeekAtToken()) != NULL);
     }
 
     // set format if it has not been specified explicitly
     if (cl-&gt;type == Log::Format::CLF_UNKNOWN)
         setLogformat(cl, &quot;squid&quot;, true);
 
     aclParseAclList(LegacyParser, &amp;cl-&gt;aclList, cl-&gt;filename);
@@ -4206,76 +4209,87 @@
     return true;
 }
 
 static int
 check_null_access_log(CustomLog *customlog_definitions)
 {
     return customlog_definitions == NULL;
 }
 
 static void
 dump_access_log(StoreEntry * entry, const char *name, CustomLog * logs)
 {
     CustomLog *log;
 
     for (log = logs; log; log = log-&gt;next) {
         storeAppendPrintf(entry, &quot;%s &quot;, name);
 
         switch (log-&gt;type) {
 
         case Log::Format::CLF_CUSTOM:
-            storeAppendPrintf(entry, &quot;%s %s&quot;, log-&gt;filename, log-&gt;logFormat-&gt;name);
+            storeAppendPrintf(entry, &quot;%s logformat=%s&quot;, log-&gt;filename, log-&gt;logFormat-&gt;name);
             break;
 
         case Log::Format::CLF_NONE:
-            storeAppendPrintf(entry, &quot;none&quot;);
+            storeAppendPrintf(entry, &quot;logformat=none&quot;);
             break;
 
         case Log::Format::CLF_SQUID:
-            storeAppendPrintf(entry, &quot;%s squid&quot;, log-&gt;filename);
+            storeAppendPrintf(entry, &quot;%s logformat=squid&quot;, log-&gt;filename);
             break;
 
         case Log::Format::CLF_COMBINED:
-            storeAppendPrintf(entry, &quot;%s combined&quot;, log-&gt;filename);
+            storeAppendPrintf(entry, &quot;%s logformat=combined&quot;, log-&gt;filename);
             break;
 
         case Log::Format::CLF_COMMON:
-            storeAppendPrintf(entry, &quot;%s common&quot;, log-&gt;filename);
+            storeAppendPrintf(entry, &quot;%s logformat=common&quot;, log-&gt;filename);
             break;
 
 #if ICAP_CLIENT
         case Log::Format::CLF_ICAP_SQUID:
-            storeAppendPrintf(entry, &quot;%s icap_squid&quot;, log-&gt;filename);
+            storeAppendPrintf(entry, &quot;%s logformat=icap_squid&quot;, log-&gt;filename);
             break;
 #endif
         case Log::Format::CLF_USERAGENT:
-            storeAppendPrintf(entry, &quot;%s useragent&quot;, log-&gt;filename);
+            storeAppendPrintf(entry, &quot;%s logformat=useragent&quot;, log-&gt;filename);
             break;
 
         case Log::Format::CLF_REFERER:
-            storeAppendPrintf(entry, &quot;%s referrer&quot;, log-&gt;filename);
+            storeAppendPrintf(entry, &quot;%s logformat=referrer&quot;, log-&gt;filename);
             break;
 
         case Log::Format::CLF_UNKNOWN:
             break;
         }
 
+        // default is on-error=die
+        if (!log-&gt;fatal)
+            storeAppendPrintf(entry, &quot; on-error=drop&quot;);
+
+        // default: 64KB
+        if (log-&gt;bufferSize != 64*1024)
+            storeAppendPrintf(entry, &quot; buffer-size=%d&quot;, log-&gt;bufferSize);
+
+        if (log-&gt;rotateCount &gt;= 0)
+            storeAppendPrintf(entry, &quot; rotate=%d&quot;, log-&gt;rotateCount);
+
         if (log-&gt;aclList)
             dump_acl_list(entry, log-&gt;aclList);
 
         storeAppendPrintf(entry, &quot;\n&quot;);
     }
 }
 
 static void
 free_access_log(CustomLog ** definitions)
 {
     while (*definitions) {
         CustomLog *log = *definitions;
         *definitions = log-&gt;next;
 
         log-&gt;logFormat = NULL;
         log-&gt;type = Log::Format::CLF_UNKNOWN;
 
         if (log-&gt;aclList)
             aclDestroyAclList(&amp;log-&gt;aclList);
 

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2014-12-24 09:20:52 +0000
+++ src/cf.data.pre	2014-12-29 05:37:59 +0000
@@ -4208,40 +4208,49 @@
 	logformat=name		Names log line format (either built-in or
 				defined by a logformat directive). Defaults
 				to 'squid'.
 
 	buffer-size=64KB	Defines approximate buffering limit for log
 				records (see buffered_logs).  Squid should not
 				keep more than the specified size and, hence,
 				should flush records before the buffer becomes
 				full to avoid overflows under normal
 				conditions (the exact flushing algorithm is
 				module-dependent though).  The on-error option
 				controls overflow handling.
 
 	on-error=die|drop	Defines action on unrecoverable errors. The
 				'drop' action ignores (i.e., does not log)
 				affected log records. The default 'die' action
 				kills the affected worker. The drop action 
 				support has not been tested for modules other
 				than tcp.
 
+	rotate=N		Specifies the number of log file rotations to
+				make when you run 'squid -k rotate'. The default
+				is to obey the logfile_rotate diretive. Setting
+				rotate=0 will disable the file name rotation,
+				but the log files are still closed and re-opened.
+				This will enable you to rename the logfiles
+				yourself just before sending the rotate signal.
+				Only supported by the stdio module.
+
 	===== Modules Currently available =====
 	
 	none	Do not log any requests matching these ACL.
 		Do not specify Place or logformat name.
 	
 	stdio	Write each log line to disk immediately at the completion of
 		each request.
 		Place: the filename and path to be written.
 	
 	daemon	Very similar to stdio. But instead of writing to disk the log
 		line is passed to a daemon helper for asychronous handling instead.
 		Place: varies depending on the daemon.
 		
 		log_file_daemon Place: the file name and path to be written.
 	
 	syslog	To log each request via syslog facility.
 		Place: The syslog facility and priority level for these entries.
 		Place Format:  facility.priority
 
 		where facility could be any of:
@@ -4428,56 +4437,61 @@
 	these swap logs will have names such as:
 
 		cache_swap_log.00
 		cache_swap_log.01
 		cache_swap_log.02
 
 	The numbered extension (which is added automatically)
 	corresponds to the order of the 'cache_dir' lines in this
 	configuration file.  If you change the order of the 'cache_dir'
 	lines in this file, these index files will NOT correspond to
 	the correct 'cache_dir' entry (unless you manually rename
 	them).  We recommend you do NOT use this option.  It is
 	better to keep these index files in each 'cache_dir' directory.
 DOC_END
 
 NAME: logfile_rotate
 TYPE: int
 DEFAULT: 10
 LOC: Config.Log.rotateNumber
 DOC_START
-	Specifies the number of logfile rotations to make when you
+	Specifies the default number of logfile rotations to make when you
 	type 'squid -k rotate'. The default is 10, which will rotate
 	with extensions 0 through 9. Setting logfile_rotate to 0 will
 	disable the file name rotation, but the logfiles are still closed
 	and re-opened. This will enable you to rename the logfiles
 	yourself just before sending the rotate signal.
 
+	Note, from Squid-3.1 this option is only a default for cache.log,
+	that log can be rotated separately by using debug_options.
+
+	Note, from Squid-3.6 this option is only a default for access.log
+	recrded by stdio: module. Those logs can be rotated separately by
+	using the rotate=N option on their access_log directive.
+
 	Note, the 'squid -k rotate' command normally sends a USR1
 	signal to the running squid process.  In certain situations
 	(e.g. on Linux with Async I/O), USR1 is used for other
 	purposes, so -k rotate uses another signal.  It is best to get
 	in the habit of using 'squid -k rotate' instead of 'kill -USR1
 	&lt;pid&gt;'.
 
-	Note, from Squid-3.1 this option is only a default for cache.log,
-	that log can be rotated separately by using debug_options.
 DOC_END
 
 NAME: mime_table
 TYPE: string
 DEFAULT: @DEFAULT_MIME_TABLE@
 LOC: Config.mimeTablePathname
 DOC_START
 	Path to Squid's icon configuration file.
 
 	You shouldn't need to change this, but the default file contains
 	examples and formatting information if you do.
 DOC_END
 
 NAME: log_mime_hdrs
 COMMENT: on|off
 TYPE: onoff
 LOC: Config.onoff.log_mime_hdrs
 DEFAULT: off
 DOC_START
 	The Cache can record both the request and the response MIME

=== modified file 'src/log/CustomLog.h'
--- src/log/CustomLog.h	2014-12-20 12:12:02 +0000
+++ src/log/CustomLog.h	2014-12-29 01:45:14 +0000
@@ -2,38 +2,40 @@
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_CUSTOMLOG_H_
 #define SQUID_CUSTOMLOG_H_
 
 //#include &quot;format/Format.h&quot;
 #include &quot;acl/forward.h&quot;
 #include &quot;log/Formats.h&quot;
 
 class Logfile;
 namespace Format
 {
 class Format;
 }
 
-/// representaiton of a custom log directive. Currently a POD.
+/// representation of a custom log directive.
 class CustomLog
 {
 public:
     char *filename;
     ACLList *aclList;
     Format::Format *logFormat;
     Logfile *logfile;
     CustomLog *next;
     Log::Format::log_type type;
     /// how much to buffer before dropping or dying (access_log buffer-size)
     size_t bufferSize;
     /// whether unrecoverable errors (e.g., dropping a log record) kill worker
     bool fatal;
+    /// How many log files to retain when rotating. Default: obey logfile_rotate
+    int16_t rotateCount;
 };
 
 #endif /* SQUID_CUSTOMLOG_H_ */
 

=== modified file 'src/log/File.cc'
--- src/log/File.cc	2014-12-20 12:12:02 +0000
+++ src/log/File.cc	2014-12-29 02:34:49 +0000
@@ -67,44 +67,44 @@
     assert(lf-&gt;data != NULL);
 
     if (fatal_flag)
         lf-&gt;flags.fatal = 1;
 
     lf-&gt;sequence_number = 0;
 
     return lf;
 }
 
 void
 logfileClose(Logfile * lf)
 {
     debugs(50, DBG_IMPORTANT, &quot;Logfile: closing log &quot; &lt;&lt; lf-&gt;path);
     lf-&gt;f_flush(lf);
     lf-&gt;f_close(lf);
     cbdataFree(lf);
 }
 
 void
-logfileRotate(Logfile * lf)
+logfileRotate(Logfile * lf, int16_t rotateCount)
 {
     debugs(50, DBG_IMPORTANT, &quot;logfileRotate: &quot; &lt;&lt; lf-&gt;path);
-    lf-&gt;f_rotate(lf);
+    lf-&gt;f_rotate(lf, rotateCount);
 }
 
 void
 logfileWrite(Logfile * lf, char *buf, size_t len)
 {
     lf-&gt;f_linewrite(lf, buf, len);
 }
 
 void
 logfilePrintf(Logfile * lf, const char *fmt,...)
 {
     va_list args;
     char buf[8192];
     int s;
 
     va_start(args, fmt);
 
     s = vsnprintf(buf, 8192, fmt, args);
 
     if (s &gt; 8192) {

=== modified file 'src/log/File.h'
--- src/log/File.h	2014-12-20 12:12:02 +0000
+++ src/log/File.h	2014-12-29 02:47:39 +0000
@@ -14,58 +14,58 @@
 #if HAVE_SYS_PARAM_H
 #include &lt;sys/param.h&gt;
 #endif
 
 class logfile_buffer_t
 {
 public:
     char *buf;
     int size;
     int len;
     int written_len;
     dlink_node node;
 };
 
 class Logfile;
 
 typedef void LOGLINESTART(Logfile *);
 typedef void LOGWRITE(Logfile *, const char *, size_t len);
 typedef void LOGLINEEND(Logfile *);
 typedef void LOGFLUSH(Logfile *);
-typedef void LOGROTATE(Logfile *);
+typedef void LOGROTATE(Logfile *, const int16_t);
 typedef void LOGCLOSE(Logfile *);
 
 class Logfile
 {
 
 public:
     char path[MAXPATHLEN];
 
     struct {
         unsigned int fatal;
     } flags;
 
     int64_t sequence_number;  ///&lt; Unique sequence number per log line.
 
 public:
     void *data;
 
     LOGLINESTART *f_linestart;
     LOGWRITE *f_linewrite;
     LOGLINEEND *f_lineend;
     LOGFLUSH *f_flush;
     LOGROTATE *f_rotate;
     LOGCLOSE *f_close;
 };
 
 /* Legacy API */
 Logfile *logfileOpen(const char *path, size_t bufsz, int);
 void logfileClose(Logfile * lf);
-void logfileRotate(Logfile * lf);
+void logfileRotate(Logfile * lf, int16_t rotateCount);
 void logfileWrite(Logfile * lf, char *buf, size_t len);
 void logfileFlush(Logfile * lf);
 void logfilePrintf(Logfile * lf, const char *fmt,...) PRINTF_FORMAT_ARG2;
 void logfileLineStart(Logfile * lf);
 void logfileLineEnd(Logfile * lf);
 
 #endif /* SQUID_SRC_LOG_FILE_H */
 

=== modified file 'src/log/ModDaemon.cc'
--- src/log/ModDaemon.cc	2014-12-20 12:12:02 +0000
+++ src/log/ModDaemon.cc	2014-12-29 02:38:40 +0000
@@ -252,41 +252,41 @@
 static void
 logfile_mod_daemon_close(Logfile * lf)
 {
     l_daemon_t *ll = static_cast&lt;l_daemon_t *&gt;(lf-&gt;data);
     debugs(50, DBG_IMPORTANT, &quot;Logfile Daemon: closing log &quot; &lt;&lt; lf-&gt;path);
     logfileFlush(lf);
     if (ll-&gt;rfd == ll-&gt;wfd)
         comm_close(ll-&gt;rfd);
     else {
         comm_close(ll-&gt;rfd);
         comm_close(ll-&gt;wfd);
     }
     kill(ll-&gt;pid, SIGTERM);
     eventDelete(logfileFlushEvent, lf);
     xfree(ll);
     lf-&gt;data = NULL;
     cbdataInternalUnlock(lf); // WTF??
 }
 
 static void
-logfile_mod_daemon_rotate(Logfile * lf)
+logfile_mod_daemon_rotate(Logfile * lf, const int16_t)
 {
     char tb[3];
     debugs(50, DBG_IMPORTANT, &quot;logfileRotate: &quot; &lt;&lt; lf-&gt;path);
     tb[0] = 'R';
     tb[1] = '\n';
     tb[2] = '\0';
     logfile_mod_daemon_append(lf, tb, 2);
 }
 
 /*
  * This routine assumes that up to one line is written. Don't try to
  * call this routine with more than one line or subsequent lines
  * won't be prefixed with the command type and confuse the logging
  * daemon somewhat.
  */
 static void
 logfile_mod_daemon_writeline(Logfile * lf, const char *buf, size_t len)
 {
     l_daemon_t *ll = static_cast&lt;l_daemon_t *&gt;(lf-&gt;data);
     /* Make sure the logfile buffer isn't too large */

=== modified file 'src/log/ModStdio.cc'
--- src/log/ModStdio.cc	2014-12-20 12:12:02 +0000
+++ src/log/ModStdio.cc	2014-12-29 02:58:02 +0000
@@ -81,79 +81,78 @@
 {
 }
 
 static void
 logfile_mod_stdio_lineend(Logfile * lf)
 {
     lf-&gt;f_flush(lf);
 }
 
 static void
 logfile_mod_stdio_flush(Logfile * lf)
 {
     l_stdio_t *ll = (l_stdio_t *) lf-&gt;data;
     if (0 == ll-&gt;offset)
         return;
     logfileWriteWrapper(lf, ll-&gt;buf, (size_t) ll-&gt;offset);
     ll-&gt;offset = 0;
 }
 
 static void
-logfile_mod_stdio_rotate(Logfile * lf)
+logfile_mod_stdio_rotate(Logfile * lf, const int16_t nRotate)
 {
 #ifdef S_ISREG
 
     struct stat sb;
 #endif
 
-    int i;
     char from[MAXPATHLEN];
     char to[MAXPATHLEN];
     l_stdio_t *ll = (l_stdio_t *) lf-&gt;data;
     assert(lf-&gt;path);
     const char *realpath = lf-&gt;path+6; // skip 'stdio:' prefix.
     assert(realpath);
 
 #ifdef S_ISREG
 
     if (stat(realpath, &amp;sb) == 0)
         if (S_ISREG(sb.st_mode) == 0)
             return;
 
 #endif
 
     debugs(0, DBG_IMPORTANT, &quot;Rotate log file &quot; &lt;&lt; lf-&gt;path);
 
     /* Rotate numbers 0 through N up one */
-    for (i = Config.Log.rotateNumber; i &gt; 1;) {
+    for (int16_t i = nRotate; i &gt; 1;) {
         --i;
         snprintf(from, MAXPATHLEN, &quot;%s.%d&quot;, realpath, i - 1);
         snprintf(to, MAXPATHLEN, &quot;%s.%d&quot;, realpath, i);
         xrename(from, to);
     }
 
     /* Rotate the current log to .0 */
     logfileFlush(lf);
 
     file_close(ll-&gt;fd);     /* always close */
 
-    if (Config.Log.rotateNumber &gt; 0) {
+    if (nRotate &gt; 0) {
         snprintf(to, MAXPATHLEN, &quot;%s.%d&quot;, realpath, 0);
         xrename(realpath, to);
     }
     /* Reopen the log.  It may have been renamed &quot;manually&quot; */
     ll-&gt;fd = file_open(realpath, O_WRONLY | O_CREAT | O_TEXT);
 
     if (DISK_ERROR == ll-&gt;fd &amp;&amp; lf-&gt;flags.fatal) {
         debugs(50, DBG_CRITICAL, &quot;ERROR: logfileRotate: &quot; &lt;&lt; lf-&gt;path &lt;&lt; &quot;: &quot; &lt;&lt; xstrerror());
         fatalf(&quot;Cannot open %s: %s&quot;, lf-&gt;path, xstrerror());
     }
 }
 
 static void
 logfile_mod_stdio_close(Logfile * lf)
 {
     l_stdio_t *ll = (l_stdio_t *) lf-&gt;data;
     lf-&gt;f_flush(lf);
 
     if (ll-&gt;fd &gt;= 0)
         file_close(ll-&gt;fd);

=== modified file 'src/log/ModSyslog.cc'
--- src/log/ModSyslog.cc	2014-12-20 12:12:02 +0000
+++ src/log/ModSyslog.cc	2014-12-29 02:39:00 +0000
@@ -103,41 +103,41 @@
     l_syslog_t *ll = (l_syslog_t *) lf-&gt;data;
     syslog(ll-&gt;syslog_priority, &quot;%s&quot;, (char *) buf);
 }
 
 static void
 logfile_mod_syslog_linestart(Logfile * lf)
 {
 }
 
 static void
 logfile_mod_syslog_lineend(Logfile * lf)
 {
 }
 
 static void
 logfile_mod_syslog_flush(Logfile * lf)
 {
 }
 
 static void
-logfile_mod_syslog_rotate(Logfile * lf)
+logfile_mod_syslog_rotate(Logfile *, const int16_t)
 {
 }
 
 static void
 logfile_mod_syslog_close(Logfile * lf)
 {
     xfree(lf-&gt;data);
     lf-&gt;data = NULL;
 }
 
 /*
  * This code expects the path to be syslog:&lt;priority&gt;
  */
 int
 logfile_mod_syslog_open(Logfile * lf, const char *path, size_t bufsz, int fatal_flag)
 {
     lf-&gt;f_close = logfile_mod_syslog_close;
     lf-&gt;f_linewrite = logfile_mod_syslog_writeline;
     lf-&gt;f_linestart = logfile_mod_syslog_linestart;
     lf-&gt;f_lineend = logfile_mod_syslog_lineend;

=== modified file 'src/log/ModUdp.cc'
--- src/log/ModUdp.cc	2014-12-20 12:12:02 +0000
+++ src/log/ModUdp.cc	2014-12-29 02:39:16 +0000
@@ -87,43 +87,42 @@
     memcpy(ll-&gt;buf + ll-&gt;offset, buf, len);
 
     ll-&gt;offset += len;
 
     assert(ll-&gt;offset &gt;= 0);
 
     assert((size_t) ll-&gt;offset &lt;= ll-&gt;bufsz);
 }
 
 static void
 logfile_mod_udp_linestart(Logfile * lf)
 {
 }
 
 static void
 logfile_mod_udp_lineend(Logfile * lf)
 {
 }
 
 static void
-logfile_mod_udp_rotate(Logfile * lf)
+logfile_mod_udp_rotate(Logfile *, const int16_t)
 {
-    return;
 }
 
 static void
 logfile_mod_udp_close(Logfile * lf)
 {
     l_udp_t *ll = (l_udp_t *) lf-&gt;data;
     lf-&gt;f_flush(lf);
 
     if (ll-&gt;fd &gt;= 0)
         file_close(ll-&gt;fd);
 
     if (ll-&gt;buf)
         xfree(ll-&gt;buf);
 
     xfree(lf-&gt;data);
     lf-&gt;data = NULL;
 }
 
 /*
  * This code expects the path to be //host:port

=== modified file 'src/log/TcpLogger.cc'
--- src/log/TcpLogger.cc	2014-12-20 12:12:02 +0000
+++ src/log/TcpLogger.cc	2014-12-29 02:39:38 +0000
@@ -406,41 +406,41 @@
 void
 Log::TcpLogger::WriteLine(Logfile * lf, const char *buf, size_t len)
 {
     if (TcpLogger *logger = StillLogging(lf))
         logger-&gt;logRecord(buf, len);
 }
 
 void
 Log::TcpLogger::StartLine(Logfile * lf)
 {
 }
 
 void
 Log::TcpLogger::EndLine(Logfile * lf)
 {
     if (!Config.onoff.buffered_logs)
         Flush(lf);
 }
 
 void
-Log::TcpLogger::Rotate(Logfile * lf)
+Log::TcpLogger::Rotate(Logfile *, const int16_t)
 {
 }
 
 void
 Log::TcpLogger::Close(Logfile * lf)
 {
     if (TcpLogger *logger = StillLogging(lf)) {
         debugs(50, 3, &quot;Closing &quot; &lt;&lt; logger);
         typedef NullaryMemFunT&lt;TcpLogger&gt; Dialer;
         Dialer dialer(logger, &amp;Log::TcpLogger::endGracefully);
         AsyncCall::Pointer call = asyncCall(50, 3, &quot;Log::TcpLogger::endGracefully&quot;, dialer);
         ScheduleCallHere(call);
     }
     delete static_cast&lt;Pointer*&gt;(lf-&gt;data);
     lf-&gt;data = NULL;
 }
 
 /*
  * This code expects the path to be //host:port
  */

=== modified file 'src/log/TcpLogger.h'
--- src/log/TcpLogger.h	2014-12-20 12:12:02 +0000
+++ src/log/TcpLogger.h	2014-12-29 02:59:37 +0000
@@ -44,41 +44,41 @@
     /// will result in [eventual] job termination.
     void endGracefully();
 
     /// buffers record and possibly writes it to the remote logger
     void logRecord(const char *buf, size_t len);
 
     /// write all currently buffered records ASAP
     void flush();
 
     /* AsyncJob API */
     virtual void start();
     virtual bool doneAll() const;
     virtual void swanSong();
 
 private:
     /* Logfile API. Map c-style Logfile calls to TcpLogger method calls. */
     static void Flush(Logfile *lf);
     static void WriteLine(Logfile *lf, const char *buf, size_t len);
     static void StartLine(Logfile *lf);
     static void EndLine(Logfile *lf);
-    static void Rotate(Logfile *lf);
+    static void Rotate(Logfile *lf, const int16_t);
     static void Close(Logfile *lf);
 
     static TcpLogger *StillLogging(Logfile *lf);
 
     static void DelayedReconnect(void *data);
     void delayedReconnect();
 
     bool canFit(const size_t len) const;
     void appendRecord(const char *buf, size_t len);
     void appendChunk(const char *chunk, const size_t len);
     void writeIfNeeded();
     void writeIfPossible();
     void doConnect();
     void disconnect();
 
     /* comm callbacks */
     void connectDone(const CommConnectCbParams &amp;conn);
     void writeDone(const CommIoCbParams &amp;io);
     void handleClosure(const CommCloseCbParams &amp;io);
 

=== modified file 'src/log/access_log.cc'
--- src/log/access_log.cc	2014-12-20 12:12:02 +0000
+++ src/log/access_log.cc	2014-12-29 02:37:18 +0000
@@ -177,47 +177,48 @@
 
         comm_udp_sendto(mcast_miss_fd,
                         &amp;mcast_miss_to, sizeof(mcast_miss_to),
                         ibuf, isize * sizeof(int));
     }
 
 #endif
 }
 
 void
 accessLogRotate(void)
 {
     CustomLog *log;
 #if USE_FORW_VIA_DB
 
     fvdbClear();
 #endif
 
     for (log = Config.Log.accesslogs; log; log = log-&gt;next) {
         if (log-&gt;logfile) {
-            logfileRotate(log-&gt;logfile);
+            int16_t rc = (log-&gt;rotateCount &gt;= 0 ? log-&gt;rotateCount : Config.Log.rotateNumber);
+            logfileRotate(log-&gt;logfile, rc);
         }
     }
 
 #if HEADERS_LOG
 
-    logfileRotate(headerslog);
+    logfileRotate(headerslog, Config.Log.rotateNumber);
 
 #endif
 }
 
 void
 accessLogClose(void)
 {
     CustomLog *log;
 
     for (log = Config.Log.accesslogs; log; log = log-&gt;next) {
         if (log-&gt;logfile) {
             logfileClose(log-&gt;logfile);
             log-&gt;logfile = NULL;
         }
     }
 
 #if HEADERS_LOG
 
     logfileClose(headerslog);
 

=== modified file 'src/store_log.cc'
--- src/store_log.cc	2014-12-20 12:12:02 +0000
+++ src/store_log.cc	2014-12-29 02:36:59 +0000
@@ -78,41 +78,41 @@
     } else {
         /* no mem object. Most RELEASE cases */
         logfileLineStart(storelog);
         logfilePrintf(storelog, &quot;%9d.%03d %-7s %02d %08X %s   ?         ?         ?         ? ?/? ?/? ? ?\n&quot;,
                       (int) current_time.tv_sec,
                       (int) current_time.tv_usec / 1000,
                       storeLogTags[tag],
                       e-&gt;swap_dirn,
                       e-&gt;swap_filen,
                       e-&gt;getMD5Text());
         logfileLineEnd(storelog);
     }
 }
 
 void
 storeLogRotate(void)
 {
     if (NULL == storelog)
         return;
 
-    logfileRotate(storelog);
+    logfileRotate(storelog, Config.Log.rotateNumber);
 }
 
 void
 storeLogClose(void)
 {
     if (NULL == storelog)
         return;
 
     logfileClose(storelog);
 
     storelog = NULL;
 }
 
 static void
 storeLogRegisterWithCacheManager(void)
 {
     Mgr::RegisterAction(&quot;store_log_tags&quot;, &quot;Histogram of store.log tags&quot;,
                         storeLogTagsHist, 0, 1);
 }
 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: accesslog_rotateN_mk1.patch.sig
Type: application/octet-stream
Size: 287 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20141230/16aad44e/attachment-0001.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20141230/16aad44e/attachment-0001.obj</A>&gt;
</PRE>























































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000842.html">[squid-dev] I was wondering about session\connection ID.
</A></li>
	<LI>Next message: <A HREF="000844.html">[squid-dev] Build failed in Jenkins: 3.HEAD-amd64-centos-7 #247
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#843">[ date ]</a>
              <a href="thread.html#843">[ thread ]</a>
              <a href="subject.html#843">[ subject ]</a>
              <a href="author.html#843">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
