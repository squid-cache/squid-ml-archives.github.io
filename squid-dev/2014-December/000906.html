<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Non-HTTP bypass
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54A2EF60.802%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000894.html">
   <LINK REL="Next"  HREF="000914.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Non-HTTP bypass</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54A2EF60.802%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Non-HTTP bypass">rousskov at measurement-factory.com
       </A><BR>
    <I>Tue Dec 30 18:30:56 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000894.html">[squid-dev] Jenkins build is back to normal :	3.HEAD-amd64-fedora-21-clang #18
</A></li>
        <LI>Next message: <A HREF="000914.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#906">[ date ]</a>
              <a href="thread.html#906">[ thread ]</a>
              <a href="subject.html#906">[ subject ]</a>
              <a href="author.html#906">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/21/2014 11:29 AM, Tsantilas Christos wrote:
&gt;&gt;&gt;<i>    - Adds &quot;on_first_request_error&quot;, a new ACL-driven squid.conf
</I>&gt;&gt;&gt;<i> directive
</I>&gt;&gt;&gt;<i> that can be used to establish a blind TCP tunnel which relays all bytes
</I>&gt;&gt;&gt;<i> from/to the intercepted connection to/from the intended destination
</I>&gt;&gt;&gt;<i> address. See the sketch above.
</I>&gt;&gt;&gt;<i> The on_first_request_error directive supports fast ACLs only.
</I>
&gt;&gt;<i> What a nasty name for an access list.
</I>
Please try to be more specific, especially when you are being negative
about others work. &quot;Nasty&quot; can mean many things to many people. In this
particular case, your comment carries no [positive] value at all. It is
difficult for the code author to make something &quot;less nasty&quot; because
they do not know what &quot;nasty&quot; means to you in this context.

BTW, on_first_request_error does not name an access list.


&gt;&gt;<i> I believe tcp_tunnel or tunnel_transparent would be more descriptive of
</I>&gt;&gt;<i> the test is *checking* for.
</I>
* If we want to tell Squid when to tunnel, then tcp_tunnel is a good
solution (but this is not what this proposal tries to do).

* If we want to tell Squid what to do with connections it does not
recognize, then tcp_tunnel is the worst alternative of the three I can
think of (see below for details).


The &quot;tcp_tunnel&quot; idea currently lacks context: Is it applied when we
accept a connection, when we authenticate the user, when we parse 10th
request, etc.? There are many very different cases where we may want to
start tunneling, for many different reasons. This lack of specifics
makes the idea look simple and, hence, appealing, but the devil is
usually revealed in the details.

The implemented &quot;on_first_request_error&quot; feature is much smaller and has
relatively narrow context: When Squid realizes that it does not
recognize the connection, it consults the proposed directive for
instructions. The &quot;on_error&quot; concept is not new in IT and should be
familiar to many admins.


The suggested feature can be converted into a tcp_tunnel feature if:

* we add a hard-coded first_request_error ACL

* agree that tcp_tunnel rules are evaluated when Squid realizes that it
does not recognize the first request on a connection (at least).

Then, instead of writing:

  on_first_request_error tunnel some
  on_first_request_error respond other
  on_first_request_error future_action yet_another

folks will write:

  tcp_tunnel on_first_request_error some
  respond_with_error on_first_request_error other
  future_action on_first_request_error yet_another

which is clearly (I hope!) worse from configuration clarity and
convenience point of view. However, folks would also be able to write:

  tcp_tunnel some_other_error some
  respond_with_error some_other_place other
  future_action some_other_category yet_another

which is an improvement over the more rigid on_first_request_error
scheme that restricts application to only certain kinds of errors in
certain places.


The design space can be summarized like this:

  # extreme left: general-purpose on-error handling:
  on_error &lt;action&gt; error_kind_acl acl ...

  # proposed feature: unrecognized connection handling;
  # the error_kind_acl is implicit in this design:
  on_first_request_error &lt;action&gt; acl ...

  # suggested extreme right: general-purpose actions:
  tcp_tunnel error_detection_acl acl ...
  ssl_tunnel error_detection_acl acl ...
  respond_with_error error_detection_acl acl ...
  terminate error_detection_acl acl ...


Since many Squid actions are likely to be appropriate under the same
conditions (tunnel, respond with an error, terminate, ssl-tunnel, etc.)
I do not think the suggested extreme is the best design. We should
either move left to the general on_error configuration or stay with the
proposal currently under review.


&gt;&gt;<i> The &quot;only checked on first request failure&quot; detail can be left in the
</I>&gt;&gt;<i> directive documentation.
</I>
It would be wrong to provide a general-looking &quot;tcp_tunnel&quot; option that
can only be applied in one specific case. The initial implementation may
be restricted to one case, of course, but a general feature needs enough
knobs to be usable in many contexts. In this case, this means a group of
hard-coded ACL guards that only match in some specific supported
contexts (see above for examples). At the end of your email, you have
already identified an error-unrelated case where the tcp_tunnel
directive would be required...


&gt;&gt;<i> I also suspect that is a false statement since
</I>&gt;&gt;<i> anything we do with a CONNECT body that fails will need a matching check
</I>&gt;&gt;<i> applied.
</I>
Not sure what you mean here, but please note that the first request
inside a bumped CONNECT tunnel is still the first request as far as the
proposed feature is concerned.

To avoid misunderstanding, I am not saying that on_first_request_error
name or its description is perfect. Better alternatives are more than
welcome (and similar names/descriptions would be needed even if we move
towards a more general on_error design)!


&gt;&gt;<i> ssl-bump calls its version of tunnelling &quot;ssl_bump splice&quot;. So if we are
</I>&gt;&gt;<i> continuing with the splice vs tunnel terminology the syntax would look
</I>&gt;&gt;<i> something like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   tcp_tunnel deny localhost
</I>&gt;&gt;<i>   tcp_tunnel splice all
</I>

This does not work because &quot;deny&quot; does not tell the admin what is going
to happen and if you replace &quot;deny&quot; with more specific &quot;respond&quot; or
&quot;serve_error&quot;, then the tcp_tunnel name becomes inappropriate (those
actions are not about tunneling at all!). To make this work, you have to
add more actions (see above for more examples):

    respond_with_error localhost
    tcp_tunnel !localhost

which is an inferior (IMO) alternative as detailed above.


&gt;&gt;<i> After this change goes in there will undoubtedly be requests to extend
</I>&gt;&gt;<i> it so that we do not waste time waiting for a parse error and just allow
</I>&gt;&gt;<i> a transparent port to tunnel selected connections right from accept().
</I>&gt;&gt;<i> So lets be prepared for that with the right naming and scope from the
</I>&gt;&gt;<i> start.
</I>
I agree that the proposed feature does not address all expected needs,
but I do not think tcp_tunnel (or any single directive!) can address all
those needs. Error handling should be separated from primary actions.
Whether we add more primary actions or not, is a separate issue.


&gt;<i> The tcp_tunnel is not a bad name.
</I>&gt;<i> Lets see if Alex has a different opinion on see...
</I>
tcp_tunnel is a good name, but not for the problem we are trying to
solve. I suspect we will eventually add a &quot;tunnel tcp&quot; or &quot;tcp_tunnel&quot;
directive, which will be applied at certain processing points. However,
we would still benefit from an on_error directive, before and after
tcp_tunnel is added.


Amos, if on_first_request_error is converted into on_error with a
first_request (or similar) ACL, would you continue to block this
frequently-requested bypass feature?


Thank you,

Alex.

</PRE>


























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000894.html">[squid-dev] Jenkins build is back to normal :	3.HEAD-amd64-fedora-21-clang #18
</A></li>
	<LI>Next message: <A HREF="000914.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#906">[ date ]</a>
              <a href="thread.html#906">[ thread ]</a>
              <a href="subject.html#906">[ subject ]</a>
              <a href="author.html#906">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
