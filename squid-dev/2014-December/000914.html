<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Non-HTTP bypass
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54A34F2F.40406%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000906.html">
   <LINK REL="Next"  HREF="000933.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Non-HTTP bypass</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54A34F2F.40406%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Non-HTTP bypass">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Dec 31 01:19:43 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000906.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
        <LI>Next message: <A HREF="000933.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#914">[ date ]</a>
              <a href="thread.html#914">[ thread ]</a>
              <a href="subject.html#914">[ subject ]</a>
              <a href="author.html#914">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 31/12/2014 7:30 a.m., Alex Rousskov wrote:
&gt;<i> On 10/21/2014 11:29 AM, Tsantilas Christos wrote:
</I>&gt;&gt;&gt;&gt;<i> - Adds &quot;on_first_request_error&quot;, a new ACL-driven squid.conf 
</I>&gt;&gt;&gt;&gt;<i> directive that can be used to establish a blind TCP tunnel
</I>&gt;&gt;&gt;&gt;<i> which relays all bytes from/to the intercepted connection
</I>&gt;&gt;&gt;&gt;<i> to/from the intended destination address. See the sketch
</I>&gt;&gt;&gt;&gt;<i> above. The on_first_request_error directive supports fast
</I>&gt;&gt;&gt;&gt;<i> ACLs only.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> What a nasty name for an access list.
</I>&gt;<i> 
</I>&gt;<i> Please try to be more specific, especially when you are being
</I>&gt;<i> negative about others work. &quot;Nasty&quot; can mean many things to many
</I>&gt;<i> people. In this particular case, your comment carries no [positive]
</I>&gt;<i> value at all. It is difficult for the code author to make something
</I>&gt;<i> &quot;less nasty&quot; because they do not know what &quot;nasty&quot; means to you in
</I>&gt;<i> this context.
</I>
nasty - horrible, mean (but not cruel), very annoying.

Henrik and I had a discussion about directive naming years back and
decided that long and &quot;nasty&quot; names like this should be reserved for
directives that we really, really did not want people using but there
was actually a rare use case for. Emphasis being on rare and not
using. The length and horribleness of the name helping to discourage
use, not documenting being another.

IMO this directive needs to be friendly and clear as its going to be
somewhat popular.

&gt;<i> 
</I>&gt;<i> BTW, on_first_request_error does not name an access list.
</I>&gt;<i> 
</I>
By access list I mean a multi-line directive, whose line ordering is
meaningful, using the syntax:

  directive_name action acl [acl ...]

Christos configuration sketch:
&quot;
   # tunnel if we think the client waits for the server to talk first:
   on_first_request_error tunnel serverTalksFirstProtocol

   # in all other error cases, just send an HTTP &quot;error page&quot; response:
   on_first_request_error respond all
&quot;

The name reads like the value is a one-liner / event handler. i.e. an
action without ACL list. Like we have one-liner directives
&quot;error_directory /foo/&quot;, &quot;enable_icmp on/off&quot;, etc.

The &quot;on_error&quot; as you say is already fairly well known. In particular
its known as an event handler hook in JavaScript and other languages.
Like I said above squid.conf is more a declarative language than those.

So in detail:

1) &quot;on_&quot; - all directives in Squid.conf are essentially declarative
and access control could almost all be prefixed with &quot;on_&quot;. This adds
no value but makes the directive longer and harder to write.

2) &quot;first_request_error&quot; as a declarative statement - implies the
value *is* the error to be supplied on first request. It is actually
declaring an action to perform *instead* of producing errors ... and
the ACL tests to determine that action.

3) due to legacy Squid being HTTP-oriented the directives we have
without explicit component names (http_, ftp_, dns_, ssl_, icp_htcp_,
wccp_ etc) are implying http_ relevance.
 This directive is not relevant to HTTP, but to SSL/TLS. So something
like ssl_ or tls_ or tcp_ is more appropriate.

4) is that &quot;error on first request&quot;, or &quot;first request with errors&quot;?
the name is not clear.

Coming back to this now (and accepting your scope narrowing from tcp_
to ssl_) we should probably call this ssl_unknown_protocol. Since
anything on port 443 which is syntactically HTTP but has some
invalidity is rightfully responded with an error, no need to ask the
admin at that point.


PS. can we please agree to start using tls_ instead of ssl_? even
SSLv3 is a dead duck now and everybody knows it. At least on new
directives.

&gt;<i> 
</I>&gt;&gt;&gt;<i> I believe tcp_tunnel or tunnel_transparent would be more
</I>&gt;&gt;&gt;<i> descriptive of the test is *checking* for.
</I>&gt;<i> 
</I>&gt;<i> * If we want to tell Squid when to tunnel, then tcp_tunnel is a
</I>&gt;<i> good solution (but this is not what this proposal tries to do).
</I>&gt;<i> 
</I>&gt;<i> * If we want to tell Squid what to do with connections it does not 
</I>&gt;<i> recognize, then tcp_tunnel is the worst alternative of the three I
</I>&gt;<i> can think of (see below for details).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The &quot;tcp_tunnel&quot; idea currently lacks context: Is it applied when
</I>&gt;<i> we accept a connection, when we authenticate the user, when we
</I>&gt;<i> parse 10th request, etc.? There are many very different cases where
</I>&gt;<i> we may want to start tunneling, for many different reasons. This
</I>&gt;<i> lack of specifics makes the idea look simple and, hence, appealing,
</I>&gt;<i> but the devil is usually revealed in the details.
</I>&gt;<i> 
</I>
It also depends on where the decision is taking place. And needs to be
agnostic of TLS.

If the decision is to allow/deny TCP tunneling it's rightfully called
&quot;tcp_tunnel allow/deny&quot; regardless of how many pathways lead to that
decision point. i.e. we do not have 9 different protocol-specific
ways/names to define cache_peer_access just because 9 protocols (HTTP,
HTTPS, FTP, Gopher, Wais, tunnel, ICP, HTCP and ICMP) can all use
peers - we have one and its tested by each component as and when
necessary.


&gt;<i> The implemented &quot;on_first_request_error&quot; feature is much smaller
</I>&gt;<i> and has relatively narrow context: When Squid realizes that it does
</I>&gt;<i> not recognize the connection, it consults the proposed directive
</I>&gt;<i> for instructions. The &quot;on_error&quot; concept is not new in IT and
</I>&gt;<i> should be familiar to many admins.
</I>&gt;<i> 
</I>
Okay. Then with the narrow scope ssl_unknown_protocol is better
naming. Or can you think of a better word than &quot;protocol&quot; for that noun ?

[accepting the narrowing of scope, shelving the discussion about
tcp_tunnel]

&gt;<i> 
</I>&gt;&gt;<i> The tcp_tunnel is not a bad name. Lets see if Alex has a
</I>&gt;&gt;<i> different opinion on see...
</I>&gt;<i> 
</I>&gt;<i> tcp_tunnel is a good name, but not for the problem we are trying
</I>&gt;<i> to solve. I suspect we will eventually add a &quot;tunnel tcp&quot; or
</I>&gt;<i> &quot;tcp_tunnel&quot; directive, which will be applied at certain processing
</I>&gt;<i> points. However, we would still benefit from an on_error directive,
</I>&gt;<i> before and after tcp_tunnel is added.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Amos, if on_first_request_error is converted into on_error with a 
</I>&gt;<i> first_request (or similar) ACL, would you continue to block this 
</I>&gt;<i> frequently-requested bypass feature?
</I>
Mosly I am waiting to see an updated patch. The blocker was on waiting
for Parser-NG request handling re-write which is now in.

PS. Since this involves UI alteration it is a 3.6 feature and we can
rename/alias the directive if we find a better name for it.

Amos

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUo08uAAoJELJo5wb/XPRjmdAH/0ikflRxKevEPOYQ8i+IEYhS
9t5l4Uedx9rjCMNNsgMvJGLYvOtgAvKRZhd3qfYI1BE6xVbON30WMvIgp0JbU5ZY
NdZfpKT38oBBKnqDb5rOokO9zUSQzrdVhKayNMO1le4DAJDdhkl2TeZWyQIDe4tl
jw8sTojlsqHKQWNXYGgBn6IpxXPLBS8iUP1qWOv4bt4TE7wmtzVzp7QY8yhhqjqO
dTvQEWJi8kET7KC6EFYM9ipyF3k6GOS0Rcp6ry/yA9GE9Rab2QBcdUcQG3g8As2z
J4aQrSKdmRSZKjSDGfPtyFQxmRowPOdTMzPAIpBUmWtKlVA3/GygNK5gqELv0do=
=FpvI
-----END PGP SIGNATURE-----
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000906.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
	<LI>Next message: <A HREF="000933.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#914">[ date ]</a>
              <a href="thread.html#914">[ thread ]</a>
              <a href="subject.html#914">[ subject ]</a>
              <a href="author.html#914">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
