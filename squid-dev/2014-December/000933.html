<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Non-HTTP bypass
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54A3ABB1.6010009%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000914.html">
   <LINK REL="Next"  HREF="000934.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Non-HTTP bypass</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54A3ABB1.6010009%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Non-HTTP bypass">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Dec 31 07:54:25 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000914.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
        <LI>Next message: <A HREF="000934.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#933">[ date ]</a>
              <a href="thread.html#933">[ thread ]</a>
              <a href="subject.html#933">[ subject ]</a>
              <a href="author.html#933">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/30/2014 06:19 PM, Amos Jeffries wrote:
&gt;<i> On 31/12/2014 7:30 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 10/21/2014 11:29 AM, Tsantilas Christos wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> - Adds &quot;on_first_request_error&quot;, a new ACL-driven squid.conf 
</I>&gt;&gt;&gt;&gt;&gt;<i> directive that can be used to establish a blind TCP tunnel
</I>&gt;&gt;&gt;&gt;&gt;<i> which relays all bytes from/to the intercepted connection
</I>&gt;&gt;&gt;&gt;&gt;<i> to/from the intended destination address. See the sketch
</I>&gt;&gt;&gt;&gt;&gt;<i> above. The on_first_request_error directive supports fast
</I>&gt;&gt;&gt;&gt;&gt;<i> ACLs only.
</I>

&gt;<i> IMO this directive needs to be friendly and clear as its going to be
</I>&gt;<i> somewhat popular.
</I>
Agreed. I am not going to respond to most of your thoughts regarding the
directive name. Suffice to say that I disagree with most of your
analysis of natural language issues, but do not have enough cycles to
engage you on that exciting topic. For now, let's focus on the proposed
feature itself and decide on the final directive(s) naming later.

Most of my post was not about naming at all. It was about three ways to
control non-HTTP bypass functionality. In your response, you have not
addressed those points at all, so I assume you interpreted them as a
discussion about naming, which rendered my last email mostly useless.
However, since you seem to be OK with the updated patch going in with
some to-be-determined directive name, perhaps we are making progress
after all!


&gt;<i> The &quot;on_error&quot; as you say is already fairly well known. In particular
</I>&gt;<i> its known as an event handler hook in JavaScript and other languages.
</I>&gt;<i> Like I said above squid.conf is more a declarative language than those.
</I>

Well-known event handlers use (and often combine) two very different
concepts:

* A declaration that an error is handled by a named handler:
  on_error=foo

* An inline implementation of an anonymous handler:
  on_error=&quot;for (i = 0; i &lt; count; ++i) { foo(i); ...&quot;


ACL-driven directives in Squid essentially combine handler declarations
with a bunch of if statements similar to an inline implementation:

  on_error=&quot;if acl1 then foo1; elsif acl2 then foo2; else foo3;&quot;

What Squid uses is more declarative than some well-known on_error
handler approaches and less declarative than others. Even if it were
possible, deciding the exact degree of &quot;declarativeness&quot; is not going to
help us make progress here IMO.

What would help is to decide whether we want to focus on

  A) multiple conditions for establishing a TCP tunnel;
  B) multiple ways to handle an unrecognized protocol error; OR
  C) multiple ways to handle multiple errors.

IMO, we want (B) or perhaps (C) while leaving (A) as a separate
out-of-scope feature.

The proposed patch implements (B). To implement (C), the patch needs to
add an ACL type to distinguish an &quot;unrecognized protocol&quot; error from
other errors.


&gt;<i> 2) &quot;first_request_error&quot; [...] is actually
</I>&gt;<i> declaring an action to perform *instead* of producing errors
</I>
No. It declares actions to perform when an error is detected. Those
actions may and often do include &quot;producing an error&quot; to the user, of
course. The fact that there may be many different actions is critical
here because the tcp_tunnel alternative does not handle multiple actions
well -- it focuses on one &quot;tunnel&quot; action only.


&gt;<i> 3) This directive is not relevant to HTTP, but to SSL/TLS.
</I>
Not exactly. The feature deals with protocols that Squid does not
recognize. We may deal with plain and encrypted HTTP connections today,
but we will probably have to deal with FTP, Web Sockets, and other
protocol connections tomorrow. SSL/TLS is just a small slice of that puzzle.


&gt;<i> Coming back to this now (and accepting your scope narrowing from tcp_
</I>&gt;<i> to ssl_) we should probably call this ssl_unknown_protocol. Since
</I>&gt;<i> anything on port 443 which is syntactically HTTP but has some
</I>&gt;<i> invalidity is rightfully responded with an error, no need to ask the
</I>&gt;<i> admin at that point.
</I>
We do _not_ want to limit this feature to receiving a non-SSL/TLS
protocol on an intercepting https_port. We want to support, at least:

* non-HTTP traffic on intercepted http_port
* non-SSL/TLS traffic on intercepted https_port
* non-HTTP traffic inside successfully bumped http_port CONNECT tunnel
* non-HTTP traffic inside successfully bumped https_port SSL/TLS tunnel


Moreover, if I am interpreting your &quot;syntactically HTTP but invalid&quot;
condition correctly, then many admins will disagree with the universal
rightfulness of sending the user an error under those conditions.


&gt;<i> PS. can we please agree to start using tls_ instead of ssl_? even
</I>&gt;<i> SSLv3 is a dead duck now and everybody knows it. At least on new
</I>&gt;<i> directives.
</I>
I am glad SSLv3 is dying, but the degree of SSL death, and what &quot;SSL&quot;
means to admins is not relevant to this feature AFAICT: The feature is
not specific to SSL or TLS.


&gt;<i> If the decision is to allow/deny TCP tunneling 
</I>
It is not. There are several possible error-handling actions the admin
has to pick from and the best action may depend on the nature of the error.



&gt;&gt;<i> The implemented &quot;on_first_request_error&quot; feature is much smaller
</I>&gt;&gt;<i> and has relatively narrow context: When Squid realizes that it does
</I>&gt;&gt;<i> not recognize the connection, it consults the proposed directive
</I>&gt;&gt;<i> for instructions.
</I>
&gt;<i> Okay. Then with the narrow scope ssl_unknown_protocol is better
</I>&gt;<i> naming. 
</I>
The feature is not specific to SSL/TLS, but, more importantly, we want
the admin to be able to specify what to do when there is a problem,
choosing among several actions. The name is not that important, but the
ability to pick one of several actions is. Currently, there are only two
supported actions: establish a TCP tunnel or respond with a
port-specific error, but I suspect that there will be more actions in
the future. Terminating a connection is one example.


&gt;&gt;<i> tcp_tunnel is a good name, but not for the problem we are trying
</I>&gt;&gt;<i> to solve. I suspect we will eventually add a &quot;tunnel tcp&quot; or
</I>&gt;&gt;<i> &quot;tcp_tunnel&quot; directive, which will be applied at certain processing
</I>&gt;&gt;<i> points. However, we would still benefit from an on_error directive,
</I>&gt;&gt;<i> before and after tcp_tunnel is added.
</I>

&gt;&gt;<i> Amos, if on_first_request_error is converted into on_error with a 
</I>&gt;&gt;<i> first_request (or similar) ACL, would you continue to block this 
</I>&gt;&gt;<i> frequently-requested bypass feature?
</I>

&gt;<i> Mosly I am waiting to see an updated patch. The blocker was on waiting
</I>&gt;<i> for Parser-NG request handling re-write which is now in.
</I>
I am interpreting your answer as a &quot;no&quot; and ask Christos to update the
patch to better integrate with the new parsing code. AFAIK, the only
integration is in detecting an &quot;HTTP request parsing has failed&quot;
condition, which is hopefully easy.


Thank you,

Alex.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000914.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
	<LI>Next message: <A HREF="000934.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#933">[ date ]</a>
              <a href="thread.html#933">[ thread ]</a>
              <a href="subject.html#933">[ subject ]</a>
              <a href="author.html#933">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
