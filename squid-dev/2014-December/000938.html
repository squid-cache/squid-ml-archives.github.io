<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] unsupported protocol classification
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20unsupported%20protocol%20classification&In-Reply-To=%3C54A434C3.4070704%40urlfilterdb.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000936.html">
   <LINK REL="Next"  HREF="000939.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] unsupported protocol classification</H1>
    <B>Marcus Kool</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20unsupported%20protocol%20classification&In-Reply-To=%3C54A434C3.4070704%40urlfilterdb.com%3E"
       TITLE="[squid-dev] unsupported protocol classification">marcus.kool at urlfilterdb.com
       </A><BR>
    <I>Wed Dec 31 17:39:15 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000936.html">[squid-dev] unsupported protocol classification
</A></li>
        <LI>Next message: <A HREF="000939.html">[squid-dev] unsupported protocol classification
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#938">[ date ]</a>
              <a href="thread.html#938">[ thread ]</a>
              <a href="subject.html#938">[ subject ]</a>
              <a href="author.html#938">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On 12/31/2014 02:23 PM, Alex Rousskov wrote:
&gt;<i> [ I am changing the Subject line for this sub-thread because this new
</I>&gt;<i> discussion is not really relevant to the unsupported protocol bypass
</I>&gt;<i> feature, even though that bypass feature will be used by those who need
</I>&gt;<i> to classify unsupported protocols. ]
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 12/31/2014 03:33 AM, Marcus Kool wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> The current functionality of filtering is divided between Squid itself and
</I>&gt;&gt;<i> 3rd party software (ICAP daemons and URL redirectors).
</I>&gt;<i>
</I>&gt;<i> ... as well as external ACLs and eCAP adapters.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I plea for an interface where an external helper can decide what to do
</I>&gt;&gt;<i> with an unknown protocol inside a tunnel because it is much more flexible
</I>&gt;&gt;<i> than using ACLs and extending Squid with detection of (many) protocols.
</I>&gt;<i>
</I>&gt;<i> I doubt pleading will be enough, unfortunately, because a considerable
</I>&gt;<i> amount of coding and design expertise is required to fulfill your dream.
</I>&gt;<i> IMO, a quality implementation would involve:
</I>
It is clear to me that this functionality will not be implemented next week,
but for me it is not a dream.  It is a reality that filtering becomes more
important, just wait until a headline in the news comes along like
&quot;secret document stolen via a web tunnel&quot; and everybody wants it.
The risk is real and it is so simple to abuse CONNECT on port 443 for anything
that it is extremely likely that it is already being used for illegal actions
and will continue to be used for illegal actions.

There is also not much point in having a web proxy that can filter 50% or 99%
of what you want to filter.  If you cannot filter everything and especially cannot
filter known security risks, the filter solution is very weak.
That is why ufdbGuard currently sends probes to sites that an application CONNECTs to.
The probes tell ufdbGuard what type of traffic is to be expected but
are also not 100% reliable since a probe is not the same as an inspection
of the real traffic.

&gt;<i> 1. Encoding the tunnel information (including traffic) in [small]
</I>&gt;<i> HTTP-like messages to be passed to ICAP/eCAP services. It is important
</I>&gt;<i> to get this API design right while anticipating complications like
</I>&gt;<i> servers that speak first, agents that do not send Hellos until they hear
</I>&gt;<i> the other agent Hello, and fragmented Hellos. Most likely, the design
</I>&gt;<i> will involve two tightly linked but concurrent streams of adaptation
</I>&gt;<i> messages: user-&gt;Squid-&gt;origin and origin-&gt;Squid-&gt;user. Let's call that
</I>&gt;<i> TUNMOD, as opposed to the existing REQMOD and RESPMOD.
</I>
Getting the design right is definitely important.  Therefore I like
to bring up this issue once in a while so that with the design decisions
made today of related parts, it will be easier to implement TUNMOD
in the future.

&gt;<i> 2. Writing adaptation hooks to pass tunnel information (using TUNMOD
</I>&gt;<i> design above) to adaptation services. The primary difficulty here is
</I>&gt;<i> handling incremental &quot;give me more&quot; and &quot;give them more&quot; decisions while
</I>&gt;<i> shoveling tunneled bytes. The current tunneling code does not do any
</I>&gt;<i> adaptation at all so the developers would be starting from scratch
</I>&gt;<i> (albeit with good examples available from non-tunneling code dealing
</I>&gt;<i> with HTTP/FTP requests and HTTP/FTP responses).
</I>
It can be simpler.  TUNMOD replies can be limited to
DONTKNOW - continue with what is happening and keep the TUNMOD server informed
ACCEPT - continue and do not inform the TUNMOD server any more about this tunnel
BLOCK - close the tunnel

I think there is no need for adaptation since one accepts a webdisk, voice
chat, VPN or whatever, or one does not accept it. So adaptation as is
used for HTTP, is not an important feature.

Sending an HTTP error on a tunnel is only useful if the tunnel uses
SSL-encapsulated HTTP.

&gt;<i> 3. Implementing more actions than the already implemented &quot;start a blind
</I>&gt;<i> tunnel&quot; and &quot;respond with an error&quot;. The &quot;shovel this to the other side
</I>&gt;<i> and then come back to me with the newly received bytes&quot; action would be
</I>&gt;<i> essential in many production cases, for example.
</I>&gt;<i>
</I>&gt;<i> The above is a large project. I do not recall any projects of that size
</I>&gt;<i> and complexity implemented without sponsors in recent years but YMMV.
</I>
We will see.  Maybe there will be a sponsor to do this.

It is 15:38 local time and my last post of the year.
Happy New Year to all.

Marcus

&gt;<i> Please note that modern Squid already has an API that lets 3rd party
</I>&gt;<i> software to pick one of the supported actions. It is called annotations:
</I>&gt;<i> External software sends Squid an annotation and the admin configures
</I>&gt;<i> Squid to do X when annotation Y is received in context Z.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> A while back when we discussed the older sslBump not being able to cope
</I>&gt;&gt;<i> with Skype I suggested to use ICAP so that the ICAP daemon receives a
</I>&gt;&gt;<i> REQMOD/RESPMOD message with CONNECT and intercepted content, which also is
</I>&gt;&gt;<i> a valid option for me.
</I>&gt;<i>
</I>&gt;<i> Yes, ICAP/eCAP is the right direction here IMO, but there are several
</I>&gt;<i> challenges on that road. I tried to detail them above.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000936.html">[squid-dev] unsupported protocol classification
</A></li>
	<LI>Next message: <A HREF="000939.html">[squid-dev] unsupported protocol classification
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#938">[ date ]</a>
              <a href="thread.html#938">[ thread ]</a>
              <a href="subject.html#938">[ subject ]</a>
              <a href="author.html#938">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
