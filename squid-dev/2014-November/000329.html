<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Drop some CbDataList
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Drop%20some%20CbDataList&In-Reply-To=%3C5460C371.5030801%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000316.html">
   <LINK REL="Next"  HREF="000332.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Drop some CbDataList</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Drop%20some%20CbDataList&In-Reply-To=%3C5460C371.5030801%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Drop some CbDataList">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Nov 10 13:53:53 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000316.html">[squid-dev] Jenkins build is back to normal :	3.HEAD-amd64-ubuntu-saucy #368
</A></li>
        <LI>Next message: <A HREF="000332.html">[squid-dev] [PATCH] Drop some CbDataList
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#329">[ date ]</a>
              <a href="thread.html#329">[ thread ]</a>
              <a href="subject.html#329">[ subject ]</a>
              <a href="author.html#329">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Most of the uses of CbDataList appear to be abusing it for regular
list storage without any real need for CBDATA to be involved at all.

This replaces several of the simpler uses of CbDataList in favour of
std::list.

Amos
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUYMNwAAoJELJo5wb/XPRjXRoH/jsgFpxVeBauRRhH1Tw8rcQG
Y4dQrGPBRZu+OEI9WOyyy5iao0cc13ueSXoW6ppmjCcyEd162bKpvgDOvoCfb2NU
lsgwcxpEg0anSSPsA+TaNT7xnC6TB/z1MPMQZRHjzTrP8d9mo/usQdDPvgcEaEl5
hmUXcVrkY4TimkBjLfQnvIUUSEpgsT056PHYQa6vRLEZTPFnE0WlxdwoObV4N76m
fjcB7/vyBbuO0JLZOGiW1CABLpu5Cqx69fAtiRan8CIZr2mbNc/wROt9B23hqWg3
aC9sfozmuJUzPebinMyK/J1+EkAjLj/+Wx4FB/swIIVxrAbAnt3hSHdC059NNyU=
=8Zfg
-----END PGP SIGNATURE-----
-------------- next part --------------
=== modified file 'src/Notes.h'
--- src/Notes.h	2014-11-02 05:51:22 +0000
+++ src/Notes.h	2014-11-03 10:03:43 +0000
@@ -1,33 +1,32 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_NOTES_H
 #define SQUID_NOTES_H
 
 #include &quot;acl/forward.h&quot;
-#include &quot;base/CbDataList.h&quot;
 #include &quot;base/RefCount.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;MemPool.h&quot;
 #include &quot;SquidString.h&quot;
 #include &quot;typedefs.h&quot;
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
 class HttpRequest;
 class HttpReply;
 typedef RefCount&lt;AccessLogEntry&gt; AccessLogEntryPointer;
 
 /**
  * Used to store a note configuration. The notes are custom key:value
  * pairs ICAP request headers or ECAP options used to pass
  * custom transaction-state related meta information to squid
  * internal subsystems or to adaptation services.
  */
 class Note: public RefCountable

=== modified file 'src/acl/AtStepData.h'
--- src/acl/AtStepData.h	2014-11-02 05:51:22 +0000
+++ src/acl/AtStepData.h	2014-11-03 03:54:25 +0000
@@ -1,41 +1,40 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLATSTEPDATA_H
 #define SQUID_ACLATSTEPDATA_H
 
 #if USE_OPENSSL
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Data.h&quot;
-#include &quot;base/CbDataList.h&quot;
 #include &quot;ssl/support.h&quot;
 
 #include &lt;list&gt;
 
 class ACLAtStepData : public ACLData&lt;Ssl::BumpStep&gt;
 {
     MEMPROXY_CLASS(ACLAtStepData);
 
 public:
     ACLAtStepData();
     ACLAtStepData(ACLAtStepData const &amp;);
     ACLAtStepData &amp;operator= (ACLAtStepData const &amp;);
     virtual ~ACLAtStepData();
     bool match(Ssl::BumpStep);
     virtual SBufList dump() const;
     void parse();
     bool empty() const;
-    virtual  ACLAtStepData *clone() const;
+    virtual ACLAtStepData *clone() const;
 
     std::list&lt;Ssl::BumpStep&gt; values;
 };
 
 #endif /* USE_OPENSSL */
 
 #endif /* SQUID_ACLSSL_ERRORDATA_H */

=== modified file 'src/acl/HierCodeData.h'
--- src/acl/HierCodeData.h	2014-11-02 05:51:22 +0000
+++ src/acl/HierCodeData.h	2014-11-03 03:53:44 +0000
@@ -1,37 +1,35 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLHIERCODEDATA_H
 #define SQUID_ACLHIERCODEDATA_H
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Data.h&quot;
-#include &quot;base/CbDataList.h&quot;
 #include &quot;hier_code.h&quot;
 
-/// \ingroup ACLAPI
 class ACLHierCodeData : public ACLData&lt;hier_code&gt;
 {
     MEMPROXY_CLASS(ACLHierCodeData);
 
 public:
     ACLHierCodeData();
     ACLHierCodeData(ACLHierCodeData const &amp;);
     ACLHierCodeData &amp;operator= (ACLHierCodeData const &amp;);
     virtual ~ACLHierCodeData();
     bool match(hier_code);
     virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData&lt;hier_code&gt; *clone() const;
 
-    // mask of codes this ACL might match.
+    /// mask of codes this ACL might match.
     bool values[HIER_MAX];
 };
 
 #endif /* SQUID_ACLHIERCODEDATA_H */

=== modified file 'src/acl/IntRange.cc'
--- src/acl/IntRange.cc	2014-09-13 13:59:43 +0000
+++ src/acl/IntRange.cc	2014-11-02 14:37:03 +0000
@@ -1,110 +1,98 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/IntRange.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;Parsing.h&quot;
 
-/* explicit instantiation required for some systems */
-/** \cond AUTODOCS_IGNORE */
-template cbdata_type CbDataList&lt; Range&lt;int&gt; &gt;::CBDATA_CbDataList;
-/** \endcond */
-
 void
 ACLIntRange::parse()
 {
     char *a;
 
     while ((a = strtokFile())) {
         char *b = strchr(a, '-');
         unsigned short port1, port2;
 
         if (b) {
             *b = '\0';
             ++b;
         }
 
         port1 = xatos(a);
 
         if (b)
             port2 = xatos(b);
         else
             port2 = port1;
 
         if (port2 &gt;= port1) {
-            RangeType temp (0,0);
-            temp.start = port1;
-            temp.end = port2+1;
+            RangeType temp(port1, port2+1);
             ranges.push_back(temp);
         } else {
             debugs(28, DBG_CRITICAL, &quot;ACLIntRange::parse: Invalid port value&quot;);
             self_destruct();
         }
     }
 }
 
 bool
 ACLIntRange::empty() const
 {
     return ranges.empty();
 }
 
 bool
 ACLIntRange::match(int i)
 {
-    RangeType const toFind (i, i+1);
-    CbDataListIterator&lt;RangeType&gt; iter(ranges);
-
-    while (!iter.end()) {
-        const RangeType &amp; element = iter.next();
-        RangeType result = element.intersection (toFind);
+    RangeType const toFind(i, i+1);
+    for (std::list&lt;RangeType&gt;::const_iterator iter = ranges.begin(); iter != ranges.end(); ++iter) {
+        const RangeType &amp; element = *iter;
+        RangeType result = element.intersection(toFind);
 
         if (result.size())
             return true;
     }
 
     return false;
 }
 
 ACLData&lt;int&gt; *
 ACLIntRange::clone() const
 {
     if (!ranges.empty())
         fatal(&quot;ACLIntRange::clone: attempt to clone used ACL&quot;);
 
-    return new ACLIntRange (*this);
+    return new ACLIntRange(*this);
 }
 
 ACLIntRange::~ACLIntRange()
 {}
 
 SBufList
 ACLIntRange::dump() const
 {
     SBufList sl;
-    CbDataListIterator&lt;RangeType&gt; iter(ranges);
-
-    while (!iter.end()) {
+    for (std::list&lt;RangeType&gt;::const_iterator iter = ranges.begin(); iter != ranges.end(); ++iter) {
         SBuf sb;
-        const RangeType &amp; element = iter.next();
+        const RangeType &amp; element = *iter;
 
         if (element.size() == 1)
             sb.Printf(&quot;%d&quot;, element.start);
         else
             sb.Printf(&quot;%d-%d&quot;, element.start, element.end-1);
 
         sl.push_back(sb);
     }
 
     return sl;
 }
-

=== modified file 'src/acl/IntRange.h'
--- src/acl/IntRange.h	2014-11-02 05:51:22 +0000
+++ src/acl/IntRange.h	2014-11-03 03:47:47 +0000
@@ -1,35 +1,35 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLINTRANGE_H
 #define SQUID_ACLINTRANGE_H
 
 #include &quot;acl/Data.h&quot;
-#include &quot;base/CbDataList.h&quot;
 #include &quot;Range.h&quot;
 
-/// \ingroup ACLAPI
+#include &lt;list&gt;
+
 class ACLIntRange : public ACLData&lt;int&gt;
 {
 
 public:
-    ACLIntRange() {};
+    ACLIntRange() {}
 
     virtual ~ACLIntRange();
     virtual bool match(int);
     virtual SBufList dump() const;
     virtual void parse();
     virtual bool empty() const;
     virtual ACLData&lt;int&gt; *clone() const;
 
 private:
     typedef Range&lt;int&gt; RangeType;
-    CbDataListContainer &lt;RangeType&gt; ranges;
+    std::list&lt;RangeType&gt; ranges;
 };
 
 #endif /* SQUID_ACLINTRANGE_H */

=== modified file 'src/acl/MethodData.cc'
--- src/acl/MethodData.cc	2014-09-13 13:59:43 +0000
+++ src/acl/MethodData.cc	2014-11-02 15:12:19 +0000
@@ -1,87 +1,69 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/MethodData.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;HttpRequestMethod.h&quot;
 
 int ACLMethodData::ThePurgeCount = 0;
 
-ACLMethodData::ACLMethodData() : values (NULL)
-{}
-
-ACLMethodData::ACLMethodData(ACLMethodData const &amp;old) : values (NULL)
+ACLMethodData::ACLMethodData(ACLMethodData const &amp;old)
 {
-    assert (!old.values);
+    assert(old.values.empty());
 }
 
 ACLMethodData::~ACLMethodData()
 {
-    if (values)
-        delete values;
+    values.clear();
 }
 
-/// todo make this a pass-by-reference now that HTTPRequestMethods a full class?
 bool
 ACLMethodData::match(HttpRequestMethod toFind)
 {
-    return values-&gt;findAndTune(toFind);
+    for (std::list&lt;HttpRequestMethod&gt;::const_iterator itr = values.begin(); itr != values.end(); ++itr) {
+        if (*itr == toFind) {
+            // tune the list for LRU ordering
+            values.erase(itr);
+            values.push_front(toFind);
+            return true;
+        }
+    }
+    return false;
 }
 
-/* explicit instantiation required for some systems */
-
-/// \cond AUTODOCS_IGNORE
-template cbdata_type CbDataList&lt;HttpRequestMethod&gt;::CBDATA_CbDataList;
-/// \endcond
-
 SBufList
 ACLMethodData::dump() const
 {
     SBufList sl;
-    CbDataList&lt;HttpRequestMethod&gt; *data = values;
-
-    while (data != NULL) {
-        sl.push_back(data-&gt;element.image());
-        data = data-&gt;next;
+    for (std::list&lt;HttpRequestMethod&gt;::const_iterator itr = values.begin(); itr != values.end(); ++itr) {
+        sl.push_back((*itr).image());
     }
 
     return sl;
 }
 
 void
 ACLMethodData::parse()
 {
-    CbDataList&lt;HttpRequestMethod&gt; **Tail;
-    char *t = NULL;
-
-    for (Tail = &values; *Tail; Tail = &amp;((*Tail)-&gt;next));
-    while ((t = strtokFile())) {
-        CbDataList&lt;HttpRequestMethod&gt; *q = new CbDataList&lt;HttpRequestMethod&gt; (HttpRequestMethod(t, NULL));
-        if (q-&gt;element == Http::METHOD_PURGE)
+    while (char *t = strtokFile()) {
+        values.push_back(HttpRequestMethod(t, NULL));
+        if (values.back() == Http::METHOD_PURGE)
             ++ThePurgeCount; // configuration code wants to know
-        *(Tail) = q;
-        Tail = &amp;q-&gt;next;
     }
 }
 
-bool
-ACLMethodData::empty() const
-{
-    return values == NULL;
-}
-
 ACLData&lt;HttpRequestMethod&gt; *
 ACLMethodData::clone() const
 {
-    assert (!values);
+    assert(!values.empty());
     return new ACLMethodData(*this);
 }

=== modified file 'src/acl/MethodData.h'
--- src/acl/MethodData.h	2014-11-02 05:51:22 +0000
+++ src/acl/MethodData.h	2014-11-02 15:12:33 +0000
@@ -1,37 +1,38 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMETHODDATA_H
 #define SQUID_ACLMETHODDATA_H
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Data.h&quot;
-#include &quot;base/CbDataList.h&quot;
 #include &quot;HttpRequestMethod.h&quot;
 
+#include &lt;list&gt;
+
 class ACLMethodData : public ACLData&lt;HttpRequestMethod&gt;
 {
     MEMPROXY_CLASS(ACLMethodData);
 
 public:
-    ACLMethodData();
+    ACLMethodData() {}
     ACLMethodData(ACLMethodData const &amp;);
     ACLMethodData &amp;operator= (ACLMethodData const &amp;);
     virtual ~ACLMethodData();
     bool match(HttpRequestMethod);
     virtual SBufList dump() const;
     void parse();
-    bool empty() const;
+    bool empty() const {return values.empty();}
     virtual ACLData&lt;HttpRequestMethod&gt; *clone() const;
 
-    CbDataList&lt;HttpRequestMethod&gt; *values;
+    std::list&lt;HttpRequestMethod&gt; values;
 
     static int ThePurgeCount; ///&lt; PURGE methods seen by parse()
 };
 
 #endif /* SQUID_ACLMETHODDATA_H */

=== modified file 'src/acl/ProtocolData.cc'
--- src/acl/ProtocolData.cc	2014-09-13 13:59:43 +0000
+++ src/acl/ProtocolData.cc	2014-11-03 03:56:21 +0000
@@ -1,94 +1,77 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/ProtocolData.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;wordlist.h&quot;
 
-ACLProtocolData::ACLProtocolData() : values (NULL)
-{}
-
-ACLProtocolData::ACLProtocolData(ACLProtocolData const &amp;old) : values (NULL)
+ACLProtocolData::ACLProtocolData(ACLProtocolData const &amp;old)
 {
-    assert (!old.values);
+    assert(old.values.empty());
 }
 
 ACLProtocolData::~ACLProtocolData()
 {
-    if (values)
-        delete values;
+    values.clear();
 }
 
 bool
 ACLProtocolData::match(AnyP::ProtocolType toFind)
 {
-    return values-&gt;findAndTune (toFind);
+    for (std::list&lt;AnyP::ProtocolType&gt;::const_iterator itr = values.begin(); itr != values.end(); ++itr) {
+        if (*itr == toFind) {
+            // tune the list for LRU ordering
+            values.erase(itr);
+            values.push_front(toFind);
+            return true;
+        }
+    }
+    return false;
 }
 
-/* explicit instantiation required for some systems */
-
-/// \cond AUTODOCS_IGNORE
-template cbdata_type CbDataList&lt;AnyP::ProtocolType&gt;::CBDATA_CbDataList;
-/// \endcond
-
 SBufList
 ACLProtocolData::dump() const
 {
     SBufList sl;
-    CbDataList&lt;AnyP::ProtocolType&gt; *data = values;
-
-    while (data != NULL) {
-        sl.push_back(SBuf(AnyP::ProtocolType_str[data-&gt;element]));
-        data = data-&gt;next;
+    for (std::list&lt;AnyP::ProtocolType&gt;::const_iterator itr = values.begin(); itr != values.end(); ++itr) {
+        sl.push_back(SBuf(AnyP::ProtocolType_str[*itr]));
     }
 
     return sl;
 }
 
 void
 ACLProtocolData::parse()
 {
-    CbDataList&lt;AnyP::ProtocolType&gt; **Tail;
-    char *t = NULL;
-
-    for (Tail = &values; *Tail; Tail = &amp;((*Tail)-&gt;next));
-    while ((t = strtokFile())) {
+    while (char *t = strtokFile()) {
         int p = AnyP::PROTO_NONE;
         for (; p &lt; AnyP::PROTO_UNKNOWN; ++p) {
             if (strcasecmp(t, AnyP::ProtocolType_str[p]) == 0) {
-                CbDataList&lt;AnyP::ProtocolType&gt; *q = new CbDataList&lt;AnyP::ProtocolType&gt;(static_cast&lt;AnyP::ProtocolType&gt;(p));
-                *(Tail) = q;
-                Tail = &amp;q-&gt;next;
+                values.push_back(static_cast&lt;AnyP::ProtocolType&gt;(p));
                 break;
             }
         }
         if (p == AnyP::PROTO_UNKNOWN) {
             debugs(28, DBG_IMPORTANT, &quot;WARNING: Ignoring unknown protocol '&quot; &lt;&lt; t &lt;&lt; &quot;' in the ACL named '&quot; &lt;&lt; AclMatchedName &lt;&lt; &quot;'&quot;);
             // XXX: store the text pattern of this protocol name for live comparisons
         }
     }
 }
 
-bool
-ACLProtocolData::empty() const
-{
-    return values == NULL;
-}
-
 ACLData&lt;AnyP::ProtocolType&gt; *
 ACLProtocolData::clone() const
 {
     /* Splay trees don't clone yet. */
-    assert (!values);
+    assert(values.empty());
     return new ACLProtocolData(*this);
 }

=== modified file 'src/acl/ProtocolData.h'
--- src/acl/ProtocolData.h	2014-11-02 05:51:22 +0000
+++ src/acl/ProtocolData.h	2014-11-03 03:57:28 +0000
@@ -1,35 +1,36 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLPROTOCOLDATA_H
 #define SQUID_ACLPROTOCOLDATA_H
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Data.h&quot;
 #include &quot;anyp/ProtocolType.h&quot;
-#include &quot;base/CbDataList.h&quot;
+
+#include &lt;list&gt;
 
 class ACLProtocolData : public ACLData&lt;AnyP::ProtocolType&gt;
 {
     MEMPROXY_CLASS(ACLProtocolData);
 
 public:
-    ACLProtocolData();
+    ACLProtocolData() {}
     ACLProtocolData(ACLProtocolData const &amp;);
     ACLProtocolData &amp;operator= (ACLProtocolData const &amp;);
     virtual ~ACLProtocolData();
     bool match(AnyP::ProtocolType);
     virtual SBufList dump() const;
     void parse();
-    bool empty() const;
+    bool empty() const {return values.empty();}
     virtual ACLData&lt;AnyP::ProtocolType&gt; *clone() const;
 
-    CbDataList&lt;AnyP::ProtocolType&gt; *values;
+    std::list&lt;AnyP::ProtocolType&gt; values;
 };
 
 #endif /* SQUID_ACLPROTOCOLDATA_H */

=== modified file 'src/auth/QueueNode.h'
--- src/auth/QueueNode.h	2014-10-20 06:58:59 +0000
+++ src/auth/QueueNode.h	2014-11-03 10:38:43 +0000
@@ -1,31 +1,33 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_AUTH_QUEUENODE_H
 #define SQUID_SRC_AUTH_QUEUENODE_H
 
+#include &quot;cbdata.h&quot;
+
 namespace Auth
 {
 
 /**
  * A queue of auth requests waiting for verification to occur.
  *
  * Certain authentication schemes such a Basic and Bearer auth
  * permit credentials tokens to be repeated from multiple sources
  * simultaneously. This queue node allows multiple validation
  * queries to be collapsed into one backend helper lookup.
  * CBDATA and handlers stored in these queue nodes can be notified
  * all at once with a result when the lookup completes.
  */
 class QueueNode
 {
     MEMPROXY_CLASS(Auth::QueueNode);
 
 private:
     // we store CBDATA here, copy is not safe
     QueueNode(const QueueNode &amp;);

-------------- next part --------------
A non-text attachment was scrubbed...
Name: CbDataList_removal_mk1.patch.sig
Type: application/octet-stream
Size: 287 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20141111/a2cb43ec/attachment-0001.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20141111/a2cb43ec/attachment-0001.obj</A>&gt;
</PRE>






















































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000316.html">[squid-dev] Jenkins build is back to normal :	3.HEAD-amd64-ubuntu-saucy #368
</A></li>
	<LI>Next message: <A HREF="000332.html">[squid-dev] [PATCH] Drop some CbDataList
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#329">[ date ]</a>
              <a href="thread.html#329">[ thread ]</a>
              <a href="subject.html#329">[ subject ]</a>
              <a href="author.html#329">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
