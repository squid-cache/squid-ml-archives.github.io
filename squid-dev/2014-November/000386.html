<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] url_rewrite_timeout directive
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20url_rewrite_timeout%20directive&In-Reply-To=%3C546A847B.1040805%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000378.html">
   <LINK REL="Next"  HREF="000413.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] url_rewrite_timeout directive</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20url_rewrite_timeout%20directive&In-Reply-To=%3C546A847B.1040805%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] url_rewrite_timeout directive">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Nov 17 23:27:55 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000378.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
        <LI>Next message: <A HREF="000413.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#386">[ date ]</a>
              <a href="thread.html#386">[ thread ]</a>
              <a href="subject.html#386">[ subject ]</a>
              <a href="author.html#386">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 18/11/2014 6:10 a.m., Tsantilas Christos wrote:
&gt;<i> On 11/16/2014 01:05 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> On 16/11/2014 7:38 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;<i> Hi all,
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> This patch adds the url_rewrite_timeout directive.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> When configured, Squid keeps track of active requests and
</I>&gt;&gt;&gt;<i> treats timed out requests to redirector as failed requests.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> url_rewrite_timeout format: url_rewrite_timeout timeout
</I>&gt;&gt;&gt;<i> time-units 
</I>&gt;&gt;&gt;<i> on_timeout=&lt;fail|bypass|retry|use_configured_response&gt; 
</I>&gt;&gt;&gt;<i> [response=&lt;quoted-string&gt;]
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> The url_rewrite_timeout directive can accept the on_timeout 
</I>&gt;&gt;&gt;<i> argument to allow user configure the action when the helper
</I>&gt;&gt;&gt;<i> request times out. The available actions are: - fail: squid
</I>&gt;&gt;&gt;<i> return a ERR_GATEWAY_FAILURE error page
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Why? It seems to me this should be doing one of the below:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> on_timeout=use_configured_response response=ERR
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> on_timeout=use_configured_response response=BH
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> although being able to redirect to a Squid default error page
</I>&gt;&gt;<i> template has its attractions regardless of this. Perhapse BH with
</I>&gt;&gt;<i> an error=ERR_GATEWAY_FAILURE kv-pair ?
</I>&gt;<i> 
</I>&gt;<i> The on_timeout= option is easier to understand and configure.
</I>&gt;<i> 
</I>&gt;<i> Also this patch add the retries operation inside helpers.cc code
</I>&gt;<i> and make it easier to implement similar features for other helpers
</I>&gt;<i> too...
</I>&gt;<i> 
</I>&gt;<i> Also the BH retry can be implemented now using helpers retry
</I>&gt;<i> operation.
</I>&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> - bypass: the url is not rewritten.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Identical to: on_timeout=use_configured_response response=OK
</I>&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> - retry: retry the request to helper
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Equivalent to what is supposed to happen for: 
</I>&gt;&gt;<i> on_timeout=use_configured_response response=BH
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> NP: if retry with different helper process is not already being
</I>&gt;&gt;<i> done on BH then it needs to be added.
</I>&gt;<i> 
</I>&gt;<i> It is not implemented for BH redirects. Also although it is make
</I>&gt;<i> sense to not use the same server for a BH response, it is not clear
</I>&gt;<i> why it is needed for a timedout server?
</I>
We dont know why the timeout happened. There are a few cases where it
may have happened due to internal helper state. Moving to a different
helper guarantees that those cases will have changed in some ways -
reducing the overall probability that it will repeat.

&gt;<i> 
</I>&gt;<i> I believe this is should have a different form. If there are many 
</I>&gt;<i> timedout responses from a server, then do not sent more requests
</I>&gt;<i> for a while, or maybe shut it down. We can add a todo for this
</I>&gt;<i> one.
</I>&gt;<i> 
</I>
Both are worth doing.

&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> - use_configured_response: use a response which can be
</I>&gt;&gt;&gt;<i> configured using the the response= option
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> So as you can see, with a change to make the URL-rewriter capable
</I>&gt;&gt;<i> of redirecting to one of the built-in error page templates we
</I>&gt;&gt;<i> could completely drop the on_timeout setting.
</I>&gt;<i> 
</I>&gt;<i> I still believe that the &quot;on-timeout&quot; is better options and easier
</I>&gt;<i> to understand and configure.
</I>&gt;<i> 
</I>
Whatever it gets called the main point was there is no need for 2
different options.

&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> Technical details =====================
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> This patch: - adds mechanism inside helpers.cc code to handle 
</I>&gt;&gt;&gt;<i> timeouts: - return a pre-configured response on timeout - or 
</I>&gt;&gt;&gt;<i> retries on timeouts. - or timedout (Helper::TimedOut code)
</I>&gt;&gt;&gt;<i> response to the  caller. The caller can select to ignore the
</I>&gt;&gt;&gt;<i> timedout request, or produce an error.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> - modify the client_side_request.cc to return
</I>&gt;&gt;&gt;<i> ERR_GATEWAY_FAILURE error page. Also the error detail
</I>&gt;&gt;&gt;<i> ERR_DETAIL_REDIRECTOR_TIMEDOUT is set to identify the type of
</I>&gt;&gt;&gt;<i> error.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> For the record I am still extremely skeptical about the use-case 
</I>&gt;&gt;<i> behind this feature. Timeout i a clear sign that the helper or
</I>&gt;&gt;<i> system behind it is broken (capacity overload / network
</I>&gt;&gt;<i> congestion). Continuing to use such systems in a way which
</I>&gt;&gt;<i> further increases network load is very often a bad choice. Hiding
</I>&gt;&gt;<i> the issue an even worse choice.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Maybe the administrator does not care about unanswered queries.
</I>
I posit that admin who truely do not care about unanswered questions
will not care enough to bother configuring this feature.

The administrator should always care about these unanswered questions.
Each one means worse proxy performance. Offering to hide them silently
and automatically without anybody having to do any work about fixing
the underlying cause implies they are not actually problems. Which is
false implication.


&gt;<i> Imagine a huge squid proxy, which may have to process thousands of
</I>&gt;<i> URLs per minute and the administrator decided that a 10% of helpers
</I>&gt;<i> request can fail. In this case we are giving him a way to configure
</I>&gt;<i> the squid behaviour in this case: may ignore the probelm, or use a
</I>&gt;<i> predefined answer etc
</I>
Now that same Squid proxy suddenly starts randomly wrongly rejecting
just one request per minute out of all those thousands.
 Which one, why, and WTF can anybody do about it?

Previous Squid would log a client request with _TIMEOUT, leave a
helper in Busy or Pending state with full trace of the pending lookup
in mgr reports, possibly even cache.log warnings about helpers queue
length.

Now all that is reduced to an overly simple aggregated &quot;Requests timed
out:&quot; hiding in a rarely viewed manager report and a hidden level-3
debug message that lists an anonymous requestId from N identical
requestIds spread over N helpers.

&gt;<i> 
</I>&gt;<i> The reason the helper is not answered enough fast, maybe is a
</I>&gt;<i> database or an external lookup failure (for example categorized
</I>&gt;<i> urls list as a DNS service). In these cases the system admin or
</I>&gt;<i> service provider, may prefer a none answer from the helper, or a
</I>&gt;<i> preconfigured answer, instead of waiting too long for the answer.
</I>
What to do if the internal dependencies are going badly is something
that should be handled *inside the helper*.
 After all Squid has absolutely no way to know if its generic lookup
helper has the DNS lookup on the DB server name or the DB query itself
broken. Each of which might have a different &quot;best&quot; way to respond.

The intention of the BrokenHelper code was to have the helpers
explicitly inform Squid that they were in trouble and needed help
shifting the load elsewhere.

Squid silently &quot;Forgetting&quot; that requests have been sent and then
sending *more* is a truely terrible way to fix all the cases of helper
overload.


&gt;<i> 
</I>&gt;<i> The helper can be implemented to not answer at all after a timeout
</I>&gt;<i> period. A policy of &quot;if you do not answer in a day, please do not
</I>&gt;<i> answer at all, I am not interested any mode&quot; is common in human
</I>&gt;<i> world, and in business.
</I>&gt;<i> 
</I>
Yes, it is also being fingered as a major reason for businesses dying
off during the recent recession. Late respondants lost out on work and
thus cashflow.


&gt;&gt;<i> 
</I>&gt;&gt;<i> in src/cache_cf.cc
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * please move the *_url_rewrite_timeout() functions to
</I>&gt;&gt;<i> redirect.cc - that will help reduce dependency issues when we get
</I>&gt;&gt;<i> around to making the redirector config a standalone FooConfig
</I>&gt;&gt;<i> object.
</I>&gt;<i> 
</I>&gt;<i> Not so easy, because of dependencies on time-related parsing
</I>&gt;<i> functions.... I let it for now. If required we must move time parse
</I>&gt;<i> functions to a library file, for example Config.cc
</I>&gt;<i> 
</I>
Pity. Oh well.

&gt;&gt;<i> 
</I>&gt;&gt;<i> * it would be simpler and easier on users to omit the 
</I>&gt;&gt;<i> &quot;on_timeout=use_configured_response response=&quot; and just have the 
</I>&gt;&gt;<i> existence of a response= kv-pair imply the on_timeout action. -
</I>&gt;&gt;<i> that also allows the above suggested removal of bypass and retry 
</I>&gt;&gt;<i> special actions without loosing any functionality. - that removes
</I>&gt;&gt;<i> the FATAL errors if admin gets the options ordering different
</I>&gt;&gt;<i> from what you expect. - and allows for forward-compatibility with
</I>&gt;&gt;<i> unknown options. A while loop fetching kv-pair and processing
</I>&gt;&gt;<i> them as found regardess of order seems best for a field
</I>&gt;&gt;<i> documented a &quot; [options] &quot;.
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> True. This is fixed in this patch
</I>
Added a memory leak when setting Config.onUrlRewriteTimeout.response
multiple times.

Also in free_url_rewrite_timeout() use safe_free() to release and NULL
the pointer in one call.

Also in dump_url_rewrite_timeout()please do not assert(). This will do
nasty things in SMP mode manager reports. Handle the error instead.


&gt;&gt;<i> 
</I>&gt;&gt;<i> * please define the new handleAdaptationFailure() *above* the
</I>&gt;&gt;<i> new calloutsError(). - that will reduce the diff and make it
</I>&gt;&gt;<i> clearer what actually is changing and what not.
</I>&gt;<i> 
</I>

Still not doing this. It adds 40 lines to your diff when there is only
5-6 lines of change.

&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * its now possible for adaptation error to silently continue 
</I>&gt;&gt;<i> processing. Before it would hang. I am not sure that is a good or
</I>&gt;&gt;<i> bad change. But it may be worth noting the difference in 
</I>&gt;&gt;<i> handleAdaptationFailure() where it not unconditionally calls 
</I>&gt;&gt;<i> doCallouts() at the end.
</I>&gt;<i> 
</I>&gt;<i> There is not any change on handling adaptation errors, or should
</I>&gt;<i> not be. Am I loosing something?
</I>
The new handleAdaptationFailure() runs doCallout unconditionally:
  ...
  calloutsError(ERR_ICAP_FAILURE, errDetail);
  doCallouts();

The old code was:
 ...
 if (calloutContext) {
   ... &lt;body of new calloutsError&gt; ...
   doCallouts();
 }


The new code for calloutsError() uses the if-condition internally now.
But this leaves the terminal doCallouts() from
handleAdaptationFailure() unprotected.


&gt;&gt;<i> in src/helper.cc:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * adding multiple double-empty lines in the chunk @195
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * helper_server::checkForTimedOutRequests() is deducting from 
</I>&gt;&gt;<i> stats.pending pending. This is incorrect, the helper request is
</I>&gt;&gt;<i> still pending.
</I>&gt;<i> 
</I>&gt;<i> Amos, I think it is better as is.... Maybe in a point of view the
</I>&gt;<i> request is still pending, but we are not waiting an answer for this
</I>&gt;<i> request any more.
</I>
Any helper which is obeying the helper protocol *will* still be
consuming resources trying to satisfy it.
This is what I mean by forgetting and sending more requests to the
helper &quot;making the overload problem worse&quot;.


&gt;<i> 
</I>&gt;&gt;<i> - your act of removing the requests from the queue invalidates
</I>&gt;&gt;<i> the logic in helperReturnBuffer() recording and managing late
</I>&gt;&gt;<i> helper responses.
</I>&gt;<i> 
</I>&gt;<i> why?
</I>
Non-concurrent helpers:
 * #1 query times out and gets discarded.
 * Lookup logics finding a helper to use see a helper without pending
requests and deliver a second lookup (#2).
 * #1 response arrives late and is used as response to the current
pending (#2) lookup.
 * #2 response arrives and is discarded.
- --&gt; helper responses are hereafter off-by-1 until another timeout
makes it off-by-2 or lucky random timing makes it off-by-0 again.

Please notice that the helpers with most common long duration lookups
are NTLM and Kerberos crypto validation. Which do not support
concurrency channels.


&gt;<i> 
</I>&gt;&gt;<i> - both of the above also corrupts the mgr report content for
</I>&gt;&gt;<i> expected pending responses. By all means call (and clear) the
</I>&gt;&gt;<i> callback on a timeout but please do not remove the queue entries
</I>&gt;&gt;<i> for them until the helper actually responds to that query.
</I>&gt;<i> 
</I>&gt;<i> Some of the queries will never  answered. This is may result to
</I>&gt;<i> memory leaks.
</I>
see the point I made next:

&gt;&gt;<i> - if a helper gets too many un-responded queries the traffic
</I>&gt;&gt;<i> being served by it is f'ckd and we should shutdown the helper. If
</I>&gt;&gt;<i> an auto-restart does not work Manual intervention is probably
</I>&gt;&gt;<i> required from the admin to resolve why it is timing out *at
</I>&gt;&gt;<i> all*.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> NP: when doing a re-try we still may get a response to this
</I>&gt;&gt;<i> lookup from *either* of the helpers which have been asked for it.
</I>&gt;&gt;<i> The frst helper is in fact more likely to respond first. IMO we
</I>&gt;&gt;<i> should be taking advantage of that and leaving both helpers with
</I>&gt;&gt;<i> shared pointer which either can call+unset the callback for.
</I>&gt;<i> 
</I>&gt;<i> Maybe this is good optimization. However requires some work.... We
</I>&gt;<i> can add it later if required as optimization...
</I>&gt;<i> 
</I>
Ok. Please add an TODO about it at least.

&gt;&gt;<i> 
</I>&gt;&gt;<i> Please also document clearly in the release notes that:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> A) helper-mux.pl we have been distributing for the past few years
</I>&gt;&gt;<i> to encourage use of concurrency is no longer compatible with
</I>&gt;&gt;<i> Squid. If used it will spawn up to 2^64 helpers and DoS the Squid
</I>&gt;&gt;<i> server.
</I>&gt;<i> 
</I>&gt;<i> What is this helper? I can not find it inside squid sources....
</I>
Under tools/
<A HREF="http://wiki.squid-cache.org/Features/HelperMultiplexer">http://wiki.squid-cache.org/Features/HelperMultiplexer</A>


&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> B) helpers utilizing arrays to handle fixed amounts of
</I>&gt;&gt;<i> concurrency channels MUST be re-written to use queues and capable
</I>&gt;&gt;<i> of handling a 64-bit int as index or they will be vulnerable to
</I>&gt;&gt;<i> buffer overrun and arbitrary memory accesses.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> OK for this
</I>&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> C) 32-bit helpers need re-writing to handle the concurrency
</I>&gt;&gt;<i> channel ID as a 64-bit integer value. If not updated they will
</I>&gt;&gt;<i> cause proxies to return unexpected results or timeout once
</I>&gt;&gt;<i> crossing the 32-bit wrap boundary. Leading to undefined behaviour
</I>&gt;&gt;<i> in the client HTTP traffic.
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> OK.
</I>&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> My vote on this is -0. Too many problems and still no clear
</I>&gt;&gt;<i> use-case has been described[1] for this to be a reasonable
</I>&gt;&gt;<i> addition.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> OK. I tried to do most  of the fixes you are suggested. I hope it
</I>&gt;<i> is OK.
</I>&gt;<i> 
</I>
Amos

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUaoR7AAoJELJo5wb/XPRjpQoIANqegwrcMVhGcAEoVBJ67yBo
7m7YmoY6vd1gI24bHTG89HkoBfiwNUW4lOA6kLlhuE+TKV2ART/jWkuEgwf1aqmh
xvg5aan/Ku0YfqAHCgn65n70dSQM3ucX2BkQ7udOHaKpLY3sAeQmrKB7I0kolber
KW4cxD4Xk6p+mxEeOkPyNysTbYYic8HcFd34zM/LbJXWn82Xu2nD5u6mYKU5mrYO
OhBYZG6y+7a9M2JdAytGbRLWhb0ocycmeL1+rB6TWrJUnYdKvKIgzqFzdMAXkc1d
Fa3wNwo6KjMK8JgYZCKbM6UBev9CaaTZgC6JMKOJXa958LDnL8gWvGuvW18iEXM=
=wPtr
-----END PGP SIGNATURE-----
</PRE>
























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000378.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
	<LI>Next message: <A HREF="000413.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#386">[ date ]</a>
              <a href="thread.html#386">[ thread ]</a>
              <a href="subject.html#386">[ subject ]</a>
              <a href="author.html#386">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
