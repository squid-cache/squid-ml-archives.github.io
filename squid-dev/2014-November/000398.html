<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Support for regex with \-escaped characters
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Support%20for%20regex%20with%20%5C-escaped%20characters&In-Reply-To=%3C546A9927.20504%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000506.html">
   <LINK REL="Next"  HREF="000453.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Support for regex with \-escaped characters</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Support%20for%20regex%20with%20%5C-escaped%20characters&In-Reply-To=%3C546A9927.20504%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Support for regex with \-escaped characters">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Nov 18 00:56:07 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000506.html">[squid-dev] Build failed in Jenkins:	3.HEAD-amd64-ubuntu-utopic-clang #11
</A></li>
        <LI>Next message: <A HREF="000453.html">[squid-dev] [PATCH] Support for regex with \-escaped characters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#398">[ date ]</a>
              <a href="thread.html#398">[ thread ]</a>
              <a href="subject.html#398">[ subject ]</a>
              <a href="author.html#398">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Since we updated the squid.conf ConfigParser it is now possible to
handle regex patterns containing quoted-pair (\-escaped) characters
properly.

This patch adds support by detecting the '\' characters as token
delimiters, and explicitly skipping the following character regardless
of whether it is a SP or not.

For now the detection is only added during parsing of regex tokens or
files.

Amos
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUapkkAAoJELJo5wb/XPRjnycIANHEE1JeAC/gnhzD2le7y9IO
yvY3zZu7LX8QixlBAj0wzO4u3ByDkS9jD3PrTXyX/tP2SKwk8D95F/IZPQbVBJG2
2LAU6Q6TW9a+7swTkxz+c5go0wZpZaIsMIwa3EvC/4oLajHX/mB3+mcCMGRMS70Y
q96xTfoeEflPOx9C7o/M56R4bWa7I1J+t5PnLqzq5KYbysmCLXeHJo7LgD+F/7lo
OIxeGFcbP4Oks3iK1K9M9vI7Nu1c10zQARg8X3iSQUoXs0l29OfFcp8p7MW3oIpo
PlW46IS0DkJOZhnxlsfRyZoJl3Zl0ocA6VK5yYHMqQlAS/iv9BuYiNWGHr+XSRQ=
=/qRU
-----END PGP SIGNATURE-----
-------------- next part --------------
=== modified file 'doc/release-notes/release-3.5.sgml'
--- doc/release-notes/release-3.5.sgml	2014-11-04 14:23:42 +0000
+++ doc/release-notes/release-3.5.sgml	2014-11-17 10:50:56 +0000
@@ -386,40 +386,45 @@
 	   slot/page size when small slot sizes are desired. The default and
 	   maximum slot size is 32KB.
 	&lt;p&gt;Removal of old rock cache dir followed by &lt;em&gt;squid -z&lt;/em&gt; is required
 	   when upgrading from earlier versions of Squid.
 	&lt;p&gt;&lt;em&gt;COSS&lt;/em&gt; storage type is formally replaced by Rock storage type.
 	   COSS storage type and all COSS specific options are removed.
 
 	&lt;tag&gt;cache_peer&lt;/tag&gt;
 	&lt;p&gt;New &lt;em&gt;standby=N&lt;/em&gt; option to retain a set of N open and unused
 	   connections to the peer at virtually all times to reduce TCP handshake
 	   delays.
 	&lt;p&gt;These connections differ from HTTP persistent connections in that they
 	   have not been used for HTTP messaging (and may never be). They may be
 	   turned into persistent connections after their first use subject to the
 	   same keep-alive critera any HTTP connection is checked for.
 	&lt;p&gt;Squid-2 option &lt;em&gt;idle=&lt;/em&gt; replaced by &lt;em&gt;standby=&lt;/em&gt;.
 	&lt;p&gt;NOTE that standby connections are started earlier and available in
 	   more circumstances than squid-2 idle connections were. They are
 	   also spread over all IPs of the peer.
 
+	&lt;tag&gt;configuration_includes_quoted_values&lt;/tag&gt;
+	&lt;p&gt;Regex expression values can not be parsed when this directive is
+	   configured to &lt;em&gt;ON&lt;/em&gt;. Instead Squid now accepts regex \-escaped
+	   characters including escaped whitespace.
+
 	&lt;tag&gt;external_acl_type&lt;/tag&gt;
 	&lt;p&gt;New format code &lt;em&gt;%ssl::&gt;sni&lt;/em&gt; to send SSL client SNI.
 	&lt;p&gt;New format code &lt;em&gt;%ssl::&lt;cert_subject&lt;/em&gt; to send SSL server certificate DN.
 	&lt;p&gt;New format code &lt;em&gt;%ssl::&lt;cert_issuer&lt;/em&gt; to send SSL server certificate issuer DN.
 	&lt;p&gt;New response kv-pair &lt;em&gt;clt_conn_tag=&lt;/em&gt; to associates a given tag with the client TCP connection.
 
 	&lt;tag&gt;forward_max_tries&lt;/tag&gt;
 	&lt;p&gt;Default value increased to &lt;em&gt;25 destinations&lt;/em&gt; to allow better
 	   contact and IPv4 failover with domains using long lists of IPv6
 	   addresses.
 
 	&lt;tag&gt;ftp_epsv&lt;/tag&gt;
 	&lt;p&gt;Converted into an Access List with allow/deny value driven by ACLs
 	   using Squid standard first line wins matching basis.
 	&lt;p&gt;The old values of &lt;em&gt;on&lt;/em&gt; and &lt;em&gt;off&lt;/em&gt; imply &lt;em&gt;allow all&lt;/em&gt;
 	    and &lt;em&gt;deny all&lt;/em&gt; respectively and are now deprecated.
 	   Do not combine use of on/off values with ACL configuration.
 
 	&lt;tag&gt;http_port&lt;/tag&gt;
 	&lt;p&gt;&lt;em&gt;protocol=&lt;/em&gt; option altered to accept protocol version details.

=== modified file 'src/ConfigParser.cc'
--- src/ConfigParser.cc	2014-11-17 10:04:18 +0000
+++ src/ConfigParser.cc	2014-11-17 11:54:55 +0000
@@ -6,40 +6,41 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;fatal.h&quot;
 #include &quot;globals.h&quot;
 
 bool ConfigParser::RecognizeQuotedValues = true;
 bool ConfigParser::StrictMode = true;
 std::stack&lt;ConfigParser::CfgFile *&gt; ConfigParser::CfgFiles;
 ConfigParser::TokenType ConfigParser::LastTokenType = ConfigParser::SimpleToken;
 const char *ConfigParser::CfgLine = NULL;
 const char *ConfigParser::CfgPos = NULL;
 std::queue&lt;char *&gt; ConfigParser::CfgLineTokens_;
 std::queue&lt;std::string&gt; ConfigParser::Undo_;
 bool ConfigParser::AllowMacros_ = false;
 bool ConfigParser::ParseQuotedOrToEol_ = false;
+bool ConfigParser::RecognizeQuotedPair_ = false;
 bool ConfigParser::PreviewMode_ = false;
 
 static const char *SQUID_ERROR_TOKEN = &quot;[invalid token]&quot;;
 
 void
 ConfigParser::destruct()
 {
     shutting_down = 1;
     if (!CfgFiles.empty()) {
         std::ostringstream message;
         CfgFile *f = CfgFiles.top();
         message &lt;&lt; &quot;Bungled &quot; &lt;&lt; f-&gt;filePath &lt;&lt; &quot; line &quot; &lt;&lt; f-&gt;lineNo &lt;&lt;
         &quot;: &quot; &lt;&lt; f-&gt;currentLine &lt;&lt; std::endl;
         CfgFiles.pop();
         delete f;
         while (!CfgFiles.empty()) {
             f = CfgFiles.top();
             message &lt;&lt; &quot; included from &quot; &lt;&lt; f-&gt;filePath &lt;&lt; &quot; line &quot; &lt;&lt;
             f-&gt;lineNo &lt;&lt; &quot;: &quot; &lt;&lt; f-&gt;currentLine &lt;&lt; std::endl;
             CfgFiles.pop();
@@ -246,44 +247,53 @@
         return NULL;
     type = ConfigParser::SimpleToken;
     nextToken += strspn(nextToken, w_space);
 
     if (*nextToken == '#')
         return NULL;
 
     if (ConfigParser::RecognizeQuotedValues &amp;&amp; (*nextToken == '&quot;' || *nextToken == '\'')) {
         type = ConfigParser::QuotedToken;
         char *token = xstrdup(UnQuote(nextToken, &amp;nextToken));
         CfgLineTokens_.push(token);
         return token;
     }
 
     const char *tokenStart = nextToken;
     const char *sep;
     if (ConfigParser::ParseQuotedOrToEol_)
         sep = &quot;\n&quot;;
     else if (!ConfigParser::RecognizeQuotedValues || *nextToken == '(')
         sep = w_space;
+    else if (ConfigParser::RecognizeQuotedPair_)
+        sep = w_space &quot;\\&quot;;
     else
         sep = w_space &quot;(&quot;;
     nextToken += strcspn(nextToken, sep);
 
+    while (ConfigParser::RecognizeQuotedPair_ &amp;&amp; *(nextToken-1) == '\\') {
+        if (*nextToken) { // do not permit \0 terminator to be escaped.
+            ++nextToken; // skip the quoted-pair (\-escaped) character
+            nextToken += strcspn(nextToken, sep);
+        }
+    }
+
     if (ConfigParser::RecognizeQuotedValues &amp;&amp; *nextToken == '(') {
         if (strncmp(tokenStart, &quot;parameters&quot;, nextToken - tokenStart) == 0)
             type = ConfigParser::FunctionParameters;
         else {
             if (PreviewMode_) {
                 char *err = xstrdup(SQUID_ERROR_TOKEN);
                 CfgLineTokens_.push(err);
                 return err;
             } else {
                 debugs(3, DBG_CRITICAL, &quot;FATAL: Unknown cfg function: &quot; &lt;&lt; tokenStart);
                 self_destruct();
             }
         }
     } else
         type = ConfigParser::SimpleToken;
 
     char *token = NULL;
     if (nextToken - tokenStart) {
         if (ConfigParser::StrictMode &amp;&amp; type == ConfigParser::SimpleToken) {
             bool tokenIsNumber = true;
@@ -415,53 +425,56 @@
     ParseQuotedOrToEol_ = false;
 
     // Assume end of current config line
     // Close all open configuration files for this config line
     while (!CfgFiles.empty()) {
         ConfigParser::CfgFile *wordfile = CfgFiles.top();
         CfgFiles.pop();
         delete wordfile;
     }
 
     return token;
 }
 
 char *
 ConfigParser::RegexStrtokFile()
 {
     if (ConfigParser::RecognizeQuotedValues) {
         debugs(3, DBG_CRITICAL, &quot;FATAL: Can not read regex expression while configuration_includes_quoted_values is enabled&quot;);
         self_destruct();
     }
+    ConfigParser::RecognizeQuotedPair_ = true;
     char * token = strtokFile();
+    ConfigParser::RecognizeQuotedPair_ = false;
     return token;
 }
 
 char *
 ConfigParser::RegexPattern()
 {
     if (ConfigParser::RecognizeQuotedValues) {
         debugs(3, DBG_CRITICAL, &quot;FATAL: Can not read regex expression while configuration_includes_quoted_values is enabled&quot;);
         self_destruct();
     }
-
+    ConfigParser::RecognizeQuotedPair_ = true;
     char * token = NextToken();
+    ConfigParser::RecognizeQuotedPair_ = false;
     return token;
 }
 
 char *
 ConfigParser::NextQuotedToken()
 {
     const bool saveRecognizeQuotedValues = ConfigParser::RecognizeQuotedValues;
     ConfigParser::RecognizeQuotedValues = true;
     char *token = NextToken();
     ConfigParser::RecognizeQuotedValues = saveRecognizeQuotedValues;
     return token;
 }
 
 const char *
 ConfigParser::QuoteString(const String &amp;var)
 {
     static String quotedStr;
     const char *s = var.termedBuf();
     bool  needQuote = false;
 

=== modified file 'src/ConfigParser.h'
--- src/ConfigParser.h	2014-09-13 13:59:43 +0000
+++ src/ConfigParser.h	2014-11-17 11:55:07 +0000
@@ -184,26 +184,27 @@
 
     /**
      * Does the real tokens parsing job: Ignore comments, unquote an
      * element if required.
      * \return the next token, or NULL if there are no available tokens in the nextToken string.
      * \param nextToken updated to point to the pos after parsed token.
      * \param type      The token type
      */
     static char *TokenParse(const char * &amp;nextToken, TokenType &amp;type);
 
     /// Wrapper method for TokenParse.
     static char *NextElement(TokenType &amp;type);
     static std::stack&lt;CfgFile *&gt; CfgFiles; ///&lt; The stack of open cfg files
     static TokenType LastTokenType; ///&lt; The type of last parsed element
     static const char *CfgLine; ///&lt; The current line to parse
     static const char *CfgPos; ///&lt; Pointer to the next element in cfgLine string
     static std::queue&lt;char *&gt; CfgLineTokens_; ///&lt; Store the list of tokens for current configuration line
     static std::queue&lt;std::string&gt; Undo_; ///&lt; The list with TokenPutBack() queued elements
     static bool AllowMacros_;
     static bool ParseQuotedOrToEol_; ///&lt; The next tokens will be handled as quoted or to_eol token
+    static bool RecognizeQuotedPair_; ///&lt; The next tokens may containing quoted-pair (\-escaped) characters
     static bool PreviewMode_; ///&lt; The next token will not poped from cfg files, will just previewd.
 };
 
 int parseConfigFile(const char *file_name);
 
 #endif /* SQUID_CONFIGPARSER_H */

-------------- next part --------------
A non-text attachment was scrubbed...
Name: bug4135_regex_parse_mk1.patch.sig
Type: application/octet-stream
Size: 287 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20141118/f801e94f/attachment.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20141118/f801e94f/attachment.obj</A>&gt;
</PRE>













































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000506.html">[squid-dev] Build failed in Jenkins:	3.HEAD-amd64-ubuntu-utopic-clang #11
</A></li>
	<LI>Next message: <A HREF="000453.html">[squid-dev] [PATCH] Support for regex with \-escaped characters
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#398">[ date ]</a>
              <a href="thread.html#398">[ thread ]</a>
              <a href="subject.html#398">[ subject ]</a>
              <a href="author.html#398">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
