<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] url_rewrite_timeout directive
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20url_rewrite_timeout%20directive&In-Reply-To=%3C546B1510.2090501%40users.sourceforge.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000386.html">
   <LINK REL="Next"  HREF="000415.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] url_rewrite_timeout directive</H1>
    <B>Tsantilas Christos</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20url_rewrite_timeout%20directive&In-Reply-To=%3C546B1510.2090501%40users.sourceforge.net%3E"
       TITLE="[squid-dev] [PATCH] url_rewrite_timeout directive">chtsanti at users.sourceforge.net
       </A><BR>
    <I>Tue Nov 18 09:44:48 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000386.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
        <LI>Next message: <A HREF="000415.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#413">[ date ]</a>
              <a href="thread.html#413">[ thread ]</a>
              <a href="subject.html#413">[ subject ]</a>
              <a href="author.html#413">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/18/2014 01:27 AM, Amos Jeffries wrote:
&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> Hash: SHA1
</I>&gt;<i>
</I>&gt;<i> On 18/11/2014 6:10 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;<i> On 11/16/2014 01:05 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On 16/11/2014 7:38 a.m., Tsantilas Christos wrote:
</I>
 &gt; ....

&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> For the record I am still extremely skeptical about the use-case
</I>&gt;&gt;&gt;<i> behind this feature. Timeout i a clear sign that the helper or
</I>&gt;&gt;&gt;<i> system behind it is broken (capacity overload / network
</I>&gt;&gt;&gt;<i> congestion). Continuing to use such systems in a way which
</I>&gt;&gt;&gt;<i> further increases network load is very often a bad choice. Hiding
</I>&gt;&gt;&gt;<i> the issue an even worse choice.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe the administrator does not care about unanswered queries.
</I>&gt;<i>
</I>&gt;<i> I posit that admin who truely do not care about unanswered questions
</I>&gt;<i> will not care enough to bother configuring this feature.
</I>
So he will not do it.
The default behaviour is to not use timeout.
The default behaviour is not changed.

&gt;<i>
</I>&gt;<i> The administrator should always care about these unanswered questions.
</I>&gt;<i> Each one means worse proxy performance. Offering to hide them silently
</I>&gt;<i> and automatically without anybody having to do any work about fixing
</I>&gt;<i> the underlying cause implies they are not actually problems. Which is
</I>&gt;<i> false implication.
</I>&gt;<i>
</I>
This option can be used to increase proxy performance. This is the 
purpose of this option.


&gt;<i>
</I>&gt;&gt;<i> Imagine a huge squid proxy, which may have to process thousands of
</I>&gt;&gt;<i> URLs per minute and the administrator decided that a 10% of helpers
</I>&gt;&gt;<i> request can fail. In this case we are giving him a way to configure
</I>&gt;&gt;<i> the squid behaviour in this case: may ignore the probelm, or use a
</I>&gt;&gt;<i> predefined answer etc
</I>&gt;<i>
</I>&gt;<i> Now that same Squid proxy suddenly starts randomly wrongly rejecting
</I>&gt;<i> just one request per minute out of all those thousands.
</I>&gt;<i>   Which one, why, and WTF can anybody do about it?
</I>
Just only requests which timed out and only if configured to do it...

&gt;<i>
</I>&gt;<i> Previous Squid would log a client request with _TIMEOUT, leave a
</I>&gt;<i> helper in Busy or Pending state with full trace of the pending lookup
</I>&gt;<i> in mgr reports, possibly even cache.log warnings about helpers queue
</I>&gt;<i> length.
</I>
The patch does not change squid behaviour, if the timeout is not 
configured (default).

&gt;<i>
</I>&gt;<i> Now all that is reduced to an overly simple aggregated &quot;Requests timed
</I>&gt;<i> out:&quot; hiding in a rarely viewed manager report and a hidden level-3
</I>&gt;<i> debug message that lists an anonymous requestId from N identical
</I>&gt;<i> requestIds spread over N helpers.
</I>&gt;<i>
</I>
IF configured you will see in mgr report a &quot;Requests timed out:&quot;  for 
each running server.
If you see that a server has many timedout requests, more than the other 
servers then you can kiil it if you consider it as a problem.


&gt;&gt;<i>
</I>&gt;&gt;<i> The reason the helper is not answered enough fast, maybe is a
</I>&gt;&gt;<i> database or an external lookup failure (for example categorized
</I>&gt;&gt;<i> urls list as a DNS service). In these cases the system admin or
</I>&gt;&gt;<i> service provider, may prefer a none answer from the helper, or a
</I>&gt;&gt;<i> preconfigured answer, instead of waiting too long for the answer.
</I>&gt;<i>
</I>&gt;<i> What to do if the internal dependencies are going badly is something
</I>&gt;<i> that should be handled *inside the helper*.
</I>&gt;<i>   After all Squid has absolutely no way to know if its generic lookup
</I>&gt;<i> helper has the DNS lookup on the DB server name or the DB query itself
</I>&gt;<i> broken. Each of which might have a different &quot;best&quot; way to respond.
</I>&gt;<i>
</I>&gt;<i> The intention of the BrokenHelper code was to have the helpers
</I>&gt;<i> explicitly inform Squid that they were in trouble and needed help
</I>&gt;<i> shifting the load elsewhere.
</I>&gt;<i>
</I>&gt;<i> Squid silently &quot;Forgetting&quot; that requests have been sent and then
</I>&gt;<i> sending *more* is a truely terrible way to fix all the cases of helper
</I>&gt;<i> overload.
</I>
Again, the timeout is optional. It is an extra option.
If the customer/squid-user, wants to use BH code, still can do it.


&gt;&gt;<i>
</I>&gt;&gt;<i> The helper can be implemented to not answer at all after a timeout
</I>&gt;&gt;<i> period. A policy of &quot;if you do not answer in a day, please do not
</I>&gt;&gt;<i> answer at all, I am not interested any mode&quot; is common in human
</I>&gt;&gt;<i> world, and in business.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yes, it is also being fingered as a major reason for businesses dying
</I>&gt;<i> off during the recent recession....
</I>
:<i>-)
</I>Well, we can do a huge discussion about the recent recession, but I am 
sure I have more examples than you on failing businesses under an 
recessionary environment!

&gt;<i>..... Late respondants lost out on work and
</I>&gt;<i> thus cashflow.
</I>
Yes but you can not avoid such cases. A stop-loss, after a reasonable 
configured timeout, is not a bad tactic in such cases.


&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> in src/cache_cf.cc
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * please move the *_url_rewrite_timeout() functions to
</I>&gt;&gt;&gt;<i> redirect.cc - that will help reduce dependency issues when we get
</I>&gt;&gt;&gt;<i> around to making the redirector config a standalone FooConfig
</I>&gt;&gt;&gt;<i> object.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Not so easy, because of dependencies on time-related parsing
</I>&gt;&gt;<i> functions.... I let it for now. If required we must move time parse
</I>&gt;&gt;<i> functions to a library file, for example Config.cc
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Pity. Oh well.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * it would be simpler and easier on users to omit the
</I>&gt;&gt;&gt;<i> &quot;on_timeout=use_configured_response response=&quot; and just have the
</I>&gt;&gt;&gt;<i> existence of a response= kv-pair imply the on_timeout action. -
</I>&gt;&gt;&gt;<i> that also allows the above suggested removal of bypass and retry
</I>&gt;&gt;&gt;<i> special actions without loosing any functionality. - that removes
</I>&gt;&gt;&gt;<i> the FATAL errors if admin gets the options ordering different
</I>&gt;&gt;&gt;<i> from what you expect. - and allows for forward-compatibility with
</I>&gt;&gt;&gt;<i> unknown options. A while loop fetching kv-pair and processing
</I>&gt;&gt;&gt;<i> them as found regardess of order seems best for a field
</I>&gt;&gt;&gt;<i> documented a &quot; [options] &quot;.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> True. This is fixed in this patch
</I>&gt;<i>
</I>&gt;<i> Added a memory leak when setting Config.onUrlRewriteTimeout.response
</I>&gt;<i> multiple times.
</I>&gt;<i>
</I>&gt;<i> Also in free_url_rewrite_timeout() use safe_free() to release and NULL
</I>&gt;<i> the pointer in one call.
</I>&gt;<i>
</I>&gt;<i> Also in dump_url_rewrite_timeout()please do not assert(). This will do
</I>&gt;<i> nasty things in SMP mode manager reports. Handle the error instead.
</I>
ok for these.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * please define the new handleAdaptationFailure() *above* the
</I>&gt;&gt;&gt;<i> new calloutsError(). - that will reduce the diff and make it
</I>&gt;&gt;&gt;<i> clearer what actually is changing and what not.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Still not doing this. It adds 40 lines to your diff when there is only
</I>&gt;<i> 5-6 lines of change.
</I>
sorry. Looks that I  forgot to do save before make the diff...

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * its now possible for adaptation error to silently continue
</I>&gt;&gt;&gt;<i> processing. Before it would hang. I am not sure that is a good or
</I>&gt;&gt;&gt;<i> bad change. But it may be worth noting the difference in
</I>&gt;&gt;&gt;<i> handleAdaptationFailure() where it not unconditionally calls
</I>&gt;&gt;&gt;<i> doCallouts() at the end.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There is not any change on handling adaptation errors, or should
</I>&gt;&gt;<i> not be. Am I loosing something?
</I>&gt;<i>
</I>&gt;<i> The new handleAdaptationFailure() runs doCallout unconditionally:
</I>&gt;<i>    ...
</I>&gt;<i>    calloutsError(ERR_ICAP_FAILURE, errDetail);
</I>&gt;<i>    doCallouts();
</I>&gt;<i>
</I>&gt;<i> The old code was:
</I>&gt;<i>   ...
</I>&gt;<i>   if (calloutContext) {
</I>&gt;<i>     ... &lt;body of new calloutsError&gt; ...
</I>&gt;<i>     doCallouts();
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The new code for calloutsError() uses the if-condition internally now.
</I>&gt;<i> But this leaves the terminal doCallouts() from
</I>&gt;<i> handleAdaptationFailure() unprotected.
</I>

I think I had check and I found that it is not possible to have 
calloutContext==NULL.
I need to put an &quot;if (calloutContext)&quot; check before call doCallouts to 
be safe.

&gt;<i>
</I>&gt;&gt;&gt;<i> in src/helper.cc:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * adding multiple double-empty lines in the chunk @195
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * helper_server::checkForTimedOutRequests() is deducting from
</I>&gt;&gt;&gt;<i> stats.pending pending. This is incorrect, the helper request is
</I>&gt;&gt;&gt;<i> still pending.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Amos, I think it is better as is.... Maybe in a point of view the
</I>&gt;&gt;<i> request is still pending, but we are not waiting an answer for this
</I>&gt;&gt;<i> request any more.
</I>&gt;<i>
</I>&gt;<i> Any helper which is obeying the helper protocol *will* still be
</I>&gt;<i> consuming resources trying to satisfy it.
</I>&gt;<i> This is what I mean by forgetting and sending more requests to the
</I>&gt;<i> helper &quot;making the overload problem worse&quot;.
</I>
Maybe we should document this behaviour in option documentation. The 
administrators who want to use timeout they have to take care of it.

&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> - your act of removing the requests from the queue invalidates
</I>&gt;&gt;&gt;<i> the logic in helperReturnBuffer() recording and managing late
</I>&gt;&gt;&gt;<i> helper responses.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> why?
</I>&gt;<i>
</I>&gt;<i> Non-concurrent helpers:
</I>&gt;<i>   * #1 query times out and gets discarded.
</I>&gt;<i>   * Lookup logics finding a helper to use see a helper without pending
</I>&gt;<i> requests and deliver a second lookup (#2).
</I>&gt;<i>   * #1 response arrives late and is used as response to the current
</I>&gt;<i> pending (#2) lookup.
</I>
This is will be discarded.
This is because the request will get new requestId before retried.  The 
old requestId is not valid any more.

&gt;<i>   * #2 response arrives and is discarded.
</I>
This is will be accepted.

&gt;<i> - --&gt; helper responses are hereafter off-by-1 until another timeout
</I>&gt;<i> makes it off-by-2 or lucky random timing makes it off-by-0 again.
</I>&gt;<i>
</I>&gt;<i> Please notice that the helpers with most common long duration lookups
</I>&gt;<i> are NTLM and Kerberos crypto validation. Which do not support
</I>&gt;<i> concurrency channels.
</I>
Yes. They can not use timeout feature.

&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> - both of the above also corrupts the mgr report content for
</I>&gt;&gt;&gt;<i> expected pending responses. By all means call (and clear) the
</I>&gt;&gt;&gt;<i> callback on a timeout but please do not remove the queue entries
</I>&gt;&gt;&gt;<i> for them until the helper actually responds to that query.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Some of the queries will never  answered. This is may result to
</I>&gt;&gt;<i> memory leaks.
</I>&gt;<i>
</I>&gt;<i> see the point I made next:
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> - if a helper gets too many un-responded queries the traffic
</I>&gt;&gt;&gt;<i> being served by it is f'ckd and we should shutdown the helper. If
</I>&gt;&gt;&gt;<i> an auto-restart does not work Manual intervention is probably
</I>&gt;&gt;&gt;<i> required from the admin to resolve why it is timing out *at
</I>&gt;&gt;&gt;<i> all*.
</I>
Yes this is true. But the admin can find out if many requests are timed 
out for a server using mgr. And then he can kill problematic server.



&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> NP: when doing a re-try we still may get a response to this
</I>&gt;&gt;&gt;<i> lookup from *either* of the helpers which have been asked for it.
</I>&gt;&gt;&gt;<i> The frst helper is in fact more likely to respond first. IMO we
</I>&gt;&gt;&gt;<i> should be taking advantage of that and leaving both helpers with
</I>&gt;&gt;&gt;<i> shared pointer which either can call+unset the callback for.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe this is good optimization. However requires some work.... We
</I>&gt;&gt;<i> can add it later if required as optimization...
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok. Please add an TODO about it at least.
</I>ok

&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Please also document clearly in the release notes that:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> A) helper-mux.pl we have been distributing for the past few years
</I>&gt;&gt;&gt;<i> to encourage use of concurrency is no longer compatible with
</I>&gt;&gt;&gt;<i> Squid. If used it will spawn up to 2^64 helpers and DoS the Squid
</I>&gt;&gt;&gt;<i> server.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What is this helper? I can not find it inside squid sources....
</I>&gt;<i>
</I>&gt;<i> Under tools/
</I>&gt;<i> <A HREF="http://wiki.squid-cache.org/Features/HelperMultiplexer">http://wiki.squid-cache.org/Features/HelperMultiplexer</A>
</I>
We need to fix this helper to work with new changes too....
OK.


&gt;&gt;&gt;<i> B) helpers utilizing arrays to handle fixed amounts of
</I>&gt;&gt;&gt;<i> concurrency channels MUST be re-written to use queues and capable
</I>&gt;&gt;&gt;<i> of handling a 64-bit int as index or they will be vulnerable to
</I>&gt;&gt;&gt;<i> buffer overrun and arbitrary memory accesses.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> OK for this
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> C) 32-bit helpers need re-writing to handle the concurrency
</I>&gt;&gt;&gt;<i> channel ID as a 64-bit integer value. If not updated they will
</I>&gt;&gt;&gt;<i> cause proxies to return unexpected results or timeout once
</I>&gt;&gt;&gt;<i> crossing the 32-bit wrap boundary. Leading to undefined behaviour
</I>&gt;&gt;&gt;<i> in the client HTTP traffic.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> OK.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> My vote on this is -0. Too many problems and still no clear
</I>&gt;&gt;&gt;<i> use-case has been described[1] for this to be a reasonable
</I>&gt;&gt;&gt;<i> addition.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> OK. I tried to do most  of the fixes you are suggested. I hope it
</I>&gt;&gt;<i> is OK.
</I>&gt;&gt;<i>
</I>
Thank you for your comments.
Regards,
    Christos


&gt;<i>
</I>&gt;<i> Amos
</I>

</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000386.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
	<LI>Next message: <A HREF="000415.html">[squid-dev] [PATCH] url_rewrite_timeout directive
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#413">[ date ]</a>
              <a href="thread.html#413">[ thread ]</a>
              <a href="subject.html#413">[ subject ]</a>
              <a href="author.html#413">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
