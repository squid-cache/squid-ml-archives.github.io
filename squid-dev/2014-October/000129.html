<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HTTP Parser upgrade
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Parser%20upgrade&In-Reply-To=%3C543D936F.2090302%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000118.html">
   <LINK REL="Next"  HREF="000130.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HTTP Parser upgrade</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Parser%20upgrade&In-Reply-To=%3C543D936F.2090302%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] HTTP Parser upgrade">rousskov at measurement-factory.com
       </A><BR>
    <I>Tue Oct 14 21:19:43 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000118.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
        <LI>Next message: <A HREF="000130.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#129">[ date ]</a>
              <a href="thread.html#129">[ thread ]</a>
              <a href="subject.html#129">[ subject ]</a>
              <a href="author.html#129">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/11/2014 02:17 PM, Amos Jeffries wrote:
&gt;<i> On 7/06/2014 4:55 a.m., Amos Jeffries wrote:
</I>&gt;&gt;<i> Latest version of the Parser-NG project branch. Since last
</I>&gt;&gt;<i> message I have dropped the copy-constructor related pieces.
</I>&gt;<i> 
</I>&gt;&gt;<i> Polygraph testing on the branch showed almost no performance 
</I>&gt;&gt;<i> impact (+0.04ms/req, -0.03% request rate). Nevertheless a half 
</I>&gt;&gt;<i> dozen points of added memory reallocate or data copy are marked
</I>&gt;&gt;<i> for future removal as the Parser-NG and SBuf improvements
</I>&gt;&gt;<i> continue.
</I>
Just to double check: Is that really 0.04ms or 40ms? The former is
beyond Polygraph precision (i.e. it is the same as &quot;zero&quot;). The latter
is a significant overhead. I hope it is the former!


&gt;<i> + * \deprecated use SBuf constructor instead */ 
</I>&gt;<i> -HttpRequestMethod::HttpRequestMethod(char const *begin, char const
</I>&gt;<i> *end) : theMethod(Http::METHOD_NONE) 
</I>&gt;<i> +HttpRequestMethod::HttpRequestMethod(char const *begin) :
</I>&gt;<i> theMethod(Http::METHOD_NONE)
</I>
Please rework this constructor into a HttpRequestMethodXXX() function
call. Otherwise, it is very difficult to spot places where it is still
being used, including in future patches. Since you are also changing
the constructor profile, it should be possible to do that replacement
directly in your patch, avoiding re-editing many files by hand.

This is especially important if this old HttpRequestMethod(char*) has
a somewhat different semantics/compliance than the new
HttpRequestMethod(SBuf).


&gt;<i> -    method = HttpRequestMethod(start, t); +    SBuf m(start,
</I>&gt;<i> start-t); // XXX: SBuf ctor allocates and data-copies. performance
</I>&gt;<i> regression. +    method = HttpRequestMethod(m);
</I>

What is the purpose of introducing this SBuf performance regression?

* If the deprecated HttpRequestMethod constructor works fine, use that
and avoid this regression while waiting for callers to pass in an SBuf.

* If the deprecated HttpRequestMethod constructor is not as good as
the new HttpRequestMethod constructor for some reason (other than SBuf
parameter itself), then should we re-implement the deprecated
HttpRequestMethod constructor to create an SBuf and then call the new
HttpRequestMethod constructor with that SBuf instead?



&gt;<i> + * or from a range of chars such as &quot;GET&quot; from &quot;GETFOOBARBAZ&quot; + * 
</I>&gt;<i> + * Assumes the s parameter contains only the method string
</I>
This description is not clear, especially because GETFOOBARBAZ does
not &quot;contain only the method string&quot; GET. The HttpRequestMethod() code
does not seem to match the documented &quot;GETFOOBARBAZ&quot; example because
it uses caseCmp(s) without any prefix size limits.


&gt;<i> +    // XXX: still check for missing method name?
</I>
Please rephrase. It is not clear what you are trying to ask here.
FWIW, the new code does handle the case of an empty method name as
well as a method name not matching any known header.


&gt;<i> const char *t = start + strcspn(start, w_space);
</I>...
&gt;<i> -    start = t + strspn(t, w_space); +    start = t + strspn(t,
</I>&gt;<i> w_space); // XXX: breaks if whitespace exists in URL
</I>
Wrong XXX? The code appears to skip the space found at t declaration
time. That is, after the declaration, &quot;t&quot; should point to either a
space character or, if there was not one in a URL, to a terminating
zero character. The XXX seems to be wrong in either case.


&gt;<i> +    SBuf url = hp-&gt;requestUri(); // use full provided URI if we
</I>&gt;<i> abort +    do { // use a loop so we can break out of it +
</I>&gt;<i> ::Parser::Tokenizer tok(url); +        if (tok.remaining()[0] ==
</I>&gt;<i> '/') +            break;
</I>
Are we guaranteed to have a non-empty URL at this point? If not, it is
unsafe to dereference its first character.


&gt;<i> +    // reject URI which are not well-formed even after the
</I>&gt;<i> processing above +    if (url[0] != '/') {
</I>
Similar concern here.


&gt;<i> -    char ipbuf[MAX_IPSTRLEN]; +    static char
</I>&gt;<i> ipbuf[MAX_IPSTRLEN];
</I>
If you are changing this, please move the declaration down, where it
is actually needed.


&gt;<i> +        static const CharacterSet authority =
</I>&gt;<i> CharacterSet(&quot;authority&quot;,&quot;-._~%:@[]!$&amp;'()*+,;=&quot;) + +
</I>&gt;<i> CharacterSet::HEXDIG + CharacterSet::ALPHA + CharacterSet::DIGIT;
</I>
Syntax error (missing &quot;+&quot; before CharacterSet::HEXDIG)? If yes, does
that imply that the above code has not been tested?


&gt;<i> +    const char *url = SBuf(hp-&gt;requestUri()).c_str();
</I>
Semantically, this returns a pointer inside the now-gone object (the
temporary anonymous SBuf). Do not do that even if it usually &quot;works&quot;
with the current SBuf implementation.


&gt;<i> -    const bool isFtp = !hp; +    const bool isFtp = (hp == NULL);
</I>
Why this change? The existing code was correct and arguably more
&quot;future proof&quot; if we start using some kind of smart pointers for &quot;hp&quot;.



&gt;<i> +    const HttpRequestMethod &amp;method = !isFtp ? hp-&gt;method() :
</I>&gt;<i> Http::METHOD_NONE; // XXX: or should this be GET ?
</I>
The answer is in the caller you modified, I think:

&gt;<i> -        clientProcessRequest(this, NULL /*parser*/,
</I>&gt;<i> context.getRaw(), -                             request-&gt;method,
</I>&gt;<i> request-&gt;http_ver); +        clientProcessRequest(this,
</I>&gt;<i> Http1::RequestParserPointer(), context.getRaw());
</I>

So it should be something like http-&gt;request-&gt;method or equivalent.
For FTP, we already have a parsed request at this point... However,
please double check that

a) you are actually using that new &quot;method&quot; variable -- it is
difficult to say by looking from the patch alone, but I see many cases
where the old &quot;method&quot; is getting replaced with &quot;hp-&gt;method()&quot;.
Perhaps all of the uses are gone now?

b) the new &quot;method&quot; declaration is as close to the uses in (a) as
possible.


&gt;<i> Http::ProtocolVersion http_ver; -        if (ClientSocketContext
</I>&gt;<i> *context = parseOneRequest(http_ver)) { +        if
</I>&gt;<i> (ClientSocketContext *context = parseOneRequest()) {
</I>
Do you still need the http_ver variable after removing the
corresponding parameter?


* clientProcessRequest() no longer consumes parsed input, right? Where
does that consumption happen now?


&gt;<i> +     * BUG: limits output to just 1KB when Squid accepts up to
</I>&gt;<i> 64KB line length. * -     * \retval -1  an error occurred.
</I>&gt;<i> request_parse_status indicates HTTP status result. -     * \retval
</I>&gt;<i> 1  successful parse. member fields contain the request-line items -
</I>&gt;<i> * \retval  0  more data is needed to complete the parse +     *
</I>&gt;<i> \return A pointer to a field-value of the first matching
</I>&gt;<i> field-name, or NULL.
</I>
In what sense does the Parser limit the output? It is documented to
return a pointer to the field-value. Are we truncating that field-value?


* Http1::Parser class has virtual methods but is missing a virtual
destructor.


&gt;<i> +    /// raw copy of the origina client reqeust-line URI field
</I>
&quot;origina&quot; typo


&gt;<i> +    Parser() : parsingStage_(HTTP_PARSE_NONE) {}
</I>
&gt;<i> +    RequestParser() : Parser() {clear();} +    virtual void
</I>&gt;<i> clear();
</I>

&gt;<i> +Http::One::Parser::clear() { -    clear(); // empty the state. -
</I>&gt;<i> state = HTTP_PARSE_NEW; -    buf = aBuf; -    bufsiz = len; -
</I>&gt;<i> debugs(74, 5, HERE &lt;&lt; &quot;Request buffer is &quot; &lt;&lt; buf); +
</I>&gt;<i> parsingStage_ = HTTP_PARSE_NONE; +    buf_ = NULL; +
</I>&gt;<i> msgProtocol_ = AnyP::ProtocolVersion(); +
</I>&gt;<i> mimeHeaderBlock_.clear(); }
</I>

&gt;<i> +void +Http::One::RequestParser::clear() +{ +
</I>&gt;<i> Http1::Parser::clear(); + +    request_parse_status =
</I>&gt;<i> Http::scNone; +    req.start = req.end = -1; +    req.m_start =
</I>&gt;<i> req.m_end = -1; +    req.u_start = req.u_end = -1; +    req.v_start
</I>&gt;<i> = req.v_end = -1; +    method_ = HttpRequestMethod(); +}
</I>

The above is OK. If you want to polish it further to avoid calling
virtual methods from constructors (which is bad style), make these
changes:

1. Initialize all members in each constructor as needed,
   without calling clear().

2. Make Parser::clear() pure, without a body.

3. In RequestParser::clear(), just do:

   *this = RequestParser();



For the proposed commit message, please add an brief explanation for
&quot;why we are doing this&quot;, in addition to the already provided &quot;what we
are doing&quot; summary.

And please make sure the commit message explicitly says that we are
adding a few potential performance regressions with this change.


Thank you,

Alex.



&gt;&gt;<i> To recap, this project so far:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Rename the HttpParser class as Http1::RequestParser and move it 
</I>&gt;&gt;<i> into the Http::One:: namespace. A base Http1::Parser class is
</I>&gt;&gt;<i> also added from which Http1::ReplyParser will also be created in
</I>&gt;&gt;<i> future work.
</I>&gt;<i> 
</I>&gt;&gt;<i> The parser API - is updated to process both the request-line and 
</I>&gt;&gt;<i> HTTP mime headers, returning a incomplete parse result until the 
</I>&gt;&gt;<i> entire header portion of the message has been received. - now 
</I>&gt;&gt;<i> contains accessor methods for retrieving the method, URI,
</I>&gt;&gt;<i> protocol, mime headers block as separate SBuf and some metrics
</I>&gt;&gt;<i> about those. - the old request_offsets structure and similar
</I>&gt;&gt;<i> offset details internal to the parsing are no longer exposed.
</I>&gt;<i> 
</I>&gt;&gt;<i> The parser is now incremental. A parser object must be created
</I>&gt;&gt;<i> (or clean() method called) for each new message. Code using the
</I>&gt;&gt;<i> parser should pass their I/O buffer to the parse(SBuf&amp;) method
</I>&gt;&gt;<i> and retrieve an updated copy of it afterwards via the
</I>&gt;&gt;<i> remaining() method.
</I>&gt;<i> 
</I>&gt;&gt;<i> Much of the code from client_side.cc parseHttpRequest() and also 
</I>&gt;&gt;<i> the header-field code from mime_headers.cc has been moved into
</I>&gt;&gt;<i> the parser classes. The client-side code now simply runs the
</I>&gt;&gt;<i> main parse() method then uses its accessors to retrieve and
</I>&gt;&gt;<i> process the parse results if it returns success.
</I>&gt;<i> 
</I>&gt;&gt;<i> The getHeaderField() method imported from mime_headers.cc has
</I>&gt;&gt;<i> been converted to simpler logics based on Tokenizer class and
</I>&gt;&gt;<i> resolving a number of bugs in its matching output.
</I>&gt;<i> 
</I>&gt;&gt;<i> A unit test for incremental parsing has been added to 
</I>&gt;&gt;<i> testHttp1Parser.
</I>&gt;<i> 
</I>&gt;&gt;<i> The HttpRequestMethod class is moved into the Http namespace and 
</I>&gt;&gt;<i> library to reduce dependencies on the parser class outside the 
</I>&gt;&gt;<i> library.
</I>&gt;<i> 
</I>&gt;&gt;<i> The HttpHeader API has been tweaked slighty to accept
</I>&gt;&gt;<i> start+length pair instead of start/end pointers.
</I>&gt;<i> 
</I>&gt;&gt;<i> Amos
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________ squid-dev mailing
</I>&gt;<i> list <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A> 
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i> 
</I>
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000118.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
	<LI>Next message: <A HREF="000130.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#129">[ date ]</a>
              <a href="thread.html#129">[ thread ]</a>
              <a href="subject.html#129">[ subject ]</a>
              <a href="author.html#129">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
