<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HTTP Parser upgrade
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Parser%20upgrade&In-Reply-To=%3C543E3FA1.6050206%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000129.html">
   <LINK REL="Next"  HREF="000153.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HTTP Parser upgrade</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Parser%20upgrade&In-Reply-To=%3C543E3FA1.6050206%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] HTTP Parser upgrade">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Oct 15 09:34:25 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000129.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
        <LI>Next message: <A HREF="000153.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#130">[ date ]</a>
              <a href="thread.html#130">[ thread ]</a>
              <a href="subject.html#130">[ subject ]</a>
              <a href="author.html#130">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 15/10/2014 10:19 a.m., Alex Rousskov wrote:
&gt;<i> On 10/11/2014 02:17 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 7/06/2014 4:55 a.m., Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> Latest version of the Parser-NG project branch. Since last 
</I>&gt;&gt;&gt;<i> message I have dropped the copy-constructor related pieces.
</I>&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> Polygraph testing on the branch showed almost no performance 
</I>&gt;&gt;&gt;<i> impact (+0.04ms/req, -0.03% request rate). Nevertheless a half
</I>&gt;&gt;&gt;<i>  dozen points of added memory reallocate or data copy are
</I>&gt;&gt;&gt;<i> marked for future removal as the Parser-NG and SBuf
</I>&gt;&gt;&gt;<i> improvements continue.
</I>&gt;<i> 
</I>&gt;<i> Just to double check: Is that really 0.04ms or 40ms? The former is 
</I>&gt;<i> beyond Polygraph precision (i.e. it is the same as &quot;zero&quot;). The
</I>&gt;<i> latter is a significant overhead. I hope it is the former!
</I>
Yes the former (insignificant).

ParserNG (Oct 11th):
Mean response number:  1925.64
Mean response time:  103.36

trunk (Oct 11th):
Mean response number:  1926.03
Mean response time:  103.34

trunk (Oct )
Mean response number:  1926.19
Mean response time:  103.33

&gt;<i> 
</I>&gt;&gt;<i> + * \deprecated use SBuf constructor instead */ 
</I>&gt;&gt;<i> -HttpRequestMethod::HttpRequestMethod(char const *begin, char
</I>&gt;&gt;<i> const *end) : theMethod(Http::METHOD_NONE) 
</I>&gt;&gt;<i> +HttpRequestMethod::HttpRequestMethod(char const *begin) : 
</I>&gt;&gt;<i> theMethod(Http::METHOD_NONE)
</I>&gt;<i> 
</I>&gt;<i> Please rework this constructor into a HttpRequestMethodXXX()
</I>&gt;<i> function call. Otherwise, it is very difficult to spot places where
</I>&gt;<i> it is still being used, including in future patches. Since you are
</I>&gt;<i> also changing the constructor profile, it should be possible to do
</I>&gt;<i> that replacement directly in your patch, avoiding re-editing many
</I>&gt;<i> files by hand.
</I>&gt;<i> 
</I>&gt;<i> This is especially important if this old HttpRequestMethod(char*)
</I>&gt;<i> has a somewhat different semantics/compliance than the new 
</I>&gt;<i> HttpRequestMethod(SBuf).
</I>&gt;<i> 
</I>
Done. This is not quite as simple as suggested, the renaming causes it
to become a method instead of constructor, so code needs adjusting to
allocate HttpRequestMethod objects separately before calling it.


&gt;<i> 
</I>&gt;&gt;<i> -    method = HttpRequestMethod(start, t); +    SBuf m(start, 
</I>&gt;&gt;<i> start-t); // XXX: SBuf ctor allocates and data-copies.
</I>&gt;&gt;<i> performance regression. +    method = HttpRequestMethod(m);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> What is the purpose of introducing this SBuf performance
</I>&gt;<i> regression?
</I>&gt;<i> 
</I>
To avoid repeated strcspn(X, w_space) over the input buffer.

&gt;<i> * If the deprecated HttpRequestMethod constructor works fine, use
</I>&gt;<i> that and avoid this regression while waiting for callers to pass in
</I>&gt;<i> an SBuf.
</I>&gt;<i> 
</I>&gt;<i> * If the deprecated HttpRequestMethod constructor is not as good
</I>&gt;<i> as the new HttpRequestMethod constructor for some reason (other
</I>&gt;<i> than SBuf parameter itself), then should we re-implement the
</I>&gt;<i> deprecated HttpRequestMethod constructor to create an SBuf and then
</I>&gt;<i> call the new HttpRequestMethod constructor with that SBuf instead?
</I>&gt;<i> 
</I>
It works fine. Done.

&gt;<i> 
</I>&gt;&gt;<i> + * or from a range of chars such as &quot;GET&quot; from &quot;GETFOOBARBAZ&quot; +
</I>&gt;&gt;<i> * + * Assumes the s parameter contains only the method string
</I>&gt;<i> 
</I>&gt;<i> This description is not clear, especially because GETFOOBARBAZ
</I>&gt;<i> does not &quot;contain only the method string&quot; GET. The
</I>&gt;<i> HttpRequestMethod() code does not seem to match the documented
</I>&gt;<i> &quot;GETFOOBARBAZ&quot; example because it uses caseCmp(s) without any
</I>&gt;<i> prefix size limits.
</I>&gt;<i> 
</I>
s is expected to contain an SBuf whose contents is *only* the chars
forming the method (buf=&quot;GET&quot;, length=3) not the &quot;FOOBARBAZ&quot; chars
which follow in the I/O buffer.

This is assumed/needs to be true whether or not the chars which
preceed or follow are the expected whitespace delimiters or some
&quot;FOOBARBAZ&quot; fluff.

How else would you write that?


&gt;<i> 
</I>&gt;&gt;<i> +    // XXX: still check for missing method name?
</I>&gt;<i> 
</I>&gt;<i> Please rephrase. It is not clear what you are trying to ask here. 
</I>&gt;<i> FWIW, the new code does handle the case of an empty method name as 
</I>&gt;<i> well as a method name not matching any known header.
</I>&gt;<i> 
</I>
That was it. Dropped.

&gt;<i> 
</I>&gt;&gt;<i> const char *t = start + strcspn(start, w_space);
</I>&gt;<i> ...
</I>&gt;&gt;<i> -    start = t + strspn(t, w_space); +    start = t + strspn(t, 
</I>&gt;&gt;<i> w_space); // XXX: breaks if whitespace exists in URL
</I>&gt;<i> 
</I>&gt;<i> Wrong XXX? The code appears to skip the space found at t
</I>&gt;<i> declaration time. That is, after the declaration, &quot;t&quot; should point
</I>&gt;<i> to either a space character or, if there was not one in a URL, to a
</I>&gt;<i> terminating zero character. The XXX seems to be wrong in either
</I>&gt;<i> case.
</I>
Er yes. mistakes strspn() for strcspn(). corrected.

&gt;<i> 
</I>&gt;&gt;<i> +    SBuf url = hp-&gt;requestUri(); // use full provided URI if we 
</I>&gt;&gt;<i> abort +    do { // use a loop so we can break out of it + 
</I>&gt;&gt;<i> ::Parser::Tokenizer tok(url); +        if (tok.remaining()[0] == 
</I>&gt;&gt;<i> '/') +            break;
</I>&gt;<i> 
</I>&gt;<i> Are we guaranteed to have a non-empty URL at this point? If not, it
</I>&gt;<i> is unsafe to dereference its first character.
</I>
Right. Using skip('/') instead with current Tokenizer guarantees.

&gt;<i> 
</I>&gt;&gt;<i> +    // reject URI which are not well-formed even after the 
</I>&gt;&gt;<i> processing above +    if (url[0] != '/') {
</I>&gt;<i> 
</I>&gt;<i> Similar concern here.
</I>&gt;<i> 
</I>
Thats an old bug in dead code, but adding isEmpty() check just for
completeness when someone gets around to makeing it non-dead.

&gt;<i> 
</I>&gt;&gt;<i> -    char ipbuf[MAX_IPSTRLEN]; +    static char 
</I>&gt;&gt;<i> ipbuf[MAX_IPSTRLEN];
</I>&gt;<i> 
</I>&gt;<i> If you are changing this, please move the declaration down, where
</I>&gt;<i> it is actually needed.
</I>&gt;<i> 
</I>
Done.

&gt;<i> 
</I>&gt;&gt;<i> +        static const CharacterSet authority = 
</I>&gt;&gt;<i> CharacterSet(&quot;authority&quot;,&quot;-._~%:@[]!$&amp;'()*+,;=&quot;) + + 
</I>&gt;&gt;<i> CharacterSet::HEXDIG + CharacterSet::ALPHA +
</I>&gt;&gt;<i> CharacterSet::DIGIT;
</I>&gt;<i> 
</I>&gt;<i> Syntax error (missing &quot;+&quot; before CharacterSet::HEXDIG)? If yes,
</I>&gt;<i> does that imply that the above code has not been tested?
</I>
It is on the end of the preceeding line.

&gt;<i> 
</I>&gt;&gt;<i> +    const char *url = SBuf(hp-&gt;requestUri()).c_str();
</I>&gt;<i> 
</I>&gt;<i> Semantically, this returns a pointer inside the now-gone object
</I>&gt;<i> (the temporary anonymous SBuf). Do not do that even if it usually
</I>&gt;<i> &quot;works&quot; with the current SBuf implementation.
</I>
Okay, using a pair of local-scope variables instead.

&gt;<i> 
</I>&gt;&gt;<i> -    const bool isFtp = !hp; +    const bool isFtp = (hp ==
</I>&gt;&gt;<i> NULL);
</I>&gt;<i> 
</I>&gt;<i> Why this change? The existing code was correct and arguably more 
</I>&gt;<i> &quot;future proof&quot; if we start using some kind of smart pointers for
</I>&gt;<i> &quot;hp&quot;.
</I>&gt;<i> 
</I>
Just consistency between X==NULL and X!=NULL checks.

hp is already a smart pointer in the branch and being non-C++11 it
does not provide operator true(), just operator !(). So we end up with
a mix of if(!X) and if(X != NULL).

Reverting since it was the other way to start with.


&gt;<i> 
</I>&gt;&gt;<i> +    const HttpRequestMethod &amp;method = !isFtp ? hp-&gt;method() : 
</I>&gt;&gt;<i> Http::METHOD_NONE; // XXX: or should this be GET ?
</I>&gt;<i> 
</I>&gt;<i> The answer is in the caller you modified, I think:
</I>&gt;<i> 
</I>&gt;&gt;<i> -        clientProcessRequest(this, NULL /*parser*/, 
</I>&gt;&gt;<i> context.getRaw(), -                             request-&gt;method, 
</I>&gt;&gt;<i> request-&gt;http_ver); +        clientProcessRequest(this, 
</I>&gt;&gt;<i> Http1::RequestParserPointer(), context.getRaw());
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> So it should be something like http-&gt;request-&gt;method or
</I>&gt;<i> equivalent. For FTP, we already have a parsed request at this
</I>&gt;<i> point... However, please double check that
</I>&gt;<i> 
</I>&gt;<i> a) you are actually using that new &quot;method&quot; variable -- it is 
</I>&gt;<i> difficult to say by looking from the patch alone, but I see many
</I>&gt;<i> cases where the old &quot;method&quot; is getting replaced with
</I>&gt;<i> &quot;hp-&gt;method()&quot;. Perhaps all of the uses are gone now?
</I>&gt;<i> 
</I>&gt;<i> b) the new &quot;method&quot; declaration is as close to the uses in (a) as 
</I>&gt;<i> possible.
</I>&gt;<i> 
</I>
Confirmed. It looks like the HTTP-only paths should all be using
hp-&gt;method(), the shared and FTP-only paths using request-&gt;method.

Removing method local.

&gt;<i> 
</I>&gt;&gt;<i> Http::ProtocolVersion http_ver; -        if (ClientSocketContext 
</I>&gt;&gt;<i> *context = parseOneRequest(http_ver)) { +        if 
</I>&gt;&gt;<i> (ClientSocketContext *context = parseOneRequest()) {
</I>&gt;<i> 
</I>&gt;<i> Do you still need the http_ver variable after removing the 
</I>&gt;<i> corresponding parameter?
</I>&gt;<i> 
</I>
No. Dropped.

&gt;<i> 
</I>&gt;<i> * clientProcessRequest() no longer consumes parsed input, right?
</I>&gt;<i> Where does that consumption happen now?
</I>&gt;<i> 
</I>
Inside parseOneRequest().

 * HttpServer syncs the I/O buffer to the Tokenizer in
parseHttpRequest() after each parse attempt.

 * FtpServer uses byte counting by the Tokenizer to manage them
separately with consumeInput().

&gt;<i> 
</I>&gt;&gt;<i> +     * BUG: limits output to just 1KB when Squid accepts up to 
</I>&gt;&gt;<i> 64KB line length. * -     * \retval -1  an error occurred. 
</I>&gt;&gt;<i> request_parse_status indicates HTTP status result. -     *
</I>&gt;&gt;<i> \retval 1  successful parse. member fields contain the
</I>&gt;&gt;<i> request-line items - * \retval  0  more data is needed to
</I>&gt;&gt;<i> complete the parse +     * \return A pointer to a field-value of
</I>&gt;&gt;<i> the first matching field-name, or NULL.
</I>&gt;<i> 
</I>&gt;<i> In what sense does the Parser limit the output? It is documented
</I>&gt;<i> to return a pointer to the field-value. Are we truncating that
</I>&gt;<i> field-value?
</I>&gt;<i> 
</I>
Copying it into a static array of size 1KB.

...
// arbitrary maximum-length for headers which can be found by
Http1Parser::getHeaderField()
#define GET_HDR_SZ      1024

...
    LOCAL_ARRAY(char, header, GET_HDR_SZ);


For this patching I have left that old limit in place. It appears to
be only used for a few things like Host: header value fetching in the
prepare*URL() functions, so not a problem for most users.


&gt;<i> 
</I>&gt;<i> * Http1::Parser class has virtual methods but is missing a virtual 
</I>&gt;<i> destructor.
</I>&gt;<i> 
</I>
Gah. C++11'ism. Default d'tor can be assumed virtual and the children
provide the virtuals.

&gt;<i> 
</I>&gt;&gt;<i> +    /// raw copy of the origina client reqeust-line URI field
</I>&gt;<i> 
</I>&gt;<i> &quot;origina&quot; typo
</I>&gt;<i> 
</I>
Fixed.

&gt;<i> 
</I>&gt;&gt;<i> +    Parser() : parsingStage_(HTTP_PARSE_NONE) {}
</I>&gt;<i> 
</I>&gt;&gt;<i> +    RequestParser() : Parser() {clear();} +    virtual void 
</I>&gt;&gt;<i> clear();
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +Http::One::Parser::clear() { -    clear(); // empty the state.
</I>&gt;&gt;<i> - state = HTTP_PARSE_NEW; -    buf = aBuf; -    bufsiz = len; - 
</I>&gt;&gt;<i> debugs(74, 5, HERE &lt;&lt; &quot;Request buffer is &quot; &lt;&lt; buf); + 
</I>&gt;&gt;<i> parsingStage_ = HTTP_PARSE_NONE; +    buf_ = NULL; + msgProtocol_
</I>&gt;&gt;<i> = AnyP::ProtocolVersion(); + mimeHeaderBlock_.clear(); }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +void +Http::One::RequestParser::clear() +{ + 
</I>&gt;&gt;<i> Http1::Parser::clear(); + +    request_parse_status = 
</I>&gt;&gt;<i> Http::scNone; +    req.start = req.end = -1; +    req.m_start = 
</I>&gt;&gt;<i> req.m_end = -1; +    req.u_start = req.u_end = -1; +
</I>&gt;&gt;<i> req.v_start = req.v_end = -1; +    method_ = HttpRequestMethod();
</I>&gt;&gt;<i> +}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The above is OK. If you want to polish it further to avoid calling 
</I>&gt;<i> virtual methods from constructors (which is bad style), make these 
</I>&gt;<i> changes:
</I>&gt;<i> 
</I>&gt;<i> 1. Initialize all members in each constructor as needed, without
</I>&gt;<i> calling clear().
</I>&gt;<i> 
</I>&gt;<i> 2. Make Parser::clear() pure, without a body.
</I>&gt;<i> 
</I>&gt;<i> 3. In RequestParser::clear(), just do:
</I>&gt;<i> 
</I>&gt;<i> *this = RequestParser();
</I>&gt;<i> 
</I>
I'm never sure during this sequence if complex types like SBuf need an
explicit call to their constructor at step (1) to free old
smart-pointer values or not.

Trying it this way.

&gt;<i> 
</I>&gt;<i> For the proposed commit message, please add an brief explanation
</I>&gt;<i> for &quot;why we are doing this&quot;, in addition to the already provided
</I>&gt;<i> &quot;what we are doing&quot; summary.
</I>&gt;<i> 
</I>&gt;<i> And please make sure the commit message explicitly says that we
</I>&gt;<i> are adding a few potential performance regressions with this
</I>&gt;<i> change.
</I>
Is that a +1 considering these are mostly cosmetic?

Amos

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUPj+hAAoJELJo5wb/XPRjG+8H/06I959LgxkJtMCq08npL/p6
+W8fsz7SWh5C6NwFzTCyonF6CCwQF7RBWxbXMaDq/RknMSyYGy7pwn+7JhNQz9TM
16I3HnP8cSheL0TDub8DlVHVIqiKW0gE12Z4F86j21YO/EqkGJuK7sZoXoePPu7w
2eMW4xg1NjsS0dbD1HJp1BRw3QUkZg30oenWhWRQbpWn3lTlEXPKOXZJxf/eILEN
q8yX9BYmTVM7Zt9ZNlU0lIfzhXTwZkaibZ4+MNpqfjyjLhVYZ77leY5Sn4xCVlr1
ERW+u4ap8HeB4oDMoP/GRchuF9GqTlSjx6hvxmWMtbxjaISUO0W7Twz5XVTfJLs=
=uro/
-----END PGP SIGNATURE-----
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000129.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
	<LI>Next message: <A HREF="000153.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#130">[ date ]</a>
              <a href="thread.html#130">[ thread ]</a>
              <a href="subject.html#130">[ subject ]</a>
              <a href="author.html#130">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
