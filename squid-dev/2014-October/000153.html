<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HTTP Parser upgrade
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Parser%20upgrade&In-Reply-To=%3C543FC7D8.4090401%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000130.html">
   <LINK REL="Next"  HREF="000111.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HTTP Parser upgrade</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Parser%20upgrade&In-Reply-To=%3C543FC7D8.4090401%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] HTTP Parser upgrade">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Oct 16 13:27:52 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000130.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
        <LI>Next message: <A HREF="000111.html">[squid-dev] Build failed in Jenkins: anybranch-wholefarm-matrix Â» clang,rs-ubuntu-saucy #85
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#153">[ date ]</a>
              <a href="thread.html#153">[ thread ]</a>
              <a href="subject.html#153">[ subject ]</a>
              <a href="author.html#153">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>(if there are no objections this will be applied in a couple of days)


This update is to lay the groundwork for several planned future projects
implementing protocol specific parsers, seperating the currently
intertwinned client connection management and HTTP protocol parsing
logics, and for zero-copy processing of transactions using SBuf.


This patch renames the HttpParser class as RequestParser and moves it
into the Http::One:: namespace as child of an Http::Parser class with
generic API accessors for shared use by other HTTP message parsers.

The class API
 - is updated to process both the request-line and HTTP mime headers,
returning an incomplete parse result until the entire headers parts of
the message have been received.
 - now contains accessor methods for retrieving the method, URI,
protocol, mime headers block (as an SBuf) and some metrics about those.
 - the old request_offsets structure and similar offset details are no
longer exposed.
 - now emits 414 and 431 HTTP status codes as appropriate.

The parser is made partially incremental and some use of Tokenizer is
added for faster parsing. There is more that can be done to further
speed up parsing of slow or very large requests.

Much of the code from client_side.cc parseHttpRequest() and also the
header-field code from mime_headers.cc has been moved into the parser
class. The client_side.cc code now simply runs the main
Http1::RequestParser::parse() method then uses accessors to retrieve
and process the parse results.

A unit test for incremental parsing has been added to testHttpParser.

Also, the HttpRequestMethod class is moved into the Http:: namespace and
library to reduce dependencies on the parser class outside the library.


The gains made so far from incremental parse, reducing parser passes and
zero-copy SBuf are offset by several temporary performance regressions
added converting SBuf for legacy code use. These are marked for later
removal.


Amos




On 15/10/2014 10:34 p.m., Amos Jeffries wrote:
&gt;<i> On 15/10/2014 10:19 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 10/11/2014 02:17 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 7/06/2014 4:55 a.m., Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> Latest version of the Parser-NG project branch. Since last 
</I>&gt;&gt;&gt;&gt;<i> message I have dropped the copy-constructor related pieces.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Polygraph testing on the branch showed almost no performance 
</I>&gt;&gt;&gt;&gt;<i> impact (+0.04ms/req, -0.03% request rate). Nevertheless a half
</I>&gt;&gt;&gt;&gt;<i>  dozen points of added memory reallocate or data copy are
</I>&gt;&gt;&gt;&gt;<i> marked for future removal as the Parser-NG and SBuf
</I>&gt;&gt;&gt;&gt;<i> improvements continue.
</I>&gt;<i> 
</I>&gt;&gt;<i> Just to double check: Is that really 0.04ms or 40ms? The former is 
</I>&gt;&gt;<i> beyond Polygraph precision (i.e. it is the same as &quot;zero&quot;). The
</I>&gt;&gt;<i> latter is a significant overhead. I hope it is the former!
</I>&gt;<i> 
</I>&gt;<i> Yes the former (insignificant).
</I>&gt;<i> 
</I>&gt;<i> ParserNG (Oct 11th):
</I>&gt;<i> Mean response number:  1925.64
</I>&gt;<i> Mean response time:  103.36
</I>&gt;<i> 
</I>&gt;<i> trunk (Oct 11th):
</I>&gt;<i> Mean response number:  1926.03
</I>&gt;<i> Mean response time:  103.34
</I>&gt;<i> 
</I>&gt;<i> trunk (Oct )
</I>&gt;<i> Mean response number:  1926.19
</I>&gt;<i> Mean response time:  103.33
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> + * \deprecated use SBuf constructor instead */ 
</I>&gt;&gt;&gt;<i> -HttpRequestMethod::HttpRequestMethod(char const *begin, char
</I>&gt;&gt;&gt;<i> const *end) : theMethod(Http::METHOD_NONE) 
</I>&gt;&gt;&gt;<i> +HttpRequestMethod::HttpRequestMethod(char const *begin) : 
</I>&gt;&gt;&gt;<i> theMethod(Http::METHOD_NONE)
</I>&gt;<i> 
</I>&gt;&gt;<i> Please rework this constructor into a HttpRequestMethodXXX()
</I>&gt;&gt;<i> function call. Otherwise, it is very difficult to spot places where
</I>&gt;&gt;<i> it is still being used, including in future patches. Since you are
</I>&gt;&gt;<i> also changing the constructor profile, it should be possible to do
</I>&gt;&gt;<i> that replacement directly in your patch, avoiding re-editing many
</I>&gt;&gt;<i> files by hand.
</I>&gt;<i> 
</I>&gt;&gt;<i> This is especially important if this old HttpRequestMethod(char*)
</I>&gt;&gt;<i> has a somewhat different semantics/compliance than the new 
</I>&gt;&gt;<i> HttpRequestMethod(SBuf).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Done. This is not quite as simple as suggested, the renaming causes it
</I>&gt;<i> to become a method instead of constructor, so code needs adjusting to
</I>&gt;<i> allocate HttpRequestMethod objects separately before calling it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> -    method = HttpRequestMethod(start, t); +    SBuf m(start, 
</I>&gt;&gt;&gt;<i> start-t); // XXX: SBuf ctor allocates and data-copies.
</I>&gt;&gt;&gt;<i> performance regression. +    method = HttpRequestMethod(m);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> What is the purpose of introducing this SBuf performance
</I>&gt;&gt;<i> regression?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> To avoid repeated strcspn(X, w_space) over the input buffer.
</I>&gt;<i> 
</I>&gt;&gt;<i> * If the deprecated HttpRequestMethod constructor works fine, use
</I>&gt;&gt;<i> that and avoid this regression while waiting for callers to pass in
</I>&gt;&gt;<i> an SBuf.
</I>&gt;<i> 
</I>&gt;&gt;<i> * If the deprecated HttpRequestMethod constructor is not as good
</I>&gt;&gt;<i> as the new HttpRequestMethod constructor for some reason (other
</I>&gt;&gt;<i> than SBuf parameter itself), then should we re-implement the
</I>&gt;&gt;<i> deprecated HttpRequestMethod constructor to create an SBuf and then
</I>&gt;&gt;<i> call the new HttpRequestMethod constructor with that SBuf instead?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It works fine. Done.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> + * or from a range of chars such as &quot;GET&quot; from &quot;GETFOOBARBAZ&quot; +
</I>&gt;&gt;&gt;<i> * + * Assumes the s parameter contains only the method string
</I>&gt;<i> 
</I>&gt;&gt;<i> This description is not clear, especially because GETFOOBARBAZ
</I>&gt;&gt;<i> does not &quot;contain only the method string&quot; GET. The
</I>&gt;&gt;<i> HttpRequestMethod() code does not seem to match the documented
</I>&gt;&gt;<i> &quot;GETFOOBARBAZ&quot; example because it uses caseCmp(s) without any
</I>&gt;&gt;<i> prefix size limits.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> s is expected to contain an SBuf whose contents is *only* the chars
</I>&gt;<i> forming the method (buf=&quot;GET&quot;, length=3) not the &quot;FOOBARBAZ&quot; chars
</I>&gt;<i> which follow in the I/O buffer.
</I>&gt;<i> 
</I>&gt;<i> This is assumed/needs to be true whether or not the chars which
</I>&gt;<i> preceed or follow are the expected whitespace delimiters or some
</I>&gt;<i> &quot;FOOBARBAZ&quot; fluff.
</I>&gt;<i> 
</I>&gt;<i> How else would you write that?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    // XXX: still check for missing method name?
</I>&gt;<i> 
</I>&gt;&gt;<i> Please rephrase. It is not clear what you are trying to ask here. 
</I>&gt;&gt;<i> FWIW, the new code does handle the case of an empty method name as 
</I>&gt;&gt;<i> well as a method name not matching any known header.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> That was it. Dropped.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> const char *t = start + strcspn(start, w_space);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> -    start = t + strspn(t, w_space); +    start = t + strspn(t, 
</I>&gt;&gt;&gt;<i> w_space); // XXX: breaks if whitespace exists in URL
</I>&gt;<i> 
</I>&gt;&gt;<i> Wrong XXX? The code appears to skip the space found at t
</I>&gt;&gt;<i> declaration time. That is, after the declaration, &quot;t&quot; should point
</I>&gt;&gt;<i> to either a space character or, if there was not one in a URL, to a
</I>&gt;&gt;<i> terminating zero character. The XXX seems to be wrong in either
</I>&gt;&gt;<i> case.
</I>&gt;<i> 
</I>&gt;<i> Er yes. mistakes strspn() for strcspn(). corrected.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    SBuf url = hp-&gt;requestUri(); // use full provided URI if we 
</I>&gt;&gt;&gt;<i> abort +    do { // use a loop so we can break out of it + 
</I>&gt;&gt;&gt;<i> ::Parser::Tokenizer tok(url); +        if (tok.remaining()[0] == 
</I>&gt;&gt;&gt;<i> '/') +            break;
</I>&gt;<i> 
</I>&gt;&gt;<i> Are we guaranteed to have a non-empty URL at this point? If not, it
</I>&gt;&gt;<i> is unsafe to dereference its first character.
</I>&gt;<i> 
</I>&gt;<i> Right. Using skip('/') instead with current Tokenizer guarantees.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    // reject URI which are not well-formed even after the 
</I>&gt;&gt;&gt;<i> processing above +    if (url[0] != '/') {
</I>&gt;<i> 
</I>&gt;&gt;<i> Similar concern here.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Thats an old bug in dead code, but adding isEmpty() check just for
</I>&gt;<i> completeness when someone gets around to makeing it non-dead.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> -    char ipbuf[MAX_IPSTRLEN]; +    static char 
</I>&gt;&gt;&gt;<i> ipbuf[MAX_IPSTRLEN];
</I>&gt;<i> 
</I>&gt;&gt;<i> If you are changing this, please move the declaration down, where
</I>&gt;&gt;<i> it is actually needed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Done.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +        static const CharacterSet authority = 
</I>&gt;&gt;&gt;<i> CharacterSet(&quot;authority&quot;,&quot;-._~%:@[]!$&amp;'()*+,;=&quot;) + + 
</I>&gt;&gt;&gt;<i> CharacterSet::HEXDIG + CharacterSet::ALPHA +
</I>&gt;&gt;&gt;<i> CharacterSet::DIGIT;
</I>&gt;<i> 
</I>&gt;&gt;<i> Syntax error (missing &quot;+&quot; before CharacterSet::HEXDIG)? If yes,
</I>&gt;&gt;<i> does that imply that the above code has not been tested?
</I>&gt;<i> 
</I>&gt;<i> It is on the end of the preceeding line.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    const char *url = SBuf(hp-&gt;requestUri()).c_str();
</I>&gt;<i> 
</I>&gt;&gt;<i> Semantically, this returns a pointer inside the now-gone object
</I>&gt;&gt;<i> (the temporary anonymous SBuf). Do not do that even if it usually
</I>&gt;&gt;<i> &quot;works&quot; with the current SBuf implementation.
</I>&gt;<i> 
</I>&gt;<i> Okay, using a pair of local-scope variables instead.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> -    const bool isFtp = !hp; +    const bool isFtp = (hp ==
</I>&gt;&gt;&gt;<i> NULL);
</I>&gt;<i> 
</I>&gt;&gt;<i> Why this change? The existing code was correct and arguably more 
</I>&gt;&gt;<i> &quot;future proof&quot; if we start using some kind of smart pointers for
</I>&gt;&gt;<i> &quot;hp&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Just consistency between X==NULL and X!=NULL checks.
</I>&gt;<i> 
</I>&gt;<i> hp is already a smart pointer in the branch and being non-C++11 it
</I>&gt;<i> does not provide operator true(), just operator !(). So we end up with
</I>&gt;<i> a mix of if(!X) and if(X != NULL).
</I>&gt;<i> 
</I>&gt;<i> Reverting since it was the other way to start with.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    const HttpRequestMethod &amp;method = !isFtp ? hp-&gt;method() : 
</I>&gt;&gt;&gt;<i> Http::METHOD_NONE; // XXX: or should this be GET ?
</I>&gt;<i> 
</I>&gt;&gt;<i> The answer is in the caller you modified, I think:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> -        clientProcessRequest(this, NULL /*parser*/, 
</I>&gt;&gt;&gt;<i> context.getRaw(), -                             request-&gt;method, 
</I>&gt;&gt;&gt;<i> request-&gt;http_ver); +        clientProcessRequest(this, 
</I>&gt;&gt;&gt;<i> Http1::RequestParserPointer(), context.getRaw());
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> So it should be something like http-&gt;request-&gt;method or
</I>&gt;&gt;<i> equivalent. For FTP, we already have a parsed request at this
</I>&gt;&gt;<i> point... However, please double check that
</I>&gt;<i> 
</I>&gt;&gt;<i> a) you are actually using that new &quot;method&quot; variable -- it is 
</I>&gt;&gt;<i> difficult to say by looking from the patch alone, but I see many
</I>&gt;&gt;<i> cases where the old &quot;method&quot; is getting replaced with
</I>&gt;&gt;<i> &quot;hp-&gt;method()&quot;. Perhaps all of the uses are gone now?
</I>&gt;<i> 
</I>&gt;&gt;<i> b) the new &quot;method&quot; declaration is as close to the uses in (a) as 
</I>&gt;&gt;<i> possible.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Confirmed. It looks like the HTTP-only paths should all be using
</I>&gt;<i> hp-&gt;method(), the shared and FTP-only paths using request-&gt;method.
</I>&gt;<i> 
</I>&gt;<i> Removing method local.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Http::ProtocolVersion http_ver; -        if (ClientSocketContext 
</I>&gt;&gt;&gt;<i> *context = parseOneRequest(http_ver)) { +        if 
</I>&gt;&gt;&gt;<i> (ClientSocketContext *context = parseOneRequest()) {
</I>&gt;<i> 
</I>&gt;&gt;<i> Do you still need the http_ver variable after removing the 
</I>&gt;&gt;<i> corresponding parameter?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> No. Dropped.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> * clientProcessRequest() no longer consumes parsed input, right?
</I>&gt;&gt;<i> Where does that consumption happen now?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Inside parseOneRequest().
</I>&gt;<i> 
</I>&gt;<i>  * HttpServer syncs the I/O buffer to the Tokenizer in
</I>&gt;<i> parseHttpRequest() after each parse attempt.
</I>&gt;<i> 
</I>&gt;<i>  * FtpServer uses byte counting by the Tokenizer to manage them
</I>&gt;<i> separately with consumeInput().
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +     * BUG: limits output to just 1KB when Squid accepts up to 
</I>&gt;&gt;&gt;<i> 64KB line length. * -     * \retval -1  an error occurred. 
</I>&gt;&gt;&gt;<i> request_parse_status indicates HTTP status result. -     *
</I>&gt;&gt;&gt;<i> \retval 1  successful parse. member fields contain the
</I>&gt;&gt;&gt;<i> request-line items - * \retval  0  more data is needed to
</I>&gt;&gt;&gt;<i> complete the parse +     * \return A pointer to a field-value of
</I>&gt;&gt;&gt;<i> the first matching field-name, or NULL.
</I>&gt;<i> 
</I>&gt;&gt;<i> In what sense does the Parser limit the output? It is documented
</I>&gt;&gt;<i> to return a pointer to the field-value. Are we truncating that
</I>&gt;&gt;<i> field-value?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Copying it into a static array of size 1KB.
</I>&gt;<i> 
</I>&gt;<i> ...
</I>&gt;<i> // arbitrary maximum-length for headers which can be found by
</I>&gt;<i> Http1Parser::getHeaderField()
</I>&gt;<i> #define GET_HDR_SZ      1024
</I>&gt;<i> 
</I>&gt;<i> ...
</I>&gt;<i>     LOCAL_ARRAY(char, header, GET_HDR_SZ);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> For this patching I have left that old limit in place. It appears to
</I>&gt;<i> be only used for a few things like Host: header value fetching in the
</I>&gt;<i> prepare*URL() functions, so not a problem for most users.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> * Http1::Parser class has virtual methods but is missing a virtual 
</I>&gt;&gt;<i> destructor.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Gah. C++11'ism. Default d'tor can be assumed virtual and the children
</I>&gt;<i> provide the virtuals.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    /// raw copy of the origina client reqeust-line URI field
</I>&gt;<i> 
</I>&gt;&gt;<i> &quot;origina&quot; typo
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Fixed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    Parser() : parsingStage_(HTTP_PARSE_NONE) {}
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    RequestParser() : Parser() {clear();} +    virtual void 
</I>&gt;&gt;&gt;<i> clear();
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +Http::One::Parser::clear() { -    clear(); // empty the state.
</I>&gt;&gt;&gt;<i> - state = HTTP_PARSE_NEW; -    buf = aBuf; -    bufsiz = len; - 
</I>&gt;&gt;&gt;<i> debugs(74, 5, HERE &lt;&lt; &quot;Request buffer is &quot; &lt;&lt; buf); + 
</I>&gt;&gt;&gt;<i> parsingStage_ = HTTP_PARSE_NONE; +    buf_ = NULL; + msgProtocol_
</I>&gt;&gt;&gt;<i> = AnyP::ProtocolVersion(); + mimeHeaderBlock_.clear(); }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +void +Http::One::RequestParser::clear() +{ + 
</I>&gt;&gt;&gt;<i> Http1::Parser::clear(); + +    request_parse_status = 
</I>&gt;&gt;&gt;<i> Http::scNone; +    req.start = req.end = -1; +    req.m_start = 
</I>&gt;&gt;&gt;<i> req.m_end = -1; +    req.u_start = req.u_end = -1; +
</I>&gt;&gt;&gt;<i> req.v_start = req.v_end = -1; +    method_ = HttpRequestMethod();
</I>&gt;&gt;&gt;<i> +}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> The above is OK. If you want to polish it further to avoid calling 
</I>&gt;&gt;<i> virtual methods from constructors (which is bad style), make these 
</I>&gt;&gt;<i> changes:
</I>&gt;<i> 
</I>&gt;&gt;<i> 1. Initialize all members in each constructor as needed, without
</I>&gt;&gt;<i> calling clear().
</I>&gt;<i> 
</I>&gt;&gt;<i> 2. Make Parser::clear() pure, without a body.
</I>&gt;<i> 
</I>&gt;&gt;<i> 3. In RequestParser::clear(), just do:
</I>&gt;<i> 
</I>&gt;&gt;<i> *this = RequestParser();
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I'm never sure during this sequence if complex types like SBuf need an
</I>&gt;<i> explicit call to their constructor at step (1) to free old
</I>&gt;<i> smart-pointer values or not.
</I>&gt;<i> 
</I>&gt;<i> Trying it this way.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> For the proposed commit message, please add an brief explanation
</I>&gt;&gt;<i> for &quot;why we are doing this&quot;, in addition to the already provided
</I>&gt;&gt;<i> &quot;what we are doing&quot; summary.
</I>&gt;<i> 
</I>&gt;&gt;<i> And please make sure the commit message explicitly says that we
</I>&gt;&gt;<i> are adding a few potential performance regressions with this
</I>&gt;&gt;<i> change.
</I>&gt;<i> 
</I>&gt;<i> Is that a +1 considering these are mostly cosmetic?
</I>&gt;<i> 
</I>&gt;<i> Amos
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i> 
</I>
-------------- next part --------------
=== modified file 'configure.ac'
--- configure.ac	2014-10-13 14:40:35 +0000
+++ configure.ac	2014-10-16 12:13:18 +0000
@@ -3766,40 +3766,41 @@
 	src/base/Makefile
 	src/acl/Makefile
 	src/clients/Makefile
 	src/servers/Makefile
 	src/fs/Makefile
 	src/repl/Makefile
 	src/auth/Makefile
 	src/auth/basic/Makefile
 	src/auth/digest/Makefile
 	src/auth/negotiate/Makefile
 	src/auth/ntlm/Makefile
 	src/adaptation/Makefile
 	src/adaptation/icap/Makefile
 	src/adaptation/ecap/Makefile
 	src/comm/Makefile
 	src/esi/Makefile
 	src/eui/Makefile
 	src/format/Makefile
 	src/helper/Makefile
 	src/http/Makefile
+	src/http/one/Makefile
 	src/icmp/Makefile
 	src/ident/Makefile
 	src/ip/Makefile
 	src/log/Makefile
 	src/ipc/Makefile
 	src/ssl/Makefile
 	src/mgr/Makefile
 	src/parser/Makefile
 	src/snmp/Makefile
 	contrib/Makefile
 	icons/Makefile
 	errors/Makefile
 	test-suite/Makefile
 	doc/Makefile
 	doc/manuals/Makefile
 	helpers/Makefile
 	helpers/basic_auth/Makefile
 	helpers/basic_auth/DB/Makefile
 	helpers/basic_auth/fake/Makefile
 	helpers/basic_auth/getpwnam/Makefile

=== modified file 'src/AccessLogEntry.h'
--- src/AccessLogEntry.h	2014-09-29 05:13:17 +0000
+++ src/AccessLogEntry.h	2014-10-05 10:43:33 +0000
@@ -1,38 +1,38 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPACCESSLOGENTRY_H
 #define SQUID_HTTPACCESSLOGENTRY_H
 
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;base/RefCount.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;HierarchyLogEntry.h&quot;
 #include &quot;http/ProtocolVersion.h&quot;
 #include &quot;HttpHeader.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;icp_opcode.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;LogTags.h&quot;
 #include &quot;MessageSizes.h&quot;
 #include &quot;Notes.h&quot;
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/Elements.h&quot;
 #endif
 #if USE_OPENSSL
 #include &quot;ssl/gadgets.h&quot;
 #endif
 
 /* forward decls */
 class HttpReply;
 class HttpRequest;
 class CustomLog;
 
 class AccessLogEntry: public RefCountable
 {
 

=== modified file 'src/HttpHeader.cc'
--- src/HttpHeader.cc	2014-09-13 13:59:43 +0000
+++ src/HttpHeader.cc	2014-09-14 12:23:03 +0000
@@ -564,188 +564,189 @@
         /* deny bad guys (ok to check for HDR_OTHER) here */
 
         if (denied_mask &amp;&amp; CBIT_TEST(*denied_mask, e-&gt;id))
             continue;
 
         debugs(55, 7, &quot;Updating header '&quot; &lt;&lt; HeadersAttrs[e-&gt;id].name &lt;&lt; &quot;' in cached entry&quot;);
 
         addEntry(e-&gt;clone());
     }
 }
 
 /* just handy in parsing: resets and returns false */
 int
 HttpHeader::reset()
 {
     clean();
     return 0;
 }
 
 int
-HttpHeader::parse(const char *header_start, const char *header_end)
+HttpHeader::parse(const char *header_start, size_t hdrLen)
 {
     const char *field_ptr = header_start;
+    const char *header_end = header_start + hdrLen; // XXX: remove
     HttpHeaderEntry *e, *e2;
     int warnOnError = (Config.onoff.relaxed_header_parser &lt;= 0 ? DBG_IMPORTANT : 2);
 
     PROF_start(HttpHeaderParse);
 
     assert(header_start &amp;&amp; header_end);
-    debugs(55, 7, &quot;parsing hdr: (&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl &lt;&lt; getStringPrefix(header_start, header_end));
+    debugs(55, 7, &quot;parsing hdr: (&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl &lt;&lt; getStringPrefix(header_start, hdrLen));
     ++ HttpHeaderStats[owner].parsedCount;
 
     char *nulpos;
-    if ((nulpos = (char*)memchr(header_start, '\0', header_end - header_start))) {
+    if ((nulpos = (char*)memchr(header_start, '\0', hdrLen))) {
         debugs(55, DBG_IMPORTANT, &quot;WARNING: HTTP header contains NULL characters {&quot; &lt;&lt;
-               getStringPrefix(header_start, nulpos) &lt;&lt; &quot;}\nNULL\n{&quot; &lt;&lt; getStringPrefix(nulpos+1, header_end));
+               getStringPrefix(header_start, nulpos-header_start) &lt;&lt; &quot;}\nNULL\n{&quot; &lt;&lt; getStringPrefix(nulpos+1, hdrLen-(nulpos-header_start)-1));
         PROF_stop(HttpHeaderParse);
         return reset();
     }
 
     /* common format headers are &quot;&lt;name&gt;:[ws]&lt;value&gt;&quot; lines delimited by &lt;CRLF&gt;.
      * continuation lines start with a (single) space or tab */
     while (field_ptr &lt; header_end) {
         const char *field_start = field_ptr;
         const char *field_end;
 
         do {
             const char *this_line = field_ptr;
             field_ptr = (const char *)memchr(field_ptr, '\n', header_end - field_ptr);
 
             if (!field_ptr) {
                 // missing &lt;LF&gt;
                 PROF_stop(HttpHeaderParse);
                 return reset();
             }
 
             field_end = field_ptr;
 
             ++field_ptr;	/* Move to next line */
 
             if (field_end &gt; this_line &amp;&amp; field_end[-1] == '\r') {
                 --field_end;	/* Ignore CR LF */
 
                 if (owner == hoRequest &amp;&amp; field_end &gt; this_line) {
                     bool cr_only = true;
                     for (const char *p = this_line; p &lt; field_end &amp;&amp; cr_only; ++p) {
                         if (*p != '\r')
                             cr_only = false;
                     }
                     if (cr_only) {
                         debugs(55, DBG_IMPORTANT, &quot;SECURITY WARNING: Rejecting HTTP request with a CR+ &quot;
                                &quot;header field to prevent request smuggling attacks: {&quot; &lt;&lt;
-                               getStringPrefix(header_start, header_end) &lt;&lt; &quot;}&quot;);
+                               getStringPrefix(header_start, hdrLen) &lt;&lt; &quot;}&quot;);
                         PROF_stop(HttpHeaderParse);
                         return reset();
                     }
                 }
             }
 
             /* Barf on stray CR characters */
             if (memchr(this_line, '\r', field_end - this_line)) {
                 debugs(55, warnOnError, &quot;WARNING: suspicious CR characters in HTTP header {&quot; &lt;&lt;
-                       getStringPrefix(field_start, field_end) &lt;&lt; &quot;}&quot;);
+                       getStringPrefix(field_start, field_end-field_start) &lt;&lt; &quot;}&quot;);
 
                 if (Config.onoff.relaxed_header_parser) {
                     char *p = (char *) this_line;	/* XXX Warning! This destroys original header content and violates specifications somewhat */
 
                     while ((p = (char *)memchr(p, '\r', field_end - p)) != NULL) {
                         *p = ' ';
                         ++p;
                     }
                 } else {
                     PROF_stop(HttpHeaderParse);
                     return reset();
                 }
             }
 
             if (this_line + 1 == field_end &amp;&amp; this_line &gt; field_start) {
                 debugs(55, warnOnError, &quot;WARNING: Blank continuation line in HTTP header {&quot; &lt;&lt;
-                       getStringPrefix(header_start, header_end) &lt;&lt; &quot;}&quot;);
+                       getStringPrefix(header_start, hdrLen) &lt;&lt; &quot;}&quot;);
                 PROF_stop(HttpHeaderParse);
                 return reset();
             }
         } while (field_ptr &lt; header_end &amp;&amp; (*field_ptr == ' ' || *field_ptr == '\t'));
 
         if (field_start == field_end) {
             if (field_ptr &lt; header_end) {
                 debugs(55, warnOnError, &quot;WARNING: unparseable HTTP header field near {&quot; &lt;&lt;
-                       getStringPrefix(field_start, header_end) &lt;&lt; &quot;}&quot;);
+                       getStringPrefix(field_start, hdrLen-(field_start-header_start)) &lt;&lt; &quot;}&quot;);
                 PROF_stop(HttpHeaderParse);
                 return reset();
             }
 
             break;		/* terminating blank line */
         }
 
         if ((e = HttpHeaderEntry::parse(field_start, field_end)) == NULL) {
             debugs(55, warnOnError, &quot;WARNING: unparseable HTTP header field {&quot; &lt;&lt;
-                   getStringPrefix(field_start, field_end) &lt;&lt; &quot;}&quot;);
-            debugs(55, warnOnError, &quot; in {&quot; &lt;&lt; getStringPrefix(header_start, header_end) &lt;&lt; &quot;}&quot;);
+                   getStringPrefix(field_start, field_end-field_start) &lt;&lt; &quot;}&quot;);
+            debugs(55, warnOnError, &quot; in {&quot; &lt;&lt; getStringPrefix(header_start, hdrLen) &lt;&lt; &quot;}&quot;);
 
             if (Config.onoff.relaxed_header_parser)
                 continue;
 
             PROF_stop(HttpHeaderParse);
             return reset();
         }
 
         if (e-&gt;id == HDR_CONTENT_LENGTH &amp;&amp; (e2 = findEntry(e-&gt;id)) != NULL) {
             if (e-&gt;value != e2-&gt;value) {
                 int64_t l1, l2;
                 debugs(55, warnOnError, &quot;WARNING: found two conflicting content-length headers in {&quot; &lt;&lt;
-                       getStringPrefix(header_start, header_end) &lt;&lt; &quot;}&quot;);
+                       getStringPrefix(header_start, hdrLen) &lt;&lt; &quot;}&quot;);
 
                 if (!Config.onoff.relaxed_header_parser) {
                     delete e;
                     PROF_stop(HttpHeaderParse);
                     return reset();
                 }
 
                 if (!httpHeaderParseOffset(e-&gt;value.termedBuf(), &amp;l1)) {
                     debugs(55, DBG_IMPORTANT, &quot;WARNING: Unparseable content-length '&quot; &lt;&lt; e-&gt;value &lt;&lt; &quot;'&quot;);
                     delete e;
                     continue;
                 } else if (!httpHeaderParseOffset(e2-&gt;value.termedBuf(), &amp;l2)) {
                     debugs(55, DBG_IMPORTANT, &quot;WARNING: Unparseable content-length '&quot; &lt;&lt; e2-&gt;value &lt;&lt; &quot;'&quot;);
                     delById(e2-&gt;id);
                 } else if (l1 &gt; l2) {
                     delById(e2-&gt;id);
                 } else {
                     delete e;
                     continue;
                 }
             } else {
                 debugs(55, warnOnError, &quot;NOTICE: found double content-length header&quot;);
                 delete e;
 
                 if (Config.onoff.relaxed_header_parser)
                     continue;
 
                 PROF_stop(HttpHeaderParse);
                 return reset();
             }
         }
 
         if (e-&gt;id == HDR_OTHER &amp;&amp; stringHasWhitespace(e-&gt;name.termedBuf())) {
             debugs(55, warnOnError, &quot;WARNING: found whitespace in HTTP header name {&quot; &lt;&lt;
-                   getStringPrefix(field_start, field_end) &lt;&lt; &quot;}&quot;);
+                   getStringPrefix(field_start, field_end-field_start) &lt;&lt; &quot;}&quot;);
 
             if (!Config.onoff.relaxed_header_parser) {
                 delete e;
                 PROF_stop(HttpHeaderParse);
                 return reset();
             }
         }
 
         addEntry(e);
     }
 
     if (chunked()) {
         // RFC 2616 section 4.4: ignore Content-Length with Transfer-Encoding
         delById(HDR_CONTENT_LENGTH);
     }
 
     PROF_stop(HttpHeaderParse);
     return 1;			/* even if no fields where found, it is a valid header */
 }
 
@@ -1614,52 +1615,52 @@
     const char *name_end = (const char *)memchr(field_start, ':', field_end - field_start);
     int name_len = name_end ? name_end - field_start :0;
     const char *value_start = field_start + name_len + 1;	/* skip ':' */
     /* note: value_end == field_end */
 
     ++ HeaderEntryParsedCount;
 
     /* do we have a valid field name within this field? */
 
     if (!name_len || name_end &gt; field_end)
         return NULL;
 
     if (name_len &gt; 65534) {
         /* String must be LESS THAN 64K and it adds a terminating NULL */
         debugs(55, DBG_IMPORTANT, &quot;WARNING: ignoring header name of &quot; &lt;&lt; name_len &lt;&lt; &quot; bytes&quot;);
         return NULL;
     }
 
     if (Config.onoff.relaxed_header_parser &amp;&amp; xisspace(field_start[name_len - 1])) {
         debugs(55, Config.onoff.relaxed_header_parser &lt;= 0 ? 1 : 2,
-               &quot;NOTICE: Whitespace after header name in '&quot; &lt;&lt; getStringPrefix(field_start, field_end) &lt;&lt; &quot;'&quot;);
+               &quot;NOTICE: Whitespace after header name in '&quot; &lt;&lt; getStringPrefix(field_start, field_end-field_start) &lt;&lt; &quot;'&quot;);
 
         while (name_len &gt; 0 &amp;&amp; xisspace(field_start[name_len - 1]))
             --name_len;
 
         if (!name_len)
             return NULL;
     }
 
     /* now we know we can parse it */
 
-    debugs(55, 9, &quot;parsing HttpHeaderEntry: near '&quot; &lt;&lt;  getStringPrefix(field_start, field_end) &lt;&lt; &quot;'&quot;);
+    debugs(55, 9, &quot;parsing HttpHeaderEntry: near '&quot; &lt;&lt;  getStringPrefix(field_start, field_end-field_start) &lt;&lt; &quot;'&quot;);
 
     /* is it a &quot;known&quot; field? */
     http_hdr_type id = httpHeaderIdByName(field_start, name_len, Headers, HDR_ENUM_END);
 
     String name;
 
     String value;
 
     if (id &lt; 0)
         id = HDR_OTHER;
 
     assert_eid(id);
 
     /* set field name */
     if (id == HDR_OTHER)
         name.limitInit(field_start, name_len);
     else
         name = Headers[id].name;
 
     /* trim field value */

=== modified file 'src/HttpHeader.h'
--- src/HttpHeader.h	2014-09-13 13:59:43 +0000
+++ src/HttpHeader.h	2014-09-14 12:23:03 +0000
@@ -1,158 +1,48 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPHEADER_H
 #define SQUID_HTTPHEADER_H
 
+#include &quot;http/RegisteredHeaders.h&quot;
 /* because we pass a spec by value */
 #include &quot;HttpHeaderMask.h&quot;
 #include &quot;MemPool.h&quot;
 #include &quot;SquidString.h&quot;
 
 #include &lt;vector&gt;
 
 /* class forward declarations */
 class HttpHdrCc;
 class HttpHdrContRange;
 class HttpHdrRange;
 class HttpHdrSc;
 class Packer;
 class StoreEntry;
 class SBuf;
 
-/* constant attributes of http header fields */
-
-/// recognized or &quot;known&quot; header fields; and the RFC which defines them (or not)
-/// <A HREF="http://www.iana.org/assignments/message-headers/message-headers.xhtml">http://www.iana.org/assignments/message-headers/message-headers.xhtml</A>
-typedef enum {
-    HDR_BAD_HDR = -1,
-    HDR_ACCEPT = 0,                     /**&lt; RFC 7231 */
-    HDR_ACCEPT_CHARSET,                 /**&lt; RFC 7231 */
-    HDR_ACCEPT_ENCODING,                /**&lt; RFC 7231 */
-    /*HDR_ACCEPT_FEATURES,*/            /* RFC 2295 */
-    HDR_ACCEPT_LANGUAGE,                /**&lt; RFC 7231 */
-    HDR_ACCEPT_RANGES,                  /**&lt; RFC 7233 */
-    HDR_AGE,                            /**&lt; RFC 7234 */
-    HDR_ALLOW,                          /**&lt; RFC 7231 */
-    HDR_AUTHENTICATION_INFO,            /**&lt; RFC 2617 */
-    HDR_AUTHORIZATION,                  /**&lt; RFC 7235, 4559 */
-    HDR_CACHE_CONTROL,                  /**&lt; RFC 7234 */
-    HDR_CONNECTION,                     /**&lt; RFC 7230 */
-    HDR_CONTENT_BASE,                   /**&lt; obsoleted RFC 2068 */
-    HDR_CONTENT_DISPOSITION,            /**&lt; RFC 2183, 6266 */
-    HDR_CONTENT_ENCODING,               /**&lt; RFC 7231 */
-    HDR_CONTENT_LANGUAGE,               /**&lt; RFC 7231 */
-    HDR_CONTENT_LENGTH,                 /**&lt; RFC 7230 */
-    HDR_CONTENT_LOCATION,               /**&lt; RFC 7231 */
-    HDR_CONTENT_MD5,                    /**&lt; deprecated, RFC 2616 */
-    HDR_CONTENT_RANGE,                  /**&lt; RFC 7233 */
-    HDR_CONTENT_TYPE,                   /**&lt; RFC 7231 */
-    HDR_COOKIE,                         /**&lt; RFC 6265 header we may need to erase */
-    HDR_COOKIE2,                        /**&lt; obsolete RFC 2965 header we may need to erase */
-    HDR_DATE,                           /**&lt; RFC 7231 */
-    /*HDR_DAV,*/                        /* RFC 2518 */
-    /*HDR_DEPTH,*/                      /* RFC 2518 */
-    /*HDR_DERIVED_FROM,*/               /* deprecated RFC 2068 */
-    /*HDR_DESTINATION,*/                /* RFC 2518 */
-    HDR_ETAG,                           /**&lt; RFC 7232 */
-    HDR_EXPECT,                         /**&lt; RFC 7231 */
-    HDR_EXPIRES,                        /**&lt; RFC 7234 */
-    HDR_FORWARDED,                      /**&lt; RFC 7239 */
-    HDR_FROM,                           /**&lt; RFC 7231 */
-    HDR_HOST,                           /**&lt; RFC 7230 */
-    HDR_HTTP2_SETTINGS,                 /**&lt; HTTP/2.0 upgrade header. see draft-ietf-httpbis-http2-13 */
-    /*HDR_IF,*/                         /* RFC 2518 */
-    HDR_IF_MATCH,                       /**&lt; RFC 7232 */
-    HDR_IF_MODIFIED_SINCE,              /**&lt; RFC 7232 */
-    HDR_IF_NONE_MATCH,                  /**&lt; RFC 7232 */
-    HDR_IF_RANGE,                       /**&lt; RFC 7233 */
-    HDR_IF_UNMODIFIED_SINCE,            /**&lt; RFC 7232 */
-    HDR_KEEP_ALIVE,                     /**&lt; obsoleted RFC 2068 header we may need to erase */
-    HDR_KEY,                            /**&lt; experimental RFC Draft draft-fielding-http-key-02 */
-    HDR_LAST_MODIFIED,                  /**&lt; RFC 7232 */
-    HDR_LINK,                           /**&lt; RFC 5988 */
-    HDR_LOCATION,                       /**&lt; RFC 7231 */
-    /*HDR_LOCK_TOKEN,*/                 /* RFC 2518 */
-    HDR_MAX_FORWARDS,                   /**&lt; RFC 7231 */
-    HDR_MIME_VERSION,                   /**&lt; RFC 2045, 7231 */
-    HDR_NEGOTIATE,                      /**&lt; experimental RFC 2295. Why only this one from 2295? */
-    /*HDR_OVERWRITE,*/                  /* RFC 2518 */
-    HDR_ORIGIN,                         /* CORS Draft specification (see <A HREF="http://www.w3.org/TR/cors/">http://www.w3.org/TR/cors/</A>) */
-    HDR_PRAGMA,                         /**&lt; RFC 7234 */
-    HDR_PROXY_AUTHENTICATE,             /**&lt; RFC 7235 */
-    HDR_PROXY_AUTHENTICATION_INFO,      /**&lt; RFC 2617 */
-    HDR_PROXY_AUTHORIZATION,            /**&lt; RFC 7235 */
-    HDR_PROXY_CONNECTION,               /**&lt; obsolete Netscape header we may need to erase. */
-    HDR_PROXY_SUPPORT,                  /**&lt; RFC 4559 */
-    HDR_PUBLIC,                         /**&lt;  RFC 2068 */
-    HDR_RANGE,                          /**&lt; RFC 7233 */
-    HDR_REFERER,                        /**&lt; RFC 7231 */
-    HDR_REQUEST_RANGE,                  /**&lt; some clients use this, sigh */
-    HDR_RETRY_AFTER,                    /**&lt; RFC 7231 */
-    HDR_SERVER,                         /**&lt; RFC 7231 */
-    HDR_SET_COOKIE,                     /**&lt; RFC 6265 header we may need to erase */
-    HDR_SET_COOKIE2,                    /**&lt; obsoleted RFC 2965 header we may need to erase */
-    /*HDR_STATUS_URI,*/                 /* RFC 2518 */
-    /*HDR_TCN,*/                        /* experimental RFC 2295 */
-    HDR_TE,                             /**&lt; RFC 7230 */
-    /*HDR_TIMEOUT,*/                    /* RFC 2518 */
-    HDR_TITLE,                          /* obsolete draft suggested header */
-    HDR_TRAILER,                        /**&lt; RFC 7230 */
-    HDR_TRANSFER_ENCODING,              /**&lt; RFC 7230 */
-    HDR_TRANSLATE,                      /**&lt; IIS custom header we may need to erase */
-    HDR_UNLESS_MODIFIED_SINCE,          /**&lt; IIS custom header we may need to erase */
-    HDR_UPGRADE,                        /**&lt; RFC 7230 */
-    HDR_USER_AGENT,                     /**&lt; RFC 7231 */
-    /*HDR_VARIANT_VARY,*/               /* experimental RFC 2295 */
-    HDR_VARY,                           /**&lt; RFC 7231 */
-    HDR_VIA,                            /**&lt; RFC 7230 */
-    HDR_WARNING,                        /**&lt; RFC 7234 */
-    HDR_WWW_AUTHENTICATE,               /**&lt; RFC 7235, 4559 */
-    HDR_X_CACHE,                        /**&lt; Squid custom header */
-    HDR_X_CACHE_LOOKUP,                 /**&lt; Squid custom header. temporary hack that became de-facto. TODO remove */
-    HDR_X_FORWARDED_FOR,                /**&lt; obsolete Squid custom header, RFC 7239 */
-    HDR_X_REQUEST_URI,                  /**&lt; Squid custom header appended if ADD_X_REQUEST_URI is defined */
-    HDR_X_SQUID_ERROR,                  /**&lt; Squid custom header on generated error responses */
-#if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,             /**&lt; obsolete Squid custom header. */
-#endif
-#if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,                /**&lt; Squid custom ICAP header */
-#endif
-    HDR_SURROGATE_CAPABILITY,           /**&lt; Edge Side Includes (ESI) header */
-    HDR_SURROGATE_CONTROL,              /**&lt; Edge Side Includes (ESI) header */
-    HDR_FRONT_END_HTTPS,                /**&lt; MS Exchange custom header we may have to add */
-    HDR_FTP_COMMAND,                    /**&lt; Internal header for FTP command */
-    HDR_FTP_ARGUMENTS,                  /**&lt; Internal header for FTP command arguments */
-    HDR_FTP_PRE,                        /**&lt; Internal header containing leading FTP control response lines */
-    HDR_FTP_STATUS,                     /**&lt; Internal header for FTP reply status */
-    HDR_FTP_REASON,                     /**&lt; Internal header for FTP reply reason */
-    HDR_OTHER,                          /**&lt; internal tag value for &quot;unknown&quot; headers */
-    HDR_ENUM_END
-} http_hdr_type;
-
 /** possible types for http header fields */
 typedef enum {
     ftInvalid = HDR_ENUM_END,	/**&lt; to catch nasty errors with hdr_id&lt;-&gt;fld_type clashes */
     ftInt,
     ftInt64,
     ftStr,
     ftDate_1123,
     ftETag,
     ftPCc,
     ftPContRange,
     ftPRange,
     ftPSc,
     ftDate_1123_or_ETag
 } field_type;
 
 /** Possible owners of http header */
 typedef enum {
     hoNone =0,
 #if USE_HTCP
     hoHtcpReply,
@@ -202,41 +92,41 @@
 class ETag;
 class TimeOrTag;
 
 class HttpHeader
 {
 
 public:
     HttpHeader();
     explicit HttpHeader(const http_hdr_owner_type owner);
     HttpHeader(const HttpHeader &amp;other);
     ~HttpHeader();
 
     HttpHeader &amp;operator =(const HttpHeader &amp;other);
 
     /* Interface functions */
     void clean();
     void append(const HttpHeader * src);
     void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
     void compact();
     int reset();
-    int parse(const char *header_start, const char *header_end);
+    int parse(const char *header_start, size_t len);
     void packInto(Packer * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
     HttpHeaderEntry *findEntry(http_hdr_type id) const;
     int delByName(const char *name);
     int delById(http_hdr_type id);
     void delAt(HttpHeaderPos pos, int &amp;headers_deleted);
     void refreshMask();
     void addEntry(HttpHeaderEntry * e);
     void insertEntry(HttpHeaderEntry * e);
     String getList(http_hdr_type id) const;
     bool getList(http_hdr_type id, String *s) const;
     String getStrOrList(http_hdr_type id) const;
     String getByName(const char *name) const;
     /// sets value and returns true iff a [possibly empty] named field is there
     bool getByNameIfPresent(const char *name, String &amp;value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(http_hdr_type id, const char *member, const char separator) const;
     int has(http_hdr_type id) const;
     void putInt(http_hdr_type id, int number);
     void putInt64(http_hdr_type id, int64_t number);

=== modified file 'src/HttpHeaderTools.cc'
--- src/HttpHeaderTools.cc	2014-09-13 13:59:43 +0000
+++ src/HttpHeaderTools.cc	2014-09-14 12:23:03 +0000
@@ -144,46 +144,45 @@
 
 #if USE_HTTP_VIOLATIONS
     if (hdr-&gt;has(HDR_PROXY_CONNECTION))
         list = hdr-&gt;getList(HDR_PROXY_CONNECTION);
     else
 #endif
         if (hdr-&gt;has(HDR_CONNECTION))
             list = hdr-&gt;getList(HDR_CONNECTION);
         else
             return 0;
 
     res = strListIsMember(&amp;list, directive, ',');
 
     list.clean();
 
     return res;
 }
 
 /** handy to printf prefixes of potentially very long buffers */
 const char *
-getStringPrefix(const char *str, const char *end)
+getStringPrefix(const char *str, size_t sz)
 {
 #define SHORT_PREFIX_SIZE 512
     LOCAL_ARRAY(char, buf, SHORT_PREFIX_SIZE);
-    const int sz = 1 + (end ? end - str : strlen(str));
-    xstrncpy(buf, str, (sz &gt; SHORT_PREFIX_SIZE) ? SHORT_PREFIX_SIZE : sz);
+    xstrncpy(buf, str, (sz+1 &gt; SHORT_PREFIX_SIZE) ? SHORT_PREFIX_SIZE : sz);
     return buf;
 }
 
 /**
  * parses an int field, complains if soemthing went wrong, returns true on
  * success
  */
 int
 httpHeaderParseInt(const char *start, int *value)
 {
     assert(value);
     *value = atoi(start);
 
     if (!*value &amp;&amp; !xisdigit(*start)) {
         debugs(66, 2, &quot;failed to parse an int header field near '&quot; &lt;&lt; start &lt;&lt; &quot;'&quot;);
         return 0;
     }
 
     return 1;
 }

=== modified file 'src/HttpHeaderTools.h'
--- src/HttpHeaderTools.h	2014-09-13 13:59:43 +0000
+++ src/HttpHeaderTools.h	2014-09-14 12:23:03 +0000
@@ -107,25 +107,25 @@
     Format::Format *valueFormat;
 
     /// internal ID for &quot;known&quot; headers or HDR_OTHER
     http_hdr_type fieldId;
 
     /// whether fieldValue may contain macros
     bool quoted;
 };
 
 int httpHeaderParseOffset(const char *start, int64_t * off);
 
 HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
 void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
 http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
 http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
 const char *httpHeaderNameById(int id);
 int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
 int httpHeaderParseInt(const char *start, int *val);
 void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
 
-const char *getStringPrefix(const char *str, const char *end);
+const char *getStringPrefix(const char *str, size_t len);
 
 void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
 
 #endif

=== modified file 'src/HttpMsg.cc'
--- src/HttpMsg.cc	2014-09-13 13:59:43 +0000
+++ src/HttpMsg.cc	2014-10-11 10:21:16 +0000
@@ -18,41 +18,41 @@
 #include &quot;SquidConfig.h&quot;
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
         cache_control(NULL), hdr_sz(0), content_length(0),
         pstate(psReadyToParseStartLine)
 {}
 
 HttpMsg::~HttpMsg()
 {
     assert(!body_pipe);
 }
 
 HttpMsgParseState &amp;operator++ (HttpMsgParseState &amp;aState)
 {
     int tmp = (int)aState;
     aState = (HttpMsgParseState)(++tmp);
     return aState;
 }
 
 /* find end of headers */
-int
+static int
 httpMsgIsolateHeaders(const char **parse_start, int l, const char **blk_start, const char **blk_end)
 {
     /*
      * parse_start points to the first line of HTTP message *headers*,
      * not including the request or status lines
      */
     size_t end = headersEnd(*parse_start, l);
     int nnl;
 
     if (end) {
         *blk_start = *parse_start;
         *blk_end = *parse_start + end - 1;
         /*
          * leave blk_end pointing to the first character after the
          * first newline which terminates the headers
          */
         assert(**blk_end == '\n');
 
         while (*(*blk_end - 1) == '\r')
             --(*blk_end);
@@ -238,48 +238,49 @@
             PROF_stop(HttpMsg_httpMsgParseStep);
             return httpMsgParseError();
         }
 
         *parse_end_ptr = parse_start;
 
         hdr_sz = *parse_end_ptr - buf;
         parse_len = parse_len - hdr_sz;
 
         ++pstate;
     }
 
     /*
      * XXX This code uses parse_start; but if we're incrementally parsing then
      * this code might not actually be given parse_start at the right spot (just
      * after headers.) Grr.
      */
     if (pstate == psReadyToParseHeaders) {
         if (!httpMsgIsolateHeaders(&amp;parse_start, parse_len, &amp;blk_start, &amp;blk_end)) {
             if (atEnd) {
-                blk_start = parse_start, blk_end = blk_start + strlen(blk_start);
+                blk_start = parse_start;
+                blk_end = blk_start + strlen(blk_start);
             } else {
                 PROF_stop(HttpMsg_httpMsgParseStep);
                 return 0;
             }
         }
 
-        if (!header.parse(blk_start, blk_end)) {
+        if (!header.parse(blk_start, blk_end-blk_start)) {
             PROF_stop(HttpMsg_httpMsgParseStep);
             return httpMsgParseError();
         }
 
         hdrCacheInit();
 
         *parse_end_ptr = parse_start;
 
         hdr_sz = *parse_end_ptr - buf;
 
         ++pstate;
     }
 
     PROF_stop(HttpMsg_httpMsgParseStep);
     return 1;
 }
 
 /* handy: resets and returns -1 */
 int
 HttpMsg::httpMsgParseError()

=== modified file 'src/HttpMsg.h'
--- src/HttpMsg.h	2014-09-13 13:59:43 +0000
+++ src/HttpMsg.h	2014-09-14 12:23:03 +0000
@@ -1,37 +1,37 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPMSG_H
 #define SQUID_HTTPMSG_H
 
 #include &quot;base/Lock.h&quot;
 #include &quot;BodyPipe.h&quot;
+#include &quot;http/forward.h&quot;
 #include &quot;http/ProtocolVersion.h&quot;
 #include &quot;http/StatusCode.h&quot;
 #include &quot;HttpHeader.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
 
 /// common parts of HttpRequest and HttpReply
 class HttpMsg : public RefCountable
 {
 
 public:
     typedef RefCount&lt;HttpMsg&gt; Pointer;
 
     HttpMsg(http_hdr_owner_type owner);
     virtual ~HttpMsg();
 
     virtual void reset() = 0; // will have body when http*Clean()s are gone
 
     void packInto(Packer * p, bool full_uri) const;
 
     ///&lt; produce a message copy, except for a few connection-specific settings
     virtual HttpMsg *clone() const = 0; ///&lt; \todo rename: not a true copy?
 
     /// [re]sets Content-Length header and cached value
     void setContentLength(int64_t clen);
@@ -81,26 +81,24 @@
 
     virtual bool inheritProperties(const HttpMsg *aMsg) = 0;
 
 protected:
     /**
      * Validate the message start line is syntactically correct.
      * Set HTTP error status according to problems found.
      *
      * \retval true   Status line has no serious problems.
      * \retval false  Status line has a serious problem. Correct response is indicated by error.
      */
     virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error) = 0;
 
     virtual void packFirstLineInto(Packer * p, bool full_uri) const = 0;
 
     virtual bool parseFirstLine(const char *blk_start, const char *blk_end) = 0;
 
     virtual void hdrCacheInit();
 };
 
-int httpMsgIsolateHeaders(const char **parse_start, int len, const char **blk_start, const char **blk_end);
-
 #define HTTPMSGUNLOCK(a) if (a) { if ((a)-&gt;unlock() == 0) delete (a); (a)=NULL; }
 #define HTTPMSGLOCK(a) (a)-&gt;lock()
 
 #endif /* SQUID_HTTPMSG_H */

=== modified file 'src/HttpRequest.cc'
--- src/HttpRequest.cc	2014-09-13 13:59:43 +0000
+++ src/HttpRequest.cc	2014-10-15 07:12:58 +0000
@@ -1,40 +1,41 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 73    HTTP Request */
 
 #include &quot;squid.h&quot;
 #include &quot;AccessLogEntry.h&quot;
 #include &quot;acl/AclSizeLimit.h&quot;
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;DnsLookupDetails.h&quot;
 #include &quot;err_detail_type.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;gopher.h&quot;
 #include &quot;http.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
 #include &quot;HttpHdrCc.h&quot;
 #include &quot;HttpHeaderRange.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;log/Config.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;URL.h&quot;
 
 #if USE_AUTH
 #include &quot;auth/UserRequest.h&quot;
 #endif
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/icap_log.h&quot;
 #endif
 
 HttpRequest::HttpRequest() :
         HttpMsg(hoRequest)
 {
     init();
@@ -262,106 +263,112 @@
 /**
  * Checks the first line of an HTTP request is valid
  * currently just checks the request method is present.
  *
  * NP: Other errors are left for detection later in the parse.
  */
 bool
 HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error)
 {
     // content is long enough to possibly hold a reply
     // 2 being magic size of a 1-byte request method plus space delimiter
     if ( buf-&gt;contentSize() &lt; 2 ) {
         // this is ony a real error if the headers apparently complete.
         if (hdr_len &gt; 0) {
             debugs(58, 3, HERE &lt;&lt; &quot;Too large request header (&quot; &lt;&lt; hdr_len &lt;&lt; &quot; bytes)&quot;);
             *error = Http::scInvalidHeader;
         }
         return false;
     }
 
-    /* See if the request buffer starts with a known HTTP request method. */
-    if (HttpRequestMethod(buf-&gt;content(),NULL) == Http::METHOD_NONE) {
+    /* See if the request buffer starts with a non-whitespace HTTP request 'method'. */
+    HttpRequestMethod m;
+    m.HttpRequestMethodXXX(buf-&gt;content());
+    if (m == Http::METHOD_NONE) {
         debugs(73, 3, &quot;HttpRequest::sanityCheckStartLine: did not find HTTP request method&quot;);
         *error = Http::scInvalidHeader;
         return false;
     }
 
     return true;
 }
 
 bool
 HttpRequest::parseFirstLine(const char *start, const char *end)
 {
-    const char *t = start + strcspn(start, w_space);
-    method = HttpRequestMethod(start, t);
+    method.HttpRequestMethodXXX(start);
 
     if (method == Http::METHOD_NONE)
         return false;
 
-    start = t + strspn(t, w_space);
+    // XXX: performance regression, strcspn() over the method bytes a second time.
+    // cheaper than allocate+copy+deallocate cycle to SBuf convert a piece of start.
+    const char *t = start + strcspn(start, w_space);
+
+    start = t + strspn(t, w_space); // skip w_space after method
 
     const char *ver = findTrailingHTTPVersion(start, end);
 
     if (ver) {
         end = ver - 1;
 
         while (xisspace(*end)) // find prev non-space
             --end;
 
         ++end;                 // back to space
 
         if (2 != sscanf(ver + 5, &quot;%d.%d&quot;, &amp;http_ver.major, &amp;http_ver.minor)) {
             debugs(73, DBG_IMPORTANT, &quot;parseRequestLine: Invalid HTTP identifier.&quot;);
             return false;
         }
     } else {
         http_ver.major = 0;
         http_ver.minor = 9;
     }
 
     if (end &lt; start)   // missing URI
         return false;
 
     char save = *end;
 
     * (char *) end = '\0';     // temp terminate URI, XXX dangerous?
 
     HttpRequest *tmp = urlParse(method, (char *) start, this);
 
     * (char *) end = save;
 
     if (NULL == tmp)
         return false;
 
     return true;
 }
 
-int
-HttpRequest::parseHeader(const char *parse_start, int len)
+bool
+HttpRequest::parseHeader(Http1::RequestParser &amp;hp)
 {
-    const char *blk_start, *blk_end;
-
-    if (!httpMsgIsolateHeaders(&amp;parse_start, len, &amp;blk_start, &amp;blk_end))
-        return 0;
+    // HTTP/1 message contains &quot;zero or more header fields&quot;
+    // zero does not need parsing
+    if (!hp.headerBlockSize())
+        return true;
 
-    int result = header.parse(blk_start, blk_end);
+    // XXX: c_str() reallocates. performance regression.
+    const bool result = header.parse(hp.mimeHeader().c_str(), hp.headerBlockSize());
 
     if (result)
         hdrCacheInit();
 
     return result;
 }
 
 /* swaps out request using httpRequestPack */
 void
 HttpRequest::swapOut(StoreEntry * e)
 {
     Packer p;
     assert(e);
     packerToStoreInit(&amp;p, e);
     pack(&amp;p);
     packerClean(&amp;p);
 }
 
 /* packs request-line and headers, appends &lt;crlf&gt; terminator */
 void

=== modified file 'src/HttpRequest.h'
--- src/HttpRequest.h	2014-09-13 13:59:43 +0000
+++ src/HttpRequest.h	2014-09-14 12:23:03 +0000
@@ -1,37 +1,37 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPREQUEST_H
 #define SQUID_HTTPREQUEST_H
 
 #include &quot;base/CbcPointer.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;err_type.h&quot;
 #include &quot;HierarchyLogEntry.h&quot;
 #include &quot;HttpMsg.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;Notes.h&quot;
 #include &quot;RequestFlags.h&quot;
 #include &quot;URL.h&quot;
 
 #if USE_AUTH
 #include &quot;auth/UserRequest.h&quot;
 #endif
 #if USE_ADAPTATION
 #include &quot;adaptation/History.h&quot;
 #endif
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/History.h&quot;
 #endif
 #if USE_SQUID_EUI
 #include &quot;eui/Eui48.h&quot;
 #include &quot;eui/Eui64.h&quot;
 #endif
 
 class ConnStateData;
 
@@ -192,41 +192,41 @@
     String extacl_user;		/* User name returned by extacl lookup */
 
     String extacl_passwd;	/* Password returned by extacl lookup */
 
     String extacl_log;		/* String to be used for access.log purposes */
 
     String extacl_message;	/* String to be used for error page purposes */
 
 #if FOLLOW_X_FORWARDED_FOR
     String x_forwarded_for_iterator; /* XXX a list of IP addresses */
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
     /// A strong etag of the cached entry. Used for refreshing that entry.
     String etag;
 
 public:
     bool multipartRangeRequest() const;
 
     bool parseFirstLine(const char *start, const char *end);
 
-    int parseHeader(const char *parse_start, int len);
+    bool parseHeader(Http1::RequestParser &amp;hp); // TODO move this function to the parser
 
     virtual bool expectingBody(const HttpRequestMethod&amp; unused, int64_t&amp;) const;
 
     bool bodyNibbled() const; // the request has a [partially] consumed body
 
     int prefixLen();
 
     void swapOut(StoreEntry * e);
 
     void pack(Packer * p);
 
     static void httpRequestPack(void *obj, Packer *p);
 
     static HttpRequest * CreateFromUrlAndMethod(char * url, const HttpRequestMethod&amp; method);
 
     static HttpRequest * CreateFromUrl(char * url);
 
     ConnStateData *pinnedConnection();
 
     /**

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2014-10-14 13:57:05 +0000
+++ src/Makefile.am	2014-10-16 12:13:18 +0000
@@ -386,50 +386,46 @@
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrSc.h \
 	HttpHdrScTarget.cc \
 	HttpHdrScTarget.h \
 	HttpHdrContRange.cc \
 	HttpHdrContRange.h \
 	HttpHeaderStat.h \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
 	HttpHeaderRange.h \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpControlMsg.h \
 	HttpMsg.cc \
 	HttpMsg.h \
-	HttpParser.cc \
-	HttpParser.h \
 	HttpReply.cc \
 	HttpReply.h \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequest.h \
-	HttpRequestMethod.cc \
-	HttpRequestMethod.h \
 	ICP.h \
 	icp_opcode.h \
 	icp_v2.cc \
 	icp_v3.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	ipcache.h \
 	$(LEAKFINDERSOURCE) \
 	SquidList.h \
 	SquidList.cc \
 	LogTags.h \
 	lookup_t.h \
 	main.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Mem.h \
@@ -598,69 +594,69 @@
 	icp_opcode.cc \
 	LogTags.cc \
 	lookup_t.cc \
 	repl_modules.cc \
 	swap_log_op.cc
 
 CLEANFILES += $(BUILT_SOURCES)
 
 nodist_squid_SOURCES = \
 	$(DISKIO_GEN_SOURCE) \
 	$(BUILT_SOURCES)
 
 squid_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	$(DISK_LIBS) \
 	acl/libapi.la \
+	clients/libclients.la \
+	servers/libservers.la \
+	ftp/libftp.la \
+	helper/libhelper.la \
+	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
 	comm/libcomm.la \
 	eui/libeui.la \
-	helper/libhelper.la \
-	http/libsquid-http.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
-	clients/libclients.la \
-	servers/libservers.la \
-	ftp/libftp.la \
 	$(XTRA_OBJS) \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS) \
 	$(DISK_OS_LIBS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SNMP_LIBS) \
-	parser/libsquid-parser.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SSLLIB) \
 	$(EPOLL_LIBS) \
 	$(MINGW_LIBS) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 squid_DEPENDENCIES = \
 	$(DISK_LIBS) \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LOCAL_LIBS) \
 	$(SSL_LIBS) \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
@@ -726,41 +722,41 @@
 	debug.cc \
 	int.h \
 	int.cc \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
 	MemBuf.h \
 	Parsing.h \
 	store_key_md5.h \
 	store_key_md5.cc \
 	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
 	String.cc \
 	SquidNew.cc \
 	tests/stub_time.cc \
 	ufsdump.cc \
 	dlink.h \
 	dlink.cc \
 	helper/ChildConfig.h \
 	tests/stub_HelperChildConfig.cc \
-	HttpRequestMethod.cc \
+	http/RequestMethod.cc \
 	RemovalPolicy.cc \
 	$(WIN32_SOURCE) \
 	fd.h \
 	tests/stub_fd.cc
 ufsdump_LDADD = \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(XTRA_OBJS) \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
@@ -1054,41 +1050,41 @@
 
 test_tools.cc: $(top_srcdir)/test-suite/test_tools.cc
 	cp $(top_srcdir)/test-suite/test_tools.cc .
 
 # stock tools for unit tests - library independent versions of dlink_list 
 # etc.
 # globals.cc is needed by test_tools.cc.
 # Neither of these should be disted from here.
 TESTSOURCES= \
 	tests/STUB.h \
 	test_tools.cc \
 	globals.cc
 
 check_PROGRAMS+=\
 	tests/testBoilerplate \
 	tests/testCacheManager \
 	tests/testDiskIO \
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
-	tests/testHttpParser \
+	tests/testHttp1Parser \
 	tests/testHttpReply \
 	tests/testHttpRequest \
 	tests/testStore \
 	tests/testString \
 	tests/testURL \
 	tests/testSBuf \
 	tests/testSBufList \
 	tests/testConfigParser \
 	tests/testStatHist
 
 if HAVE_FS_ROCK
 check_PROGRAMS += tests/testRock
 endif
 if HAVE_FS_UFS
 check_PROGRAMS += tests/testUfs
 endif
 
 ## NP: required to run the above list. check_PROGRAMS only builds the binaries...
 TESTS += $(check_PROGRAMS)
 
@@ -1192,40 +1188,41 @@
 	tests/stub_StatHist.cc \
 	repl_modules.h \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/stub_HttpRequest.cc \
 	tests/testHttpReply.cc \
 	tests/testHttpReply.h \
 	tests/testMain.cc \
 	tests/stub_time.cc \
 	url.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpReply_SOURCES=\
 	$(TESTSOURCES)
 tests_testHttpReply_LDFLAGS = $(LIBADD_DL)
 tests_testHttpReply_LDADD=\
 	CommCalls.o \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	anyp/libanyp.la \
 	ip/libip.la \
 	base/libbase.la \
 	ipc/libipc.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(NETTLELIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpReply_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
 
 tests_testACLMaxUserIP_SOURCES= \
 	cbdata.cc \
@@ -1239,41 +1236,40 @@
 	event.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
-	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Notes.cc \
 	Notes.h \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
 	Packer.cc \
 	Parsing.cc \
 	SquidMath.cc \
 	StatCounters.cc \
 	StatCounters.h \
 	StatHist.h \
 	StrList.h \
 	StrList.cc \
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
@@ -1328,40 +1324,41 @@
 	tests/stub_tools.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_UdsOp.cc \
 	tests/testACLMaxUserIP.cc \
 	tests/testACLMaxUserIP.h \
 	tests/testMain.cc \
 	tests/stub_time.cc \
 	url.cc \
 	URL.h \
 	Mem.h \
 	tests/stub_mem.cc \
 	MemBuf.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testACLMaxUserIP_SOURCES= \
 	$(TESTSOURCES)
 tests_testACLMaxUserIP_LDADD= \
 	libsquid.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_OS_LIBS) \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
@@ -1379,46 +1376,43 @@
 	tests/stub_debug.cc \
 	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	tests/stub_cbdata.cc \
 	tests/stub_MemBuf.cc \
 	$(TESTSOURCES)
 tests_testBoilerplate_LDADD= \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testBoilerplate_LDFLAGS = $(LIBADD_DL)
 tests_testBoilerplate_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests of the CacheManager module.
 tests_testCacheManager_SOURCES = \
 	AccessLogEntry.cc \
 	debug.cc \
-	HttpParser.cc \
-	HttpParser.h \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
-	HttpRequestMethod.cc \
 	Mem.h \
 	tests/stub_mem.cc \
 	String.cc \
 	tests/testCacheManager.cc \
 	tests/testCacheManager.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
@@ -1581,48 +1575,48 @@
 	$(UNLINKDSOURCE) \
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testCacheManager_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
+	ftp/libftp.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
-	ftp/libftp.la \
+	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
-	parser/libsquid-parser.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
 	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	anyp/libanyp.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1664,41 +1658,40 @@
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHdrRange.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Mem.h \
 	tests/stub_mem.cc \
 	Notes.h \
 	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
@@ -1771,40 +1764,41 @@
 	tests/testMain.cc \
 	tests/testStoreSupport.cc \
 	tests/testStoreSupport.h \
 	tests/stub_time.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc \
 	tools.h \
 	tests/stub_tools.cc
 nodist_tests_testDiskIO_SOURCES= \
 	$(TESTSOURCES) \
 	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
 	libsquid.la \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	comm/libcomm.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	mgr/libmgr.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -1887,49 +1881,46 @@
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
-	HttpParser.cc \
-	HttpParser.h \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
-	HttpRequestMethod.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Mem.h \
 	tests/stub_mem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
@@ -2013,48 +2004,48 @@
 	tests/stub_tunnel.cc \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEvent_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
+	ftp/libftp.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
-	ftp/libftp.la \
+	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
-	parser/libsquid-parser.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -2135,49 +2126,46 @@
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
-	HttpParser.cc \
-	HttpParser.h \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
-	HttpRequestMethod.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
 	tests/stub_mem.cc \
 	mem_node.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
@@ -2261,48 +2249,48 @@
 	tests/stub_tunnel.cc \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEventLoop_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
+	ftp/libftp.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
-	ftp/libftp.la \
+	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
-	parser/libsquid-parser.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -2379,49 +2367,46 @@
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
-	HttpParser.cc \
-	HttpParser.h \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
-	HttpRequestMethod.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
 	tests/stub_mem.cc \
 	mem_node.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
@@ -2502,136 +2487,136 @@
 	tools.cc \
 	tests/stub_tunnel.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_test_http_range_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
+	ftp/libftp.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
-	ftp/libftp.la \
+	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	parser/libsquid-parser.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_test_http_range_LDFLAGS = $(LIBADD_DL)
 tests_test_http_range_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
-tests_testHttpParser_SOURCES = \
+tests_testHttp1Parser_SOURCES = \
 	Debug.h \
-	HttpParser.cc \
-	HttpParser.h \
 	MemBuf.cc \
 	MemBuf.h \
 	tests/stub_MemObject.cc \
 	Mem.h \
 	tests/stub_mem.cc \
+	mime_header.cc \
+	mime_header.h \
 	String.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	$(SBUF_SOURCE) \
 	tests/stub_SBufDetailedStats.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_comm.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_event.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_stmem.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tools.h \
 	tests/stub_tools.cc \
-	tests/testHttpParser.cc \
-	tests/testHttpParser.h \
+	tests/testHttp1Parser.cc \
+	tests/testHttp1Parser.h \
 	tests/testMain.cc \
 	tests/stub_time.cc \
 	wordlist.h \
 	wordlist.cc
-nodist_tests_testHttpParser_SOURCES = \
+nodist_tests_testHttp1Parser_SOURCES = \
 	$(TESTSOURCES)
-tests_testHttpParser_LDADD= \
+tests_testHttp1Parser_LDADD= \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
+	anyp/libanyp.la \
 	SquidConfig.o \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
-tests_testHttpParser_LDFLAGS = $(LIBADD_DL)
-tests_testHttpParser_DEPENDENCIES = \
+tests_testHttp1Parser_LDFLAGS = $(LIBADD_DL)
+tests_testHttp1Parser_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests of the HttpRequest module.
 tests_testHttpRequest_SOURCES = \
 	AccessLogEntry.cc \
-	HttpParser.cc \
-	HttpParser.h \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
-	HttpRequestMethod.cc \
 	Mem.h \
 	tests/stub_mem.cc \
 	String.cc \
 	tests/testHttpRequest.h \
 	tests/testHttpRequest.cc \
 	tests/testHttpRequestMethod.h \
 	tests/testHttpRequestMethod.cc \
 	tests/testMain.cc \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_libauth.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -2794,58 +2779,59 @@
 	MemStore.cc \
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpRequest_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testHttpRequest_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	helper/libhelper.la \
 	ftp/libftp.la \
+	http/libsquid-http.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	parser/libsquid-parser.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
+	parser/libsquid-parser.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
-	http/libsquid-http.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_OS_LIBS) \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpRequest_LDFLAGS = $(LIBADD_DL)
 tests_testHttpRequest_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
@@ -2868,41 +2854,40 @@
 	event.cc \
 	EventLoop.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
-	HttpRequestMethod.cc \
 	RequestFlags.cc \
 	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Mem.h \
 	tests/stub_mem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Notes.h \
 	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	refresh.h \
 	refresh.cc \
@@ -2981,40 +2966,41 @@
 	tests/testStoreHashIndex.cc \
 	tests/testStoreHashIndex.h \
 	tests/testStoreSupport.cc \
 	tests/testStoreSupport.h \
 	tests/TestSwapDir.cc \
 	tests/TestSwapDir.h \
 	tests/stub_time.cc \
 	url.cc \
 	wordlist.h \
 	wordlist.cc
 
 nodist_tests_testStore_SOURCES= \
 	$(TESTSOURCES) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 
 tests_testStore_LDADD= \
 	libsquid.la \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(COMPAT_LIB) \
@@ -3136,41 +3122,40 @@
 	StoreIOState.cc \
 	StoreMetaUnpacker.cc \
 	$(STOREMETA_SOURCE) \
 	StoreFileSystem.cc \
 	store_io.cc \
 	store_swapout.cc \
 	store_swapmeta.cc \
 	$(UNLINKDSOURCE) \
 	$(WIN32_SOURCE) \
 	event.cc \
 	$(DELAY_POOL_SOURCE) \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	ConfigParser.cc \
 	EventLoop.cc \
 	HttpMsg.cc \
 	RemovalPolicy.cc \
 	store_dir.cc \
 	repl_modules.h \
 	store.cc \
-	HttpRequestMethod.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
 	Parsing.cc \
 	ConfigOption.cc \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	tests/stub_debug.cc \
 	tests/stub_client_side_request.cc \
 	tests/stub_http.cc \
 	tests/stub_libauth.cc \
 	mem_node.cc \
@@ -3210,40 +3195,41 @@
 	refresh.h \
 	refresh.cc \
 	tests/stub_store_client.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/testStoreSupport.cc \
 	tests/testStoreSupport.h \
 	time.cc \
 	wordlist.h \
 	wordlist.cc \
 	$(DISKIO_SOURCE)
 
 nodist_tests_testUfs_SOURCES = \
 	$(TESTSOURCES) \
 	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testUfs_LDADD = \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
 	$(REPL_OBJS) \
 	acl/libacls.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	base/libbase.la \
@@ -3294,41 +3280,40 @@
 	fd.cc \
 	fde.h \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpHeaderFieldStat.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHdrCc.cc \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	RequestFlags.cc \
 	RequestFlags.h \
 	StatCounters.h \
 	StatCounters.cc \
@@ -3395,40 +3380,41 @@
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	time.cc \
 	url.cc \
 	wordlist.h \
 	wordlist.cc \
 	$(DELAY_POOL_SOURCE) \
 	$(DISKIO_SOURCE) \
 	$(UNLINKDSOURCE)
 nodist_tests_testRock_SOURCES = \
 	$(DISKIO_GEN_SOURCE) \
 	swap_log_op.cc \
 	SquidMath.cc \
 	SquidMath.h \
 	$(TESTSOURCES)
 tests_testRock_LDADD = \
 	http/libsquid-http.la \
+	parser/libsquid-parser.la \
 	libsquid.la \
 	comm/libcomm.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(COMMON_LIBS) \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	anyp/libanyp.la \
 	eui/libeui.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
@@ -3503,49 +3489,46 @@
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
-	HttpParser.cc \
-	HttpParser.h \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
-	HttpRequestMethod.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	Mem.h \
 	tests/stub_mem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -3634,47 +3617,47 @@
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
 	ftp/libftp.la \
+	parser/libsquid-parser.la \
 	anyp/libanyp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
-	parser/libsquid-parser.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	$(DISK_OS_LIBS) \
 	format/libformat.la \
 	$(REGEXLIB) \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \

=== modified file 'src/MemObject.h'
--- src/MemObject.h	2014-09-13 13:59:43 +0000
+++ src/MemObject.h	2014-09-14 12:23:03 +0000
@@ -1,34 +1,34 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_MEMOBJECT_H
 #define SQUID_MEMOBJECT_H
 
 #include &quot;CommRead.h&quot;
 #include &quot;dlink.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;RemovalPolicy.h&quot;
 #include &quot;stmem.h&quot;
 #include &quot;StoreIOBuffer.h&quot;
 #include &quot;StoreIOState.h&quot;
 
 #if USE_DELAY_POOLS
 #include &quot;DelayId.h&quot;
 #endif
 
 typedef void STMCB (void *data, StoreIOBuffer wroteBuffer);
 
 class store_client;
 class HttpRequest;
 class HttpReply;
 
 class MemObject
 {
 
 public:
     static size_t inUseCount();

=== modified file 'src/Store.h'
--- src/Store.h	2014-09-13 13:59:43 +0000
+++ src/Store.h	2014-09-14 12:23:03 +0000
@@ -1,42 +1,43 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_STORE_H
 #define SQUID_STORE_H
 
 /**
  \defgroup StoreAPI  Store API
  \ingroup FileSystems
  */
 
 #include &quot;base/RefCount.h&quot;
 #include &quot;comm/forward.h&quot;
 #include &quot;CommRead.h&quot;
 #include &quot;hash.h&quot;
+#include &quot;http/forward.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;HttpReply.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;Range.h&quot;
 #include &quot;RemovalPolicy.h&quot;
 #include &quot;StoreIOBuffer.h&quot;
 #include &quot;StoreStats.h&quot;
 
 #if USE_SQUID_ESI
 #include &quot;esi/Element.h&quot;
 #endif
 
 #include &lt;ostream&gt;
 
 class AsyncCall;
 class HttpRequest;
 class Packer;
 class RequestFlags;
 class StoreClient;
 class StoreSearch;
 class SwapDir;
 

=== modified file 'src/acl/Method.h'
--- src/acl/Method.h	2014-09-13 13:59:43 +0000
+++ src/acl/Method.h	2014-09-14 12:23:03 +0000
@@ -1,34 +1,34 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMETHOD_H
 #define SQUID_ACLMETHOD_H
 
 #include &quot;acl/Strategised.h&quot;
 #include &quot;acl/Strategy.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 
 /// \ingroup ACLAPI
 class ACLMethodStrategy : public ACLStrategy&lt;HttpRequestMethod&gt;
 {
 
 public:
     virtual int match (ACLData&lt;MatchType&gt; * &amp;, ACLFilledChecklist *, ACLFlags &amp;);
     virtual bool requiresRequest() const {return true;}
 
     static ACLMethodStrategy *Instance();
 
     /**
      * Not implemented to prevent copies of the instance.
      \par
      * Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends
      */
     ACLMethodStrategy(ACLMethodStrategy const &amp;);
 
 private:

=== modified file 'src/acl/MethodData.cc'
--- src/acl/MethodData.cc	2014-09-13 13:59:43 +0000
+++ src/acl/MethodData.cc	2014-10-15 06:21:21 +0000
@@ -1,35 +1,35 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/MethodData.h&quot;
 #include &quot;cache_cf.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 
 int ACLMethodData::ThePurgeCount = 0;
 
 ACLMethodData::ACLMethodData() : values (NULL)
 {}
 
 ACLMethodData::ACLMethodData(ACLMethodData const &amp;old) : values (NULL)
 {
     assert (!old.values);
 }
 
 ACLMethodData::~ACLMethodData()
 {
     if (values)
         delete values;
 }
 
 /// todo make this a pass-by-reference now that HTTPRequestMethods a full class?
 bool
 ACLMethodData::match(HttpRequestMethod toFind)
@@ -48,40 +48,42 @@
 {
     SBufList sl;
     CbDataList&lt;HttpRequestMethod&gt; *data = values;
 
     while (data != NULL) {
         sl.push_back(data-&gt;element.image());
         data = data-&gt;next;
     }
 
     return sl;
 }
 
 void
 ACLMethodData::parse()
 {
     CbDataList&lt;HttpRequestMethod&gt; **Tail;
     char *t = NULL;
 
     for (Tail = &values; *Tail; Tail = &amp;((*Tail)-&gt;next));
     while ((t = strtokFile())) {
-        CbDataList&lt;HttpRequestMethod&gt; *q = new CbDataList&lt;HttpRequestMethod&gt; (HttpRequestMethod(t, NULL));
+        HttpRequestMethod m;
+        m.HttpRequestMethodXXX(t);
+        CbDataList&lt;HttpRequestMethod&gt; *q = new CbDataList&lt;HttpRequestMethod&gt;(m);
         if (q-&gt;element == Http::METHOD_PURGE)
             ++ThePurgeCount; // configuration code wants to know
         *(Tail) = q;
         Tail = &amp;q-&gt;next;
     }
 }
 
 bool
 ACLMethodData::empty() const
 {
     return values == NULL;
 }
 
 ACLData&lt;HttpRequestMethod&gt; *
 ACLMethodData::clone() const
 {
     assert (!values);
     return new ACLMethodData(*this);
 }

=== modified file 'src/acl/MethodData.h'
--- src/acl/MethodData.h	2014-09-13 13:59:43 +0000
+++ src/acl/MethodData.h	2014-09-14 12:23:03 +0000
@@ -1,35 +1,35 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMETHODDATA_H
 #define SQUID_ACLMETHODDATA_H
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Data.h&quot;
 #include &quot;CbDataList.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 
 /// \ingroup ACLAPI
 class ACLMethodData : public ACLData&lt;HttpRequestMethod&gt;
 {
 
 public:
     MEMPROXY_CLASS(ACLMethodData);
 
     ACLMethodData();
     ACLMethodData(ACLMethodData const &amp;);
     ACLMethodData &amp;operator= (ACLMethodData const &amp;);
     virtual ~ACLMethodData();
     bool match(HttpRequestMethod);
     virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData&lt;HttpRequestMethod&gt; *clone() const;
 
     CbDataList&lt;HttpRequestMethod&gt; *values;
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2014-09-13 13:59:43 +0000
+++ src/cache_cf.cc	2014-09-14 12:23:03 +0000
@@ -16,41 +16,40 @@
 #include &quot;acl/AclSizeLimit.h&quot;
 #include &quot;acl/Gadgets.h&quot;
 #include &quot;acl/MethodData.h&quot;
 #include &quot;acl/Tree.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;anyp/UriScheme.h&quot;
 #include &quot;AuthReg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;CachePeer.h&quot;
 #include &quot;CachePeerDomainList.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;CpuAffinityMap.h&quot;
 #include &quot;DiskIO/DiskIOModule.h&quot;
 #include &quot;eui/Config.h&quot;
 #include &quot;ExternalACL.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;ftp/Elements.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
 #include &quot;ident/Config.h&quot;
 #include &quot;ip/Intercept.h&quot;
 #include &quot;ip/QosConfig.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;ipc/Kids.h&quot;
 #include &quot;log/Config.h&quot;
 #include &quot;log/CustomLog.h&quot;
 #include &quot;Mem.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;mgr/ActionPasswordList.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;neighbors.h&quot;
 #include &quot;NeighborTypeDomainList.h&quot;
 #include &quot;Parsing.h&quot;
 #include &quot;pconn.h&quot;
 #include &quot;PeerDigest.h&quot;
 #include &quot;PeerPoolMgr.h&quot;
 #include &quot;RefreshPattern.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;SBufList.h&quot;

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2014-10-07 14:11:12 +0000
+++ src/client_side.cc	2014-10-15 14:07:41 +0000
@@ -69,40 +69,41 @@
 #include &quot;client_side_reply.h&quot;
 #include &quot;client_side_request.h&quot;
 #include &quot;ClientRequestContext.h&quot;
 #include &quot;clientStream.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;comm/Loops.h&quot;
 #include &quot;comm/Read.h&quot;
 #include &quot;comm/TcpAcceptor.h&quot;
 #include &quot;comm/Write.h&quot;
 #include &quot;CommCalls.h&quot;
 #include &quot;errorpage.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;fqdncache.h&quot;
 #include &quot;FwdState.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;helper.h&quot;
 #include &quot;helper/Reply.h&quot;
 #include &quot;http.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
 #include &quot;HttpHdrContRange.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;ident/Config.h&quot;
 #include &quot;ident/Ident.h&quot;
 #include &quot;internal.h&quot;
 #include &quot;ipc/FdNotes.h&quot;
 #include &quot;ipc/StartListening.h&quot;
 #include &quot;log/access_log.h&quot;
 #include &quot;Mem.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mime_header.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 #include &quot;profiler/Profiler.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;servers/forward.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
@@ -181,41 +182,40 @@
 #endif
 static CTCB clientLifetimeTimeout;
 #if USE_IDENT
 static IDCB clientIdentDone;
 #endif
 static int clientIsContentLengthValid(HttpRequest * r);
 static int clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength);
 
 static void clientUpdateStatHistCounters(LogTags logType, int svc_time);
 static void clientUpdateStatCounters(LogTags logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &amp;);
 #ifndef PURIFY
 static bool connIsUsable(ConnStateData * conn);
 #endif
 static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
 static void clientUpdateSocketStats(LogTags logType, size_t size);
 
 char *skipLeadingSpace(char *aString);
-static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
 
 clientStreamNode *
 ClientSocketContext::getTail() const
 {
     if (http-&gt;client_stream.tail)
         return (clientStreamNode *)http-&gt;client_stream.tail-&gt;data;
 
     return NULL;
 }
 
 clientStreamNode *
 ClientSocketContext::getClientReplyContext() const
 {
     return (clientStreamNode *)http-&gt;client_stream.tail-&gt;prev-&gt;data;
 }
 
 ConnStateData *
 ClientSocketContext::getConn() const
 {
     return http-&gt;getConn();
@@ -1979,359 +1979,307 @@
             char *tmp_uri = static_cast&lt;char*&gt;(xmalloc(strlen(uri) + 1));
             char *q = tmp_uri;
             t = uri;
             while (*t) {
                 if (!xisspace(*t)) {
                     *q = *t;
                     ++q;
                 }
                 ++t;
             }
             *q = '\0';
             http-&gt;log_uri = xstrndup(rfc1738_escape_unescaped(tmp_uri), MAX_URL);
             xfree(tmp_uri);
         }
         break;
         }
     }
 }
 
 static void
-prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url, const char *req_hdr)
+prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, const Http1::RequestParserPointer &amp;hp)
 {
     int vhost = conn-&gt;port-&gt;vhost;
     int vport = conn-&gt;port-&gt;vport;
-    char *host;
-    char ipbuf[MAX_IPSTRLEN];
+    static char ipbuf[MAX_IPSTRLEN];
 
     http-&gt;flags.accel = true;
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
 
-    if (strncasecmp(url, &quot;cache_<A HREF="object://">object://</A>&quot;, 15) == 0)
+    static const SBuf cache_object(&quot;cache_<A HREF="object://">object://</A>&quot;);
+    if (hp-&gt;requestUri().startsWith(cache_object))
         return; /* already in good shape */
 
-    if (*url != '/') {
+    // XXX: re-use proper URL parser for this
+    SBuf url = hp-&gt;requestUri(); // use full provided URI if we abort
+    do { // use a loop so we can break out of it
+        ::Parser::Tokenizer tok(url);
+        if (tok.skip('/')) // origin-form URL already.
+            break;
+
         if (conn-&gt;port-&gt;vhost)
             return; /* already in good shape */
 
-        /* else we need to ignore the host name */
-        url = strstr(url, &quot;//&quot;);
+        // skip the URI scheme
+        static const CharacterSet uriScheme = CharacterSet(&quot;URI-scheme&quot;,&quot;+-.&quot;) + CharacterSet::ALPHA + CharacterSet::DIGIT;
+        static const SBuf uriSchemeEnd(&quot;://&quot;);
+        if (!tok.skipAll(uriScheme) || !tok.skip(uriSchemeEnd))
+            break;
 
-#if SHOULD_REJECT_UNKNOWN_URLS
+        // skip the authority segment
+        // RFC 3986 complex nested ABNF for &quot;authority&quot; boils down to this:
+        static const CharacterSet authority = CharacterSet(&quot;authority&quot;,&quot;-._~%:@[]!$&amp;'()*+,;=&quot;) +
+             CharacterSet::HEXDIG + CharacterSet::ALPHA + CharacterSet::DIGIT;
+        if (!tok.skipAll(authority))
+            break;
 
-        if (!url) {
-            hp-&gt;request_parse_status = Http::scBadRequest;
-            return conn-&gt;abortRequestParsing(&quot;error:invalid-request&quot;);
-        }
-#endif
+        static const SBuf slashUri(&quot;/&quot;);
+        const SBuf t = tok.remaining();
+        if (t.isEmpty())
+            url = slashUri;
+        else if (t[0]=='/') // looks like path
+            url = t;
+        else if (t[0]=='?' || t[0]=='#') { // looks like query or fragment. fix '/'
+            url = slashUri;
+            url.append(t);
+        } // else do nothing. invalid path
 
-        if (url)
-            url = strchr(url + 2, '/');
+    } while(false);
 
-        if (!url)
-            url = (char *) &quot;/&quot;;
+#if SHOULD_REJECT_UNKNOWN_URLS
+    // reject URI which are not well-formed even after the processing above
+    if (url.isEmpty() || url[0] != '/') {
+        hp-&gt;request_parse_status = Http::scBadRequest;
+        return conn-&gt;abortRequestParsing(&quot;error:invalid-request&quot;);
     }
+#endif
 
     if (vport &lt; 0)
         vport = http-&gt;getConn()-&gt;clientConnection-&gt;local.port();
 
     const bool switchedToHttps = conn-&gt;switchedToHttps();
     const bool tryHostHeader = vhost || switchedToHttps;
-    if (tryHostHeader &amp;&amp; (host = mime_get_header(req_hdr, &quot;Host&quot;)) != NULL) {
+    char *host = NULL;
+    if (tryHostHeader &amp;&amp; (host = hp-&gt;getHeaderField(&quot;Host&quot;))) {
         debugs(33, 5, &quot;ACCEL VHOST REWRITE: vhost=&quot; &lt;&lt; host &lt;&lt; &quot; + vport=&quot; &lt;&lt; vport);
         char thost[256];
         if (vport &gt; 0) {
             thost[0] = '\0';
             char *t = NULL;
             if (host[strlen(host)] != ']' &amp;&amp; (t = strrchr(host,':')) != NULL) {
                 strncpy(thost, host, (t-host));
                 snprintf(thost+(t-host), sizeof(thost)-(t-host), &quot;:%d&quot;, vport);
                 host = thost;
             } else if (!t) {
                 snprintf(thost, sizeof(thost), &quot;%s:%d&quot;,host, vport);
                 host = thost;
             }
         } // else nothing to alter port-wise.
-        int url_sz = strlen(url) + 32 + Config.appendDomainLen +
-                     strlen(host);
+        const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen + strlen(host);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         const char *protocol = switchedToHttps ?
                                &quot;https&quot; : AnyP::UriScheme(conn-&gt;port-&gt;transport.protocol).c_str();
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s%s">s://%s%s</A>&quot;, protocol, host, url);
-        debugs(33, 5, &quot;ACCEL VHOST REWRITE: '&quot; &lt;&lt; http-&gt;uri &lt;&lt; &quot;'&quot;);
+        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s">s://%s</A>&quot; SQUIDSBUFPH, protocol, host, SQUIDSBUFPRINT(url));
+        debugs(33, 5, &quot;ACCEL VHOST REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else if (conn-&gt;port-&gt;defaultsite /* &amp;&amp; !vhost */) {
         debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: defaultsite=&quot; &lt;&lt; conn-&gt;port-&gt;defaultsite &lt;&lt; &quot; + vport=&quot; &lt;&lt; vport);
-        int url_sz = strlen(url) + 32 + Config.appendDomainLen +
+        const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen +
                      strlen(conn-&gt;port-&gt;defaultsite);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         char vportStr[32];
         vportStr[0] = '\0';
         if (vport &gt; 0) {
             snprintf(vportStr, sizeof(vportStr),&quot;:%d&quot;,vport);
         }
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s%s%s">s://%s%s%s</A>&quot;,
-                 AnyP::UriScheme(conn-&gt;port-&gt;transport.protocol).c_str(), conn-&gt;port-&gt;defaultsite, vportStr, url);
-        debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: '&quot; &lt;&lt; http-&gt;uri &lt;&lt;&quot;'&quot;);
+        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s%s">s://%s%s</A>&quot; SQUIDSBUFPH,
+                 AnyP::UriScheme(conn-&gt;port-&gt;transport.protocol).c_str(), conn-&gt;port-&gt;defaultsite, vportStr, SQUIDSBUFPRINT(url));
+        debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else if (vport &gt; 0 /* &amp;&amp; (!vhost || no Host:) */) {
         debugs(33, 5, &quot;ACCEL VPORT REWRITE: *_port IP + vport=&quot; &lt;&lt; vport);
         /* Put the local socket IP address as the hostname, with whatever vport we found  */
-        int url_sz = strlen(url) + 32 + Config.appendDomainLen;
+        const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         http-&gt;getConn()-&gt;clientConnection-&gt;local.toHostStr(ipbuf,MAX_IPSTRLEN);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s:%d%s">s://%s:%d%s</A>&quot;,
+        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s:%d">s://%s:%d</A>&quot; SQUIDSBUFPH,
                  AnyP::UriScheme(conn-&gt;port-&gt;transport.protocol).c_str(),
-                 ipbuf, vport, url);
-        debugs(33, 5, &quot;ACCEL VPORT REWRITE: '&quot; &lt;&lt; http-&gt;uri &lt;&lt; &quot;'&quot;);
+                 ipbuf, vport, SQUIDSBUFPRINT(url));
+        debugs(33, 5, &quot;ACCEL VPORT REWRITE: &quot; &lt;&lt; http-&gt;uri);
     }
 }
 
 static void
-prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url, const char *req_hdr)
+prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1::RequestParserPointer &amp;hp)
 {
-    char *host;
-    char ipbuf[MAX_IPSTRLEN];
-
-    if (*url != '/')
+    // TODO Must() on URI !empty when the parser supports throw. For now avoid assert().
+    if (!hp-&gt;requestUri().isEmpty() &amp;&amp; hp-&gt;requestUri()[0] != '/')
         return; /* already in good shape */
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
 
-    if ((host = mime_get_header(req_hdr, &quot;Host&quot;)) != NULL) {
-        int url_sz = strlen(url) + 32 + Config.appendDomainLen +
+    if (const char *host = hp-&gt;getHeaderField(&quot;Host&quot;)) {
+        const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen +
                      strlen(host);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s%s">s://%s%s</A>&quot;, AnyP::UriScheme(conn-&gt;port-&gt;transport.protocol).c_str(), host, url);
-        debugs(33, 5, &quot;TRANSPARENT HOST REWRITE: '&quot; &lt;&lt; http-&gt;uri &lt;&lt;&quot;'&quot;);
+        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s">s://%s</A>&quot; SQUIDSBUFPH,
+             AnyP::UriScheme(conn-&gt;port-&gt;transport.protocol).c_str(), host, SQUIDSBUFPRINT(hp-&gt;requestUri()));
+        debugs(33, 5, &quot;TRANSPARENT HOST REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else {
         /* Put the local socket IP address as the hostname.  */
-        int url_sz = strlen(url) + 32 + Config.appendDomainLen;
+        const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
+        static char ipbuf[MAX_IPSTRLEN];
         http-&gt;getConn()-&gt;clientConnection-&gt;local.toHostStr(ipbuf,MAX_IPSTRLEN);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s:%d%s">s://%s:%d%s</A>&quot;,
+        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s:%d">s://%s:%d</A>&quot; SQUIDSBUFPH,
                  AnyP::UriScheme(http-&gt;getConn()-&gt;port-&gt;transport.protocol).c_str(),
-                 ipbuf, http-&gt;getConn()-&gt;clientConnection-&gt;local.port(), url);
-        debugs(33, 5, &quot;TRANSPARENT REWRITE: '&quot; &lt;&lt; http-&gt;uri &lt;&lt; &quot;'&quot;);
+                 ipbuf, http-&gt;getConn()-&gt;clientConnection-&gt;local.port(), SQUIDSBUFPRINT(hp-&gt;requestUri()));
+        debugs(33, 5, &quot;TRANSPARENT REWRITE: &quot; &lt;&lt; http-&gt;uri);
     }
 }
 
 /** Parse an HTTP request
  *
  *  \note Sets result-&gt;flags.parsed_ok to 0 if failed to parse the request,
  *          to 1 if the request was correctly parsed.
  *  \param[in] csd a ConnStateData. The caller must make sure it is not null
- *  \param[in] hp an HttpParser
+ *  \param[in] hp an Http1::RequestParser
  *  \param[out] mehtod_p will be set as a side-effect of the parsing.
  *          Pointed-to value will be set to Http::METHOD_NONE in case of
  *          parsing failure
  *  \param[out] http_ver will be set as a side-effect of the parsing
  *  \return NULL on incomplete requests,
  *          a ClientSocketContext structure on success or failure.
  */
 ClientSocketContext *
-parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_p, Http::ProtocolVersion *http_ver)
+parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &amp;hp)
 {
-    char *req_hdr = NULL;
-    char *end;
-    size_t req_sz;
-    ClientHttpRequest *http;
-    ClientSocketContext *result;
-    StoreIOBuffer tempBuffer;
-    int r;
-
-    /* pre-set these values to make aborting simpler */
-    *method_p = Http::METHOD_NONE;
-
-    /* NP: don't be tempted to move this down or remove again.
-     * It's the only DDoS protection old-String has against long URL */
-    if ( hp-&gt;bufsiz &lt;= 0) {
-        debugs(33, 5, &quot;Incomplete request, waiting for end of request line&quot;);
-        return NULL;
-    } else if ( (size_t)hp-&gt;bufsiz &gt;= Config.maxRequestHeaderSize &amp;&amp; headersEnd(hp-&gt;buf, Config.maxRequestHeaderSize) == 0) {
-        debugs(33, 5, &quot;parseHttpRequest: Too large request&quot;);
-        hp-&gt;request_parse_status = Http::scHeaderTooLarge;
-        return csd-&gt;abortRequestParsing(&quot;error:request-too-large&quot;);
-    }
-
-    /* Attempt to parse the first line; this'll define the method, url, version and header begin */
-    r = HttpParserParseReqLine(hp);
-
-    if (r == 0) {
-        debugs(33, 5, &quot;Incomplete request, waiting for end of request line&quot;);
-        return NULL;
-    }
-
-    if (r == -1) {
-        return csd-&gt;abortRequestParsing(&quot;error:invalid-request&quot;);
-    }
+    /* Attempt to parse the first line; this will define where the method, url, version and header begin */
+    {
+        const bool parsedOk = hp-&gt;parse(csd-&gt;in.buf);
 
-    /* Request line is valid here .. */
-    *http_ver = Http::ProtocolVersion(hp-&gt;req.v_maj, hp-&gt;req.v_min);
+        // sync the buffers after parsing.
+        csd-&gt;in.buf = hp-&gt;remaining();
 
-    /* This call scans the entire request, not just the headers */
-    if (hp-&gt;req.v_maj &gt; 0) {
-        if ((req_sz = headersEnd(hp-&gt;buf, hp-&gt;bufsiz)) == 0) {
-            debugs(33, 5, &quot;Incomplete request, waiting for end of headers&quot;);
+        if (hp-&gt;needsMoreData()) {
+            debugs(33, 5, &quot;Incomplete request, waiting for end of request line&quot;);
             return NULL;
         }
-    } else {
-        debugs(33, 3, &quot;parseHttpRequest: Missing HTTP identifier&quot;);
-        req_sz = HttpParserReqSz(hp);
-    }
-
-    /* We know the whole request is in hp-&gt;buf now */
-
-    assert(req_sz &lt;= (size_t) hp-&gt;bufsiz);
 
-    /* Will the following be true with HTTP/0.9 requests? probably not .. */
-    /* So the rest of the code will need to deal with '0'-byte headers (ie, none, so don't try parsing em) */
-    assert(req_sz &gt; 0);
+        if (!parsedOk) {
+            if (hp-&gt;request_parse_status == Http::scRequestHeaderFieldsTooLarge || hp-&gt;request_parse_status == Http::scUriTooLong)
+                return csd-&gt;abortRequestParsing(&quot;error:request-too-large&quot;);
 
-    hp-&gt;hdr_end = req_sz - 1;
-
-    hp-&gt;hdr_start = hp-&gt;req.end + 1;
-
-    /* Enforce max_request_size */
-    if (req_sz &gt;= Config.maxRequestHeaderSize) {
-        debugs(33, 5, &quot;parseHttpRequest: Too large request&quot;);
-        hp-&gt;request_parse_status = Http::scHeaderTooLarge;
-        return csd-&gt;abortRequestParsing(&quot;error:request-too-large&quot;);
+            return csd-&gt;abortRequestParsing(&quot;error:invalid-request&quot;);
+        }
     }
 
-    /* Set method_p */
-    *method_p = HttpRequestMethod(&amp;hp-&gt;buf[hp-&gt;req.m_start], &amp;hp-&gt;buf[hp-&gt;req.m_end]+1);
+    /* We know the whole request is in parser now */
+    debugs(11, 2, &quot;HTTP Client &quot; &lt;&lt; csd-&gt;clientConnection);
+    debugs(11, 2, &quot;HTTP Client REQUEST:\n---------\n&quot; &lt;&lt;
+           hp-&gt;method() &lt;&lt; &quot; &quot; &lt;&lt; hp-&gt;requestUri() &lt;&lt; &quot; &quot; &lt;&lt; hp-&gt;messageProtocol() &lt;&lt; &quot;\n&quot; &lt;&lt;
+           hp-&gt;mimeHeader() &lt;&lt;
+           &quot;\n----------&quot;);
 
     /* deny CONNECT via accelerated ports */
-    if (*method_p == Http::METHOD_CONNECT &amp;&amp; csd-&gt;port != NULL &amp;&amp; csd-&gt;port-&gt;flags.accelSurrogate) {
+    if (hp-&gt;method() == Http::METHOD_CONNECT &amp;&amp; csd-&gt;port != NULL &amp;&amp; csd-&gt;port-&gt;flags.accelSurrogate) {
         debugs(33, DBG_IMPORTANT, &quot;WARNING: CONNECT method received on &quot; &lt;&lt; csd-&gt;port-&gt;transport.protocol &lt;&lt; &quot; Accelerator port &quot; &lt;&lt; csd-&gt;port-&gt;s.port());
-        /* XXX need a way to say &quot;this many character length string&quot; */
-        debugs(33, DBG_IMPORTANT, &quot;WARNING: for request: &quot; &lt;&lt; hp-&gt;buf);
+        debugs(33, DBG_IMPORTANT, &quot;WARNING: for request: &quot; &lt;&lt; hp-&gt;method() &lt;&lt; &quot; &quot; &lt;&lt; hp-&gt;requestUri() &lt;&lt; &quot; &quot; &lt;&lt; hp-&gt;messageProtocol());
         hp-&gt;request_parse_status = Http::scMethodNotAllowed;
         return csd-&gt;abortRequestParsing(&quot;error:method-not-allowed&quot;);
     }
 
-    if (*method_p == Http::METHOD_NONE) {
-        /* XXX need a way to say &quot;this many character length string&quot; */
-        debugs(33, DBG_IMPORTANT, &quot;clientParseRequestMethod: Unsupported method in request '&quot; &lt;&lt; hp-&gt;buf &lt;&lt; &quot;'&quot;);
+    if (hp-&gt;method() == Http::METHOD_NONE) {
+        debugs(33, DBG_IMPORTANT, &quot;WARNING: Unsupported method: &quot; &lt;&lt; hp-&gt;method() &lt;&lt; &quot; &quot; &lt;&lt; hp-&gt;requestUri() &lt;&lt; &quot; &quot; &lt;&lt; hp-&gt;messageProtocol());
         hp-&gt;request_parse_status = Http::scMethodNotAllowed;
         return csd-&gt;abortRequestParsing(&quot;error:unsupported-request-method&quot;);
     }
 
-    /*
-     * Process headers after request line
-     * TODO: Use httpRequestParse here.
-     */
-    /* XXX this code should be modified to take a const char * later! */
-    req_hdr = (char *) hp-&gt;buf + hp-&gt;req.end + 1;
-
-    debugs(33, 3, &quot;parseHttpRequest: req_hdr = {&quot; &lt;&lt; req_hdr &lt;&lt; &quot;}&quot;);
-
-    end = (char *) hp-&gt;buf + hp-&gt;hdr_end;
-
-    debugs(33, 3, &quot;parseHttpRequest: end = {&quot; &lt;&lt; end &lt;&lt; &quot;}&quot;);
-
-    debugs(33, 3, &quot;parseHttpRequest: prefix_sz = &quot; &lt;&lt;
-           (int) HttpParserRequestLen(hp) &lt;&lt; &quot;, req_line_sz = &quot; &lt;&lt;
-           HttpParserReqSz(hp));
+    // Process headers after request line
+    debugs(33, 3, &quot;complete request received. &quot; &lt;&lt;
+           &quot;prefix_sz = &quot; &lt;&lt; hp-&gt;messageHeaderSize() &lt;&lt;
+           &quot;, request-line-size=&quot; &lt;&lt; hp-&gt;firstLineSize() &lt;&lt;
+           &quot;, mime-header-size=&quot; &lt;&lt; hp-&gt;headerBlockSize() &lt;&lt;
+           &quot;, mime header block:\n&quot; &lt;&lt; hp-&gt;mimeHeader() &lt;&lt; &quot;\n----------&quot;);
 
     /* Ok, all headers are received */
-    http = new ClientHttpRequest(csd);
+    ClientHttpRequest *http = new ClientHttpRequest(csd);
 
-    http-&gt;req_sz = HttpParserRequestLen(hp);
-    result = new ClientSocketContext(csd-&gt;clientConnection, http);
+    http-&gt;req_sz = hp-&gt;messageHeaderSize();
+    ClientSocketContext *result = new ClientSocketContext(csd-&gt;clientConnection, http);
+
+    StoreIOBuffer tempBuffer;
     tempBuffer.data = result-&gt;reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
 
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
                      clientSocketDetach, newClient, tempBuffer);
 
-    debugs(33, 5, &quot;parseHttpRequest: Request Header is\n&quot; &lt;&lt;(hp-&gt;buf) + hp-&gt;hdr_start);
-
     /* set url */
-    /*
-     * XXX this should eventually not use a malloc'ed buffer; the transformation code
-     * below needs to be modified to not expect a mutable nul-terminated string.
-     */
-    char *url = (char *)xmalloc(hp-&gt;req.u_end - hp-&gt;req.u_start + 16);
-
-    memcpy(url, hp-&gt;buf + hp-&gt;req.u_start, hp-&gt;req.u_end - hp-&gt;req.u_start + 1);
-
-    url[hp-&gt;req.u_end - hp-&gt;req.u_start + 1] = '\0';
-
-#if THIS_VIOLATES_HTTP_SPECS_ON_URL_TRANSFORMATION
-
-    if ((t = strchr(url, '#')))	/* remove HTML anchors */
-        *t = '\0';
-
-#endif
+    // XXX: c_str() does re-allocate but here replaces explicit malloc/free.
+    // when internalCheck() accepts SBuf removing this will be a net gain for performance.
+    SBuf tmp(hp-&gt;requestUri());
+    const char *url = tmp.c_str();
 
     debugs(33,5, HERE &lt;&lt; &quot;repare absolute URL from &quot; &lt;&lt;
            (csd-&gt;transparent()?&quot;intercept&quot;:(csd-&gt;port-&gt;flags.accelSurrogate ? &quot;accel&quot;:&quot;&quot;)));
     /* Rewrite the URL in transparent or accelerator mode */
     /* NP: there are several cases to traverse here:
      *  - standard mode (forward proxy)
      *  - transparent mode (TPROXY)
      *  - transparent mode with failures
      *  - intercept mode (NAT)
      *  - intercept mode with failures
      *  - accelerator mode (reverse proxy)
      *  - internal URL
      *  - mixed combos of the above with internal URL
      *  - remote interception with PROXY protocol
      *  - remote reverse-proxy with PROXY protocol
      */
     if (csd-&gt;transparent()) {
         /* intercept or transparent mode, properly working with no failures */
-        prepareTransparentURL(csd, http, url, req_hdr);
+        prepareTransparentURL(csd, http, hp);
 
     } else if (internalCheck(url)) {
         /* internal URL mode */
         /* prepend our name &amp; port */
         http-&gt;uri = xstrdup(internalLocalUri(NULL, url));
         // We just re-wrote the URL. Must replace the Host: header.
         //  But have not parsed there yet!! flag for local-only handling.
         http-&gt;flags.internal = true;
 
     } else if (csd-&gt;port-&gt;flags.accelSurrogate || csd-&gt;switchedToHttps()) {
         /* accelerator mode */
-        prepareAcceleratedURL(csd, http, url, req_hdr);
+        prepareAcceleratedURL(csd, http, hp);
     }
 
     if (!http-&gt;uri) {
         /* No special rewrites have been applied above, use the
          * requested url. may be rewritten later, so make extra room */
-        int url_sz = strlen(url) + Config.appendDomainLen + 5;
+        int url_sz = hp-&gt;requestUri().length() + Config.appendDomainLen + 5;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         strcpy(http-&gt;uri, url);
     }
 
-    debugs(33, 5, &quot;parseHttpRequest: Complete request received&quot;);
-
-    // XXX: crop this dump at the end of headers. No need for extras
-    debugs(11, 2, &quot;HTTP Client &quot; &lt;&lt; csd-&gt;clientConnection);
-    debugs(11, 2, &quot;HTTP Client REQUEST:\n---------\n&quot; &lt;&lt; (hp-&gt;buf) + hp-&gt;req.m_start &lt;&lt; &quot;\n----------&quot;);
-
     result-&gt;flags.parsed_ok = 1;
-    xfree(url);
     return result;
 }
 
 bool
 ConnStateData::In::maybeMakeSpaceAvailable()
 {
     if (buf.spaceSize() &lt; 2) {
         const SBuf::size_type haveCapacity = buf.length() + buf.spaceSize();
         if (haveCapacity &gt;= Config.maxRequestBufferSize) {
             debugs(33, 4, &quot;request buffer full: client_request_buffer_max_size=&quot; &lt;&lt; Config.maxRequestBufferSize);
             return false;
         }
         if (haveCapacity == 0) {
             // haveCapacity is based on the SBuf visible window of the MemBlob buffer, which may fill up.
             // at which point bump the buffer back to default. This allocates a new MemBlob with any un-parsed bytes.
             buf.reserveCapacity(CLIENT_REQ_BUF_SZ);
         } else {
             const SBuf::size_type wantCapacity = min(static_cast&lt;SBuf::size_type&gt;(Config.maxRequestBufferSize), haveCapacity*2);
             buf.reserveCapacity(wantCapacity);
         }
@@ -2373,47 +2321,40 @@
             return 1;
         } else if (!Config.onoff.half_closed_clients) {
             /* admin doesn't want to support half-closed client sockets */
             debugs(33, 3, HERE &lt;&lt; clientConnection &lt;&lt; &quot; aborted (half_closed_clients disabled)&quot;);
             notifyAllContexts(0); // no specific error implies abort
             return 1;
         }
     }
 
     return 0;
 }
 
 void
 ConnStateData::consumeInput(const size_t byteCount)
 {
     assert(byteCount &gt; 0 &amp;&amp; byteCount &lt;= in.buf.length());
     in.buf.consume(byteCount);
     debugs(33, 5, &quot;in.buf has &quot; &lt;&lt; in.buf.length() &lt;&lt; &quot; unused bytes&quot;);
 }
 
-// TODO: Remove when renaming ConnStateData
-void
-connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount)
-{
-    conn-&gt;consumeInput(byteCount);
-}
-
 void
 ConnStateData::clientAfterReadingRequests()
 {
     // Were we expecting to read more request body from half-closed connection?
     if (mayNeedToReadMoreBody() &amp;&amp; commIsHalfClosed(clientConnection-&gt;fd)) {
         debugs(33, 3, HERE &lt;&lt; &quot;truncated body: closing half-closed &quot; &lt;&lt; clientConnection);
         clientConnection-&gt;close();
         return;
     }
 
     if (flags.readMore)
         readSomeData();
 }
 
 void
 ConnStateData::quitAfterError(HttpRequest *request)
 {
     // From HTTP p.o.v., we do not have to close after every error detected
     // at the client-side, but many such errors do require closure and the
     // client-side code is bad at handling errors so we play it safe.
@@ -2499,149 +2440,149 @@
                 }
                 repContext-&gt;setReplyToError(request-&gt;method, err);
                 assert(context-&gt;http-&gt;out.offset == 0);
                 context-&gt;pullData();
                 return true;
             }
         }
     }
 
     return false;
 }
 #endif // USE_OPENSSL
 
 static void
 clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &amp;request)
 {
     /*
      * DPW 2007-05-18
      * Moved the TCP_RESET feature from clientReplyContext::sendMoreData
      * to here because calling comm_reset_close() causes http to
-     * be freed and the above connNoteUseOfBuffer() would hit an
-     * assertion, not to mention that we were accessing freed memory.
+     * be freed before accessing.
      */
     if (request != NULL &amp;&amp; request-&gt;flags.resetTcp &amp;&amp; Comm::IsConnOpen(conn-&gt;clientConnection)) {
         debugs(33, 3, HERE &lt;&lt; &quot;Sending TCP RST on &quot; &lt;&lt; conn-&gt;clientConnection);
         conn-&gt;flags.readMore = false;
         comm_reset_close(conn-&gt;clientConnection);
     }
 }
 
 void
-clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod&amp; method, Http::ProtocolVersion http_ver)
+clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &amp;hp, ClientSocketContext *context)
 {
     ClientHttpRequest *http = context-&gt;http;
     HttpRequest::Pointer request;
-    bool notedUseOfBuffer = false;
     bool chunked = false;
     bool mustReplyToOptions = false;
     bool unsupportedTe = false;
     bool expectBody = false;
 
     // temporary hack to avoid splitting this huge function with sensitive code
     const bool isFtp = !hp;
     if (isFtp) {
         // In FTP, case, we already have the request parsed and checked, so we
         // only need to go through the final body/conn setup to doCallouts().
         assert(http-&gt;request);
         request = http-&gt;request;
-        notedUseOfBuffer = true;
     } else {
 
         if (context-&gt;flags.parsed_ok == 0) {
             clientStreamNode *node = context-&gt;getClientReplyContext();
-            debugs(33, 2, &quot;clientProcessRequest: Invalid Request&quot;);
+            debugs(33, 2, &quot;Invalid Request&quot;);
             conn-&gt;quitAfterError(NULL);
             // setLogUri should called before repContext-&gt;setReplyToError
-            setLogUri(http, http-&gt;uri,  true);
+            setLogUri(http, http-&gt;uri, true);
             clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
-            assert (repContext);
+            assert(repContext);
+
+            // determine which error page templates to use for specific parsing errors
+            err_type errPage = ERR_INVALID_REQ;
             switch (hp-&gt;request_parse_status) {
-            case Http::scHeaderTooLarge:
-                repContext-&gt;setReplyToError(ERR_TOO_BIG, Http::scBadRequest, method, http-&gt;uri, conn-&gt;clientConnection-&gt;remote, NULL, conn-&gt;in.buf.c_str(), NULL);
+            case Http::scRequestHeaderFieldsTooLarge:
+                // fall through to next case
+            case Http::scUriTooLong:
+                errPage = ERR_TOO_BIG;
                 break;
             case Http::scMethodNotAllowed:
-                repContext-&gt;setReplyToError(ERR_UNSUP_REQ, Http::scMethodNotAllowed, method, http-&gt;uri,
-                                            conn-&gt;clientConnection-&gt;remote, NULL, conn-&gt;in.buf.c_str(), NULL);
+                errPage = ERR_UNSUP_REQ;
+                break;
+            case Http::scHttpVersionNotSupported:
+                errPage = ERR_UNSUP_HTTPVERSION;
                 break;
             default:
-                repContext-&gt;setReplyToError(ERR_INVALID_REQ, hp-&gt;request_parse_status, method, http-&gt;uri,
-                                            conn-&gt;clientConnection-&gt;remote, NULL, conn-&gt;in.buf.c_str(), NULL);
+                // use default ERR_INVALID_REQ set above.
+                break;
             }
+            repContext-&gt;setReplyToError(errPage, hp-&gt;request_parse_status, hp-&gt;method(), http-&gt;uri,
+                                        conn-&gt;clientConnection-&gt;remote, NULL, conn-&gt;in.buf.c_str(), NULL);
             assert(context-&gt;http-&gt;out.offset == 0);
             context-&gt;pullData();
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
             return;
         }
 
-        if ((request = HttpRequest::CreateFromUrlAndMethod(http-&gt;uri, method)) == NULL) {
+        if ((request = HttpRequest::CreateFromUrlAndMethod(http-&gt;uri, hp-&gt;method())) == NULL) {
             clientStreamNode *node = context-&gt;getClientReplyContext();
             debugs(33, 5, &quot;Invalid URL: &quot; &lt;&lt; http-&gt;uri);
             conn-&gt;quitAfterError(request.getRaw());
             // setLogUri should called before repContext-&gt;setReplyToError
-            setLogUri(http, http-&gt;uri,  true);
+            setLogUri(http, http-&gt;uri, true);
             clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
-            assert (repContext);
-            repContext-&gt;setReplyToError(ERR_INVALID_URL, Http::scBadRequest, method, http-&gt;uri, conn-&gt;clientConnection-&gt;remote, NULL, NULL, NULL);
+            assert(repContext);
+            repContext-&gt;setReplyToError(ERR_INVALID_URL, Http::scBadRequest, hp-&gt;method(), http-&gt;uri, conn-&gt;clientConnection-&gt;remote, NULL, NULL, NULL);
             assert(context-&gt;http-&gt;out.offset == 0);
             context-&gt;pullData();
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
             return;
         }
 
         /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
         /* We currently only support 0.9, 1.0, 1.1 properly */
         /* TODO: move HTTP-specific processing into servers/HttpServer and such */
-        if ( (http_ver.major == 0 &amp;&amp; http_ver.minor != 9) ||
-                (http_ver.major &gt; 1) ) {
+        if ( (hp-&gt;messageProtocol().major == 0 &amp;&amp; hp-&gt;messageProtocol().minor != 9) ||
+                (hp-&gt;messageProtocol().major &gt; 1) ) {
 
             clientStreamNode *node = context-&gt;getClientReplyContext();
-            debugs(33, 5, &quot;Unsupported HTTP version discovered. :\n&quot; &lt;&lt; HttpParserHdrBuf(hp));
+            debugs(33, 5, &quot;Unsupported HTTP version discovered. :\n&quot; &lt;&lt; hp-&gt;messageProtocol());
             conn-&gt;quitAfterError(request.getRaw());
             // setLogUri should called before repContext-&gt;setReplyToError
             setLogUri(http, http-&gt;uri,  true);
             clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
             assert (repContext);
-            repContext-&gt;setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, method, http-&gt;uri,
-                                        conn-&gt;clientConnection-&gt;remote, NULL, HttpParserHdrBuf(hp), NULL);
+            repContext-&gt;setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, hp-&gt;method(), http-&gt;uri,
+                                        conn-&gt;clientConnection-&gt;remote, NULL, NULL, NULL);
             assert(context-&gt;http-&gt;out.offset == 0);
             context-&gt;pullData();
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
             clientProcessRequestFinished(conn, request);
             return;
         }
 
         /* compile headers */
-        /* we should skip request line! */
-        /* XXX should actually know the damned buffer size here */
-        if (http_ver.major &gt;= 1 &amp;&amp; !request-&gt;parseHeader(HttpParserHdrBuf(hp), HttpParserHdrSz(hp))) {
+        if (hp-&gt;messageProtocol().major &gt;= 1 &amp;&amp; !request-&gt;parseHeader(*hp)) {
             clientStreamNode *node = context-&gt;getClientReplyContext();
-            debugs(33, 5, &quot;Failed to parse request headers:\n&quot; &lt;&lt; HttpParserHdrBuf(hp));
+            debugs(33, 5, &quot;Failed to parse request headers:\n&quot; &lt;&lt; hp-&gt;mimeHeader());
             conn-&gt;quitAfterError(request.getRaw());
             // setLogUri should called before repContext-&gt;setReplyToError
-            setLogUri(http, http-&gt;uri,  true);
+            setLogUri(http, http-&gt;uri, true);
             clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
-            assert (repContext);
-            repContext-&gt;setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, method, http-&gt;uri, conn-&gt;clientConnection-&gt;remote, NULL, NULL, NULL);
+            assert(repContext);
+            repContext-&gt;setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, hp-&gt;method(), http-&gt;uri, conn-&gt;clientConnection-&gt;remote, NULL, NULL, NULL);
             assert(context-&gt;http-&gt;out.offset == 0);
             context-&gt;pullData();
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
             clientProcessRequestFinished(conn, request);
             return;
         }
     }
 
     // Some blobs below are still HTTP-specific, but we would have to rewrite
     // this entire function to remove them from the FTP code path. Connection
     // setup and body_pipe preparation blobs are needed for FTP.
 
     request-&gt;clientConnectionManager = conn;
 
     request-&gt;flags.accelerated = http-&gt;flags.accel;
     request-&gt;flags.sslBumped=conn-&gt;switchedToHttps();
     request-&gt;flags.ignoreCc = conn-&gt;port-&gt;ignore_cc;
     // TODO: decouple http-&gt;flags.accel from request-&gt;flags.sslBumped
     request-&gt;flags.noDirect = (request-&gt;flags.accelerated &amp;&amp; !request-&gt;flags.sslBumped) ?
                               !conn-&gt;port-&gt;allow_direct : 0;
 #if USE_AUTH
     if (request-&gt;flags.sslBumped) {
         if (conn-&gt;getAuth() != NULL)
@@ -2680,191 +2621,172 @@
             request-&gt;port = getMyPort();
             http-&gt;flags.internal = true;
         } else
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;GetHost() &lt;&lt;
                    ':' &lt;&lt; request-&gt;port &lt;&lt; &quot; (not this proxy)&quot;);
     }
 
     if (http-&gt;flags.internal)
         request-&gt;login[0] = '\0';
 
     request-&gt;flags.internal = http-&gt;flags.internal;
     setLogUri (http, urlCanonicalClean(request.getRaw()));
     request-&gt;client_addr = conn-&gt;clientConnection-&gt;remote; // XXX: remove reuest-&gt;client_addr member.
 #if FOLLOW_X_FORWARDED_FOR
     // indirect client gets stored here because it is an HTTP header result (from X-Forwarded-For:)
     // not a details about teh TCP connection itself
     request-&gt;indirect_client_addr = conn-&gt;clientConnection-&gt;remote;
 #endif /* FOLLOW_X_FORWARDED_FOR */
     request-&gt;my_addr = conn-&gt;clientConnection-&gt;local;
     request-&gt;myportname = conn-&gt;port-&gt;name;
-    request-&gt;http_ver = http_ver;
+
+    if (!isFtp) {
+        // XXX: for non-HTTP messages instantiate a different HttpMsg child type
+        // for now Squid only supports HTTP requests
+        const AnyP::ProtocolVersion &amp;http_ver = hp-&gt;messageProtocol();
+        assert(request-&gt;http_ver.protocol == http_ver.protocol);
+        request-&gt;http_ver.major = http_ver.major;
+        request-&gt;http_ver.minor = http_ver.minor;
+    }
 
     // Link this HttpRequest to ConnStateData relatively early so the following complex handling can use it
     // TODO: this effectively obsoletes a lot of conn-&gt;FOO copying. That needs cleaning up later.
     request-&gt;clientConnectionManager = conn;
 
     if (request-&gt;header.chunked()) {
         chunked = true;
     } else if (request-&gt;header.has(HDR_TRANSFER_ENCODING)) {
         const String te = request-&gt;header.getList(HDR_TRANSFER_ENCODING);
         // HTTP/1.1 requires chunking to be the last encoding if there is one
         unsupportedTe = te.size() &amp;&amp; te != &quot;identity&quot;;
     } // else implied identity coding
 
-    mustReplyToOptions = (method == Http::METHOD_OPTIONS) &amp;&amp;
+    mustReplyToOptions = (request-&gt;method == Http::METHOD_OPTIONS) &amp;&amp;
                          (request-&gt;header.getInt64(HDR_MAX_FORWARDS) == 0);
     if (!urlCheckRequest(request.getRaw()) || mustReplyToOptions || unsupportedTe) {
         clientStreamNode *node = context-&gt;getClientReplyContext();
         conn-&gt;quitAfterError(request.getRaw());
         clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
         assert (repContext);
         repContext-&gt;setReplyToError(ERR_UNSUP_REQ, Http::scNotImplemented, request-&gt;method, NULL,
                                     conn-&gt;clientConnection-&gt;remote, request.getRaw(), NULL, NULL);
         assert(context-&gt;http-&gt;out.offset == 0);
         context-&gt;pullData();
-        connNoteUseOfBuffer(conn, http-&gt;req_sz);
         clientProcessRequestFinished(conn, request);
         return;
     }
 
     if (!chunked &amp;&amp; !clientIsContentLengthValid(request.getRaw())) {
         clientStreamNode *node = context-&gt;getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
         assert (repContext);
         conn-&gt;quitAfterError(request.getRaw());
         repContext-&gt;setReplyToError(ERR_INVALID_REQ,
                                     Http::scLengthRequired, request-&gt;method, NULL,
                                     conn-&gt;clientConnection-&gt;remote, request.getRaw(), NULL, NULL);
         assert(context-&gt;http-&gt;out.offset == 0);
         context-&gt;pullData();
-        connNoteUseOfBuffer(conn, http-&gt;req_sz);
         clientProcessRequestFinished(conn, request);
         return;
     }
 
     if (request-&gt;header.has(HDR_EXPECT)) {
         const String expect = request-&gt;header.getList(HDR_EXPECT);
         const bool supportedExpect = (expect.caseCmp(&quot;100-continue&quot;) == 0);
         if (!supportedExpect) {
             clientStreamNode *node = context-&gt;getClientReplyContext();
             clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
             assert (repContext);
             conn-&gt;quitAfterError(request.getRaw());
             repContext-&gt;setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request-&gt;method, http-&gt;uri,
                                         conn-&gt;clientConnection-&gt;remote, request.getRaw(), NULL, NULL);
             assert(context-&gt;http-&gt;out.offset == 0);
             context-&gt;pullData();
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
             clientProcessRequestFinished(conn, request);
             return;
         }
     }
 
     if (!isFtp) {
         http-&gt;request = request.getRaw();
         HTTPMSGLOCK(http-&gt;request);
     }
 
     clientSetKeepaliveFlag(http);
     // Let tunneling code be fully responsible for CONNECT requests
     if (http-&gt;request-&gt;method == Http::METHOD_CONNECT) {
         context-&gt;mayUseConnection(true);
         conn-&gt;flags.readMore = false;
-
-        // consume header early so that tunnel gets just the body
-        connNoteUseOfBuffer(conn, http-&gt;req_sz);
-        notedUseOfBuffer = true;
     }
 
 #if USE_OPENSSL
     if (conn-&gt;switchedToHttps() &amp;&amp; conn-&gt;serveDelayedError(context)) {
-        if (!notedUseOfBuffer)
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
         clientProcessRequestFinished(conn, request);
         return;
     }
 #endif
 
     /* Do we expect a request-body? */
     expectBody = chunked || request-&gt;content_length &gt; 0;
     if (!context-&gt;mayUseConnection() &amp;&amp; expectBody) {
         request-&gt;body_pipe = conn-&gt;expectRequestBody(
                                  chunked ? -1 : request-&gt;content_length);
 
-        if (!isFtp) {
-            // consume header early so that body pipe gets just the body
-            connNoteUseOfBuffer(conn, http-&gt;req_sz);
-            notedUseOfBuffer = true;
-        }
-
         /* Is it too large? */
         if (!chunked &amp;&amp; // if chunked, we will check as we accumulate
                 clientIsRequestBodyTooLargeForPolicy(request-&gt;content_length)) {
             clientStreamNode *node = context-&gt;getClientReplyContext();
             clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
             assert (repContext);
             conn-&gt;quitAfterError(request.getRaw());
             repContext-&gt;setReplyToError(ERR_TOO_BIG,
                                         Http::scPayloadTooLarge, Http::METHOD_NONE, NULL,
                                         conn-&gt;clientConnection-&gt;remote, http-&gt;request, NULL, NULL);
             assert(context-&gt;http-&gt;out.offset == 0);
             context-&gt;pullData();
             clientProcessRequestFinished(conn, request);
             return;
         }
 
         if (!isFtp) {
             // We may stop producing, comm_close, and/or call setReplyToError()
             // below, so quit on errors to avoid http-&gt;doCallouts()
             if (!conn-&gt;handleRequestBodyData()) {
                 clientProcessRequestFinished(conn, request);
                 return;
             }
 
             if (!request-&gt;body_pipe-&gt;productionEnded()) {
                 debugs(33, 5, &quot;need more request body&quot;);
                 context-&gt;mayUseConnection(true);
                 assert(conn-&gt;flags.readMore);
             }
         }
     }
 
     http-&gt;calloutContext = new ClientRequestContext(http);
 
     http-&gt;doCallouts();
 
-    if (!notedUseOfBuffer)
-        connNoteUseOfBuffer(conn, http-&gt;req_sz);
-
     clientProcessRequestFinished(conn, request);
 }
 
-static void
-connStripBufferWhitespace (ConnStateData * conn)
-{
-    // XXX: kill this whole function.
-    while (!conn-&gt;in.buf.isEmpty() &amp;&amp; xisspace(conn-&gt;in.buf.at(0))) {
-        conn-&gt;in.buf.consume(1);
-    }
-}
-
 int
 ConnStateData::pipelinePrefetchMax() const
 {
     return Config.pipeline_max_prefetch;
 }
 
 /**
  * Limit the number of concurrent requests.
  * \return true  when there are available position(s) in the pipeline queue for another request.
  * \return false when the pipeline queue is full or disabled.
  */
 bool
 ConnStateData::concurrentRequestQueueFilled() const
 {
     const int existingRequestCount = getConcurrentRequestCount();
 
     // default to the configured pipeline size.
     // add 1 because the head of pipeline is counted in concurrent requests and not prefetch queue
     const int concurrentRequestLimit = pipelinePrefetchMax() + 1;
 
@@ -3141,64 +3063,63 @@
         fqdncache_gethostbyaddr(clientConnection-&gt;remote, FQDN_LOOKUP_IF_MISS);
 
     return true;
 }
 
 /**
  * Attempt to parse one or more requests from the input buffer.
  * Returns true after completing parsing of at least one request [header]. That
  * includes cases where parsing ended with an error (e.g., a huge request).
  */
 bool
 ConnStateData::clientParseRequests()
 {
     bool parsed_req = false;
 
     debugs(33, 5, HERE &lt;&lt; clientConnection &lt;&lt; &quot;: attempting to parse&quot;);
 
     // Loop while we have read bytes that are not needed for producing the body
     // On errors, bodyPipe may become nil, but readMore will be cleared
     while (!in.buf.isEmpty() &amp;&amp; !bodyPipe &amp;&amp; flags.readMore) {
-        connStripBufferWhitespace(this);
 
         /* Don't try to parse if the buffer is empty */
         if (in.buf.isEmpty())
             break;
 
         /* Limit the number of concurrent requests */
         if (concurrentRequestQueueFilled())
             break;
 
         // try to parse the PROXY protocol header magic bytes
         if (needProxyProtocolHeader_ &amp;&amp; !parseProxyProtocolHeader())
             break;
 
-        Http::ProtocolVersion http_ver;
-        if (ClientSocketContext *context = parseOneRequest(http_ver)) {
+        if (ClientSocketContext *context = parseOneRequest()) {
             debugs(33, 5, clientConnection &lt;&lt; &quot;: done parsing a request&quot;);
+
             AsyncCall::Pointer timeoutCall = commCbCall(5, 4, &quot;clientLifetimeTimeout&quot;,
                                              CommTimeoutCbPtrFun(clientLifetimeTimeout, context-&gt;http));
             commSetConnTimeout(clientConnection, Config.Timeout.lifetime, timeoutCall);
 
             context-&gt;registerWithConn();
 
-            processParsedRequest(context, http_ver);
+            processParsedRequest(context);
 
             parsed_req = true; // XXX: do we really need to parse everything right NOW ?
 
             if (context-&gt;mayUseConnection()) {
                 debugs(33, 3, HERE &lt;&lt; &quot;Not parsing new requests, as this request may need the connection&quot;);
                 break;
             }
         } else {
             debugs(33, 5, clientConnection &lt;&lt; &quot;: not enough request data: &quot; &lt;&lt;
                    in.buf.length() &lt;&lt; &quot; &lt; &quot; &lt;&lt; Config.maxRequestHeaderSize);
             Must(in.buf.length() &lt; Config.maxRequestHeaderSize);
             break;
         }
     }
 
     /* XXX where to 'finish' the parsing pass? */
     return parsed_req;
 }
 
 void
@@ -3326,41 +3247,41 @@
 {
     assert(bodyPipe != NULL);
 
     size_t putSize = 0;
 
     if (in.bodyParser) { // chunked encoding
         if (const err_type error = handleChunkedRequestBody(putSize)) {
             abortChunkedRequestBody(error);
             return false;
         }
     } else { // identity encoding
         debugs(33,5, HERE &lt;&lt; &quot;handling plain request body for &quot; &lt;&lt; clientConnection);
         putSize = bodyPipe-&gt;putMoreData(in.buf.c_str(), in.buf.length());
         if (!bodyPipe-&gt;mayNeedMoreData()) {
             // BodyPipe will clear us automagically when we produced everything
             bodyPipe = NULL;
         }
     }
 
     if (putSize &gt; 0)
-        connNoteUseOfBuffer(this, putSize);
+        consumeInput(putSize);
 
     if (!bodyPipe) {
         debugs(33,5, HERE &lt;&lt; &quot;produced entire request body for &quot; &lt;&lt; clientConnection);
 
         if (const char *reason = stoppedSending()) {
             /* we've finished reading like good clients,
              * now do the close that initiateClose initiated.
              */
             debugs(33, 3, HERE &lt;&lt; &quot;closing for earlier sending error: &quot; &lt;&lt; reason);
             clientConnection-&gt;close();
             return false;
         }
     }
 
     return true;
 }
 
 /// parses available chunked encoded body bytes, checks size, returns errors
 err_type
 ConnStateData::handleChunkedRequestBody(size_t &amp;putSize)

=== modified file 'src/client_side.h'
--- src/client_side.h	2014-09-24 14:07:55 +0000
+++ src/client_side.h	2014-09-27 09:53:31 +0000
@@ -1,38 +1,38 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 33    Client-side Routines */
 
 #ifndef SQUID_CLIENTSIDE_H
 #define SQUID_CLIENTSIDE_H
 
 #include &quot;clientStreamForward.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;helper/forward.h&quot;
 #include &quot;HttpControlMsg.h&quot;
-#include &quot;HttpParser.h&quot;
+#include &quot;http/forward.h&quot;
 #include &quot;ipc/FdNotes.h&quot;
 #include &quot;SBuf.h&quot;
 #if USE_AUTH
 #include &quot;auth/UserRequest.h&quot;
 #endif
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
 class ChunkedCodingParser;
 namespace AnyP
 {
 class PortCfg;
 } // namespace Anyp
 
 /**
  * Badly named.
@@ -392,75 +392,78 @@
     /// remove no longer needed leading bytes from the input buffer
     void consumeInput(const size_t byteCount);
 
     /* TODO: Make the methods below (at least) non-public when possible. */
 
     /// stop parsing the request and create context for relaying error info
     ClientSocketContext *abortRequestParsing(const char *const errUri);
 
 protected:
     void startDechunkingRequest();
     void finishDechunkingRequest(bool withSuccess);
     void abortChunkedRequestBody(const err_type error);
     err_type handleChunkedRequestBody(size_t &amp;putSize);
 
     void startPinnedConnectionMonitoring();
     void clientPinnedConnectionRead(const CommIoCbParams &amp;io);
 
     /// parse input buffer prefix into a single transfer protocol request
     /// return NULL to request more header bytes (after checking any limits)
     /// use abortRequestParsing() to handle parsing errors w/o creating request
-    virtual ClientSocketContext *parseOneRequest(Http::ProtocolVersion &amp;ver) = 0;
+    virtual ClientSocketContext *parseOneRequest() = 0;
 
     /// start processing a freshly parsed request
-    virtual void processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &amp;ver) = 0;
+    virtual void processParsedRequest(ClientSocketContext *context) = 0;
 
     /// returning N allows a pipeline of 1+N requests (see pipeline_prefetch)
     virtual int pipelinePrefetchMax() const;
 
     /// timeout to use when waiting for the next request
     virtual time_t idleTimeout() const = 0;
 
     BodyPipe::Pointer bodyPipe; ///&lt; set when we are reading request body
 
 private:
     int connFinishedWithConn(int size);
     void clientAfterReadingRequests();
     bool concurrentRequestQueueFilled() const;
 
     void pinNewConnection(const Comm::ConnectionPointer &amp;pinServer, HttpRequest *request, CachePeer *aPeer, bool auth);
 
     /* PROXY protocol functionality */
     bool proxyProtocolValidateClient();
     bool parseProxyProtocolHeader();
     bool parseProxy1p0();
     bool parseProxy2p0();
     bool proxyProtocolError(const char *reason);
 
     /// whether PROXY protocol header is still expected
     bool needProxyProtocolHeader_;
 
 #if USE_AUTH
     /// some user details that can be used to perform authentication on this connection
     Auth::UserRequest::Pointer auth_;
 #endif
 
+    /// the parser state for current HTTP/1.x input buffer processing
+    Http1::RequestParserPointer parser_;
+
 #if USE_OPENSSL
     bool switchedToHttps_;
     /// The SSL server host name appears in CONNECT request or the server ip address for the intercepted requests
     String sslConnectHostOrIp; ///&lt; The SSL server host name as passed in the CONNECT request
     String sslCommonName; ///&lt; CN name for SSL certificate generation
     String sslBumpCertKey; ///&lt; Key to use to store/retrieve generated certificate
 
     /// HTTPS server cert. fetching state for bump-ssl-server-first
     Ssl::ServerBump *sslServerBump;
     Ssl::CertSignAlgorithm signAlgorithm; ///&lt; The signing algorithm to use
 #endif
 
     /// the reason why we no longer write the response or nil
     const char *stoppedSending_;
     /// the reason why we no longer read the request or nil
     const char *stoppedReceiving_;
 
     AsyncCall::Pointer reader; ///&lt; set when we are reading
 
     SBuf connectionTag_; ///&lt; clt_conn_tag=Tag annotation for client connection
@@ -473,25 +476,25 @@
 int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
 
 /// accept requests to a given port and inform subCall about them
 void clientStartListeningOn(AnyP::PortCfgPointer &amp;port, const RefCount&lt; CommCbFunPtrCallT&lt;CommAcceptCbPtrFun&gt; &gt; &amp;subCall, const Ipc::FdNoteId noteId);
 
 void clientOpenListenSockets(void);
 void clientConnectionsClose(void);
 void httpRequestFree(void *);
 
 /// decide whether to expect multiple requests on the corresponding connection
 void clientSetKeepaliveFlag(ClientHttpRequest *http);
 
 /* misplaced declaratrions of Stream callbacks provided/used by client side */
 SQUIDCEXTERN CSR clientGetMoreData;
 SQUIDCEXTERN CSS clientReplyStatus;
 SQUIDCEXTERN CSD clientReplyDetach;
 CSCB clientSocketRecipient;
 CSD clientSocketDetach;
 
 /* TODO: Move to HttpServer. Warning: Move requires large code nonchanges! */
-ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, Http::ProtocolVersion *);
-void clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod&amp; method, Http::ProtocolVersion http_ver);
-void clientPostHttpsAccept(ConnStateData *connState);
+ClientSocketContext *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &amp;);
+void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &amp;, ClientSocketContext *);
+void clientPostHttpsAccept(ConnStateData *);
 
 #endif /* SQUID_CLIENTSIDE_H */

=== modified file 'src/htcp.cc'
--- src/htcp.cc	2014-09-29 05:13:17 +0000
+++ src/htcp.cc	2014-10-15 06:31:27 +0000
@@ -132,55 +132,61 @@
     Countstr key_name;
     Countstr signature;
 };
 
 class htcpSpecifier : public StoreClient
 {
 
 public:
     MEMPROXY_CLASS(htcpSpecifier);
 
     void created (StoreEntry *newEntry);
     void checkHit();
     void checkedHit(StoreEntry *e);
 
     void setFrom(Ip::Address &amp;from);
     void setDataHeader(htcpDataHeader *);
     const char *method;
     char *uri;
     char *version;
     char *req_hdrs;
+    size_t reqHdrsSz; ///&lt; size of the req_hdrs content
     HttpRequest *request;
 
 private:
     HttpRequest *checkHitRequest;
 
     Ip::Address from; // was a ptr. return to such IFF needed. otherwise copy should do.
     htcpDataHeader *dhdr;
 };
 
 MEMPROXY_CLASS_INLINE(htcpSpecifier);
 
 struct _htcpDetail {
     char *resp_hdrs;
+    size_t respHdrsSz;
+
     char *entity_hdrs;
+    size_t entityHdrsSz;
+
     char *cache_hdrs;
+    size_t cacheHdrsSz;
 };
 
 struct _htcpStuff {
     int op;
     int rr;
     int f1;
     int response;
     int reason;
     uint32_t msg_id;
     htcpSpecifier S;
     htcpDetail D;
 };
 
 enum {
     HTCP_NOP,
     HTCP_TST,
     HTCP_MON,
     HTCP_SET,
     HTCP_CLR,
     HTCP_END
@@ -216,41 +222,41 @@
 };
 
 static void htcpIncomingConnectionOpened(const Comm::ConnectionPointer &amp;conn, int errNo);
 static uint32_t msg_id_counter = 0;
 
 static Comm::ConnectionPointer htcpOutgoingConn = NULL;
 static Comm::ConnectionPointer htcpIncomingConn = NULL;
 #define N_QUERIED_KEYS 8192
 static uint32_t queried_id[N_QUERIED_KEYS];
 static cache_key queried_keys[N_QUERIED_KEYS][SQUID_MD5_DIGEST_LENGTH];
 
 static Ip::Address queried_addr[N_QUERIED_KEYS];
 static MemAllocator *htcpDetailPool = NULL;
 
 static int old_squid_format = 0;
 
 static ssize_t htcpBuildPacket(char *buf, size_t buflen, htcpStuff * stuff);
 static htcpSpecifier *htcpUnpackSpecifier(char *buf, int sz);
 static htcpDetail *htcpUnpackDetail(char *buf, int sz);
 static ssize_t htcpBuildAuth(char *buf, size_t buflen);
-static ssize_t htcpBuildCountstr(char *buf, size_t buflen, const char *s);
+static ssize_t htcpBuildCountstr(char *buf, size_t buflen, const char *s, size_t len);
 static ssize_t htcpBuildData(char *buf, size_t buflen, htcpStuff * stuff);
 static ssize_t htcpBuildDetail(char *buf, size_t buflen, htcpStuff * stuff);
 static ssize_t htcpBuildOpData(char *buf, size_t buflen, htcpStuff * stuff);
 static ssize_t htcpBuildSpecifier(char *buf, size_t buflen, htcpStuff * stuff);
 static ssize_t htcpBuildTstOpData(char *buf, size_t buflen, htcpStuff * stuff);
 static void htcpFreeSpecifier(htcpSpecifier * s);
 static void htcpFreeDetail(htcpDetail * s);
 
 static void htcpHandleMsg(char *buf, int sz, Ip::Address &amp;from);
 
 static void htcpLogHtcp(Ip::Address &amp;, int, LogTags, const char *);
 static void htcpHandleMon(htcpDataHeader *, char *buf, int sz, Ip::Address &amp;from);
 
 static void htcpHandleNop(htcpDataHeader *, char *buf, int sz, Ip::Address &amp;from);
 
 static void htcpHandleSet(htcpDataHeader *, char *buf, int sz, Ip::Address &amp;from);
 
 static void htcpHandleTst(htcpDataHeader *, char *buf, int sz, Ip::Address &amp;from);
 
 static void htcpRecv(int fd, void *data);
@@ -290,133 +296,126 @@
 
 /*
  * STUFF FOR SENDING HTCP MESSAGES
  */
 
 static ssize_t
 htcpBuildAuth(char *buf, size_t buflen)
 {
     htcpAuthHeader auth;
     size_t copy_sz = 0;
     assert(2 == sizeof(uint16_t));
     auth.length = htons(2);
     copy_sz += 2;
     if (buflen &lt; copy_sz)
         return -1;
     memcpy(buf, &amp;auth, copy_sz);
     return copy_sz;
 }
 
 static ssize_t
-htcpBuildCountstr(char *buf, size_t buflen, const char *s)
+htcpBuildCountstr(char *buf, size_t buflen, const char *s, size_t len)
 {
-    uint16_t length;
-    size_t len;
     int off = 0;
 
     if (buflen - off &lt; 2)
         return -1;
 
-    if (s)
-        len = strlen(s);
-    else
-        len = 0;
-
     debugs(31, 3, &quot;htcpBuildCountstr: LENGTH = &quot; &lt;&lt; len);
 
     debugs(31, 3, &quot;htcpBuildCountstr: TEXT = {&quot; &lt;&lt; (s ? s : &quot;&lt;NULL&gt;&quot;) &lt;&lt; &quot;}&quot;);
 
-    length = htons((uint16_t) len);
+    uint16_t length = htons((uint16_t) len);
 
     memcpy(buf + off, &amp;length, 2);
 
     off += 2;
 
     if (buflen - off &lt; len)
         return -1;
 
     if (len)
         memcpy(buf + off, s, len);
 
     off += len;
 
     return off;
 }
 
 static ssize_t
 htcpBuildSpecifier(char *buf, size_t buflen, htcpStuff * stuff)
 {
     ssize_t off = 0;
     ssize_t s;
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.method);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.method, (stuff-&gt;S.method?strlen(stuff-&gt;S.method):0));
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.uri);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.uri, (stuff-&gt;S.uri?strlen(stuff-&gt;S.uri):0));
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.version);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.version, (stuff-&gt;S.version?strlen(stuff-&gt;S.version):0));
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.req_hdrs);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;S.req_hdrs, stuff-&gt;S.reqHdrsSz);
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
     debugs(31, 3, &quot;htcpBuildSpecifier: size &quot; &lt;&lt; off);
 
     return off;
 }
 
 static ssize_t
 htcpBuildDetail(char *buf, size_t buflen, htcpStuff * stuff)
 {
     ssize_t off = 0;
     ssize_t s;
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;D.resp_hdrs);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;D.resp_hdrs, stuff-&gt;D.respHdrsSz);
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;D.entity_hdrs);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;D.entity_hdrs, stuff-&gt;D.entityHdrsSz);
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
-    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;D.cache_hdrs);
+    s = htcpBuildCountstr(buf + off, buflen - off, stuff-&gt;D.cache_hdrs, stuff-&gt;D.cacheHdrsSz);
 
     if (s &lt; 0)
         return s;
 
     off += s;
 
     return off;
 }
 
 static ssize_t
 htcpBuildTstOpData(char *buf, size_t buflen, htcpStuff * stuff)
 {
     switch (stuff-&gt;rr) {
 
     case RR_REQUEST:
         debugs(31, 3, &quot;htcpBuildTstOpData: RR_REQUEST&quot;);
         return htcpBuildSpecifier(buf, buflen, stuff);
 
     case RR_RESPONSE:
         debugs(31, 3, &quot;htcpBuildTstOpData: RR_RESPONSE&quot;);
@@ -611,40 +610,42 @@
 }
 
 static void
 htcpFreeSpecifier(htcpSpecifier * s)
 {
     HTTPMSGUNLOCK(s-&gt;request);
 
     delete s;
 }
 
 static void
 htcpFreeDetail(htcpDetail * d)
 {
     htcpDetailPool-&gt;freeOne(d);
 }
 
 /*
  * Unpack an HTCP SPECIFIER in place
  * This will overwrite any following AUTH block
  */
+// XXX: this needs to be turned into an Htcp1::Parser inheriting from Http1::RequestParser
+//   but with different first-line and block unpacking logic.
 static htcpSpecifier *
 htcpUnpackSpecifier(char *buf, int sz)
 {
     htcpSpecifier *s = new htcpSpecifier;
     HttpRequestMethod method;
 
     /* Find length of METHOD */
     uint16_t l = ntohs(*(uint16_t *) buf);
     sz -= 2;
     buf += 2;
 
     if (l &gt; sz) {
         debugs(31, 3, &quot;htcpUnpackSpecifier: failed to unpack METHOD&quot;);
         htcpFreeSpecifier(s);
         return NULL;
     }
 
     /* Set METHOD */
     s-&gt;method = buf;
     buf += l;
@@ -692,135 +693,131 @@
     debugs(31, 6, &quot;htcpUnpackSpecifier: VERSION (&quot; &lt;&lt; l &lt;&lt; &quot;/&quot; &lt;&lt; sz &lt;&lt; &quot;) '&quot; &lt;&lt; s-&gt;version &lt;&lt; &quot;'&quot;);
 
     /* Find length of REQ-HDRS */
     l = ntohs(*(uint16_t *) buf);
     sz -= 2;
 
     if (l &gt; sz) {
         debugs(31, 3, &quot;htcpUnpackSpecifier: failed to unpack REQ-HDRS&quot;);
         htcpFreeSpecifier(s);
         return NULL;
     }
 
     /* Add terminating null to URI */
     *buf = '\0';
     buf += 2;
 
     /* Set REQ-HDRS */
     s-&gt;req_hdrs = buf;
     buf += l;
     sz -= l;
+    s-&gt;reqHdrsSz = l;
     debugs(31, 6, &quot;htcpUnpackSpecifier: REQ-HDRS (&quot; &lt;&lt; l &lt;&lt; &quot;/&quot; &lt;&lt; sz &lt;&lt; &quot;) '&quot; &lt;&lt; s-&gt;req_hdrs &lt;&lt; &quot;'&quot;);
 
     debugs(31, 3, &quot;htcpUnpackSpecifier: &quot; &lt;&lt; sz &lt;&lt; &quot; bytes left&quot;);
 
     /*
      * Add terminating null to REQ-HDRS. This is possible because we allocated
      * an extra byte when we received the packet. This will overwrite any following
      * AUTH block.
      */
     *buf = '\0';
 
-    /*
-     * Parse the request
-     */
-    method = HttpRequestMethod(s-&gt;method, NULL);
+    // Parse the request
+    method.HttpRequestMethodXXX(s-&gt;method);
 
     s-&gt;request = HttpRequest::CreateFromUrlAndMethod(s-&gt;uri, method == Http::METHOD_NONE ? HttpRequestMethod(Http::METHOD_GET) : method);
 
     if (s-&gt;request)
         HTTPMSGLOCK(s-&gt;request);
 
     return s;
 }
 
 /*
  * Unpack an HTCP DETAIL in place
  * This will overwrite any following AUTH block
  */
 static htcpDetail *
 htcpUnpackDetail(char *buf, int sz)
 {
     htcpDetail *d = static_cast&lt;htcpDetail *&gt;(htcpDetailPool-&gt;alloc());
 
     /* Find length of RESP-HDRS */
     uint16_t l = ntohs(*(uint16_t *) buf);
     sz -= 2;
     buf += 2;
 
     if (l &gt; sz) {
         debugs(31, 3, &quot;htcpUnpackDetail: failed to unpack RESP_HDRS&quot;);
         htcpFreeDetail(d);
         return NULL;
     }
 
     /* Set RESP-HDRS */
     d-&gt;resp_hdrs = buf;
-
     buf += l;
-
+    d-&gt;respHdrsSz = l;
     sz -= l;
 
     /* Find length of ENTITY-HDRS */
     l = ntohs(*(uint16_t *) buf);
 
     sz -= 2;
 
     if (l &gt; sz) {
         debugs(31, 3, &quot;htcpUnpackDetail: failed to unpack ENTITY_HDRS&quot;);
         htcpFreeDetail(d);
         return NULL;
     }
 
     /* Add terminating null to RESP-HDRS */
     *buf = '\0';
 
     /* Set ENTITY-HDRS */
     buf += 2;
 
     d-&gt;entity_hdrs = buf;
-
     buf += l;
-
+    d-&gt;entityHdrsSz = l;
     sz -= l;
 
     /* Find length of CACHE-HDRS */
     l = ntohs(*(uint16_t *) buf);
 
     sz -= 2;
 
     if (l &gt; sz) {
         debugs(31, 3, &quot;htcpUnpackDetail: failed to unpack CACHE_HDRS&quot;);
         htcpFreeDetail(d);
         return NULL;
     }
 
     /* Add terminating null to ENTITY-HDRS */
     *buf = '\0';
 
     /* Set CACHE-HDRS */
     buf += 2;
 
     d-&gt;cache_hdrs = buf;
-
     buf += l;
-
+    d-&gt;cacheHdrsSz = l;
     sz -= l;
 
     debugs(31, 3, &quot;htcpUnpackDetail: &quot; &lt;&lt; sz &lt;&lt; &quot; bytes left&quot;);
 
     /*
      * Add terminating null to CACHE-HDRS. This is possible because we allocated
      * an extra byte when we received the packet. This will overwrite any following
      * AUTH block.
      */
     *buf = '\0';
 
     return d;
 }
 
 static bool
 htcpAccessAllowed(acl_access * acl, htcpSpecifier * s, Ip::Address &amp;from)
 {
     /* default deny if no access list present */
     if (!acl)
         return false;
@@ -838,95 +835,102 @@
     static char pkt[8192];
     HttpHeader hdr(hoHtcpReply);
     MemBuf mb;
     Packer p;
     ssize_t pktlen;
     memset(&amp;stuff, '\0', sizeof(stuff));
     stuff.op = HTCP_TST;
     stuff.rr = RR_RESPONSE;
     stuff.f1 = 0;
     stuff.response = e ? 0 : 1;
     debugs(31, 3, &quot;htcpTstReply: response = &quot; &lt;&lt; stuff.response);
     stuff.msg_id = dhdr-&gt;msg_id;
 
     if (spec) {
         mb.init();
         packerToMemInit(&amp;p, &amp;mb);
         stuff.S.method = spec-&gt;method;
         stuff.S.uri = spec-&gt;uri;
         stuff.S.version = spec-&gt;version;
         stuff.S.req_hdrs = spec-&gt;req_hdrs;
+        stuff.S.reqHdrsSz = spec-&gt;reqHdrsSz;
         if (e)
             hdr.putInt(HDR_AGE, (e-&gt;timestamp &lt;= squid_curtime ? (squid_curtime - e-&gt;timestamp) : 0) );
         else
             hdr.putInt(HDR_AGE, 0);
         hdr.packInto(&amp;p);
         stuff.D.resp_hdrs = xstrdup(mb.buf);
+        stuff.D.respHdrsSz = mb.contentSize();
         debugs(31, 3, &quot;htcpTstReply: resp_hdrs = {&quot; &lt;&lt; stuff.D.resp_hdrs &lt;&lt; &quot;}&quot;);
         mb.reset();
         hdr.reset();
 
         if (e &amp;&amp; e-&gt;expires &gt; -1)
             hdr.putTime(HDR_EXPIRES, e-&gt;expires);
 
         if (e &amp;&amp; e-&gt;lastmod &gt; -1)
             hdr.putTime(HDR_LAST_MODIFIED, e-&gt;lastmod);
 
         hdr.packInto(&amp;p);
 
         stuff.D.entity_hdrs = xstrdup(mb.buf);
+        stuff.D.entityHdrsSz = mb.contentSize();
 
         debugs(31, 3, &quot;htcpTstReply: entity_hdrs = {&quot; &lt;&lt; stuff.D.entity_hdrs &lt;&lt; &quot;}&quot;);
 
         mb.reset();
 
         hdr.reset();
 
 #if USE_ICMP
         if (char *host = urlHostname(spec-&gt;uri)) {
             int rtt = 0;
             int hops = 0;
             int samp = 0;
             netdbHostData(host, &amp;samp, &amp;rtt, &amp;hops);
 
             if (rtt || hops) {
                 char cto_buf[128];
                 snprintf(cto_buf, 128, &quot;%s %d %f %d&quot;,
                          host, samp, 0.001 * rtt, hops);
                 hdr.putExt(&quot;Cache-to-Origin&quot;, cto_buf);
             }
         }
 #endif /* USE_ICMP */
 
         hdr.packInto(&amp;p);
         stuff.D.cache_hdrs = xstrdup(mb.buf);
+        stuff.D.cacheHdrsSz = mb.contentSize();
         debugs(31, 3, &quot;htcpTstReply: cache_hdrs = {&quot; &lt;&lt; stuff.D.cache_hdrs &lt;&lt; &quot;}&quot;);
         mb.clean();
         hdr.clean();
         packerClean(&amp;p);
     }
 
     pktlen = htcpBuildPacket(pkt, sizeof(pkt), &amp;stuff);
 
     safe_free(stuff.D.resp_hdrs);
+    stuff.D.respHdrsSz = 0;
     safe_free(stuff.D.entity_hdrs);
+    stuff.D.entityHdrsSz = 0;
     safe_free(stuff.D.cache_hdrs);
+    stuff.D.cacheHdrsSz = 0;
 
     if (!pktlen) {
         debugs(31, 3, &quot;htcpTstReply: htcpBuildPacket() failed&quot;);
         return;
     }
 
     htcpSend(pkt, (int) pktlen, from);
 }
 
 static void
 
 htcpClrReply(htcpDataHeader * dhdr, int purgeSucceeded, Ip::Address &amp;from)
 {
     htcpStuff stuff;
     static char pkt[8192];
     ssize_t pktlen;
 
     /* If dhdr-&gt;F1 == 0, no response desired */
 
     if (dhdr-&gt;F1 == 0)
@@ -949,52 +953,49 @@
     pktlen = htcpBuildPacket(pkt, sizeof(pkt), &amp;stuff);
 
     if (pktlen == 0) {
         debugs(31, 3, &quot;htcpClrReply: htcpBuildPacket() failed&quot;);
         return;
     }
 
     htcpSend(pkt, (int) pktlen, from);
 }
 
 static void
 
 htcpHandleNop(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &amp;from)
 {
     debugs(31, 3, &quot;htcpHandleNop: Unimplemented&quot;);
 }
 
 void
 htcpSpecifier::checkHit()
 {
-    char *blk_end;
     checkHitRequest = request;
 
     if (NULL == checkHitRequest) {
         debugs(31, 3, &quot;htcpCheckHit: NO; failed to parse URL&quot;);
         checkedHit(NullStoreEntry::getInstance());
         return;
     }
 
-    blk_end = req_hdrs + strlen(req_hdrs);
-
-    if (!checkHitRequest-&gt;header.parse(req_hdrs, blk_end)) {
+    if (!checkHitRequest-&gt;header.parse(req_hdrs, reqHdrsSz)) {
         debugs(31, 3, &quot;htcpCheckHit: NO; failed to parse request headers&quot;);
         delete checkHitRequest;
         checkHitRequest = NULL;
         checkedHit(NullStoreEntry::getInstance());
         return;
     }
 
     StoreEntry::getPublicByRequest(this, checkHitRequest);
 }
 
 void
 htcpSpecifier::created (StoreEntry *e)
 {
     StoreEntry *hit=NULL;
     assert (e);
 
     if (e-&gt;isNull()) {
         debugs(31, 3, &quot;htcpCheckHit: NO; public object not found&quot;);
     } else if (!e-&gt;validToSend()) {
         debugs(31, 3, &quot;htcpCheckHit: NO; entry not valid to send&quot; );
@@ -1002,53 +1003,50 @@
         debugs(31, 3, &quot;htcpCheckHit: NO; cached response is stale&quot;);
     } else {
         debugs(31, 3, &quot;htcpCheckHit: YES!?&quot;);
         hit = e;
     }
 
     checkedHit (hit);
 }
 
 static void
 htcpClrStoreEntry(StoreEntry * e)
 {
     debugs(31, 4, &quot;htcpClrStoreEntry: Clearing store for entry: &quot; &lt;&lt; e-&gt;url()  );
     e-&gt;releaseRequest();
 }
 
 static int
 htcpClrStore(const htcpSpecifier * s)
 {
     HttpRequest *request = s-&gt;request;
-    char *blk_end;
     StoreEntry *e = NULL;
     int released = 0;
 
     if (request == NULL) {
         debugs(31, 3, &quot;htcpClrStore: failed to parse URL&quot;);
         return -1;
     }
 
     /* Parse request headers */
-    blk_end = s-&gt;req_hdrs + strlen(s-&gt;req_hdrs);
-
-    if (!request-&gt;header.parse(s-&gt;req_hdrs, blk_end)) {
+    if (!request-&gt;header.parse(s-&gt;req_hdrs, s-&gt;reqHdrsSz)) {
         debugs(31, 2, &quot;htcpClrStore: failed to parse request headers&quot;);
         return -1;
     }
 
     /* Lookup matching entries. This matches both GET and HEAD */
     while ((e = storeGetPublicByRequest(request)) != NULL) {
         if (e != NULL) {
             htcpClrStoreEntry(e);
             ++released;
         }
     }
 
     if (released) {
         debugs(31, 4, &quot;htcpClrStore: Cleared &quot; &lt;&lt; released &lt;&lt; &quot; matching entries&quot;);
         return 1;
     } else {
         debugs(31, 4, &quot;htcpClrStore: No matching entry found&quot;);
         return 0;
     }
 }
@@ -1109,47 +1107,47 @@
         debugs(31, 2, &quot;htcpHandleTstResponse: error condition, F1/MO == 1&quot;);
         return;
     }
 
     htcpReply.msg_id = hdr-&gt;msg_id;
     debugs(31, 3, &quot;htcpHandleTstResponse: msg_id = &quot; &lt;&lt; htcpReply.msg_id);
     htcpReply.hit = hdr-&gt;response ? 0 : 1;
 
     if (hdr-&gt;F1) {
         debugs(31, 3, &quot;htcpHandleTstResponse: MISS&quot;);
     } else {
         debugs(31, 3, &quot;htcpHandleTstResponse: HIT&quot;);
         d = htcpUnpackDetail(buf, sz);
 
         if (d == NULL) {
             debugs(31, 3, &quot;htcpHandleTstResponse: bad DETAIL&quot;);
             return;
         }
 
         if ((t = d-&gt;resp_hdrs))
-            htcpReply.hdr.parse(t, t + strlen(t));
+            htcpReply.hdr.parse(t, d-&gt;respHdrsSz);
 
         if ((t = d-&gt;entity_hdrs))
-            htcpReply.hdr.parse(t, t + strlen(t));
+            htcpReply.hdr.parse(t, d-&gt;entityHdrsSz);
 
         if ((t = d-&gt;cache_hdrs))
-            htcpReply.hdr.parse(t, t + strlen(t));
+            htcpReply.hdr.parse(t, d-&gt;cacheHdrsSz);
     }
 
     debugs(31, 3, &quot;htcpHandleTstResponse: key (&quot; &lt;&lt; key &lt;&lt; &quot;) &quot; &lt;&lt; storeKeyText(key));
     neighborsHtcpReply(key, &amp;htcpReply, from);
     htcpReply.hdr.clean();
 
     if (d)
         htcpFreeDetail(d);
 }
 
 static void
 htcpHandleTstRequest(htcpDataHeader * dhdr, char *buf, int sz, Ip::Address &amp;from)
 {
     /* buf should be a SPECIFIER */
     htcpSpecifier *s;
 
     if (sz == 0) {
         debugs(31, 3, &quot;htcpHandleTst: nothing to do&quot;);
         return;
     }

=== modified file 'src/htcp.h'
--- src/htcp.h	2014-09-13 13:59:43 +0000
+++ src/htcp.h	2014-09-14 12:23:03 +0000
@@ -1,39 +1,37 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTCP_H
 #define SQUID_HTCP_H
 
 #if USE_HTCP
 
 #include &quot;HttpHeader.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/forward.h&quot;
 #include &quot;ip/forward.h&quot;
 
-class HttpRequest;
-
 /// \ingroup ServerProtocolHTCP
 class HtcpReplyData
 {
 
 public:
     HtcpReplyData();
     int hit;
     HttpHeader hdr;
     uint32_t msg_id;
     double version;
 
     struct cto_t {
         /* cache-to-origin */
         double rtt;
         int samp;
         int hops;
     } cto;
 };
 
 /// \ingroup ServerProtocolHTCP

=== modified file 'src/http/Makefile.am'
--- src/http/Makefile.am	2014-09-13 13:59:43 +0000
+++ src/http/Makefile.am	2014-09-14 12:23:03 +0000
@@ -1,26 +1,37 @@
 ## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
 ##
 ## Squid software is distributed under GPLv2+ license and includes
 ## contributions from numerous individuals and organizations.
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
+AUTOMAKE_OPTIONS = subdir-objects
+
+SUBDIRS = one
+DIST_SUBDIRS = one
+
 noinst_LTLIBRARIES = libsquid-http.la
 
 libsquid_http_la_SOURCES = \
+	forward.h \
 	MethodType.cc \
 	MethodType.h \
 	ProtocolVersion.h \
+	RegisteredHeaders.h \
+	RequestMethod.cc \
+	RequestMethod.h \
 	StatusCode.cc \
 	StatusCode.h \
 	StatusLine.cc \
 	StatusLine.h
 
+libsquid_http_la_LIBADD= one/libhttp1.la
+
 MethodType.cc: MethodType.h $(top_srcdir)/src/mk-string-arrays.awk
 	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk sbuf=1 &lt; $(srcdir)/MethodType.h | \
 		sed -e 's%METHOD_%%' -e 's%_C%-C%' &gt;$@) || ($(RM) -f $@ &amp;&amp; exit 1)
 
 CLEANFILES += MethodType.cc

=== added file 'src/http/RegisteredHeaders.h'
--- src/http/RegisteredHeaders.h	1970-01-01 00:00:00 +0000
+++ src/http/RegisteredHeaders.h	2014-08-19 12:14:45 +0000
@@ -0,0 +1,113 @@
+#ifndef SQUID_HTTP_REGISTEREDHEADERS_H
+#define SQUID_HTTP_REGISTEREDHEADERS_H
+
+/// recognized or &quot;known&quot; header fields; and the RFC which defines them (or not)
+/// <A HREF="http://www.iana.org/assignments/message-headers/message-headers.xhtml">http://www.iana.org/assignments/message-headers/message-headers.xhtml</A>
+typedef enum {
+    HDR_BAD_HDR = -1,
+    HDR_ACCEPT = 0,                     /**&lt; RFC 7231 */
+    HDR_ACCEPT_CHARSET,                 /**&lt; RFC 7231 */
+    HDR_ACCEPT_ENCODING,                /**&lt; RFC 7231 */
+    /*HDR_ACCEPT_FEATURES,*/            /* RFC 2295 */
+    HDR_ACCEPT_LANGUAGE,                /**&lt; RFC 7231 */
+    HDR_ACCEPT_RANGES,                  /**&lt; RFC 7233 */
+    HDR_AGE,                            /**&lt; RFC 7234 */
+    HDR_ALLOW,                          /**&lt; RFC 7231 */
+    HDR_AUTHENTICATION_INFO,            /**&lt; RFC 2617 */
+    HDR_AUTHORIZATION,                  /**&lt; RFC 7235, 4559 */
+    HDR_CACHE_CONTROL,                  /**&lt; RFC 7234 */
+    HDR_CONNECTION,                     /**&lt; RFC 7230 */
+    HDR_CONTENT_BASE,                   /**&lt; obsoleted RFC 2068 */
+    HDR_CONTENT_DISPOSITION,            /**&lt; RFC 2183, 6266 */
+    HDR_CONTENT_ENCODING,               /**&lt; RFC 7231 */
+    HDR_CONTENT_LANGUAGE,               /**&lt; RFC 7231 */
+    HDR_CONTENT_LENGTH,                 /**&lt; RFC 7230 */
+    HDR_CONTENT_LOCATION,               /**&lt; RFC 7231 */
+    HDR_CONTENT_MD5,                    /**&lt; deprecated, RFC 2616 */
+    HDR_CONTENT_RANGE,                  /**&lt; RFC 7233 */
+    HDR_CONTENT_TYPE,                   /**&lt; RFC 7231 */
+    HDR_COOKIE,                         /**&lt; RFC 6265 header we may need to erase */
+    HDR_COOKIE2,                        /**&lt; obsolete RFC 2965 header we may need to erase */
+    HDR_DATE,                           /**&lt; RFC 7231 */
+    /*HDR_DAV,*/                        /* RFC 2518 */
+    /*HDR_DEPTH,*/                      /* RFC 2518 */
+    /*HDR_DERIVED_FROM,*/               /* deprecated RFC 2068 */
+    /*HDR_DESTINATION,*/                /* RFC 2518 */
+    HDR_ETAG,                           /**&lt; RFC 7232 */
+    HDR_EXPECT,                         /**&lt; RFC 7231 */
+    HDR_EXPIRES,                        /**&lt; RFC 7234 */
+    HDR_FORWARDED,                      /**&lt; RFC 7239 */
+    HDR_FROM,                           /**&lt; RFC 7231 */
+    HDR_HOST,                           /**&lt; RFC 7230 */
+    HDR_HTTP2_SETTINGS,                 /**&lt; HTTP/2.0 upgrade header. see draft-ietf-httpbis-http2-13 */
+    /*HDR_IF,*/                         /* RFC 2518 */
+    HDR_IF_MATCH,                       /**&lt; RFC 7232 */
+    HDR_IF_MODIFIED_SINCE,              /**&lt; RFC 7232 */
+    HDR_IF_NONE_MATCH,                  /**&lt; RFC 7232 */
+    HDR_IF_RANGE,                       /**&lt; RFC 7233 */
+    HDR_IF_UNMODIFIED_SINCE,            /**&lt; RFC 7232 */
+    HDR_KEEP_ALIVE,                     /**&lt; obsoleted RFC 2068 header we may need to erase */
+    HDR_KEY,                            /**&lt; experimental RFC Draft draft-fielding-http-key-02 */
+    HDR_LAST_MODIFIED,                  /**&lt; RFC 7232 */
+    HDR_LINK,                           /**&lt; RFC 5988 */
+    HDR_LOCATION,                       /**&lt; RFC 7231 */
+    /*HDR_LOCK_TOKEN,*/                 /* RFC 2518 */
+    HDR_MAX_FORWARDS,                   /**&lt; RFC 7231 */
+    HDR_MIME_VERSION,                   /**&lt; RFC 2045, 7231 */
+    HDR_NEGOTIATE,                      /**&lt; experimental RFC 2295. Why only this one from 2295? */
+    /*HDR_OVERWRITE,*/                  /* RFC 2518 */
+    HDR_ORIGIN,                         /* CORS Draft specification (see <A HREF="http://www.w3.org/TR/cors/">http://www.w3.org/TR/cors/</A>) */
+    HDR_PRAGMA,                         /**&lt; RFC 7234 */
+    HDR_PROXY_AUTHENTICATE,             /**&lt; RFC 7235 */
+    HDR_PROXY_AUTHENTICATION_INFO,      /**&lt; RFC 2617 */
+    HDR_PROXY_AUTHORIZATION,            /**&lt; RFC 7235 */
+    HDR_PROXY_CONNECTION,               /**&lt; obsolete Netscape header we may need to erase. */
+    HDR_PROXY_SUPPORT,                  /**&lt; RFC 4559 */
+    HDR_PUBLIC,                         /**&lt;  RFC 2068 */
+    HDR_RANGE,                          /**&lt; RFC 7233 */
+    HDR_REFERER,                        /**&lt; RFC 7231 */
+    HDR_REQUEST_RANGE,                  /**&lt; some clients use this, sigh */
+    HDR_RETRY_AFTER,                    /**&lt; RFC 7231 */
+    HDR_SERVER,                         /**&lt; RFC 7231 */
+    HDR_SET_COOKIE,                     /**&lt; RFC 6265 header we may need to erase */
+    HDR_SET_COOKIE2,                    /**&lt; obsoleted RFC 2965 header we may need to erase */
+    /*HDR_STATUS_URI,*/                 /* RFC 2518 */
+    /*HDR_TCN,*/                        /* experimental RFC 2295 */
+    HDR_TE,                             /**&lt; RFC 7230 */
+    /*HDR_TIMEOUT,*/                    /* RFC 2518 */
+    HDR_TITLE,                          /* obsolete draft suggested header */
+    HDR_TRAILER,                        /**&lt; RFC 7230 */
+    HDR_TRANSFER_ENCODING,              /**&lt; RFC 7230 */
+    HDR_TRANSLATE,                      /**&lt; IIS custom header we may need to erase */
+    HDR_UNLESS_MODIFIED_SINCE,          /**&lt; IIS custom header we may need to erase */
+    HDR_UPGRADE,                        /**&lt; RFC 7230 */
+    HDR_USER_AGENT,                     /**&lt; RFC 7231 */
+    /*HDR_VARIANT_VARY,*/               /* experimental RFC 2295 */
+    HDR_VARY,                           /**&lt; RFC 7231 */
+    HDR_VIA,                            /**&lt; RFC 7230 */
+    HDR_WARNING,                        /**&lt; RFC 7234 */
+    HDR_WWW_AUTHENTICATE,               /**&lt; RFC 7235, 4559 */
+    HDR_X_CACHE,                        /**&lt; Squid custom header */
+    HDR_X_CACHE_LOOKUP,                 /**&lt; Squid custom header. temporary hack that became de-facto. TODO remove */
+    HDR_X_FORWARDED_FOR,                /**&lt; obsolete Squid custom header, RFC 7239 */
+    HDR_X_REQUEST_URI,                  /**&lt; Squid custom header appended if ADD_X_REQUEST_URI is defined */
+    HDR_X_SQUID_ERROR,                  /**&lt; Squid custom header on generated error responses */
+#if X_ACCELERATOR_VARY
+    HDR_X_ACCELERATOR_VARY,             /**&lt; obsolete Squid custom header. */
+#endif
+#if USE_ADAPTATION
+    HDR_X_NEXT_SERVICES,                /**&lt; Squid custom ICAP header */
+#endif
+    HDR_SURROGATE_CAPABILITY,           /**&lt; Edge Side Includes (ESI) header */
+    HDR_SURROGATE_CONTROL,              /**&lt; Edge Side Includes (ESI) header */
+    HDR_FRONT_END_HTTPS,                /**&lt; MS Exchange custom header we may have to add */
+    HDR_FTP_COMMAND,                    /**&lt; Internal header for FTP command */
+    HDR_FTP_ARGUMENTS,                  /**&lt; Internal header for FTP command arguments */
+    HDR_FTP_PRE,                        /**&lt; Internal header containing leading FTP control response lines */
+    HDR_FTP_STATUS,                     /**&lt; Internal header for FTP reply status */
+    HDR_FTP_REASON,                     /**&lt; Internal header for FTP reply reason */
+    HDR_OTHER,                          /**&lt; internal tag value for &quot;unknown&quot; headers */
+    HDR_ENUM_END
+} http_hdr_type;
+
+#endif /* SQUID_HTTP_REGISTEREDHEADERS_H */

=== renamed file 'src/HttpRequestMethod.cc' =&gt; 'src/http/RequestMethod.cc'
--- src/HttpRequestMethod.cc	2014-09-13 13:59:43 +0000
+++ src/http/RequestMethod.cc	2014-10-15 09:48:49 +0000
@@ -1,84 +1,117 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 73    HTTP Request */
 
 #include &quot;squid.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;wordlist.h&quot;
 
 static Http::MethodType &amp;
 operator++ (Http::MethodType &amp;aMethod)
 {
     int tmp = (int)aMethod;
     aMethod = (Http::MethodType)(++tmp);
     return aMethod;
 }
 
 /**
- * Construct a HttpRequestMethod from a NULL terminated string such as &quot;GET&quot;
- * or from a range of chars, * such as &quot;GET&quot; from &quot;GETFOOBARBAZ&quot;
- * (pass in pointer to G and pointer to F.)
+ * Construct a HttpRequestMethod from a C-string such as &quot;GET&quot;
+ * Assumes the string is either nul-terminated or contains whitespace
+ *
+ * \deprecated use SBuf constructor instead
  */
-HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod(Http::METHOD_NONE)
+void
+HttpRequestMethod::HttpRequestMethodXXX(char const *begin)
 {
+    // XXX: performance regression due to this method no longer being a constructor
+    // ensure the members are empty/default values before any of the early-return
+    // optimizations can be used.
+    theMethod = Http::METHOD_NONE;
+    theImage.clear();
+
     if (begin == NULL)
         return;
 
-    /*
-     * if e is NULL, b must be NULL terminated and we
-     * make e point to the first whitespace character
-     * after b.
-     */
-    if (NULL == end)
-        end = begin + strcspn(begin, w_space);
+    char const *end = begin + strcspn(begin, w_space);
 
     if (end == begin)
         return;
 
     // TODO: Optimize this linear search.
     for (++theMethod; theMethod &lt; Http::METHOD_ENUM_END; ++theMethod) {
         // RFC 2616 section 5.1.1 - Method names are case-sensitive
         // NP: this is not a HTTP_VIOLATIONS case since there is no MUST/SHOULD involved.
         if (0 == image().caseCmp(begin, end-begin)) {
 
             // relaxed parser allows mixed-case and corrects them on output
             if (Config.onoff.relaxed_header_parser)
                 return;
 
             if (0 == image().cmp(begin, end-begin))
                 return;
         }
     }
 
     // if method not found and method string is not null then it is other method
     theMethod = Http::METHOD_OTHER;
     theImage.assign(begin, end-begin);
 }
 
+/**
+ * Construct a HttpRequestMethod from an SBuf string such as &quot;GET&quot;
+ * or from a range of chars such as &quot;FOO&quot; from buffer &quot;GETFOOBARBAZ&quot;
+ *
+ * Assumes the s parameter contains only the characters representing the method name
+ */
+HttpRequestMethod::HttpRequestMethod(const SBuf &amp;s) : theMethod(Http::METHOD_NONE)
+{
+    if (s.isEmpty())
+        return;
+
+    // TODO: Optimize this linear search.
+    for (++theMethod; theMethod &lt; Http::METHOD_ENUM_END; ++theMethod) {
+        // RFC 2616 section 5.1.1 - Method names are case-sensitive
+        // NP: this is not a HTTP_VIOLATIONS case since there is no MUST/SHOULD involved.
+        if (0 == image().caseCmp(s)) {
+
+            // relaxed parser allows mixed-case and corrects them on output
+            if (Config.onoff.relaxed_header_parser)
+                return;
+
+            if (0 == image().cmp(s))
+                return;
+        }
+    }
+
+    // if method not found and method string is not null then it is other method
+    theMethod = Http::METHOD_OTHER;
+    theImage = s;
+}
+
 const SBuf &amp;
 HttpRequestMethod::image() const
 {
     static const SBuf methodOther(&quot;METHOD_OTHER&quot;);
     if (Http::METHOD_OTHER != theMethod) {
         return Http::MethodType_sb[theMethod];
     } else {
         if (!theImage.isEmpty()) {
             return theImage;
         } else {
             return methodOther;
         }
     }
 }
 
 bool
 HttpRequestMethod::isHttpSafe() const
 {
     // Only a few methods are defined as safe. All others are &quot;unsafe&quot;
 

=== renamed file 'src/HttpRequestMethod.h' =&gt; 'src/http/RequestMethod.h'
--- src/HttpRequestMethod.h	2014-09-13 13:59:43 +0000
+++ src/http/RequestMethod.h	2014-10-15 04:17:38 +0000
@@ -1,61 +1,53 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPREQUESTMETHOD_H
 #define SQUID_HTTPREQUESTMETHOD_H
 
+#include &quot;http/forward.h&quot;
 #include &quot;http/MethodType.h&quot;
 #include &quot;SBuf.h&quot;
 
 class SquidConfig;
 
 #include &lt;iosfwd&gt;
 
 /**
  * This class represents an HTTP Request METHOD
  * - i.e. PUT, POST, GET etc.
  * It has a runtime extension facility to allow it to
  * efficiently support new methods
  */
-class HttpRequestMethod
+class HttpRequestMethod : public RefCountable
 {
-
 public:
-//    static void Configure(SquidConfig &amp;Config);
-
     HttpRequestMethod() : theMethod(Http::METHOD_NONE), theImage() {}
-
     HttpRequestMethod(Http::MethodType const aMethod) : theMethod(aMethod), theImage() {}
+    explicit HttpRequestMethod(const SBuf &amp;);
 
-    /**
-     \param begin    string to convert to request method.
-     \param end      end of the method string (relative to begin). Use NULL if this is unknown.
-     *
-     \note DO NOT give end a default (ie NULL). That will cause silent char* conversion clashes.
-     */
-    HttpRequestMethod(char const * begin, char const * end);
+    void HttpRequestMethodXXX(char const *); // deprecated old c-string to SBuf converter.
 
     HttpRequestMethod &amp; operator = (const HttpRequestMethod&amp; aMethod) {
         theMethod = aMethod.theMethod;
         theImage = aMethod.theImage;
         return *this;
     }
 
     HttpRequestMethod &amp; operator = (Http::MethodType const aMethod) {
         theMethod = aMethod;
         theImage.clear();
         return *this;
     }
 
     bool operator == (Http::MethodType const &amp; aMethod) const { return theMethod == aMethod; }
     bool operator == (HttpRequestMethod const &amp; aMethod) const {
         return theMethod == aMethod.theMethod &amp;&amp;
                (theMethod != Http::METHOD_OTHER || theImage == aMethod.theImage);
     }
 
     bool operator != (Http::MethodType const &amp; aMethod) const { return theMethod != aMethod; }

=== added file 'src/http/forward.h'
--- src/http/forward.h	1970-01-01 00:00:00 +0000
+++ src/http/forward.h	2014-05-20 07:45:55 +0000
@@ -0,0 +1,16 @@
+#ifndef SQUID_SRC_HTTP_FORWARD_H
+#define SQUID_SRC_HTTP_FORWARD_H
+
+#include &quot;http/one/forward.h&quot;
+
+// TODO move these classes into Http namespace
+class HttpRequestMethod;
+typedef RefCount&lt;HttpRequestMethod&gt; HttpRequestMethodPointer;
+
+class HttpRequest;
+typedef RefCount&lt;HttpRequest&gt; HttpRequestPointer;
+
+class HttpReply;
+typedef RefCount&lt;HttpReply&gt; HttpReplyPointer;
+
+#endif /* SQUID_SRC_HTTP_FORWARD_H */

=== added directory 'src/http/one'
=== added file 'src/http/one/Makefile.am'
--- src/http/one/Makefile.am	1970-01-01 00:00:00 +0000
+++ src/http/one/Makefile.am	2014-07-30 07:38:25 +0000
@@ -0,0 +1,11 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libhttp1.la
+
+libhttp1_la_SOURCES = \
+	forward.h \
+	Parser.cc \
+	Parser.h \
+	RequestParser.cc \
+	RequestParser.h

=== renamed file 'src/HttpParser.cc' =&gt; 'src/http/one/Parser.cc'
--- src/HttpParser.cc	2014-09-13 13:59:43 +0000
+++ src/http/one/Parser.cc	2014-09-14 12:23:03 +0000
@@ -1,302 +1,80 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;Debug.h&quot;
-#include &quot;HttpParser.h&quot;
-#include &quot;profiler/Profiler.h&quot;
-#include &quot;SquidConfig.h&quot;
+#include &quot;http/one/Parser.h&quot;
+#include &quot;parser/Tokenizer.h&quot;
 
-void
-HttpParser::clear()
-{
-    state = HTTP_PARSE_NONE;
-    request_parse_status = Http::scNone;
-    buf = NULL;
-    bufsiz = 0;
-    req.start = req.end = -1;
-    hdr_start = hdr_end = -1;
-    req.m_start = req.m_end = -1;
-    req.u_start = req.u_end = -1;
-    req.v_start = req.v_end = -1;
-    req.v_maj = req.v_min = 0;
-}
+/// RFC 7230 section 2.6 - 7 magic octets
+const SBuf Http::One::Parser::Http1magic(&quot;HTTP/1.&quot;);
 
 void
-HttpParser::reset(const char *aBuf, int len)
+Http::One::Parser::clear()
 {
-    clear(); // empty the state.
-    state = HTTP_PARSE_NEW;
-    buf = aBuf;
-    bufsiz = len;
-    debugs(74, 5, HERE &lt;&lt; &quot;Request buffer is &quot; &lt;&lt; buf);
+    parsingStage_ = HTTP_PARSE_NONE;
+    buf_ = NULL;
+    msgProtocol_ = AnyP::ProtocolVersion();
+    mimeHeaderBlock_.clear();
 }
 
-int
-HttpParser::parseRequestFirstLine()
+// arbitrary maximum-length for headers which can be found by Http1Parser::getHeaderField()
+#define GET_HDR_SZ	1024
+
+// BUG: returns only the first header line with given name,
+//      ignores multi-line headers and obs-fold headers
+char *
+Http::One::Parser::getHeaderField(const char *name)
 {
-    int second_word = -1; // track the suspected URI start
-    int first_whitespace = -1, last_whitespace = -1; // track the first and last SP byte
-    int line_end = -1; // tracks the last byte BEFORE terminal \r\n or \n sequence
-
-    debugs(74, 5, HERE &lt;&lt; &quot;parsing possible request: &quot; &lt;&lt; buf);
-
-    // Single-pass parse: (provided we have the whole line anyways)
-
-    req.start = 0;
-    if (Config.onoff.relaxed_header_parser) {
-        if (Config.onoff.relaxed_header_parser &lt; 0 &amp;&amp; buf[req.start] == ' ')
-            debugs(74, DBG_IMPORTANT, &quot;WARNING: Invalid HTTP Request: &quot; &lt;&lt;
-                   &quot;Whitespace bytes received ahead of method. &quot; &lt;&lt;
-                   &quot;Ignored due to relaxed_header_parser.&quot;);
-        // Be tolerant of prefix spaces (other bytes are valid method values)
-        for (; req.start &lt; bufsiz &amp;&amp; buf[req.start] == ' '; ++req.start);
-    }
-    req.end = -1;
-    for (int i = 0; i &lt; bufsiz; ++i) {
-        // track first and last whitespace (SP only)
-        if (buf[i] == ' ') {
-            last_whitespace = i;
-            if (first_whitespace &lt; req.start)
-                first_whitespace = i;
-        }
-
-        // track next non-SP/non-HT byte after first_whitespace
-        if (second_word &lt; first_whitespace &amp;&amp; buf[i] != ' ' &amp;&amp; buf[i] != '\t') {
-            second_word = i;
-        }
-
-        // locate line terminator
-        if (buf[i] == '\n') {
-            req.end = i;
-            line_end = i - 1;
-            break;
-        }
-        if (i &lt; bufsiz - 1 &amp;&amp; buf[i] == '\r') {
-            if (Config.onoff.relaxed_header_parser) {
-                if (Config.onoff.relaxed_header_parser &lt; 0 &amp;&amp; buf[i + 1] == '\r')
-                    debugs(74, DBG_IMPORTANT, &quot;WARNING: Invalid HTTP Request: &quot; &lt;&lt;
-                           &quot;Series of carriage-return bytes received prior to line terminator. &quot; &lt;&lt;
-                           &quot;Ignored due to relaxed_header_parser.&quot;);
-
-                // Be tolerant of invalid multiple \r prior to terminal \n
-                if (buf[i + 1] == '\n' || buf[i + 1] == '\r')
-                    line_end = i - 1;
-                while (i &lt; bufsiz - 1 &amp;&amp; buf[i + 1] == '\r')
-                    ++i;
-
-                if (buf[i + 1] == '\n') {
-                    req.end = i + 1;
-                    break;
-                }
-            } else {
-                if (buf[i + 1] == '\n') {
-                    req.end = i + 1;
-                    line_end = i - 1;
-                    break;
-                }
-            }
-
-            // RFC 2616 section 5.1
-            // &quot;No CR or LF is allowed except in the final CRLF sequence&quot;
-            request_parse_status = Http::scBadRequest;
-            return -1;
-        }
-    }
-    if (req.end == -1) {
-        debugs(74, 5, &quot;Parser: retval 0: from &quot; &lt;&lt; req.start &lt;&lt;
-               &quot;-&gt;&quot; &lt;&lt; req.end &lt;&lt; &quot;: needs more data to complete first line.&quot;);
-        return 0;
-    }
+    if (!headerBlockSize() || !name)
+        return NULL;
 
-    // NP: we have now seen EOL, more-data (0) cannot occur.
-    //     From here on any failure is -1, success is 1
+    LOCAL_ARRAY(char, header, GET_HDR_SZ);
+    const int namelen = name ? strlen(name) : 0;
 
-    // Input Validation:
+    debugs(25, 5, &quot;looking for &quot; &lt;&lt; name);
 
-    // Process what we now know about the line structure into field offsets
-    // generating HTTP status for any aborts as we go.
+    // while we can find more LF in the SBuf
+    static CharacterSet iso8859Line = CharacterSet(&quot;non-LF&quot;,'\0','\n'-1) + CharacterSet(NULL, '\n'+1, (unsigned char)0xFF);
+    ::Parser::Tokenizer tok(mimeHeaderBlock_);
+    SBuf p;
+    static const SBuf crlf(&quot;\r\n&quot;);
 
-    // First non-whitespace = beginning of method
-    if (req.start &gt; line_end) {
-        request_parse_status = Http::scBadRequest;
-        return -1;
-    }
-    req.m_start = req.start;
+    while (tok.prefix(p, iso8859Line)) {
+        tok.skipOne(CharacterSet::LF); // move tokenizer past the LF
 
-    // First whitespace = end of method
-    if (first_whitespace &gt; line_end || first_whitespace &lt; req.start) {
-        request_parse_status = Http::scBadRequest; // no method
-        return -1;
-    }
-    req.m_end = first_whitespace - 1;
-    if (req.m_end &lt; req.m_start) {
-        request_parse_status = Http::scBadRequest; // missing URI?
-        return -1;
-    }
+        // header lines must start with the name (case insensitive)
+        if (p.substr(0, namelen).caseCmp(name, namelen))
+            continue;
 
-    // First non-whitespace after first SP = beginning of URL+Version
-    if (second_word &gt; line_end || second_word &lt; req.start) {
-        request_parse_status = Http::scBadRequest; // missing URI
-        return -1;
-    }
-    req.u_start = second_word;
+        // then a COLON
+        if (p[namelen] != ':')
+            continue;
 
-    // RFC 1945: SP and version following URI are optional, marking version 0.9
-    // we identify this by the last whitespace being earlier than URI start
-    if (last_whitespace &lt; second_word &amp;&amp; last_whitespace &gt;= req.start) {
-        req.v_maj = 0;
-        req.v_min = 9;
-        req.u_end = line_end;
-        request_parse_status = Http::scOkay; // HTTP/0.9
-        return 1;
-    } else {
-        // otherwise last whitespace is somewhere after end of URI.
-        req.u_end = last_whitespace;
-        // crop any trailing whitespace in the area we think of as URI
-        for (; req.u_end &gt;= req.u_start &amp;&amp; xisspace(buf[req.u_end]); --req.u_end);
-    }
-    if (req.u_end &lt; req.u_start) {
-        request_parse_status = Http::scBadRequest; // missing URI
-        return -1;
-    }
+        // drop any trailing *CR sequence
+        p.trim(crlf, false, true);
 
-    // Last whitespace SP = before start of protocol/version
-    if (last_whitespace &gt;= line_end) {
-        request_parse_status = Http::scBadRequest; // missing version
-        return -1;
-    }
-    req.v_start = last_whitespace + 1;
-    req.v_end = line_end;
+        debugs(25, 5, &quot;checking &quot; &lt;&lt; p);
+        p.consume(namelen + 1);
 
-    // We only accept HTTP protocol requests right now.
-    // TODO: accept other protocols; RFC 2326 (RTSP protocol) etc
-    if ((req.v_end - req.v_start +1) &lt; 5 || strncasecmp(&amp;buf[req.v_start], &quot;HTTP/&quot;, 5) != 0) {
-#if USE_HTTP_VIOLATIONS
-        // being lax; old parser accepted strange versions
-        // there is a LOT of cases which are ambiguous, therefore we cannot use relaxed_header_parser here.
-        req.v_maj = 0;
-        req.v_min = 9;
-        req.u_end = line_end;
-        request_parse_status = Http::scOkay; // treat as HTTP/0.9
-        return 1;
-#else
-        // protocol not supported / implemented.
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-#endif
-    }
+        // TODO: optimize SBuf::trim to take CharacterSet directly
+        ::Parser::Tokenizer t(p);
+        t.skipAll(CharacterSet::WSP);
+        p = t.remaining();
 
-    int i = req.v_start + sizeof(&quot;HTTP/&quot;) -1;
+        // prevent buffer overrun on char header[];
+        p.chop(0, sizeof(header)-1);
 
-    /* next should be 1 or more digits */
-    if (!isdigit(buf[i])) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-    }
-    int maj = 0;
-    for (; i &lt;= line_end &amp;&amp; (isdigit(buf[i])) &amp;&amp; maj &lt; 65536; ++i) {
-        maj = maj * 10;
-        maj = maj + (buf[i]) - '0';
+        // return the header field-value
+        xstrncpy(header, p.rawContent(), p.length());
+        debugs(25, 5, &quot;returning &quot; &lt;&lt; header);
+        return header;
     }
-    // catch too-big values or missing remainders
-    if (maj &gt;= 65536 || i &gt; line_end) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-    }
-    req.v_maj = maj;
 
-    /* next should be .; we -have- to have this as we have a whole line.. */
-    if (buf[i] != '.') {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-    }
-    // catch missing minor part
-    if (++i &gt; line_end) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-    }
-    /* next should be one or more digits */
-    if (!isdigit(buf[i])) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-    }
-    int min = 0;
-    for (; i &lt;= line_end &amp;&amp; (isdigit(buf[i])) &amp;&amp; min &lt; 65536; ++i) {
-        min = min * 10;
-        min = min + (buf[i]) - '0';
-    }
-    // catch too-big values or trailing garbage
-    if (min &gt;= 65536 || i &lt; line_end) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
-    }
-    req.v_min = min;
-
-    /*
-     * Rightio - we have all the schtuff. Return true; we've got enough.
-     */
-    request_parse_status = Http::scOkay;
-    return 1;
-}
-
-int
-HttpParserParseReqLine(HttpParser *hmsg)
-{
-    PROF_start(HttpParserParseReqLine);
-    int retcode = hmsg-&gt;parseRequestFirstLine();
-    debugs(74, 5, &quot;Parser: retval &quot; &lt;&lt; retcode &lt;&lt; &quot;: from &quot; &lt;&lt; hmsg-&gt;req.start &lt;&lt;
-           &quot;-&gt;&quot; &lt;&lt; hmsg-&gt;req.end &lt;&lt; &quot;: method &quot; &lt;&lt; hmsg-&gt;req.m_start &lt;&lt; &quot;-&gt;&quot; &lt;&lt;
-           hmsg-&gt;req.m_end &lt;&lt; &quot;; url &quot; &lt;&lt; hmsg-&gt;req.u_start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; hmsg-&gt;req.u_end &lt;&lt;
-           &quot;; version &quot; &lt;&lt; hmsg-&gt;req.v_start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; hmsg-&gt;req.v_end &lt;&lt; &quot; (&quot; &lt;&lt; hmsg-&gt;req.v_maj &lt;&lt;
-           &quot;/&quot; &lt;&lt; hmsg-&gt;req.v_min &lt;&lt; &quot;)&quot;);
-    PROF_stop(HttpParserParseReqLine);
-    return retcode;
-}
-
-#if MSGDODEBUG
-/* XXX This should eventually turn into something inlined or #define'd */
-int
-HttpParserReqSz(HttpParser *hp)
-{
-    assert(hp-&gt;state == HTTP_PARSE_NEW);
-    assert(hp-&gt;req.start != -1);
-    assert(hp-&gt;req.end != -1);
-    return hp-&gt;req.end - hp-&gt;req.start + 1;
-}
-
-/*
- * This +1 makes it 'right' but won't make any sense if
- * there's a 0 byte header? This won't happen normally - a valid header
- * is at -least- a blank line (\n, or \r\n.)
- */
-int
-HttpParserHdrSz(HttpParser *hp)
-{
-    assert(hp-&gt;state == HTTP_PARSE_NEW);
-    assert(hp-&gt;hdr_start != -1);
-    assert(hp-&gt;hdr_end != -1);
-    return hp-&gt;hdr_end - hp-&gt;hdr_start + 1;
-}
-
-const char *
-HttpParserHdrBuf(HttpParser *hp)
-{
-    assert(hp-&gt;state == HTTP_PARSE_NEW);
-    assert(hp-&gt;hdr_start != -1);
-    assert(hp-&gt;hdr_end != -1);
-    return hp-&gt;buf + hp-&gt;hdr_start;
+    return NULL;
 }
-
-int
-HttpParserRequestLen(HttpParser *hp)
-{
-    return hp-&gt;hdr_end - hp-&gt;req.start + 1;
-}
-#endif
-

=== renamed file 'src/HttpParser.h' =&gt; 'src/http/one/Parser.h'
--- src/HttpParser.h	2014-09-13 13:59:43 +0000
+++ src/http/one/Parser.h	2014-10-15 08:18:33 +0000
@@ -1,104 +1,110 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef _SQUID_SRC_HTTPPARSER_H
-#define _SQUID_SRC_HTTPPARSER_H
+#ifndef _SQUID_SRC_HTTP_ONE_PARSER_H
+#define _SQUID_SRC_HTTP_ONE_PARSER_H
 
-#include &quot;http/StatusCode.h&quot;
+#include &quot;anyp/ProtocolVersion.h&quot;
+#include &quot;http/one/forward.h&quot;
+#include &quot;SBuf.h&quot;
+
+namespace Http {
+namespace One {
 
 // Parser states
-#define HTTP_PARSE_NONE   0 // nothing. completely unset state.
-#define HTTP_PARSE_NEW    1 // initialized, but nothing usefully parsed yet.
+enum ParseState {
+    HTTP_PARSE_NONE,     ///&lt; initialized, but nothing usefully parsed yet
+    HTTP_PARSE_FIRST,    ///&lt; HTTP/1 message first-line
+    HTTP_PARSE_MIME,     ///&lt; HTTP/1 mime-header block
+    HTTP_PARSE_DONE      ///&lt; parsed a message header, or reached a terminal syntax error
+};
 
-/** HTTP protocol parser.
+/** HTTP/1.x protocol parser
  *
  * Works on a raw character I/O buffer and tokenizes the content into
- * either an error state or, an HTTP procotol request major segments:
- *  1. Request Line (method, URL, protocol, version)
- *  2. Mime header block
+ * the major CRLF delimited segments of an HTTP/1 procotol message:
+ *
+ * \item first-line (request-line / simple-request / status-line)
+ * \item mime-header 0*( header-name ':' SP field-value CRLF)
  */
-class HttpParser
+class Parser : public RefCountable
 {
 public:
-    HttpParser() { clear(); }
+    typedef SBuf::size_type size_type;
 
-    /** Initialize a new parser.
-     * Presenting it a buffer to work on and the current length of available
-     * data.
-     * NOTE: This is *not* the buffer size, just the parse-able data length.
-     * The parse routines may be called again later with more data.
-     */
-    HttpParser(const char *aBuf, int len) { reset(aBuf,len); };
+    Parser() : parsingStage_(HTTP_PARSE_NONE) {}
+    virtual ~Parser() {}
 
     /// Set this parser back to a default state.
     /// Will DROP any reference to a buffer (does not free).
-    void clear();
+    virtual void clear() = 0;
+
+    /// attempt to parse a message from the buffer
+    /// \retval true if a full message was found and parsed
+    /// \retval false if incomplete, invalid or no message was found
+    virtual bool parse(const SBuf &amp;aBuf) = 0;
+
+    /** Whether the parser is waiting on more data to complete parsing a message.
+     * Use to distinguish between incomplete data and error results
+     * when parse() returns false.
+     */
+    bool needsMoreData() const {return parsingStage_!=HTTP_PARSE_DONE;}
+
+    /// size in bytes of the first line including CRLF terminator
+    virtual size_type firstLineSize() const = 0;
 
-    /// Reset the parser for use on a new buffer.
-    void reset(const char *aBuf, int len);
+    /// size in bytes of the message headers including CRLF terminator(s)
+    /// but excluding first-line bytes
+    size_type headerBlockSize() const {return mimeHeaderBlock_.length();}
+
+    /// size in bytes of HTTP message block, includes first-line and mime headers
+    /// excludes any body/entity/payload bytes
+    /// excludes any garbage prefix before the first-line
+    size_type messageHeaderSize() const {return firstLineSize() + headerBlockSize();}
+
+    /// buffer containing HTTP mime headers, excluding message first-line.
+    SBuf mimeHeader() const {return mimeHeaderBlock_;}
+
+    /// the protocol label for this message
+    const AnyP::ProtocolVersion &amp; messageProtocol() const {return msgProtocol_;}
 
     /**
-     * Attempt to parse the first line of a new request message.
+     * Scan the mime header block (badly) for a header with teh given name.
      *
-     * Governed by:
-     *  RFC 1945 section 5.1
-     *  RFC 2616 section 5.1
+     * BUG: omits lines when searching for headers with obs-fold or multiple entries.
      *
-     * Parsing state is stored between calls. However the current implementation
-     * begins parsing from scratch on every call.
-     * The return value tells you whether the parsing state fields are valid or not.
+     * BUG: limits output to just 1KB when Squid accepts up to 64KB line length.
      *
-     * \retval -1  an error occurred. request_parse_status indicates HTTP status result.
-     * \retval  1  successful parse. member fields contain the request-line items
-     * \retval  0  more data is needed to complete the parse
+     * \return A pointer to a field-value of the first matching field-name, or NULL.
      */
-    int parseRequestFirstLine();
+    char *getHeaderField(const char *name);
 
-public:
-    uint8_t state;
-    const char *buf;
-    int bufsiz;
-
-    /// Offsets for pieces of the (HTTP request) Request-Line as per RFC 2616
-    struct request_offsets {
-        int start, end;
-        int m_start, m_end; // method
-        int u_start, u_end; // url
-        int v_start, v_end; // version (full text)
-        int v_maj, v_min;   // version numerics
-    } req;
+    /// the remaining unprocessed section of buffer
+    const SBuf &amp;remaining() const {return buf_;}
 
-    // Offsets for pieces of the MiME Header segment
-    int hdr_start, hdr_end;
+protected:
+    /// RFC 7230 section 2.6 - 7 magic octets
+    static const SBuf Http1magic;
 
-    // TODO: Offsets for pieces of the (HTTP reply) Status-Line as per RFC 2616
+    /// bytes remaining to be parsed
+    SBuf buf_;
 
-    /** HTTP status code to be used on the invalid-request error page
-     * Http::scNone indicates incomplete parse, Http::scOkay indicates no error.
-     */
-    Http::StatusCode request_parse_status;
+    /// what stage the parser is currently up to
+    ParseState parsingStage_;
+
+    /// what protocol label has been found in the first line (if any)
+    AnyP::ProtocolVersion msgProtocol_;
+
+    /// buffer holding the mime headers (if any)
+    SBuf mimeHeaderBlock_;
 };
 
-// Legacy functions
-#define HttpParserInit(h,b,l) (h)-&gt;reset((b),(l))
-int HttpParserParseReqLine(HttpParser *hp);
-
-#define MSGDODEBUG 0
-#if MSGDODEBUG
-int HttpParserReqSz(HttpParser *);
-int HttpParserHdrSz(HttpParser *);
-const char * HttpParserHdrBuf(HttpParser *);
-int HttpParserRequestLen(HttpParser *hp);
-#else
-#define HttpParserReqSz(hp)     ( (hp)-&gt;req.end - (hp)-&gt;req.start + 1 )
-#define HttpParserHdrSz(hp)     ( (hp)-&gt;hdr_end - (hp)-&gt;hdr_start + 1 )
-#define HttpParserHdrBuf(hp)    ( (hp)-&gt;buf + (hp)-&gt;hdr_start )
-#define HttpParserRequestLen(hp)        ( (hp)-&gt;hdr_end - (hp)-&gt;req.start + 1 )
-#endif
+} // namespace One
+} // namespace Http
 
-#endif /*  _SQUID_SRC_HTTPPARSER_H */
+#endif /*  _SQUID_SRC_HTTP_ONE_PARSER_H */

=== added file 'src/http/one/RequestParser.cc'
--- src/http/one/RequestParser.cc	1970-01-01 00:00:00 +0000
+++ src/http/one/RequestParser.cc	2014-10-15 09:32:12 +0000
@@ -0,0 +1,356 @@
+#include &quot;squid.h&quot;
+#include &quot;Debug.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
+#include &quot;http/ProtocolVersion.h&quot;
+#include &quot;mime_header.h&quot;
+#include &quot;profiler/Profiler.h&quot;
+#include &quot;SquidConfig.h&quot;
+
+Http::One::RequestParser::RequestParser() :
+        Parser(),
+        request_parse_status(Http::scNone)
+{
+    req.start = req.end = -1;
+    req.m_start = req.m_end = -1;
+    req.u_start = req.u_end = -1;
+    req.v_start = req.v_end = -1;
+}
+
+/**
+ * Attempt to parse the first line of a new request message.
+ *
+ * Governed by RFC 7230 section 3.5
+ *  &quot;
+ *    In the interest of robustness, a server that is expecting to receive
+ *    and parse a request-line SHOULD ignore at least one empty line (CRLF)
+ *    received prior to the request-line.
+ *  &quot;
+ *
+ * Parsing state is stored between calls to avoid repeating buffer scans.
+ * If garbage is found the parsing offset is incremented.
+ */
+void
+Http::One::RequestParser::skipGarbageLines()
+{
+    if (Config.onoff.relaxed_header_parser) {
+        if (Config.onoff.relaxed_header_parser &lt; 0 &amp;&amp; (buf_[0] == '\r' || buf_[0] == '\n'))
+            debugs(74, DBG_IMPORTANT, &quot;WARNING: Invalid HTTP Request: &quot; &lt;&lt;
+                   &quot;CRLF bytes received ahead of request-line. &quot; &lt;&lt;
+                   &quot;Ignored due to relaxed_header_parser.&quot;);
+        // Be tolerant of prefix empty lines
+        // ie any series of either \n or \r\n with no other characters and no repeated \r
+        while (!buf_.isEmpty() &amp;&amp; (buf_[0] == '\n' || (buf_[0] == '\r' &amp;&amp; buf_[1] == '\n'))) {
+            buf_.consume(1);
+        }
+    }
+
+    /* XXX: this is a Squid-specific tolerance
+     * it appears never to have been relevant outside out unit-tests
+     * because the ConnStateData parser loop starts with consumeWhitespace()
+     * which absorbs any SP HTAB VTAB CR LF characters.
+     * But unit-tests called the HttpParser method directly without that pruning.
+     */
+#if USE_HTTP_VIOLATIONS
+    if (Config.onoff.relaxed_header_parser) {
+        if (Config.onoff.relaxed_header_parser &lt; 0 &amp;&amp; buf_[0] == ' ')
+            debugs(74, DBG_IMPORTANT, &quot;WARNING: Invalid HTTP Request: &quot; &lt;&lt;
+                   &quot;Whitespace bytes received ahead of method. &quot; &lt;&lt;
+                   &quot;Ignored due to relaxed_header_parser.&quot;);
+        // Be tolerant of prefix spaces (other bytes are valid method values)
+        while (!buf_.isEmpty() &amp;&amp; buf_[0] == ' ') {
+            buf_.consume(1);
+        }
+    }
+#endif
+}
+
+/**
+ * Attempt to parse the first line of a new request message.
+ *
+ * Governed by:
+ *  RFC 1945 section 5.1
+ *  RFC 7230 section 3.1 and 3.5
+ *
+ * Parsing state is stored between calls. However the current implementation
+ * begins parsing from scratch on every call.
+ * The return value tells you whether the parsing state fields are valid or not.
+ *
+ * \retval -1  an error occurred. request_parse_status indicates HTTP status result.
+ * \retval  1  successful parse. member fields contain the request-line items
+ * \retval  0  more data is needed to complete the parse
+ */
+int
+Http::One::RequestParser::parseRequestFirstLine()
+{
+    int second_word = -1; // track the suspected URI start
+    int first_whitespace = -1, last_whitespace = -1; // track the first and last SP byte
+    int line_end = -1; // tracks the last byte BEFORE terminal \r\n or \n sequence
+
+    debugs(74, 5, &quot;parsing possible request: buf.length=&quot; &lt;&lt; buf_.length());
+    debugs(74, DBG_DATA, buf_);
+
+    // Single-pass parse: (provided we have the whole line anyways)
+
+    req.start = 0;
+    req.end = -1;
+    for (SBuf::size_type i = 0; i &lt; buf_.length(); ++i) {
+        // track first and last whitespace (SP only)
+        if (buf_[i] == ' ') {
+            last_whitespace = i;
+            if (first_whitespace &lt; req.start)
+                first_whitespace = i;
+        }
+
+        // track next non-SP/non-HT byte after first_whitespace
+        if (second_word &lt; first_whitespace &amp;&amp; buf_[i] != ' ' &amp;&amp; buf_[i] != '\t') {
+            second_word = i;
+        }
+
+        // locate line terminator
+        if (buf_[i] == '\n') {
+            req.end = i;
+            line_end = i - 1;
+            break;
+        }
+        if (i &lt; buf_.length() - 1 &amp;&amp; buf_[i] == '\r') {
+            if (Config.onoff.relaxed_header_parser) {
+                if (Config.onoff.relaxed_header_parser &lt; 0 &amp;&amp; buf_[i + 1] == '\r')
+                    debugs(74, DBG_IMPORTANT, &quot;WARNING: Invalid HTTP Request: &quot; &lt;&lt;
+                           &quot;Series of carriage-return bytes received prior to line terminator. &quot; &lt;&lt;
+                           &quot;Ignored due to relaxed_header_parser.&quot;);
+
+                // Be tolerant of invalid multiple \r prior to terminal \n
+                if (buf_[i + 1] == '\n' || buf_[i + 1] == '\r')
+                    line_end = i - 1;
+                while (i &lt; buf_.length() - 1 &amp;&amp; buf_[i + 1] == '\r')
+                    ++i;
+
+                if (buf_[i + 1] == '\n') {
+                    req.end = i + 1;
+                    break;
+                }
+            } else {
+                if (buf_[i + 1] == '\n') {
+                    req.end = i + 1;
+                    line_end = i - 1;
+                    break;
+                }
+            }
+
+            // RFC 7230 section 3.1.1 does not prohibit embeded CR like RFC 2616 used to.
+            // However it does explicitly state an exact syntax which omits un-encoded CR
+            // and defines 400 (Bad Request) as the required action when
+            // handed an invalid request-line.
+            request_parse_status = Http::scBadRequest;
+            return -1;
+        }
+    }
+
+    if (req.end == -1) {
+        // DoS protection against long first-line
+        if ((size_t)buf_.length() &gt;= Config.maxRequestHeaderSize) {
+            debugs(33, 5, &quot;Too large request-line&quot;);
+            // RFC 7230 section 3.1.1 mandatory 414 response if URL longer than acceptible.
+            request_parse_status = Http::scUriTooLong;
+            return -1;
+        }
+
+        debugs(74, 5, &quot;Parser: retval 0: from &quot; &lt;&lt; req.start &lt;&lt;
+               &quot;-&gt;&quot; &lt;&lt; req.end &lt;&lt; &quot;: needs more data to complete first line.&quot;);
+        return 0;
+    }
+
+    // NP: we have now seen EOL, more-data (0) cannot occur.
+    //     From here on any failure is -1, success is 1
+
+    // Input Validation:
+
+    // DoS protection against long first-line
+    if ((size_t)(req.end-req.start) &gt;= Config.maxRequestHeaderSize) {
+        debugs(33, 5, &quot;Too large request-line&quot;);
+        request_parse_status = Http::scUriTooLong;
+        return -1;
+    }
+
+    // Process what we now know about the line structure into field offsets
+    // generating HTTP status for any aborts as we go.
+
+    // First non-whitespace = beginning of method
+    if (req.start &gt; line_end) {
+        request_parse_status = Http::scBadRequest;
+        return -1;
+    }
+    req.m_start = req.start;
+
+    // First whitespace = end of method
+    if (first_whitespace &gt; line_end || first_whitespace &lt; req.start) {
+        request_parse_status = Http::scBadRequest; // no method
+        return -1;
+    }
+    req.m_end = first_whitespace - 1;
+    if (req.m_end &lt; req.m_start) {
+        request_parse_status = Http::scBadRequest; // missing URI?
+        return -1;
+    }
+
+    /* Set method_ */
+    const SBuf tmp = buf_.substr(req.m_start, req.m_end - req.m_start + 1);
+    method_ = HttpRequestMethod(tmp);
+
+    // First non-whitespace after first SP = beginning of URL+Version
+    if (second_word &gt; line_end || second_word &lt; req.start) {
+        request_parse_status = Http::scBadRequest; // missing URI
+        return -1;
+    }
+    req.u_start = second_word;
+
+    // RFC 1945: SP and version following URI are optional, marking version 0.9
+    // we identify this by the last whitespace being earlier than URI start
+    if (last_whitespace &lt; second_word &amp;&amp; last_whitespace &gt;= req.start) {
+        msgProtocol_ = Http::ProtocolVersion(0,9);
+        req.u_end = line_end;
+        uri_ = buf_.substr(req.u_start, req.u_end - req.u_start + 1);
+        request_parse_status = Http::scOkay; // HTTP/0.9
+        return 1;
+    } else {
+        // otherwise last whitespace is somewhere after end of URI.
+        req.u_end = last_whitespace;
+        // crop any trailing whitespace in the area we think of as URI
+        for (; req.u_end &gt;= req.u_start &amp;&amp; xisspace(buf_[req.u_end]); --req.u_end);
+    }
+    if (req.u_end &lt; req.u_start) {
+        request_parse_status = Http::scBadRequest; // missing URI
+        return -1;
+    }
+    uri_ = buf_.substr(req.u_start, req.u_end - req.u_start + 1);
+
+    // Last whitespace SP = before start of protocol/version
+    if (last_whitespace &gt;= line_end) {
+        request_parse_status = Http::scBadRequest; // missing version
+        return -1;
+    }
+    req.v_start = last_whitespace + 1;
+    req.v_end = line_end;
+
+    /* RFC 7230 section 2.6 : handle unsupported HTTP major versions cleanly. */
+    if ((req.v_end - req.v_start +1) &lt; (int)Http1magic.length() || !buf_.substr(req.v_start, SBuf::npos).startsWith(Http1magic)) {
+        // non-HTTP/1 protocols not supported / implemented.
+        request_parse_status = Http::scHttpVersionNotSupported;
+        return -1;
+    }
+    // NP: magic octets include the protocol name and major version DIGIT.
+    msgProtocol_.protocol = AnyP::PROTO_HTTP;
+    msgProtocol_.major = 1;
+
+    int i = req.v_start + Http1magic.length() -1;
+
+    // catch missing minor part
+    if (++i &gt; line_end) {
+        request_parse_status = Http::scHttpVersionNotSupported;
+        return -1;
+    }
+    /* next should be one or more digits */
+    if (!isdigit(buf_[i])) {
+        request_parse_status = Http::scHttpVersionNotSupported;
+        return -1;
+    }
+    int min = 0;
+    for (; i &lt;= line_end &amp;&amp; (isdigit(buf_[i])) &amp;&amp; min &lt; 65536; ++i) {
+        min = min * 10;
+        min = min + (buf_[i]) - '0';
+    }
+    // catch too-big values or trailing garbage
+    if (min &gt;= 65536 || i &lt; line_end) {
+        request_parse_status = Http::scHttpVersionNotSupported;
+        return -1;
+    }
+    msgProtocol_.minor = min;
+
+    /*
+     * Rightio - we have all the schtuff. Return true; we've got enough.
+     */
+    request_parse_status = Http::scOkay;
+    return 1;
+}
+
+bool
+Http::One::RequestParser::parse(const SBuf &amp;aBuf)
+{
+    buf_ = aBuf;
+    debugs(74, DBG_DATA, &quot;Parse buf={length=&quot; &lt;&lt; aBuf.length() &lt;&lt; &quot;, data='&quot; &lt;&lt; aBuf &lt;&lt; &quot;'}&quot;);
+
+    // stage 1: locate the request-line
+    if (parsingStage_ == HTTP_PARSE_NONE) {
+        skipGarbageLines();
+
+        // if we hit something before EOS treat it as a message
+        if (!buf_.isEmpty())
+            parsingStage_ = HTTP_PARSE_FIRST;
+        else
+            return false;
+    }
+
+    // stage 2: parse the request-line
+    if (parsingStage_ == HTTP_PARSE_FIRST) {
+        PROF_start(HttpParserParseReqLine);
+        const int retcode = parseRequestFirstLine();
+
+        // first-line (or a look-alike) found successfully.
+        if (retcode &gt; 0) {
+            buf_.consume(firstLineSize()); // first line bytes including CRLF terminator are now done.
+            parsingStage_ = HTTP_PARSE_MIME;
+        }
+
+        debugs(74, 5, &quot;request-line: retval &quot; &lt;&lt; retcode &lt;&lt; &quot;: from &quot; &lt;&lt; req.start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; req.end &lt;&lt;
+               &quot; line={&quot; &lt;&lt; aBuf.length() &lt;&lt; &quot;, data='&quot; &lt;&lt; aBuf &lt;&lt; &quot;'}&quot;);
+        debugs(74, 5, &quot;request-line: method &quot; &lt;&lt; req.m_start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; req.m_end &lt;&lt; &quot; (&quot; &lt;&lt; method_ &lt;&lt; &quot;)&quot;);
+        debugs(74, 5, &quot;request-line: url &quot; &lt;&lt; req.u_start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; req.u_end &lt;&lt; &quot; (&quot; &lt;&lt; uri_ &lt;&lt; &quot;)&quot;);
+        debugs(74, 5, &quot;request-line: proto &quot; &lt;&lt; req.v_start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; req.v_end &lt;&lt; &quot; (&quot; &lt;&lt; msgProtocol_ &lt;&lt; &quot;)&quot;);
+        debugs(74, 5, &quot;Parser: bytes processed=&quot; &lt;&lt; (aBuf.length()-buf_.length()));
+        PROF_stop(HttpParserParseReqLine);
+
+        // syntax errors already
+        if (retcode &lt; 0) {
+            parsingStage_ = HTTP_PARSE_DONE;
+            return false;
+        }
+    }
+
+    // stage 3: locate the mime header block
+    if (parsingStage_ == HTTP_PARSE_MIME) {
+        // HTTP/1.x request-line is valid and parsing completed.
+        if (msgProtocol_.major == 1) {
+            /* NOTE: HTTP/0.9 requests do not have a mime header block.
+             *       So the rest of the code will need to deal with '0'-byte headers
+             *       (ie, none, so don't try parsing em)
+             */
+            int64_t mimeHeaderBytes = 0;
+            // XXX: c_str() reallocates. performance regression.
+            if ((mimeHeaderBytes = headersEnd(buf_.c_str(), buf_.length())) == 0) {
+                if (buf_.length()+firstLineSize() &gt;= Config.maxRequestHeaderSize) {
+                    debugs(33, 5, &quot;Too large request&quot;);
+                    request_parse_status = Http::scRequestHeaderFieldsTooLarge;
+                    parsingStage_ = HTTP_PARSE_DONE;
+                } else
+                    debugs(33, 5, &quot;Incomplete request, waiting for end of headers&quot;);
+                return false;
+            }
+            mimeHeaderBlock_ = buf_.consume(mimeHeaderBytes);
+            debugs(74, 5, &quot;mime header (0-&quot; &lt;&lt; mimeHeaderBytes &lt;&lt; &quot;) {&quot; &lt;&lt; mimeHeaderBlock_ &lt;&lt; &quot;}&quot;);
+
+        } else
+            debugs(33, 3, &quot;Missing HTTP/1.x identifier&quot;);
+
+        // NP: we do not do any further stages here yet so go straight to DONE
+        parsingStage_ = HTTP_PARSE_DONE;
+
+        // Squid could handle these headers, but admin does not want to
+        if (messageHeaderSize() &gt;= Config.maxRequestHeaderSize) {
+            debugs(33, 5, &quot;Too large request&quot;);
+            request_parse_status = Http::scRequestHeaderFieldsTooLarge;
+            return false;
+        }
+    }
+
+    return !needsMoreData();
+}

=== added file 'src/http/one/RequestParser.h'
--- src/http/one/RequestParser.h	1970-01-01 00:00:00 +0000
+++ src/http/one/RequestParser.h	2014-10-15 08:19:57 +0000
@@ -0,0 +1,65 @@
+#ifndef _SQUID_SRC_HTTP_ONE_REQUESTPARSER_H
+#define _SQUID_SRC_HTTP_ONE_REQUESTPARSER_H
+
+#include &quot;http/one/Parser.h&quot;
+#include &quot;http/RequestMethod.h&quot;
+#include &quot;http/StatusCode.h&quot;
+
+namespace Http {
+namespace One {
+
+/** HTTP/1.x protocol request parser
+ *
+ * Works on a raw character I/O buffer and tokenizes the content into
+ * the major CRLF delimited segments of an HTTP/1 request message:
+ *
+ * \item request-line (method, URL, protocol, version)
+ * \item mime-header (set of RFC2616 syntax header fields)
+ */
+class RequestParser : public Http1::Parser
+{
+public:
+    RequestParser();
+    virtual ~RequestParser() {}
+
+    /* Http::One::Parser API */
+    virtual void clear() {*this = RequestParser();}
+    virtual Http1::Parser::size_type firstLineSize() const {return req.end - req.start + 1;}
+    virtual bool parse(const SBuf &amp;aBuf);
+
+    /// the HTTP method if this is a request message
+    const HttpRequestMethod &amp; method() const {return method_;}
+
+    /// the request-line URI if this is a request message, or an empty string.
+    const SBuf &amp;requestUri() const {return uri_;}
+
+    /** HTTP status code to be used on the invalid-request error page.
+     * Http::scNone indicates incomplete parse,
+     * Http::scOkay indicates no error.
+     */
+    Http::StatusCode request_parse_status;
+
+private:
+    void skipGarbageLines();
+    int parseRequestFirstLine();
+
+    /// Offsets for pieces of the (HTTP request) Request-Line as per RFC 7230 section 3.1.1.
+    /// only valid before and during parse stage HTTP_PARSE_FIRST
+    struct request_offsets {
+        int start, end;
+        int m_start, m_end; // method
+        int u_start, u_end; // url
+        int v_start, v_end; // version (full text)
+    } req;
+
+    /// what request method has been found on the first line
+    HttpRequestMethod method_;
+
+    /// raw copy of the original client reqeust-line URI field
+    SBuf uri_;
+};
+
+} // namespace One
+} // namespace Http
+
+#endif /*  _SQUID_SRC_HTTP_ONE_REQUESTPARSER_H */

=== added file 'src/http/one/forward.h'
--- src/http/one/forward.h	1970-01-01 00:00:00 +0000
+++ src/http/one/forward.h	2014-07-30 07:38:25 +0000
@@ -0,0 +1,20 @@
+#ifndef SQUID_SRC_HTTP_ONE_FORWARD_H
+#define SQUID_SRC_HTTP_ONE_FORWARD_H
+
+#include &quot;base/RefCount.h&quot;
+
+namespace Http {
+namespace One {
+
+class Parser;
+typedef RefCount&lt;Http::One::Parser&gt; ParserPointer;
+
+class RequestParser;
+typedef RefCount&lt;Http::One::RequestParser&gt; RequestParserPointer;
+
+} // namespace One
+} // namespace Http
+
+namespace Http1 = Http::One;
+
+#endif /* SQUID_SRC_HTTP_ONE_FORWARD_H */

=== modified file 'src/mgr/ActionParams.cc'
--- src/mgr/ActionParams.cc	2014-09-13 13:59:43 +0000
+++ src/mgr/ActionParams.cc	2014-10-15 06:22:51 +0000
@@ -6,41 +6,41 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 16    Cache Manager API */
 
 #include &quot;squid.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;ipc/TypedMsgHdr.h&quot;
 #include &quot;mgr/ActionParams.h&quot;
 
 Mgr::ActionParams::ActionParams(): httpMethod(Http::METHOD_NONE)
 {
 }
 
 Mgr::ActionParams::ActionParams(const Ipc::TypedMsgHdr &amp;msg)
 {
     msg.getString(httpUri);
 
     String method;
     msg.getString(method);
-    httpMethod = HttpRequestMethod(method.termedBuf(), NULL);
+    httpMethod.HttpRequestMethodXXX(method.termedBuf());
 
     msg.getPod(httpFlags);
     msg.getString(httpOrigin);
 
     msg.getString(actionName);
     msg.getString(userName);
     msg.getString(password);
     queryParams.unpack(msg);
 }
 
 void
 Mgr::ActionParams::pack(Ipc::TypedMsgHdr &amp;msg) const
 {
     msg.putString(httpUri);
     String foo(httpMethod.image().toString());
     msg.putString(foo);
     msg.putPod(httpFlags);
     msg.putString(httpOrigin);
 
     msg.putString(actionName);

=== modified file 'src/mgr/ActionParams.h'
--- src/mgr/ActionParams.h	2014-09-13 13:59:43 +0000
+++ src/mgr/ActionParams.h	2014-09-14 12:23:03 +0000
@@ -1,34 +1,34 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 16    Cache Manager API */
 
 #ifndef SQUID_MGR_ACTION_PARAMS_H
 #define SQUID_MGR_ACTION_PARAMS_H
 
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;ipc/forward.h&quot;
 #include &quot;mgr/QueryParams.h&quot;
 #include &quot;RequestFlags.h&quot;
 
 namespace Mgr
 {
 
 /// Cache Manager Action parameters extracted from the user request
 class ActionParams
 {
 public:
     ActionParams();
 
     explicit ActionParams(const Ipc::TypedMsgHdr &amp;msg); ///&lt; load from msg
     void pack(Ipc::TypedMsgHdr &amp;msg) const; ///&lt; store into msg
 
 public:
     /* details of the client HTTP request that caused the action */
     String httpUri; ///&lt; HTTP request URI
     HttpRequestMethod httpMethod; ///&lt; HTTP request method

=== modified file 'src/mgr/ActionWriter.h'
--- src/mgr/ActionWriter.h	2014-09-13 13:59:43 +0000
+++ src/mgr/ActionWriter.h	2014-09-14 12:23:03 +0000
@@ -1,35 +1,34 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 16    Cache Manager API */
 
 #ifndef SQUID_MGR_ACTION_WRITER_H
 #define SQUID_MGR_ACTION_WRITER_H
 
 #include &quot;comm/forward.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
 #include &quot;mgr/StoreToCommWriter.h&quot;
 
 namespace Mgr
 {
 
 /// Creates Store entry, fills it using action's fillEntry(), and
 /// Comm-writes it using parent StoreToCommWriter.
 class ActionWriter: public StoreToCommWriter
 {
 public:
     ActionWriter(const Action::Pointer &amp;anAction, const Comm::ConnectionPointer &amp;conn);
 
 protected:
     /* AsyncJob API */
     virtual void start();
 
 private:
     Action::Pointer action; ///&lt; action that fills the entry
 
     CBDATA_CLASS2(ActionWriter);

=== modified file 'src/mgr/Filler.h'
--- src/mgr/Filler.h	2014-09-13 13:59:43 +0000
+++ src/mgr/Filler.h	2014-09-14 12:23:03 +0000
@@ -1,35 +1,34 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 16    Cache Manager API */
 
 #ifndef SQUID_MGR_FILLER_H
 #define SQUID_MGR_FILLER_H
 
 #include &quot;comm/forward.h&quot;
-#include &quot;HttpRequestMethod.h&quot;
 #include &quot;mgr/Action.h&quot;
 #include &quot;mgr/StoreToCommWriter.h&quot;
 
 namespace Mgr
 {
 
 /// provides Coordinator with a local cache manager response
 class Filler: public StoreToCommWriter
 {
 public:
     Filler(const Action::Pointer &amp;anAction, const Comm::ConnectionPointer &amp;conn, unsigned int aRequestId);
 
 protected:
     /* AsyncJob API */
     virtual void start();
     virtual void swanSong();
 
 private:
     Action::Pointer action; ///&lt; action that will run() and sendResponse()
     unsigned int requestId; ///&lt; the ID of the Request we are responding to

=== modified file 'src/mime.cc'
--- src/mime.cc	2014-09-13 13:59:43 +0000
+++ src/mime.cc	2014-09-14 12:23:03 +0000
@@ -12,42 +12,40 @@
 #include &quot;disk.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpHdrCc.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;internal.h&quot;
 #include &quot;Mem.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mime.h&quot;
 #include &quot;RequestFlags.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;StoreClient.h&quot;
 
 #if HAVE_SYS_STAT_H
 #include &lt;sys/stat.h&gt;
 #endif
 
-#define GET_HDR_SZ 1024
-
 /* forward declarations */
 static void mimeFreeMemory(void);
 static char const *mimeGetIcon(const char *fn);
 
 class MimeIcon : public StoreClient
 {
 public:
     explicit MimeIcon(const char *aName);
     ~MimeIcon();
     void setName(char const *);
     char const * getName() const;
     void load();
     void created(StoreEntry *newEntry);
     MEMPROXY_CLASS(MimeIcon);
 
 private:
     const char *icon_;
     char *url_;
 };
 MEMPROXY_CLASS_INLINE(MimeIcon);

=== modified file 'src/mime_header.cc'
--- src/mime_header.cc	2014-09-13 13:59:43 +0000
+++ src/mime_header.cc	2014-09-14 12:23:03 +0000
@@ -1,116 +1,34 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 25    MiME Header Parsing */
 
 #include &quot;squid.h&quot;
-
-#define GET_HDR_SZ 1024
 #include &quot;Debug.h&quot;
 #include &quot;profiler/Profiler.h&quot;
 
-/*
- * returns a pointer to a field-value of the first matching field-name where
- * field-value matches prefix if any
- */
-char *
-mime_get_header_field(const char *mime, const char *name, const char *prefix)
-{
-    LOCAL_ARRAY(char, header, GET_HDR_SZ);
-    const char *p = NULL;
-    char *q = NULL;
-    char got = 0;
-    const int namelen = name ? strlen(name) : 0;
-    const int preflen = prefix ? strlen(prefix) : 0;
-    int l;
-
-    if (NULL == mime)
-        return NULL;
-
-    assert(NULL != name);
-
-    debugs(25, 5, &quot;mime_get_header: looking for '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;);
-
-    for (p = mime; *p; p += strcspn(p, &quot;\n\r&quot;)) {
-        if (strcmp(p, &quot;\r\n\r\n&quot;) == 0 || strcmp(p, &quot;\n\n&quot;) == 0)
-            return NULL;
-
-        while (xisspace(*p))
-            ++p;
-
-        if (strncasecmp(p, name, namelen))
-            continue;
-
-        if (!xisspace(p[namelen]) &amp;&amp; p[namelen] != ':')
-            continue;
-
-        l = strcspn(p, &quot;\n\r&quot;) + 1;
-
-        if (l &gt; GET_HDR_SZ)
-            l = GET_HDR_SZ;
-
-        xstrncpy(header, p, l);
-
-        debugs(25, 5, &quot;mime_get_header: checking '&quot; &lt;&lt; header &lt;&lt; &quot;'&quot;);
-
-        q = header;
-
-        q += namelen;
-
-        if (*q == ':') {
-            ++q;
-            got = 1;
-        }
-
-        while (xisspace(*q)) {
-            ++q;
-            got = 1;
-        }
-
-        if (got &amp;&amp; prefix) {
-            /* we could process list entries here if we had strcasestr(). */
-            /* make sure we did not match a part of another field-value */
-            got = !strncasecmp(q, prefix, preflen) &amp;&amp; !xisalpha(q[preflen]);
-        }
-
-        if (got) {
-            debugs(25, 5, &quot;mime_get_header: returning '&quot; &lt;&lt; q &lt;&lt; &quot;'&quot;);
-            return q;
-        }
-    }
-
-    return NULL;
-}
-
-/* returns a pointer to a field-value of the first matching field-name */
-char *
-mime_get_header(const char *mime, const char *name)
-{
-    return mime_get_header_field(mime, name, NULL);
-}
-
 size_t
 headersEnd(const char *mime, size_t l)
 {
     size_t e = 0;
     int state = 1;
 
     PROF_start(headersEnd);
 
     while (e &lt; l &amp;&amp; state &lt; 3) {
         switch (state) {
 
         case 0:
 
             if ('\n' == mime[e])
                 state = 1;
 
             break;
 
         case 1:
             if ('\r' == mime[e])

=== modified file 'src/mime_header.h'
--- src/mime_header.h	2014-09-13 13:59:43 +0000
+++ src/mime_header.h	2014-09-14 12:23:03 +0000
@@ -1,18 +1,16 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 25    MiME Header Parsing */
 
 #ifndef SQUID_MIME_HEADER_H_
 #define SQUID_MIME_HEADER_H_
 
-char *mime_get_header(const char *mime, const char *header);
-char *mime_get_header_field(const char *mime, const char *name, const char *prefix);
 size_t headersEnd(const char *, size_t);
 
 #endif /* SQUID_MIME_HEADER_H_ */

=== modified file 'src/servers/FtpServer.cc'
--- src/servers/FtpServer.cc	2014-09-29 05:13:17 +0000
+++ src/servers/FtpServer.cc	2014-10-05 10:43:33 +0000
@@ -7,40 +7,41 @@
  */
 
 /* DEBUG: section 33    Transfer protocol servers */
 
 #include &quot;squid.h&quot;
 #include &quot;base/CharacterSet.h&quot;
 #include &quot;base/RefCount.h&quot;
 #include &quot;base/Subscription.h&quot;
 #include &quot;client_side_reply.h&quot;
 #include &quot;client_side_request.h&quot;
 #include &quot;clientStream.h&quot;
 #include &quot;comm/ConnOpener.h&quot;
 #include &quot;comm/Read.h&quot;
 #include &quot;comm/TcpAcceptor.h&quot;
 #include &quot;comm/Write.h&quot;
 #include &quot;errorpage.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;ftp/Elements.h&quot;
 #include &quot;ftp/Parsing.h&quot;
 #include &quot;globals.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
 #include &quot;HttpHdrCc.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;ipc/FdNotes.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 #include &quot;servers/forward.h&quot;
 #include &quot;servers/FtpServer.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;StatCounters.h&quot;
 #include &quot;tools.h&quot;
 
 #include &lt;set&gt;
 #include &lt;map&gt;
 
 CBDATA_NAMESPACED_CLASS_INIT(Ftp, Server);
 
 namespace Ftp
 {
 static void PrintReply(MemBuf &amp;mb, const HttpReply *reply, const char *const prefix = &quot;&quot;);
 static bool SupportedCommand(const SBuf &amp;name);
 static bool CommandHasPathParameter(const SBuf &amp;cmd);
@@ -123,49 +124,48 @@
 {
     // zero pipelinePrefetchMax() ensures that there is only parsed request
     ClientSocketContext::Pointer context = getCurrentContext();
     Must(context != NULL);
     Must(getConcurrentRequestCount() == 1);
 
     ClientHttpRequest *const http = context-&gt;http;
     assert(http != NULL);
 
     HttpRequest *const request = http-&gt;request;
     Must(http-&gt;storeEntry() || request);
     const bool mayForward = !http-&gt;storeEntry() &amp;&amp; handleRequest(request);
 
     if (http-&gt;storeEntry() != NULL) {
         debugs(33, 4, &quot;got an immediate response&quot;);
         clientSetKeepaliveFlag(http);
         context-&gt;pullData();
     } else if (mayForward) {
         debugs(33, 4, &quot;forwarding request to server side&quot;);
         assert(http-&gt;storeEntry() == NULL);
-        clientProcessRequest(this, NULL /*parser*/, context.getRaw(),
-                             request-&gt;method, request-&gt;http_ver);
+        clientProcessRequest(this, Http1::RequestParserPointer(), context.getRaw());
     } else {
         debugs(33, 4, &quot;will resume processing later&quot;);
     }
 }
 
 void
-Ftp::Server::processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &amp;)
+Ftp::Server::processParsedRequest(ClientSocketContext *context)
 {
     Must(getConcurrentRequestCount() == 1);
 
     // Process FTP request asynchronously to make sure FTP
     // data connection accept callback is fired first.
     CallJobHere(33, 4, CbcPointer&lt;Server&gt;(this),
                 Ftp::Server, doProcessRequest);
 }
 
 /// imports more upload data from the data connection
 void
 Ftp::Server::readUploadData(const CommIoCbParams &amp;io)
 {
     debugs(33, 5, io.conn &lt;&lt; &quot; size &quot; &lt;&lt; io.size);
     Must(reader != NULL);
     reader = NULL;
 
     assert(Comm::IsConnOpen(dataConn));
     assert(io.conn-&gt;fd == dataConn-&gt;fd);
 
@@ -601,41 +601,41 @@
         // no default so that a compiler can check that we have covered all cases
     }
 
     ClientSocketContext *context = abortRequestParsing(errUri);
     clientStreamNode *node = context-&gt;getClientReplyContext();
     Must(node);
     clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
     Must(repContext);
 
     // We cannot relay FTP scode/reason via HTTP-specific ErrorState.
     // TODO: When/if ErrorState can handle native FTP errors, use it instead.
     HttpReply *reply = Ftp::HttpReplyWrapper(scode, reason, Http::scBadRequest, -1);
     repContext-&gt;setReplyToReply(reply);
     return context;
 }
 
 /// Parses a single FTP request on the control connection.
 /// Returns a new ClientSocketContext on valid requests and all errors.
 /// Returns NULL on incomplete requests that may still succeed given more data.
 ClientSocketContext *
-Ftp::Server::parseOneRequest(Http::ProtocolVersion &amp;ver)
+Ftp::Server::parseOneRequest()
 {
     flags.readMore = false; // common for all but one case below
 
     // OWS &lt;command&gt; [ RWS &lt;parameter&gt; ] OWS LF
 
     // InlineSpaceChars are isspace(3) or RFC 959 Section 3.1.1.5.2, except
     // for the LF character that we must exclude here (but see FullWhiteSpace).
     static const char * const InlineSpaceChars = &quot; \f\r\t\v&quot;;
     static const CharacterSet InlineSpace = CharacterSet(&quot;Ftp::Inline&quot;, InlineSpaceChars);
     static const CharacterSet FullWhiteSpace = (InlineSpace + CharacterSet::LF).rename(&quot;Ftp::FWS&quot;);
     static const CharacterSet CommandChars = FullWhiteSpace.complement(&quot;Ftp::Command&quot;);
     static const CharacterSet TailChars = CharacterSet::LF.complement(&quot;Ftp::Tail&quot;);
 
     // This set is used to ignore empty commands without allowing an attacker
     // to keep us endlessly busy by feeding us whitespace or empty commands.
     static const CharacterSet &amp;LeadingSpace = FullWhiteSpace;
 
     SBuf cmd;
     SBuf params;
 
@@ -702,43 +702,42 @@
 
     if (!Ftp::SupportedCommand(cmd))
         return earlyError(eekUnsupportedCommand);
 
     const HttpRequestMethod method =
         cmd == cmdAppe() || cmd == cmdStor() || cmd == cmdStou() ?
         Http::METHOD_PUT : Http::METHOD_GET;
 
     const SBuf *path = (params.length() &amp;&amp; CommandHasPathParameter(cmd)) ?
                        &amp;params : NULL;
     calcUri(path);
     char *newUri = xstrdup(uri.c_str());
     HttpRequest *const request = HttpRequest::CreateFromUrlAndMethod(newUri, method);
     if (!request) {
         debugs(33, 5, &quot;Invalid FTP URL: &quot; &lt;&lt; uri);
         uri.clear();
         safe_free(newUri);
         return earlyError(eekInvalidUri);
     }
 
-    ver = Http::ProtocolVersion(Ftp::ProtocolVersion().major, Ftp::ProtocolVersion().minor);
     request-&gt;flags.ftpNative = true;
-    request-&gt;http_ver = ver;
+    request-&gt;http_ver = Http::ProtocolVersion(Ftp::ProtocolVersion().major, Ftp::ProtocolVersion().minor);
 
     // Our fake Request-URIs are not distinctive enough for caching to work
     request-&gt;flags.cachable = false; // XXX: reset later by maybeCacheable()
     request-&gt;flags.noCache = true;
 
     request-&gt;header.putStr(HDR_FTP_COMMAND, cmd.c_str());
     request-&gt;header.putStr(HDR_FTP_ARGUMENTS, params.c_str()); // may be &quot;&quot;
     if (method == Http::METHOD_PUT) {
         request-&gt;header.putStr(HDR_EXPECT, &quot;100-continue&quot;);
         request-&gt;header.putStr(HDR_TRANSFER_ENCODING, &quot;chunked&quot;);
     }
 
     ClientHttpRequest *const http = new ClientHttpRequest(this);
     http-&gt;request = request;
     HTTPMSGLOCK(http-&gt;request);
     http-&gt;req_sz = tok.parsedSize();
     http-&gt;uri = newUri;
 
     ClientSocketContext *const result =
         new ClientSocketContext(clientConnection, http);

=== modified file 'src/servers/FtpServer.h'
--- src/servers/FtpServer.h	2014-09-13 13:59:43 +0000
+++ src/servers/FtpServer.h	2014-09-14 12:23:03 +0000
@@ -58,42 +58,42 @@
 
     // This is a pointer in hope to minimize future changes when MasterState
     // becomes a part of MasterXaction. Guaranteed not to be nil.
     MasterState::Pointer master; ///&lt; info shared among our FTP client and server jobs
 
 protected:
     friend void StartListening();
 
     // errors detected before it is possible to create an HTTP request wrapper
     typedef enum {
         eekHugeRequest,
         eekMissingLogin,
         eekMissingUsername,
         eekMissingHost,
         eekUnsupportedCommand,
         eekInvalidUri,
         eekMalformedCommand
     } EarlyErrorKind;
 
     /* ConnStateData API */
-    virtual ClientSocketContext *parseOneRequest(Http::ProtocolVersion &amp;ver);
-    virtual void processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &amp;ver);
+    virtual ClientSocketContext *parseOneRequest();
+    virtual void processParsedRequest(ClientSocketContext *context);
     virtual void notePeerConnection(Comm::ConnectionPointer conn);
     virtual void clientPinnedConnectionClosed(const CommCloseCbParams &amp;io);
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData);
     virtual int pipelinePrefetchMax() const;
     virtual void writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &amp;call);
     virtual time_t idleTimeout() const;
 
     /* BodyPipe API */
     virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
     virtual void noteBodyConsumerAborted(BodyPipe::Pointer ptr);
 
     /* AsyncJob API */
     virtual void start();
 
     /* Comm callbacks */
     static void AcceptCtrlConnection(const CommAcceptCbParams &amp;params);
     void acceptDataConnection(const CommAcceptCbParams &amp;params);
     void readUploadData(const CommIoCbParams &amp;io);
     void wroteEarlyReply(const CommIoCbParams &amp;io);
     void wroteReply(const CommIoCbParams &amp;io);

=== modified file 'src/servers/HttpServer.cc'
--- src/servers/HttpServer.cc	2014-09-13 13:59:43 +0000
+++ src/servers/HttpServer.cc	2014-09-14 12:23:03 +0000
@@ -1,71 +1,72 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 33    Client-side Routines */
 
 #include &quot;squid.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;client_side_request.h&quot;
 #include &quot;comm/Write.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
 #include &quot;profiler/Profiler.h&quot;
 #include &quot;servers/forward.h&quot;
 #include &quot;SquidConfig.h&quot;
 
 namespace Http
 {
 
 /// Manages a connection from an HTTP client.
 class Server: public ConnStateData
 {
 public:
     Server(const MasterXaction::Pointer &amp;xact, const bool beHttpsServer);
     virtual ~Server() {}
 
     void readSomeHttpData();
 
 protected:
     /* ConnStateData API */
-    virtual ClientSocketContext *parseOneRequest(Http::ProtocolVersion &amp;ver);
-    virtual void processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &amp;ver);
+    virtual ClientSocketContext *parseOneRequest();
+    virtual void processParsedRequest(ClientSocketContext *context);
     virtual void handleReply(HttpReply *rep, StoreIOBuffer receivedData);
     virtual void writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &amp;call);
     virtual time_t idleTimeout() const;
 
     /* BodyPipe API */
     virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
     virtual void noteBodyConsumerAborted(BodyPipe::Pointer);
 
     /* AsyncJob API */
     virtual void start();
 
 private:
     void processHttpRequest(ClientSocketContext *const context);
     void handleHttpRequestData();
 
-    HttpParser parser_;
+    Http1::RequestParserPointer parser_;
     HttpRequestMethod method_; ///&lt; parsed HTTP method
 
     /// temporary hack to avoid creating a true HttpsServer class
     const bool isHttpsServer;
 
     CBDATA_CLASS2(Server);
 };
 
 } // namespace Http
 
 CBDATA_NAMESPACED_CLASS_INIT(Http, Server);
 
 Http::Server::Server(const MasterXaction::Pointer &amp;xact, bool beHttpsServer):
         AsyncJob(&quot;Http::Server&quot;),
         ConnStateData(xact),
         isHttpsServer(beHttpsServer)
 {
 }
 
 time_t
@@ -92,54 +93,61 @@
     AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
                                       TimeoutDialer, this, Http::Server::requestTimeout);
     commSetConnTimeout(clientConnection, Config.Timeout.request, timeoutCall);
     readSomeData();
 }
 
 void
 Http::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 {
     if (!handleRequestBodyData())
         return;
 
     // too late to read more body
     if (!isOpen() || stoppedReceiving())
         return;
 
     readSomeData();
 }
 
 ClientSocketContext *
-Http::Server::parseOneRequest(Http::ProtocolVersion &amp;ver)
+Http::Server::parseOneRequest()
 {
-    ClientSocketContext *context = NULL;
     PROF_start(HttpServer_parseOneRequest);
-    HttpParserInit(&amp;parser_, in.buf.c_str(), in.buf.length());
-    context = parseHttpRequest(this, &amp;parser_, &amp;method_, &amp;ver);
+
+    // parser is incremental. Generate new parser state if we,
+    // a) dont have one already
+    // b) have completed the previous request parsing already
+    if (!parser_ || !parser_-&gt;needsMoreData())
+        parser_ = new Http1::RequestParser();
+
+    /* Process request */
+    ClientSocketContext *context = parseHttpRequest(this, parser_);
+
     PROF_stop(HttpServer_parseOneRequest);
     return context;
 }
 
 void
-Http::Server::processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &amp;ver)
+Http::Server::processParsedRequest(ClientSocketContext *context)
 {
-    clientProcessRequest(this, &amp;parser_, context, method_, ver);
+    clientProcessRequest(this, parser_, context);
 }
 
 void
 Http::Server::noteBodyConsumerAborted(BodyPipe::Pointer ptr)
 {
     ConnStateData::noteBodyConsumerAborted(ptr);
     stopReceiving(&quot;virgin request body consumer aborted&quot;); // closes ASAP
 }
 
 void
 Http::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
 {
     // the caller guarantees that we are dealing with the current context only
     ClientSocketContext::Pointer context = getCurrentContext();
     Must(context != NULL);
     const ClientHttpRequest *http = context-&gt;http;
     Must(http != NULL);
 
     // After sending Transfer-Encoding: chunked (at least), always send
     // the last-chunk if there was no error, ignoring responseFinishedOrFailed.

=== renamed file 'src/tests/testHttpParser.cc' =&gt; 'src/tests/testHttp1Parser.cc'
--- src/tests/testHttpParser.cc	2014-09-12 23:00:48 +0000
+++ src/tests/testHttp1Parser.cc	2014-10-15 10:14:29 +0000
@@ -1,1108 +1,1442 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 
 #include &lt;cppunit/TestAssert.h&gt;
 
-#include &quot;HttpParser.h&quot;
+#define private public
+#define protected public
+
+#include &quot;testHttp1Parser.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;Mem.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;SquidConfig.h&quot;
-#include &quot;testHttpParser.h&quot;
+#include &quot;testHttp1Parser.h&quot;
 
-CPPUNIT_TEST_SUITE_REGISTRATION( testHttpParser );
+CPPUNIT_TEST_SUITE_REGISTRATION( testHttp1Parser );
 
 void
-testHttpParser::globalSetup()
+testHttp1Parser::globalSetup()
 {
     static bool setup_done = false;
     if (setup_done)
         return;
 
     Mem::Init();
     setup_done = true;
+
+    // default to strict parser. set for loose parsing specifically where behaviour differs.
+    Config.onoff.relaxed_header_parser = 0;
+
+    Config.maxRequestHeaderSize = 1024; // XXX: unit test the RequestParser handling of this limit
+}
+
+struct resultSet {
+    bool parsed;
+    bool needsMore;
+    Http1::ParseState parserState;
+    Http::StatusCode status;
+    int msgStart;
+    int msgEnd;
+    SBuf::size_type suffixSz;
+    int methodStart;
+    int methodEnd;
+    HttpRequestMethod method;
+    int uriStart;
+    int uriEnd;
+    const char *uri;
+    int versionStart;
+    int versionEnd;
+    AnyP::ProtocolVersion version;
+};
+
+static void
+testResults(int line, const SBuf &amp;input, Http1::RequestParser &amp;output, struct resultSet &amp;expect)
+{
+#if WHEN_TEST_DEBUG_IS_NEEDED
+    printf(&quot;TEST @%d, in=%u: &quot; SQUIDSBUFPH &quot;\n&quot;, line, input.length(), SQUIDSBUFPRINT(input));
+#endif
+
+    CPPUNIT_ASSERT_EQUAL(expect.parsed, output.parse(input));
+    CPPUNIT_ASSERT_EQUAL(expect.needsMore, output.needsMoreData());
+    if (output.needsMoreData())
+        CPPUNIT_ASSERT_EQUAL(expect.parserState, output.parsingStage_);
+    CPPUNIT_ASSERT_EQUAL(expect.status, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(expect.msgStart, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(expect.msgEnd, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(expect.suffixSz, output.buf_.length());
+    CPPUNIT_ASSERT_EQUAL(expect.methodStart, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(expect.methodEnd, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(expect.method, output.method_);
+    CPPUNIT_ASSERT_EQUAL(expect.uriStart, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(expect.uriEnd, output.req.u_end);
+    if (expect.uri != NULL)
+        CPPUNIT_ASSERT_EQUAL(0, output.uri_.cmp(expect.uri));
+    CPPUNIT_ASSERT_EQUAL(expect.versionStart, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(expect.versionEnd, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(expect.version, output.msgProtocol_);
 }
 
 void
-testHttpParser::testParseRequestLineProtocols()
+testHttp1Parser::testParserConstruct()
+{
+    // whether the constructor works
+    {
+        Http1::RequestParser output;
+        CPPUNIT_ASSERT_EQUAL(true, output.needsMoreData());
+        CPPUNIT_ASSERT_EQUAL(Http1::HTTP_PARSE_NONE, output.parsingStage_);
+        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status); // XXX: clear() not being called.
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.start);
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+        CPPUNIT_ASSERT(output.buf_.isEmpty());
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+        CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), output.method_);
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+        CPPUNIT_ASSERT(output.uri_.isEmpty());
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+        CPPUNIT_ASSERT_EQUAL(AnyP::ProtocolVersion(), output.msgProtocol_);
+    }
+
+    // whether new() works
+    {
+        Http1::RequestParser *output = new Http1::RequestParser;
+        CPPUNIT_ASSERT_EQUAL(true, output-&gt;needsMoreData());
+        CPPUNIT_ASSERT_EQUAL(Http1::HTTP_PARSE_NONE, output-&gt;parsingStage_);
+        CPPUNIT_ASSERT_EQUAL(Http::scNone, output-&gt;request_parse_status);
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.start);
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.end);
+        CPPUNIT_ASSERT(output-&gt;buf_.isEmpty());
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.m_start);
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.m_end);
+        CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), output-&gt;method_);
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.u_start);
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.u_end);
+        CPPUNIT_ASSERT(output-&gt;uri_.isEmpty());
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.v_start);
+        CPPUNIT_ASSERT_EQUAL(-1, output-&gt;req.v_end);
+        CPPUNIT_ASSERT_EQUAL(AnyP::ProtocolVersion(), output-&gt;msgProtocol_);
+        delete output;
+    }
+}
+
+void
+testHttp1Parser::testParseRequestLineProtocols()
 {
     // ensure MemPools etc exist
     globalSetup();
 
-    MemBuf input;
-    HttpParser output;
-    input.init();
+    SBuf input;
+    Http1::RequestParser output;
 
     // TEST: Do we comply with RFC 1945 section 5.1 ?
     // TEST: Do we comply with RFC 2616 section 5.1 ?
 
     // RFC 1945 : HTTP/0.9 simple-request
     {
         input.append(&quot;GET /\r\n&quot;, 7);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0,memcmp(&quot;GET /\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start], (output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start], (output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // RFC 1945 : invalid HTTP/0.9 simple-request (only GET is valid)
-#if 0
+#if WHEN_RFC_COMPLIANT
     {
         input.append(&quot;POST /\r\n&quot;, 7);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0,memcmp(&quot;GET /\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start], (output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start], (output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 3,
+            .method = HttpRequestMethod(Http::METHOD_POST),
+            .uriStart = 5,
+            .uriEnd = 5,
+            .uri = &quot;/&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 #endif
-
     // RFC 1945 and 2616 : HTTP/1.0 request
     {
         input.append(&quot;GET / HTTP/1.0\r\n&quot;, 16);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.0\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.0&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,0)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // RFC 2616 : HTTP/1.1 request
     {
         input.append(&quot;GET / HTTP/1.1\r\n&quot;, 16);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.1\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // RFC 2616 : future version full-request
-    {    input.append(&quot;GET / HTTP/1.2\r\n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.2\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.2&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.v_min);
-        input.reset();
+    {
+        input.append(&quot;GET / HTTP/1.2\r\n&quot;, 16);
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,2)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    // RFC 2616 : future version full-request
+    // RFC 7230 : future versions do not use request-line syntax
     {
-        // XXX: IETF HTTPbis WG has made this two-digits format invalid.
         input.append(&quot;GET / HTTP/10.12\r\n&quot;, 18);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/10.12\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(15, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/10.12&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(10, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 15,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    // This stage of the parser does not yet accept non-HTTP protocol names.
+    // unknown non-HTTP protocol names
     {
-        // violations mode treats them as HTTP/0.9 requests!
         input.append(&quot;GET / FOO/1.0\n&quot;, 14);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-#if USE_HTTP_VIOLATIONS
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/ FOO/1.0&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-#else
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-#endif
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / FOO/1.0\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;FOO/1.0&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 12,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // no version
     {
         input.append(&quot;GET / HTTP/\n&quot;, 12);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(10, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 10,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // no major version
     {
         input.append(&quot;GET / HTTP/.1\n&quot;, 14);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 12,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // no version dot
     {
         input.append(&quot;GET / HTTP/11\n&quot;, 14);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/11\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/11&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 12,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // negative major version (bug 3062)
     {
         input.append(&quot;GET / HTTP/-999999.1\n&quot;, 21);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/-999999.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/-999999.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 19,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // no minor version
     {
         input.append(&quot;GET / HTTP/1.\n&quot;, 14);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 12,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,0)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // negative major version (bug 3062 corollary)
     {
         input.append(&quot;GET / HTTP/1.-999999\n&quot;, 21);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.-999999\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.-999999&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 19,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,0)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 }
 
 void
-testHttpParser::testParseRequestLineStrange()
+testHttp1Parser::testParseRequestLineStrange()
 {
     // ensure MemPools etc exist
     globalSetup();
 
-    MemBuf input;
-    HttpParser output;
-    input.init();
+    SBuf input;
+    Http1::RequestParser output;
 
     // space padded URL
     {
         input.append(&quot;GET  /     HTTP/1.1\r\n&quot;, 21);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET  /     HTTP/1.1\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(11, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(18, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 5,
+            .uriEnd = 5,
+            .uri = &quot;/&quot;,
+            .versionStart = 11,
+            .versionEnd = 18,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // whitespace inside URI. (nasty but happens)
+    // XXX: depends on tolerant parser...
     {
         input.append(&quot;GET /fo o/ HTTP/1.1\n&quot;, 20);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0,memcmp(&quot;GET /fo o/ HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/fo o/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(11, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(18, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 9,
+            .uri = &quot;/fo o/&quot;,
+            .versionStart = 11,
+            .versionEnd = 18,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // additional data in buffer
     {
         input.append(&quot;GET /     HTTP/1.1\nboo!&quot;, 23);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-5, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET /     HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end); // strangeness generated by following RFC
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(10, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(17, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-5,
+            .suffixSz = 4, // strlen(&quot;boo!&quot;)
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 10,
+            .versionEnd = 17,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 }
 
 void
-testHttpParser::testParseRequestLineTerminators()
+testHttp1Parser::testParseRequestLineTerminators()
 {
     // ensure MemPools etc exist
     globalSetup();
 
-    MemBuf input;
-    HttpParser output;
-    input.init();
+    SBuf input;
+    Http1::RequestParser output;
 
     // alternative EOL sequence: NL-only
     {
         input.append(&quot;GET / HTTP/1.1\n&quot;, 15);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // alternative EOL sequence: double-NL-only
     {
         input.append(&quot;GET / HTTP/1.1\n\n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-2, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-2,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    // RELAXED alternative EOL sequence: multi-CR-NL
+    // alternative EOL sequence: multi-CR-NL
     {
         input.append(&quot;GET / HTTP/1.1\r\r\r\n&quot;, 18);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        Config.onoff.relaxed_header_parser = 1;
         // Being tolerant we can ignore and elide these apparently benign CR
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.1\r\r\r\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
-    }
+        Config.onoff.relaxed_header_parser = 1;
+        struct resultSet expectRelaxed = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectRelaxed);
 
-    // STRICT alternative EOL sequence: multi-CR-NL
-    {
-        input.append(&quot;GET / HTTP/1.1\r\r\r\n&quot;, 18);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
         // strict mode treats these as several bare-CR in the request line which is explicitly invalid.
         Config.onoff.relaxed_header_parser = 0;
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = -1,
+            .suffixSz = input.length(),
+            .methodStart =-1,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
+        input.clear();
     }
 
     // space padded version
     {
         // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
         // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
         input.append(&quot;GET / HTTP/1.1 \n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.1 \n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(13, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/ HTTP/1.1&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
-    }
-
-    // incomplete line at various positions
-    {
-        input.append(&quot;GET&quot;, 3);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
-
-        input.append(&quot;GET &quot;, 4);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
-
-        input.append(&quot;GET / HT&quot;, 8);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
-
-        input.append(&quot;GET / HTTP/1.1&quot;, 14);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 13,
+            .uri = &quot;/ HTTP/1.1&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 }
 
 void
-testHttpParser::testParseRequestLineMethods()
+testHttp1Parser::testParseRequestLineMethods()
 {
     // ensure MemPools etc exist
     globalSetup();
 
-    MemBuf input;
-    HttpParser output;
-    input.init();
+    SBuf input;
+    Http1::RequestParser output;
 
     // RFC 2616 : . method
     {
         input.append(&quot;. / HTTP/1.1\n&quot;, 13);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;. / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;.&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(2, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(11, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 0,
+            .method = HttpRequestMethod(SBuf(&quot;.&quot;)),
+            .uriStart = 2,
+            .uriEnd = 2,
+            .uri = &quot;/&quot;,
+            .versionStart = 4,
+            .versionEnd = 11,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // OPTIONS with * URL
     {
         input.append(&quot;OPTIONS * HTTP/1.1\n&quot;, 19);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;OPTIONS * HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(6, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;OPTIONS&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(8, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(8, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;*&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(10, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(17, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 6,
+            .method = HttpRequestMethod(Http::METHOD_OPTIONS),
+            .uriStart = 8,
+            .uriEnd = 8,
+            .uri = &quot;*&quot;,
+            .versionStart = 10,
+            .versionEnd = 17,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // unknown method
     {
         input.append(&quot;HELLOWORLD / HTTP/1.1\n&quot;, 22);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HELLOWORLD / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HELLOWORLD&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(11, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(11, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(13, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(20, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 9,
+            .method = HttpRequestMethod(SBuf(&quot;HELLOWORLD&quot;)),
+            .uriStart = 11,
+            .uriEnd = 11,
+            .uri = &quot;/&quot;,
+            .versionStart = 13,
+            .versionEnd = 20,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // method-only
     {
         input.append(&quot;A\n&quot;, 2);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;A\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    input.append(&quot;GET\n&quot;, 4);
-    {
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+    {
+        input.append(&quot;GET\n&quot;, 4);
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    // RELAXED space padded method (in strict mode SP is reserved so invalid as a method byte)
+    // space padded method (in strict mode SP is reserved so invalid as a method byte)
     {
         input.append(&quot; GET / HTTP/1.1\n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
+        // RELAXED mode Squid custom tolerance ignores SP
+#if USE_HTTP_VIOLATIONS
         Config.onoff.relaxed_header_parser = 1;
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
-    }
+        struct resultSet expectRelaxed = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0, // garbage collection consumes the SP
+            .msgEnd = (int)input.length()-2,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectRelaxed);
+#endif
 
-    // STRICT space padded method (in strict mode SP is reserved so invalid as a method byte)
-    {
-        input.append(&quot; GET / HTTP/1.1\n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
+        // STRICT mode obeys RFC syntax
         Config.onoff.relaxed_header_parser = 0;
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot; GET / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
+        input.clear();
+    }
+
+    // RFC 2616 defined tolerance: ignore empty line(s) prefix on messages
+#if WHEN_RFC_COMPLIANT
+    {
+        input.append(&quot;\r\n\r\n\nGET / HTTP/1.1\r\n&quot;, 21);
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 5,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 5,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 4,
+            .uri = &quot;/&quot;,
+            .versionStart = 6,
+            .versionEnd = 13,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
+#endif
 
     // tab padded method (NP: tab is not SP so treated as any other binary)
     {
         input.append(&quot;\tGET / HTTP/1.1\n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;\tGET / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;\tGET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+#if WHEN_RFC_COMPLIANT
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = -1,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+#else // XXX: currently broken
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0, // garbage collection consumes the SP
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 3,
+            .method = HttpRequestMethod(SBuf(&quot;\tGET&quot;)),
+            .uriStart = 5,
+            .uriEnd = 5,
+            .uri = &quot;/&quot;,
+            .versionStart = 7,
+            .versionEnd = 14,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+#endif
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 }
 
 void
-testHttpParser::testParseRequestLineInvalid()
+testHttp1Parser::testParseRequestLineInvalid()
 {
     // ensure MemPools etc exist
     globalSetup();
 
-    MemBuf input;
-    HttpParser output;
-    input.init();
+    SBuf input;
+    Http1::RequestParser output;
 
     // no method (but in a form which is ambiguous with HTTP/0.9 simple-request)
     {
-        // XXX: Bug: HTTP/0.9 requires method to be &quot;GET&quot;
+        // XXX: HTTP/0.9 requires method to be &quot;GET&quot;
         input.append(&quot;/ HTTP/1.0\n&quot;, 11);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/ HTTP/1.0\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(2, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.0&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 0,
+            .method = HttpRequestMethod(SBuf(&quot;/&quot;)),
+            .uriStart = 2,
+            .uriEnd = 9,
+            .uri = &quot;HTTP/1.0&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    // RELAXED no method (an invalid format)
+    // no method (an invalid format)
     {
         input.append(&quot; / HTTP/1.0\n&quot;, 12);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
+
+        // XXX: squid custom tolerance consumes initial SP.
         Config.onoff.relaxed_header_parser = 1;
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/ HTTP/1.0\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(3, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(10, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.0&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-        input.reset();
-    }
+        struct resultSet expectRelaxed = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-2,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 0,
+            .method = HttpRequestMethod(SBuf(&quot;/&quot;)),
+            .uriStart = 2,
+            .uriEnd = 9,
+            .uri = &quot;HTTP/1.0&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectRelaxed);
 
-    // STRICT no method (an invalid format)
-    {
-        input.append(&quot; / HTTP/1.0\n&quot;, 12);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
+        // STRICT detect as invalid
         Config.onoff.relaxed_header_parser = 0;
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot; / HTTP/1.0\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+#if WHEN_RFC_COMPLIANT
+        // XXX: except Squid does not
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+#else
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+#endif
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
+        input.clear();
     }
 
-    // binary code in method (strange but ...)
+    // binary code in method (invalid)
     {
         input.append(&quot;GET\x0B / HTTP/1.1\n&quot;, 16);
-        //printf(&quot;TEST: %d-%d/%d '%.*s'\n&quot;, output.req.start, output.req.end, input.contentSize(), 16, input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET\x0B / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET\x0B&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+#if WHEN_RFC_COMPLIANT
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = -1,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+#else
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0, // garbage collection consumes the SP
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 3,
+            .method = HttpRequestMethod(SBuf(&quot;GET\x0B&quot;, 4)),
+            .uriStart = 5,
+            .uriEnd = 5,
+            .uri = &quot;/&quot;,
+            .versionStart = 7,
+            .versionEnd = 14,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+#endif
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // CR in method
     {
         // RFC 2616 sec 5.1 prohibits CR other than in terminator.
         input.append(&quot;GET\r / HTTP/1.1\r\n&quot;, 16);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = -1, // halt at the first \r
+            .suffixSz = input.length(),
+            .methodStart = -1,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // binary code NUL! in method (strange but ...)
     {
         input.append(&quot;GET\0 / HTTP/1.1\n&quot;, 16);
-        //printf(&quot;TEST: %d-%d/%d '%.*s'\n&quot;, output.req.start, output.req.end, input.contentSize(), 16, input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET\0 / HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET\0&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;/&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(7, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(14, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)));
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
-        input.reset();
+#if WHEN_RFC_COMPLIANT
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = -1, // halt at the \0
+            .suffixSz = input.length(),
+            .methodStart = -1,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+#else
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 3,
+            .method = HttpRequestMethod(SBuf(&quot;GET\0&quot;,4)),
+            .uriStart = 5,
+            .uriEnd = 5,
+            .uri = &quot;/&quot;,
+            .versionStart = 7,
+            .versionEnd = 14,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+#endif
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
-    // no URL (grammer otherwise correct)
+    // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
     {
         input.append(&quot;GET  HTTP/1.1\n&quot;, 14);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET  HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 5,
+            .uriEnd = 12,
+            .uri = &quot;HTTP/1.1&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
     {
         input.append(&quot;GET HTTP/1.1\n&quot;, 13);
-        //printf(&quot;TEST: '%s'\n&quot;,input.content());
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET HTTP/1.1\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;GET&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(11, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;HTTP/1.1&quot;, &amp;output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scOkay,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = 0,
+            .methodStart = 0,
+            .methodEnd = 2,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uriStart = 4,
+            .uriEnd = 11,
+            .uri = &quot;HTTP/1.1&quot;,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // binary line
     {
         input.append(&quot;\xB\xC\xE\xF\n&quot;, 5);
-        //printf(&quot;TEST: binary-line\n&quot;);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;\xB\xC\xE\xF\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // mixed whitespace line
     {
         // We accept non-space binary bytes for method so first \t shows up as that
         // but remaining space and tabs are skipped searching for URI-start
         input.append(&quot;\t \t \t\n&quot;, 6);
-        //printf(&quot;TEST: mixed whitespace\n&quot;);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;\t \t \t\n&quot;, &amp;output.buf[output.req.start],(output.req.end-output.req.start+1)));
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(0, memcmp(&quot;\t&quot;, &amp;output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)));
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = (int)input.length()-1,
+            .suffixSz = input.length(),
+            .methodStart = 0,
+            .methodEnd = 0,
+            .method = HttpRequestMethod(SBuf(&quot;\t&quot;)),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
     }
 
     // mixed whitespace line with CR middle
     {
         // CR aborts on sight, so even initial \t method is not marked as above
         // (not when parsing clean with whole line available anyway)
         input.append(&quot;\t  \r \n&quot;, 6);
-        //printf(&quot;TEST: mixed whitespace with CR\n&quot;);
-        output.reset(input.content(), input.contentSize());
-        CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&amp;output));
-        CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-        CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-        input.reset();
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .msgStart = 0,
+            .msgEnd = -1, // halt on the \r
+            .suffixSz = input.length(),
+            .methodStart = -1,
+            .methodEnd = -1,
+            .method = HttpRequestMethod(),
+            .uriStart = -1,
+            .uriEnd = -1,
+            .uri = NULL,
+            .versionStart = -1,
+            .versionEnd = -1,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
+    }
+}
+
+void
+testHttp1Parser::testDripFeed()
+{
+    // Simulate a client drip-feeding Squid a few bytes at a time.
+    // extend the size of the buffer from 0 bytes to full request length
+    // calling the parser repeatedly as visible data grows.
+
+    SBuf data;
+    data.append(&quot;            &quot;, 12);
+    SBuf::size_type garbageEnd = data.length();
+    data.append(&quot;GET <A HREF="http://example.com/">http://example.com/</A> HTTP/1.1\r\n&quot;, 34);
+    SBuf::size_type reqLineEnd = data.length() - 1;
+    data.append(&quot;Host: example.com\r\n\r\n&quot;, 21);
+    SBuf::size_type mimeEnd = data.length() - 1;
+    data.append(&quot;...&quot;, 3); // trailer to catch mime EOS errors.
+
+    SBuf ioBuf; // begins empty
+    Http1::RequestParser hp;
+
+    // only relaxed parser accepts the garbage whitespace
+    Config.onoff.relaxed_header_parser = 1;
+
+    // state of things we expect right now
+    struct resultSet expect = {
+        .parsed = false,
+        .needsMore = true,
+        .parserState = Http1::HTTP_PARSE_NONE,
+        .status = Http::scNone,
+        .msgStart = -1,
+        .msgEnd = -1,
+        .suffixSz = 0,
+        .methodStart = -1,
+        .methodEnd = -1,
+        .method = HttpRequestMethod(),
+        .uriStart = -1,
+        .uriEnd = -1,
+        .uri = NULL,
+        .versionStart = -1,
+        .versionEnd = -1,
+        .version = AnyP::ProtocolVersion()
+    };
+
+    Config.maxRequestHeaderSize = 1024; // large enough to hold the test data.
+
+    for (SBuf::size_type pos = 0; pos &lt;= data.length(); ++pos) {
+
+        // simulate reading one more byte
+        ioBuf.append(data.substr(pos,1));
+
+        // when the garbage is passed we expect to start seeing first-line bytes
+        if (pos == garbageEnd) {
+            expect.parserState = Http1::HTTP_PARSE_FIRST;
+            expect.msgStart = 0;
+        }
+
+        // all points after garbage start to see accumulated bytes looking for end of current section
+        if (pos &gt;= garbageEnd)
+            expect.suffixSz = ioBuf.length();
+
+        // at end of request line expect to see method, URI, version details
+        // and switch to seeking Mime header section
+        if (pos == reqLineEnd) {
+            expect.parserState = Http1::HTTP_PARSE_MIME;
+            expect.suffixSz = 0;
+            expect.msgEnd = reqLineEnd-garbageEnd;
+            expect.status = Http::scOkay;
+            expect.methodStart = 0;
+            expect.methodEnd = 2;
+            expect.method = HttpRequestMethod(Http::METHOD_GET);
+            expect.uriStart = 4;
+            expect.uriEnd = 22;
+            expect.uri = &quot;<A HREF="http://example.com/">http://example.com/</A>&quot;;
+            expect.versionStart = 24;
+            expect.versionEnd = 31;
+            expect.version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1);
+        }
+
+        // one mime header is done we are expectign a new request
+        // parse results say true and initial data is all gone from the buffer
+        if (pos == mimeEnd) {
+            expect.parsed = true;
+            expect.needsMore = false;
+            expect.suffixSz = 0;
+        }
+
+        testResults(__LINE__, ioBuf, hp, expect);
+
+        // sync the buffers like Squid does
+        ioBuf = hp.remaining();
+
+        // Squid stops using the parser once it has parsed the first message.
+        if (!hp.needsMoreData())
+            break;
     }
 }

=== renamed file 'src/tests/testHttpParser.h' =&gt; 'src/tests/testHttp1Parser.h'
--- src/tests/testHttpParser.h	2014-09-12 23:00:48 +0000
+++ src/tests/testHttp1Parser.h	2014-10-11 19:23:50 +0000
@@ -1,35 +1,41 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SRC_TESTS_TESTHTTPPARSER_H
-#define SQUID_SRC_TESTS_TESTHTTPPARSER_H
+#ifndef SQUID_SRC_TESTS_TESTHTTP1PARSER_H
+#define SQUID_SRC_TESTS_TESTHTTP1PARSER_H
 
 #include &lt;cppunit/extensions/HelperMacros.h&gt;
 
-class testHttpParser : public CPPUNIT_NS::TestFixture
+class testHttp1Parser : public CPPUNIT_NS::TestFixture
 {
-    CPPUNIT_TEST_SUITE( testHttpParser );
+    CPPUNIT_TEST_SUITE( testHttp1Parser );
+    CPPUNIT_TEST( testParserConstruct );
     CPPUNIT_TEST( testParseRequestLineTerminators );
     CPPUNIT_TEST( testParseRequestLineMethods );
     CPPUNIT_TEST( testParseRequestLineProtocols );
     CPPUNIT_TEST( testParseRequestLineStrange );
     CPPUNIT_TEST( testParseRequestLineInvalid );
+    CPPUNIT_TEST( testDripFeed );
     CPPUNIT_TEST_SUITE_END();
 
 protected:
     void globalSetup(); // MemPools init etc.
 
+    void testParserConstruct(); // whether the constructor works
+
     // request-line unit tests
     void testParseRequestLineTerminators(); // terminator detection correct
     void testParseRequestLineMethods();     // methoid detection correct
     void testParseRequestLineProtocols();   // protocol tokens handled correctly
     void testParseRequestLineStrange();     // strange but valid lines accepted
     void testParseRequestLineInvalid();     // rejection of invalid lines happens
+
+    void testDripFeed(); // test incremental parse works
 };
 
 #endif

=== modified file 'src/tests/testHttpRequestMethod.cc'
--- src/tests/testHttpRequestMethod.cc	2014-09-12 23:00:48 +0000
+++ src/tests/testHttpRequestMethod.cc	2014-10-15 13:39:59 +0000
@@ -1,67 +1,92 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &lt;cppunit/TestAssert.h&gt;
 
-#include &quot;HttpRequestMethod.h&quot;
+#include &quot;http/RequestMethod.h&quot;
 #include &quot;Mem.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;testHttpRequestMethod.h&quot;
 
 #include &lt;sstream&gt;
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpRequestMethod );
 
 /*
  * We should be able to make an HttpRequestMethod straight from a string.
  */
 void
 testHttpRequestMethod::testConstructCharStart()
 {
+    // string in SBuf
+
     /* parse an empty string -&gt; Http::METHOD_NONE */
-    CPPUNIT_ASSERT(HttpRequestMethod(NULL,NULL) == Http::METHOD_NONE);
+    CPPUNIT_ASSERT(HttpRequestMethod(SBuf()) == Http::METHOD_NONE);
+
+    /* parsing a literal should work */
+    CPPUNIT_ASSERT(HttpRequestMethod(SBuf(&quot;GET&quot;)) == Http::METHOD_GET);
+    CPPUNIT_ASSERT(HttpRequestMethod(SBuf(&quot;QWERTY&quot;)) == Http::METHOD_OTHER);
+
+    // string in char*
+
+    /* parse an empty string -&gt; Http::METHOD_NONE */
+    HttpRequestMethod a;
+    a.HttpRequestMethodXXX(NULL);
+    CPPUNIT_ASSERT(a == Http::METHOD_NONE);
+
     /* parsing a literal should work */
-    CPPUNIT_ASSERT(HttpRequestMethod(&quot;GET&quot;, NULL) == Http::METHOD_GET);
-    CPPUNIT_ASSERT(HttpRequestMethod(&quot;QWERTY&quot;, NULL) == Http::METHOD_OTHER);
+    HttpRequestMethod b;
+    b.HttpRequestMethodXXX(&quot;GET&quot;);
+    CPPUNIT_ASSERT(b == Http::METHOD_GET);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;GET&quot;), b.image());
+    HttpRequestMethod c;
+    c.HttpRequestMethodXXX(&quot;QWERTY&quot;);
+    CPPUNIT_ASSERT(c == Http::METHOD_OTHER);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;QWERTY&quot;), c.image());
+
+    // parsing error should not leave stale results
+    b.HttpRequestMethodXXX(NULL);
+    CPPUNIT_ASSERT(b == Http::METHOD_NONE);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;NONE&quot;), b.image());
 }
 
 /*
- * We can also parse precise ranges of characters
+ * We can also parse precise ranges of characters with SBuf
  */
 void
 testHttpRequestMethod::testConstructCharStartEnd()
 {
     char const * buffer;
     /* parse an empty string -&gt; Http::METHOD_NONE */
-    CPPUNIT_ASSERT(HttpRequestMethod(NULL, NULL) == Http::METHOD_NONE);
+    CPPUNIT_ASSERT(HttpRequestMethod(SBuf()) == Http::METHOD_NONE);
     /* parsing a literal should work */
-    CPPUNIT_ASSERT(HttpRequestMethod(&quot;GET&quot;, NULL) == Http::METHOD_GET);
+    CPPUNIT_ASSERT(HttpRequestMethod(SBuf(&quot;GET&quot;)) == Http::METHOD_GET);
     /* parsing with an explicit end should work */
     buffer = &quot;POSTPLUS&quot;;
-    CPPUNIT_ASSERT(HttpRequestMethod(buffer, buffer + 4) == Http::METHOD_POST);
+    CPPUNIT_ASSERT(HttpRequestMethod(SBuf(buffer, 4)) == Http::METHOD_POST);
 }
 
 /*
  * we should be able to assign a Http::MethodType to a HttpRequestMethod
  */
 void
 testHttpRequestMethod::testAssignFrommethod_t()
 {
     HttpRequestMethod method;
     method = Http::METHOD_NONE;
     CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), method);
     method = Http::METHOD_POST;
     CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_POST), method);
 }
 
 /*
  * a default constructed HttpRequestMethod is == Http::METHOD_NONE
  */
 void
 testHttpRequestMethod::testDefaultConstructor()
@@ -73,74 +98,74 @@
 
 /*
  * we should be able to construct a HttpRequestMethod from a Http::MethodType
  */
 void
 testHttpRequestMethod::testConstructmethod_t()
 {
     CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), HttpRequestMethod(Http::METHOD_NONE));
     CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_POST), HttpRequestMethod(Http::METHOD_POST));
     CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_NONE) != HttpRequestMethod(Http::METHOD_POST));
 }
 
 /*
  * we should be able to get a char const * version of the method.
  */
 void
 testHttpRequestMethod::testImage()
 {
     // relaxed RFC-compliance parse HTTP methods are upgraded to correct case
     Config.onoff.relaxed_header_parser = 1;
-    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(&quot;POST&quot;,NULL).image());
-    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(&quot;pOsT&quot;,NULL).image());
-    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(&quot;post&quot;,NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(SBuf(&quot;POST&quot;)).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(SBuf(&quot;pOsT&quot;)).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(SBuf(&quot;post&quot;)).image());
 
     // strict RFC-compliance parse HTTP methods are case sensitive
     Config.onoff.relaxed_header_parser = 0;
-    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(&quot;POST&quot;,NULL).image());
-    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;pOsT&quot;), HttpRequestMethod(&quot;pOsT&quot;,NULL).image());
-    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;post&quot;), HttpRequestMethod(&quot;post&quot;,NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;POST&quot;), HttpRequestMethod(SBuf(&quot;POST&quot;)).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;pOsT&quot;), HttpRequestMethod(SBuf(&quot;pOsT&quot;)).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;post&quot;), HttpRequestMethod(SBuf(&quot;post&quot;)).image());
 }
 
 /*
  * an HttpRequestMethod should be comparable to a Http::MethodType without false
  * matches
  */
 void
 testHttpRequestMethod::testEqualmethod_t()
 {
     CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_NONE) == Http::METHOD_NONE);
     CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_POST) == Http::METHOD_GET));
     CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_GET) == Http::METHOD_GET);
     CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_TRACE) == Http::METHOD_SEARCH));
 }
 
 /*
  * an HttpRequestMethod should testable for inequality without fail maatches
  */
 void
 testHttpRequestMethod::testNotEqualmethod_t()
 {
     CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_NONE) != Http::METHOD_GET);
     CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_POST) != Http::METHOD_POST));
     CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_GET) != Http::METHOD_NONE);
     CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_SEARCH) != Http::METHOD_SEARCH));
 }
 
 /*
  * we should be able to send it to a stream and get the normalised version
  */
 void
 testHttpRequestMethod::testStream()
 {
     // relaxed RFC-compliance parse HTTP methods are upgraded to correct case
     Config.onoff.relaxed_header_parser = 1;
     std::ostringstream buffer;
-    buffer &lt;&lt; HttpRequestMethod(&quot;get&quot;, NULL);
+    buffer &lt;&lt; HttpRequestMethod(SBuf(&quot;get&quot;));
     CPPUNIT_ASSERT_EQUAL(String(&quot;GET&quot;), String(buffer.str().c_str()));
 
     // strict RFC-compliance parse HTTP methods are case sensitive
     Config.onoff.relaxed_header_parser = 0;
     std::ostringstream buffer2;
-    buffer2 &lt;&lt; HttpRequestMethod(&quot;get&quot;, NULL);
+    buffer2 &lt;&lt; HttpRequestMethod(SBuf(&quot;get&quot;));
     CPPUNIT_ASSERT_EQUAL(String(&quot;get&quot;), String(buffer2.str().c_str()));
 }

</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000130.html">[squid-dev] [PATCH] HTTP Parser upgrade
</A></li>
	<LI>Next message: <A HREF="000111.html">[squid-dev] Build failed in Jenkins: anybranch-wholefarm-matrix Â» clang,rs-ubuntu-saucy #85
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#153">[ date ]</a>
              <a href="thread.html#153">[ thread ]</a>
              <a href="subject.html#153">[ subject ]</a>
              <a href="author.html#153">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
