<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Non-HTTP bypass
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54465FA3.5050506%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000131.html">
   <LINK REL="Next"  HREF="000175.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Non-HTTP bypass</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54465FA3.5050506%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Non-HTTP bypass">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Oct 21 13:29:07 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000131.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
        <LI>Next message: <A HREF="000175.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#170">[ date ]</a>
              <a href="thread.html#170">[ thread ]</a>
              <a href="subject.html#170">[ subject ]</a>
              <a href="author.html#170">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sorry I didn't get back to you on this earier.

Please hold off on this until the Parser-NG patch lands. You may
want/need to redesign parts of this based on parser changes already in
that branch, or which will follow in the next stages.
In fact this tunneling behaviour was to *be* one of the following stages.

Some hints follow ...

On 16/10/2014 7:30 a.m., Tsantilas Christos wrote:
&gt;<i> 
</I>&gt;<i> Intercepting proxies often receive non-HTTP connections. Squid cannot
</I>&gt;<i> currently deal with such connections well because it assumes that a
</I>&gt;<i> given port receives HTTP, FTP, or HTTPS traffic exclusively. This patch
</I>&gt;<i> allows Squid to tunnel unexpected connections instead of terminating
</I>&gt;<i> them with an error.
</I>&gt;<i> 
</I>&gt;<i> This patch:
</I>&gt;<i>    -Defines an unexpected connection as a connection that resulted in a
</I>&gt;<i> Squid error during first request parsing. Which errors trigger tunneling
</I>&gt;<i> behavior is configurable by the admin using ACLs.
</I>
The new parser will give a definitive fail answer to identify non-HTTP
traffic. Consisting of hp-&gt;parse() call returning false, and
hp-&gt;request_parse_status == Http::scBadRequest.

You can see the relevant case at the top of client_side.cc
parseHttpRequest() where it emits &quot;error:invalid-request&quot;.

I have also just committed the flexible transferProtocol member for
ConnStateData. With this proposed feature we will need to add a
AnyP::PROTO_TCP and set the traffic type to be that when bypassing
opaque data through the proxy.

&gt;<i> 
</I>&gt;<i>   - Adds &quot;on_first_request_error&quot;, a new ACL-driven squid.conf directive
</I>&gt;<i> that can be used to establish a blind TCP tunnel which relays all bytes
</I>&gt;<i> from/to the intercepted connection to/from the intended destination
</I>&gt;<i> address. See the sketch above.
</I>&gt;<i> The on_first_request_error directive supports fast ACLs only.
</I>&gt;<i> 
</I>
What a nasty name for an access list.


I believe tcp_tunnel or tunnel_transparent would be more descriptive of
the test is *checking* for. Particularly when we fix the missing CONNECT
via peers issue.


The &quot;only checked on first request failure&quot; detail can be left in the
directive documentation. I also suspect that is a false statement since
anything we do with a CONNECT body that fails will need a matching check
applied.

ssl-bump calls its version of tunnelling &quot;ssl_bump splice&quot;. So if we are
continuing with the splice vs tunnel terminology the syntax would look
something like this:

 tcp_tunnel deny localhost
 tcp_tunnel splice all


After this change goes in there will undoubtedly be requests to extend
it so that we do not waste time waiting for a parse error and just allow
a transparent port to tunnel selected connections right from accept().
So lets be prepared for that with the right naming and scope from the start.


&gt;<i>   - Adds &quot;squid_error&quot;, a new ACL type to match transactions that
</I>&gt;<i> triggered a given Squid error. Squid error IDs are used to configure one
</I>&gt;<i> or more errors to match. This is similar to the existing ssl_error ACL
</I>&gt;<i> type but works with Squid-generated errors rather than SSL library errors.
</I>
Note that what you are calling an &quot;error&quot; is just the presented payload
page ID. It is not necessarily one of the registered codes in the
template list since deny_info attached to any ACL can change it and load
custom pages.

&gt;<i> 
</I>&gt;<i>   - Adds &quot;ERR_WRONG_PROTOCOL&quot;, a new Squid error triggered for http_port
</I>&gt;<i> connections that start with something that lacks even basic HTTP request
</I>&gt;<i> structure. This error is triggered by the HTTP request parser, and
</I>&gt;<i> probably only when/after the current parsing code detects an error.
</I>
There is nothing wrong about the protocol. It is the administrators
&quot;bad&quot; decision to intercept that port which is the problem.

 ERR_UNSUP_PROTOCOL is more correct and even matches the actual template
message you picked.

Also, what HTTP status code are you intending to use for this template?
since scBadRequest maps to ERR_INVALID_REQUEST already.


&gt;<i> 
</I>&gt;<i>   Adds &quot;request_start_timeout&quot;, a new squid.conf directive to trigger a
</I>&gt;<i> new Squid ERR_REQUEST_START_TIMEOUT error if no bytes are received from
</I>&gt;<i> the client on a newly established http_port connection during the
</I>&gt;<i> configured time period. Applies to all http_ports (for now).
</I>
That was a separate discussion and should be a separate patch IMO.
Please separate the two features.

I know that hanging client connections is *possibly* a sign that they
are trying to use some protocol where the server handshakes first.

However, the times when that was even halfway reliable are long gone.
Browsers implemented &quot;happy eyeballs&quot;, Alex implemented standby
connections, IPv4 people block ICMP packet-too-big, etc ... new
connections with long timeout are a very common error in otherwise
perfectly normal HTTP traffic. It is invalid criteria to base a
determination of the &quot;unsupported protocol&quot; status.

Also, allowing a client to bypass the proxy simply by hanging their
connection for some seconds/minutes before using it is an extremely
hazardous action to allow. I would be surprised if any sane admin wanted
this to happen.

In short, I want to see this added separately with a default action on
this timeout to be connection close / TCP_RST or the usual squid error
page (no checking for bypass until someone can provide a rock-solid
reason for it and way to do so reliably).


&gt;<i> 
</I>&gt;<i> No support for tunneling through cache_peers is included. Configurations
</I>&gt;<i> that direct outgoing traffic through a peer may break Squid.
</I>&gt;<i> 
</I>&gt;<i> Configuration sketch:
</I>&gt;<i> 
</I>&gt;<i>    # define what Squid errors indicate receiving non-HTTP traffic:
</I>&gt;<i>    acl foreignProtocol squid_error ERR_WRONG_PROTOCOL ERR_TOO_BIG
</I>
TOO_BIG is not correct for this. It appears if the URL field or the mime
headers portions are larger than admin *configured* limits - regardless
of how valid they are in HTTP syntax.

There are a handful of situations where the too-big request happens so
routinely that status codes 414 and 431 got standardized to help
browsers auto-crop their request details and retry.


&gt;<i> 
</I>&gt;<i>    # define what Squid errors indicate receiving nothing:
</I>&gt;<i>    acl serverTalksFirstProtocol squid_error ERR_REQUEST_START_TIMEOUT
</I>&gt;<i> 
</I>&gt;<i>    # tunnel everything that does not look like HTTP:
</I>&gt;<i>    on_first_request_error tunnel foreignProtocol
</I>&gt;<i> 
</I>&gt;<i>    # tunnel if we think the client waits for the server to talk first:
</I>&gt;<i>    on_first_request_error tunnel serverTalksFirstProtocol
</I>&gt;<i> 
</I>&gt;<i>    # in all other error cases, just send an HTTP &quot;error page&quot; response:
</I>&gt;<i>    on_first_request_error respond all
</I>&gt;<i> 
</I>&gt;<i>    # Configure how long to wait for the first byte on the incoming
</I>&gt;<i>    # connection before raising an ERR_REQUEST_START_TIMEOUT error.
</I>&gt;<i>    request_start_timeout 5 seconds
</I>&gt;<i> 
</I>&gt;<i> For more informations please read patch preamble.
</I>&gt;<i> 
</I>&gt;<i> This is a Measurement Factory project
</I>&gt;<i> 
</I>
I've had a quick look through the patch. Two major things stood out:

1)  The timeout change being unrelated to the transparent proxy changes,
as mentioned above.

2) All changes in src/tunnel.cc seem to be needless.
 - tunnelStartShovelling() should *always* be the entrypoint to begin
transmit on a tunnel in any direction. At that point there is maybe
client data to send to server ...
 - The socket may not even permit one whole TCP_RCV_BUF worth of bytes
to be written in a single action. comm_write can handle that just fine.
If comm_write is unable to handle all the available conn-&gt;in.buf in one
comm_write() call then that would be a bug in comm to fix separate from
all this.
 There is simply no reason to add an extra if
(preReadClientData.length()) conditional in *every* packet I/O cycle.

Cheers
Amos

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJURl+iAAoJELJo5wb/XPRjI2MIAJqSAbdiX08FKrCeXaPn1ZCP
kYSDcLVTBH9FQyHlGwXLlefh9YTaHnCSx+XLGrvqPFOWQtQ7RkECzQD0/VgxxxSt
tkm5Mrt2lNk/jvu153nctfraVvfWWz+yqF6sbcYv9Ufdr/QhVggob3c6kNIYido4
XFvvAqzaeV/g8FkylAcuCnnxIGLQcyzmUmsDg64shIKPx5nzUARxVkrDyHhjYPqU
D+lf4QMoyYuIJOytU++PdL2gkyEfVAtdLWZqfeaxZN89lRkpPGmNWRNOYjW+RqeY
WXGn0ulRlHuJpTOEsB98nGBd/sV51e49OnGo4cNAKXHI3IXK/49b9L4hqWj+rAY=
=4FE+
-----END PGP SIGNATURE-----
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000131.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
	<LI>Next message: <A HREF="000175.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#170">[ date ]</a>
              <a href="thread.html#170">[ thread ]</a>
              <a href="subject.html#170">[ subject ]</a>
              <a href="author.html#170">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
