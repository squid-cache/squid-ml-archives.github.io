<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Non-HTTP bypass
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54469814.8000500%40users.sourceforge.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000170.html">
   <LINK REL="Next"  HREF="000177.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Non-HTTP bypass</H1>
    <B>Tsantilas Christos</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Non-HTTP%20bypass&In-Reply-To=%3C54469814.8000500%40users.sourceforge.net%3E"
       TITLE="[squid-dev] [PATCH] Non-HTTP bypass">chtsanti at users.sourceforge.net
       </A><BR>
    <I>Tue Oct 21 17:29:56 UTC 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000170.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
        <LI>Next message: <A HREF="000177.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#175">[ date ]</a>
              <a href="thread.html#175">[ thread ]</a>
              <a href="subject.html#175">[ subject ]</a>
              <a href="author.html#175">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/21/2014 04:29 PM, Amos Jeffries wrote:
&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> Hash: SHA1
</I>&gt;<i>
</I>&gt;<i> Sorry I didn't get back to you on this earier.
</I>&gt;<i>
</I>&gt;<i> Please hold off on this until the Parser-NG patch lands. You may
</I>&gt;<i> want/need to redesign parts of this based on parser changes already in
</I>&gt;<i> that branch, or which will follow in the next stages.
</I>&gt;<i> In fact this tunneling behaviour was to *be* one of the following stages.
</I>
OK.

&gt;<i>
</I>&gt;<i> Some hints follow ...
</I>&gt;<i>
</I>&gt;<i> On 16/10/2014 7:30 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Intercepting proxies often receive non-HTTP connections. Squid cannot
</I>&gt;&gt;<i> currently deal with such connections well because it assumes that a
</I>&gt;&gt;<i> given port receives HTTP, FTP, or HTTPS traffic exclusively. This patch
</I>&gt;&gt;<i> allows Squid to tunnel unexpected connections instead of terminating
</I>&gt;&gt;<i> them with an error.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This patch:
</I>&gt;&gt;<i>     -Defines an unexpected connection as a connection that resulted in a
</I>&gt;&gt;<i> Squid error during first request parsing. Which errors trigger tunneling
</I>&gt;&gt;<i> behavior is configurable by the admin using ACLs.
</I>&gt;<i>
</I>&gt;<i> The new parser will give a definitive fail answer to identify non-HTTP
</I>&gt;<i> traffic. Consisting of hp-&gt;parse() call returning false, and
</I>&gt;<i> hp-&gt;request_parse_status == Http::scBadRequest.
</I>&gt;<i>
</I>&gt;<i> You can see the relevant case at the top of client_side.cc
</I>&gt;<i> parseHttpRequest() where it emits &quot;error:invalid-request&quot;.
</I>
Please see my comments bellow....
If required I will make my comments in parser-ng patch discussion too....

&gt;<i>
</I>&gt;<i> I have also just committed the flexible transferProtocol member for
</I>&gt;<i> ConnStateData. With this proposed feature we will need to add a
</I>&gt;<i> AnyP::PROTO_TCP and set the traffic type to be that when bypassing
</I>&gt;<i> opaque data through the proxy.
</I>
Yep I saw this change.
I will remake the patch after your patch applied to trunk.


&gt;&gt;<i>
</I>&gt;&gt;<i>    - Adds &quot;on_first_request_error&quot;, a new ACL-driven squid.conf directive
</I>&gt;&gt;<i> that can be used to establish a blind TCP tunnel which relays all bytes
</I>&gt;&gt;<i> from/to the intercepted connection to/from the intended destination
</I>&gt;&gt;<i> address. See the sketch above.
</I>&gt;&gt;<i> The on_first_request_error directive supports fast ACLs only.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> What a nasty name for an access list.
</I>
it is not so bad :-)

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I believe tcp_tunnel or tunnel_transparent would be more descriptive of
</I>&gt;<i> the test is *checking* for. Particularly when we fix the missing CONNECT
</I>&gt;<i> via peers issue.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The &quot;only checked on first request failure&quot; detail can be left in the
</I>&gt;<i> directive documentation. I also suspect that is a false statement since
</I>&gt;<i> anything we do with a CONNECT body that fails will need a matching check
</I>&gt;<i> applied.
</I>&gt;<i>
</I>&gt;<i> ssl-bump calls its version of tunnelling &quot;ssl_bump splice&quot;. So if we are
</I>&gt;<i> continuing with the splice vs tunnel terminology the syntax would look
</I>&gt;<i> something like this:
</I>&gt;<i>
</I>&gt;<i>   tcp_tunnel deny localhost
</I>&gt;<i>   tcp_tunnel splice all
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> After this change goes in there will undoubtedly be requests to extend
</I>&gt;<i> it so that we do not waste time waiting for a parse error and just allow
</I>&gt;<i> a transparent port to tunnel selected connections right from accept().
</I>&gt;<i> So lets be prepared for that with the right naming and scope from the start.
</I>
The tcp_tunnel is not a bad name.
Lets see if Alex has a different opinion on see...


&gt;&gt;<i>    - Adds &quot;squid_error&quot;, a new ACL type to match transactions that
</I>&gt;&gt;<i> triggered a given Squid error. Squid error IDs are used to configure one
</I>&gt;&gt;<i> or more errors to match. This is similar to the existing ssl_error ACL
</I>&gt;&gt;<i> type but works with Squid-generated errors rather than SSL library errors.
</I>&gt;<i>
</I>&gt;<i> Note that what you are calling an &quot;error&quot; is just the presented payload
</I>&gt;<i> page ID. It is not necessarily one of the registered codes in the
</I>&gt;<i> template list since deny_info attached to any ACL can change it and load
</I>&gt;<i> custom pages.
</I>
It is the error we are recording to request::errType or the error passed 
directly to FillledChecklist::requestErrorType

The HttpRequest::errType set using the HttpRequest::detailError() method 
which will not update with new error code the errType member it it is 
already set.
So I believe that the deny_info can not change/adjust the 
HttpRequest::errType. This is always the first error.
Am I missing something?

&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    - Adds &quot;ERR_WRONG_PROTOCOL&quot;, a new Squid error triggered for http_port
</I>&gt;&gt;<i> connections that start with something that lacks even basic HTTP request
</I>&gt;&gt;<i> structure. This error is triggered by the HTTP request parser, and
</I>&gt;&gt;<i> probably only when/after the current parsing code detects an error.
</I>&gt;<i>
</I>&gt;<i> There is nothing wrong about the protocol. It is the administrators
</I>&gt;<i> &quot;bad&quot; decision to intercept that port which is the problem.
</I>&gt;<i>
</I>&gt;<i>   ERR_UNSUP_PROTOCOL is more correct and even matches the actual template
</I>&gt;<i> message you picked.
</I>
Actually still I am confused about the correct errors...
Probably the ERR_UNSUP_PROTOCOL is an error triggered where we can read 
the protocol, but we are not support it. For example a request in the 
form:
     GET <A HREF="rtsp://destodomain.com/path/">rtsp://destodomain.com/path/</A> RTSP/1.1

The wrong protocol menas a completely foreign protocol, for example a 
sequence of binary chars...
But still I am not sure if we need to separate these cases....

&gt;<i>
</I>&gt;<i> Also, what HTTP status code are you intending to use for this template?
</I>&gt;<i> since scBadRequest maps to ERR_INVALID_REQUEST already.
</I>
Bad request may include a variety of errors in an HTTP request. But not 
an unknown protocol.

Do you think that these cases can be handled (and needed) in new 
parser-ng patch?


&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Adds &quot;request_start_timeout&quot;, a new squid.conf directive to trigger a
</I>&gt;&gt;<i> new Squid ERR_REQUEST_START_TIMEOUT error if no bytes are received from
</I>&gt;&gt;<i> the client on a newly established http_port connection during the
</I>&gt;&gt;<i> configured time period. Applies to all http_ports (for now).
</I>&gt;<i>
</I>&gt;<i> That was a separate discussion and should be a separate patch IMO.
</I>&gt;<i> Please separate the two features.
</I>
Does it make sense this feature with out the non-http bypass feature?

&gt;<i>
</I>&gt;<i> I know that hanging client connections is *possibly* a sign that they
</I>&gt;<i> are trying to use some protocol where the server handshakes first.
</I>&gt;<i>
</I>&gt;<i> However, the times when that was even halfway reliable are long gone.
</I>&gt;<i> Browsers implemented &quot;happy eyeballs&quot;, Alex implemented standby
</I>&gt;<i> connections, IPv4 people block ICMP packet-too-big, etc ... new
</I>&gt;<i> connections with long timeout are a very common error in otherwise
</I>&gt;<i> perfectly normal HTTP traffic. It is invalid criteria to base a
</I>&gt;<i> determination of the &quot;unsupported protocol&quot; status.
</I>
Yes! this is true.
Also the browsers may open connections just in case they need them in 
the future.
It is not a prof but it is an indication. Just for special applications.
It can be combined with other acls (ip addresses)

&gt;<i>
</I>&gt;<i> Also, allowing a client to bypass the proxy simply by hanging their
</I>&gt;<i> connection for some seconds/minutes before using it is an extremely
</I>&gt;<i> hazardous action to allow. I would be surprised if any sane admin wanted
</I>&gt;<i> this to happen.
</I>
Yes. But we should not consider clients always as enemies.
There are cases where there is trust between admins and users.

&gt;<i>
</I>&gt;<i> In short, I want to see this added separately with a default action on
</I>&gt;<i> this timeout to be connection close / TCP_RST or the usual squid error
</I>&gt;<i> page (no checking for bypass until someone can provide a rock-solid
</I>&gt;<i> reason for it and way to do so reliably).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No support for tunneling through cache_peers is included. Configurations
</I>&gt;&gt;<i> that direct outgoing traffic through a peer may break Squid.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Configuration sketch:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     # define what Squid errors indicate receiving non-HTTP traffic:
</I>&gt;&gt;<i>     acl foreignProtocol squid_error ERR_WRONG_PROTOCOL ERR_TOO_BIG
</I>&gt;<i>
</I>&gt;<i> TOO_BIG is not correct for this. It appears if the URL field or the mime
</I>&gt;<i> headers portions are larger than admin *configured* limits - regardless
</I>&gt;<i> of how valid they are in HTTP syntax.
</I>
It is an example.
I will remove it.


&gt;<i>
</I>&gt;<i> There are a handful of situations where the too-big request happens so
</I>&gt;<i> routinely that status codes 414 and 431 got standardized to help
</I>&gt;<i> browsers auto-crop their request details and retry.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     # define what Squid errors indicate receiving nothing:
</I>&gt;&gt;<i>     acl serverTalksFirstProtocol squid_error ERR_REQUEST_START_TIMEOUT
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     # tunnel everything that does not look like HTTP:
</I>&gt;&gt;<i>     on_first_request_error tunnel foreignProtocol
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     # tunnel if we think the client waits for the server to talk first:
</I>&gt;&gt;<i>     on_first_request_error tunnel serverTalksFirstProtocol
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     # in all other error cases, just send an HTTP &quot;error page&quot; response:
</I>&gt;&gt;<i>     on_first_request_error respond all
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     # Configure how long to wait for the first byte on the incoming
</I>&gt;&gt;<i>     # connection before raising an ERR_REQUEST_START_TIMEOUT error.
</I>&gt;&gt;<i>     request_start_timeout 5 seconds
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For more informations please read patch preamble.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is a Measurement Factory project
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I've had a quick look through the patch. Two major things stood out:
</I>&gt;<i>
</I>&gt;<i> 1)  The timeout change being unrelated to the transparent proxy changes,
</I>&gt;<i> as mentioned above.
</I>&gt;<i>
</I>&gt;<i> 2) All changes in src/tunnel.cc seem to be needless.
</I>&gt;<i>   - tunnelStartShovelling() should *always* be the entrypoint to begin
</I>&gt;<i> transmit on a tunnel in any direction. At that point there is maybe
</I>&gt;<i> client data to send to server ...
</I>&gt;<i>   - The socket may not even permit one whole TCP_RCV_BUF worth of bytes
</I>&gt;<i> to be written in a single action. comm_write can handle that just fine.
</I>&gt;<i> If comm_write is unable to handle all the available conn-&gt;in.buf in one
</I>&gt;<i> comm_write() call then that would be a bug in comm to fix separate from
</I>&gt;<i> all this.
</I>&gt;<i>   There is simply no reason to add an extra if
</I>&gt;<i> (preReadClientData.length()) conditional in *every* packet I/O cycle.
</I>
I will review the related changes. I am to tired now to make clear 
thoughts on this...



&gt;<i>
</I>&gt;<i> Cheers
</I>&gt;<i> Amos
</I>&gt;<i>
</I>


</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000170.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
	<LI>Next message: <A HREF="000177.html">[squid-dev] [PATCH] Non-HTTP bypass
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#175">[ date ]</a>
              <a href="thread.html#175">[ thread ]</a>
              <a href="subject.html#175">[ subject ]</a>
              <a href="author.html#175">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
