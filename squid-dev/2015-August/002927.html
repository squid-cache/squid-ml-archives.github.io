<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HttpHeader%20migration%20%28coverity-fixes%20branch%29&In-Reply-To=%3C55C17017.7060401%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002926.html">
   <LINK REL="Next"  HREF="002929.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HttpHeader%20migration%20%28coverity-fixes%20branch%29&In-Reply-To=%3C55C17017.7060401%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Aug  5 02:08:23 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002926.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
        <LI>Next message: <A HREF="002929.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2927">[ date ]</a>
              <a href="thread.html#2927">[ thread ]</a>
              <a href="subject.html#2927">[ subject ]</a>
              <a href="author.html#2927">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 5/08/2015 9:08 a.m., Kinkie wrote:
&gt;<i> On Tue, Aug 4, 2015 at 2:58 PM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> On 4/08/2015 11:22 p.m., Kinkie wrote:
</I>&gt;&gt;&gt;<i> Hi all,
</I>&gt;&gt;&gt;<i>   the attached patch is a build- and run-tested merge proposal for next
</I>&gt;&gt;&gt;<i> round of the coverity-fixes branch, currently focusing on more effective
</I>&gt;&gt;&gt;<i> header name -&gt; id lookups.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Here's the status with the current todo checklist:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  * DONE 1. shift HDR_BAD_HDR to end of enum
</I>&gt;&gt;&gt;<i>  * DONE 2. shift headers data array to http/RegistredHeaders.cc
</I>&gt;&gt;&gt;<i>  * DONE 3. creatign LookupTable object from teh enum and array
</I>&gt;&gt;&gt;<i>  * (with HDR_BAD_HDR as invalid value)
</I>&gt;&gt;&gt;<i>  * DONE 4. replacing httpHeaderIdByName() uses with the lookup table
</I>&gt;&gt;&gt;<i>  * NOT POSSIBLE 5. merge HDR_BAD_HDR and HDR_ENUM_END into one thing -
</I>&gt;&gt;&gt;<i> HDR_ENUM_END is overloaded meaning &quot;All&quot; headers in Manglers.
</I>&gt;&gt;&gt;<i>  * DONE 6. replacing httpHeaderNameById with direct array lookups
</I>&gt;&gt;&gt;<i>  * DONE 7. being looking at the other arrays removal
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In working on this I found out several instances of enum abuses -
</I>&gt;&gt;<i> tracking
</I>&gt;&gt;&gt;<i> those down has been the hardest part of the effort.
</I>&gt;&gt;&gt;<i> HttpHeader::parse is being used to parse error page templates - thus the
</I>&gt;&gt;&gt;<i> relaxed any_registered_header() checks in some methods, e.g.
</I>&gt;&gt;&gt;<i> HttpHdeader::addEntry().
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Next steps, if there is consensus:
</I>&gt;&gt;&gt;<i> - moving LookupTable away from std::map to std::hash with custom
</I>&gt;&gt;&gt;<i> gperf-derived Hashers for extra boost
</I>&gt;&gt;&gt;<i> - investigating whether strongly-typed enums can be used instead of
</I>&gt;&gt;<i> C-style
</I>&gt;&gt;&gt;<i> enums in more places.
</I>&gt;&gt;&gt;<i> - moving away from homegrown bitfields (CBIT_TEST etc.) towards
</I>&gt;&gt;&gt;<i> std::vector&lt;bool&gt; or std::vector&lt;unsigned char&gt;, possibly via a class
</I>&gt;&gt;&gt;<i> bitfield or somesuch.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> audit results:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * httpHdrCcCleanModule() and httpHdrScCleanModule() can both be fully
</I>&gt;&gt;<i> deleted now.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Yes. I chose to let them in: they are NOPs, not in the critical path, and
</I>&gt;<i> may be useful in the future. Let me know if you still want them removed.
</I>&gt;<i> 
</I>
:<i>-( more 'dead' code. This kind of thing is useful for
</I>ctpr/dtor/functor/virtual definition. But C functions that are not even
used as functors is a waste of LOC and also compiler time dealing with
the symbols.
 Its minor but still technical debt. The long-term plan is also to use
RegisteredRunners for this type of thing not C functions.


&gt;&gt;<i> * LookupTableRecord should be a class.
</I>&gt;&gt;<i>  - custom storage types can then inherit from it, with it as the first
</I>&gt;&gt;<i> parent
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Well, templatization can prevent that need, but sure. Should I implement
</I>&gt;<i> that?
</I>&gt;<i> Isn't nowadays a struct == all-public class though? It looks odd, but
</I>&gt;<i> functionally is the same
</I>&gt;<i> 
</I>
Avoid &quot;looks odd&quot; whenever possible :-) as you say, the compiler dont
care. But this is about us humans quick and easy reading it in 10 years
time.

I think its okay for useful code optimizations. Bt then the design
choice needs documenting so nobody breaks or undoes it casually.


&gt;<i> 
</I>&gt;&gt;<i> in src/HttpHeader.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * can you move the headerLookupTable to src/http/RegisteredHeaders.cc
</I>&gt;&gt;<i> and the Http:: namespace as well please ?
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Moved to RegisteredHeaders and renamed HDR_FOO to Http::HdrType::FOO .
</I>&gt;<i> Moving to a strongly-typed enum is unfortunately not feasible as eCAP
</I>&gt;<i> requires integer-enum equivalence; it may be that the whole change has to
</I>&gt;<i> be reverted.
</I>&gt;<i> 
</I>
I thought &quot;enum class&quot; with first parameter value assigned 0
(&quot;HDR_ACCEPT = 0,&quot;) should do that. ie. strongly typed to unsigned
integer values.


&gt;&gt;<i> * any_registered_header() is wrong.
</I>&gt;&gt;<i>  - it matches for HDR_OTHER which by definition is a non-registered header
</I>&gt;&gt;<i>  - assert_eid() is equivalent to any_valid_header()
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Then we need to change name. We need two semantics:
</I>&gt;<i> 1) any header which is valid and defined (including OTHER)
</I>&gt;<i> 2) any header ID which will not go out-of-bounds (same as (1) + HDR_BAD_HDR)
</I>&gt;<i> 
</I>&gt;<i> any suggestion?
</I>&gt;<i> 
</I>
(1) is already any_valid_header().

(2) any_HdrType_enum_value()


But where/why do we need (2) ?
 Any value input or received that is non-(1) needs to be represented as
BAD_HDR when parsing/validating the input to an enum value.

Are you looking at things HttpHeader.cc line ~524:

AA)

+  if (e-&gt;id &gt;= Http::HdrType::ENUM_END) {
    debugs(55, DBG_CRITICAL, &quot;BUG: invalid entry (&quot; &lt;&lt; e-&gt;id &lt;&lt; &quot;)...

That should probably be if(!any_valid_header(e-&gt;id)) since BAD is also
invalid entry value for a header.

If the logic there explicitly requires BAD handling, it should be:
  // some reason for why BAD is accepted as 'valid'.
  if(!any_valid_header(e-&gt;id) &amp;&amp; e-&gt;id != BAD)

Although note that when parsing is fixed BAD will represent *any*
invalid value.


or BB) the header manglers &quot;All&quot; ?

For that I think we need a new enum value like &quot;Other,&quot;  (&quot;All,&quot; ?)
which is outside registered headers, but valid only as an enum entry.
Currently END, but that needs a rename and never to be used by
non-mangler code.


&gt;&gt;<i>
</I>&gt;&gt;<i>  - please consider removing the assert(assert(any_valid_header(id)))
</I>&gt;&gt;<i>    it could probably be replaced by:
</I>&gt;&gt;<i>       if (!assert(any_valid_header(id)))
</I>&gt;&gt;<i>           id = HDR_OTHER
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Huh? I can't find any nested assert
</I>&gt;<i> 
</I>
copy-paste error on my part. It is the assert you are adding three lines
below what is now &quot;got hdr-id=&quot; in the chunk @1512.

I can't see the function name, but it looks like parsing some input.
Avoid assert in all parsers. Output BAD or OTHER as appropriate instead.


I been thinking a bit more (sorry dangerous).

It may be worth adjusting the src/mk-string-arrays.awk script to also be
capable of output LookupTable&lt;X&gt;::Record arrays. That script is designed
to guarantee invariance. Though it does leave us with another .cc.
Anyhow thats a followup to think about, not in this scope.


second round audit:

in src/HttpHdrCc.cc:

* valid_id in httpHdrCcStatDumper() can probably be a const bool like
the other.


in src/HttpHdrSc.cc:

* useless include of dlink.h since its done in the .h

* a duplicate include of HttpHdrSc.h since its pulled in by
HttpHdrScTarget.h.
 - but in this case I think replece it with:
  //#include &quot;HttpHdrSc.h&quot; // pulled in by HttpHdrScTarget.h


in src/HttpHdrSc.h:

* please use mem/forward.h instead of mem/AllocatorProxy.h

* please store the class pre-defines alphabetically.
 - Packable above StatHist.


in src/HttpHdrScTarget.cc:

* useless include of HttpHdrSc.h
 - thanks for fixing the missing HttpHdrScTarget.h


in src/HttpHdrScTarget.h:

* now has useless include of mem/forward.h (after above fix),
SquidString.h, dlink.h, typedefs.h


in src/HttpHeader.cc:

* please take the opportunity to remove useless includes overlapping
with HttpHdrCc.h and HttpHdrSc.h

* please replace include fof HttpHdrSc.h with HttpHdrScTarget.h in the
new include nesting.
 - also checking for duplicate includes between HttpHdrScTarget.h and
HttpHeader.cc

* chunk @562, s/NULL/nullptr/
 - maybe others in the touched lines

* HttpHeaderEntry dtor use of assert(any_valid_header(id)); at the top
is needless.
 - protect the stats accounting against BAD though.


* HttpHeaderEntry ctor accepts OTHER but also &quot;anId != BAD&quot; implies that
it accepts BAD as well despite the previous
assert(any_registered_header(anId)).
 - wrap the stats accounting in if (id != BAD).

 - fixing those ctor/dtor asserts will avoid any potential for assertion
from temporary default- or partially- constructed objects, or bad
emplacement destructions.


in src/acl/RequestHeaderStrategy.h:

 * please take the opportunity to remove that empty line between
'template' and 'class' at lines at ~14


in src/http/RegisteredHeaders.cc:

* please add empty line between namespace '{' and start of comment.


in src/http/RegisteredHeaders.h:

* please document on HeaderTable that lookup() will return BAD if the
header is unknown / unregistered. callers need to check and handle that
case properly.


I think that is all. And all polish :-)

+1 on this so far. Though you/we still need to sort the valid registered
ID tests before commit.


NOTE: these are about old bugs you are uncovering. I'd like to take the
opportunity to fix them. But this is already huge, so for now just XXX
mark it and followup patch.

* I'm still not clear on why insertEntry() checks for valid header enum
values but addEntry() needs to accept BAD.
 - if that need is true its worth a comment to document. otherwise
update top of addEntry() to match insertEntry().
 - NP: we should *never* be adding a BAD/invalid header entry to a
message object. Custom ones yes, but they are OTHER.


* like has() all the has/put/get*(ID, ...) methods need to exclude BAD
and OTHER as a valid inputs.
 - OTHER means we are accessing and using the Entry by string name, not
by ID value.
 - BAD means we should never have put it into object in the first place.
 - the put*(ID, ...) accepting OTHER may be where addEntry(ID,...) goes
wrong.
 - sorry these seem to have got caught in cleaning up one of my earlier
comments which was about another changed use of assert_eid().
assert_eid() test was wrong for these get/put/has*(ID,...) to begin with.


[[ httpHeaderFieldStatDumper() earning itself a place in the hall of
horrors :-(
  ..., double val, ...
  const int id = static_cast&lt;int&gt;(val);
  const bool valid_id = id &lt; Http::HdrType::ENUM_END;
 // back away, quietly ...
]]

Amos
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002926.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
	<LI>Next message: <A HREF="002929.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2927">[ date ]</a>
              <a href="thread.html#2927">[ thread ]</a>
              <a href="subject.html#2927">[ subject ]</a>
              <a href="author.html#2927">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
