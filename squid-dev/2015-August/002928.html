<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Simpler and more robust request line parser
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Simpler%20and%20more%20robust%20request%20line%20parser&In-Reply-To=%3C55C1BD57.9020105%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002930.html">
   <LINK REL="Next"  HREF="002931.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Simpler and more robust request line parser</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Simpler%20and%20more%20robust%20request%20line%20parser&In-Reply-To=%3C55C1BD57.9020105%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Simpler and more robust request line parser">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Aug  5 07:37:59 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002930.html">[squid-dev] Jenkins build is back to normal : trunk-polygraph #798
</A></li>
        <LI>Next message: <A HREF="002931.html">[squid-dev] [CODE] iterating over enums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2928">[ date ]</a>
              <a href="thread.html#2928">[ thread ]</a>
              <a href="subject.html#2928">[ subject ]</a>
              <a href="author.html#2928">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 24/07/2015 11:13 a.m., Alex Rousskov wrote:
&gt;<i> On 07/23/2015 08:16 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> Please note: most of my comments in this long email are informational.
</I>&gt;&gt;<i> Things which need to be taken into consideration when touching the parser.
</I>&gt;<i> 
</I>&gt;<i> Noted. I will do my best to treat them as such.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> I request performance testing of the final version of this change vs
</I>&gt;&gt;<i> lastest trunk at the time.
</I>&gt;<i> 
</I>&gt;<i> Noted.
</I>&gt;<i> 
</I>&gt;<i> The next patch will address comments not discussed in this email. Thank
</I>&gt;<i> you for those!
</I>&gt;<i> 
</I>&gt;<i> The rest of this email is the usual waste of time discussing
</I>&gt;<i> non-existent bugs, arguing about mostly irrelevant issues, burning straw
</I>&gt;<i> men, and talking past each other. The only important bit of information
</I>&gt;<i> is probably the following paragraph that I will quote here for those who
</I>&gt;<i> do not want to waste their time reading everything:
</I>&gt;<i> 
</I>&gt;<i> &quot;I am happy to restrict URIs to what older Squids accepted or more.
</I>&gt;<i> Recent parser changes broke Squid. There is no need to go beyond what we
</I>&gt;<i> were doing before those changes. I will gladly make a simple patch
</I>&gt;<i> change to restrict URIs to either that old subset or to the current
</I>&gt;<i> trunk subset, whichever is larger. Exactly what subset do you want me to
</I>&gt;<i> use?&quot;
</I>

Current trunk already accepts all ASCII printable characters, and a
bunch of whitespace / control codes.

&quot;What I would like&quot; is:

// RFC 3986 URI component character set(s)
// RFC 7230 request-line delimiter
// RFC 7230 HTTP-version character set
auto permit = uriValidCharacters() + CharacterSet::SP;

if (relaxed_header_parser) {

 // RFC7230 section 3.5 alternative control-code whitespace
 permit += CharacterSet::HTAB
   + CharacterSet(&quot;VT,FF&quot;,&quot;\x0B\x0C&quot;)
   + CharacterSet::CR;

#if USE_HTTP_VIOLATIONS
  // RFC 2396 unwise character set
  // the &quot;transport agents are known to sometimes modify or use as
delimiter&quot; set
  // which must never be transmitted in un-escaped form
  permit.add('\0');
  permit += CharacterSet(&quot;RFC2396-unwise&quot;,&quot;\&quot;\\|^&lt;&gt;`{}&quot;);
#endif
}


Which leaves some 27 CTL characters (0x01-0x1F) still forbidden. Things
like delete, backslash, bell, escape, end-of-transmission. I hope you
are not going to argue for re-enabling those inside this parser.

Of course the bare UTF-8 extended unicode characters are omitted too.
Those is prohibited anywhere in HTTP, and a sure sign that its non-HTTP
being processed. So definitely exit this parser.

IFF you have no objections to the above charsets then the only thing
this patch is waiting on in the technical sense is polygraph test results.



&gt;&gt;<i> On 23/07/2015 4:05 p.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> Hello,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     The attached patch implements a simpler and more robust HTTP request
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is less robust as many potential attacks are now accepted by the
</I>&gt;&gt;<i> Parser as valid HTTP messages. 
</I>&gt;<i> 
</I>&gt;<i> The parser is more robust because it correctly accepts a larger variety
</I>&gt;<i> of benign messages (see Robustness Principle). That necessarily includes
</I>&gt;<i> a larger variety of &quot;potential attack messages&quot;, of course, because
</I>&gt;<i> &quot;potential attack&quot; is such an open-ended term.
</I>&gt;<i> 
</I>&gt;<i> FWIW, it would be perfectly reasonable to enhance relaxed_header_parser
</I>&gt;<i> (or add a new relaxed_uri_parser directive) to make URI parsing
</I>&gt;<i> restrictions more flexible than virtually-all-or-virtually-nothing
</I>&gt;<i> approach used today. I would not be surprised if we do see use cases
</I>&gt;<i> encouraging such changes. The patched code makes them easier.
</I>

The current situation is that loose input accepted by
Http1::RequestParser causes parsing to produce a true, which triggers
allocating a bunch of transaction state.
 This either did not happen before, or did not get so far into the
resource allocations because several repeat-parsing layers of sanity
checks used to exist after the old firstLine() parsing. Which are now
gone / melded into the new first-line parse checking.

 Then the final stage of allocations is to call urlParse() to allocate
the HttpRequest object itself. Which still rejects invalid URI input and
triggers de-allocating all the state again.

 Lots of wasted work and resource activity in the name of tolerance for
the 9! very rarely used characters which are outside the permitted set
for un-escaped transmission *in any protocol*.


FYI: the next stage of refactoring class URL is going to move urlParse()
into the class and I was hoping to have Http1::RequestParser use it
instead of a blind CharacterSet scan of the URI field.

 That way the URI is parsed + validated fully before
Http1::RequestParser accepts the first line and starts allocating more
resources than the buffer + parser already existant.

 We can then also do selective leniency for particular parts. eg
query-string only for {}|, query-string or path for space, etc.


I am okay with making it a tolerant parse. But we need to be as strict
as possible about what is accepted at the first-line parse because in
the end there will not be a second re-parse checking validity, and what
gets past the front-line already means resource allocations. If we screw
up entirely and it gets out the other end it is the remote server that
pays the price more than Squid internal store etc. Though it is popular
to have shell scripts parsing Squid logs, or SQL / JSON logging as well
get screwed up by these 9 chars.


&gt;<i> 
</I>&gt;&gt;<i> Squid may &quot;work&quot; as a consequence only because this code was the primary
</I>&gt;&gt;<i> security protection layer. Internal parsers later on (if any) are
</I>&gt;&gt;<i> sometimes less robust and picky.
</I>&gt;<i> 
</I>&gt;<i> I agree that inner layers may receive URIs they have never seen before
</I>&gt;<i> and that those URIs may crash those layers. However, they did receive
</I>&gt;<i> quite a variety before recent parser restrictions were added, and we
</I>&gt;<i> cannot fix bugs [in those other layers] that we do not know about.
</I>
Not always. There are 2-3 layers of sanity checks removed now.

For one example; there are stretches of ConnStateData,
ClientHttpRequest, and ClientSocketContext code that have never before
seen 0xC in a domain name. Now they will because anything be found in
query-string with generic whitespace tolerance (as opposed to just-SP
tolerance).
 Yes there are characters previously forbidden which are now allowed.
Going back is not always more tolerant.


&gt;&gt;<i> In these threads we have had around parsing I am getting the impression
</I>&gt;&gt;<i> you think of the HTTPbis WG documents as restrictive arbitrary committee
</I>&gt;&gt;<i> designs.
</I>&gt;<i> 
</I>&gt;<i> If we are talking about RFCs defining HTTP/1, then I think of them as
</I>&gt;<i> protocol specifications. Characterizing a protocol specification written
</I>&gt;<i> by a committee as &quot;restrictive arbitrary committee design&quot; does not
</I>&gt;<i> really help us do something useful AFAICT.
</I>&gt;<i> 
</I>&gt;<i> As an intermediary operating in an imperfect world, Squid has to achieve
</I>&gt;<i> the right balance of what to accept and what to send. IETF community has
</I>&gt;<i> struggled with finding that balance for a very long time, and I do not
</I>&gt;<i> think that struggle is over. Just because there is a real need to accept
</I>&gt;<i> some protocol-violating messages does not mean that HTTP RFCs should be
</I>&gt;<i> ignored or belittled, of course.
</I>&gt;<i> 
</I>
catch-22 at the top of a slippery slope we are halfway down.


&gt;<i> 
</I>&gt;&gt;<i> In the contrary they are explicity tested documents based on what the
</I>&gt;&gt;<i> real-world traffic has been actively observed doing over the past 10
</I>&gt;&gt;<i> years.
</I>&gt;<i> 
</I>&gt;<i> Very true! However, there are things that a protocol specification does
</I>&gt;<i> not and cannot cover. Looking at the specs alone is a doomed approach,
</I>&gt;<i> as illustrated by the restricted parser disaster.
</I>
It was no disaster. We now have documented some previously unknown
broken clients. When those are fixed and/or obsolete we can try again.
Eventually the protocol will work as designed and we can further
optimize without having to special-case for them on both input and
output translation to other protocols.


&gt;<i> 
</I>&gt;<i> I have no problems with Squid identifying protocol-violating messages if
</I>&gt;<i> there is some practical need in that. However, my focus is on what to do
</I>&gt;<i> with the received message. Blocking *all* protocol-violating messages is
</I>&gt;<i> not practical in most environments. Thus, we must consider things that
</I>&gt;<i> are not documented in the RFC into the equation and occasionally even
</I>&gt;<i> violate the RFC.
</I>
Any URI containing \`() { :; }; echo &quot;hi&quot; | cat &gt;&gt; /tmp/hello_world \`
(with back-quotes included) relays shell-chock vulnerability to backend
servers, log processing scripts, you name it.

... and is accepted by Squid RFC-violating parser but not RFC-compliant
parse. Thats using 7 of the 9 &quot;unwise&quot; chars BTW.  '{ }&gt; and |.


&gt;<i> 
</I>&gt;&gt;<i>  Where the real-world traffic was tracked down to malicious behaviour or
</I>&gt;&gt;<i> causing indirect vulnerability exposure it was explicitly forbidden.
</I>&gt;&gt;<i> Intro things like removal of URI user-info segment, explicit
</I>&gt;&gt;<i> single-digit HTTP version, forbidding of whitespace after &quot;HTTP/1.1&quot;
</I>&gt;&gt;<i> token, single SP delimiter in 'strict' parse, etc.
</I>&gt;<i> 
</I>&gt;<i> And I think Squid follows (or should follow) those protocol changes [at
</I>&gt;<i> least up to a point they start causing interoperability problems].
</I>&gt;<i> 
</I>
By following the prescribed behaviour Squid cannot be the cause of
interoperability problem. It is the victim.

By doing expressly forbidden things Squid *does* become the perpetrator
of any unwanted side effects. Acceptance of abuse being the cause.


&gt;<i> 
</I>&gt;&gt;&gt;<i> line parser. After getting a series of complaints and seeing admins
</I>&gt;&gt;&gt;<i> adding more and more exceptional URL characters to the existing trunk
</I>&gt;<i> 
</I>&gt;&gt;<i> I hope you can see the real problem is the admins approach to that
</I>&gt;&gt;<i> traffic.
</I>&gt;<i> 
</I>&gt;<i> We disagree on who to blame as the cause of the problem and who should
</I>&gt;<i> be responsible for fixing it. I doubt you have any new arguments that
</I>&gt;<i> can convince me that Squid should block benign traffic just because it
</I>&gt;<i> violates an RFC.
</I>
problem != blame.

The blame is the client softwares.

Problem is the admins choice to let the client get away with it while
punishing the victim (Squid) and forcing all the rest of us Squid users
who now have to put up with Squid accepting raw JSON or shell code
silently in URLs.


&gt;<i> 
</I>&gt;&gt;<i> AFAIK, the only non-permitted URI characters in current trunk are the
</I>&gt;&gt;<i> *binary* CTL characters. 
</I>&gt;<i> 
</I>&gt;<i> Sounds good. Could you define &quot;binary CTL characters&quot; so that I can use
</I>&gt;<i> the same set in the patched code, please?
</I>
Its no longer a defined set in its own right. RFC2396 defined it as
0x00-0x1F + 0x7F-0xFF but nowdays its more the disallowed hole left in
that area between the overlapping currently permitted sets for
whitespace and whatever the transport or encoding protocols use as
delimiters.

For HTTP that hole is:  0x1-0x8 + 0xE-0x1F + 0x7F-0xFF

Note that 0x80-0xFF are not disallowed, nor permitted either. &quot;reserved
for future use&quot; by the punycode people. UTF-8 URI support is gradually
being worked out, but not yet so we protect the space from squatters
until it matures.


&gt;<i> 
</I>&gt;&gt;<i> Squid does not even check for correct
</I>&gt;&gt;<i> positioning of delimiters in tollerant parse at this stage of the
</I>&gt;&gt;<i> processing.
</I>&gt;<i> 
</I>&gt;<i> Bugs notwithstanding, the new parser does require delimiters between
</I>&gt;<i> method, URI, and HTTP version.
</I>&gt;<i> 
</I>
The entire set of excluded characters are delimiters in one protocol or
another which may or may not be arriving on port 80/443 channels.

HTTP uses WspDelims. Which varies betwene tolerant and strict parsing
and also &quot;required&quot; by these same broken clients *within* the URI field.
So identifying which delimiter is a delimiter and which a un-escaped
data character is the core of the problem. As you should know well.

&gt;<i> 
</I>&gt;&gt;<i> Which makes me wonder exactly what these &quot;more and more&quot; extra
</I>&gt;&gt;<i> characters the admin are adding are? I hope you are referring to the
</I>&gt;&gt;<i> r14157 set, as opposed to people blindly trying to let those
</I>&gt;&gt;<i> request-line injection attacks Section 9.2 talks about work through
</I>&gt;&gt;<i> their proxies.
</I>&gt;<i> 
</I>&gt;<i> Section 9.2 does not talk about injection attacks; its scope is quite
</I>&gt;<i> different from the subject of this thread.
</I>
Its scope is an intermediary (ie. Squid) interpreting the protocol in
non-compliant ways (ie accepting invalid URI) and as a result performing
unexpected and undefined behaviours (ie converting invalid request to
valid request for something else). Particularly when used in the form of
MITM functionality (common for Squid).

Attacks are along the lines of accepting the shell-shock URL form and
%-escaping or mangling it in a way that gets it deliverd through an
unsuspecting protection layer at the server end so it can harm the
server backend. Which would not be possible if a) the client had sent
the same message to server directly, or b) Squid rejected the request as
invalid HTTP.


&gt;<i> You may be thinking of
</I>&gt;<i> Sections 9.4 and 9.5. I do not think the relaxed parser makes us more
</I>&gt;<i> susceptible to CRLF injection attacks (9.4). As for request smuggling
</I>&gt;<i> (9.5), I think that was possible before and is possible after the
</I>&gt;<i> changes because it requires two agents to interpret the same request
</I>&gt;<i> differently, something that will always be possible as long as there are
</I>&gt;<i> malformed requests and buggy agents.
</I>
Them too. But as you say thats more message framing issues. Your point
on LF detection being first avoids those.

&gt;&gt;&gt;<i> parser, I took the plunge and rewrote the existing code using the
</I>&gt;&gt;&gt;<i> approach recently discussed on this list.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This Http1::RequestParser has one purpose, and one only. To identify a
</I>&gt;&gt;<i> standards compliant (RFC 1945 or 7230) HTTP/1 request-line.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> All other inputs are undefined behaviour intended to be handled by other
</I>&gt;&gt;<i> Parsers. Some in future, some already existing (ie FTP).
</I>&gt;<i> 
</I>&gt;<i> I disagree that Http1::RequestParser purpose is to identify standards
</I>&gt;<i> compliant HTTP/1 request-lines. Moreover, I doubt that a parser with
</I>&gt;<i> that purpose is really needed in Squid (beyond academic exercises and
</I>&gt;<i> experiments).
</I>
Then why did I bother calling it an HTTP/1 parser and documenting all
that protocol operations that it does.

Surely its a whiz-bang-anything-goes-actuator. No?
 Perhapse I mistook an IRC protocol parser ?
 Maybe &quot;class RequestParser&quot; is a HTTP *response* parser ?

No. Its purpose is to identify and parse HTTP request-line and identify
the start-end of an (optional) mime-header that may follow.  We have
other FooParser classes for other message types and protocols. If this
parser rejects something it means its not an HTTP message. Try a
different Parser.

&gt;&gt;<i> Non-incremental will also re-introduce admin complaints about high CPU
</I>&gt;&gt;<i> consumption on traffic where they receive long URLs over a number of
</I>&gt;&gt;<i> very small packets. ie the traffic which is normal, valid but looks like
</I>&gt;&gt;<i> Slow Loris (or is actually).
</I>&gt;<i> 
</I>&gt;<i> AFAICT, the incremental parser in trunk does not parse URI fields
</I>&gt;<i> incrementally so the proposed parser is not making the above situation
</I>&gt;<i> worse. A quote from the trunk code:
</I>&gt;<i> 
</I>&gt;<i>   tok.reset(buf_);
</I>&gt;<i>   if (tok.prefix(line, LfDelim) &amp;&amp; tok.skip('\n')) { ... }
</I>&gt;<i>   if (!tok.atEnd()) { ... }
</I>&gt;<i>   debugs(74, 5, &quot;Parser needs more data&quot;);
</I>&gt;<i>   return 0;
</I>&gt;<i> 
</I>&gt;<i> The &quot;...&quot; code does not run while we accumulate the input buffer to find
</I>&gt;<i> the end of the URI. Thus, we exit with what we came with until the whole
</I>&gt;<i> URI is available. No incremental URI parsing.
</I>
The bit you quote is what you are seeking to make the *entire* parser
into. Pull in whole line before validating.

With a quick switch of relaxed_header_parser on. One goes to the other
parsing path which (could) validate each character as it goes and just
globs the resulting buffer section into storage as URL.


&gt;<i> 
</I>&gt;&gt;<i> Note that real-world URLs have a *minimum* accepted limit of 4KB now,
</I>&gt;&gt;<i> and sightings have been measured with URL as high as 200KB in length
</I>&gt;&gt;<i> from some domains. Most origin servers wont accept &gt;32KB though.
</I>&gt;<i> 
</I>&gt;<i> Yes, we must handle long URIs. I already have non-triaged bug reports
</I>&gt;<i> that trunk no longer accepts them. That is a separate issue though.
</I>&gt;<i> 
</I>
One that I would like to get to the bottom of. Because old Squid
accepted 0-65534 byte URLs. Current trunk accepts 0-65524 byte URLs.
Hardly a big change to length, and neither actually include the magic
65535 / 64KB number.


BTW that length reduction is directly due to the size of &quot; HTTP/1.1\r&quot;
which has to be pulled into a 64K buffer then reverse-parsed out again
by the relaxed parsing mode. Strict parse accepts full 65535 bytes in
just the URI field.

If we add a 32 byte method in the line buffer too ...

Maybe its the long-polling people. Sending &quot;GET&quot; followed by KB of SP
characters one per second then trying to fit a long URL in as well.

Old Squid used to not count the OSP against request message size.


&gt;&gt;<i> * I believe we can retain incremental parsing despite your changes here.
</I>&gt;&gt;<i> As noted above its use was a fairly major protection against some very
</I>&gt;&gt;<i> trivial attack vectors.
</I>&gt;&gt;<i>  - I agree the current incremental implementation is not optimal, but
</I>&gt;&gt;<i> rather fix than removing completely IMO.
</I>&gt;<i> 
</I>&gt;<i> The old incremental parsing was not offering us anything worth
</I>&gt;<i> preserving it for. I agree that it is possible to add *useful*
</I>&gt;<i> incremental parsing. That work should be driven by specific scenarios we
</I>&gt;<i> want to address though.
</I>
It was offering full 65535 byte URI fields limits. As mentioned above.



Amos
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002930.html">[squid-dev] Jenkins build is back to normal : trunk-polygraph #798
</A></li>
	<LI>Next message: <A HREF="002931.html">[squid-dev] [CODE] iterating over enums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2928">[ date ]</a>
              <a href="thread.html#2928">[ thread ]</a>
              <a href="subject.html#2928">[ subject ]</a>
              <a href="author.html#2928">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
