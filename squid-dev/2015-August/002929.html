<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HttpHeader%20migration%20%28coverity-fixes%20branch%29&In-Reply-To=%3CCA%2BY8hcMUxAvnqYRSdj6Bwjw1NbCmidpk8nYjTykqx%3DcY%3DJJboA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002927.html">
   <LINK REL="Next"  HREF="002936.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HttpHeader%20migration%20%28coverity-fixes%20branch%29&In-Reply-To=%3CCA%2BY8hcMUxAvnqYRSdj6Bwjw1NbCmidpk8nYjTykqx%3DcY%3DJJboA%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)">gkinkie at gmail.com
       </A><BR>
    <I>Wed Aug  5 13:58:05 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002927.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
        <LI>Next message: <A HREF="002936.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2929">[ date ]</a>
              <a href="thread.html#2929">[ thread ]</a>
              <a href="subject.html#2929">[ subject ]</a>
              <a href="author.html#2929">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Aug 5, 2015 at 4:08 AM, Amos Jeffries &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid3 at treenet.co.nz</A>&gt; wrote:

&gt;<i> On 5/08/2015 9:08 a.m., Kinkie wrote:
</I>&gt;<i> &gt; On Tue, Aug 4, 2015 at 2:58 PM, Amos Jeffries wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; On 4/08/2015 11:22 p.m., Kinkie wrote:
</I>&gt;<i> &gt;&gt;&gt; Hi all,
</I>&gt;<i> &gt;&gt;&gt;   the attached patch is a build- and run-tested merge proposal for next
</I>&gt;<i> &gt;&gt;&gt; round of the coverity-fixes branch, currently focusing on more
</I>&gt;<i> effective
</I>&gt;<i> &gt;&gt;&gt; header name -&gt; id lookups.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; Here's the status with the current todo checklist:
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;  * DONE 1. shift HDR_BAD_HDR to end of enum
</I>&gt;<i> &gt;&gt;&gt;  * DONE 2. shift headers data array to http/RegistredHeaders.cc
</I>&gt;<i> &gt;&gt;&gt;  * DONE 3. creatign LookupTable object from teh enum and array
</I>&gt;<i> &gt;&gt;&gt;  * (with HDR_BAD_HDR as invalid value)
</I>&gt;<i> &gt;&gt;&gt;  * DONE 4. replacing httpHeaderIdByName() uses with the lookup table
</I>&gt;<i> &gt;&gt;&gt;  * NOT POSSIBLE 5. merge HDR_BAD_HDR and HDR_ENUM_END into one thing -
</I>&gt;<i> &gt;&gt;&gt; HDR_ENUM_END is overloaded meaning &quot;All&quot; headers in Manglers.
</I>&gt;<i> &gt;&gt;&gt;  * DONE 6. replacing httpHeaderNameById with direct array lookups
</I>&gt;<i> &gt;&gt;&gt;  * DONE 7. being looking at the other arrays removal
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; In working on this I found out several instances of enum abuses -
</I>&gt;<i> &gt;&gt; tracking
</I>&gt;<i> &gt;&gt;&gt; those down has been the hardest part of the effort.
</I>&gt;<i> &gt;&gt;&gt; HttpHeader::parse is being used to parse error page templates - thus
</I>&gt;<i> the
</I>&gt;<i> &gt;&gt;&gt; relaxed any_registered_header() checks in some methods, e.g.
</I>&gt;<i> &gt;&gt;&gt; HttpHdeader::addEntry().
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; Next steps, if there is consensus:
</I>&gt;<i> &gt;&gt;&gt; - moving LookupTable away from std::map to std::hash with custom
</I>&gt;<i> &gt;&gt;&gt; gperf-derived Hashers for extra boost
</I>&gt;<i> &gt;&gt;&gt; - investigating whether strongly-typed enums can be used instead of
</I>&gt;<i> &gt;&gt; C-style
</I>&gt;<i> &gt;&gt;&gt; enums in more places.
</I>&gt;<i> &gt;&gt;&gt; - moving away from homegrown bitfields (CBIT_TEST etc.) towards
</I>&gt;<i> &gt;&gt;&gt; std::vector&lt;bool&gt; or std::vector&lt;unsigned char&gt;, possibly via a class
</I>&gt;<i> &gt;&gt;&gt; bitfield or somesuch.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; audit results:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; * httpHdrCcCleanModule() and httpHdrScCleanModule() can both be fully
</I>&gt;<i> &gt;&gt; deleted now.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yes. I chose to let them in: they are NOPs, not in the critical path, and
</I>&gt;<i> &gt; may be useful in the future. Let me know if you still want them removed.
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> :-( more 'dead' code. This kind of thing is useful for
</I>&gt;<i> ctpr/dtor/functor/virtual definition. But C functions that are not even
</I>&gt;<i> used as functors is a waste of LOC and also compiler time dealing with
</I>&gt;<i> the symbols.
</I>&gt;<i>  Its minor but still technical debt. The long-term plan is also to use
</I>&gt;<i> RegisteredRunners for this type of thing not C functions.
</I>&gt;<i>
</I>
Ok. Removed all empty module cleanup functions - which are only invoked if
LEAKCHECK is enabled anyway.

&gt;&gt;<i> * LookupTableRecord should be a class.
</I>&gt;<i> &gt;&gt;  - custom storage types can then inherit from it, with it as the first
</I>&gt;<i> &gt;&gt; parent
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Well, templatization can prevent that need, but sure. Should I implement
</I>&gt;<i> &gt; that?
</I>&gt;<i> &gt; Isn't nowadays a struct == all-public class though? It looks odd, but
</I>&gt;<i> &gt; functionally is the same
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> Avoid &quot;looks odd&quot; whenever possible :-) as you say, the compiler dont
</I>&gt;<i> care. But this is about us humans quick and easy reading it in 10 years
</I>&gt;<i> time.
</I>&gt;<i>
</I>&gt;<i> I think its okay for useful code optimizations. Bt then the design
</I>&gt;<i> choice needs documenting so nobody breaks or undoes it casually.
</I>&gt;<i>
</I>
Ok.


&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; in src/HttpHeader.cc:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; * can you move the headerLookupTable to src/http/RegisteredHeaders.cc
</I>&gt;<i> &gt;&gt; and the Http:: namespace as well please ?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Moved to RegisteredHeaders and renamed HDR_FOO to Http::HdrType::FOO .
</I>&gt;<i> &gt; Moving to a strongly-typed enum is unfortunately not feasible as eCAP
</I>&gt;<i> &gt; requires integer-enum equivalence; it may be that the whole change has to
</I>&gt;<i> &gt; be reverted.
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> I thought &quot;enum class&quot; with first parameter value assigned 0
</I>&gt;<i> (&quot;HDR_ACCEPT = 0,&quot;) should do that. ie. strongly typed to unsigned
</I>&gt;<i> integer values.
</I>&gt;<i>
</I>
No.
strongly-typed == doesn't automatically cast to int, if you use
strongly-typed you have to static_cast, while for old-style enum casting is
automatic.

in c++11 the full enum syntax (square brackets mean optional) is
enum [ class ] enumName [ : storage_specification ] {
  enum_elem_1 [ = elem-1-representation ],
  ...
};

where storage_specification is the underlying integral data type.
Using the optional &quot;class&quot; specification disables auto-cast-to-int.
Elements can then be referenced by enumName::enum_elem_name , where the
enumName specification is mandatory for &quot;enum class&quot;, optional for
old-style enum.

BTW: I've tried changing the underlying storage to unsigned, and I get
asserts in masks calculation.


&gt;<i> &gt;&gt; * any_registered_header() is wrong.
</I>&gt;<i> &gt;&gt;  - it matches for HDR_OTHER which by definition is a non-registered
</I>&gt;<i> header
</I>&gt;<i> &gt;&gt;  - assert_eid() is equivalent to any_valid_header()
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Then we need to change name. We need two semantics:
</I>&gt;<i> &gt; 1) any header which is valid and defined (including OTHER)
</I>&gt;<i> &gt; 2) any header ID which will not go out-of-bounds (same as (1) +
</I>&gt;<i> HDR_BAD_HDR)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; any suggestion?
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> (1) is already any_valid_header().
</I>&gt;<i>
</I>&gt;<i> (2) any_HdrType_enum_value()
</I>&gt;<i>
</I>&gt;<i> But where/why do we need (2) ?
</I>&gt;<i>  Any value input or received that is non-(1) needs to be represented as
</I>&gt;<i> BAD_HDR when parsing/validating the input to an enum value.
</I>&gt;<i>
</I>
It's sprinkled all over the place, mostly meant to protect against
int-related abuses which may end up causing out of bounds in arrays,
vectors and masks. Moving to enum class would mean implicit safety in this
regard, but would require accessor functions to ensure consistent checks in
typecasts. Hello again HdrIdFromName and HdrDescFromId. I'm cool with it,
if that's a wise design decision in your opinion. It'd save the need of a
dozen asserts or so.


&gt;<i> Are you looking at things HttpHeader.cc line ~524:
</I>&gt;<i>
</I>&gt;<i> AA)
</I>&gt;<i>
</I>&gt;<i> +  if (e-&gt;id &gt;= Http::HdrType::ENUM_END) {
</I>&gt;<i>     debugs(55, DBG_CRITICAL, &quot;BUG: invalid entry (&quot; &lt;&lt; e-&gt;id &lt;&lt; &quot;)...
</I>&gt;<i>
</I>&gt;<i> That should probably be if(!any_valid_header(e-&gt;id)) since BAD is also
</I>&gt;<i> invalid entry value for a header.
</I>&gt;<i>
</I>
aha, got it and turned in all places where ENUM_END is used to this end.


&gt;<i> If the logic there explicitly requires BAD handling, it should be:
</I>&gt;<i>   // some reason for why BAD is accepted as 'valid'.
</I>&gt;<i>   if(!any_valid_header(e-&gt;id) &amp;&amp; e-&gt;id != BAD)
</I>&gt;<i>
</I>&gt;<i> Although note that when parsing is fixed BAD will represent *any*
</I>&gt;<i> invalid value.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> or BB) the header manglers &quot;All&quot; ?
</I>&gt;<i>
</I>&gt;<i> For that I think we need a new enum value like &quot;Other,&quot;  (&quot;All,&quot; ?)
</I>&gt;<i> which is outside registered headers, but valid only as an enum entry.
</I>&gt;<i> Currently END, but that needs a rename and never to be used by
</I>&gt;<i> non-mangler code.
</I>&gt;<i>
</I>



&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;  - please consider removing the assert(assert(any_valid_header(id)))
</I>&gt;<i> &gt;&gt;    it could probably be replaced by:
</I>&gt;<i> &gt;&gt;       if (!assert(any_valid_header(id)))
</I>&gt;<i> &gt;&gt;           id = HDR_OTHER
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Huh? I can't find any nested assert
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> copy-paste error on my part. It is the assert you are adding three lines
</I>&gt;<i> below what is now &quot;got hdr-id=&quot; in the chunk @1512.
</I>&gt;<i>
</I>&gt;<i> I can't see the function name, but it looks like parsing some input.
</I>&gt;<i> Avoid assert in all parsers. Output BAD or OTHER as appropriate instead.
</I>&gt;<i>
</I>
It's HttpHeader::parse.
That assert is actually useless: it's set by a HeaderLookupTable.lookup.
It's guaranteed to be valid (if BAD, and the BAD case is handled by
reassigning to OTHER.
Removing that assert full stop.


&gt;<i> I been thinking a bit more (sorry dangerous).
</I>&gt;<i>
</I>&gt;<i> It may be worth adjusting the src/mk-string-arrays.awk script to also be
</I>&gt;<i> capable of output LookupTable&lt;X&gt;::Record arrays. That script is designed
</I>&gt;<i> to guarantee invariance. Though it does leave us with another .cc.
</I>&gt;<i> Anyhow thats a followup to think about, not in this scope.
</I>&gt;<i>
</I>
I agree on it not being in scope. Also because if we wish to use gperf to
generate the perfect hashes, then gperf could (and thus should) do that for
us (see
<A HREF="http://www.gnu.org/software/gperf/manual/html_node/User_002dsupplied-Struct.html#User_002dsupplied-Struct">http://www.gnu.org/software/gperf/manual/html_node/User_002dsupplied-Struct.html#User_002dsupplied-Struct</A>
)


&gt;<i> second round audit:
</I>&gt;<i>
</I>&gt;<i> in src/HttpHdrCc.cc:
</I>&gt;<i>
</I>&gt;<i> * valid_id in httpHdrCcStatDumper() can probably be a const bool like
</I>&gt;<i> the other.
</I>&gt;<i>
</I>
Yes. Done.

in src/HttpHdrSc.cc:
&gt;<i>
</I>&gt;<i> * useless include of dlink.h since its done in the .h
</I>&gt;<i>
</I>
Ok.


&gt;<i>
</I>&gt;<i> * a duplicate include of HttpHdrSc.h since its pulled in by
</I>&gt;<i> HttpHdrScTarget.h.
</I>&gt;<i>  - but in this case I think replece it with:
</I>&gt;<i>   //#include &quot;HttpHdrSc.h&quot; // pulled in by HttpHdrScTarget.h
</I>&gt;<i>
</I>
Done. Good idea, it'd look odd otherwise.


&gt;<i>
</I>&gt;<i> in src/HttpHdrSc.h:
</I>&gt;<i>
</I>&gt;<i> * please use mem/forward.h instead of mem/AllocatorProxy.h
</I>&gt;<i>
</I>
Ok


&gt;<i>
</I>&gt;<i> * please store the class pre-defines alphabetically.
</I>&gt;<i>  - Packable above StatHist.
</I>&gt;<i>
</I>
Done.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> in src/HttpHdrScTarget.cc:
</I>&gt;<i>
</I>&gt;<i> * useless include of HttpHdrSc.h
</I>&gt;<i>  - thanks for fixing the missing HttpHdrScTarget.h
</I>&gt;<i>
</I>
Done. NP :)


&gt;<i> in src/HttpHdrScTarget.h:
</I>&gt;<i>
</I>&gt;<i> * now has useless include of mem/forward.h (after above fix),
</I>&gt;<i> SquidString.h, dlink.h, typedefs.h
</I>&gt;<i>
</I>&gt;<i> Ok.
</I>

&gt;<i> in src/HttpHeader.cc:
</I>&gt;<i>
</I>&gt;<i> * please take the opportunity to remove useless includes overlapping
</I>&gt;<i> with HttpHdrCc.h and HttpHdrSc.h
</I>&gt;<i>
</I>
Done. I've commented them and mentioned the indirect inclusion in a comment.


&gt;<i> * please replace include fof HttpHdrSc.h with HttpHdrScTarget.h in the
</I>&gt;<i> new include nesting.
</I>&gt;<i>  - also checking for duplicate includes between HttpHdrScTarget.h and
</I>&gt;<i> HttpHeader.cc
</I>&gt;<i>
</I>
Ok.


&gt;<i> * chunk @562, s/NULL/nullptr/
</I>&gt;<i>  - maybe others in the touched lines
</I>&gt;<i>
</I>
Done.


&gt;<i>
</I>&gt;<i> * HttpHeaderEntry dtor use of assert(any_valid_header(id)); at the top
</I>&gt;<i> is needless.
</I>&gt;<i>  - protect the stats accounting against BAD though
</I>&gt;<i>
</I>
Done.


&gt;<i>
</I>&gt;<i> * HttpHeaderEntry ctor accepts OTHER but also &quot;anId != BAD&quot; implies that
</I>&gt;<i> it accepts BAD as well despite the previous
</I>&gt;<i> assert(any_registered_header(anId)).
</I>&gt;<i>  - wrap the stats accounting in if (id != BAD).
</I>&gt;<i>
</I>
done


&gt;<i>
</I>&gt;<i>  - fixing those ctor/dtor asserts will avoid any potential for assertion
</I>&gt;<i> from temporary default- or partially- constructed objects, or bad
</I>&gt;<i> emplacement destructions.
</I>&gt;<i>
</I>
..which are not there, or we'd assert all over the place. But sure.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> in src/acl/RequestHeaderStrategy.h:
</I>&gt;<i>
</I>&gt;<i>  * please take the opportunity to remove that empty line between
</I>&gt;<i> 'template' and 'class' at lines at ~14
</I>&gt;<i>
</I>
Done


&gt;<i> in src/http/RegisteredHeaders.cc:
</I>&gt;<i>
</I>&gt;<i> * please add empty line between namespace '{' and start of comment.
</I>&gt;<i>
</I>
Ok


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> in src/http/RegisteredHeaders.h:
</I>&gt;<i>
</I>&gt;<i> * please document on HeaderTable that lookup() will return BAD if the
</I>&gt;<i> header is unknown / unregistered. callers need to check and handle that
</I>&gt;<i> case properly.
</I>&gt;<i>
</I>
Ok.


&gt;<i> I think that is all. And all polish :-)
</I>&gt;<i>
</I>&gt;<i> +1 on this so far. Though you/we still need to sort the valid registered
</I>&gt;<i> ID tests before commit.
</I>&gt;<i>
</I>
I think I have fixed those, although it's hard to be sure - layering
violations all over the place.


&gt;<i> NOTE: these are about old bugs you are uncovering. I'd like to take the
</I>&gt;<i> opportunity to fix them. But this is already huge, so for now just XXX
</I>&gt;<i> mark it and followup patch.
</I>&gt;<i>
</I>

Like many other areas, there is (plenty of) room for improvement :)
If not performance-wise, certainly code-wise.
I'd leave them as a follow-up effort.


&gt;<i>
</I>&gt;<i> * I'm still not clear on why insertEntry() checks for valid header enum
</I>&gt;<i> values but addEntry() needs to accept BAD.
</I>&gt;<i>  - if that need is true its worth a comment to document. otherwise
</I>&gt;<i> update top of addEntry() to match insertEntry().
</I>&gt;<i>  - NP: we should *never* be adding a BAD/invalid header entry to a
</I>&gt;<i> message object. Custom ones yes, but they are OTHER.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> * like has() all the has/put/get*(ID, ...) methods need to exclude BAD
</I>&gt;<i> and OTHER as a valid inputs.
</I>&gt;<i>  - OTHER means we are accessing and using the Entry by string name, not
</I>&gt;<i> by ID value.
</I>&gt;<i>  - BAD means we should never have put it into object in the first place.
</I>&gt;<i>  - the put*(ID, ...) accepting OTHER may be where addEntry(ID,...) goes
</I>&gt;<i> wrong.
</I>&gt;<i>  - sorry these seem to have got caught in cleaning up one of my earlier
</I>&gt;<i> comments which was about another changed use of assert_eid().
</I>&gt;<i> assert_eid() test was wrong for these get/put/has*(ID,...) to begin with.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> [[ httpHeaderFieldStatDumper() earning itself a place in the hall of
</I>&gt;<i> horrors :-(
</I>&gt;<i>   ..., double val, ...
</I>&gt;<i>   const int id = static_cast&lt;int&gt;(val);
</I>&gt;<i>   const bool valid_id = id &lt; Http::HdrType::ENUM_END;
</I>&gt;<i>  // back away, quietly ...
</I>&gt;<i> ]]
</I>&gt;<i>
</I>&gt;<i>
</I>
-- 
    Francesco
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150805/66370516/attachment-0001.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150805/66370516/attachment-0001.html</A>&gt;
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002927.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
	<LI>Next message: <A HREF="002936.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2929">[ date ]</a>
              <a href="thread.html#2929">[ thread ]</a>
              <a href="subject.html#2929">[ subject ]</a>
              <a href="author.html#2929">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
