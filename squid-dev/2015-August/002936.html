<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HttpHeader%20migration%20%28coverity-fixes%20branch%29&In-Reply-To=%3CCA%2BY8hcPKRZ%3DTQ8heOCHs%3DFrDtF7TeRsE7GNjnOf%3DRguLht4OYQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002929.html">
   <LINK REL="Next"  HREF="002924.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HttpHeader%20migration%20%28coverity-fixes%20branch%29&In-Reply-To=%3CCA%2BY8hcPKRZ%3DTQ8heOCHs%3DFrDtF7TeRsE7GNjnOf%3DRguLht4OYQ%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)">gkinkie at gmail.com
       </A><BR>
    <I>Thu Aug  6 07:31:15 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002929.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
        <LI>Next message: <A HREF="002924.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2936">[ date ]</a>
              <a href="thread.html#2936">[ thread ]</a>
              <a href="subject.html#2936">[ subject ]</a>
              <a href="author.html#2936">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Merged as revision 14210 with some minor added polish (ostream&lt;&lt; for
HttpHdrCcType and Http::HdrType).

On Wed, Aug 5, 2015 at 3:58 PM, Kinkie &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">gkinkie at gmail.com</A>&gt; wrote:

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Wed, Aug 5, 2015 at 4:08 AM, Amos Jeffries &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid3 at treenet.co.nz</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On 5/08/2015 9:08 a.m., Kinkie wrote:
</I>&gt;&gt;<i> &gt; On Tue, Aug 4, 2015 at 2:58 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;&gt; On 4/08/2015 11:22 p.m., Kinkie wrote:
</I>&gt;&gt;<i> &gt;&gt;&gt; Hi all,
</I>&gt;&gt;<i> &gt;&gt;&gt;   the attached patch is a build- and run-tested merge proposal for
</I>&gt;&gt;<i> next
</I>&gt;&gt;<i> &gt;&gt;&gt; round of the coverity-fixes branch, currently focusing on more
</I>&gt;&gt;<i> effective
</I>&gt;&gt;<i> &gt;&gt;&gt; header name -&gt; id lookups.
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt; Here's the status with the current todo checklist:
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt;  * DONE 1. shift HDR_BAD_HDR to end of enum
</I>&gt;&gt;<i> &gt;&gt;&gt;  * DONE 2. shift headers data array to http/RegistredHeaders.cc
</I>&gt;&gt;<i> &gt;&gt;&gt;  * DONE 3. creatign LookupTable object from teh enum and array
</I>&gt;&gt;<i> &gt;&gt;&gt;  * (with HDR_BAD_HDR as invalid value)
</I>&gt;&gt;<i> &gt;&gt;&gt;  * DONE 4. replacing httpHeaderIdByName() uses with the lookup table
</I>&gt;&gt;<i> &gt;&gt;&gt;  * NOT POSSIBLE 5. merge HDR_BAD_HDR and HDR_ENUM_END into one thing -
</I>&gt;&gt;<i> &gt;&gt;&gt; HDR_ENUM_END is overloaded meaning &quot;All&quot; headers in Manglers.
</I>&gt;&gt;<i> &gt;&gt;&gt;  * DONE 6. replacing httpHeaderNameById with direct array lookups
</I>&gt;&gt;<i> &gt;&gt;&gt;  * DONE 7. being looking at the other arrays removal
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt; In working on this I found out several instances of enum abuses -
</I>&gt;&gt;<i> &gt;&gt; tracking
</I>&gt;&gt;<i> &gt;&gt;&gt; those down has been the hardest part of the effort.
</I>&gt;&gt;<i> &gt;&gt;&gt; HttpHeader::parse is being used to parse error page templates - thus
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> &gt;&gt;&gt; relaxed any_registered_header() checks in some methods, e.g.
</I>&gt;&gt;<i> &gt;&gt;&gt; HttpHdeader::addEntry().
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt; Next steps, if there is consensus:
</I>&gt;&gt;<i> &gt;&gt;&gt; - moving LookupTable away from std::map to std::hash with custom
</I>&gt;&gt;<i> &gt;&gt;&gt; gperf-derived Hashers for extra boost
</I>&gt;&gt;<i> &gt;&gt;&gt; - investigating whether strongly-typed enums can be used instead of
</I>&gt;&gt;<i> &gt;&gt; C-style
</I>&gt;&gt;<i> &gt;&gt;&gt; enums in more places.
</I>&gt;&gt;<i> &gt;&gt;&gt; - moving away from homegrown bitfields (CBIT_TEST etc.) towards
</I>&gt;&gt;<i> &gt;&gt;&gt; std::vector&lt;bool&gt; or std::vector&lt;unsigned char&gt;, possibly via a class
</I>&gt;&gt;<i> &gt;&gt;&gt; bitfield or somesuch.
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; audit results:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; * httpHdrCcCleanModule() and httpHdrScCleanModule() can both be fully
</I>&gt;&gt;<i> &gt;&gt; deleted now.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Yes. I chose to let them in: they are NOPs, not in the critical path,
</I>&gt;&gt;<i> and
</I>&gt;&gt;<i> &gt; may be useful in the future. Let me know if you still want them removed.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> :-( more 'dead' code. This kind of thing is useful for
</I>&gt;&gt;<i> ctpr/dtor/functor/virtual definition. But C functions that are not even
</I>&gt;&gt;<i> used as functors is a waste of LOC and also compiler time dealing with
</I>&gt;&gt;<i> the symbols.
</I>&gt;&gt;<i>  Its minor but still technical debt. The long-term plan is also to use
</I>&gt;&gt;<i> RegisteredRunners for this type of thing not C functions.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok. Removed all empty module cleanup functions - which are only invoked if
</I>&gt;<i> LEAKCHECK is enabled anyway.
</I>&gt;<i>
</I>&gt;<i> &gt;&gt; * LookupTableRecord should be a class.
</I>&gt;&gt;<i> &gt;&gt;  - custom storage types can then inherit from it, with it as the first
</I>&gt;&gt;<i> &gt;&gt; parent
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Well, templatization can prevent that need, but sure. Should I implement
</I>&gt;&gt;<i> &gt; that?
</I>&gt;&gt;<i> &gt; Isn't nowadays a struct == all-public class though? It looks odd, but
</I>&gt;&gt;<i> &gt; functionally is the same
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Avoid &quot;looks odd&quot; whenever possible :-) as you say, the compiler dont
</I>&gt;&gt;<i> care. But this is about us humans quick and easy reading it in 10 years
</I>&gt;&gt;<i> time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think its okay for useful code optimizations. Bt then the design
</I>&gt;&gt;<i> choice needs documenting so nobody breaks or undoes it casually.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;&gt; in src/HttpHeader.cc:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; * can you move the headerLookupTable to src/http/RegisteredHeaders.cc
</I>&gt;&gt;<i> &gt;&gt; and the Http:: namespace as well please ?
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Moved to RegisteredHeaders and renamed HDR_FOO to Http::HdrType::FOO .
</I>&gt;&gt;<i> &gt; Moving to a strongly-typed enum is unfortunately not feasible as eCAP
</I>&gt;&gt;<i> &gt; requires integer-enum equivalence; it may be that the whole change has
</I>&gt;&gt;<i> to
</I>&gt;&gt;<i> &gt; be reverted.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I thought &quot;enum class&quot; with first parameter value assigned 0
</I>&gt;&gt;<i> (&quot;HDR_ACCEPT = 0,&quot;) should do that. ie. strongly typed to unsigned
</I>&gt;&gt;<i> integer values.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> No.
</I>&gt;<i> strongly-typed == doesn't automatically cast to int, if you use
</I>&gt;<i> strongly-typed you have to static_cast, while for old-style enum casting is
</I>&gt;<i> automatic.
</I>&gt;<i>
</I>&gt;<i> in c++11 the full enum syntax (square brackets mean optional) is
</I>&gt;<i> enum [ class ] enumName [ : storage_specification ] {
</I>&gt;<i>   enum_elem_1 [ = elem-1-representation ],
</I>&gt;<i>   ...
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> where storage_specification is the underlying integral data type.
</I>&gt;<i> Using the optional &quot;class&quot; specification disables auto-cast-to-int.
</I>&gt;<i> Elements can then be referenced by enumName::enum_elem_name , where the
</I>&gt;<i> enumName specification is mandatory for &quot;enum class&quot;, optional for
</I>&gt;<i> old-style enum.
</I>&gt;<i>
</I>&gt;<i> BTW: I've tried changing the underlying storage to unsigned, and I get
</I>&gt;<i> asserts in masks calculation.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> &gt;&gt; * any_registered_header() is wrong.
</I>&gt;&gt;<i> &gt;&gt;  - it matches for HDR_OTHER which by definition is a non-registered
</I>&gt;&gt;<i> header
</I>&gt;&gt;<i> &gt;&gt;  - assert_eid() is equivalent to any_valid_header()
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Then we need to change name. We need two semantics:
</I>&gt;&gt;<i> &gt; 1) any header which is valid and defined (including OTHER)
</I>&gt;&gt;<i> &gt; 2) any header ID which will not go out-of-bounds (same as (1) +
</I>&gt;&gt;<i> HDR_BAD_HDR)
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; any suggestion?
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (1) is already any_valid_header().
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (2) any_HdrType_enum_value()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But where/why do we need (2) ?
</I>&gt;&gt;<i>  Any value input or received that is non-(1) needs to be represented as
</I>&gt;&gt;<i> BAD_HDR when parsing/validating the input to an enum value.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It's sprinkled all over the place, mostly meant to protect against
</I>&gt;<i> int-related abuses which may end up causing out of bounds in arrays,
</I>&gt;<i> vectors and masks. Moving to enum class would mean implicit safety in this
</I>&gt;<i> regard, but would require accessor functions to ensure consistent checks in
</I>&gt;<i> typecasts. Hello again HdrIdFromName and HdrDescFromId. I'm cool with it,
</I>&gt;<i> if that's a wise design decision in your opinion. It'd save the need of a
</I>&gt;<i> dozen asserts or so.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Are you looking at things HttpHeader.cc line ~524:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AA)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> +  if (e-&gt;id &gt;= Http::HdrType::ENUM_END) {
</I>&gt;&gt;<i>     debugs(55, DBG_CRITICAL, &quot;BUG: invalid entry (&quot; &lt;&lt; e-&gt;id &lt;&lt; &quot;)...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That should probably be if(!any_valid_header(e-&gt;id)) since BAD is also
</I>&gt;&gt;<i> invalid entry value for a header.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> aha, got it and turned in all places where ENUM_END is used to this end.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> If the logic there explicitly requires BAD handling, it should be:
</I>&gt;&gt;<i>   // some reason for why BAD is accepted as 'valid'.
</I>&gt;&gt;<i>   if(!any_valid_header(e-&gt;id) &amp;&amp; e-&gt;id != BAD)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Although note that when parsing is fixed BAD will represent *any*
</I>&gt;&gt;<i> invalid value.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> or BB) the header manglers &quot;All&quot; ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For that I think we need a new enum value like &quot;Other,&quot;  (&quot;All,&quot; ?)
</I>&gt;&gt;<i> which is outside registered headers, but valid only as an enum entry.
</I>&gt;&gt;<i> Currently END, but that needs a rename and never to be used by
</I>&gt;&gt;<i> non-mangler code.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;  - please consider removing the assert(assert(any_valid_header(id)))
</I>&gt;&gt;<i> &gt;&gt;    it could probably be replaced by:
</I>&gt;&gt;<i> &gt;&gt;       if (!assert(any_valid_header(id)))
</I>&gt;&gt;<i> &gt;&gt;           id = HDR_OTHER
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Huh? I can't find any nested assert
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> copy-paste error on my part. It is the assert you are adding three lines
</I>&gt;&gt;<i> below what is now &quot;got hdr-id=&quot; in the chunk @1512.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I can't see the function name, but it looks like parsing some input.
</I>&gt;&gt;<i> Avoid assert in all parsers. Output BAD or OTHER as appropriate instead.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It's HttpHeader::parse.
</I>&gt;<i> That assert is actually useless: it's set by a HeaderLookupTable.lookup.
</I>&gt;<i> It's guaranteed to be valid (if BAD, and the BAD case is handled by
</I>&gt;<i> reassigning to OTHER.
</I>&gt;<i> Removing that assert full stop.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I been thinking a bit more (sorry dangerous).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It may be worth adjusting the src/mk-string-arrays.awk script to also be
</I>&gt;&gt;<i> capable of output LookupTable&lt;X&gt;::Record arrays. That script is designed
</I>&gt;&gt;<i> to guarantee invariance. Though it does leave us with another .cc.
</I>&gt;&gt;<i> Anyhow thats a followup to think about, not in this scope.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I agree on it not being in scope. Also because if we wish to use gperf to
</I>&gt;<i> generate the perfect hashes, then gperf could (and thus should) do that for
</I>&gt;<i> us (see
</I>&gt;<i> <A HREF="http://www.gnu.org/software/gperf/manual/html_node/User_002dsupplied-Struct.html#User_002dsupplied-Struct">http://www.gnu.org/software/gperf/manual/html_node/User_002dsupplied-Struct.html#User_002dsupplied-Struct</A>
</I>&gt;<i> )
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> second round audit:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in src/HttpHdrCc.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * valid_id in httpHdrCcStatDumper() can probably be a const bool like
</I>&gt;&gt;<i> the other.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yes. Done.
</I>&gt;<i>
</I>&gt;<i> in src/HttpHdrSc.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * useless include of dlink.h since its done in the .h
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * a duplicate include of HttpHdrSc.h since its pulled in by
</I>&gt;&gt;<i> HttpHdrScTarget.h.
</I>&gt;&gt;<i>  - but in this case I think replece it with:
</I>&gt;&gt;<i>   //#include &quot;HttpHdrSc.h&quot; // pulled in by HttpHdrScTarget.h
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done. Good idea, it'd look odd otherwise.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in src/HttpHdrSc.h:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * please use mem/forward.h instead of mem/AllocatorProxy.h
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * please store the class pre-defines alphabetically.
</I>&gt;&gt;<i>  - Packable above StatHist.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in src/HttpHdrScTarget.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * useless include of HttpHdrSc.h
</I>&gt;&gt;<i>  - thanks for fixing the missing HttpHdrScTarget.h
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done. NP :)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> in src/HttpHdrScTarget.h:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * now has useless include of mem/forward.h (after above fix),
</I>&gt;&gt;<i> SquidString.h, dlink.h, typedefs.h
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ok.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> in src/HttpHeader.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * please take the opportunity to remove useless includes overlapping
</I>&gt;&gt;<i> with HttpHdrCc.h and HttpHdrSc.h
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done. I've commented them and mentioned the indirect inclusion in a
</I>&gt;<i> comment.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * please replace include fof HttpHdrSc.h with HttpHdrScTarget.h in the
</I>&gt;&gt;<i> new include nesting.
</I>&gt;&gt;<i>  - also checking for duplicate includes between HttpHdrScTarget.h and
</I>&gt;&gt;<i> HttpHeader.cc
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * chunk @562, s/NULL/nullptr/
</I>&gt;&gt;<i>  - maybe others in the touched lines
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * HttpHeaderEntry dtor use of assert(any_valid_header(id)); at the top
</I>&gt;&gt;<i> is needless.
</I>&gt;&gt;<i>  - protect the stats accounting against BAD though
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * HttpHeaderEntry ctor accepts OTHER but also &quot;anId != BAD&quot; implies that
</I>&gt;&gt;<i> it accepts BAD as well despite the previous
</I>&gt;&gt;<i> assert(any_registered_header(anId)).
</I>&gt;&gt;<i>  - wrap the stats accounting in if (id != BAD).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> done
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  - fixing those ctor/dtor asserts will avoid any potential for assertion
</I>&gt;&gt;<i> from temporary default- or partially- constructed objects, or bad
</I>&gt;&gt;<i> emplacement destructions.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ..which are not there, or we'd assert all over the place. But sure.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in src/acl/RequestHeaderStrategy.h:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  * please take the opportunity to remove that empty line between
</I>&gt;&gt;<i> 'template' and 'class' at lines at ~14
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Done
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> in src/http/RegisteredHeaders.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * please add empty line between namespace '{' and start of comment.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in src/http/RegisteredHeaders.h:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * please document on HeaderTable that lookup() will return BAD if the
</I>&gt;&gt;<i> header is unknown / unregistered. callers need to check and handle that
</I>&gt;&gt;<i> case properly.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ok.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I think that is all. And all polish :-)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> +1 on this so far. Though you/we still need to sort the valid registered
</I>&gt;&gt;<i> ID tests before commit.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I think I have fixed those, although it's hard to be sure - layering
</I>&gt;<i> violations all over the place.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> NOTE: these are about old bugs you are uncovering. I'd like to take the
</I>&gt;&gt;<i> opportunity to fix them. But this is already huge, so for now just XXX
</I>&gt;&gt;<i> mark it and followup patch.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Like many other areas, there is (plenty of) room for improvement :)
</I>&gt;<i> If not performance-wise, certainly code-wise.
</I>&gt;<i> I'd leave them as a follow-up effort.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * I'm still not clear on why insertEntry() checks for valid header enum
</I>&gt;&gt;<i> values but addEntry() needs to accept BAD.
</I>&gt;&gt;<i>  - if that need is true its worth a comment to document. otherwise
</I>&gt;&gt;<i> update top of addEntry() to match insertEntry().
</I>&gt;&gt;<i>  - NP: we should *never* be adding a BAD/invalid header entry to a
</I>&gt;&gt;<i> message object. Custom ones yes, but they are OTHER.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * like has() all the has/put/get*(ID, ...) methods need to exclude BAD
</I>&gt;&gt;<i> and OTHER as a valid inputs.
</I>&gt;&gt;<i>  - OTHER means we are accessing and using the Entry by string name, not
</I>&gt;&gt;<i> by ID value.
</I>&gt;&gt;<i>  - BAD means we should never have put it into object in the first place.
</I>&gt;&gt;<i>  - the put*(ID, ...) accepting OTHER may be where addEntry(ID,...) goes
</I>&gt;&gt;<i> wrong.
</I>&gt;&gt;<i>  - sorry these seem to have got caught in cleaning up one of my earlier
</I>&gt;&gt;<i> comments which was about another changed use of assert_eid().
</I>&gt;&gt;<i> assert_eid() test was wrong for these get/put/has*(ID,...) to begin with.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [[ httpHeaderFieldStatDumper() earning itself a place in the hall of
</I>&gt;&gt;<i> horrors :-(
</I>&gt;&gt;<i>   ..., double val, ...
</I>&gt;&gt;<i>   const int id = static_cast&lt;int&gt;(val);
</I>&gt;&gt;<i>   const bool valid_id = id &lt; Http::HdrType::ENUM_END;
</I>&gt;&gt;<i>  // back away, quietly ...
</I>&gt;&gt;<i> ]]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i>     Francesco
</I>&gt;<i>
</I>


-- 
    Francesco
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150806/30d9ef23/attachment-0001.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150806/30d9ef23/attachment-0001.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002929.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
	<LI>Next message: <A HREF="002924.html">[squid-dev] [PATCH] HttpHeader migration (coverity-fixes branch)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2936">[ date ]</a>
              <a href="thread.html#2936">[ thread ]</a>
              <a href="subject.html#2936">[ subject ]</a>
              <a href="author.html#2936">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
