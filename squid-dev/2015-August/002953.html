<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PackableStream for cachemgr reports
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C5B7E8.4070607%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002951.html">
   <LINK REL="Next"  HREF="002954.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PackableStream for cachemgr reports</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C5B7E8.4070607%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] PackableStream for cachemgr reports">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Aug  8 08:03:52 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002951.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
        <LI>Next message: <A HREF="002954.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2953">[ date ]</a>
              <a href="thread.html#2953">[ thread ]</a>
              <a href="subject.html#2953">[ subject ]</a>
              <a href="author.html#2953">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 8/08/2015 5:04 p.m., Alex Rousskov wrote:
&gt;<i> On 08/05/2015 10:24 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> Adds a PackableStream class which provides std::ostream semantics for
</I>&gt;&gt;<i> writing data to a cachemgr report.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    PackableStreamBuf(Packable *out) : outBuf(out) {}
</I>&gt;<i> 
</I>&gt;<i> Missing &quot;explicit&quot; or a comment justifying implicit conversions.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    ~PackableStreamBuf() {}
</I>&gt;<i> 
</I>&gt;<i> Please add &quot;virtual&quot;.
</I>&gt;<i> 
</I>
Fixed both. Darn cut-n-paste.

Also fixing the StoreEntryStream.h where these originated.

&gt;<i> 
</I>&gt;&gt;<i> +    virtual int_type overflow(int_type aChar = traits_type::eof()) {
</I>&gt;<i> 
</I>&gt;&gt;<i> +    virtual int sync() {
</I>&gt;<i> 
</I>&gt;&gt;<i> +    virtual std::streamsize xsputn(const char * chars, std::streamsize number) {
</I>&gt;<i> 
</I>&gt;<i> Please add &quot;override&quot; to each overridden virtual method from the
</I>&gt;<i> std::streambuf API.
</I>
I dont quite follow you here.

Is that a request to add comments?
 or an attribute I was not aware of?

&gt;<i> 
</I>&gt;&gt;<i> +            // NP: cast because GCC promotes int_type to 32-bit type
</I>&gt;&gt;<i> +            //     std::basic_streambuf&lt;char&gt;::int_type {aka int}
</I>&gt;&gt;<i> +            //     despite the definition with 8-bit type value.
</I>&gt;&gt;<i> +            char chars[1] = {char(aChar)};
</I>&gt;<i> 
</I>&gt;<i> Please use static_cast (or another appropriately named cast) to cast.
</I>&gt;<i> 
</I>&gt;<i> Do not declare &quot;chars&quot; when you do not need them.
</I>
The comment says 'cast' because that is essentially what is being done.

However the char(int_type) type constructor is necessary because this is
the fundamental int_type being passed in. All the available
*_cast&lt;char&gt;() operators are built to convert a 32-bit int_type value
into an array of 4 bytes before dealing with the byte-&gt;char conversion
part. Which then incorrectly takes the lowest-8 bits rather than the
first-8.

The int_type being passed in actually has only 8-bits of length, not
32-bits. Which screws over those cast operators memory accesses. They
typically end up casting the value at 2nd or 4th byte of a 1-byte stack
object to char.


If you are aware of a foo_cast&lt;&gt;() operator that correctly converts in
the presence of that traits weirdness I am interested.


&gt;<i> 
</I>&gt;<i> Make &quot;chars&quot; constant if you can.
</I>
Trying.

&gt;<i> 
</I>&gt;&gt;<i> +                outBuf-&gt;append(chars, 1);
</I>&gt;<i> ...
</I>&gt;&gt;<i> +            outBuf-&gt;append(pbase(), pending);
</I>&gt;<i> ...
</I>&gt;&gt;<i> +            outBuf-&gt;append(chars, number);
</I>&gt;<i> 
</I>&gt;<i> To reduce code duplication and to assist with debugging, it would be
</I>&gt;<i> nice to move these three into a single dedicated private write() method
</I>&gt;<i> or similar.
</I>&gt;<i> 
</I>
Calling xsputn() instead now. Although note that trampolining off a
virtual function (non-inlinable in some compilers) actually makes it
less efficient.


&gt;<i> 
</I>&gt;&gt;<i> +        if (pending)
</I>&gt;&gt;<i> +            outBuf-&gt;append(pbase(), pending);
</I>&gt;<i> ...
</I>&gt;&gt;<i> +        if (number)
</I>&gt;&gt;<i> +            outBuf-&gt;append(chars, number);
</I>&gt;<i> 
</I>&gt;<i> Are you sure you are saving more cycles by bypassing zero-size appends
</I>&gt;<i> than you are wasting on the size check? If you are not, do not waste
</I>&gt;<i> cycles and ink on that check.
</I>
The MemBuf and SBuf implementations of append() check for 0 themselves.
But the StoreEntry assumed non-0 and does some relatively heavy
allocation. PackableStream(StoreEntry) is expected to be the common use
case so this is a net performance gain until StoreEntry itself gets
optimized.


&gt;<i> 
</I>&gt;&gt;<i> +private:
</I>&gt;&gt;<i> +    Packable *outBuf;
</I>&gt;&gt;<i> +};
</I>&gt;<i> 
</I>&gt;<i> Why is this a pointer? The class code seems to require a non-null
</I>&gt;<i> pointer. If you can make this a reference, please do.
</I>&gt;<i> 
</I>&gt;<i> If this member remains a pointer, we ought to check that it is not null.
</I>
It was pointer in StoreEntyStream. Trying reference.

&gt;<i> 
</I>&gt;&gt;<i> +    PackableStream(Packable *entry): std::ostream(0), theBuffer(entry) {
</I>&gt;<i> 
</I>&gt;<i> Missing &quot;explicit&quot; or a comment justifying implicit conversions.
</I>
Fixed.

&gt;<i> 
</I>&gt;<i> If you do not want this class to be responsible for checking &quot;entry&quot; for
</I>&gt;<i> being nil (after the PackableStreamBuf fixes above), then use a
</I>&gt;<i> reference instead of a pointer.
</I>&gt;<i> 
</I>&gt;<i> Please s/entry/packable/ or something like that. We should not imply
</I>&gt;<i> that this is StoreEntry even if it [usually] is today.
</I>
Nod. Using p like everywhere else.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    /* create a stream for writing text etc into theEntry */
</I>&gt;<i> 
</I>&gt;<i> No theEntry here.
</I>
Fixed.

&gt;&gt;<i> +    virtual void dump(std::ostream &amp;) {}
</I>&gt;<i> 
</I>&gt;<i> This should either throw (if it must not be called unless overridden) or
</I>&gt;<i> provide some debugging (if it is OK to leave it a no-op).
</I>&gt;<i> 
</I>
It is okay to be a no-op. It should not be called if not overridden.
Making it dump &quot;X is NOT Implemented&quot; to the stream for now.


&gt;<i> 
</I>&gt;&gt;<i> +    virtual void dump(std::ostream &amp;) {}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    // magic wrapper.
</I>&gt;&gt;<i> +    // old code will override this instead of the new ostream dumper.
</I>&gt;&gt;<i> +    virtual void dump(StoreEntry *e);
</I>&gt;<i> 
</I>&gt;<i> IIRC, it is not possible to override just one dump() without hiding the
</I>&gt;<i> other. I do not know whether we enable compiler warnings about hiding
</I>&gt;<i> virtual methods by default, but we _should_ enable them if we do not
</I>&gt;<i> already.
</I>
I thought both symbols had a vtable entry under their different mangling.

Running some extra tests to check that now.


&gt;<i> 
</I>&gt;<i> Perhaps more importantly, why do we actually need this [black] magic
</I>&gt;<i> here? Can the new method just use a different name, like dumpToStream(),
</I>&gt;<i> until the transition is over?
</I>
The only black magic bit is if both virtuals get hidden when one is
overridden. And that is anti-useful. So if it happens I will definitely
rename.

Otherwise it is six of one, half a dozen of the other.

&gt;<i> 
</I>&gt;&gt;<i> * convert old Action classes to new API
</I>&gt;&gt;<i> * refactor old C-code report generators to be Action classes
</I>&gt;&gt;<i>  - fixing display output syntax to minimal YAML as we go on both the
</I>&gt;&gt;<i> above. It mostly is already, but some reports have wrong syntax.
</I>&gt;<i> 
</I>&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;<i> impossible) to make syntax mistakes?
</I>&gt;<i> 
</I>
Action itself is currently that class you speak about AFAICT. Maybe in
future the &quot;update Action API to receive client desired format&quot; will be
a formatter class rather than just header value.

For now its just a free-form mix in plain text. To which a stream is
suited. And possible something the formatter classes could use better
than a direct Packable object pointer/reference.

Given the 4 years it has taken to get this far I'm expecting the stream
and cut-down YAML will be used for a long time before we get around to
debating better formatter syntax(es) again.


&gt;<i> 
</I>&gt;<i> Finally, &quot;make check&quot; fails in my tests with several errors like:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> tests/stub_libmgr.cc:65:6: error: prototype for ‘void Mgr::RotateAction::dump(StoreEntry*)’ does not match any in class ‘Mgr::RotateAction’
</I>&gt;&gt;<i>  void Mgr::RotateAction::dump(StoreEntry *entry) STUB
</I>&gt;&gt;<i>       ^
</I>&gt;&gt;<i> In file included from tests/stub_libmgr.cc:48:0:
</I>&gt;&gt;<i> ../src/mgr/BasicActions.h:78:18: error: candidate is: virtual void Mgr::RotateAction::dump(std::ostream&amp;)
</I>&gt;&gt;<i>      virtual void dump(std::ostream &amp;);
</I>&gt;&gt;<i>                   ^
</I>&gt;<i> 
</I>
Fixing.

Followup patch to come when the virtual experiments and re-tests are
completed.

Amos

</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002951.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
	<LI>Next message: <A HREF="002954.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2953">[ date ]</a>
              <a href="thread.html#2953">[ thread ]</a>
              <a href="subject.html#2953">[ subject ]</a>
              <a href="author.html#2953">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
