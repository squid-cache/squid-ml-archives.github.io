<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PackableStream for cachemgr reports
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C6A971.6010209%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002953.html">
   <LINK REL="Next"  HREF="002955.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PackableStream for cachemgr reports</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C6A971.6010209%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] PackableStream for cachemgr reports">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Aug  9 01:14:25 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002953.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
        <LI>Next message: <A HREF="002955.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2954">[ date ]</a>
              <a href="thread.html#2954">[ thread ]</a>
              <a href="subject.html#2954">[ subject ]</a>
              <a href="author.html#2954">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/08/2015 02:03 AM, Amos Jeffries wrote:
&gt;<i> On 8/08/2015 5:04 p.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 08/05/2015 10:24 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> +    virtual int_type overflow(int_type aChar = traits_type::eof()) {
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +    virtual int sync() {
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +    virtual std::streamsize xsputn(const char * chars, std::streamsize number) {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please add &quot;override&quot; to each overridden virtual method from the
</I>&gt;&gt;<i> std::streambuf API.
</I>&gt;<i> 
</I>&gt;<i> I dont quite follow you here.
</I>&gt;<i> 
</I>&gt;<i> Is that a request to add comments?
</I>&gt;<i>  or an attribute I was not aware of?
</I>
It is a C++11 specifier that allows the compiler to check that you are
indeed overriding a parent method and tells the reader that you are
overriding a parent method:

  <A HREF="http://en.cppreference.com/w/cpp/language/override">http://en.cppreference.com/w/cpp/language/override</A>

It should be mandatory in new trunk code IMO.


&gt;&gt;&gt;<i> +            // NP: cast because GCC promotes int_type to 32-bit type
</I>&gt;&gt;&gt;<i> +            //     std::basic_streambuf&lt;char&gt;::int_type {aka int}
</I>&gt;&gt;&gt;<i> +            //     despite the definition with 8-bit type value.
</I>&gt;&gt;&gt;<i> +            char chars[1] = {char(aChar)};
</I>
&gt;&gt;<i> Please use static_cast (or another appropriately named cast) to cast.
</I>

&gt;<i> The comment says 'cast' because that is essentially what is being done.
</I>
Yes, I know, hence the request.


&gt;<i> However the char(int_type) type constructor is necessary because this is
</I>&gt;<i> the fundamental int_type being passed in. All the available
</I>&gt;<i> *_cast&lt;char&gt;() operators are built to convert a 32-bit int_type value
</I>&gt;<i> into an array of 4 bytes before dealing with the byte-&gt;char conversion
</I>&gt;<i> part. Which then incorrectly takes the lowest-8 bits rather than the
</I>&gt;<i> first-8.
</I>
I am curious where you got the above information from, especially the
last sentence.

Here is the sequence of conversions for std::basic_streambuf&lt;char&gt;
AFAICT (where &quot;c&quot; is of type &quot;char&quot; and &quot;int_type&quot; is &quot;int&quot;):

1. sputc(c) or a similar method is called to write our character c.

2. sputc() calls traits_type::to_int_type(c) to convert c to int.

3. traits_type::to_int_type() returns static_cast&lt;int_type&gt;(c).

4. sputc() calls your overflow() with the int result of #3:
   this-&gt;overflow(traits_type::to_int_type(c));

In summary, there is only one conversion, and that conversion is
static_cast&lt;int&gt;(c).

If we cannot reverse that using static_cast&lt;char&gt; in your overflow(),
then there exist such a &quot;char&quot; c for which

   static_cast&lt;char&gt;(static_cast&lt;int&gt;(c)) != c

I cannot find such a character c.

Moreover, AFAICT, the existence of such a character would contradict the
standard requirement that integer values from the [minimum character,
maximum character] range are preserved during conversions from integer
to character:

&gt;<i> When a value with integer type is converted to another integer type
</I>&gt;<i> other than Bool, if the value can be represented by the new type, it
</I>&gt;<i> is unchanged.
</I>
There may be something else in this picture that I am missing, of
course, but it seems rather straightforward to me as long as we stay in
the std::basic_streambuf&lt;char&gt; context (which you and your code seem to
assume as well).


&gt;<i> The int_type being passed in actually has only 8-bits of length, not
</I>&gt;<i> 32-bits.
</I>
AFAIK, the &quot;int_type&quot; being passes is just &quot;int&quot;. I believe you have
said that yourself.


Also, do not declare &quot;chars&quot; until you need them. This is unrelated to
casting. It is related to where you declare &quot;chars&quot;. You are declaring
them too early, inserting them in the wider context where they are not
needed AFAICT.


&gt;<i> If you are aware of a foo_cast&lt;&gt;() operator that correctly converts in
</I>&gt;<i> the presence of that traits weirdness I am interested.
</I>
I do not see anything weird going on and expect static_cast&lt;char&gt;(int)
to reverse the effects of static_cast&lt;int&gt;(char).


&gt;&gt;&gt;<i> +                outBuf-&gt;append(chars, 1);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +            outBuf-&gt;append(pbase(), pending);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +            outBuf-&gt;append(chars, number);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To reduce code duplication and to assist with debugging, it would be
</I>&gt;&gt;<i> nice to move these three into a single dedicated private write() method
</I>&gt;&gt;<i> or similar.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Calling xsputn() instead now. Although note that trampolining off a
</I>&gt;<i> virtual function (non-inlinable in some compilers) actually makes it
</I>&gt;<i> less efficient.
</I>

This is exactly the reason I did not suggest to call xsputn(). Please do
not call that virtual method! Please add and call a dedicated private
write() method (or similar).


&gt;&gt;&gt;<i> +        if (pending)
</I>&gt;&gt;&gt;<i> +            outBuf-&gt;append(pbase(), pending);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +        if (number)
</I>&gt;&gt;&gt;<i> +            outBuf-&gt;append(chars, number);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Are you sure you are saving more cycles by bypassing zero-size appends
</I>&gt;&gt;<i> than you are wasting on the size check? If you are not, do not waste
</I>&gt;&gt;<i> cycles and ink on that check.
</I>
&gt;<i> The MemBuf and SBuf implementations of append() check for 0 themselves.
</I>&gt;<i> But the StoreEntry assumed non-0 and does some relatively heavy
</I>&gt;<i> allocation. PackableStream(StoreEntry) is expected to be the common use
</I>&gt;<i> case so this is a net performance gain until StoreEntry itself gets
</I>&gt;<i> optimized.
</I>
If zero-length appends are very rare, you would be wasting cycles
instead of saving them, despite StoreEntry &quot;heavy&quot; implementation.

Moreover, if StoreEntry does something important when handling
zero-length calls (e.g., calling invokeHandlers), then blocking that
code from running might actually introduce a well-hidden bug.


&gt;<i> Otherwise it is six of one, half a dozen of the other.
</I>

It is not. Using the same method name wasted yours and mine time
already. It will waste more time in the future when somebody wants to
search for one of the methods and not the other. It will make method
names in error message more difficult to interpret. It will make method
names in debugs() output more difficult to interpret. It is &quot;black&quot;
magic because few people know about this and many people are confused by
how it actually works.

This article explains name hiding I was thinking about (see the first
example; the second is different):
<A HREF="http://www.programmerinterview.com/index.php/c-cplusplus/c-name-hiding/">http://www.programmerinterview.com/index.php/c-cplusplus/c-name-hiding/</A>

However, I was wrong that it is an optional GCC warning. It is actually
an error. Still, there are plenty of other reasons to avoid same-name
virtual methods in this context.


&gt;&gt;&gt;<i> * convert old Action classes to new API
</I>&gt;&gt;&gt;<i> * refactor old C-code report generators to be Action classes
</I>&gt;&gt;&gt;<i>  - fixing display output syntax to minimal YAML as we go on both the
</I>&gt;&gt;&gt;<i> above. It mostly is already, but some reports have wrong syntax.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;&gt;<i> impossible) to make syntax mistakes?
</I>

&gt;<i> Action itself is currently that class you speak about AFAICT. 
</I>
Mgr::Action is a cache manager command [processor]. Action knows where
to get the information we need to write. Formatting obtained information
is a very different matter. Yes, we could add formatting methods to
Action itself, but I am not sure that is a good idea.


&gt;<i> Maybe in
</I>&gt;<i> future the &quot;update Action API to receive client desired format&quot; will be
</I>&gt;<i> a formatter class rather than just header value.
</I>
Perhaps, but what is the value of replacing dump(StoreEntry) with
dump(ostream) now, when what we actually want is dump(void) or
dump(Formatter)? It feels like you want to rewrite the same code twice,
and I do not understand why (especially since the results of that code
are parsed by admin scripts making extra changes harmful).


&gt;<i> For now its just a free-form mix in plain text. To which a stream is
</I>&gt;<i> suited. And possible something the formatter classes could use better
</I>&gt;<i> than a direct Packable object pointer/reference.
</I>
The code for free-form formatting already exists. We do not want it in
the future. Why replace one free-form with a slightly different
free-form when what we need is YAML-form?


Thank you,

Alex.

</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002953.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
	<LI>Next message: <A HREF="002955.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2954">[ date ]</a>
              <a href="thread.html#2954">[ thread ]</a>
              <a href="subject.html#2954">[ subject ]</a>
              <a href="author.html#2954">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
