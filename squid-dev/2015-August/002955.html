<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PackableStream for cachemgr reports
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C70584.1020501%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002954.html">
   <LINK REL="Next"  HREF="002956.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PackableStream for cachemgr reports</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C70584.1020501%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] PackableStream for cachemgr reports">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Aug  9 07:47:16 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002954.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
        <LI>Next message: <A HREF="002956.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2955">[ date ]</a>
              <a href="thread.html#2955">[ thread ]</a>
              <a href="subject.html#2955">[ subject ]</a>
              <a href="author.html#2955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>[ I've re-ordered the discussion points so the important design part we
ended discussion with is now at the top for first consideration.
Depending on that the rest of it may or may not matter. ]



On 9/08/2015 1:14 p.m., Alex Rousskov wrote:
&gt;<i> On 08/08/2015 02:03 AM, Amos Jeffries wrote:
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> * convert old Action classes to new API
</I>&gt;&gt;&gt;&gt;<i> * refactor old C-code report generators to be Action classes
</I>&gt;&gt;&gt;&gt;<i>  - fixing display output syntax to minimal YAML as we go on both the
</I>&gt;&gt;&gt;&gt;<i> above. It mostly is already, but some reports have wrong syntax.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;&gt;&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;&gt;&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;&gt;&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;&gt;&gt;<i> impossible) to make syntax mistakes?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Action itself is currently that class you speak about AFAICT.
</I>&gt;<i>
</I>&gt;<i> Mgr::Action is a cache manager command [processor]. Action knows where
</I>&gt;<i> to get the information we need to write. Formatting obtained information
</I>&gt;<i> is a very different matter. Yes, we could add formatting methods to
</I>&gt;<i> Action itself, but I am not sure that is a good idea.
</I>
... with children inheriting which do all the formatting display parts.


&gt;<i>
</I>&gt;&gt;<i> Maybe in
</I>&gt;&gt;<i> future the &quot;update Action API to receive client desired format&quot; will be
</I>&gt;&gt;<i> a formatter class rather than just header value.
</I>&gt;<i>
</I>&gt;<i> Perhaps, but what is the value of replacing dump(StoreEntry) with
</I>&gt;<i> dump(ostream) now, when what we actually want is dump(void) or
</I>&gt;<i> dump(Formatter)? It feels like you want to rewrite the same code twice,
</I>
The last attempt was 4 years ago. The one before that 6 years prior again.

If you can agree that we start with a Mgr::Formatter class that does not
do anything initially but dump out a free-form &quot;notice&quot; box with a line
of text in it. The other reports output and formatter API/functionality
to be deferred to adding by other patches as need arises. Then I think
I/we can go forward with that.

A &quot;notice&quot; is all the basic actions altered in this patch need (apart
from menu, but that can revert). I will then drop PackableStream in
favour of that class going in now/shortly.
 [yes renaming dump(ostream&amp;) to displayWith(Formatter&amp;) ]


&gt;<i> and I do not understand why (especially since the results of that code
</I>&gt;<i> are parsed by admin scripts making extra changes harmful).
</I>&gt;<i>
</I>
Primarily that we can do the formatting cleanup without adding a
circular dependency between libbase and libmem in the current code
situation.

The memory allocator needs to display its part(s) of reports but is
depended on for allocating the objects used to do the dumping. Which if
passed those objects, would in turn depend on linking to them. Loop
problems then ensue between convenience libraries link ordering.


This cycle will exist unless we;
a) inherit the formatter from a totally external type of dumper,
b) make formatter fully an inline or template class, or
c) refactor the deepest memory allocators to split their working code
from their stats code

NP: the current code has already taken the (a) design path and uses
StoreEntryStream passed as ostream&amp; to the memory allocator component.
Thats where PackableStream was taken from, and avoiding touching the
memory allocator yet again was a factor in the choice.


&gt;<i>
</I>&gt;&gt;<i> For now its just a free-form mix in plain text. To which a stream is
</I>&gt;&gt;<i> suited. And possible something the formatter classes could use better
</I>&gt;&gt;<i> than a direct Packable object pointer/reference.
</I>&gt;<i>
</I>&gt;<i> The code for free-form formatting already exists. We do not want it in
</I>&gt;<i> the future. Why replace one free-form with a slightly different
</I>&gt;<i> free-form when what we need is YAML-form?
</I>&gt;<i>
</I>
I want to see the reports actually looking like sets of tables instead
of some (ie. mgr:dns) being groups of wiggly columns or (store_io) a
jumbled set of differently sized tables when parsed according to the few
bits of published cachemgr syntax. Its quite horrible in some points and
others commenting on it every now and again is usually what keeps it
high-ish on my todo list.


For now I was taking the best approach from the currently existing but
incomplete designs in Squid code and picking the one that appears to be
most suited for completing. StoreEntryStream in current trunk appeared
to be the one that did not limit future display options.



 ... the remainder is specific to the proposed PackableStream or
StoreEntryStream code. Which would be dropped if you agree on the above
approach for how to get a Formatter class transition going.


On 9/08/2015 1:14 p.m., Alex Rousskov wrote:
&gt;<i> On 08/08/2015 02:03 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 8/08/2015 5:04 p.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 08/05/2015 10:24 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> +    virtual int_type overflow(int_type aChar = traits_type::eof()) {
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +    virtual int sync() {
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +    virtual std::streamsize xsputn(const char * chars, std::streamsize number) {
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Please add &quot;override&quot; to each overridden virtual method from the
</I>&gt;&gt;&gt;<i> std::streambuf API.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I dont quite follow you here.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Is that a request to add comments?
</I>&gt;&gt;<i>  or an attribute I was not aware of?
</I>&gt;<i> 
</I>&gt;<i> It is a C++11 specifier that allows the compiler to check that you are
</I>&gt;<i> indeed overriding a parent method and tells the reader that you are
</I>&gt;<i> overriding a parent method:
</I>&gt;<i> 
</I>&gt;<i>   <A HREF="http://en.cppreference.com/w/cpp/language/override">http://en.cppreference.com/w/cpp/language/override</A>
</I>&gt;<i> 
</I>&gt;<i> It should be mandatory in new trunk code IMO.
</I>&gt;<i> 
</I>
Aha. Thank you. Agreed.

&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +            // NP: cast because GCC promotes int_type to 32-bit type
</I>&gt;&gt;&gt;&gt;<i> +            //     std::basic_streambuf&lt;char&gt;::int_type {aka int}
</I>&gt;&gt;&gt;&gt;<i> +            //     despite the definition with 8-bit type value.
</I>&gt;&gt;&gt;&gt;<i> +            char chars[1] = {char(aChar)};
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Please use static_cast (or another appropriately named cast) to cast.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> The comment says 'cast' because that is essentially what is being done.
</I>&gt;<i> 
</I>&gt;<i> Yes, I know, hence the request.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> However the char(int_type) type constructor is necessary because this is
</I>&gt;&gt;<i> the fundamental int_type being passed in. All the available
</I>&gt;&gt;<i> *_cast&lt;char&gt;() operators are built to convert a 32-bit int_type value
</I>&gt;&gt;<i> into an array of 4 bytes before dealing with the byte-&gt;char conversion
</I>&gt;&gt;<i> part. Which then incorrectly takes the lowest-8 bits rather than the
</I>&gt;&gt;<i> first-8.
</I>&gt;<i> 
</I>&gt;<i> I am curious where you got the above information from, especially the
</I>&gt;<i> last sentence.
</I>&gt;<i> 
</I>
&gt;<i>From several long days testing why static_cast always 0-terminated the
</I>strings when trying to fix this same thing in the same way for
StoreEntryStream years back. LP says rev.11605 (initial c++0x support).

Repeating the tests it seems to work now. Although I am building with
GCC-5 now. IIRC that was about GCC 4.6-ish.


&gt;<i> 
</I>&gt;&gt;<i> The int_type being passed in actually has only 8-bits of length, not
</I>&gt;&gt;<i> 32-bits.
</I>&gt;<i> 
</I>&gt;<i> AFAIK, the &quot;int_type&quot; being passes is just &quot;int&quot;. I believe you have
</I>&gt;<i> said that yourself.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Also, do not declare &quot;chars&quot; until you need them. This is unrelated to
</I>&gt;<i> casting. It is related to where you declare &quot;chars&quot;. You are declaring
</I>&gt;<i> them too early, inserting them in the wider context where they are not
</I>&gt;<i> needed AFAICT.
</I>&gt;<i> 
</I>
Looking up the origins of the hack I found the chars being outside the
if() was result of a different patch by one Alex R when adding the if(). :-P

Fixing both PackableStream and StoreEntryStream.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +                outBuf-&gt;append(chars, 1);
</I>&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;<i> +            outBuf-&gt;append(pbase(), pending);
</I>&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;<i> +            outBuf-&gt;append(chars, number);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> To reduce code duplication and to assist with debugging, it would be
</I>&gt;&gt;&gt;<i> nice to move these three into a single dedicated private write() method
</I>&gt;&gt;&gt;<i> or similar.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Calling xsputn() instead now. Although note that trampolining off a
</I>&gt;&gt;<i> virtual function (non-inlinable in some compilers) actually makes it
</I>&gt;&gt;<i> less efficient.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This is exactly the reason I did not suggest to call xsputn(). Please do
</I>&gt;<i> not call that virtual method! Please add and call a dedicated private
</I>&gt;<i> write() method (or similar).
</I>
So what is the point then?
If it is inline the compiler optimizes it away even in stack traces. No
use for debugging then.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +        if (pending)
</I>&gt;&gt;&gt;&gt;<i> +            outBuf-&gt;append(pbase(), pending);
</I>&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;<i> +        if (number)
</I>&gt;&gt;&gt;&gt;<i> +            outBuf-&gt;append(chars, number);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are you sure you are saving more cycles by bypassing zero-size appends
</I>&gt;&gt;&gt;<i> than you are wasting on the size check? If you are not, do not waste
</I>&gt;&gt;&gt;<i> cycles and ink on that check.
</I>&gt;<i> 
</I>&gt;&gt;<i> The MemBuf and SBuf implementations of append() check for 0 themselves.
</I>&gt;&gt;<i> But the StoreEntry assumed non-0 and does some relatively heavy
</I>&gt;&gt;<i> allocation. PackableStream(StoreEntry) is expected to be the common use
</I>&gt;&gt;<i> case so this is a net performance gain until StoreEntry itself gets
</I>&gt;&gt;<i> optimized.
</I>&gt;<i> 
</I>&gt;<i> If zero-length appends are very rare, you would be wasting cycles
</I>&gt;<i> instead of saving them, despite StoreEntry &quot;heavy&quot; implementation.
</I>&gt;<i> 
</I>&gt;<i> Moreover, if StoreEntry does something important when handling
</I>&gt;<i> zero-length calls (e.g., calling invokeHandlers), then blocking that
</I>&gt;<i> code from running might actually introduce a well-hidden bug.
</I>&gt;<i> 
</I>
Good point. Removing the if().

&gt;<i> 
</I>&gt;&gt;<i> Otherwise it is six of one, half a dozen of the other.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It is not. Using the same method name wasted yours and mine time
</I>&gt;<i> already. It will waste more time in the future when somebody wants to
</I>&gt;<i> search for one of the methods and not the other. It will make method
</I>&gt;<i> names in error message more difficult to interpret. It will make method
</I>&gt;<i> names in debugs() output more difficult to interpret. It is &quot;black&quot;
</I>&gt;<i> magic because few people know about this and many people are confused by
</I>&gt;<i> how it actually works.
</I>&gt;<i> 
</I>&gt;<i> This article explains name hiding I was thinking about (see the first
</I>&gt;<i> example; the second is different):
</I>&gt;<i> <A HREF="http://www.programmerinterview.com/index.php/c-cplusplus/c-name-hiding/">http://www.programmerinterview.com/index.php/c-cplusplus/c-name-hiding/</A>
</I>&gt;<i> 
</I>&gt;<i> However, I was wrong that it is an optional GCC warning. It is actually
</I>&gt;<i> an error. Still, there are plenty of other reasons to avoid same-name
</I>&gt;<i> virtual methods in this context.
</I>
Ah. The hiding is an artifact of grandparenting relationships.

I just compiled and ran it several times with the proposed code. The
result was exactly what I was expecting:

* The caller mgr:menu calls dump(StoreEntry*) which calls the
dump(ostream&amp;) override which displays the expected results.

* The caller mgr:info calls dump(StoreEntry*) which runs the
dump(StoreEntry*) override which displays the expected results.

Clearly dump(StoreEntry*) is not hidden when dump(ostream&amp;) is
overridden. I presume the dump(ostream&amp;) is not hidden in the reverse case.


Amos
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002954.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
	<LI>Next message: <A HREF="002956.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2955">[ date ]</a>
              <a href="thread.html#2955">[ thread ]</a>
              <a href="subject.html#2955">[ subject ]</a>
              <a href="author.html#2955">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
