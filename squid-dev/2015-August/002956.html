<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PackableStream for cachemgr reports
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C7CD2E.2080804%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002955.html">
   <LINK REL="Next"  HREF="002957.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PackableStream for cachemgr reports</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C7CD2E.2080804%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] PackableStream for cachemgr reports">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Aug  9 21:59:10 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002955.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
        <LI>Next message: <A HREF="002957.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2956">[ date ]</a>
              <a href="thread.html#2956">[ thread ]</a>
              <a href="subject.html#2956">[ subject ]</a>
              <a href="author.html#2956">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/09/2015 01:47 AM, Amos Jeffries wrote:
&gt;<i> On 9/08/2015 1:14 p.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 08/08/2015 02:03 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> * convert old Action classes to new API
</I>&gt;&gt;&gt;&gt;&gt;<i> * refactor old C-code report generators to be Action classes
</I>&gt;&gt;&gt;&gt;&gt;<i>  - fixing display output syntax to minimal YAML as we go on both the
</I>&gt;&gt;&gt;&gt;&gt;<i> above. It mostly is already, but some reports have wrong syntax.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;&gt;&gt;&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;&gt;&gt;&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;&gt;&gt;&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;&gt;&gt;&gt;<i> impossible) to make syntax mistakes?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Action itself is currently that class you speak about AFAICT.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Mgr::Action is a cache manager command [processor]. Action knows where
</I>&gt;&gt;<i> to get the information we need to write. Formatting obtained information
</I>&gt;&gt;<i> is a very different matter. Yes, we could add formatting methods to
</I>&gt;&gt;<i> Action itself, but I am not sure that is a good idea.
</I>&gt;<i> 
</I>&gt;<i> ... with children inheriting which do all the formatting display parts.
</I>
The distinction between the parent class and children is irrelevant
here. The fact that Action (and/or Action children) do formatting now
does not change what Action (and/or Action children) are defined and
meant to do. They are not meant to know formatting details, but somebody
has to format and the current Action (and/or Action children) code does it.


&gt;&gt;&gt;<i> Maybe in
</I>&gt;&gt;&gt;<i> future the &quot;update Action API to receive client desired format&quot; will be
</I>&gt;&gt;&gt;<i> a formatter class rather than just header value.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Perhaps, but what is the value of replacing dump(StoreEntry) with
</I>&gt;&gt;<i> dump(ostream) now, when what we actually want is dump(void) or
</I>&gt;&gt;<i> dump(Formatter)? It feels like you want to rewrite the same code twice,
</I>&gt;<i> 
</I>&gt;<i> The last attempt was 4 years ago. The one before that 6 years prior again.
</I>
Why is that relevant? Just because nobody has done the right thing for
many years does not imply we should do something else which does not
even move us in the right direction and causes problems for the admins.


&gt;<i> If you can agree that we start with a Mgr::Formatter class that does not
</I>&gt;<i> do anything initially but dump out a free-form &quot;notice&quot; box with a line
</I>&gt;<i> of text in it. The other reports output and formatter API/functionality
</I>&gt;<i> to be deferred to adding by other patches as need arises. Then I think
</I>&gt;<i> I/we can go forward with that.
</I>

We pretty much already have what you describe today: The current code
uses StoreEntry::append*() calls. One could view (or even implement)
that slice of StoreEntry API as dumb Formatter class that you have
described. This is the easier part of the problem that has been already
solved.

The more difficult part is introducing a non-free-form Formatter class.


&gt;<i> Primarily that we can do the formatting cleanup without adding a
</I>&gt;<i> circular dependency between libbase and libmem in the current code
</I>&gt;<i> situation.
</I>

This answer to my &quot;Why do the same change twice?&quot; question does not
compute/correlate for me. I do not see why two cleanups are better than
one here (if that is what you are implying). Also, &quot;without adding X&quot;
cannot be the reason because the existing code does not add anything.



&gt;&gt;&gt;<i> For now its just a free-form mix in plain text. To which a stream is
</I>&gt;&gt;&gt;<i> suited. And possible something the formatter classes could use better
</I>&gt;&gt;&gt;<i> than a direct Packable object pointer/reference.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The code for free-form formatting already exists. We do not want it in
</I>&gt;&gt;<i> the future. Why replace one free-form with a slightly different
</I>&gt;&gt;<i> free-form when what we need is YAML-form?
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> I want to see the reports actually looking like sets of tables 
</I>
This desire seems unrelated to my concern.


&gt;<i> For now I was taking the best approach from the currently existing but
</I>&gt;<i> incomplete designs in Squid code and picking the one that appears to be
</I>&gt;<i> most suited for completing. StoreEntryStream in current trunk appeared
</I>&gt;<i> to be the one that did not limit future display options.
</I>
I do not see how changing StoreEntry-&gt;append() to ostream::operator &lt;&lt;
helps you to make &quot;reports actually looking like sets of tables&quot; and/or
to move us closer to YAML support. Again, it feels like we are making
admins life harder without any significant internal improvements.


&gt;<i> If you can agree that we start with a Mgr::Formatter class that does not
</I>&gt;<i> do anything initially but dump out a free-form &quot;notice&quot; box with a line
</I>&gt;<i> of text in it.
</I>
I hope we can come up with a minimal API (only usable for the very basic
output such as one-line notices and such). We will need to discuss and
agree on what that minimum is exactly.

If YAML support is one of the ultimate goals, then I would propose
something like this:

// Assembles information for a single Cache Manager &quot;page&quot;.
// Supplied information goes into a configured stream.
// Kids implement various information formatting methods.
class Page: public std::ostream {
public:
    Page(std::ostream &amp;os);
    virtual ~Page() {}

    // a comment
    virtual Page &amp;comment(const SBuf &amp;text) = 0;

    /// starts recording a list of values
    virtual Page &amp;beginList() = 0;
    /// finishes recording a list of values
    virtual Page &amp;endList() = 0;

    /// starts recording a list of values
    virtual Page &amp;beginListItem() = 0;
    /// finishes recording a list of values
    virtual Page &amp;endListItem() = 0;

    /// starts recording a key:value pair with a given key
    virtual Page &amp;beginKv(const SBuf &amp;key) = 0;
    /// finishes recording a key:value pair
    virtual Page &amp;endKv() = 0;
...
};

The methods below comment() may be needed for more advanced stuff like
the menu but probably not needed for &quot;notice boxes&quot;. If that API is what
you were describing as a free-form &quot;notice box&quot; or &quot;line of text&quot;, then
we are in agreement.

The attached file has a sample implementation of that API for a YAML
formatter. It currently violates most YAML rules but can become
compliant with more work. Here is a sample output for the menu page
(adjusted for indentation that is not automated in the sample code):


---
- 5min: menu item description to be extracted from Action::desc
  protection: public
- 60min: menu item description to be extracted from Action::desc
  protection: public
- disk_io: menu item description to be extracted from Action::desc
  protection: public
- events: menu item description to be extracted from Action::desc
  protection: public
- shutdown: menu item description to be extracted from Action::desc
  protection: public
# This is not really related to the menu example above
TestKey: several words per 1 value are OK
---



&gt;<i>  ... the remainder is specific to the proposed PackableStream or
</I>&gt;<i> StoreEntryStream code. Which would be dropped if you agree on the above
</I>&gt;<i> approach for how to get a Formatter class transition going.
</I>
Sorry, have to run. I will read/review the rest later.

Alex.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: Page.cc
Type: text/x-c++src
Size: 3697 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150809/b01e5f5c/attachment.cc">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150809/b01e5f5c/attachment.cc</A>&gt;
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002955.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
	<LI>Next message: <A HREF="002957.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2956">[ date ]</a>
              <a href="thread.html#2956">[ thread ]</a>
              <a href="subject.html#2956">[ subject ]</a>
              <a href="author.html#2956">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
