<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PackableStream for cachemgr reports
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C81CEF.9040902%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002956.html">
   <LINK REL="Next"  HREF="002961.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PackableStream for cachemgr reports</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PackableStream%20for%20cachemgr%20reports&In-Reply-To=%3C55C81CEF.9040902%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] PackableStream for cachemgr reports">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Aug 10 03:39:27 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002956.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
        <LI>Next message: <A HREF="002961.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2957">[ date ]</a>
              <a href="thread.html#2957">[ thread ]</a>
              <a href="subject.html#2957">[ subject ]</a>
              <a href="author.html#2957">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/08/2015 9:59 a.m., Alex Rousskov wrote:
&gt;<i> On 08/09/2015 01:47 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 9/08/2015 1:14 p.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 08/08/2015 02:03 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> * convert old Action classes to new API
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> * refactor old C-code report generators to be Action classes
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>  - fixing display output syntax to minimal YAML as we go on both the
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> above. It mostly is already, but some reports have wrong syntax.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;&gt;&gt;&gt;&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;&gt;&gt;&gt;&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;&gt;&gt;&gt;&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;&gt;&gt;&gt;&gt;<i> impossible) to make syntax mistakes?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Action itself is currently that class you speak about AFAICT.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Mgr::Action is a cache manager command [processor]. Action knows where
</I>&gt;&gt;&gt;<i> to get the information we need to write. Formatting obtained information
</I>&gt;&gt;&gt;<i> is a very different matter. Yes, we could add formatting methods to
</I>&gt;&gt;&gt;<i> Action itself, but I am not sure that is a good idea.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ... with children inheriting which do all the formatting display parts.
</I>&gt;<i> 
</I>&gt;<i> The distinction between the parent class and children is irrelevant
</I>&gt;<i> here. The fact that Action (and/or Action children) do formatting now
</I>&gt;<i> does not change what Action (and/or Action children) are defined and
</I>&gt;<i> meant to do. They are not meant to know formatting details, but somebody
</I>&gt;<i> has to format and the current Action (and/or Action children) code does it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> Maybe in
</I>&gt;&gt;&gt;&gt;<i> future the &quot;update Action API to receive client desired format&quot; will be
</I>&gt;&gt;&gt;&gt;<i> a formatter class rather than just header value.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Perhaps, but what is the value of replacing dump(StoreEntry) with
</I>&gt;&gt;&gt;<i> dump(ostream) now, when what we actually want is dump(void) or
</I>&gt;&gt;&gt;<i> dump(Formatter)? It feels like you want to rewrite the same code twice,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The last attempt was 4 years ago. The one before that 6 years prior again.
</I>&gt;<i> 
</I>&gt;<i> Why is that relevant? Just because nobody has done the right thing for
</I>&gt;<i> many years does not imply we should do something else which does not
</I>&gt;<i> even move us in the right direction and causes problems for the admins.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> If you can agree that we start with a Mgr::Formatter class that does not
</I>&gt;&gt;<i> do anything initially but dump out a free-form &quot;notice&quot; box with a line
</I>&gt;&gt;<i> of text in it. The other reports output and formatter API/functionality
</I>&gt;&gt;<i> to be deferred to adding by other patches as need arises. Then I think
</I>&gt;&gt;<i> I/we can go forward with that.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> We pretty much already have what you describe today: The current code
</I>&gt;<i> uses StoreEntry::append*() calls. One could view (or even implement)
</I>&gt;<i> that slice of StoreEntry API as dumb Formatter class that you have
</I>&gt;<i> described. This is the easier part of the problem that has been already
</I>&gt;<i> solved.
</I>
s/Formatter/Packable/ and then this Alex guy tied the patch up that
starts Store.h include removal.

&gt;<i> 
</I>&gt;<i> The more difficult part is introducing a non-free-form Formatter class.
</I>&gt;<i> 
</I>
Yes.

&gt;<i> 
</I>&gt;&gt;<i> Primarily that we can do the formatting cleanup without adding a
</I>&gt;&gt;<i> circular dependency between libbase and libmem in the current code
</I>&gt;&gt;<i> situation.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This answer to my &quot;Why do the same change twice?&quot; question does not
</I>&gt;<i> compute/correlate for me. I do not see why two cleanups are better than
</I>&gt;<i> one here (if that is what you are implying). Also, &quot;without adding X&quot;
</I>&gt;<i> cannot be the reason because the existing code does not add anything.
</I>&gt;<i> 
</I>
 LDADD=
   store/libstore.la
   mem/libmem.la

... undefined symbols StoreEntry::* in libmem.

LDADD=
  mem/libmem.la
  store/libstore.la

... undefined symbols Mem::AllocatorProxy::* in store/libstore.la.


Since we dont have libstore yet the problem shows up indirectly with
other libraries in LDADD listed after libmem and presenting a symbol
used by Store code inline functions (ie. libhttp header types). When the
store code shuffles the above loop appears more clearly.


Anyhow. Thats hopefully not going to be relevant with a simple enough
Formatter and Packable.

&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> For now its just a free-form mix in plain text. To which a stream is
</I>&gt;&gt;&gt;&gt;<i> suited. And possible something the formatter classes could use better
</I>&gt;&gt;&gt;&gt;<i> than a direct Packable object pointer/reference.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The code for free-form formatting already exists. We do not want it in
</I>&gt;&gt;&gt;<i> the future. Why replace one free-form with a slightly different
</I>&gt;&gt;&gt;<i> free-form when what we need is YAML-form?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I want to see the reports actually looking like sets of tables 
</I>&gt;<i> 
</I>&gt;<i> This desire seems unrelated to my concern.
</I>&gt;<i> 
</I>
You asked. As you say my reason does not preclude meeting your concern.
Impass avoided this time around.

&gt;<i> 
</I>&gt;&gt;<i> For now I was taking the best approach from the currently existing but
</I>&gt;&gt;<i> incomplete designs in Squid code and picking the one that appears to be
</I>&gt;&gt;<i> most suited for completing. StoreEntryStream in current trunk appeared
</I>&gt;&gt;<i> to be the one that did not limit future display options.
</I>&gt;<i> 
</I>&gt;<i> I do not see how changing StoreEntry-&gt;append() to ostream::operator &lt;&lt;
</I>&gt;<i> helps you to make &quot;reports actually looking like sets of tables&quot; and/or
</I>&gt;<i> to move us closer to YAML support. Again, it feels like we are making
</I>&gt;<i> admins life harder without any significant internal improvements.
</I>
To use your argument from above:
 2 changes [layers] are better than 3.

Getting all the way down to 1 change did not seem possible a week ago
when I started this. Now it looks more hopeful.

&gt;<i> 
</I>&gt;&gt;<i> If you can agree that we start with a Mgr::Formatter class that does not
</I>&gt;&gt;<i> do anything initially but dump out a free-form &quot;notice&quot; box with a line
</I>&gt;&gt;<i> of text in it.
</I>&gt;<i> 
</I>&gt;<i> I hope we can come up with a minimal API (only usable for the very basic
</I>&gt;<i> output such as one-line notices and such). We will need to discuss and
</I>&gt;<i> agree on what that minimum is exactly.
</I>&gt;<i> 
</I>&gt;<i> If YAML support is one of the ultimate goals, then I would propose
</I>&gt;<i> something like this:
</I>&gt;<i> 
</I>&gt;<i> // Assembles information for a single Cache Manager &quot;page&quot;.
</I>&gt;<i> // Supplied information goes into a configured stream.
</I>&gt;<i> // Kids implement various information formatting methods.
</I>&gt;<i> class Page: public std::ostream {
</I>&gt;<i> public:
</I>&gt;<i>     Page(std::ostream &amp;os);
</I>
Does this mean you want to go head with PackableStream for the libmem
problem ?

If we plan to get rid of PackableStream / StoreEntryStream in the end
product that ctor could take a Packable&amp;.


This assumes that the Page object does the actual append() to the
Packable it references.

For the record; I have considered the alternative design where the Page
is just a struct holding tokens for output at each position in the
display state.
PageSimple {
.comment = ': ';
.beginList = ':\n';
.endList = '\n';
.tableRow = '\t';
.tableEndRow = '\n'
... and so on.
}

Useful for some syntaxes, but we can avoid things like tableEndRow
states with yours.


&gt;<i>     virtual ~Page() {}
</I>&gt;<i> 
</I>&gt;<i>     // a comment
</I>&gt;<i>     virtual Page &amp;comment(const SBuf &amp;text) = 0;
</I>&gt;<i> 
</I>
I was suggesting just the above bit in the first patch.

Although the immediate uses seem more like notice box / announcements
than regular text comment. The display end would highlight them in bold
colors or something to attract attention.


The below ...

B)

&gt;<i>     /// starts recording a list of values
</I>&gt;<i>     virtual Page &amp;beginList() = 0;
</I>&gt;<i>     /// finishes recording a list of values
</I>&gt;<i>     virtual Page &amp;endList() = 0;
</I>&gt;<i> 
</I>&gt;<i>     /// starts recording a list of values
</I>&gt;<i>     virtual Page &amp;beginListItem() = 0;
</I>&gt;<i>     /// finishes recording a list of values
</I>&gt;<i>     virtual Page &amp;endListItem() = 0;
</I>&gt;<i> 
</I>
A)
&gt;<i>     /// starts recording a key:value pair with a given key
</I>&gt;<i>     virtual Page &amp;beginKv(const SBuf &amp;key) = 0;
</I>&gt;<i>     /// finishes recording a key:value pair
</I>&gt;<i>     virtual Page &amp;endKv() = 0;
</I>&gt;<i> ...
</I>
(A) deferred to next patch updating a report that uses just a kv-pair
output list.

Then (B) or similar when a tabular report is done.

&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> The methods below comment() may be needed for more advanced stuff like
</I>&gt;<i> the menu but probably not needed for &quot;notice boxes&quot;. If that API is what
</I>&gt;<i> you were describing as a free-form &quot;notice box&quot; or &quot;line of text&quot;, then
</I>&gt;<i> we are in agreement.
</I>
Okay.

&gt;<i> 
</I>&gt;<i> The attached file has a sample implementation of that API for a YAML
</I>&gt;<i> formatter. It currently violates most YAML rules but can become
</I>&gt;<i> compliant with more work. Here is a sample output for the menu page
</I>&gt;<i> (adjusted for indentation that is not automated in the sample code):
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ---
</I>&gt;<i> - 5min: menu item description to be extracted from Action::desc
</I>&gt;<i>   protection: public
</I>&gt;<i> - 60min: menu item description to be extracted from Action::desc
</I>&gt;<i>   protection: public
</I>&gt;<i> - disk_io: menu item description to be extracted from Action::desc
</I>&gt;<i>   protection: public
</I>&gt;<i> - events: menu item description to be extracted from Action::desc
</I>&gt;<i>   protection: public
</I>&gt;<i> - shutdown: menu item description to be extracted from Action::desc
</I>&gt;<i>   protection: public
</I>&gt;<i> # This is not really related to the menu example above
</I>&gt;<i> TestKey: several words per 1 value are OK
</I>&gt;<i> ---
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>  ... the remainder is specific to the proposed PackableStream or
</I>&gt;&gt;<i> StoreEntryStream code. Which would be dropped if you agree on the above
</I>&gt;&gt;<i> approach for how to get a Formatter class transition going.
</I>&gt;<i> 
</I>&gt;<i> Sorry, have to run. I will read/review the rest later.
</I>
Nevermind. I'm dropping it for now and running with the above.

Amos
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002956.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
	<LI>Next message: <A HREF="002961.html">[squid-dev] [PATCH] PackableStream for cachemgr reports
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2957">[ date ]</a>
              <a href="thread.html#2957">[ thread ]</a>
              <a href="subject.html#2957">[ subject ]</a>
              <a href="author.html#2957">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
