<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] squid SSL subsystem did not initialized correctly
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20squid%20SSL%20subsystem%20did%20not%20initialized%0A%20correctly&In-Reply-To=%3C55C8B154.2040206%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002958.html">
   <LINK REL="Next"  HREF="002964.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] squid SSL subsystem did not initialized correctly</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20squid%20SSL%20subsystem%20did%20not%20initialized%0A%20correctly&In-Reply-To=%3C55C8B154.2040206%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] squid SSL subsystem did not initialized correctly">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Aug 10 14:12:36 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002958.html">[squid-dev] [PATCH] squid SSL subsystem did not initialized	correctly
</A></li>
        <LI>Next message: <A HREF="002964.html">[squid-dev] [PATCH] squid SSL subsystem did not initialized	correctly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2959">[ date ]</a>
              <a href="thread.html#2959">[ thread ]</a>
              <a href="subject.html#2959">[ subject ]</a>
              <a href="author.html#2959">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/08/2015 11:29 p.m., Tsantilas Christos wrote:
&gt;<i> On 08/06/2015 02:55 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 6/08/2015 9:54 p.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;<i> Hi all,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     Currently SSL subsystem did not initialized correctly in squid
</I>&gt;&gt;&gt;<i> trunk.
</I>&gt;&gt;&gt;<i> This is because of the Security::ProxyOutgoingConfig.encryptTransport
</I>&gt;&gt;&gt;<i> which is always false so the client SSL CTX object never builds. As a
</I>&gt;&gt;&gt;<i> result squid may not start if SSL is configured. I am attaching a small
</I>&gt;&gt;&gt;<i> patch I am using in my squid trees to work with SSL.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This always-enabled code is not compatible with the possible admin
</I>&gt;&gt;<i> configuration:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   tls_outgoing_options disable
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Can you please try this instead:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   Security::PeerOptions::parse(const char *token)
</I>&gt;&gt;<i>   {
</I>&gt;&gt;<i>       if (strncmp(token, &quot;disable&quot;, 7) == 0) {
</I>&gt;&gt;<i>           clear();
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i>       } else if (strncmp(token, &quot;cert=&quot;, 5) == 0) {
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i>       } else {
</I>&gt;&gt;<i>           debugs(3, DBG_CRITICAL, &quot;ERROR: Unknown TLS option '&quot; &lt;&lt; ...
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i>       }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    encryptTransport = true;
</I>&gt;&gt;<i>   }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If that works you can go through and also remove uses of
</I>&gt;&gt;<i> &quot;secure.encryptTransport = true&quot; from adaptation/ServiceConfig.cc and
</I>&gt;&gt;<i> cache_cf.cc where it is set next to a call to secure.parse()
</I>&gt;&gt;<i> ... but not the other one where it is set to always-on for https_port.
</I>&gt;<i> 
</I>&gt;<i> This is will not work, because it is not required for someone to
</I>&gt;<i> configure any of the sslproxy options for the SSL client to work.
</I>&gt;<i> Squid can always work with the default options.
</I>
Did you test it?

The default squid.conf parser always sets &quot;tls_outgoing_options
tls-min-version=1.0&quot;. Which should auto-enable DIRECT outgoing, then
explicit disable is required to turn off again.


http_port ... protocol=HTTPS and https_port forces
&quot;encryptTransport=true;&quot; explicitly based on the expected protocol. So
it is either enabled by the parse() call when TLS options are used, or
forced on anyway later when the protocol is validated.


<A HREF="icaps://">icaps://</A> services also explicitly set &quot;encryptTransport=true;&quot;
explicitly based on 's' in the service URI scheme.

The cache_peer requires a minimum of &quot;ssl&quot; option to be configured. And
calls parse(). I see that simple case is passing &quot;&quot; token which gets
reported as unknown option.


With the attached patch TLS should be:
* default-on for all https_port, <A HREF="icaps://">icaps://</A> services, and outgoing
<A HREF="https://">https://</A> traffic.
* manually enabled on cache_peer and http_port.
* manually disabled on outgoing <A HREF="https://">https://</A> traffic.


&gt;<i> 
</I>&gt;<i> The Security::ProxyOutgoingConfig.encryptTransport = true must be always
</I>&gt;<i> true unless the the SSL client is disabled.
</I>
Yes. And the default config should see to that happening. Which is why I
asked if you could try the change.


&gt;<i> 
</I>&gt;<i> In previous squid releases it was not possible to disable SSL client,
</I>&gt;<i> but now looks that this is can be done using the
</I>&gt;<i>   &quot;tls_outgoing_options disable&quot;
</I>
Yes, that is new in Squid-4. Along with some small non-OpenSSL HTTPS
support (not much yet, but growing).


&gt;<i> 
</I>&gt;<i> Maybe we need to add a parameter to Security::PeerOptions constructor,
</I>&gt;<i> to define if the SSL is enabled by default (for example in the case of
</I>&gt;<i> ProxyOutgoingConfig) or not (for example in HTTP ports configuration).
</I>&gt;<i> 
</I>
That would be messy because ProxyOutgoingConfig is a global and the
others are all explicitly constructed.

Amos

-------------- next part --------------
=== modified file 'src/adaptation/ServiceConfig.cc'
--- src/adaptation/ServiceConfig.cc	2015-05-06 14:58:01 +0000
+++ src/adaptation/ServiceConfig.cc	2015-08-10 12:49:30 +0000
@@ -119,41 +119,40 @@
         else if (strcmp(name, &quot;uri&quot;) == 0)
             grokked = grokkedUri = grokUri(value);
         else if (strcmp(name, &quot;ipv6&quot;) == 0) {
             grokked = grokBool(ipv6, name, value);
             if (grokked &amp;&amp; ipv6 &amp;&amp; !Ip::EnableIpv6)
                 debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: IPv6 is disabled. ICAP service option ignored.&quot;);
         } else if (strcmp(name, &quot;max-conn&quot;) == 0)
             grokked = grokLong(maxConn, name, value);
         else if (strcmp(name, &quot;on-overload&quot;) == 0) {
             grokked = grokOnOverload(onOverload, value);
             onOverloadSet = true;
         } else if (strncmp(name, &quot;ssl&quot;, 3) == 0 || strncmp(name, &quot;tls-&quot;, 4) == 0) {
 #if !USE_OPENSSL
             debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: adaptation option '&quot; &lt;&lt; name &lt;&lt; &quot;' requires --with-openssl. ICAP service option ignored.&quot;);
 #else
             // name prefix is &quot;ssl&quot; or &quot;tls-&quot;
             std::string tmp = name + (name[0] == 's' ? 3 : 4);
             tmp += &quot;=&quot;;
             tmp += value;
             secure.parse(tmp.c_str());
-            secure.encryptTransport = true;
             grokked = true;
 #endif
         } else
             grokked = grokExtension(name, value);
 
         if (!grokked)
             return false;
     }
 
     // set default on-overload value if needed
     if (!onOverloadSet)
         onOverload = bypass ? srvBypass : srvWait;
 
     // is the service URI set?
     if (!grokkedUri) {
         debugs(3, DBG_CRITICAL, cfg_filename &lt;&lt; ':' &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt;
                &quot;No \&quot;uri\&quot; option in adaptation service definition&quot;);
         return false;
     }
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-08-04 21:04:09 +0000
+++ src/cache_cf.cc	2015-08-10 12:47:04 +0000
@@ -2176,45 +2176,43 @@
         } else if (!strncmp(token, &quot;max-conn=&quot;, 9)) {
             p-&gt;max_conn = xatoi(token + 9);
         } else if (!strncmp(token, &quot;standby=&quot;, 8)) {
             p-&gt;standby.limit = xatoi(token + 8);
         } else if (!strcmp(token, &quot;originserver&quot;)) {
             p-&gt;options.originserver = true;
         } else if (!strncmp(token, &quot;name=&quot;, 5)) {
             safe_free(p-&gt;name);
 
             if (token[5])
                 p-&gt;name = xstrdup(token + 5);
         } else if (!strncmp(token, &quot;forceddomain=&quot;, 13)) {
             safe_free(p-&gt;domain);
             if (token[13])
                 p-&gt;domain = xstrdup(token + 13);
 
         } else if (strncmp(token, &quot;ssl&quot;, 3) == 0) {
 #if !USE_OPENSSL
             debugs(0, DBG_CRITICAL, &quot;WARNING: cache_peer option '&quot; &lt;&lt; token &lt;&lt; &quot;' requires --with-openssl&quot;);
 #else
-            p-&gt;secure.encryptTransport = true;
             p-&gt;secure.parse(token+3);
 #endif
         } else if (strncmp(token, &quot;tls-&quot;, 4) == 0) {
-            p-&gt;secure.encryptTransport = true;
             p-&gt;secure.parse(token+4);
         } else if (strcmp(token, &quot;front-end-https&quot;) == 0) {
             p-&gt;front_end_https = 1;
         } else if (strcmp(token, &quot;front-end-https=on&quot;) == 0) {
             p-&gt;front_end_https = 1;
         } else if (strcmp(token, &quot;front-end-https=auto&quot;) == 0) {
             p-&gt;front_end_https = 2;
         } else if (strcmp(token, &quot;connection-auth=off&quot;) == 0) {
             p-&gt;connection_auth = 0;
         } else if (strcmp(token, &quot;connection-auth&quot;) == 0) {
             p-&gt;connection_auth = 1;
         } else if (strcmp(token, &quot;connection-auth=on&quot;) == 0) {
             p-&gt;connection_auth = 1;
         } else if (strcmp(token, &quot;connection-auth=auto&quot;) == 0) {
             p-&gt;connection_auth = 2;
         } else if (token[0] == '#') {
             // start of a text comment. stop reading this line.
             break;
         } else {
             debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;ERROR: Ignoring unknown cache_peer option '&quot; &lt;&lt; token &lt;&lt; &quot;'&quot;);

=== modified file 'src/security/PeerOptions.cc'
--- src/security/PeerOptions.cc	2015-07-19 08:33:29 +0000
+++ src/security/PeerOptions.cc	2015-08-10 12:46:13 +0000
@@ -25,79 +25,91 @@
 Security::PeerOptions::PeerOptions(const Security::PeerOptions &amp;p) :
     certFile(p.certFile),
     privateKeyFile(p.privateKeyFile),
     sslOptions(p.sslOptions),
     caFile(p.caFile),
     caDir(p.caDir),
     crlFile(p.crlFile),
     sslCipher(p.sslCipher),
     sslFlags(p.sslFlags),
     sslDomain(p.sslDomain),
     parsedOptions(p.parsedOptions),
     parsedFlags(p.parsedFlags),
     sslVersion(p.sslVersion),
     encryptTransport(p.encryptTransport)
 {
 }
 
 void
 Security::PeerOptions::parse(const char *token)
 {
+    if (!*token) {
+        // config says just &quot;ssl&quot; or &quot;tls&quot; (or &quot;tls-&quot;)
+        encryptTransport = true;
+        return;
+    }
+
     if (strncmp(token, &quot;disable&quot;, 7) == 0) {
         clear();
-    } else if (strncmp(token, &quot;cert=&quot;, 5) == 0) {
+        return;
+    }
+
+    if (strncmp(token, &quot;cert=&quot;, 5) == 0) {
         certFile = SBuf(token + 5);
         if (privateKeyFile.isEmpty())
             privateKeyFile = certFile;
     } else if (strncmp(token, &quot;key=&quot;, 4) == 0) {
         privateKeyFile = SBuf(token + 4);
         if (certFile.isEmpty()) {
             debugs(3, DBG_PARSE_NOTE(1), &quot;WARNING: cert= option needs to be set before key= is used.&quot;);
             certFile = privateKeyFile;
         }
     } else if (strncmp(token, &quot;version=&quot;, 8) == 0) {
         debugs(0, DBG_PARSE_NOTE(1), &quot;UPGRADE WARNING: SSL version= is deprecated. Use options= to limit protocols instead.&quot;);
         sslVersion = xatoi(token + 8);
     } else if (strncmp(token, &quot;min-version=&quot;, 12) == 0) {
         tlsMinVersion = SBuf(token + 12);
     } else if (strncmp(token, &quot;options=&quot;, 8) == 0) {
         sslOptions = SBuf(token + 8);
         parsedOptions = parseOptions();
     } else if (strncmp(token, &quot;cipher=&quot;, 7) == 0) {
         sslCipher = SBuf(token + 7);
     } else if (strncmp(token, &quot;cafile=&quot;, 7) == 0) {
         caFile = SBuf(token + 7);
     } else if (strncmp(token, &quot;capath=&quot;, 7) == 0) {
         caDir = SBuf(token + 7);
     } else if (strncmp(token, &quot;crlfile=&quot;, 8) == 0) {
         crlFile = SBuf(token + 8);
     } else if (strncmp(token, &quot;flags=&quot;, 6) == 0) {
         if (parsedFlags != 0) {
             debugs(3, DBG_PARSE_NOTE(1), &quot;WARNING: Overwriting flags=&quot; &lt;&lt; sslFlags &lt;&lt; &quot; with &quot; &lt;&lt; SBuf(token + 6));
         }
         sslFlags = SBuf(token + 6);
         parsedFlags = parseFlags();
     } else if (strncmp(token, &quot;domain=&quot;, 7) == 0) {
         sslDomain = SBuf(token + 7);
     } else {
         debugs(3, DBG_CRITICAL, &quot;ERROR: Unknown TLS option '&quot; &lt;&lt; token &lt;&lt; &quot;'&quot;);
+        return;
     }
+
+    encryptTransport = true;
 }
 
 void
 Security::PeerOptions::dumpCfg(Packable *p, const char *pfx) const
 {
     if (!encryptTransport) {
         p-&gt;appendf(&quot; %sdisable&quot;, pfx);
         return; // no other settings are relevant
     }
 
     if (!certFile.isEmpty())
         p-&gt;appendf(&quot; %scert=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(certFile));
 
     if (!privateKeyFile.isEmpty() &amp;&amp; privateKeyFile != certFile)
         p-&gt;appendf(&quot; %skey=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(privateKeyFile));
 
     if (!sslOptions.isEmpty())
         p-&gt;appendf(&quot; %soptions=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslOptions));
 
     if (!sslCipher.isEmpty())

</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002958.html">[squid-dev] [PATCH] squid SSL subsystem did not initialized	correctly
</A></li>
	<LI>Next message: <A HREF="002964.html">[squid-dev] [PATCH] squid SSL subsystem did not initialized	correctly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2959">[ date ]</a>
              <a href="thread.html#2959">[ thread ]</a>
              <a href="subject.html#2959">[ subject ]</a>
              <a href="author.html#2959">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
