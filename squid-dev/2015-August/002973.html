<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [WTF] HttpHeader strangenesses
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BWTF%5D%20HttpHeader%20strangenesses&In-Reply-To=%3C55C9624C.6050204%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002970.html">
   <LINK REL="Next"  HREF="002982.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [WTF] HttpHeader strangenesses</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BWTF%5D%20HttpHeader%20strangenesses&In-Reply-To=%3C55C9624C.6050204%40treenet.co.nz%3E"
       TITLE="[squid-dev] [WTF] HttpHeader strangenesses">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Aug 11 02:47:40 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002970.html">[squid-dev] [WTF] HttpHeader strangenesses
</A></li>
        <LI>Next message: <A HREF="002982.html">[squid-dev] [WTF] HttpHeader strangenesses
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2973">[ date ]</a>
              <a href="thread.html#2973">[ thread ]</a>
              <a href="subject.html#2973">[ subject ]</a>
              <a href="author.html#2973">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/08/2015 11:10 a.m., Alex Rousskov wrote:
&gt;<i> On 08/10/2015 02:13 PM, Kinkie wrote:
</I>&gt;&gt;<i> I'm going over HttpHeader to see if there's any possible improvements to
</I>&gt;&gt;<i> be obtained by dragging it (kicking and screaming, from the look of it)
</I>&gt;&gt;<i> into the 10's.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Here's a list of weirdnesses I'm coming to find, hopefully someone has
</I>&gt;&gt;<i> any idea of WHY they are like this, or if they can be safely be removed:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - HttpHeader::insertTime makes no sense. It's O(N) and it's always used
</I>&gt;&gt;<i> in two patterns: delById(HDR); insertTime(HDR) and if (!has(HDR)
</I>&gt;&gt;<i> insertTime(HDR)).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Henrik may know why he went the extra mile to insert header Date at the
</I>&gt;<i> beginning of the message as opposed to just appending it at the end
</I>&gt;<i> (trunk r7037).
</I>&gt;<i> 
</I>
IIRC its a HTTP/1.0 performance optimization.

Locating Host quickly avoids work in the inefficient getHost() pre-parse
function which is now Http::One::Parser::getHeaderField().

Locating Date header at the top avoids a similar scan to determine
cacheability and validity of received replies. AFAIK that is not a
useful now that HTTP/1.1 involve other headers than Date.



&gt;<i> If I have to guess, I would say that it might be related to the RFC 2616
</I>&gt;<i> recommendation to order headers a certain way:
</I>&gt;<i> 
</I>&gt;&gt;<i> it is &quot;good practice&quot; to send
</I>&gt;&gt;<i> general-header fields first, followed by request-header or response-
</I>&gt;&gt;<i> header fields, and ending with the entity-header fields.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> RFC 7230 updates that with:
</I>&gt;<i> 
</I>&gt;&gt;<i> it is good practice to send
</I>&gt;&gt;<i> header fields that contain control data first, such as Host on
</I>&gt;&gt;<i> requests and Date on responses
</I>&gt;<i> 
</I>
Yes. And HTTP/2 will add a third group of &quot;pseudo&quot; headers representing
URI segments with a MUST condition of being at the top of the header list.

So if we want to optimize it is probably best to optimize allowing this
type of insertion than to remove it completely. At least sorting in
blocks of { pseudo, control, entity, custom/unknown } header type. Exact
placement within each grouping is only important for list headers.

We probably want to be making the headers list into multiple lists and
just add/remove/append to the appropriate one. Squid will mostly not
have to deal with the entity or custom headers at all and it wastes time
searching through them for control headers that were already found
during parse.


We may also want to think about having the control headers as
first-class unique members of HttpHeader instead of using the list
accesses. For example a HdrDate HdrCc, HdrSc, Hdr member that stores the
date including a &quot;not present&quot; flag. Leaving the headers list only
containing the entity and unknown headers.
 Assembling the message buffer would then be a hard-coded sequence of {
member Host, member Date, member Cc, member ..., walk generic headers list }


&gt;<i> 
</I>&gt;&gt;<i> I've replaced with putTime everywhere
</I>&gt;<i> 
</I>&gt;<i> Sounds good to me. IIRC, at some point, we have tried to make &quot;put&quot;
</I>&gt;<i> delete all old headers, but I doubt that idea survived. To make the code
</I>&gt;<i> consistent, you may want to check that no remaining put methods delete
</I>&gt;<i> old headers now (and adjust the code as needed if some still do).
</I>&gt;<i> 
</I>
Seconded.

&gt;<i> 
</I>&gt;&gt;<i> - why doesn't HttpHeaderEntry use a copy-constructor, relying instead in
</I>&gt;&gt;<i> a clone() method?
</I>&gt;<i> 
</I>&gt;<i> The conversion from a C struct to a C++ class was incomplete, most
</I>&gt;<i> likely because we did not know as much about C++ as we know now.
</I>&gt;<i> Renaming the old httpHeaderEntryClone() into HttpHeaderEntry::clone()
</I>&gt;<i> was probably a natural thing to do ten years ago (trunk r7589).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> - why the strange loop in HttpHeader's copy-constructor?
</I>&gt;<i> 
</I>&gt;<i> What do you find strange about it? It just reuses a method to clone all
</I>&gt;<i> the header fields from the other header. I could (should?) have
</I>&gt;<i> optimized this by refactoring the cloning/second loop from update() into
</I>&gt;<i> a separate cloneEntries() method and using just that.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Replaced with a &quot;= default&quot;, it should be just fine..
</I>&gt;<i> 
</I>&gt;<i> But is it? AFAICT, the &quot;default&quot; (i.e., generated) copy constructor will
</I>&gt;<i> not clone individual header entries. Perhaps you have added some magic
</I>&gt;<i> to make that cloning happen now, but the old code did require an
</I>&gt;<i> explicit cloning loop (the second loop in update(), see above).
</I>&gt;<i> 
</I>
Nod. I find its best to think of default copy-constructor a memcpy()
(usually it is) and do the appropriate actions whenever that would not
be suitable.


&gt;<i> 
</I>&gt;&gt;<i> - statistics accounting: we count A LOT (see HttpHeader::clean) Is it
</I>&gt;&gt;<i> really worth it in a performance-critical code as this? Maybe we could
</I>&gt;&gt;<i> shuffle things around to HttpHeader and HttpHeaderEntry's ctor and dtor ..
</I>&gt;<i> 
</I>&gt;<i> The statics code is ugly and, IIRC, collects inaccurate stats in many
</I>&gt;<i> cases. I am sure it can be significantly improved.
</I>&gt;<i> 
</I>&gt;<i> However, I would recommend going into the _opposite_ direction. Instead
</I>&gt;<i> of trying to find the right low-level code to collect header stats (and
</I>&gt;<i> then dealing with problems such as cloned headers screwing up all
</I>&gt;<i> stats), I would add dedicated statistics-collection calls in a few
</I>&gt;<i> specific places in the high-level code, where new headers are &quot;accepted
</I>&gt;<i> into Squid&quot; and should be counted.
</I>&gt;<i> 
</I>&gt;<i> Neither approach will cover 100% of cases, but I think the high-level
</I>&gt;<i> approach will have a lot less problems overall. As an added bonus, it
</I>&gt;<i> would be easier to disable all or some statistics header collection that
</I>&gt;<i> way.
</I>

Agreed. Parser is the only thing that should be stats accounting for
&quot;seen&quot; (aka received) headers. And that can do it at the same point it
adds the freshly parsed value to the HttpHeader object state.
 As a bonus it even knows the type of message the header was seen in for
request/reply and HTTP/ICAP/HTCP stats correctness.

Amos
</PRE>



































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002970.html">[squid-dev] [WTF] HttpHeader strangenesses
</A></li>
	<LI>Next message: <A HREF="002982.html">[squid-dev] [WTF] HttpHeader strangenesses
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2973">[ date ]</a>
              <a href="thread.html#2973">[ thread ]</a>
              <a href="subject.html#2973">[ subject ]</a>
              <a href="author.html#2973">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
