<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [CODE] iterating over enums
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BCODE%5D%20iterating%20over%20enums&In-Reply-To=%3C55CB9A6C.7090201%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003000.html">
   <LINK REL="Next"  HREF="003008.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [CODE] iterating over enums</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BCODE%5D%20iterating%20over%20enums&In-Reply-To=%3C55CB9A6C.7090201%40measurement-factory.com%3E"
       TITLE="[squid-dev] [CODE] iterating over enums">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Aug 12 19:11:40 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003000.html">[squid-dev] [CODE] iterating over enums
</A></li>
        <LI>Next message: <A HREF="003008.html">[squid-dev] [CODE] iterating over enums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3002">[ date ]</a>
              <a href="thread.html#3002">[ thread ]</a>
              <a href="subject.html#3002">[ subject ]</a>
              <a href="author.html#3002">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/12/2015 09:36 AM, Kinkie wrote:

&gt;<i> So I went ahead and just implemented it, starting from your observations.
</I>&gt;<i> It's a bit more complex that your proposal, as I took the chance to
</I>&gt;<i> implement bidirectional forward and reverse iterators.
</I>&gt;<i> The attached patch is in changeset 14235 of
</I>&gt;<i> lp:~kinkie/squid/coverity-fixes, but since the code is quite well
</I>&gt;<i> self-contained I'd like to submit it for audit as a standalone unit; If
</I>
Yes, submitting Enum iterators for review as a stand-alone patch is the
right thing to do. Hiding this and other significant changes under
&quot;coverity fixes&quot; cover is wrong IMO, even if those changes were prompted
by something Coverity has detected.

I would encourage you to show actual Squid usage examples (besides
artificial test cases), either in the patch itself or in the patch cover
email.

Also, please adjust the WholeEnum documentation. It is currently too
similar to EnumRange, including the identical first/summary line. It is
often best to document children classes in terms of parent classes
rather then repeating everything the parent documentation [currently]
says IMO. For example:

/// EnumRange for iterating all enum values, from enumBegin_ up to, but
// not including, enumEnd_. The two markers must be present in the enum.
template &lt;typename Enum&gt;
class WholeEnum ...


If you have not considered implementing WholeEnum without inheritance,
please do so. I speculate that lack of any data members may help inline
WholeEnum. Please note that I am just asking you to _consider_ this. I
do not have enough information to insist on it.


&gt;<i> +    typedef typename std::underlying_type&lt;Enum&gt;::type value_t;
</I>&gt;<i> +    value_t current_value;
</I>
This type and data member is more about iteration position than &quot;value&quot;
(in STL sense). AFAICT, STL calls this type &quot;iterator_type&quot; and the data
member &quot;current&quot;. I think that naming is better than yours.


&gt;<i> +    reverse_iterator rbegin() const { auto i = reverse_iterator(end_); ++i; return i; }
</I>&gt;<i> +    reverse_iterator rend() const { auto i = reverse_iterator(begin_); ++i; return i; }
</I>
If these methods can be implemented simply as

  reverse_iterator rbegin() const { return ++reverse_iterator(end_); }
  reverse_iterator rend() const { return ++reverse_iterator(begin_); }

then please simplify.


I do not understand how rend() would actually work when iterating whole
enums! For a typical enum that starts with a zero-valued item, will the
rend() position (called current_value in your code) go negative?? Is
that actually guaranteed to work by the standard? If not, we may need to
require a begin-1 marker (which may be negative if needed)!

Are you sure you need reverse iterators at all?


[ EnumRange is not suitable for iterating up to the end of an enum that
does not have an end+1 marker. This limitation is not a bug, but may be
another reason to require all enums to have markers. ]


If possible, please add and use a global function to guess EnumRange
template parameter value from the actual function parameter types and
return the right EnumRange object, to avoid writing Enum type three
times when using EnumRangeT&lt;&gt;.

  template &lt;typename Enum&gt;
  EnumRangeT&lt;Enum&gt; EnumRange(Enum begin, Enum end) {
      return EnumRangeT&lt;Enum&gt;(begin, end);
  }


HTH,

Alex.



&gt;<i> On 08/05/2015 07:58 PM, Kinkie wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> What I understand from the changes you propose is that:
</I>&gt;<i> 
</I>&gt;&gt;<i> 1. instead of having explicit begin/end markers passed as template
</I>&gt;&gt;<i> arguments you propose to have a convention on begin/end markers.
</I>&gt;<i> 
</I>&gt;<i> There are several different things/layers mixed up here:
</I>&gt;<i> 
</I>&gt;<i> * If we want to use range loops for enums [in a sane way], then our
</I>&gt;<i> enums should have begin/end markers. Many already do, but we will have
</I>&gt;<i> to standardize their names and fill the gaps.
</I>&gt;<i> 
</I>&gt;<i> * The begin/end parameters should not be template parameters.
</I>&gt;<i> 
</I>&gt;<i> * If we need to iterate sub-ranges, then we should add EnumRangeT&lt;Enum&gt;
</I>&gt;<i> class with begin/end as constructor parameters (see below).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> 2. you skip the typedef fixing these parameters in favor of letting the
</I>&gt;&gt;<i> template parameters appear in the calls.
</I>&gt;<i> 
</I>&gt;<i> There are two separate issues/layers here:
</I>&gt;<i> 
</I>&gt;<i> * Naming an expression is a good idea, especially if that name is going
</I>&gt;<i> to be used multiple times.
</I>&gt;<i> 
</I>&gt;<i> * Fewer template parameters are generally better if they can accomplish
</I>&gt;<i> the same thing as more template parameters.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> 1. looks interesting, especially as an enum missing those markers will
</I>&gt;&gt;<i> fail to compile. Maybe both approaches can be combined by using default
</I>&gt;&gt;<i> template arguments, what do you think?
</I>&gt;&gt;<i> template &lt;typename C, C first = C::enumBegin_, C last_plus_one =
</I>&gt;&gt;<i> C::enumEnd_&gt;
</I>&gt;<i> 
</I>&gt;<i> I think we should not specify iteration range boundaries as template
</I>&gt;<i> parameters.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> 3. we could maybe combine the benefits of beautiful range-for and ugly
</I>&gt;&gt;<i> explicit-for also for shorter ranges by having (in the class-based
</I>&gt;&gt;<i> variant), on top of what you have already proposed (untested)
</I>&gt;<i> 
</I>&gt;<i> Yes, if sub-range iteration using range loops is needed, then we should
</I>&gt;<i> add EnumRangeT&lt;Enum&gt; class that does it. Sorry if I have not mentioned
</I>&gt;<i> that explicitly.
</I>&gt;<i> 
</I>&gt;<i> Your sketch for that class is fine, but it will be a EnumRangeT class,
</I>&gt;<i> separate from simpler WholeEnum, and we would try to define a function
</I>&gt;<i> that will create that EnumRangeT object so that we only have to type
</I>&gt;<i> &quot;Numbers&quot; zero or two times as illustrated below:
</I>&gt;<i> 
</I>&gt;<i> template &lt;typename Enum&gt;
</I>&gt;<i> inline
</I>&gt;<i> EnumRangeT&lt;Enum&gt; EnumRange(const Enum from, const Enum to) {
</I>&gt;<i>     return EnumRangeT&lt;Enum&gt;(from, to);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> So that instead of:
</I>&gt;<i> 
</I>&gt;&gt;<i> for (auto i : WholeEnum&lt;Numbers&gt;(Numbers::one, Numbers::three)) {
</I>&gt;&gt;<i>  // do stuff
</I>&gt;&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> we could do:
</I>&gt;<i> 
</I>&gt;<i>   // iterating sub-range of a class enum:
</I>&gt;<i>   for (auto i: EnumRange(Numbers::one, Numbers::three)) ...
</I>&gt;<i> 
</I>&gt;<i>   // iterating sub-range of a global C enum:
</I>&gt;<i>   for (auto i: EnumRange(one, three)) ...
</I>&gt;<i> 
</I>&gt;<i>   // iterating a whole enum:
</I>&gt;<i>   for (auto i: WholeEnum&lt;Numbers&gt;()) ...
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Again, the above range objects can be named (and the first two should be
</I>&gt;<i> named if they are used more than once). For example:
</I>&gt;<i> 
</I>&gt;<i>   WholeEnum&lt;Numbers&gt; AllNumbers() { return WholeEnum&lt;Numbers&gt;(); }
</I>&gt;<i> 
</I>&gt;<i>   EnumRange&lt;Numbers&gt; FooBarNumbers() { return EnumRange(Numbers::foo,
</I>&gt;<i> Numbers::bar); }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> It looks to me that I have crossed an itch you feel as well,
</I>&gt;<i> 
</I>&gt;<i> No, I am just trying to help you scratch your itch without scarring
</I>&gt;<i> Squid code. I do not know whether your itch is real or imaginary.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Cheers,
</I>&gt;<i> 
</I>&gt;<i> Alex.
</I>&gt;<i> 
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003000.html">[squid-dev] [CODE] iterating over enums
</A></li>
	<LI>Next message: <A HREF="003008.html">[squid-dev] [CODE] iterating over enums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3002">[ date ]</a>
              <a href="thread.html#3002">[ thread ]</a>
              <a href="subject.html#3002">[ subject ]</a>
              <a href="author.html#3002">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
