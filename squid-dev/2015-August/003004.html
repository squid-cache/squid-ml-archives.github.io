<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PayloadFormatter (was PackableStream)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55CBC685.4070004%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002995.html">
   <LINK REL="Next"  HREF="003019.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PayloadFormatter (was PackableStream)</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55CBC685.4070004%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] PayloadFormatter (was PackableStream)">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Aug 12 22:19:49 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002995.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
        <LI>Next message: <A HREF="003019.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3004">[ date ]</a>
              <a href="thread.html#3004">[ thread ]</a>
              <a href="subject.html#3004">[ subject ]</a>
              <a href="author.html#3004">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/12/2015 06:28 AM, Amos Jeffries wrote:
&gt;<i> On 12/08/2015 5:07 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 08/10/2015 08:20 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> Here is mk2 of the Formatter class for doing display things to CacheMgr
</I>&gt;&gt;&gt;<i> report payloads.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please post the patch (your post had no attachments), preferably
</I>&gt;&gt;<i> reflecting the discussion that happened since then.
</I>

&gt;<i> Oops. Sorry.
</I>

Unfortunately this patch does not seem to reflect recent discussions. I
am not sure how to restart them efficiently, but here are a few specific
comments:


&gt;<i> +/// Base API for organizing the processing of a compiled cache manager command.
</I>&gt;<i> +/// Not a job because all methods are synchronous (but they may start jobs).
</I>&gt;<i> +class PayloadFormatter
</I>
Wrong class description (belongs to Action, not this class).

I do not think we should call this class Mgr::PayloadFormatter because
it formats high-level [cache manager] reports and &quot;payload&quot; is commonly
used to refer to very different (and usually low-level) things.
Moreover, formatting may be just one of the things this class does. I
believe something like Mgr::Page, Mgr::Report or, if you really want a
Formatter suffix, Mgr::Page/ReportFormatter would work much better.

The same applies to other changes using &quot;payload&quot; terminology.


&gt;<i> +/**
</I>&gt;<i> + * Produces cache manager report payloads in a human-readable markup syntax
</I>&gt;<i> + * which is parsed by the cachemgr.cgi tool.
</I>...
&gt;<i> +class PayloadOldCgi: public PayloadFormatter
</I>
I think it is wrong to strongly associate the old format with
cachemgr.cgi. Lot's of admins use those reports without cachemgr.cgi.
The CGI script is just one way to render them. I also would not use the
&quot;Old&quot; suffix because the current format might remain with us forever and
watch other formats become &quot;old&quot;.

Alternatives to consider: Mgr::PlainPage or Mgr::PlainReport.


&gt;<i> +class PayloadFormatter
</I>...
&gt;<i> +    Packable &outBuf;
</I>&gt;<i> +};
</I>
Since the majority of PayloadFormatter methods and callers are going to
assemble and format pieces of text and numbers, I think this should
become an ostream. Or, if you have very good reasons for using outBuf
here, there could be a method that returns an ostream backed by this outBuf.

Almost all the code that uses outBuf and PayloadFormatter methods in the
patch already looks labored/awkward (often worse than the trivial code
it replaces!), and would look much better if replaced by the usual
ostream &quot;&lt;&lt;&quot; expressions.

This is important to address now so that we do not have to suffer with
an awkward cache manager page writing interface through all the future
Action::dump() rewrites.


&gt;<i> +    // a comment
</I>&gt;<i> +    virtual void notice(const SBuf &amp;) = 0;
</I>
Let's try to define the purpose of this method more precisely so that we
know when it is being used [in]correctly. For example:

  /// a free-form comment or informational text that
  /// is not meant to be further parsed by automation tools
  virtual void notice(const SBuf &amp;) = 0;

Return PayloadFormatter reference so that the calls can be chained
together (see earlier discussion for examples).


&gt;<i> +    void notImplemented(const char *name, size_t len) {
</I>&gt;<i> +        outBuf.append(name, len);
</I>&gt;<i> +        outBuf.append(&quot; is Not Implemented&quot;,19);
</I>&gt;<i> +    }
</I>
Missing documentation for a non-obvious public method. Most likely, you
do not want the second argument because callers will not find it useful.
The current caller does not AFAICT.

The current implementation will violate formatting rules.
PayloadFormatter methods should not write text directly because they do
not know how it is supposed to be formatted! The implementation should
probably just use notice() instead.

Please add &quot;cache manager action&quot; prefix to explain what is not
implemented. I would also rename notImplemented() to
actionNotImplemented() for clarity sake.

Capitalization in &quot;foo is Not Implemented&quot; looks weird to me. It is
better to use lower case letters throughput IMO.


&gt;<i> + * Syntax ABNF:
</I>&gt;<i> + *  payload     = *( table / kv-list / notice / LF )
</I>&gt;<i> + *  table       = [ label ':' [ table-row ] ] 1*( table-row )
</I>&gt;<i> + *  table-row   = 1*( [ string ] '\t' ) string LF
</I>&gt;<i> + *  kv-list     = label ( '=' / ':' ' ' ) string LF
</I>&gt;<i> + *  label       = 1*( VCHAR / SP ) ; any printable excluding ':' and '='
</I>&gt;<i> + *  notice      = string LF
</I>&gt;<i> + *  string      = 1*OCTET    ; any characters excluding LF (\n) and TAB (\t)
</I>
This syntax is very ambiguous AFAICT. If it actually matches reality
(and cachemgr.cgi just guesses what the next construct is most likely to
be), then you may want to add a comment about that fact. Same if this
syntax only approximates what Squid actually dumps.

Also, the proposed notice() method says nothing about excluding LF (\n)
and TAB (\t) from comment values. The method should document what we
want to exclude from all notices (if anything).


&gt;<i> +    virtual void displayWith(Mgr::PayloadFormatter &amp;p) ...
</I>
This is not really about &quot;display&quot; as the response may still go through
several post-processing layers before it is seen by anybody. Consider
using writeTo() or dumpTo() instead.


&gt;<i> -    virtual void dump(StoreEntry *entry);
</I>&gt;<i> +    virtual void displayWith(Mgr::PayloadFormatter &amp;) override final;
</I>
Why is this method and many others marked as &quot;final&quot;? Is there something
wrong with adding a kid class that would dump a longer menu, for example?

AFAICT, the primary intent of using the &quot;final&quot; specification is to
restrict future overriding, not just to document that &quot;nothing is
overriding this method right now&quot;. That is, there is a difference
between &quot;cannot be overridden without breaking something&quot; (the &quot;final&quot;
intended purpose) vs &quot;is not currently overridden&quot; (the &quot;final&quot; abuse).

(&quot;final&quot; may also be used as a potential performance optimization, but
we do not care about such minor optimizations in this context.)

This is somewhat similar to &quot;throw()&quot; declarations that C++ folks were
initially excited about until they realized that it is actually a severe
restriction (often with bad consequences) rather than just a convenient
documentation trick.


HTH,

Alex.

</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002995.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
	<LI>Next message: <A HREF="003019.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3004">[ date ]</a>
              <a href="thread.html#3004">[ thread ]</a>
              <a href="subject.html#3004">[ subject ]</a>
              <a href="author.html#3004">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
