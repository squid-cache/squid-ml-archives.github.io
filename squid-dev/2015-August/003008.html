<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [CODE] iterating over enums
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BCODE%5D%20iterating%20over%20enums&In-Reply-To=%3CCA%2BY8hcPNjMckWp5shWdUCFoAZ2vJXyCf%3DSn9dSjwHV7JS4SMAQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003002.html">
   <LINK REL="Next"  HREF="003011.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [CODE] iterating over enums</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BCODE%5D%20iterating%20over%20enums&In-Reply-To=%3CCA%2BY8hcPNjMckWp5shWdUCFoAZ2vJXyCf%3DSn9dSjwHV7JS4SMAQ%40mail.gmail.com%3E"
       TITLE="[squid-dev] [CODE] iterating over enums">gkinkie at gmail.com
       </A><BR>
    <I>Thu Aug 13 09:20:50 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003002.html">[squid-dev] [CODE] iterating over enums
</A></li>
        <LI>Next message: <A HREF="003011.html">[squid-dev] [CODE] iterating over enums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3008">[ date ]</a>
              <a href="thread.html#3008">[ thread ]</a>
              <a href="subject.html#3008">[ subject ]</a>
              <a href="author.html#3008">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Aug 12, 2015 at 9:11 PM, Alex Rousskov &lt;
<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:

&gt;<i> On 08/12/2015 09:36 AM, Kinkie wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; So I went ahead and just implemented it, starting from your observations.
</I>&gt;<i> &gt; It's a bit more complex that your proposal, as I took the chance to
</I>&gt;<i> &gt; implement bidirectional forward and reverse iterators.
</I>&gt;<i> &gt; The attached patch is in changeset 14235 of
</I>&gt;<i> &gt; lp:~kinkie/squid/coverity-fixes, but since the code is quite well
</I>&gt;<i> &gt; self-contained I'd like to submit it for audit as a standalone unit; If
</I>&gt;<i>
</I>&gt;<i> Yes, submitting Enum iterators for review as a stand-alone patch is the
</I>&gt;<i> right thing to do. Hiding this and other significant changes under
</I>&gt;<i> &quot;coverity fixes&quot; cover is wrong IMO, even if those changes were prompted
</I>&gt;<i> by something Coverity has detected.
</I>&gt;<i>
</I>&gt;<i> I would encourage you to show actual Squid usage examples (besides
</I>&gt;<i> artificial test cases), either in the patch itself or in the patch cover
</I>&gt;<i> email.
</I>&gt;<i>
</I>
./src/HttpHdrCc.cc:HttpHdrCcType &amp;operator++ (HttpHdrCcType &amp;aHeader)
./src/HttpHdrSc.cc:http_hdr_sc_type &amp;operator++ (http_hdr_sc_type &amp;aHeader)
./src/HttpHdrScTarget.cc:http_hdr_sc_type &amp;operator++ (http_hdr_sc_type
&amp;aHeader);
./src/HttpMsg.cc:HttpMsgParseState &amp;operator++ (HttpMsgParseState &amp;aState)
./src/errorpage.cc:err_type &amp;operator++ (err_type &amp;anErr)
./src/http/RequestMethod.cc:operator++ (Http::MethodType &amp;aMethod)
./src/mem/old_api.cc:mem_type &amp;operator++ (mem_type &amp;aMem)

These are all used to iterate over enums from what I can tell. There are
for sure more cases using different techniques, that are less trivial to
detect.


&gt;<i> Also, please adjust the WholeEnum documentation. It is currently too
</I>&gt;<i> similar to EnumRange, including the identical first/summary line. It is
</I>&gt;<i> often best to document children classes in terms of parent classes
</I>&gt;<i> rather then repeating everything the parent documentation [currently]
</I>&gt;<i> says IMO. For example:
</I>&gt;<i>
</I>&gt;<i> /// EnumRange for iterating all enum values, from enumBegin_ up to, but
</I>&gt;<i> // not including, enumEnd_. The two markers must be present in the enum.
</I>&gt;<i> template &lt;typename Enum&gt;
</I>&gt;<i> class WholeEnum ...
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If you have not considered implementing WholeEnum without inheritance,
</I>&gt;<i> please do so. I speculate that lack of any data members may help inline
</I>&gt;<i> WholeEnum. Please note that I am just asking you to _consider_ this. I
</I>&gt;<i> do not have enough information to insist on it.
</I>&gt;<i>
</I>
As all classes are nonvirtual and everything is in the same translation
unit, for now I would skip that. and avoid the code duplication.


&gt;<i> &gt; +    typedef typename std::underlying_type&lt;Enum&gt;::type value_t;
</I>&gt;<i> &gt; +    value_t current_value;
</I>&gt;<i>
</I>&gt;<i> This type and data member is more about iteration position than &quot;value&quot;
</I>&gt;<i> (in STL sense). AFAICT, STL calls this type &quot;iterator_type&quot; and the data
</I>&gt;<i> member &quot;current&quot;. I think that naming is better than yours.
</I>&gt;<i>
</I>
Ok


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; +    reverse_iterator rbegin() const { auto i = reverse_iterator(end_);
</I>&gt;<i> ++i; return i; }
</I>&gt;<i> &gt; +    reverse_iterator rend() const { auto i = reverse_iterator(begin_);
</I>&gt;<i> ++i; return i; }
</I>&gt;<i>
</I>&gt;<i> If these methods can be implemented simply as
</I>&gt;<i>
</I>&gt;<i>   reverse_iterator rbegin() const { return ++reverse_iterator(end_); }
</I>&gt;<i>   reverse_iterator rend() const { return ++reverse_iterator(begin_); }
</I>&gt;<i>
</I>&gt;<i> then please simplify.
</I>&gt;<i>
</I>
Ok.


&gt;<i> I do not understand how rend() would actually work when iterating whole
</I>&gt;<i> enums! For a typical enum that starts with a zero-valued item, will the
</I>&gt;<i> rend() position (called current_value in your code) go negative?? Is
</I>&gt;<i> that actually guaranteed to work by the standard? If not, we may need to
</I>&gt;<i> require a begin-1 marker (which may be negative if needed)!
</I>&gt;<i>
</I>
It'll go negative, or in case of unsigned underlyng_type, wrap. It'll still
work (added a test for that), to be sure.


&gt;<i> Are you sure you need reverse iterators at all?
</I>&gt;<i>
</I>
No, not sure; I added them mostly for completeness sake.


&gt;<i> [ EnumRange is not suitable for iterating up to the end of an enum that
</I>&gt;<i> does not have an end+1 marker. This limitation is not a bug, but may be
</I>&gt;<i> another reason to require all enums to have markers. ]
</I>&gt;<i>
</I>
I've added documentation to highlight that corner case so it doesn't come
unexpected.
I've considered changing it so that it includes the last value in the
range, but in the end decided against it as it's inconsistent with common
behavior.
In some cases it may not be feasible to have markers. Maybe the enum comes
from a library, or maybe markers may hurt some code path for all we know.
As long as the behavior is well documented and consistent, I don't think
it'll be a problem.


&gt;<i> If possible, please add and use a global function to guess EnumRange
</I>&gt;<i> template parameter value from the actual function parameter types and
</I>&gt;<i> return the right EnumRange object, to avoid writing Enum type three
</I>&gt;<i> times when using EnumRangeT&lt;&gt;.
</I>&gt;<i>
</I>&gt;<i>   template &lt;typename Enum&gt;
</I>&gt;<i>   EnumRangeT&lt;Enum&gt; EnumRange(Enum begin, Enum end) {
</I>&gt;<i>       return EnumRangeT&lt;Enum&gt;(begin, end);
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>
</I>Done.
I'm attaching the resulting files. If that's OK by you, I'll start using
them and merge together with the next round of coverity-fixes.



&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; On 08/05/2015 07:58 PM, Kinkie wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; What I understand from the changes you propose is that:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; 1. instead of having explicit begin/end markers passed as template
</I>&gt;<i> &gt;&gt; arguments you propose to have a convention on begin/end markers.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; There are several different things/layers mixed up here:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * If we want to use range loops for enums [in a sane way], then our
</I>&gt;<i> &gt; enums should have begin/end markers. Many already do, but we will have
</I>&gt;<i> &gt; to standardize their names and fill the gaps.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * The begin/end parameters should not be template parameters.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * If we need to iterate sub-ranges, then we should add EnumRangeT&lt;Enum&gt;
</I>&gt;<i> &gt; class with begin/end as constructor parameters (see below).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; 2. you skip the typedef fixing these parameters in favor of letting the
</I>&gt;<i> &gt;&gt; template parameters appear in the calls.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; There are two separate issues/layers here:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * Naming an expression is a good idea, especially if that name is going
</I>&gt;<i> &gt; to be used multiple times.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * Fewer template parameters are generally better if they can accomplish
</I>&gt;<i> &gt; the same thing as more template parameters.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; 1. looks interesting, especially as an enum missing those markers will
</I>&gt;<i> &gt;&gt; fail to compile. Maybe both approaches can be combined by using default
</I>&gt;<i> &gt;&gt; template arguments, what do you think?
</I>&gt;<i> &gt;&gt; template &lt;typename C, C first = C::enumBegin_, C last_plus_one =
</I>&gt;<i> &gt;&gt; C::enumEnd_&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I think we should not specify iteration range boundaries as template
</I>&gt;<i> &gt; parameters.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; 3. we could maybe combine the benefits of beautiful range-for and ugly
</I>&gt;<i> &gt;&gt; explicit-for also for shorter ranges by having (in the class-based
</I>&gt;<i> &gt;&gt; variant), on top of what you have already proposed (untested)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yes, if sub-range iteration using range loops is needed, then we should
</I>&gt;<i> &gt; add EnumRangeT&lt;Enum&gt; class that does it. Sorry if I have not mentioned
</I>&gt;<i> &gt; that explicitly.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Your sketch for that class is fine, but it will be a EnumRangeT class,
</I>&gt;<i> &gt; separate from simpler WholeEnum, and we would try to define a function
</I>&gt;<i> &gt; that will create that EnumRangeT object so that we only have to type
</I>&gt;<i> &gt; &quot;Numbers&quot; zero or two times as illustrated below:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; template &lt;typename Enum&gt;
</I>&gt;<i> &gt; inline
</I>&gt;<i> &gt; EnumRangeT&lt;Enum&gt; EnumRange(const Enum from, const Enum to) {
</I>&gt;<i> &gt;     return EnumRangeT&lt;Enum&gt;(from, to);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So that instead of:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; for (auto i : WholeEnum&lt;Numbers&gt;(Numbers::one, Numbers::three)) {
</I>&gt;<i> &gt;&gt;  // do stuff
</I>&gt;<i> &gt;&gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; we could do:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   // iterating sub-range of a class enum:
</I>&gt;<i> &gt;   for (auto i: EnumRange(Numbers::one, Numbers::three)) ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   // iterating sub-range of a global C enum:
</I>&gt;<i> &gt;   for (auto i: EnumRange(one, three)) ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   // iterating a whole enum:
</I>&gt;<i> &gt;   for (auto i: WholeEnum&lt;Numbers&gt;()) ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Again, the above range objects can be named (and the first two should be
</I>&gt;<i> &gt; named if they are used more than once). For example:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   WholeEnum&lt;Numbers&gt; AllNumbers() { return WholeEnum&lt;Numbers&gt;(); }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   EnumRange&lt;Numbers&gt; FooBarNumbers() { return EnumRange(Numbers::foo,
</I>&gt;<i> &gt; Numbers::bar); }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; It looks to me that I have crossed an itch you feel as well,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; No, I am just trying to help you scratch your itch without scarring
</I>&gt;<i> &gt; Squid code. I do not know whether your itch is real or imaginary.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Cheers,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Alex.
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>

-- 
    Francesco
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0001.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0001.html</A>&gt;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: EnumIterator.h
Type: text/x-chdr
Size: 4587 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0002.h">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0002.h</A>&gt;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: testEnumIterator.cc
Type: application/octet-stream
Size: 2421 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0001.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0001.obj</A>&gt;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: testEnumIterator.h
Type: text/x-chdr
Size: 1011 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0003.h">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150813/f8ca8437/attachment-0003.h</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003002.html">[squid-dev] [CODE] iterating over enums
</A></li>
	<LI>Next message: <A HREF="003011.html">[squid-dev] [CODE] iterating over enums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3008">[ date ]</a>
              <a href="thread.html#3008">[ thread ]</a>
              <a href="subject.html#3008">[ subject ]</a>
              <a href="author.html#3008">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
