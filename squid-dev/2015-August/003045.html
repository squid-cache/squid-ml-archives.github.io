<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PayloadFormatter (was PackableStream)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D40B13.2080101%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003019.html">
   <LINK REL="Next"  HREF="003056.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PayloadFormatter (was PackableStream)</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D40B13.2080101%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] PayloadFormatter (was PackableStream)">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Aug 19 04:50:27 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003019.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
        <LI>Next message: <A HREF="003056.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3045">[ date ]</a>
              <a href="thread.html#3045">[ thread ]</a>
              <a href="subject.html#3045">[ subject ]</a>
              <a href="author.html#3045">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/15/2015 12:20 AM, Amos Jeffries wrote:
&gt;<i> I dont like payload particularly either in this case. But page is wrong.
</I>&gt;<i> 
</I>&gt;<i> Page is what the remote end display tool will be generating. *IF* a
</I>&gt;<i> &quot;page&quot; exists at all.
</I>
There are many kinds of payloads. There are many kinds of pages. There
are many kinds of reports. No name is perfect. I am not going to spend
more time trying to explain why your wrong name is wronger than my wrong
name. If you think your naming scheme is better, who am I to argue?
[rhetorical]


&gt;&gt;&gt;<i> +/**
</I>&gt;&gt;&gt;<i> + * Produces cache manager report payloads in a human-readable markup syntax
</I>&gt;&gt;&gt;<i> + * which is parsed by the cachemgr.cgi tool.
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +class PayloadOldCgi: public PayloadFormatter
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think it is wrong to strongly associate the old format with
</I>&gt;&gt;<i> cachemgr.cgi.
</I>
&gt;<i> That was intentional. This format is nasty even for a free-form format.
</I>&gt;<i> You noticed the syntax is ambiguous and commented on it.
</I>&gt;<i> 
</I>&gt;<i> IMO deprecating this while leaving it available is a good choice. If it
</I>&gt;<i> were not for backward compatibiliy and transitional needs I would
</I>&gt;<i> propose removing it entirely (did in fact).
</I>&gt;<i>  Instead I'm starting with this one, and moving on to YAML etc. to
</I>&gt;<i> provide the non-ambiguous outputs.
</I>
Your response does not seem to be related to my objection, but again, I
am not going to spend more time arguing about your naming scheme.


&gt;<i> For now this class is specifically and intentionally dumping out the
</I>&gt;<i> (old) format for cachemgr.cgi. Other third-party tools are considered
</I>&gt;<i> only so far as the cachemgr ambiguous syntax was published in various
</I>&gt;<i> parts in various places. As long as the output still matches that they
</I>&gt;<i> should be fine (or better off).
</I>
IMO, made-up after-the-fact syntax rules are irrelevant (because
&quot;nobody&quot; knows about them, and they are imprecise). Cachemgr.cgi itself
is irrelevant (because we control it). Admin scripts parsing old output
are relevant. Thus, we should either keep the old output pretty much &quot;as
is&quot; or replace it with something sufficiently better to justify the
change pains for the admins. Adjusting output (while claiming
compatibility with some syntax rules we made up) is a bad approach
because it makes admins unhappy while not making us happy.


&gt;&gt;&gt;<i> +class PayloadFormatter
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +    Packable &outBuf;
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Since the majority of PayloadFormatter methods and callers are going to
</I>&gt;&gt;<i> assemble and format pieces of text and numbers, I think this should
</I>&gt;&gt;<i> become an ostream.
</I>
&gt;<i> You want to go back to PackableStream now?
</I>
If possible, the new page/report/payload building interface should be
ostream-enabled, not PackableStream-enabled. IIRC, that's what I
sketched a few emails back.

We do not have to support Packable to provide ostream interface, but if
Packable backing helps, we should certainly use it.

Said that, ostream is the wrong primary interface for assembling
payload/pages/reports. IMO, you should reintroduce ostream capabilities,
but we should not be [going back to] assembling primary
payload/pages/reports using ostream. More on that below.


&gt;<i> Because StoreEntryStream would place a Store.h dependency almost as
</I>&gt;<i> widely as squid.h dependency.
</I>
The _implementation_ of the ostream-based interface may use something
like PackableStream or even StoreEntryStream without introducing any
excessive dependencies AFAICT. In the sketch I posted, only one line of
code new about std::cout backing while the rest was using ostream.



&gt;&gt;<i> Almost all the code that uses outBuf and PayloadFormatter methods in the
</I>&gt;&gt;<i> patch already looks labored/awkward (often worse than the trivial code
</I>&gt;&gt;<i> it replaces!), and would look much better if replaced by the usual
</I>&gt;&gt;<i> ostream &quot;&lt;&lt;&quot; expressions.
</I>
&gt;<i> Now you see the benefit of ostream.
</I>
My attitude towards ostream has not changed. Forming payloads/pages
/reports using ostream as the top-level interface was wrong and still is.

Making ostream available for opaque and low-level parts of payload is a
good approach. My earlier sketch was probably too small to illustrate
this point, but it does provide high-level report structuring methods
while keeping ostream available for low-level stuff. More needs to be
done to polish that split based on actual typical use cases.


&gt;&gt;&gt;<i> +    // a comment
</I>&gt;&gt;&gt;<i> +    virtual void notice(const SBuf &amp;) = 0;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Let's try to define the purpose of this method more precisely so that we
</I>&gt;&gt;<i> know when it is being used [in]correctly. For example:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   /// a free-form comment or informational text that
</I>&gt;&gt;<i>   /// is not meant to be further parsed by automation tools
</I>

&gt;<i> No.
</I>&gt;<i> 
</I>&gt;<i> notice = &quot;A free-form informational text block that is meant for display
</I>&gt;<i> without further processing.&quot;
</I>&gt;<i> 
</I>&gt;<i> comment = &quot;A free-form informational text that is not meant for
</I>&gt;<i> automated tool processing or display. May be discarded by automation.&quot;
</I>
You have documented notice() as &quot;a comment&quot;. Now you give two different
definitions for those two words. Please make up your mind and adjust the
notice() description accordingly. After that, it should be clear whether
we agree what notice() is.

Please also adjust the description to emphasize whether a notice() is an
indication of a possible problem/error or can be safely ignored [by
automation tools] without any harm. The distinction would be important
for automation. If there are two kinds of notices (e.g., Warnings and
FYI messages), then we may need to add a notice(kind) parameter or split
notice() into two methods.

For example, &quot;foo is not yet implemented&quot; is probably something that
tools may safely ignore, but &quot;you do not have permission to access foo&quot;
is an error that a tool should treat as such. Should both use the same
notice() method and, hence, be indistinguishable to the automation tool?
Probably not.


&gt;&gt;<i>   virtual void notice(const SBuf &amp;) = 0;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Return PayloadFormatter reference so that the calls can be chained
</I>&gt;&gt;<i> together (see earlier discussion for examples).
</I>

&gt;<i> IME chaining usually turns out to be a mistake when it comes to regular
</I>&gt;<i> methods like these and needs undoing later when things move beyond
</I>&gt;<i> simplistic cases. I would rather avoid as long as possible.
</I>
If you agree that &quot;simplistic cases&quot; benefit from chaining, then I do
not understand why deny them a useful tool? Many cache manager
payloads/pages/reports are pretty simple... Availability of a chaining
API does not force the caller to use it.

The menu example I posted earlier uses chaining and seems to benefit
from chaining. I suspect some other use cases will benefit as well.

However, this issue is not a deal breaker. If you are certain chaining
is harmful, do not add it.


&gt;&gt;<i> Capitalization in &quot;foo is Not Implemented&quot; looks weird to me. It is
</I>&gt;&gt;<i> better to use lower case letters throughput IMO.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Sorry, old habbit. 501. Fixed.
</I>
Now you may want to fix the method description as well. Naming the
formal parameter and using the name in the fixed description text would
help clarify the description IMO. For example:

    /// a 'something is not implemented' notice()
    void notImplemented(const SBuf &amp;something);



&gt;&gt;&gt;<i> + * Syntax ABNF:
</I>&gt;&gt;&gt;<i> + *  payload     = *( table / kv-list / notice / LF )
</I>&gt;&gt;&gt;<i> + *  table       = [ label ':' [ table-row ] ] 1*( table-row )
</I>&gt;&gt;&gt;<i> + *  table-row   = 1*( [ string ] '\t' ) string LF
</I>&gt;&gt;&gt;<i> + *  kv-list     = label ( '=' / ':' ' ' ) string LF
</I>&gt;&gt;&gt;<i> + *  label       = 1*( VCHAR / SP ) ; any printable excluding ':' and '='
</I>&gt;&gt;&gt;<i> + *  notice      = string LF
</I>&gt;&gt;&gt;<i> + *  string      = 1*OCTET    ; any characters excluding LF (\n) and TAB (\t)
</I>

&gt;&gt;<i> This syntax is very ambiguous AFAICT.
</I>

&gt;<i> Indeed. You see one reason why I have been so impatient about it.
</I>

&gt;&gt;<i> If it actually matches reality
</I>&gt;&gt;<i> (and cachemgr.cgi just guesses what the next construct is most likely to
</I>&gt;&gt;<i> be), then you may want to add a comment about that fact. Same if this
</I>&gt;&gt;<i> syntax only approximates what Squid actually dumps.
</I>

&gt;<i> Yes and no. This combines both what cachemgr.cgi parses (table, notice),
</I>&gt;<i> and what Squid is elsewhere documented as outputting (kv-list). With
</I>&gt;<i> extra detail gleaned from what Squid actually outputs byte-wise in
</I>&gt;<i> reports that use those table/list constructs (kv-list delimiters, tables
</I>&gt;<i> without header row, and empty-lines).
</I>&gt;<i> 
</I>&gt;<i> There are a few reports using syntax like SP-padded columns with no tabs
</I>&gt;<i> which cachemgr.cgi borks display of badly. I count them as wrong reports
</I>&gt;<i> (using notice lines instead of table or kv-list) to be fixed.
</I>&gt;<i> 
</I>&gt;<i> And I've not managed to add block indentation in there yet in a way that
</I>&gt;<i> leaves the syntax readable. So reality is worse than it looks.
</I>
Your description matches my expectations so my suggestion still stands:
Document that the ABNF is ambiguous, only approximates the reality, will
not be adhered to (or even guide) future formats, and is provided as an
illustration only.


&gt;&gt;<i> Also, the proposed notice() method says nothing about excluding LF (\n)
</I>&gt;&gt;<i> and TAB (\t) from comment values. The method should document what we
</I>&gt;&gt;<i> want to exclude from all notices (if anything).
</I>
&gt;<i> I don't want to exclude anything. YAML and other syntaxes wont need to
</I>&gt;<i> in the end result.
</I>

Your desires and plans only strengthens my suggestion to disclaim the
actual impact of this formal- and precise-looking ABNF.



&gt;&gt;&gt;<i> -    virtual void dump(StoreEntry *entry);
</I>&gt;&gt;&gt;<i> +    virtual void displayWith(Mgr::PayloadFormatter &amp;) override final;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why is this method and many others marked as &quot;final&quot;? Is there something
</I>&gt;&gt;<i> wrong with adding a kid class that would dump a longer menu, for example?
</I>&gt;<i> 
</I>&gt;<i> Yes. 
</I>

For the record, I think your reasons do not justify &quot;final&quot; use. They
are &quot;political&quot; reasons, not &quot;code&quot; reasons. However, I am not going to
insist on a complete &quot;final&quot; removal right now.


&gt;<i> I absolutely do not want anything deriving from OldCgi and keeping
</I>&gt;<i> it around longer than it has to be for transition to the better ones.
</I>
If you motivation is to prevent derivatives, then you are misplacing
&quot;final&quot;. It should go into the class declaration line instead (as
illustrated below). However, since nobody will know why you are abusing
&quot;final&quot; like this, please also add a comment:


  /// ...
  /// Nothing should derive from this class because we are afraid
  /// that any derivative will keep this class around longer.
  class PayloadOldCgi final: public PayloadFormatter


&gt;<i> As to menu. The length of menu, and any report segments appended is
</I>&gt;<i> Action/ActionChild scope. Whose duty it is to fetch the menu data and
</I>&gt;<i> call formatter once per segment type, or simply provide more table rows
</I>&gt;<i> before ending the menu table.
</I>
I do not know why the above is relevant, but please remove &quot;final&quot; from
non-OldCgi methods. Overriding them may not be needed right now, but
there is no reason, even a political one, to prohibit such overriding.


Going forward, please do not use &quot;final&quot; unless really necessary. Treat
it like we treat &quot;throw()&quot; declarations.


In summary, the most important top-level problems [I remember] are:

* unavailability of an ostream interface for low-level formatting
* poorly defined notice() scope


Thank you,

Alex.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003019.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
	<LI>Next message: <A HREF="003056.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3045">[ date ]</a>
              <a href="thread.html#3045">[ thread ]</a>
              <a href="subject.html#3045">[ subject ]</a>
              <a href="author.html#3045">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
