<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PayloadFormatter (was PackableStream)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D4A514.6010409%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003045.html">
   <LINK REL="Next"  HREF="003061.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PayloadFormatter (was PackableStream)</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D4A514.6010409%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] PayloadFormatter (was PackableStream)">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Aug 19 15:47:32 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003045.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
        <LI>Next message: <A HREF="003061.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3056">[ date ]</a>
              <a href="thread.html#3056">[ thread ]</a>
              <a href="subject.html#3056">[ subject ]</a>
              <a href="author.html#3056">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 19/08/2015 4:50 p.m., Alex Rousskov wrote:
&gt;<i> On 08/15/2015 12:20 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> I dont like payload particularly either in this case. But page is wrong.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Page is what the remote end display tool will be generating. *IF* a
</I>&gt;&gt;<i> &quot;page&quot; exists at all.
</I>&gt;<i> 
</I>&gt;<i> There are many kinds of payloads. There are many kinds of pages. There
</I>&gt;<i> are many kinds of reports. No name is perfect. I am not going to spend
</I>&gt;<i> more time trying to explain why your wrong name is wronger than my wrong
</I>&gt;<i> name. If you think your naming scheme is better, who am I to argue?
</I>&gt;<i> [rhetorical]
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +/**
</I>&gt;&gt;&gt;&gt;<i> + * Produces cache manager report payloads in a human-readable markup syntax
</I>&gt;&gt;&gt;&gt;<i> + * which is parsed by the cachemgr.cgi tool.
</I>&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;<i> +class PayloadOldCgi: public PayloadFormatter
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think it is wrong to strongly associate the old format with
</I>&gt;&gt;&gt;<i> cachemgr.cgi.
</I>&gt;<i> 
</I>&gt;&gt;<i> That was intentional. This format is nasty even for a free-form format.
</I>&gt;&gt;<i> You noticed the syntax is ambiguous and commented on it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> IMO deprecating this while leaving it available is a good choice. If it
</I>&gt;&gt;<i> were not for backward compatibiliy and transitional needs I would
</I>&gt;&gt;<i> propose removing it entirely (did in fact).
</I>&gt;&gt;<i>  Instead I'm starting with this one, and moving on to YAML etc. to
</I>&gt;&gt;<i> provide the non-ambiguous outputs.
</I>&gt;<i> 
</I>&gt;<i> Your response does not seem to be related to my objection, but again, I
</I>&gt;<i> am not going to spend more time arguing about your naming scheme.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> For now this class is specifically and intentionally dumping out the
</I>&gt;&gt;<i> (old) format for cachemgr.cgi. Other third-party tools are considered
</I>&gt;&gt;<i> only so far as the cachemgr ambiguous syntax was published in various
</I>&gt;&gt;<i> parts in various places. As long as the output still matches that they
</I>&gt;&gt;<i> should be fine (or better off).
</I>&gt;<i> 
</I>&gt;<i> IMO, made-up after-the-fact syntax rules are irrelevant (because
</I>&gt;<i> &quot;nobody&quot; knows about them, and they are imprecise). Cachemgr.cgi itself
</I>&gt;<i> is irrelevant (because we control it). Admin scripts parsing old output
</I>&gt;<i> are relevant. Thus, we should either keep the old output pretty much &quot;as
</I>&gt;<i> is&quot; or replace it with something sufficiently better to justify the
</I>&gt;<i> change pains for the admins. Adjusting output (while claiming
</I>&gt;<i> compatibility with some syntax rules we made up) is a bad approach
</I>&gt;<i> because it makes admins unhappy while not making us happy.
</I>&gt;<i> 
</I>
&quot;The Definitive Guide&quot; 14.2. All the way through its talking about
cachemgr.cgi display &quot;columns&quot;.

To find the detail of what a input &quot;column&quot; actually is refer to
cachemgr.cgi code itself. Specificaly the munge_other_line() function
for converting report text/plain to text/html. This code has not changed
in any significant way since the 1990's.

* Any line excluding a \t is a free-form text line. Lets call that ...
comment, kv-pair, LF.

* table is a series of \t delimited cells. Lets call that ... 'table-row'.

* If the first cell of the first line of a table includes a ':' its a
header row. Lets call that ... 'table' for the whole set of rows, and we
will need a optional 'label' for the pre-colon bit in the first table-row.



The Guide is also talking about how several reports including
'redirectors' are *identical* in format to 'idns' ... not today, they
use tab-delimiting. idns got screwed up years later and now uses space
delimiting and looks like crap in CGI display as a result.


The kv-pairs is not part of the Guide + CGI documentation. Those parts I
took from your own emails and IRC chats educating me an kinkie about
what the report format was supposed to be.

It turns out that no, those were just PRE (free-form) lines &quot;more easily
machine interpretable than human readable&quot; as the Guide says. But it
does make sense to have them, and many reports look like they were
created with that in mind so I added the kv-pair descriptor to the
grammar too. You object to that?

The lack of a written copy of the grammar to date does not preclude its
existence prior to now. Human language is a good example there, it
&quot;obviously&quot; has a grammar even though an entire field of research was
created to find out what it is, a long time after use began.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +class PayloadFormatter
</I>&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;<i> +    Packable &outBuf;
</I>&gt;&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Since the majority of PayloadFormatter methods and callers are going to
</I>&gt;&gt;&gt;<i> assemble and format pieces of text and numbers, I think this should
</I>&gt;&gt;&gt;<i> become an ostream.
</I>&gt;<i> 
</I>&gt;&gt;<i> You want to go back to PackableStream now?
</I>&gt;<i> 
</I>&gt;<i> If possible, the new page/report/payload building interface should be
</I>&gt;<i> ostream-enabled, not PackableStream-enabled. IIRC, that's what I
</I>&gt;<i> sketched a few emails back.
</I>
So how does the data get from std::ostreambuf to the client if its not
going near a Packable (ie StoreEntry).

You ask to data-copy into the stream buffer, then data-copy a second
time to the StoreEntry buffer.

PackableStream is an ostream child providing StoreEntry as the buffer.
So PackableStream data-copies to the StoreEntry buffer.

Which would you expect provides better performance:
 one or two data-copies ?

&gt;<i> 
</I>&gt;<i> We do not have to support Packable to provide ostream interface, but if
</I>&gt;<i> Packable backing helps, we should certainly use it.
</I>
The alternative as I already mentioned is StoreEntryStream.
 Which pulls in Store.h dependency.
 Which pulls in HttpRequest dependency.
 ... and so on

Appending strings (as ostream does) to a StoreEntry uses the Packable
virtual API. Exclusively. So why would we pull in all that StoreEntry
dependency just to use StoreEntryStream?
(hint: the caller Action already did locking and buffering so those bits
are no-op).


&gt;<i> 
</I>&gt;<i> Said that, ostream is the wrong primary interface for assembling
</I>&gt;<i> payload/pages/reports. IMO, you should reintroduce ostream capabilities,
</I>&gt;<i> but we should not be [going back to] assembling primary
</I>&gt;<i> payload/pages/reports using ostream. More on that below.
</I>&gt;<i> 
</I>
The code proposal you submitted has Formatter inherting from ostream.

The only use of Formatter is by Action. Ergo you intend Action to be
using a ostream interface to assemble top-level report data.

So WTF?

Either ostream is a private internal to Formatter for low-level use
only, or it is available (and eventually used) at high-level Action.

Formatter with its clean API distinct from StoreEntry and Action does
not pull in the dependencoes I was worried about with libmem. So it
(alone) can be passed there potentially if ostream&amp; is not wanted later.


&gt;<i> 
</I>&gt;&gt;<i> Because StoreEntryStream would place a Store.h dependency almost as
</I>&gt;&gt;<i> widely as squid.h dependency.
</I>&gt;<i> 
</I>&gt;<i> The _implementation_ of the ostream-based interface may use something
</I>&gt;<i> like PackableStream or even StoreEntryStream without introducing any
</I>&gt;<i> excessive dependencies AFAICT. In the sketch I posted, only one line of
</I>&gt;<i> code new about std::cout backing while the rest was using ostream.
</I>
You argued strongly for *not* doing it exactly that way only the other week.

Your response has been to propose an object ... which is an ostream
child. And would thus be used like PackableStream in my first proposal.

So, run &quot;sed s/PackableStream/PageFormatter/g&quot; on my first patch and
re-submit for audit? I doubt.


&gt;<i> 
</I>&gt;&gt;&gt;<i> Almost all the code that uses outBuf and PayloadFormatter methods in the
</I>&gt;&gt;&gt;<i> patch already looks labored/awkward (often worse than the trivial code
</I>&gt;&gt;&gt;<i> it replaces!), and would look much better if replaced by the usual
</I>&gt;&gt;&gt;<i> ostream &quot;&lt;&lt;&quot; expressions.
</I>&gt;<i> 
</I>&gt;&gt;<i> Now you see the benefit of ostream.
</I>&gt;<i> 
</I>&gt;<i> My attitude towards ostream has not changed. Forming payloads/pages
</I>&gt;<i> /reports using ostream as the top-level interface was wrong and still is.
</I>
Your objection was something along the lines of &quot;do not use an ostream
in Action&quot;.

So you proposed the Formatter class, an ostream child to be used by Action.

WTF?


&gt;<i> 
</I>&gt;<i> Making ostream available for opaque and low-level parts of payload is a
</I>&gt;<i> good approach. My earlier sketch was probably too small to illustrate
</I>&gt;<i> this point, but it does provide high-level report structuring methods
</I>&gt;<i> while keeping ostream available for low-level stuff. More needs to be
</I>&gt;<i> done to polish that split based on actual typical use cases.
</I>
The low-level stuff that makes sense using ostream is all internal to
Formatter. We seemed to be agreeing on that much.

What I'm not getting is why you insist this ostream API be exposed and
used by Action now but that PackableStream was inappropriate when it
could simply have had new members added and been identical to your
proposed Formatter.


The problem in the memory libraries is the *StoreEntry*. In particular
its class declaration head and things it pulls in.

Action depends deeply on StoreEntry. So there is no Action dumper in
libmem. Just currently some pool methods taking (ostream&amp;) and free-form
dumping out &quot;tables&quot;.

StoreEntry was made a Packable child for the purpose of using the
Packable API, possibly via PackableStream. To store stuff into a
StoreEntry (or just  a Membuf/SBuf) in more complex Formatter-like ways
without having libmem be aware it was anything other than a Packable.

If we are going to use Formatter in the libmem dumper code. Then it has
to be detatched from StoreEntry completely. That also means detatching
it from Action which depends deeply on StoreEntry. And that it can only
use the Packable API, possibly via PackableStream (aka ostream&amp;).


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +    // a comment
</I>&gt;&gt;&gt;&gt;<i> +    virtual void notice(const SBuf &amp;) = 0;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Let's try to define the purpose of this method more precisely so that we
</I>&gt;&gt;&gt;<i> know when it is being used [in]correctly. For example:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   /// a free-form comment or informational text that
</I>&gt;&gt;&gt;<i>   /// is not meant to be further parsed by automation tools
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> No.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> notice = &quot;A free-form informational text block that is meant for display
</I>&gt;&gt;<i> without further processing.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> comment = &quot;A free-form informational text that is not meant for
</I>&gt;&gt;<i> automated tool processing or display. May be discarded by automation.&quot;
</I>&gt;<i> 
</I>&gt;<i> You have documented notice() as &quot;a comment&quot;. Now you give two different
</I>&gt;<i> definitions for those two words. Please make up your mind and adjust the
</I>&gt;<i> notice() description accordingly. After that, it should be clear whether
</I>&gt;<i> we agree what notice() is.
</I>
Of course. I put the change in and you object again. And we go round in
circles.

Pause, &quot;Let's try to define the purpose of this method more precisely&quot;.

*Do you agree to those definitions* before I go changing any more code
around them?

The below seems to say &quot;no, not good enough&quot;. So it was a reasonable
choice not to change the code on last patch. I've have removed the &quot;a
comment&quot; bit for now until the final text is agreed.


&gt;<i> 
</I>&gt;<i> Please also adjust the description to emphasize whether a notice() is an
</I>&gt;<i> indication of a possible problem/error or can be safely ignored [by
</I>&gt;<i> automation tools] without any harm. The distinction would be important
</I>&gt;<i> for automation. If there are two kinds of notices (e.g., Warnings and
</I>&gt;<i> FYI messages), then we may need to add a notice(kind) parameter or split
</I>&gt;<i> notice() into two methods.
</I>&gt;<i> 
</I>&gt;<i> For example, &quot;foo is not yet implemented&quot; is probably something that
</I>&gt;<i> tools may safely ignore, but &quot;you do not have permission to access foo&quot;
</I>&gt;<i> is an error that a tool should treat as such. Should both use the same
</I>&gt;<i> notice() method and, hence, be indistinguishable to the automation tool?
</I>&gt;<i> Probably not.
</I>
Okay. Good point. Though we don't have any warning or error outputs to
display in any of the reports to date AFAIK. Just the notices about
features and sub-segements being &quot;not implemented&quot;, or some reports
being large.

We will probably need error()/warning() when POST and such are coded.
But thats a problem for later.

For now notice() is just informational with a requirement that it
reaches the report reader. There is no other implications on teh
processing tool.

I'm not sure how to emphasise *informational* any better than using it
as the active noune in the descriptive. ALL-CAPS seems over the top.
 Any suggestions?


&gt;<i> 
</I>&gt;&gt;&gt;<i> Capitalization in &quot;foo is Not Implemented&quot; looks weird to me. It is
</I>&gt;&gt;&gt;<i> better to use lower case letters throughput IMO.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sorry, old habbit. 501. Fixed.
</I>&gt;<i> 
</I>&gt;<i> Now you may want to fix the method description as well. Naming the
</I>&gt;<i> formal parameter and using the name in the fixed description text would
</I>&gt;<i> help clarify the description IMO. For example:
</I>&gt;<i> 
</I>&gt;<i>     /// a 'something is not implemented' notice()
</I>&gt;<i>     void notImplemented(const SBuf &amp;something);
</I>&gt;<i>
</I>
Fixed. Thanks.


&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> + * Syntax ABNF:
</I>&gt;&gt;&gt;&gt;<i> + *  payload     = *( table / kv-list / notice / LF )
</I>&gt;&gt;&gt;&gt;<i> + *  table       = [ label ':' [ table-row ] ] 1*( table-row )
</I>&gt;&gt;&gt;&gt;<i> + *  table-row   = 1*( [ string ] '\t' ) string LF
</I>&gt;&gt;&gt;&gt;<i> + *  kv-list     = label ( '=' / ':' ' ' ) string LF
</I>&gt;&gt;&gt;&gt;<i> + *  label       = 1*( VCHAR / SP ) ; any printable excluding ':' and '='
</I>&gt;&gt;&gt;&gt;<i> + *  notice      = string LF
</I>&gt;&gt;&gt;&gt;<i> + *  string      = 1*OCTET    ; any characters excluding LF (\n) and TAB (\t)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> This syntax is very ambiguous AFAICT.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Indeed. You see one reason why I have been so impatient about it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> If it actually matches reality
</I>&gt;&gt;&gt;<i> (and cachemgr.cgi just guesses what the next construct is most likely to
</I>&gt;&gt;&gt;<i> be), then you may want to add a comment about that fact. Same if this
</I>&gt;&gt;&gt;<i> syntax only approximates what Squid actually dumps.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Yes and no. This combines both what cachemgr.cgi parses (table, notice),
</I>&gt;&gt;<i> and what Squid is elsewhere documented as outputting (kv-list). With
</I>&gt;&gt;<i> extra detail gleaned from what Squid actually outputs byte-wise in
</I>&gt;&gt;<i> reports that use those table/list constructs (kv-list delimiters, tables
</I>&gt;&gt;<i> without header row, and empty-lines).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are a few reports using syntax like SP-padded columns with no tabs
</I>&gt;&gt;<i> which cachemgr.cgi borks display of badly. I count them as wrong reports
</I>&gt;&gt;<i> (using notice lines instead of table or kv-list) to be fixed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> And I've not managed to add block indentation in there yet in a way that
</I>&gt;&gt;<i> leaves the syntax readable. So reality is worse than it looks.
</I>&gt;<i> 
</I>&gt;<i> Your description matches my expectations so my suggestion still stands:
</I>&gt;<i> Document that the ABNF is ambiguous, only approximates the reality, will
</I>&gt;<i> not be adhered to (or even guide) future formats, and is provided as an
</I>&gt;<i> illustration only.
</I>
Ah. Another misunderstanding. That I grok and agree with.

But I thought it was clear I intend the outputs using OldCgi formatter
*will* adhere to it. I have been over all of Squid reports so many times
I am doubtful that anything was missed. However if something does appear
the syntax will be tweaked to include that too ensuring it corectly
documents what the old report format documented in the FAQ and
Definitive Guide was in ABNF terms.

Added text to that effect with the disclaimer you requested.


&gt;<i> 
</I>&gt;&gt;&gt;<i> Also, the proposed notice() method says nothing about excluding LF (\n)
</I>&gt;&gt;&gt;<i> and TAB (\t) from comment values. The method should document what we
</I>&gt;&gt;&gt;<i> want to exclude from all notices (if anything).
</I>&gt;<i> 
</I>&gt;&gt;<i> I don't want to exclude anything. YAML and other syntaxes wont need to
</I>&gt;&gt;<i> in the end result.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Your desires and plans only strengthens my suggestion to disclaim the
</I>&gt;<i> actual impact of this formal- and precise-looking ABNF.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> -    virtual void dump(StoreEntry *entry);
</I>&gt;&gt;&gt;&gt;<i> +    virtual void displayWith(Mgr::PayloadFormatter &amp;) override final;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Why is this method and many others marked as &quot;final&quot;? Is there something
</I>&gt;&gt;&gt;<i> wrong with adding a kid class that would dump a longer menu, for example?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> For the record, I think your reasons do not justify &quot;final&quot; use. They
</I>&gt;<i> are &quot;political&quot; reasons, not &quot;code&quot; reasons. However, I am not going to
</I>&gt;<i> insist on a complete &quot;final&quot; removal right now.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> I absolutely do not want anything deriving from OldCgi and keeping
</I>&gt;&gt;<i> it around longer than it has to be for transition to the better ones.
</I>&gt;<i> 
</I>&gt;<i> If you motivation is to prevent derivatives, then you are misplacing
</I>&gt;<i> &quot;final&quot;. It should go into the class declaration line instead (as
</I>&gt;<i> illustrated below). However, since nobody will know why you are abusing
</I>&gt;<i> &quot;final&quot; like this, please also add a comment:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>   /// ...
</I>&gt;<i>   /// Nothing should derive from this class because we are afraid
</I>&gt;<i>   /// that any derivative will keep this class around longer.
</I>&gt;<i>   class PayloadOldCgi final: public PayloadFormatter
</I>&gt;<i> 
</I>
Hmm, yes that is simpler. Thanks. Added something similar.

&gt;<i> 
</I>&gt;&gt;<i> As to menu. The length of menu, and any report segments appended is
</I>&gt;&gt;<i> Action/ActionChild scope. Whose duty it is to fetch the menu data and
</I>&gt;&gt;<i> call formatter once per segment type, or simply provide more table rows
</I>&gt;&gt;<i> before ending the menu table.
</I>&gt;<i> 
</I>&gt;<i> I do not know why the above is relevant, but please remove &quot;final&quot; from
</I>&gt;<i> non-OldCgi methods. Overriding them may not be needed right now, but
</I>&gt;<i> there is no reason, even a political one, to prohibit such overriding.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Going forward, please do not use &quot;final&quot; unless really necessary. Treat
</I>&gt;<i> it like we treat &quot;throw()&quot; declarations.
</I>
You mean spotted liberally around the new code in the form of a wrapper
keyword like Must() ?

I dont think so.


&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> In summary, the most important top-level problems [I remember] are:
</I>&gt;<i> 
</I>&gt;<i> * unavailability of an ostream interface for low-level formatting
</I>&gt;<i> * poorly defined notice() scope
</I>&gt;<i> 
</I>
Which we are still hacking out circles in discussion.

New patch to follow tomorrow.

Amos

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003045.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
	<LI>Next message: <A HREF="003061.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3056">[ date ]</a>
              <a href="thread.html#3056">[ thread ]</a>
              <a href="subject.html#3056">[ subject ]</a>
              <a href="author.html#3056">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
