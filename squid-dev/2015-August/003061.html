<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PayloadFormatter (was PackableStream)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D4F29C.9040403%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003056.html">
   <LINK REL="Next"  HREF="003083.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PayloadFormatter (was PackableStream)</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D4F29C.9040403%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] PayloadFormatter (was PackableStream)">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Aug 19 21:18:20 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003056.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
        <LI>Next message: <A HREF="003083.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3061">[ date ]</a>
              <a href="thread.html#3061">[ thread ]</a>
              <a href="subject.html#3061">[ subject ]</a>
              <a href="author.html#3061">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/19/2015 09:47 AM, Amos Jeffries wrote:
&gt;<i> On 19/08/2015 4:50 p.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 08/15/2015 12:20 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> For now this class is specifically and intentionally dumping out the
</I>&gt;&gt;&gt;<i> (old) format for cachemgr.cgi. Other third-party tools are considered
</I>&gt;&gt;&gt;<i> only so far as the cachemgr ambiguous syntax was published in various
</I>&gt;&gt;&gt;<i> parts in various places. As long as the output still matches that they
</I>&gt;&gt;&gt;<i> should be fine (or better off).
</I>
&gt;&gt;<i> IMO, made-up after-the-fact syntax rules are irrelevant (because
</I>&gt;&gt;<i> &quot;nobody&quot; knows about them, and they are imprecise). Cachemgr.cgi itself
</I>&gt;&gt;<i> is irrelevant (because we control it). Admin scripts parsing old output
</I>&gt;&gt;<i> are relevant. Thus, we should either keep the old output pretty much &quot;as
</I>&gt;&gt;<i> is&quot; or replace it with something sufficiently better to justify the
</I>&gt;&gt;<i> change pains for the admins. Adjusting output (while claiming
</I>&gt;&gt;<i> compatibility with some syntax rules we made up) is a bad approach
</I>&gt;&gt;<i> because it makes admins unhappy while not making us happy.
</I>

&gt;<i> &quot;The Definitive Guide&quot; 14.2. All the way through its talking about
</I>&gt;<i> cachemgr.cgi display &quot;columns&quot;.
</I>&gt;<i> 
</I>&gt;<i> To find the detail of what a input &quot;column&quot; actually is refer to
</I>&gt;<i> cachemgr.cgi code itself. Specificaly the munge_other_line() function
</I>&gt;<i> for converting report text/plain to text/html. This code has not changed
</I>&gt;<i> in any significant way since the 1990's.
</I>&gt;<i> 
</I>&gt;<i> * Any line excluding a \t is a free-form text line. Lets call that ...
</I>&gt;<i> comment, kv-pair, LF.
</I>&gt;<i> 
</I>&gt;<i> * table is a series of \t delimited cells. Lets call that ... 'table-row'.
</I>&gt;<i> 
</I>&gt;<i> * If the first cell of the first line of a table includes a ':' its a
</I>&gt;<i> header row. Lets call that ... 'table' for the whole set of rows, and we
</I>&gt;<i> will need a optional 'label' for the pre-colon bit in the first table-row.
</I>
&gt;<i> The Guide is also talking about how several reports including
</I>&gt;<i> 'redirectors' are *identical* in format to 'idns' ... not today, they
</I>&gt;<i> use tab-delimiting. idns got screwed up years later and now uses space
</I>&gt;<i> delimiting and looks like crap in CGI display as a result.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The kv-pairs is not part of the Guide + CGI documentation. Those parts I
</I>&gt;<i> took from your own emails and IRC chats educating me an kinkie about
</I>&gt;<i> what the report format was supposed to be.
</I>

This part of the email thread was discussing whether the existence of
admin scripts (rather than various imprecise syntax rules or
cachemgr.cgi code) should be the primary factor in our decision making.
How is the above information relevant to that discussion?


&gt;<i> It turns out that no, those were just PRE (free-form) lines &quot;more easily
</I>&gt;<i> machine interpretable than human readable&quot; as the Guide says. But it
</I>&gt;<i> does make sense to have them, and many reports look like they were
</I>&gt;<i> created with that in mind so I added the kv-pair descriptor to the
</I>&gt;<i> grammar too. You object to that?
</I>
Do I object to adding kv-pair to the grammar? No. I did not even review
those low-level details! I trust you with roughly approximating the
actual output. And a rough approximation is sufficient [and the only
thing possible] here IMO.


&gt;<i> The lack of a written copy of the grammar to date does not preclude its
</I>&gt;<i> existence prior to now. 
</I>
In practical terms, it pretty much does preclude it actually: Whenever
dozens of poorly coordinated developers spend years producing informal
output, one can virtually guarantee that no useful formal grammar can
describe what they did.


&gt;<i> Human language is a good example there, it
</I>&gt;<i> &quot;obviously&quot; has a grammar even though an entire field of research was
</I>&gt;<i> created to find out what it is, a long time after use began.
</I>
Human language is a good example of where no useful formal grammar
exists. There are various useful approximations, of course, but I do not
think anybody is even trying to confine human language into a useful
formal grammar for the last 30 years or so.



&gt;&gt;&gt;&gt;&gt;<i> +class PayloadFormatter
</I>&gt;&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;&gt;<i> +    Packable &outBuf;
</I>&gt;&gt;&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Since the majority of PayloadFormatter methods and callers are going to
</I>&gt;&gt;&gt;&gt;<i> assemble and format pieces of text and numbers, I think this should
</I>&gt;&gt;&gt;&gt;<i> become an ostream.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> You want to go back to PackableStream now?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If possible, the new page/report/payload building interface should be
</I>&gt;&gt;<i> ostream-enabled, not PackableStream-enabled. IIRC, that's what I
</I>&gt;&gt;<i> sketched a few emails back.
</I>&gt;<i> 
</I>&gt;<i> So how does the data get from std::ostreambuf to the client if its not
</I>&gt;<i> going near a Packable (ie StoreEntry).
</I>
I do not think ostream should use std::ostreambuf if that is what you
meant. It should use our own buffer, backed by Packable (or StoreEntry).
However, cache manager code would not know that and, hence, there should
be no linking problems associated with that knowledge.


&gt;<i> You ask to data-copy into the stream buffer, then data-copy a second
</I>&gt;<i> time to the StoreEntry buffer.
</I>
No, I do not. The stream buffer should use StoreEntry as storage [when
the output goes to Store].


&gt;<i> PackableStream is an ostream child providing StoreEntry as the buffer.
</I>&gt;<i> So PackableStream data-copies to the StoreEntry buffer.
</I>
Yes.


&gt;<i> Which would you expect provides better performance:
</I>&gt;<i>  one or two data-copies ?
</I>
One copy.

(The design choices here are actually not driven by performance, but by
the requirement to avoid buffering of huge cache manager responses in
RAM. However, the same custom ostream buffer design happens to eliminate
the extra copy as a positive performance side effect).



&gt;&gt;<i> Said that, ostream is the wrong primary interface for assembling
</I>&gt;&gt;<i> payload/pages/reports. IMO, you should reintroduce ostream capabilities,
</I>&gt;&gt;<i> but we should not be [going back to] assembling primary
</I>&gt;&gt;<i> payload/pages/reports using ostream. More on that below.
</I>

&gt;<i> The code proposal you submitted has Formatter inherting from ostream.
</I>
Yes, Page is a child of ostream in my sketch.


&gt;<i> The only use of Formatter is by Action.
</I>
Yes, at least in the scope of this discussion.


&gt;<i> Ergo you intend Action to be
</I>&gt;<i> using a ostream interface to assemble top-level report data.
</I>
No. Page provides a set of methods for high-level assembly, including:

    /// starts recording a list of values
    virtual Page &amp;beginList() = 0;
    /// finishes recording a list of values
    virtual Page &amp;endList() = 0;

    /// starts recording a list of values
    virtual Page &amp;beginListItem() = 0;
    /// finishes recording a list of values
    virtual Page &amp;endListItem() = 0;

    /// starts recording a key:value pair with a given key
    virtual Page &amp;beginKv(const SBuf &amp;key) = 0;
    /// finishes recording a key:value pair
    virtual Page &amp;endKv() = 0;



&gt;<i> Either ostream is a private internal to Formatter for low-level use
</I>&gt;<i> only, or it is available (and eventually used) at high-level Action.
</I>
It is a public interface for assembling some opaque/atomic values for
formal output such as YAML.

Whether inheriting from ostream is the best approach to accomplish that,
I am not sure, but it is probably the simplest one. The alternative to
consider is to provide a method that returns an ostream reference. There
are some examples below.


&gt;<i> Formatter with its clean API distinct from StoreEntry and Action does
</I>&gt;<i> not pull in the dependencoes I was worried about with libmem.
</I>
Yes, of course.



&gt;&gt;&gt;<i> Because StoreEntryStream would place a Store.h dependency almost as
</I>&gt;&gt;&gt;<i> widely as squid.h dependency.
</I>
&gt;&gt;<i> The _implementation_ of the ostream-based interface may use something
</I>&gt;&gt;<i> like PackableStream or even StoreEntryStream without introducing any
</I>&gt;&gt;<i> excessive dependencies AFAICT. In the sketch I posted, only one line of
</I>&gt;&gt;<i> code new about std::cout backing while the rest was using ostream.
</I>
&gt;<i> You argued strongly for *not* doing it exactly that way only the other week.
</I>

I did not. I argued against using ostream to format strict syntax (e.g.,
YAML) output. Later, I provided a sketch how to avoid doing that while
still supporting ostream-based assembly of YAML atomic values. I now
included specific examples further below.


&gt;<i> Your response has been to propose an object ... which is an ostream
</I>&gt;<i> child. And would thus be used like PackableStream in my first proposal.
</I>
The difference between the Page class and PackableStream is that Page
provides methods for high-level formal formatting (such as YAML).
PackableStream does not and should not have such methods. You should
look at the whole Page class declaration, not just at its first line
(where ostream inheritance is declared).


&gt;&gt;&gt;&gt;<i> Almost all the code that uses outBuf and PayloadFormatter methods in the
</I>&gt;&gt;&gt;&gt;<i> patch already looks labored/awkward (often worse than the trivial code
</I>&gt;&gt;&gt;&gt;<i> it replaces!), and would look much better if replaced by the usual
</I>&gt;&gt;&gt;&gt;<i> ostream &quot;&lt;&lt;&quot; expressions.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Now you see the benefit of ostream.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My attitude towards ostream has not changed. Forming payloads/pages
</I>&gt;&gt;<i> /reports using ostream as the top-level interface was wrong and still is.
</I>&gt;<i> 
</I>&gt;<i> Your objection was something along the lines of &quot;do not use an ostream
</I>&gt;<i> in Action&quot;.
</I>&gt;<i> 
</I>&gt;<i> So you proposed the Formatter class, an ostream child to be used by Action.
</I>&gt;<i> 
</I>&gt;<i> WTF?
</I>
When you only pay attention the first few words of my paragraph or my
class declaration, it is easy to arrive at strange conclusions. Here is
my initial objection, prefaced with its context sample:


&gt;<i> Mgr::MenuAction::dump(std::ostream &amp;p)
</I>&gt;<i> {
</I>&gt;<i>     p.fill(' '); // space pad the menu fields for readability
</I>&gt;<i>     p.setf(std::ios::left);
</I>&gt;<i>     for (auto &amp;a : CacheManager::GetInstance()-&gt;menu()) {
</I>&gt;<i>         p &lt;&lt; '\t' // menu is a table
</I>&gt;<i>           &lt;&lt; std::setw(22) &lt;&lt; a-&gt;name &lt;&lt; '\t'
</I>&gt;<i>           &lt;&lt; std::setw(32) &lt;&lt; a-&gt;desc &lt;&lt; '\t'
</I>&gt;<i>           &lt;&lt; std::setw(8) &lt;&lt; CacheManager::GetInstance()-&gt;ActionProtection(*a)
</I>&gt;<i>           &lt;&lt; '\n';
</I>&gt;<i>     }
</I>&gt;<i>     p.unsetf(std::ios::left);
</I>&gt;<i> }
</I>
&gt;&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;&gt;<i> impossible) to make syntax mistakes?
</I>
The Page class in my sketch is an example of that &quot;specialized&quot; class I
was talking about in the above paragraph. It makes formal output &quot;easy&quot;
by providing methods that ensure correct syntax. Here is the sketch code
implementing something similar to the MenuAction::dump() above:


&gt;<i>     page.beginList();
</I>&gt;<i>     for (auto name: {&quot;5min&quot;, &quot;60min&quot;, &quot;disk_io&quot;, &quot;events&quot;, &quot;shutdown&quot;}) {
</I>&gt;<i>         page.beginListItem().
</I>&gt;<i>             beginHash().
</I>&gt;<i>                 kv(name, &quot;menu item description to be extracted from Action::desc&quot;).
</I>&gt;<i>                 kv(&quot;protection&quot;, &quot;public&quot;). // ActionProtection(*a)
</I>&gt;<i>             endHash().
</I>&gt;<i>         endListItem();
</I>&gt;<i>     }
</I>&gt;<i>     page.endList();
</I>

We can discuss how &quot;hard&quot; it should be for Action to get access to
Page's ostream interface. In the sketch, the developer would have to use
an ostream method or operator to get access to ostream features. For
example:

  page.beginKv(&quot;statistics_foo&quot;) &lt;&lt; something.mean() &lt;&lt; endKv;
  page.beginkv(&quot;worker_id&quot;) &lt;&lt; &quot;disker&quot; &lt;&lt; DiskerId &lt;&lt; endKv;


If that usage of a low-level interface is not visible enough, we can
hide ostream access behind a dedicated method returning an ostream
reference:

class Page {
public:
...
    /// use this to assemble opaque/atomic values
    ostream &amp;raw();
...
}

It might be used along these lines:

  page.beginKv(&quot;statistics_foo&quot;).raw() &lt;&lt; something.mean() &lt;&lt; endKv;
  page.beginkv(&quot;worker_id&quot;).raw() &lt;&lt; &quot;disker&quot; &lt;&lt; DiskerId &lt;&lt; endKv;


Needless to say, there is some danger in providing such raw access. If a
developer is not careful, they might introduce a syntax error inside
what they saw were perfectly fine atomic values. We can protect against
that and offer automatic escaping of bad characters (among other
things), but that would require more work. I suspect such protections
would not necessarily require Page interface changes; if I am right, we
can delay their implementation until it is clear they are actually needed.


&gt;&gt;<i> Making ostream available for opaque and low-level parts of payload is a
</I>&gt;&gt;<i> good approach. My earlier sketch was probably too small to illustrate
</I>&gt;&gt;<i> this point, but it does provide high-level report structuring methods
</I>&gt;&gt;<i> while keeping ostream available for low-level stuff. More needs to be
</I>&gt;&gt;<i> done to polish that split based on actual typical use cases.
</I>
&gt;<i> The low-level stuff that makes sense using ostream is all internal to
</I>&gt;<i> Formatter. We seemed to be agreeing on that much.
</I>
We do not agree on the &quot;all internal part&quot;. IMO, ostream should be
exposed so that Actions can assemble opaque values using it. I hope the
specific examples above illustrate what I mean by that.


&gt;<i> What I'm not getting is why you insist this ostream API be exposed and
</I>&gt;<i> used by Action now but that PackableStream was inappropriate when it
</I>&gt;<i> could simply have had new members added and been identical to your
</I>&gt;<i> proposed Formatter.
</I>
First of all, the first patch I was reviewing did not pass
PackableStream to Actions. It passed ostream. We cannot add methods to
ostream.

Second, adding formal-syntax formatting methods to PackableStream (and
passing PackableStream to Actions) would be wrong. The PackableStream
class should be dedicated to providing a Packable-backed ostream. It
should not know anything about Cache Manager reports and their
formatting. We may use PackableStream outside Cache Manager.


&gt;<i> The problem in the memory libraries is the *StoreEntry*. In particular
</I>&gt;<i> its class declaration head and things it pulls in.
</I>&gt;<i> 
</I>&gt;<i> Action depends deeply on StoreEntry. So there is no Action dumper in
</I>&gt;<i> libmem. Just currently some pool methods taking (ostream&amp;) and free-form
</I>&gt;<i> dumping out &quot;tables&quot;.
</I>&gt;<i> 
</I>&gt;<i> StoreEntry was made a Packable child for the purpose of using the
</I>&gt;<i> Packable API, possibly via PackableStream. To store stuff into a
</I>&gt;<i> StoreEntry (or just  a Membuf/SBuf) in more complex Formatter-like ways
</I>&gt;<i> without having libmem be aware it was anything other than a Packable.
</I>&gt;<i> 
</I>&gt;<i> If we are going to use Formatter in the libmem dumper code. Then it has
</I>&gt;<i> to be detatched from StoreEntry completely. That also means detatching
</I>&gt;<i> it from Action which depends deeply on StoreEntry. 
</I>
Yes, I suspect we are [still] in agreement here.


&gt;<i> And that it can only
</I>&gt;<i> use the Packable API, possibly via PackableStream (aka ostream&amp;).
</I>
I hope that Page/Formatter does not need to know about Packable, just
ostream, but there may be some corner cases I am not aware of.


&gt;&gt;&gt;&gt;&gt;<i> +    // a comment
</I>&gt;&gt;&gt;&gt;&gt;<i> +    virtual void notice(const SBuf &amp;) = 0;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Let's try to define the purpose of this method more precisely so that we
</I>&gt;&gt;&gt;&gt;<i> know when it is being used [in]correctly. For example:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>   /// a free-form comment or informational text that
</I>&gt;&gt;&gt;&gt;<i>   /// is not meant to be further parsed by automation tools
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> No.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> notice = &quot;A free-form informational text block that is meant for display
</I>&gt;&gt;&gt;<i> without further processing.&quot;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> comment = &quot;A free-form informational text that is not meant for
</I>&gt;&gt;&gt;<i> automated tool processing or display. May be discarded by automation.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You have documented notice() as &quot;a comment&quot;. Now you give two different
</I>&gt;&gt;<i> definitions for those two words. Please make up your mind and adjust the
</I>&gt;&gt;<i> notice() description accordingly. After that, it should be clear whether
</I>&gt;&gt;<i> we agree what notice() is.
</I>

&gt;<i> *Do you agree to those definitions* before I go changing any more code
</I>&gt;<i> around them?
</I>
Do I agree that any notice and any comment fit your definitions? No.
Fortunately, we are not writing word definitions for a dictionary but
documenting a specific class method, so we only need to agree on what
our notice() should do.

I have proposed how to describe the notice() method. You said &quot;No&quot; and
provided two different descriptions for the two words you previously
used as _synonyms_. You did not say which of those two descriptions
applies to the notice() method. There was no explanatory text
accompanying the two descriptions either (unless you count &quot;No&quot; as
such). I hope you can see why I asked you to pick one of the two
descriptions so that we can focus the discussion on it.


I believe your &quot;notice&quot; description is closer to what we need than your
&quot;comment&quot; description. The key here, IMO, is that notice() text is not
meant to be parsed further by automation tools. If we do not want to
prohibit comparisons, then a tool may even compare the received notice
to some notices it knows about, but only as an opaque blob of text, with
no internal structure.

Do I like &quot;display without further processing&quot;? No, I do not like that
phrasing because it is not clear whether

  * further processing for display purposes is allowed;
  * other use (e.g., comparison with other notices) is prohibited;
  * automated reaction without display is prohibited.

In my imperfect description example, I tried to avoid those pitfalls by
focusing on prohibiting just one key activity: parsing of the notice
value [to extract some usable parts]. If we prohibit that, then we are
free to use any format/arrangement for the notice text, but must resist
the temptation to include some information that automation scripts will
want to parse.

For example, the following are &quot;bad&quot; notices (Squid should not generate
them):

  uptime: 1 hour
  built with libecap v1.1
  reconfiguration finished in 5 seconds
  error: I/O error while responding to a cache manager request

and the following are &quot;good&quot; notices:

  reconfiguration finished
  unsupported action
  unknown cache manager output format


&gt;<i> For now notice() is just informational with a requirement that it
</I>&gt;<i> reaches the report reader. There is no other implications on teh
</I>&gt;<i> processing tool.
</I>
If we require that a notice reaches a human report reader, does it mean
that a script receiving a notice cannot act on it autonomously? If yes,
I do not think we want that. If no, then I recommend avoiding such
language as &quot;report reader&quot;.


&gt;<i> I'm not sure how to emphasise *informational* any better than using it
</I>&gt;<i> as the active noune in the descriptive. ALL-CAPS seems over the top.
</I>&gt;<i>  Any suggestions?
</I>
I do not think we should try to regulate that aspect of notice usage.
What is &quot;informational&quot; (as in &quot;FYI, X happened, but feel free to
disregard&quot;?) for one, could be very important (as in &quot;do Y if you
receive notice X&quot;) for another recipient.



&gt;&gt;<i> Going forward, please do not use &quot;final&quot; unless really necessary. Treat
</I>&gt;&gt;<i> it like we treat &quot;throw()&quot; declarations.
</I>

&gt;<i> You mean spotted liberally around the new code in the form of a wrapper
</I>&gt;<i> keyword like Must() ?
</I>
No, I mean avoided like the now-deprecated &quot;throw()&quot; exception
specification:

  <A HREF="http://en.cppreference.com/w/cpp/language/except_spec">http://en.cppreference.com/w/cpp/language/except_spec</A>
  <A HREF="http://www.gotw.ca/publications/mill22.htm">http://www.gotw.ca/publications/mill22.htm</A>

Proposed rule of thumb: If correct inheritance or overriding is
possible, do not use &quot;final&quot;, even if you do not see any good reasons to
inherit or override.


HTH,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003056.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
	<LI>Next message: <A HREF="003083.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3061">[ date ]</a>
              <a href="thread.html#3061">[ thread ]</a>
              <a href="subject.html#3061">[ subject ]</a>
              <a href="author.html#3061">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
