<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PayloadFormatter (was PackableStream)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D5D267.4050905%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003061.html">
   <LINK REL="Next"  HREF="003087.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PayloadFormatter (was PackableStream)</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D5D267.4050905%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] PayloadFormatter (was PackableStream)">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Aug 20 13:13:11 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003061.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
        <LI>Next message: <A HREF="003087.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3083">[ date ]</a>
              <a href="thread.html#3083">[ thread ]</a>
              <a href="subject.html#3083">[ subject ]</a>
              <a href="author.html#3083">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 20/08/2015 9:18 a.m., Alex Rousskov wrote:
&gt;<i> On 08/19/2015 09:47 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 19/08/2015 4:50 p.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 08/15/2015 12:20 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> For now this class is specifically and intentionally dumping out the
</I>&gt;&gt;&gt;&gt;<i> (old) format for cachemgr.cgi. Other third-party tools are considered
</I>&gt;&gt;&gt;&gt;<i> only so far as the cachemgr ambiguous syntax was published in various
</I>&gt;&gt;&gt;&gt;<i> parts in various places. As long as the output still matches that they
</I>&gt;&gt;&gt;&gt;<i> should be fine (or better off).
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> IMO, made-up after-the-fact syntax rules are irrelevant (because
</I>&gt;&gt;&gt;<i> &quot;nobody&quot; knows about them, and they are imprecise). Cachemgr.cgi itself
</I>&gt;&gt;&gt;<i> is irrelevant (because we control it). Admin scripts parsing old output
</I>&gt;&gt;&gt;<i> are relevant. Thus, we should either keep the old output pretty much &quot;as
</I>&gt;&gt;&gt;<i> is&quot; or replace it with something sufficiently better to justify the
</I>&gt;&gt;&gt;<i> change pains for the admins. Adjusting output (while claiming
</I>&gt;&gt;&gt;<i> compatibility with some syntax rules we made up) is a bad approach
</I>&gt;&gt;&gt;<i> because it makes admins unhappy while not making us happy.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> &quot;The Definitive Guide&quot; 14.2. All the way through its talking about
</I>&gt;&gt;<i> cachemgr.cgi display &quot;columns&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To find the detail of what a input &quot;column&quot; actually is refer to
</I>&gt;&gt;<i> cachemgr.cgi code itself. Specificaly the munge_other_line() function
</I>&gt;&gt;<i> for converting report text/plain to text/html. This code has not changed
</I>&gt;&gt;<i> in any significant way since the 1990's.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Any line excluding a \t is a free-form text line. Lets call that ...
</I>&gt;&gt;<i> comment, kv-pair, LF.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * table is a series of \t delimited cells. Lets call that ... 'table-row'.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * If the first cell of the first line of a table includes a ':' its a
</I>&gt;&gt;<i> header row. Lets call that ... 'table' for the whole set of rows, and we
</I>&gt;&gt;<i> will need a optional 'label' for the pre-colon bit in the first table-row.
</I>&gt;<i> 
</I>&gt;&gt;<i> The Guide is also talking about how several reports including
</I>&gt;&gt;<i> 'redirectors' are *identical* in format to 'idns' ... not today, they
</I>&gt;&gt;<i> use tab-delimiting. idns got screwed up years later and now uses space
</I>&gt;&gt;<i> delimiting and looks like crap in CGI display as a result.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The kv-pairs is not part of the Guide + CGI documentation. Those parts I
</I>&gt;&gt;<i> took from your own emails and IRC chats educating me an kinkie about
</I>&gt;&gt;<i> what the report format was supposed to be.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This part of the email thread was discussing whether the existence of
</I>&gt;<i> admin scripts (rather than various imprecise syntax rules or
</I>&gt;<i> cachemgr.cgi code) should be the primary factor in our decision making.
</I>&gt;<i> How is the above information relevant to that discussion?
</I>&gt;<i> 
</I>
If such admin scripts are based on anything beyond blind guesses it will
be based on that public documentation and dicussion.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +class PayloadFormatter
</I>&gt;&gt;&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +    Packable &outBuf;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Since the majority of PayloadFormatter methods and callers are going to
</I>&gt;&gt;&gt;&gt;&gt;<i> assemble and format pieces of text and numbers, I think this should
</I>&gt;&gt;&gt;&gt;&gt;<i> become an ostream.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> You want to go back to PackableStream now?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If possible, the new page/report/payload building interface should be
</I>&gt;&gt;&gt;<i> ostream-enabled, not PackableStream-enabled. IIRC, that's what I
</I>&gt;&gt;&gt;<i> sketched a few emails back.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So how does the data get from std::ostreambuf to the client if its not
</I>&gt;&gt;<i> going near a Packable (ie StoreEntry).
</I>&gt;<i> 
</I>&gt;<i> I do not think ostream should use std::ostreambuf if that is what you
</I>&gt;<i> meant. It should use our own buffer, backed by Packable (or StoreEntry).
</I>&gt;<i> However, cache manager code would not know that and, hence, there should
</I>&gt;<i> be no linking problems associated with that knowledge.
</I>&gt;<i> 
</I>
Okay. I think I undertand you there.

But the statement about cachemgr does not quite click. Formatter and all
thus *is* cache manager (Mgr::) code. I dont see how Mgr:: code can not
know about how its own internals work.

I assume by &quot;cache manager code&quot; you mean Action and the HTTP
request/reply handling part of Mgr::.


&gt;<i> 
</I>&gt;&gt;<i> You ask to data-copy into the stream buffer, then data-copy a second
</I>&gt;&gt;<i> time to the StoreEntry buffer.
</I>&gt;<i> 
</I>&gt;<i> No, I do not. The stream buffer should use StoreEntry as storage [when
</I>&gt;<i> the output goes to Store].
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> PackableStream is an ostream child providing StoreEntry as the buffer.
</I>&gt;&gt;<i> So PackableStream data-copies to the StoreEntry buffer.
</I>&gt;<i> 
</I>&gt;<i> Yes.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Which would you expect provides better performance:
</I>&gt;&gt;<i>  one or two data-copies ?
</I>&gt;<i> 
</I>&gt;<i> One copy.
</I>&gt;<i> 
</I>&gt;<i> (The design choices here are actually not driven by performance, but by
</I>&gt;<i> the requirement to avoid buffering of huge cache manager responses in
</I>&gt;<i> RAM. However, the same custom ostream buffer design happens to eliminate
</I>&gt;<i> the extra copy as a positive performance side effect).
</I>

Then I am going back to the PackableStream patch and making a new
iteration that just renames StoreEntryStream and fixes the syntax
things. Patch for that in the other thread as soon as it works.

This patch will then have Formatter creating one of those streams
if/when necessary to drop values into.

Agreed?


&gt;<i> 
</I>&gt;&gt;&gt;<i> Said that, ostream is the wrong primary interface for assembling
</I>&gt;&gt;&gt;<i> payload/pages/reports. IMO, you should reintroduce ostream capabilities,
</I>&gt;&gt;&gt;<i> but we should not be [going back to] assembling primary
</I>&gt;&gt;&gt;<i> payload/pages/reports using ostream. More on that below.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> The code proposal you submitted has Formatter inherting from ostream.
</I>&gt;<i> 
</I>&gt;<i> Yes, Page is a child of ostream in my sketch.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> The only use of Formatter is by Action.
</I>&gt;<i> 
</I>&gt;<i> Yes, at least in the scope of this discussion.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Ergo you intend Action to be
</I>&gt;&gt;<i> using a ostream interface to assemble top-level report data.
</I>&gt;<i> 
</I>&gt;<i> No. Page provides a set of methods for high-level assembly, including:
</I>&gt;<i> 
</I>&gt;<i>     /// starts recording a list of values
</I>&gt;<i>     virtual Page &amp;beginList() = 0;
</I>&gt;<i>     /// finishes recording a list of values
</I>&gt;<i>     virtual Page &amp;endList() = 0;
</I>&gt;<i> 
</I>&gt;<i>     /// starts recording a list of values
</I>&gt;<i>     virtual Page &amp;beginListItem() = 0;
</I>&gt;<i>     /// finishes recording a list of values
</I>&gt;<i>     virtual Page &amp;endListItem() = 0;
</I>&gt;<i> 
</I>&gt;<i>     /// starts recording a key:value pair with a given key
</I>&gt;<i>     virtual Page &amp;beginKv(const SBuf &amp;key) = 0;
</I>&gt;<i>     /// finishes recording a key:value pair
</I>&gt;<i>     virtual Page &amp;endKv() = 0;
</I>&gt;<i> 
</I>
That is not usable by code taking ostream&amp;. Therefore not useful to the
code which most needs to use this objects API.

&gt;<i> 
</I>&gt;&gt;<i> Either ostream is a private internal to Formatter for low-level use
</I>&gt;&gt;<i> only, or it is available (and eventually used) at high-level Action.
</I>&gt;<i> 
</I>&gt;<i> It is a public interface for assembling some opaque/atomic values for
</I>&gt;<i> formal output such as YAML.
</I>
This *will not* correctly format YAML or HTML syntax:

  Page &lt;&lt; &quot;Hello World&quot;;

Making Page/Formatter an ostream child is just not useful for its one
and only user (Action).


&gt;<i> 
</I>&gt;<i> Whether inheriting from ostream is the best approach to accomplish that,
</I>&gt;<i> I am not sure, but it is probably the simplest one. The alternative to
</I>&gt;<i> consider is to provide a method that returns an ostream reference. There
</I>&gt;<i> are some examples below.
</I>
I'm certain its not. So why are we still circling this ?


&gt;&gt;&gt;&gt;<i> Because StoreEntryStream would place a Store.h dependency almost as
</I>&gt;&gt;&gt;&gt;<i> widely as squid.h dependency.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> The _implementation_ of the ostream-based interface may use something
</I>&gt;&gt;&gt;<i> like PackableStream or even StoreEntryStream without introducing any
</I>&gt;&gt;&gt;<i> excessive dependencies AFAICT. In the sketch I posted, only one line of
</I>&gt;&gt;&gt;<i> code new about std::cout backing while the rest was using ostream.
</I>&gt;<i> 
</I>&gt;&gt;<i> You argued strongly for *not* doing it exactly that way only the other week.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I did not. I argued against using ostream to format strict syntax (e.g.,
</I>&gt;<i> YAML) output. Later, I provided a sketch how to avoid doing that while
</I>&gt;<i> still supporting ostream-based assembly of YAML atomic values. I now
</I>&gt;<i> included specific examples further below.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Your response has been to propose an object ... which is an ostream
</I>&gt;&gt;<i> child. And would thus be used like PackableStream in my first proposal.
</I>&gt;<i> 
</I>&gt;<i> The difference between the Page class and PackableStream is that Page
</I>&gt;<i> provides methods for high-level formal formatting (such as YAML).
</I>&gt;<i> PackableStream does not and should not have such methods. You should
</I>&gt;<i> look at the whole Page class declaration, not just at its first line
</I>&gt;<i> (where ostream inheritance is declared).
</I>
I did. The first line indicates that its providing ostream&amp; operators
API ... apparently for use.

The other code was passing it as ostream&amp;. Which elides the new
formatting methods and leaves Action internal methods with only stream
operator&lt;&lt; to work with. That does not fit with the concept of avoiding
Action using streams.




&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;&gt;<i> Almost all the code that uses outBuf and PayloadFormatter methods in the
</I>&gt;&gt;&gt;&gt;&gt;<i> patch already looks labored/awkward (often worse than the trivial code
</I>&gt;&gt;&gt;&gt;&gt;<i> it replaces!), and would look much better if replaced by the usual
</I>&gt;&gt;&gt;&gt;&gt;<i> ostream &quot;&lt;&lt;&quot; expressions.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Now you see the benefit of ostream.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> My attitude towards ostream has not changed. Forming payloads/pages
</I>&gt;&gt;&gt;<i> /reports using ostream as the top-level interface was wrong and still is.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Your objection was something along the lines of &quot;do not use an ostream
</I>&gt;&gt;<i> in Action&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So you proposed the Formatter class, an ostream child to be used by Action.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> WTF?
</I>&gt;<i> 
</I>&gt;<i> When you only pay attention the first few words of my paragraph or my
</I>&gt;<i> class declaration, it is easy to arrive at strange conclusions. Here is
</I>&gt;<i> my initial objection, prefaced with its context sample:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Mgr::MenuAction::dump(std::ostream &amp;p)
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i>     p.fill(' '); // space pad the menu fields for readability
</I>&gt;&gt;<i>     p.setf(std::ios::left);
</I>&gt;&gt;<i>     for (auto &amp;a : CacheManager::GetInstance()-&gt;menu()) {
</I>&gt;&gt;<i>         p &lt;&lt; '\t' // menu is a table
</I>&gt;&gt;<i>           &lt;&lt; std::setw(22) &lt;&lt; a-&gt;name &lt;&lt; '\t'
</I>&gt;&gt;<i>           &lt;&lt; std::setw(32) &lt;&lt; a-&gt;desc &lt;&lt; '\t'
</I>&gt;&gt;<i>           &lt;&lt; std::setw(8) &lt;&lt; CacheManager::GetInstance()-&gt;ActionProtection(*a)
</I>&gt;&gt;<i>           &lt;&lt; '\n';
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     p.unsetf(std::ios::left);
</I>&gt;&gt;<i> }
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> It feels wrong that you want Actions to output using strict syntax but
</I>&gt;&gt;&gt;<i> give them an &quot;free form&quot; or &quot;anything goes&quot; std::ostream as a tool to
</I>&gt;&gt;&gt;<i> accomplish that. Should not Action dumping methods receive a specialized
</I>&gt;&gt;&gt;<i> class that makes it easy to produce the output you want and hard (if not
</I>&gt;&gt;&gt;<i> impossible) to make syntax mistakes?
</I>&gt;<i> 
</I>&gt;<i> The Page class in my sketch is an example of that &quot;specialized&quot; class I
</I>&gt;<i> was talking about in the above paragraph. It makes formal output &quot;easy&quot;
</I>&gt;<i> by providing methods that ensure correct syntax. Here is the sketch code
</I>&gt;<i> implementing something similar to the MenuAction::dump() above:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>     page.beginList();
</I>&gt;&gt;<i>     for (auto name: {&quot;5min&quot;, &quot;60min&quot;, &quot;disk_io&quot;, &quot;events&quot;, &quot;shutdown&quot;}) {
</I>&gt;&gt;<i>         page.beginListItem().
</I>&gt;&gt;<i>             beginHash().
</I>&gt;&gt;<i>                 kv(name, &quot;menu item description to be extracted from Action::desc&quot;).
</I>&gt;&gt;<i>                 kv(&quot;protection&quot;, &quot;public&quot;). // ActionProtection(*a)
</I>&gt;&gt;<i>             endHash().
</I>&gt;&gt;<i>         endListItem();
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     page.endList();
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> We can discuss how &quot;hard&quot; it should be for Action to get access to
</I>&gt;<i> Page's ostream interface. In the sketch, the developer would have to use
</I>&gt;<i> an ostream method or operator to get access to ostream features. For
</I>&gt;<i> example:
</I>&gt;<i> 
</I>&gt;<i>   page.beginKv(&quot;statistics_foo&quot;) &lt;&lt; something.mean() &lt;&lt; endKv;
</I>&gt;<i>   page.beginkv(&quot;worker_id&quot;) &lt;&lt; &quot;disker&quot; &lt;&lt; DiskerId &lt;&lt; endKv;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> If that usage of a low-level interface is not visible enough, we can
</I>&gt;<i> hide ostream access behind a dedicated method returning an ostream
</I>&gt;<i> reference:
</I>&gt;<i> 
</I>&gt;<i> class Page {
</I>&gt;<i> public:
</I>&gt;<i> ...
</I>&gt;<i>     /// use this to assemble opaque/atomic values
</I>&gt;<i>     ostream &amp;raw();
</I>&gt;<i> ...
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> It might be used along these lines:
</I>&gt;<i> 
</I>&gt;<i>   page.beginKv(&quot;statistics_foo&quot;).raw() &lt;&lt; something.mean() &lt;&lt; endKv;
</I>&gt;<i>   page.beginkv(&quot;worker_id&quot;).raw() &lt;&lt; &quot;disker&quot; &lt;&lt; DiskerId &lt;&lt; endKv;
</I>&gt;<i> 
</I>
Aha. Back to Action code using streams. And why you want chaining.

But I think I see what you are imagining in the background now.


This relies on chaining and comes back to the same reasons I dont want that.

* It is reasonable to expect that worker_id has different syntax for
string and numeric representations in one of the syntaxes added later.
 That would call for multiple kvPair(name, value) methods based on the
value received here by the &lt;&lt; operator.

* With indentation in the syntax (both current and YAML) the
&quot;something.mean()&quot; output needs a specific prefix applied at the start
of each of its lines.

In both those circumstances it is better to pass 'page' to mean() and
ensure that sub-pieces of something.mean(page) are individually prefixed
and syntaxed by page with correct bits according to its internal state.


Also, the bits between &lt;&lt; are now free-flow outputs again. Thats a sure
recipe for some report to make an assumption like you do in the example
code itself (with &quot;disker&quot; assuming a string ID). That a particular kv
thing is going to take a string rather than an integer value.
 This model would kill any hope of an ASN1 or such Formatter/Page.



&gt;<i> 
</I>&gt;<i> Needless to say, there is some danger in providing such raw access. If a
</I>&gt;<i> developer is not careful, they might introduce a syntax error inside
</I>&gt;<i> what they saw were perfectly fine atomic values. We can protect against
</I>&gt;<i> that and offer automatic escaping of bad characters (among other
</I>&gt;<i> things), but that would require more work. I suspect such protections
</I>&gt;<i> would not necessarily require Page interface changes; if I am right, we
</I>&gt;<i> can delay their implementation until it is clear they are actually needed.
</I>&gt;<i> 
</I>

I don't think that is necessary though. So I am leaving it out of these
early patches. Okay?


&gt;<i> 
</I>&gt;&gt;&gt;<i> Making ostream available for opaque and low-level parts of payload is a
</I>&gt;&gt;&gt;<i> good approach. My earlier sketch was probably too small to illustrate
</I>&gt;&gt;&gt;<i> this point, but it does provide high-level report structuring methods
</I>&gt;&gt;&gt;<i> while keeping ostream available for low-level stuff. More needs to be
</I>&gt;&gt;&gt;<i> done to polish that split based on actual typical use cases.
</I>&gt;<i> 
</I>&gt;&gt;<i> The low-level stuff that makes sense using ostream is all internal to
</I>&gt;&gt;<i> Formatter. We seemed to be agreeing on that much.
</I>&gt;<i> 
</I>&gt;<i> We do not agree on the &quot;all internal part&quot;. IMO, ostream should be
</I>&gt;<i> exposed so that Actions can assemble opaque values using it. I hope the
</I>&gt;<i> specific examples above illustrate what I mean by that.
</I>
see above.

The current free-form outputs already place indentation requirements the
mixed methods + ostream Page API cannot meet. Its either ostream with
Action::dump() doing the indentation explicitly, or just the
Page/Formatter methods.

YAML adds extra construct syntax requirements that make it even more
nasty. Then any potential binary outputs we want to generate later will
die horribly.


&gt;<i> 
</I>&gt;&gt;<i> What I'm not getting is why you insist this ostream API be exposed and
</I>&gt;&gt;<i> used by Action now but that PackableStream was inappropriate when it
</I>&gt;&gt;<i> could simply have had new members added and been identical to your
</I>&gt;&gt;<i> proposed Formatter.
</I>&gt;<i> 
</I>&gt;<i> First of all, the first patch I was reviewing did not pass
</I>&gt;<i> PackableStream to Actions. It passed ostream. We cannot add methods to
</I>&gt;<i> ostream.
</I>
It is not passed to Actions. Its created by Action and passed to
Action::dump() and action sub-code.

&gt;<i> 
</I>&gt;<i> Second, adding formal-syntax formatting methods to PackableStream (and
</I>&gt;<i> passing PackableStream to Actions) would be wrong. The PackableStream
</I>&gt;<i> class should be dedicated to providing a Packable-backed ostream. It
</I>&gt;<i> should not know anything about Cache Manager reports and their
</I>&gt;<i> formatting. We may use PackableStream outside Cache Manager.
</I>

Its only uses were as an output serializer (formatter) for Action dump()
code. The slightly higher-order syntax of what the fields were was being
left in Action::dump() and related functions where it is in current trunk.

We agreed to use Page/Formatter to allow markup injection between fields
now, so re-coding was not necessary later.

In either model Action::dump is still responsible for knowledge of what
field types are being output. Either in the Page/Formatter methods its
calling, or the particular stream &lt;&lt; sequencing.

As I mentioned above exposing operator&lt;&lt; to Action just means important
parts of the markup injection is not possible. At least not without
moving format/syntax scope things from Formatter back to Action.


&gt;<i> 
</I>&gt;&gt;<i> The problem in the memory libraries is the *StoreEntry*. In particular
</I>&gt;&gt;<i> its class declaration head and things it pulls in.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Action depends deeply on StoreEntry. So there is no Action dumper in
</I>&gt;&gt;<i> libmem. Just currently some pool methods taking (ostream&amp;) and free-form
</I>&gt;&gt;<i> dumping out &quot;tables&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> StoreEntry was made a Packable child for the purpose of using the
</I>&gt;&gt;<i> Packable API, possibly via PackableStream. To store stuff into a
</I>&gt;&gt;<i> StoreEntry (or just  a Membuf/SBuf) in more complex Formatter-like ways
</I>&gt;&gt;<i> without having libmem be aware it was anything other than a Packable.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If we are going to use Formatter in the libmem dumper code. Then it has
</I>&gt;&gt;<i> to be detatched from StoreEntry completely. That also means detatching
</I>&gt;&gt;<i> it from Action which depends deeply on StoreEntry. 
</I>&gt;<i> 
</I>&gt;<i> Yes, I suspect we are [still] in agreement here.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> And that it can only
</I>&gt;&gt;<i> use the Packable API, possibly via PackableStream (aka ostream&amp;).
</I>&gt;<i> 
</I>&gt;<i> I hope that Page/Formatter does not need to know about Packable, just
</I>&gt;<i> ostream, but there may be some corner cases I am not aware of.
</I>
If Formatter is allocating the PackableStream it would. But
PackableStream is an wholly inline thing for exactly that type of reason.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +    // a comment
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +    virtual void notice(const SBuf &amp;) = 0;
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Let's try to define the purpose of this method more precisely so that we
</I>&gt;&gt;&gt;&gt;&gt;<i> know when it is being used [in]correctly. For example:
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>   /// a free-form comment or informational text that
</I>&gt;&gt;&gt;&gt;&gt;<i>   /// is not meant to be further parsed by automation tools
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> No.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> notice = &quot;A free-form informational text block that is meant for display
</I>&gt;&gt;&gt;&gt;<i> without further processing.&quot;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> comment = &quot;A free-form informational text that is not meant for
</I>&gt;&gt;&gt;&gt;<i> automated tool processing or display. May be discarded by automation.&quot;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> You have documented notice() as &quot;a comment&quot;. Now you give two different
</I>&gt;&gt;&gt;<i> definitions for those two words. Please make up your mind and adjust the
</I>&gt;&gt;&gt;<i> notice() description accordingly. After that, it should be clear whether
</I>&gt;&gt;&gt;<i> we agree what notice() is.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> *Do you agree to those definitions* before I go changing any more code
</I>&gt;&gt;<i> around them?
</I>&gt;<i> 
</I>&gt;<i> Do I agree that any notice and any comment fit your definitions? No.
</I>&gt;<i> Fortunately, we are not writing word definitions for a dictionary but
</I>&gt;<i> documenting a specific class method, so we only need to agree on what
</I>&gt;<i> our notice() should do.
</I>&gt;<i> 
</I>&gt;<i> I have proposed how to describe the notice() method. You said &quot;No&quot; and
</I>&gt;<i> provided two different descriptions for the two words you previously
</I>&gt;<i> used as _synonyms_. You did not say which of those two descriptions
</I>&gt;<i> applies to the notice() method. There was no explanatory text
</I>&gt;<i> accompanying the two descriptions either (unless you count &quot;No&quot; as
</I>&gt;<i> such). I hope you can see why I asked you to pick one of the two
</I>&gt;<i> descriptions so that we can focus the discussion on it.
</I>
Sorry. I missed off the (). I intended those to be the as-is
documentation for the two methods with those names.



&gt;<i> 
</I>&gt;<i> I believe your &quot;notice&quot; description is closer to what we need than your
</I>&gt;<i> &quot;comment&quot; description. The key here, IMO, is that notice() text is not
</I>&gt;<i> meant to be parsed further by automation tools. If we do not want to
</I>&gt;<i> prohibit comparisons, then a tool may even compare the received notice
</I>&gt;<i> to some notices it knows about, but only as an opaque blob of text, with
</I>&gt;<i> no internal structure.
</I>
Okay.


&gt;<i> 
</I>&gt;<i> Do I like &quot;display without further processing&quot;? No, I do not like that
</I>&gt;<i> phrasing because it is not clear whether
</I>&gt;<i> 
</I>&gt;<i>   * further processing for display purposes is allowed;
</I>&gt;<i>   * other use (e.g., comparison with other notices) is prohibited;
</I>&gt;<i>   * automated reaction without display is prohibited.
</I>&gt;<i> 
</I>&gt;<i> In my imperfect description example, I tried to avoid those pitfalls by
</I>&gt;<i> focusing on prohibiting just one key activity: parsing of the notice
</I>&gt;<i> value [to extract some usable parts]. If we prohibit that, then we are
</I>&gt;<i> free to use any format/arrangement for the notice text, but must resist
</I>&gt;<i> the temptation to include some information that automation scripts will
</I>&gt;<i> want to parse.
</I>
Okay.

&gt;<i> 
</I>&gt;<i> For example, the following are &quot;bad&quot; notices (Squid should not generate
</I>&gt;<i> them):
</I>&gt;<i> 
</I>&gt;<i>   uptime: 1 hour
</I>&gt;<i>   built with libecap v1.1
</I>&gt;<i>   reconfiguration finished in 5 seconds
</I>&gt;<i>   error: I/O error while responding to a cache manager request
</I>&gt;<i> 
</I>&gt;<i> and the following are &quot;good&quot; notices:
</I>&gt;<i> 
</I>&gt;<i>   reconfiguration finished
</I>&gt;<i>   unsupported action
</I>&gt;<i>   unknown cache manager output format
</I>&gt;<i> 
</I>
Agreed.

&gt;<i> 
</I>&gt;&gt;<i> For now notice() is just informational with a requirement that it
</I>&gt;&gt;<i> reaches the report reader. There is no other implications on teh
</I>&gt;&gt;<i> processing tool.
</I>&gt;<i> 
</I>&gt;<i> If we require that a notice reaches a human report reader, does it mean
</I>&gt;<i> that a script receiving a notice cannot act on it autonomously? If yes,
</I>&gt;<i> I do not think we want that. If no, then I recommend avoiding such
</I>&gt;<i> language as &quot;report reader&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> I'm not sure how to emphasise *informational* any better than using it
</I>&gt;&gt;<i> as the active noune in the descriptive. ALL-CAPS seems over the top.
</I>&gt;&gt;<i>  Any suggestions?
</I>&gt;<i> 
</I>&gt;<i> I do not think we should try to regulate that aspect of notice usage.
</I>&gt;<i> What is &quot;informational&quot; (as in &quot;FYI, X happened, but feel free to
</I>&gt;<i> disregard&quot;?) for one, could be very important (as in &quot;do Y if you
</I>&gt;<i> receive notice X&quot;) for another recipient.
</I>&gt;<i> 
</I>
I think we agree on intention. But neither have a good text for it yet.

It's that passing-on property we need to clearly state. I've used
&quot;display&quot; there since its variable by context and loose enough to cover
any type of that action.


How about just a terse:

notice() - &quot;An informational text announcement. To be passed on instead
of ignored. Do not automatically parse the text.&quot;

comment() - &quot;An informational text comment. May be ignored or dropped.
Do not automatically parse the text.&quot;



&gt;<i> 
</I>&gt;&gt;&gt;<i> Going forward, please do not use &quot;final&quot; unless really necessary. Treat
</I>&gt;&gt;&gt;<i> it like we treat &quot;throw()&quot; declarations.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> You mean spotted liberally around the new code in the form of a wrapper
</I>&gt;&gt;<i> keyword like Must() ?
</I>&gt;<i> 
</I>&gt;<i> No, I mean avoided like the now-deprecated &quot;throw()&quot; exception
</I>&gt;<i> specification:
</I>&gt;<i> 
</I>&gt;<i>   <A HREF="http://en.cppreference.com/w/cpp/language/except_spec">http://en.cppreference.com/w/cpp/language/except_spec</A>
</I>&gt;<i>   <A HREF="http://www.gotw.ca/publications/mill22.htm">http://www.gotw.ca/publications/mill22.htm</A>
</I>&gt;<i> 
</I>&gt;<i> Proposed rule of thumb: If correct inheritance or overriding is
</I>&gt;<i> possible, do not use &quot;final&quot;, even if you do not see any good reasons to
</I>&gt;<i> inherit or override.
</I>&gt;<i> 
</I>
Aha. Though AFAIK correct inhertence is *always* possible in reasonable
code. So that is just a ban on &quot;final&quot;.

As you saw my uses of it are kind of &quot;political&quot; in nature. To enforce
better code use and graceful deprecations of widely used things.

Amos

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003061.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
	<LI>Next message: <A HREF="003087.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3083">[ date ]</a>
              <a href="thread.html#3083">[ thread ]</a>
              <a href="subject.html#3083">[ subject ]</a>
              <a href="author.html#3083">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
