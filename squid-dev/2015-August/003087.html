<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PayloadFormatter (was PackableStream)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D676B4.6010204%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003083.html">
   <LINK REL="Next"  HREF="002963.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PayloadFormatter (was PackableStream)</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PayloadFormatter%20%28was%20PackableStream%29&In-Reply-To=%3C55D676B4.6010204%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] PayloadFormatter (was PackableStream)">rousskov at measurement-factory.com
       </A><BR>
    <I>Fri Aug 21 00:54:12 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003083.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
        <LI>Next message: <A HREF="002963.html">[squid-dev] [PATCH] Ignore impossible SSL bumping actions, as intended and documented / bug 4237 fix
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3087">[ date ]</a>
              <a href="thread.html#3087">[ thread ]</a>
              <a href="subject.html#3087">[ subject ]</a>
              <a href="author.html#3087">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/20/2015 07:13 AM, Amos Jeffries wrote:
&gt;&gt;<i> This part of the email thread was discussing whether the existence of
</I>&gt;&gt;<i> admin scripts (rather than various imprecise syntax rules or
</I>&gt;&gt;<i> cachemgr.cgi code) should be the primary factor in our decision making.
</I>&gt;&gt;<i> How is the above information relevant to that discussion?
</I>
&gt;<i> If such admin scripts are based on anything beyond blind guesses it will
</I>&gt;<i> be based on that public documentation and dicussion.
</I>
Thank you for explaining why you talked about Guide and cachemgr.cgi code.

I suspect most admin scripts are based on the output received from
Squid. You may call that &quot;blind guesses&quot; if you wish; the label is not
important in this case. Since there was no public documentation when
most of those scripts were hacked together, I do not think we should
expect much else, *even* if we fantasize about admins that read guide
books and study obscure source code just to parse simple (but
non-standard) output.


&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> +class PayloadFormatter
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> +    Packable &outBuf;
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Since the majority of PayloadFormatter methods and callers are going to
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> assemble and format pieces of text and numbers, I think this should
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> become an ostream.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> You want to go back to PackableStream now?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> If possible, the new page/report/payload building interface should be
</I>&gt;&gt;&gt;&gt;<i> ostream-enabled, not PackableStream-enabled. IIRC, that's what I
</I>&gt;&gt;&gt;&gt;<i> sketched a few emails back.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So how does the data get from std::ostreambuf to the client if its not
</I>&gt;&gt;&gt;<i> going near a Packable (ie StoreEntry).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I do not think ostream should use std::ostreambuf if that is what you
</I>&gt;&gt;<i> meant. It should use our own buffer, backed by Packable (or StoreEntry).
</I>&gt;&gt;<i> However, cache manager code would not know that and, hence, there should
</I>&gt;&gt;<i> be no linking problems associated with that knowledge.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Okay. I think I undertand you there.
</I>&gt;<i> 
</I>&gt;<i> But the statement about cachemgr does not quite click. Formatter and all
</I>&gt;<i> thus *is* cache manager (Mgr::) code. I dont see how Mgr:: code can not
</I>&gt;<i> know about how its own internals work.
</I>&gt;<i> 
</I>&gt;<i> I assume by &quot;cache manager code&quot; you mean Action and the HTTP
</I>&gt;<i> request/reply handling part of Mgr::.
</I>
... and Page/Formatter itself. The code that needs to know about
StoreEntry is the code that creates a specific ostream object to
configure the Page/Formatter object with. Whether that code is inside
the Mgr:: namespace is irrelevant to the linking problems you were
worried about.


&gt;&gt;&gt;<i> You ask to data-copy into the stream buffer, then data-copy a second
</I>&gt;&gt;&gt;<i> time to the StoreEntry buffer.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No, I do not. The stream buffer should use StoreEntry as storage [when
</I>&gt;&gt;<i> the output goes to Store].
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> PackableStream is an ostream child providing StoreEntry as the buffer.
</I>&gt;&gt;&gt;<i> So PackableStream data-copies to the StoreEntry buffer.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Which would you expect provides better performance:
</I>&gt;&gt;&gt;<i>  one or two data-copies ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> One copy.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (The design choices here are actually not driven by performance, but by
</I>&gt;&gt;<i> the requirement to avoid buffering of huge cache manager responses in
</I>&gt;&gt;<i> RAM. However, the same custom ostream buffer design happens to eliminate
</I>&gt;&gt;<i> the extra copy as a positive performance side effect).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Then I am going back to the PackableStream patch and making a new
</I>&gt;<i> iteration that just renames StoreEntryStream and fixes the syntax
</I>&gt;<i> things. Patch for that in the other thread as soon as it works.
</I>
Re-introducing PackableStream sounds good to me. Please note that
Actions should not get PackableStream, StoreEntryStream, or ostream as
the new dump() argument though! They should get an object with
payload/page/report formatting methods. See my Page sketch for an example.


&gt;<i> This patch will then have Formatter creating one of those streams
</I>&gt;<i> if/when necessary to drop values into.
</I>
That does not sound quite right:

* an ostream would be needed for virtually any Formatter/Page method
and, hence, should be created once;

* an ostream should be backed by StoreEntry or another complex
destination that Formatter/Page should not know about and, hence, it
should be created outside Formatter/Page.


&gt;<i> Agreed?
</I>
To avoid misunderstanding: I hesitate reviewing a future patch now,
based on a verbal description of changes, especially since &quot;fixes the
syntax things&quot; may mean very different things to me and you. Even the
specific red flags I noted above may not match your true intent and/or
the next patch iteration!



&gt;&gt;&gt;&gt;<i> Said that, ostream is the wrong primary interface for assembling
</I>&gt;&gt;&gt;&gt;<i> payload/pages/reports. IMO, you should reintroduce ostream capabilities,
</I>&gt;&gt;&gt;&gt;<i> but we should not be [going back to] assembling primary
</I>&gt;&gt;&gt;&gt;<i> payload/pages/reports using ostream. More on that below.
</I>

&gt;&gt;<i> Page provides a set of methods for high-level assembly, including:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     /// starts recording a list of values
</I>&gt;&gt;<i>     virtual Page &amp;beginList() = 0;
</I>&gt;&gt;<i>     /// finishes recording a list of values
</I>&gt;&gt;<i>     virtual Page &amp;endList() = 0;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     /// starts recording a list of values
</I>&gt;&gt;<i>     virtual Page &amp;beginListItem() = 0;
</I>&gt;&gt;<i>     /// finishes recording a list of values
</I>&gt;&gt;<i>     virtual Page &amp;endListItem() = 0;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     /// starts recording a key:value pair with a given key
</I>&gt;&gt;<i>     virtual Page &amp;beginKv(const SBuf &amp;key) = 0;
</I>&gt;&gt;<i>     /// finishes recording a key:value pair
</I>&gt;&gt;<i>     virtual Page &amp;endKv() = 0;
</I>

&gt;<i> That is not usable by code taking ostream&amp;. Therefore not useful to the
</I>&gt;<i> code which most needs to use this objects API.
</I>
Sorry, I do not understand this comment. There should be no
Action::dump2 &quot;code taking ostream&quot; if I interpret you correctly. The
new Action::dump2 methods should accept Page reference as an argument,
not an ostream reference.


&gt;&gt;<i> class Page {
</I>&gt;&gt;<i> public:
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i>     /// use this to assemble opaque/atomic values
</I>&gt;&gt;<i>     ostream &amp;raw();
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It might be used along these lines:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   page.beginKv(&quot;statistics_foo&quot;).raw() &lt;&lt; something.mean() &lt;&lt; endKv;
</I>&gt;&gt;<i>   page.beginkv(&quot;worker_id&quot;).raw() &lt;&lt; &quot;disker&quot; &lt;&lt; DiskerId &lt;&lt; endKv;
</I>

&gt;<i> This relies on chaining
</I>
The above illustrates ostream usage for atomic value assembly. Chaining
is a separate issue. The above can be trivially rewritten if chaining is
not supported. We can also remove convenience manipulators if we decide
they are bad for some reason:

  page.beginKv(&quot;statistics_foo&quot;);
  page.raw() &lt;&lt; something.mean();
  page.endKv();
  ...



&gt;<i> * It is reasonable to expect that worker_id has different syntax for
</I>&gt;<i> string and numeric representations in one of the syntaxes added later.
</I>
I am happy to assume that for the sake of the argument.


&gt;<i> That would call for multiple kvPair(name, value) methods based on the
</I>&gt;<i> value received here by the &lt;&lt; operator.
</I>
I think that is more likely to call for a multiple value wrapping
methods. It is not related to the &quot;key&quot; part of &quot;kv&quot;.

This is not an argument against chaining or for banning ostream access
AFAICT. To address multiple value types, we will add
Page::beginValueFoo() and valueBar(...) methods and alike.


&gt;<i> * With indentation in the syntax (both current and YAML) the
</I>&gt;<i> &quot;something.mean()&quot; output needs a specific prefix applied at the start
</I>&gt;<i> of each of its lines.
</I>
The mean() method returns a double (an average value over some sample).
Sorry if that was not clear from the example.

beginKv(key) should provide any necessary value prefixes, of course (at
least until we need value-type-specific wrappers).


&gt;<i> In both those circumstances it is better to pass 'page' to mean() and
</I>&gt;<i> ensure that sub-pieces of something.mean(page) are individually prefixed
</I>&gt;<i> and syntaxed by page with correct bits according to its internal state.
</I>
Sorry, but passing Page to a statistics function returning a mean value
of some sample does not make sense to me. There is no need to expose
statistics code to these formatting issues.

However, let's assume a more complicated example where we are not
dumping a simple double value but something more complex that really
needs to be exposed to Page. How does that more complex code dump a
simple double value keyed to some name? Using the same begin/endKey()
pair with a &quot;&lt;&lt;&quot; operator as illustrated by the above example.


&gt;<i> Also, the bits between &lt;&lt; are now free-flow outputs again. Thats a sure
</I>&gt;<i> recipe for some report to make an assumption like you do in the example
</I>&gt;<i> code itself (with &quot;disker&quot; assuming a string ID). That a particular kv
</I>&gt;<i> thing is going to take a string rather than an integer value.
</I>
The ostream part of the interface is reserved for assembly of atomic
values. You argue that it is _possible_ to misuse it for non-atomic
values. That statement is true for any interface!

Regardless of the interface you provide, it is possible to use it
incorrectly. For example, if your interface only accepts string values,
it is possible to incorrectly pass it a non-atomic &quot;foo: bar&quot; value. In
fact, with a string-only API, it may be arguably harder for reviewers to
spot that mistake because no &quot;&lt;&lt;&quot; operator or .raw() call will attract
their attention.


&gt;&gt;<i> Needless to say, there is some danger in providing such raw access. If a
</I>&gt;&gt;<i> developer is not careful, they might introduce a syntax error inside
</I>&gt;&gt;<i> what they saw were perfectly fine atomic values. We can protect against
</I>&gt;&gt;<i> that and offer automatic escaping of bad characters (among other
</I>&gt;&gt;<i> things), but that would require more work. I suspect such protections
</I>&gt;&gt;<i> would not necessarily require Page interface changes; if I am right, we
</I>&gt;&gt;<i> can delay their implementation until it is clear they are actually needed.
</I>

&gt;<i> I don't think that is necessary though. So I am leaving it out of these
</I>&gt;<i> early patches. Okay?
</I>
Pronouns &quot;that&quot; and &quot;it&quot; below a 7-line paragraph make it difficult for
me to guess what exactly you are leaving out. Not adding extra layer of
value protection/wrapping (for now) is the right approach. Using
string-based interfaces for string values is fine. Avoiding ostream
interfaces where they help (or introducing barriers to their future
addition) is not a good idea.


&gt;<i> The current free-form outputs already place indentation requirements the
</I>&gt;<i> mixed methods + ostream Page API cannot meet. Its either ostream with
</I>&gt;<i> Action::dump() doing the indentation explicitly, or just the
</I>&gt;<i> Page/Formatter methods.
</I>&gt;<i> 
</I>&gt;<i> YAML adds extra construct syntax requirements that make it even more
</I>&gt;<i> nasty. Then any potential binary outputs we want to generate later will
</I>&gt;<i> die horribly.
</I>
Any format has atomic values. Ostream is the right interface for
assembling those atomic values, especially where everything has to
eventually go into a StoreEntry-backed stream or alike. There is no
reason to avoid ostream where it is useful.

Please note that I am not saying that everything has to be formatted
using ostream. It is just an optional part of the interface, used where
it is helpful, ignored where it is not.


&gt;&gt;&gt;<i> What I'm not getting is why you insist this ostream API be exposed and
</I>&gt;&gt;&gt;<i> used by Action now but that PackableStream was inappropriate when it
</I>&gt;&gt;&gt;<i> could simply have had new members added and been identical to your
</I>&gt;&gt;&gt;<i> proposed Formatter.
</I>
&gt;&gt;<i> First of all, the first patch I was reviewing did not pass
</I>&gt;&gt;<i> PackableStream to Actions. It passed ostream. We cannot add methods to
</I>&gt;&gt;<i> ostream.
</I>
&gt;<i> It is not passed to Actions. Its created by Action and passed to
</I>&gt;<i> Action::dump() and action sub-code.
</I>
Yes, &quot;passed to Action::dump()&quot; is what I meant by &quot;passed to Actions&quot;.

You asserted that PackableStream &quot;could simply have had new members
added&quot;. That assertion did not apply to your patch because
PackableStream was not passed to Action::dump() where those methods were
needed. You passed ostream instead. We cannot add methods to ostream.


&gt;&gt;<i> Second, adding formal-syntax formatting methods to PackableStream (and
</I>&gt;&gt;<i> passing PackableStream to Actions) would be wrong. The PackableStream
</I>&gt;&gt;<i> class should be dedicated to providing a Packable-backed ostream. It
</I>&gt;&gt;<i> should not know anything about Cache Manager reports and their
</I>&gt;&gt;<i> formatting. We may use PackableStream outside Cache Manager.
</I>

&gt;<i> Its only uses were as an output serializer (formatter) for Action dump()
</I>&gt;<i> code. The slightly higher-order syntax of what the fields were was being
</I>&gt;<i> left in Action::dump() and related functions where it is in current trunk.
</I>&gt;<i> 
</I>&gt;<i> We agreed to use Page/Formatter to allow markup injection between fields
</I>&gt;<i> now, so re-coding was not necessary later.
</I>
I answered your &quot;why&quot; question with two specific reasons/explanations.
It feels like you are now arguing about something else. I do not know
what you are arguing about.


&gt;<i> In either model Action::dump is still responsible for knowledge of what
</I>&gt;<i> field types are being output. Either in the Page/Formatter methods its
</I>&gt;<i> calling, or the particular stream &lt;&lt; sequencing.
</I>
I do not know which two models you are talking about, but yes, the new
Action::dump2 would know about payload/page/report structure in
virtually any reasonable implementation.


&gt;<i> As I mentioned above exposing operator&lt;&lt; to Action just means important
</I>&gt;<i> parts of the markup injection is not possible. 
</I>
That assertion does not compute for me: How can giving Action and
_additional_ and _optional_ tool make something impossible?!



&gt;&gt;<i> I hope that Page/Formatter does not need to know about Packable, just
</I>&gt;&gt;<i> ostream, but there may be some corner cases I am not aware of.
</I>

&gt;<i> If Formatter is allocating the PackableStream it would. But
</I>&gt;<i> PackableStream is an wholly inline thing for exactly that type of reason.
</I>

I do not know why Page/Formatter would need to allocate PackableStream.
Ideally, Page/Formatter should not know exactly where its output is
going. If possible, Page/Formatter should just accept ostream (or, if
really needed, PackableStream) from its caller/creator/configurator.



&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> +    // a comment
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> +    virtual void notice(const SBuf &amp;) = 0;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Let's try to define the purpose of this method more precisely so that we
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> know when it is being used [in]correctly.
</I>

&gt;&gt;<i> For example, the following are &quot;bad&quot; notices (Squid should not generate
</I>&gt;&gt;<i> them):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   uptime: 1 hour
</I>&gt;&gt;<i>   built with libecap v1.1
</I>&gt;&gt;<i>   reconfiguration finished in 5 seconds
</I>&gt;&gt;<i>   error: I/O error while responding to a cache manager request
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> and the following are &quot;good&quot; notices:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   reconfiguration finished
</I>&gt;&gt;<i>   unsupported action
</I>&gt;&gt;<i>   unknown cache manager output format
</I>

&gt;<i> I think we agree on intention. But neither have a good text for it yet.
</I>&gt;<i> 
</I>&gt;<i> It's that passing-on property we need to clearly state. I've used
</I>&gt;<i> &quot;display&quot; there since its variable by context and loose enough to cover
</I>&gt;<i> any type of that action.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> How about just a terse:
</I>&gt;<i> 
</I>&gt;<i> notice() - &quot;An informational text announcement. To be passed on instead
</I>&gt;<i> of ignored. Do not automatically parse the text.&quot;
</I>
We should not document what should not be ignored. &quot;Not ignoring&quot; is the
assumed default, of course. &quot;Passed on&quot; to what or to whom? If I am an
admin looking at the notice on my terminal, I do not need to pass it on
further. How about this:

notice(): Text containing potentially useful information for admins.
Expected to be treated as a single opaque string by automation tools.


BTW, if we want to make admins and support folks life easier, I would
actually add a notice ID as a notice parameter and require that all
notices with the same ID mean the same thing, regardless of the text
(which we may change). Without an explicit ID, the text itself
essentially becomes an ID, which makes it difficult to adjust it.


&gt;<i> comment() - &quot;An informational text comment. May be ignored or dropped.
</I>&gt;<i> Do not automatically parse the text.&quot;
</I>
This one is much easier, IMO (unless we disagree what this method should
be used for):

comment(): A comment as defined by the format syntax. Usually contains
information meant for developers. Expected to be discarded by automation
tools.



&gt;&gt;&gt;&gt;<i> Going forward, please do not use &quot;final&quot; unless really necessary. Treat
</I>&gt;&gt;&gt;&gt;<i> it like we treat &quot;throw()&quot; declarations.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> You mean spotted liberally around the new code in the form of a wrapper
</I>&gt;&gt;&gt;<i> keyword like Must() ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No, I mean avoided like the now-deprecated &quot;throw()&quot; exception
</I>&gt;&gt;<i> specification:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   <A HREF="http://en.cppreference.com/w/cpp/language/except_spec">http://en.cppreference.com/w/cpp/language/except_spec</A>
</I>&gt;&gt;<i>   <A HREF="http://www.gotw.ca/publications/mill22.htm">http://www.gotw.ca/publications/mill22.htm</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Proposed rule of thumb: If correct inheritance or overriding is
</I>&gt;&gt;<i> possible, do not use &quot;final&quot;, even if you do not see any good reasons to
</I>&gt;&gt;<i> inherit or override.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Aha. Though AFAIK correct inhertence is *always* possible in reasonable
</I>&gt;<i> code. So that is just a ban on &quot;final&quot;.
</I>
It depends on how you define &quot;correct&quot;. Some say[1] that there is no
_correct_ way to subclass std::vector, for example. Since this is just a
rule of thumb, I am not sure we need to make it more precise.

[1]
<A HREF="http://stackoverflow.com/questions/6806173/subclass-inherit-standard-containers">http://stackoverflow.com/questions/6806173/subclass-inherit-standard-containers</A>

In practice, I think it is used for low-level stuff that plays dirty
tricks with memory or devices. FWIW, STL implementation in GCC v4.8 has
about a dozen &quot;final&quot; classes and structures. All very low-level memory
allocation and shared pointers stuff AFAICT -- I do not claim to
understand exactly why those complex classes are final!

Here is one easy-to-understand example of where final would be useful:
<A HREF="https://akrzemi1.wordpress.com/2012/09/30/why-make-your-classes-final/">https://akrzemi1.wordpress.com/2012/09/30/why-make-your-classes-final/</A>


&gt;<i> As you saw my uses of it are kind of &quot;political&quot; in nature. To enforce
</I>&gt;<i> better code use and graceful deprecations of widely used things.
</I>
I do not think final should be used for graceful deprecation. Final
should not imply &quot;dying&quot; or &quot;soon to go away&quot;. And even if something is
planned to be removed, it may still make sense to subclass or override
it (all other alternatives can be worse than extending deprecated code).


Cheers,

Alex.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003083.html">[squid-dev] [PATCH] PayloadFormatter (was PackableStream)
</A></li>
	<LI>Next message: <A HREF="002963.html">[squid-dev] [PATCH] Ignore impossible SSL bumping actions, as intended and documented / bug 4237 fix
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3087">[ date ]</a>
              <a href="thread.html#3087">[ thread ]</a>
              <a href="subject.html#3087">[ subject ]</a>
              <a href="author.html#3087">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
