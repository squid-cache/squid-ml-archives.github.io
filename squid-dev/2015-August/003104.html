<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Coverity%28-inspired%29%20fixes%20part%20four%2C%0A%20HttpHeader%20refactor&In-Reply-To=%3CCA%2BY8hcOACnkyYJ-9yJSLe97xX5%3DfRtfaW%3D1%2B-rf3dOe9j9_4XQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003100.html">
   <LINK REL="Next"  HREF="003126.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Coverity%28-inspired%29%20fixes%20part%20four%2C%0A%20HttpHeader%20refactor&In-Reply-To=%3CCA%2BY8hcOACnkyYJ-9yJSLe97xX5%3DfRtfaW%3D1%2B-rf3dOe9j9_4XQ%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor">gkinkie at gmail.com
       </A><BR>
    <I>Fri Aug 21 17:31:48 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003100.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
        <LI>Next message: <A HREF="003126.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3104">[ date ]</a>
              <a href="thread.html#3104">[ thread ]</a>
              <a href="subject.html#3104">[ subject ]</a>
              <a href="author.html#3104">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Aug 21, 2015 at 6:39 PM, Alex Rousskov &lt;
<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:

&gt;<i> On 08/21/2015 04:37 AM, Kinkie wrote:
</I>&gt;<i>
</I>&gt;<i> &gt;   the attached patch does:
</I>&gt;<i>
</I>&gt;<i> ... a long list of mostly unrelated changes ...
</I>&gt;<i>
</I>&gt;<i> Sigh. Some of the patch changes are not necessary at all. Some are
</I>&gt;<i> useful. Some should be redone to minimize conflicts. Some are
</I>&gt;<i> performance optimizations that should be considered very carefully. It
</I>&gt;<i> would take too much time to sift through all of this and separate the
</I>&gt;<i> good from the bad, so we would have to accept pretty much all of them,
</I>&gt;<i> create a lot of conflicts, and probably miss bugs.
</I>&gt;<i>
</I>
Sorry about that.
To defend the code, I'll comment that this has been extensively build-,
polygraph- coadvisor- and run-tested. It's hard - if possible at all - to
cover all code paths, I've done my best to be very cautious.

Sometimes, changing a lot of code is necessary. There is no way around
&gt;<i> that. However, combining many unrelated changes, some of which change a
</I>&gt;<i> lot of code, and some of which are performance-sensitive or bug-prone,
</I>&gt;<i> is virtually never necessary.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; -        Tolower(name);
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -        if (strcmp(name, &quot;*&quot;) == 0) {
</I>&gt;<i> &gt; -            /* Can not handle &quot;Vary: *&quot; withtout ETag support */
</I>&gt;<i> &gt; -            safe_free(name);
</I>&gt;<i> &gt; +        SBuf name(item, ilen);
</I>&gt;<i> &gt; +        if (name.cmp(&quot;*&quot;,1) == 0) {
</I>&gt;<i> &gt;              vstr.clean();
</I>&gt;<i> &gt;              break;
</I>&gt;<i> &gt;          }
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -        strListAdd(&amp;vstr, name, ',');
</I>&gt;<i> &gt; +        name.toLower();
</I>&gt;<i>
</I>&gt;<i> Do you know why we need to convert header names to lowercase here? The
</I>&gt;<i> header names are not a part of some Store hash, right? This conversion
</I>&gt;<i> is expensive because most header names will be changed here, breaking
</I>&gt;<i> SBuf reuse. If you know the reason, let's add a comment since you are
</I>&gt;<i> changing this code anyway.
</I>&gt;<i>
</I>
(pseudo) code removing memory management was:
while (e = get_list_element()) {
   e = lowerCase(e)
   if (e == &quot;*&quot;) {
     abort_processing()
     break
   }
   vstr.append(e)
   //other stuff
}

new code is:
while (e = get_list_element()) {
  if (e == &quot;*&quot;) {
    abort_processing()
    break
  }
  e = lowerCase(e)
  vstr.append(e)
  //some other stuff as above
}

Since lowerCase(&quot;*&quot;) == &quot;*&quot;, I'd hope that the behavior is unchanged, if
anything it's a small optimization in a hopefully uncommon case (no change
in the common case)


&gt;<i>
</I>&gt;<i> &gt;     in src/http.cc:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     * please mark use of name.c_str() with &quot;XXX: performance regression,
</I>&gt;<i> &gt;     c_str() reallocates&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Actually, no in this case it doesn't unless ilen is exactly equal to one
</I>&gt;<i> &gt; of the MemBlob MemPool sizes (possible but unlikely, I estimate in the
</I>&gt;<i> &gt; 0.1% range).
</I>&gt;<i>
</I>&gt;<i> *If* we remove toLower(), then there will be other, very common cases
</I>&gt;<i> where c_str() will reallocate in this context, either right now or when
</I>&gt;<i> the surrounding code is optimized to be more SBuf-friendly. Without
</I>&gt;<i> toLower(), the &quot;name&quot; SBuf should be pointing in the middle of another
</I>&gt;<i> SBuf in most cases where name was already in lower case.
</I>&gt;<i>
</I>
in the general case, I agree. I also hope that by the time the general case
comes, we won't need this very specific c_str().
In this case:
SBuf is allocated, lower-cased (guaranteed in place due to single
reference) and then - if there's room which should be a statistically
common case - a ghost \0 is appended to ensure termination.

I would honor Amos request for an XXX. In that XXX, I would not use the

&gt;<i> word &quot;regression&quot; because this change may not make performance worse
</I>&gt;<i> than it was, but it is still bad code from performance point of view and
</I>&gt;<i> should eventually be changed/optimized. I would write something like:
</I>&gt;<i>
</I>&gt;<i>   // XXX: will reallocate if toLower() above is removed
</I>&gt;<i>
</I>
.. and strListGetItem will start emitting SBufs in place of (char*,
length).


&gt;<i>
</I>&gt;<i> &gt; -        if (strcmp(name, &quot;*&quot;) == 0) {
</I>&gt;<i> &gt; -            /* Can not handle &quot;Vary: *&quot; withtout ETag support */
</I>&gt;<i> &gt; -            safe_free(name);
</I>&gt;<i> &gt; +        SBuf name(item, ilen);
</I>&gt;<i> &gt; +        if (name.cmp(&quot;*&quot;,1) == 0) {
</I>&gt;<i>
</I>&gt;<i> AFAICT, the new code looks for names starting with &quot;*&quot;. The old code was
</I>&gt;<i> looking for &quot;*&quot; names.
</I>&gt;<i>
</I>
doh! you're right.


&gt;<i> &gt; -    while ((e = getEntry(&amp;pos))) {
</I>&gt;<i> &gt; -        if (e-&gt;id == id)
</I>&gt;<i> &gt; -            delAt(pos, count);
</I>&gt;<i> &gt; -    }
</I>&gt;<i> &gt; +    int sz_before = entries.size();
</I>&gt;<i> &gt; +    entries.erase(std::remove_if(entries.begin(), entries.end(),
</I>&gt;<i> &gt; +    [=](HttpHeaderEntry *e) { return e &amp;&amp; e-&gt;id == id; }),
</I>&gt;<i> &gt; +    entries.end());
</I>&gt;<i>
</I>&gt;<i> This change is a performance regression AFAICT: Unlike the old delAt(),
</I>&gt;<i> std::remove_if is very expensive for std::vector. Consider using
</I>&gt;<i> std::replace_if without .erasing instead.
</I>&gt;<i>
</I>
yes, it is a small regresson (from N to 2N
). Reimplemented using replace_if - readability goes a bit down the drain,
unfortunatley.


&gt;<i> &gt; +enum HdrKind {
</I>&gt;<i>
</I>&gt;<i> Use C++11 class enums for global enums, especially when such use does
</I>&gt;<i> not increase the amount of old code changes. In this specific case, it
</I>&gt;<i> does not AFAICT.
</I>&gt;<i>
</I>
Unfortunately it's not possible in ordeer to use it as a bit-field (I have
tried and the compiler refused)


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; -    for(HttpHeaderEntry *e : entries) {
</I>&gt;<i> &gt; +    for (HttpHeaderEntry *e : entries) {
</I>&gt;<i>
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -    return NULL;        /* not reached */
</I>&gt;<i> &gt; +    return nullptr;        /* not reached */
</I>&gt;<i>
</I>&gt;<i> &gt;      /* check mask first */
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt;      if (!CBIT_TEST(mask, id))
</I>&gt;<i> &gt;          return NULL;
</I>&gt;<i>
</I>&gt;<i> ...
</I>&gt;<i>
</I>&gt;<i> Avoid out of scope changes, especially whitespace changes and NULL
</I>&gt;<i> renaming.
</I>&gt;<i>
</I>
I can't check it before replying to this mail, but will fix before merge.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; +    assert(0);
</I>&gt;<i>
</I>&gt;<i> s/0/false/
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; +    int sz_before = entries.size();
</I>&gt;<i> &gt; +    entries.erase(std::remove_if(entries.begin(), entries.end(),
</I>&gt;<i> &gt; +    [=](HttpHeaderEntry *e) { return e &amp;&amp; e-&gt;id == id; }),
</I>&gt;<i> &gt; +    entries.end());
</I>&gt;<i> &gt; +    int count = entries.size() - sz_before;
</I>&gt;<i>
</I>&gt;<i> If you can make sz_before, *e, and/or count const, make them const.
</I>&gt;<i>
</I>
Have to use a side-effect in the predicate if I want to use replace_if.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; +        if (e != nullptr &amp;&amp; e-&gt;id == id)
</I>&gt;<i>
</I>&gt;<i> You can save a lot of ink by writing &quot;e&quot; instead of &quot;e != nullptr&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As always, please post patches with at least 20 context lines to
</I>&gt;<i> increase chances of reviewers spotting bugs.
</I>&gt;<i>
</I>
 New patch attached according to spec.
&quot;bzr send&quot; unfortunately doesn't allow to specify context to be added :(

Thank you!

-- 
    Francesco
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150821/d0d7e13e/attachment-0001.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150821/d0d7e13e/attachment-0001.html</A>&gt;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: coverity-fixes-4-v3.patch
Type: application/octet-stream
Size: 209809 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150821/d0d7e13e/attachment-0001.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150821/d0d7e13e/attachment-0001.obj</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003100.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
	<LI>Next message: <A HREF="003126.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3104">[ date ]</a>
              <a href="thread.html#3104">[ thread ]</a>
              <a href="subject.html#3104">[ subject ]</a>
              <a href="author.html#3104">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
