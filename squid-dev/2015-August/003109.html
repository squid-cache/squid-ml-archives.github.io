<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20renaming%20StoreEntryStream%20to%20PackableStream&In-Reply-To=%3C55D84C66.3060709%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003105.html">
   <LINK REL="Next"  HREF="003124.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20renaming%20StoreEntryStream%20to%20PackableStream&In-Reply-To=%3C55D84C66.3060709%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Aug 22 10:18:14 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003105.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
        <LI>Next message: <A HREF="003124.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3109">[ date ]</a>
              <a href="thread.html#3109">[ thread ]</a>
              <a href="subject.html#3109">[ subject ]</a>
              <a href="author.html#3109">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 22/08/2015 5:44 a.m., Alex Rousskov wrote:
&gt;<i> On 08/21/2015 04:38 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> So PackableStream is really just a rename of StoreEntryStream BUT with
</I>&gt;&gt;<i> some implicit new properties from the underlying type change:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * lack of Store.h dependency
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * ability to stream into a MemBuf if its creator desires that
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This patch demonstrates that by doing the upgrade in-place and re-typing
</I>&gt;&gt;<i> all StoreEntryStream objects.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It includes some extra polishing of the *StreamBuf logics to remove
</I>&gt;&gt;<i> styling and redundant code issues identified in the previous cycles of
</I>&gt;&gt;<i> discussion. But otherwise is essentially a drop-in replacement.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Thank you for making a well-scoped change. It makes finding problems a
</I>&gt;<i> lot easier.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    virtual int sync() override {
</I>&gt;&gt;<i>          std::streamsize pending(pptr() - pbase());
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -        if (pending)
</I>&gt;&gt;<i> -            theEntry-&gt;append(pbase(), pending);
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -        theEntry-&gt;flush();
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> +        lowAppend(pbase(), pending);
</I>&gt;&gt;<i>          return 0;
</I>&gt;&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> Patched sync() no longer flush()es the entry. This is a significant
</I>&gt;<i> undocumented change and,
</I>
&quot;ability to stream into a MemBuf&quot;. but I see what you mean.

&gt;<i> AFAICT, a major bug. If I am right (see below
</I>&gt;<i> for specifics), please consider adding a pure virtual Packable::flush()
</I>&gt;<i> method and calling that in the above code _regardless_ of the &quot;pending&quot;
</I>&gt;<i> value, just like the old code used to do.
</I>
That was intentional. Packable does not flush().

I think it is fixing a previous bug. The Action caller code using
StoreEntryStream is (still) using buffer() and flush() explicitly to
prevent lots of small N-byte writes to FD.

The flush() in StoreEntryStream was completely disabling buffer() state
despite that explicit use by Action. So the StreamBuf was *permenently*
disabling Actions intended use of buffer() at the first use of sync().


If we add flush() to the Packable API I believe we should add buffer()
and bool isBuffering() const; as well to prevent that type of thing
happening again in future.

BUT. I'm not seeing any current usefulness to it being part of Packable
API outside of keeping that previously hidden issue in StoreEntryStream.
Removing/fixing the permanence of the un-buffering breaks bug
compatibility too.

Do you see any solid reason why we actually would have to flush() a
Packable?


&gt;<i> 
</I>&gt;&gt;<i> +    PackableStream stream(*sentry);
</I>&gt;<i> ...
</I>&gt;&gt;<i>      stream.flush();
</I>&gt;<i> 
</I>&gt;<i> How would that flush() call reach &quot;sentry&quot; if PackableStreamBuf never
</I>&gt;<i> flushes its buf_?
</I>
stream flush() is not about flushing the sentry AFAIK. It is about
ensuring the stream state is all in the buffer memory.

flushing the sentry data to the FD is a separate event done by Action later.


&gt;<i> 
</I>&gt;&gt;<i> +        anEntry-&gt;lock(&quot;test&quot;);
</I>&gt;&gt;<i> +        PackableStream stream(*anEntry);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>          stream.setf(std::ios::fixed);
</I>&gt;&gt;<i>          stream &lt;&lt; 123456 &lt;&lt; std::setprecision(1) &lt;&lt; 77.7;
</I>&gt;&gt;<i>          stream &lt;&lt; &quot; some text&quot; &lt;&lt; std::setw(4) &lt;&lt; &quot;!&quot; &lt;&lt; '.';
</I>&gt;&gt;<i>          stream.flush();
</I>&gt;&gt;<i> -        // flushed at least once more
</I>&gt;&gt;<i> -        CPPUNIT_ASSERT(anEntry-&gt;_flush_calls &gt; preFlushCount);
</I>&gt;&gt;<i> +        CPPUNIT_ASSERT_EQUAL(String(&quot;12345677.7 some text   !.&quot;), anEntry-&gt;_appended_text);
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +        delete anEntry; // does the unlock()
</I>&gt;<i> 
</I>&gt;<i> Checking the appended text without checking that the entry was flushed
</I>&gt;<i> is not sufficient because the appended text does not know what store
</I>&gt;<i> entry sent to Store clients. It only shows what Store servers appended
</I>&gt;<i> to the entry.
</I>&gt;<i> 
</I>
This is a PackableStream API unit test. The stream flush() ensure the
text is in the entry memory. The unit test is testing that it got there
completely and correctly.


The entry flush() ensures the entry text reaches the recipient / store -
which may have pruned from the entry if it is a Transient-like store.
But all that is not relevant to Packable API.

This is why the flush accounting is removed from the test cases. We are
testing only PackableStream use of Packable API here, not extra
StoreEntry API behaviours.

The only relevance entry flush() has is after a buffer() to cleanup
StoreEntry internal state before its deletion. And buffer() is not being
used.

&gt;<i> 
</I>&gt;&gt;<i> +        anEntry-&gt;lock(&quot;test&quot;);
</I>&gt;&gt;<i> +        PackableStream stream(*anEntry);
</I>&gt;<i> ...
</I>&gt;&gt;<i> +        delete anEntry; // does the unlock()
</I>&gt;<i> 
</I>&gt;<i> This leads to a dangling reference in the &quot;stream&quot; object. Please
</I>&gt;<i> consider narrowing the &quot;stream&quot; scope so that it is destroyed before you
</I>&gt;<i> delete anEntry.
</I>
The alternatives lead to segfault accessing a raw-pointer that no longer
exists.


&gt;<i> 
</I>&gt;&gt;<i> +    PackableStreamBuf(Packable &amp;p) : buf_(p) {}
</I>&gt;<i> 
</I>&gt;<i> If you can make the ctor explicit, please do.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    PackableStream(Packable &amp;p) : std::ostream(0), theBuffer(p) {
</I>&gt;<i> 
</I>&gt;<i> Ditto.
</I>&gt;<i> 
</I>
I thought explicit was relevant to raw-ptr ctor where NULL/0 casting had
integer related problems. Not for references with type checking.

Done for both anyway.

&gt;<i> 
</I>&gt;&gt;<i> +    ~PackableStreamBuf() = default;
</I>&gt;<i> 
</I>&gt;<i> I would remove that for simplicity and consistency sake.
</I>&gt;<i> 
</I>&gt;<i> Rule of thumb: Given a set of method kinds that can be marked as default
</I>&gt;<i> or can be explicitly deleted (i.e., copy constructor, destructor,
</I>&gt;<i> assignment operator, etc.), we should either explicitly declare all such
</I>&gt;<i> methods or none at all. None is the right choice when we do not _need_
</I>&gt;<i> to redefine any default methods or explicitly delete any methods.
</I>&gt;<i> 
</I>&gt;<i> The &quot;none&quot; choice applies to both PackableStreamBuf and PackableStream.
</I>
Okay. Done.

Amos

</PRE>
























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003105.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
	<LI>Next message: <A HREF="003124.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3109">[ date ]</a>
              <a href="thread.html#3109">[ thread ]</a>
              <a href="subject.html#3109">[ subject ]</a>
              <a href="author.html#3109">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
