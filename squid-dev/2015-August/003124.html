<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20renaming%20StoreEntryStream%20to%20PackableStream&In-Reply-To=%3C55D9FC27.6040605%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003109.html">
   <LINK REL="Next"  HREF="003128.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20renaming%20StoreEntryStream%20to%20PackableStream&In-Reply-To=%3C55D9FC27.6040605%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Aug 23 17:00:23 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003109.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
        <LI>Next message: <A HREF="003128.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3124">[ date ]</a>
              <a href="thread.html#3124">[ thread ]</a>
              <a href="subject.html#3124">[ subject ]</a>
              <a href="author.html#3124">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/22/2015 04:18 AM, Amos Jeffries wrote:
&gt;<i> On 22/08/2015 5:44 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 08/21/2015 04:38 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> So PackableStream is really just a rename of StoreEntryStream BUT with
</I>&gt;&gt;&gt;<i> some implicit new properties from the underlying type change:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * lack of Store.h dependency
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * ability to stream into a MemBuf if its creator desires that
</I>

&gt;<i> Packable does not flush().
</I>
Any streambuf, including Packable, must either:

A) support on-demand flushing or
B) flush on each append (essentially making on-demand flushing a no-op)

Since the scope of your changes is StoreEntryStream renaming, and
StoreEntryStream supports (A), (A) is the correct choice for your patch.
There are other reasons why (A) may be better, but keeping changes in
scope should be sufficient.

Packable kids may have kid-specific flush() implementation, of course.
However, within your patch scope, StoreEntry (one of the existing
Packable kids) implementation of flush() should remain unchanged.


&gt;<i> I think it is fixing a previous bug. The Action caller code using
</I>&gt;<i> StoreEntryStream is (still) using buffer() and flush() explicitly to
</I>&gt;<i> prevent lots of small N-byte writes to FD.
</I>&gt;<i> 
</I>&gt;<i> The flush() in StoreEntryStream was completely disabling buffer() state
</I>&gt;<i> despite that explicit use by Action. So the StreamBuf was *permenently*
</I>&gt;<i> disabling Actions intended use of buffer() at the first use of sync().
</I>
We can discuss how to fix/improve/optimize this, but it is a complicated
discussion. Complicated fixes/improvements/optimizations are outside
your patch scope. If you think they are important to do soon, let's
discuss them after this email thread is closed.


&gt;<i> If we add flush() to the Packable API I believe we should add buffer()
</I>&gt;<i> and bool isBuffering() const; as well to prevent that type of thing
</I>&gt;<i> happening again in future.
</I>
Let's discuss how to optimize the use of flushing after PackableStream
(with flushing support matching current trunk code) is committed.


&gt;<i> BUT. I'm not seeing any current usefulness to it being part of Packable
</I>&gt;<i> API outside of keeping that previously hidden issue in StoreEntryStream.
</I>&gt;<i> Removing/fixing the permanence of the un-buffering breaks bug
</I>&gt;<i> compatibility too.
</I>
&gt;<i> Do you see any solid reason why we actually would have to flush() a
</I>&gt;<i> Packable?
</I>
There are several, but here is a brief summary of the most important
one: Changing how flushing works, what it means, or when it is used is a
complicated decision outside your patch scope.



&gt;&gt;&gt;<i> +    PackableStream stream(*sentry);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i>      stream.flush();
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> How would that flush() call reach &quot;sentry&quot; if PackableStreamBuf never
</I>&gt;&gt;<i> flushes its buf_?
</I>
&gt;<i> stream flush() is not about flushing the sentry AFAIK.
</I>
It had that effect before your changes AFAIK.


&gt;<i> It is about ensuring the stream state is all in the buffer memory.
</I>
ostream::flush() ensures that previously appended characters get to the
so called &quot;controlled sequence&quot;. We can define what &quot;controlled
sequence&quot; is, but REdefining controlled sequence is a complicated
decision outside your patch scope. The current definition should be
preserved, which requires flush()ing in sync() and propagating that
flush() call to StoreEntry when Packable controls StoreEntry.


&gt;&gt;&gt;<i> +        anEntry-&gt;lock(&quot;test&quot;);
</I>&gt;&gt;&gt;<i> +        PackableStream stream(*anEntry);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +        delete anEntry; // does the unlock()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This leads to a dangling reference in the &quot;stream&quot; object. Please
</I>&gt;&gt;<i> consider narrowing the &quot;stream&quot; scope so that it is destroyed before you
</I>&gt;&gt;<i> delete anEntry.
</I>&gt;<i> 
</I>&gt;<i> The alternatives lead to segfault accessing a raw-pointer that no longer
</I>&gt;<i> exists.
</I>
Regardless of the specific problems of specific solutions, the patch
needs to be fixed to avoid dangling pointers.

FWIW, I do not see how destroying the stream object earlier would result
in a dangling pointer access, but perhaps I am missing something or you
are discussing some other alternative. These details are not important
as long as the patch is fixed.


&gt;<i> I thought explicit was relevant to raw-ptr ctor where NULL/0 casting had
</I>&gt;<i> integer related problems. Not for references with type checking.
</I>
The &quot;explicit&quot; mark is relevant to all single-parameter constructors
because without that marking, they essentially become implicit type
conversion operators (e.g., converting from Packable to
PackableStreamBuf or from StoreEntry to PackableStream).

Alex.

</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003109.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
	<LI>Next message: <A HREF="003128.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3124">[ date ]</a>
              <a href="thread.html#3124">[ thread ]</a>
              <a href="subject.html#3124">[ subject ]</a>
              <a href="author.html#3124">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
