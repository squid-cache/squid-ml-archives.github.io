<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20renaming%20StoreEntryStream%20to%20PackableStream&In-Reply-To=%3C55DA22A5.1050104%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003124.html">
   <LINK REL="Next"  HREF="003285.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20renaming%20StoreEntryStream%20to%20PackableStream&In-Reply-To=%3C55DA22A5.1050104%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Aug 23 19:44:37 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003124.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
        <LI>Next message: <A HREF="003285.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3128">[ date ]</a>
              <a href="thread.html#3128">[ thread ]</a>
              <a href="subject.html#3128">[ subject ]</a>
              <a href="author.html#3128">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Okay. Added the flushing but left the existing StoreEntry logic bug in
place.

Also re-added the flush/buffer unit testing since that is now Packable
API relevant.

Everything that auditor script you posted complains about now is
intentional whitespace polish.


In the side topic of Big3 rules this streambuf child is a good edge case
where virtual destructor for the streambuf needs to be declared, but can
be default. Which would make all Big3 =default operators.

By the reasoning behind your proposed rules does this virtual destructor
mean the copy and assignment need to be defined with =default as well?
 or omitted like this is fine?

Amos

-------------- next part --------------
=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-08-03 03:50:25 +0000
+++ src/Makefile.am	2015-08-19 15:28:32 +0000
@@ -504,41 +504,40 @@
 
 EXTRA_squid_SOURCES = \
 	$(all_AUTHMODULES) \
 	ConfigOption.h \
 	$(DELAY_POOL_ALL_SOURCE) \
 	htcp.cc \
 	htcp.h \
 	ipc.cc \
 	ipc_win32.cc \
 	ProfStats.cc \
 	LeakFinder.cc \
 	LeakFinder.h \
 	$(SNMP_ALL_SOURCE) \
 	$(UNLINKDSOURCE) \
 	$(WIN32_ALL_SOURCE) \
 	$(LOADABLE_MODULES_SOURCES)
 
 noinst_HEADERS = \
 	client_side_request.cci \
 	MemBuf.h \
-	StoreEntryStream.h \
 	String.cci \
 	SquidString.h \
 	SquidTime.h
 
 BUILT_SOURCES = \
 	cf_gen_defines.cci \
 	cf_parser.cci \
 	err_type.cc \
 	err_detail_type.cc \
 	globals.cc \
 	hier_code.cc \
 	icp_opcode.cc \
 	lookup_t.cc \
 	repl_modules.cc \
 	swap_log_op.cc
 
 CLEANFILES += $(BUILT_SOURCES)
 
 nodist_squid_SOURCES = \
 	$(BUILT_SOURCES)
@@ -2849,44 +2848,44 @@
 	tests/stub_libsslsquid.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	tests/stub_HttpReply.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_libcomm.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
 	tests/stub_Port.cc \
 	tests/stub_stat.cc \
 	tests/stub_store_client.cc \
 	tests/stub_store_stats.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_swapout.cc \
 	tools.h \
 	Transients.cc \
 	tests/stub_tools.cc \
 	tests/stub_UdsOp.cc \
+	tests/testPackableStream.cc \
+	tests/testPackableStream.h \
 	tests/testStore.cc \
 	tests/testStore.h \
-	tests/testStoreEntryStream.cc \
-	tests/testStoreEntryStream.h \
 	tests/testStoreController.cc \
 	tests/testStoreController.h \
 	tests/testStoreHashIndex.cc \
 	tests/testStoreHashIndex.h \
 	tests/testStoreSupport.cc \
 	tests/testStoreSupport.h \
 	tests/TestSwapDir.cc \
 	tests/TestSwapDir.h \
 	tests/stub_time.cc \
 	url.cc \
 	wordlist.h \
 	wordlist.cc
 
 nodist_tests_testStore_SOURCES= \
 	$(TESTSOURCES) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 
 tests_testStore_LDADD= \

=== modified file 'src/SBufStatsAction.cc'
--- src/SBufStatsAction.cc	2015-03-19 12:12:08 +0000
+++ src/SBufStatsAction.cc	2015-08-19 15:16:42 +0000
@@ -1,76 +1,76 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
+#include &quot;base/PackableStream.h&quot;
 #include &quot;ipc/Messages.h&quot;
 #include &quot;ipc/TypedMsgHdr.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;SBufDetailedStats.h&quot;
 #include &quot;SBufStatsAction.h&quot;
-#include &quot;StoreEntryStream.h&quot;
 
 SBufStatsAction::SBufStatsAction(const Mgr::CommandPointer &amp;cmd_):
     Action(cmd_)
 { } //default constructor is OK for data member
 
 SBufStatsAction::Pointer
 SBufStatsAction::Create(const Mgr::CommandPointer &amp;cmd)
 {
     return new SBufStatsAction(cmd);
 }
 
 void
 SBufStatsAction::add(const Mgr::Action&amp; action)
 {
     sbdata += dynamic_cast&lt;const SBufStatsAction&amp;&gt;(action).sbdata;
     mbdata += dynamic_cast&lt;const SBufStatsAction&amp;&gt;(action).mbdata;
     sbsizesatdestruct += dynamic_cast&lt;const SBufStatsAction&amp;&gt;(action).sbsizesatdestruct;
     mbsizesatdestruct += dynamic_cast&lt;const SBufStatsAction&amp;&gt;(action).mbsizesatdestruct;
 }
 
 void
 SBufStatsAction::collect()
 {
     sbdata = SBuf::GetStats();
     mbdata = MemBlob::GetStats();
     sbsizesatdestruct = *collectSBufDestructTimeStats();
     mbsizesatdestruct = *collectMemBlobDestructTimeStats();
 }
 
 static void
 statHistSBufDumper(StoreEntry * sentry, int, double val, double size, int count)
 {
     if (count == 0)
         return;
     storeAppendPrintf(sentry, &quot;\t%d-%d\t%d\n&quot;, static_cast&lt;int&gt;(val), static_cast&lt;int&gt;(val+size), count);
 }
 
 void
 SBufStatsAction::dump(StoreEntry* entry)
 {
-    StoreEntryStream ses(entry);
+    PackableStream ses(*entry);
     ses &lt;&lt; &quot;\n\n\nThese statistics are experimental; their format and contents &quot;
         &quot;should not be relied upon, they are bound to change as &quot;
         &quot;the SBuf feature is evolved\n&quot;;
     sbdata.dump(ses);
     mbdata.dump(ses);
     ses &lt;&lt; &quot;\n&quot;;
     ses &lt;&lt; &quot;SBuf size distribution at destruct time:\n&quot;;
     sbsizesatdestruct.dump(entry,statHistSBufDumper);
     ses &lt;&lt; &quot;MemBlob capacity distribution at destruct time:\n&quot;;
     mbsizesatdestruct.dump(entry,statHistSBufDumper);
 }
 
 void
 SBufStatsAction::pack(Ipc::TypedMsgHdr&amp; msg) const
 {
     msg.setType(Ipc::mtCacheMgrResponse);
     msg.putPod(sbdata);
     msg.putPod(mbdata);
 }
 

=== modified file 'src/Store.h'
--- src/Store.h	2015-05-25 14:02:29 +0000
+++ src/Store.h	2015-08-23 17:30:14 +0000
@@ -165,73 +165,71 @@
 
     swap_status_t swap_status:3;
 
 public:
     static size_t inUseCount();
     static void getPublicByRequestMethod(StoreClient * aClient, HttpRequest * request, const HttpRequestMethod&amp; method);
     static void getPublicByRequest(StoreClient * aClient, HttpRequest * request);
     static void getPublic(StoreClient * aClient, const char *uri, const HttpRequestMethod&amp; method);
 
     virtual bool isNull() {
         return false;
     };
 
     void *operator new(size_t byteCount);
     void operator delete(void *address);
     void setReleaseFlag();
 #if USE_SQUID_ESI
 
     ESIElement::Pointer cachedESITree;
 #endif
-    /** disable sending content to the clients */
-    virtual void buffer();
-    /** flush any buffered content */
-    virtual void flush();
     virtual int64_t objectLen() const;
     virtual int64_t contentLen() const;
 
     /// claim shared ownership of this entry (for use in a given context)
     /// matching lock() and unlock() contexts eases leak triage but is optional
     void lock(const char *context);
 
     /// disclaim shared ownership; may remove entry from store and delete it
     /// returns remaning lock level (zero for unlocked and possibly gone entry)
     int unlock(const char *context);
 
     /// returns a local concurrent use counter, for debugging
     int locks() const { return static_cast&lt;int&gt;(lock_count); }
 
     /// update last reference timestamp and related Store metadata
     void touch();
 
     virtual void release();
 
 #if USE_ADAPTATION
     /// call back producer when more buffer space is available
     void deferProducer(const AsyncCall::Pointer &amp;producer);
     /// calls back producer registered with deferProducer
     void kickProducer();
 #endif
 
     /* Packable API */
     virtual void append(char const *, int);
     virtual void vappendf(const char *, va_list);
+    virtual void buffer();
+    virtual void flush();
 
 protected:
     void transientsAbandonmentCheck();
 
 private:
     bool checkTooBig() const;
 
     static MemAllocator *pool;
 
     unsigned short lock_count;      /* Assume &lt; 65536! */
 
 #if USE_ADAPTATION
     /// producer callback registered with deferProducer
     AsyncCall::Pointer deferredProducer;
 #endif
 
     bool validLength() const;
     bool hasOneOfEtags(const String &amp;reqETags, const bool allowWeakMatch) const;
 };
 

=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2015-08-03 02:08:22 +0000
+++ src/base/Makefile.am	2015-08-19 15:08:32 +0000
@@ -11,28 +11,29 @@
 noinst_LTLIBRARIES = libbase.la
 
 libbase_la_SOURCES = \
 	AsyncCall.cc \
 	AsyncCall.h \
 	AsyncCbdataCalls.h \
 	AsyncJob.h \
 	AsyncJob.cc \
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
 	CbcPointer.h \
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
 	LruMap.h \
 	Packable.h \
+	PackableStream.h \
 	RegexPattern.cc \
 	RegexPattern.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
 	TidyPointer.h

=== modified file 'src/base/Packable.h'
--- src/base/Packable.h	2015-08-11 05:35:08 +0000
+++ src/base/Packable.h	2015-08-23 17:34:05 +0000
@@ -52,24 +52,39 @@
     virtual ~Packable() {}
 
     /// Appends a c-string to existing packed data.
     virtual void append(const char *buf, int size) = 0;
 
     /// Append operation with printf-style arguments.
     void appendf(const char *fmt,...) PRINTF_FORMAT_ARG2
     {
         va_list args;
         va_start(args, fmt);
         vappendf(fmt, args);
         va_end(args);
     }
 
     /** Append operation, with vsprintf(3)-style arguments.
      *
      * \note arguments may be evaluated more than once, be careful
      *       of side-effects
      */
     virtual void vappendf(const char *fmt, va_list ap) = 0;
+
+    /** start buffering appends (if relevant)
+     *
+     * Indicates that a number of small appends are about to
+     * follow so would be detrimental to trigger expensive
+     * activity on each.
+     */
+    virtual void buffer() {}
+
+    /** perform a buffer flush (if relevant)
+     *
+     * Used by code such as PackableStream, that assumes the
+     * Packable leads to some form of output buffer.
+     */
+    virtual void flush() {}
 };
 
 #endif /* SQUID_SRC_BASE_PACKABLE_H */
 

=== renamed file 'src/StoreEntryStream.h' =&gt; 'src/base/PackableStream.h'
--- src/StoreEntryStream.h	2015-01-13 07:25:36 +0000
+++ src/base/PackableStream.h	2015-08-23 19:34:45 +0000
@@ -1,102 +1,82 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_STORE_ENTRY_STREAM_H
-#define SQUID_STORE_ENTRY_STREAM_H
+#ifndef SQUID_SRC_BASE_PACKABLESTREAM_H
+#define SQUID_SRC_BASE_PACKABLESTREAM_H
 
-#include &quot;Store.h&quot;
+#include &quot;base/Packable.h&quot;
 
 #include &lt;ostream&gt;
 
-/*
- * This class provides a streambuf interface for writing
- * to StoreEntries. Typical use is via a StoreEntryStream
- * rather than direct manipulation
+/**
+ * Provides a streambuf interface for writing to Packable objects.
+ * Typical use is via a PackableStream rather than direct manipulation
  */
-
-class StoreEntryStreamBuf : public std::streambuf
+class PackableStreamBuf : public std::streambuf
 {
-
 public:
-    StoreEntryStreamBuf(StoreEntry *anEntry) : theEntry(anEntry) {
-        theEntry-&gt;lock(&quot;StoreEntryStreamBuf&quot;);
-        theEntry-&gt;buffer();
-    }
-
-    ~StoreEntryStreamBuf() {
-        theEntry-&gt;unlock(&quot;StoreEntryStreamBuf&quot;);
-    }
+    explicit PackableStreamBuf(Packable &amp;p) : buf_(p) { buf_.buffer(); }
+    virtual ~PackableStreamBuf() = default;
 
 protected:
-    /* flush the current buffer and the character that is overflowing
-     * to the store entry.
+    /** flush the current buffer and the character that is overflowing
+     * to the Packable.
      */
-    virtual int_type overflow(int_type aChar = traits_type::eof()) {
+    virtual int_type overflow(int_type aChar = traits_type::eof()) override {
         std::streamsize pending(pptr() - pbase());
 
-        if (pending &amp;&amp; sync ())
+        if (pending &amp;&amp; sync())
             return traits_type::eof();
 
         if (aChar != traits_type::eof()) {
-            // NP: cast because GCC promotes int_type to 32-bit type
-            //     std::basic_streambuf&lt;char&gt;::int_type {aka int}
-            //     despite the definition with 8-bit type value.
-            char chars[1] = {char(aChar)};
-
-            if (aChar != traits_type::eof())
-                theEntry-&gt;append(chars, 1);
+            const char C = static_cast&lt;char&gt;(aChar);
+            lowAppend(&amp;C, 1);
         }
 
-        pbump (-pending);  // Reset pptr().
+        pbump(-pending);  // Reset pptr().
         return aChar;
     }
 
-    /* push the buffer to the store */
-    virtual int sync() {
+    /** push the buffer to the Packable */
+    virtual int sync() override {
         std::streamsize pending(pptr() - pbase());
-
-        if (pending)
-            theEntry-&gt;append(pbase(), pending);
-
-        theEntry-&gt;flush();
-
+        lowAppend(pbase(), pending);
+        buf_.flush();
         return 0;
     }
 
-    /* write multiple characters to the store entry
+    /** write multiple characters to the Packable
      * - this is an optimisation method.
      */
-    virtual std::streamsize xsputn(const char * chars, std::streamsize number) {
-        if (number)
-            theEntry-&gt;append(chars, number);
-
+    virtual std::streamsize xsputn(const char * chars, std::streamsize number) override {
+        lowAppend(chars, number);
         return number;
     }
 
 private:
-    StoreEntry *theEntry;
+    void lowAppend(const char *s, const std::streamsize n) {buf_.append(s,n);}
 
+    Packable &amp;buf_;
 };
 
-class StoreEntryStream : public std::ostream
+class PackableStream : public std::ostream
 {
-
 public:
-    /* create a stream for writing text etc into theEntry */
+    /* create a stream for writing text etc into theBuffer */
     // See <A HREF="http://www.codecomments.com/archive292-2005-2-396222.html">http://www.codecomments.com/archive292-2005-2-396222.html</A>
-    StoreEntryStream(StoreEntry *entry): std::ostream(0), theBuffer(entry) {
+    explicit PackableStream(Packable &amp;p) : std::ostream(0), theBuffer(p) {
         rdbuf(&amp;theBuffer); // set the buffer to now-initialized theBuffer
         clear(); //clear badbit set by calling init(0)
     }
 
 private:
-    StoreEntryStreamBuf theBuffer;
+    PackableStreamBuf theBuffer;
 };
 
-#endif /* SQUID_STORE_ENTRY_STREAM_H */
+#endif /* SQUID_SRC_BASE_PACKABLESTREAM_H */
 

=== modified file 'src/mem/old_api.cc'
--- src/mem/old_api.cc	2015-07-27 05:21:06 +0000
+++ src/mem/old_api.cc	2015-08-19 15:17:20 +0000
@@ -1,53 +1,52 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 13    High Level Memory Pool Management */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/AclDenyInfoList.h&quot;
 #include &quot;acl/AclNameList.h&quot;
+#include &quot;base/PackableStream.h&quot;
 #include &quot;CacheDigest.h&quot;
 #include &quot;ClientInfo.h&quot;
 #include &quot;disk.h&quot;
 #include &quot;dlink.h&quot;
 #include &quot;event.h&quot;
 #include &quot;icmp/net_db.h&quot;
 #include &quot;md5.h&quot;
 #include &quot;mem/forward.h&quot;
 #include &quot;mem/Pool.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;memMeter.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidList.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
-#include &quot;StoreEntryStream.h&quot;
 
 #include &lt;iomanip&gt;
-#include &lt;ostream&gt;
 
 /* forward declarations */
 static void memFree2K(void *);
 static void memFree4K(void *);
 static void memFree8K(void *);
 static void memFree16K(void *);
 static void memFree32K(void *);
 static void memFree64K(void *);
 
 /* module globals */
 const size_t squidSystemPageSize=getpagesize();
 
 /* local prototypes */
 static void memStringStats(std::ostream &amp;);
 
 /* module locals */
 static MemAllocator *MemPools[MEM_MAX];
 static double xm_time = 0;
 static double xm_deltat = 0;
 
@@ -126,41 +125,41 @@
     stream &lt;&lt; std::setw(20) &lt;&lt; std::left &lt;&lt; &quot;Other Strings&quot;;
 
     stream &lt;&lt; std::right &lt;&lt; &quot;\t &quot;;
 
     stream &lt;&lt; xpercentInt(StrCountMeter.level - pooled_count, StrCountMeter.level) &lt;&lt; &quot;\t &quot;;
 
     stream &lt;&lt; xpercentInt(StrVolumeMeter.level - pooled_volume, StrVolumeMeter.level) &lt;&lt; &quot;\n\n&quot;;
 }
 
 static void
 memBufStats(std::ostream &amp; stream)
 {
     stream &lt;&lt; &quot;Large buffers: &quot; &lt;&lt;
            HugeBufCountMeter.level &lt;&lt; &quot; (&quot; &lt;&lt;
            HugeBufVolumeMeter.level / 1024 &lt;&lt; &quot; KB)\n&quot;;
 }
 
 void
 Mem::Stats(StoreEntry * sentry)
 {
-    StoreEntryStream stream(sentry);
+    PackableStream stream(*sentry);
     Report(stream);
     memStringStats(stream);
     memBufStats(stream);
 #if WITH_VALGRIND
     if (RUNNING_ON_VALGRIND) {
         long int leaked = 0, dubious = 0, reachable = 0, suppressed = 0;
         stream &lt;&lt; &quot;Valgrind Report:\n&quot;;
         stream &lt;&lt; &quot;Type\tAmount\n&quot;;
         debugs(13, DBG_IMPORTANT, &quot;Asking valgrind for memleaks&quot;);
         VALGRIND_DO_LEAK_CHECK;
         debugs(13, DBG_IMPORTANT, &quot;Getting valgrind statistics&quot;);
         VALGRIND_COUNT_LEAKS(leaked, dubious, reachable, suppressed);
         stream &lt;&lt; &quot;Leaked\t&quot; &lt;&lt; leaked &lt;&lt; &quot;\n&quot;;
         stream &lt;&lt; &quot;Dubious\t&quot; &lt;&lt; dubious &lt;&lt; &quot;\n&quot;;
         stream &lt;&lt; &quot;Reachable\t&quot; &lt;&lt; reachable &lt;&lt; &quot;\n&quot;;
         stream &lt;&lt; &quot;Suppressed\t&quot; &lt;&lt; suppressed &lt;&lt; &quot;\n&quot;;
     }
 #endif
     stream.flush();
 }

=== modified file 'src/ssl/context_storage.cc'
--- src/ssl/context_storage.cc	2015-04-16 04:10:51 +0000
+++ src/ssl/context_storage.cc	2015-08-19 15:17:08 +0000
@@ -1,52 +1,52 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
+#include &quot;base/PackableStream.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;ssl/context_storage.h&quot;
 #include &quot;Store.h&quot;
-#include &quot;StoreEntryStream.h&quot;
 
 #include &lt;limits&gt;
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 
 Ssl::CertificateStorageAction::CertificateStorageAction(const Mgr::Command::Pointer &amp;aCmd)
     :   Mgr::Action(aCmd)
 {}
 
 Ssl::CertificateStorageAction::Pointer
 Ssl::CertificateStorageAction::Create(const Mgr::Command::Pointer &amp;aCmd)
 {
     return new CertificateStorageAction(aCmd);
 }
 
 void Ssl::CertificateStorageAction::dump (StoreEntry *sentry)
 {
-    StoreEntryStream stream(sentry);
+    PackableStream stream(*sentry);
     const char delimiter = '\t';
     const char endString = '\n';
     // Page title.
     stream &lt;&lt; &quot;Cached ssl certificates statistic.\n&quot;;
     // Title of statistic table.
     stream &lt;&lt; &quot;Port&quot; &lt;&lt; delimiter &lt;&lt; &quot;Max mem(KB)&quot; &lt;&lt; delimiter &lt;&lt; &quot;Cert number&quot; &lt;&lt; delimiter &lt;&lt; &quot;KB/cert&quot; &lt;&lt; delimiter &lt;&lt; &quot;Mem used(KB)&quot; &lt;&lt; delimiter &lt;&lt; &quot;Mem free(KB)&quot; &lt;&lt; endString;
 
     // Add info for each port.
     for (std::map&lt;Ip::Address, LocalContextStorage *&gt;::iterator i = TheGlobalContextStorage.storage.begin(); i != TheGlobalContextStorage.storage.end(); ++i) {
         stream &lt;&lt; i-&gt;first &lt;&lt; delimiter;
         LocalContextStorage &amp; ssl_store_policy(*(i-&gt;second));
         stream &lt;&lt; ssl_store_policy.memLimit() / 1024 &lt;&lt; delimiter;
         stream &lt;&lt; ssl_store_policy.entries() &lt;&lt; delimiter;
         stream &lt;&lt; SSL_CTX_SIZE / 1024 &lt;&lt; delimiter;
         stream &lt;&lt; ssl_store_policy.size() / 1024 &lt;&lt; delimiter;
         stream &lt;&lt; ssl_store_policy.freeMem() / 1024 &lt;&lt; endString;
     }
     stream &lt;&lt; endString;
     stream.flush();
 }

=== modified file 'src/store.cc'
--- src/store.cc	2015-08-04 19:57:07 +0000
+++ src/store.cc	2015-08-23 19:29:27 +0000
@@ -1733,48 +1733,55 @@
         return &quot;[null_mem_obj]&quot;;
     else
         return mem_obj-&gt;storeId();
 }
 
 MemObject *
 StoreEntry::makeMemObject()
 {
     if (!mem_obj)
         mem_obj = new MemObject();
     return mem_obj;
 }
 
 void
 StoreEntry::createMemObject(const char *aUrl, const char *aLogUrl, const HttpRequestMethod &amp;aMethod)
 {
     makeMemObject();
     mem_obj-&gt;setUris(aUrl, aLogUrl, aMethod);
 }
 
-/* this just sets DELAY_SENDING */
+/** disable sending content to the clients.
+ *
+ * This just sets DELAY_SENDING.
+ */
 void
 StoreEntry::buffer()
 {
     EBIT_SET(flags, DELAY_SENDING);
 }
 
-/* this just clears DELAY_SENDING and Invokes the handlers */
+/** flush any buffered content.
+ *
+ * This just clears DELAY_SENDING and Invokes the handlers
+ * to begin sending anything that may be buffered.
+ */
 void
 StoreEntry::flush()
 {
     if (EBIT_TEST(flags, DELAY_SENDING)) {
         EBIT_CLR(flags, DELAY_SENDING);
         invokeHandlers();
     }
 }
 
 int64_t
 StoreEntry::objectLen() const
 {
     assert(mem_obj != NULL);
     return mem_obj-&gt;object_sz;
 }
 
 int64_t
 StoreEntry::contentLen() const
 {
     assert(mem_obj != NULL);

=== renamed file 'src/tests/testStoreEntryStream.cc' =&gt; 'src/tests/testPackableStream.cc'
--- src/tests/testStoreEntryStream.cc	2015-01-13 07:25:36 +0000
+++ src/tests/testPackableStream.cc	2015-08-23 19:21:52 +0000
@@ -1,60 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
+#include &quot;base/PackableStream.h&quot;
 #include &quot;CapturingStoreEntry.h&quot;
 #include &quot;Store.h&quot;
-#include &quot;StoreEntryStream.h&quot;
 #include &quot;testStore.h&quot;
-#include &quot;testStoreEntryStream.h&quot;
+#include &quot;testPackableStream.h&quot;
 
 #include &lt;iomanip&gt;
 #include &lt;cppunit/TestAssert.h&gt;
 
-CPPUNIT_TEST_SUITE_REGISTRATION( testStoreEntryStream );
+CPPUNIT_TEST_SUITE_REGISTRATION( testPackableStream );
 
 /* init memory pools */
 
-void testStoreEntryStream::setUp()
+void testPackableStream::setUp()
 {
     Mem::Init();
 }
 
+// TODO: test streaming to a MemBuf as well.
+
 void
-testStoreEntryStream::testGetStream()
+testPackableStream::testGetStream()
 {
     /* Setup a store root so we can create a StoreEntry */
     StorePointer aStore (new TestStore);
     Store::Root(aStore);
 
     CapturingStoreEntry * anEntry = new CapturingStoreEntry();
     {
-        StoreEntryStream stream(anEntry); // locks and unlocks/deletes anEntry
+        anEntry-&gt;lock(&quot;test&quot;);
+        PackableStream stream(*anEntry);
         CPPUNIT_ASSERT_EQUAL(1, anEntry-&gt;_buffer_calls);
         CPPUNIT_ASSERT_EQUAL(0, anEntry-&gt;_flush_calls);
 
         stream.setf(std::ios::fixed);
         stream &lt;&lt; 123456 &lt;&lt; std::setprecision(1) &lt;&lt; 77.7;
         stream &lt;&lt; &quot; some text&quot; &lt;&lt; std::setw(4) &lt;&lt; &quot;!&quot; &lt;&lt; '.';
         CPPUNIT_ASSERT_EQUAL(1, anEntry-&gt;_buffer_calls);
 
         const int preFlushCount = anEntry-&gt;_flush_calls;
         // may have already flushed
         CPPUNIT_ASSERT(preFlushCount &gt;= 0);
         stream.flush();
         // flushed at least once more
         CPPUNIT_ASSERT(anEntry-&gt;_flush_calls &gt; preFlushCount);
 
         CPPUNIT_ASSERT_EQUAL(1, anEntry-&gt;_buffer_calls);
-
-        CPPUNIT_ASSERT_EQUAL(String(&quot;12345677.7 some text   !.&quot;),
-                             anEntry-&gt;_appended_text);
+        CPPUNIT_ASSERT_EQUAL(String(&quot;12345677.7 some text   !.&quot;), anEntry-&gt;_appended_text);
     }
+    delete anEntry; // does the unlock()
     Store::Root(NULL);
 }
 

=== renamed file 'src/tests/testStoreEntryStream.h' =&gt; 'src/tests/testPackableStream.h'
--- src/tests/testStoreEntryStream.h	2015-01-13 07:25:36 +0000
+++ src/tests/testPackableStream.h	2015-08-19 15:23:47 +0000
@@ -1,32 +1,32 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SRC_TEST_STORE_ENTRY_STREAM_H
-#define SQUID_SRC_TEST_STORE_ENTRY_STREAM_H
+#ifndef SQUID_SRC_TESTS_TESTPACKABLESTREAM_H
+#define SQUID_SRC_TESTS_TESTPACKABLESTREAM_H
 
 #include &lt;cppunit/extensions/HelperMacros.h&gt;
 
 /*
- * test StoreEntryStream
+ * test PackableStream
  */
 
-class testStoreEntryStream : public CPPUNIT_NS::TestFixture
+class testPackableStream : public CPPUNIT_NS::TestFixture
 {
-    CPPUNIT_TEST_SUITE( testStoreEntryStream );
+    CPPUNIT_TEST_SUITE( testPackableStream );
     CPPUNIT_TEST( testGetStream );
     CPPUNIT_TEST_SUITE_END();
 
 public:
     void setUp();
 
 protected:
     void testGetStream();
 };
 
-#endif
+#endif /* SQUID_SRC_TESTS_TESTPACKABLESTREAM_H */
 

</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003124.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
	<LI>Next message: <A HREF="003285.html">[squid-dev] [PATCH] renaming StoreEntryStream to PackableStream
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3128">[ date ]</a>
              <a href="thread.html#3128">[ thread ]</a>
              <a href="subject.html#3128">[ subject ]</a>
              <a href="author.html#3128">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
