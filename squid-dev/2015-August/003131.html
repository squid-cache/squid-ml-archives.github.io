<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Coverity%28-inspired%29%20fixes%20part%20four%2C%0A%20HttpHeader%20refactor&In-Reply-To=%3CCA%2BY8hcMVnvFYRg5xdcCUgVWdMkCTnDuw%3DwdtHB6ce%2BvWf6ZiGw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003130.html">
   <LINK REL="Next"  HREF="003136.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Coverity%28-inspired%29%20fixes%20part%20four%2C%0A%20HttpHeader%20refactor&In-Reply-To=%3CCA%2BY8hcMVnvFYRg5xdcCUgVWdMkCTnDuw%3DwdtHB6ce%2BvWf6ZiGw%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor">gkinkie at gmail.com
       </A><BR>
    <I>Sun Aug 23 22:01:58 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003130.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
        <LI>Next message: <A HREF="003136.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3131">[ date ]</a>
              <a href="thread.html#3131">[ thread ]</a>
              <a href="subject.html#3131">[ subject ]</a>
              <a href="author.html#3131">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>.. now with the actual patch

On Mon, Aug 24, 2015 at 12:01 AM, Kinkie &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">gkinkie at gmail.com</A>&gt; wrote:

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, Aug 23, 2015 at 7:55 PM, Alex Rousskov &lt;
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On 08/21/2015 11:31 AM, Kinkie wrote:
</I>&gt;&gt;<i> &gt; On Fri, Aug 21, 2015 at 6:39 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     On 08/21/2015 04:37 AM, Kinkie wrote:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     &gt;   the attached patch does:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     ... a long list of mostly unrelated changes ...
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     Sigh. Some of the patch changes are not necessary at all. Some are
</I>&gt;&gt;<i> &gt;     useful. Some should be redone to minimize conflicts. Some are
</I>&gt;&gt;<i> &gt;     performance optimizations that should be considered very carefully.
</I>&gt;&gt;<i> It
</I>&gt;&gt;<i> &gt;     would take too much time to sift through all of this and separate
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> &gt;     good from the bad, so we would have to accept pretty much all of
</I>&gt;&gt;<i> them,
</I>&gt;&gt;<i> &gt;     create a lot of conflicts, and probably miss bugs.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; To defend the code, ...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Your code was not under attack. Your choice to assemble many unrelated
</I>&gt;&gt;<i> and/or supposed-to-be-sequential changes into one patch was.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I'm sorry about that. I tend to go depth-first, unfortunately.
</I>&gt;<i> I'll try to resist, but it's really hard for me.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> &gt;     &gt; -        Tolower(name);
</I>&gt;&gt;<i> &gt;     &gt; -
</I>&gt;&gt;<i> &gt;     &gt; -        if (strcmp(name, &quot;*&quot;) == 0) {
</I>&gt;&gt;<i> &gt;     &gt; -            /* Can not handle &quot;Vary: *&quot; withtout ETag support */
</I>&gt;&gt;<i> &gt;     &gt; -            safe_free(name);
</I>&gt;&gt;<i> &gt;     &gt; +        SBuf name(item, ilen);
</I>&gt;&gt;<i> &gt;     &gt; +        if (name.cmp(&quot;*&quot;,1) == 0) {
</I>&gt;&gt;<i> &gt;     &gt;              vstr.clean();
</I>&gt;&gt;<i> &gt;     &gt;              break;
</I>&gt;&gt;<i> &gt;     &gt;          }
</I>&gt;&gt;<i> &gt;     &gt; -
</I>&gt;&gt;<i> &gt;     &gt; -        strListAdd(&amp;vstr, name, ',');
</I>&gt;&gt;<i> &gt;     &gt; +        name.toLower();
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     Do you know why we need to convert header names to lowercase here?
</I>&gt;&gt;<i> The
</I>&gt;&gt;<i> &gt;     header names are not a part of some Store hash, right? This
</I>&gt;&gt;<i> conversion
</I>&gt;&gt;<i> &gt;     is expensive because most header names will be changed here,
</I>&gt;&gt;<i> breaking
</I>&gt;&gt;<i> &gt;     SBuf reuse. If you know the reason, let's add a comment since you
</I>&gt;&gt;<i> are
</I>&gt;&gt;<i> &gt;     changing this code anyway.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; Since lowerCase(&quot;*&quot;) == &quot;*&quot;, I'd hope that the behavior is unchanged,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I did not say something has changed. I asked *why* we need to convert
</I>&gt;&gt;<i> header names to lower case. I am not trying to sneak in some veiled
</I>&gt;&gt;<i> attack on your code inside an innocent-looking question. I asked exactly
</I>&gt;&gt;<i> what I wanted to know. An &quot;I do not know&quot; would be a perfectly
</I>&gt;&gt;<i> acceptable response, of course, but if you do know, it would be good to
</I>&gt;&gt;<i> add a comment.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You are right, I got defensive over nothing.
</I>&gt;<i> Truth is, I don't know.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt;       // XXX: will reallocate if toLower() above is removed
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; .. and strListGetItem will start emitting SBufs in place of (char*,
</I>&gt;&gt;<i> &gt; length).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Right, so perhaps s/will/may/ to be less precise since there are many
</I>&gt;&gt;<i> factors here. The toLower() call is the most hidden factor though. This
</I>&gt;&gt;<i> is not important -- if you disagree that a comment would be useful, do
</I>&gt;&gt;<i> not add it. This is not an attack on your code.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Adding comment: &quot;will reallocate if ilen happens to equal pool size&quot;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt;     &gt; -    while ((e = getEntry(&amp;pos))) {
</I>&gt;&gt;<i> &gt;     &gt; -        if (e-&gt;id == id)
</I>&gt;&gt;<i> &gt;     &gt; -            delAt(pos, count);
</I>&gt;&gt;<i> &gt;     &gt; -    }
</I>&gt;&gt;<i> &gt;     &gt; +    int sz_before = entries.size();
</I>&gt;&gt;<i> &gt;     &gt; +    entries.erase(std::remove_if(entries.begin(), entries.end(),
</I>&gt;&gt;<i> &gt;     &gt; +    [=](HttpHeaderEntry *e) { return e &amp;&amp; e-&gt;id == id; }),
</I>&gt;&gt;<i> &gt;     &gt; +    entries.end());
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     This change is a performance regression AFAICT: Unlike the old
</I>&gt;&gt;<i> delAt(),
</I>&gt;&gt;<i> &gt;     std::remove_if is very expensive for std::vector. Consider using
</I>&gt;&gt;<i> &gt;     std::replace_if without .erasing instead.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; yes, it is a small regresson (from N to 2N)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I suspect a factor of 2 does not describe the overhead accurately. If
</I>&gt;&gt;<i> remove_if removes a field, then all subsequent fields (except those that
</I>&gt;&gt;<i> are also removed) would have to be moved, which is probably much more
</I>&gt;&gt;<i> expensive than just checking their values twice.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; ). Reimplemented using replace_if - readability goes a bit down the
</I>&gt;&gt;<i> &gt; drain, unfortunatley.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Perhaps a little bit. Personally, I could not interpret the earlier
</I>&gt;&gt;<i> erase(remove_if) combination without looking things up anyway :-).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> This is what it looks like right now:
</I>&gt;<i>
</I>&gt;<i>     //set all items in entries where item is not nullptr and
</I>&gt;<i>     // has same id as argument, to nullptr. Increment count variable
</I>&gt;<i>     // as a side-effect on matches during sweep
</I>&gt;<i>     std::replace_if(entries.begin(), entries.end(),
</I>&gt;<i>         [&amp;](HttpHeaderEntry *e) {
</I>&gt;<i>             if (e &amp;&amp; e-&gt;id == id) {
</I>&gt;<i>                 ++count;
</I>&gt;<i>                 return true;
</I>&gt;<i>             }
</I>&gt;<i>             return false;
</I>&gt;<i>         },
</I>&gt;<i>         nullptr);
</I>&gt;<i>
</I>&gt;<i> Hopefully the comment will clarify intent :)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> &gt;     &gt; +enum HdrKind {
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;     Use C++11 class enums for global enums, especially when such use
</I>&gt;&gt;<i> does
</I>&gt;&gt;<i> &gt;     not increase the amount of old code changes. In this specific case,
</I>&gt;&gt;<i> it
</I>&gt;&gt;<i> &gt;     does not AFAICT.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Unfortunately it's not possible in ordeer to use it as a bit-field (I
</I>&gt;&gt;<i> &gt; have tried and the compiler refused)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Interesting! If you still have an example of what goes wrong, can you
</I>&gt;&gt;<i> post it? I tried a few tests myself, but they seem to be working fine if
</I>&gt;&gt;<i> I specify the underlying class storage type (as we should, per [1]):
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Using clang on MacOS:
</I>&gt;<i> ------------------------ source code
</I>&gt;<i> #include &lt;iostream&gt;
</I>&gt;<i>
</I>&gt;<i> enum class foo : std::int8_t {
</I>&gt;<i>   zero = 0,
</I>&gt;<i>   one = 1,
</I>&gt;<i>   two = 1&lt;&lt;1,
</I>&gt;<i>   three = 1&lt;&lt;2,
</I>&gt;<i>   four = 1&lt;&lt;3
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> std::int8_t var = foo::one | foo::four;
</I>&gt;<i>
</I>&gt;<i> int main() {
</I>&gt;<i>   std::cout &lt;&lt; var &lt;&lt; std::endl;
</I>&gt;<i>   return 0;
</I>&gt;<i> }
</I>&gt;<i> ---------------------------- compiler output
</I>&gt;<i> example.cc:11:28: error: invalid operands to binary expression ('foo' and
</I>&gt;<i> 'foo')
</I>&gt;<i> std::int8_t var = foo::one | foo::four;
</I>&gt;<i>                   ~~~~~~~~ ^ ~~~~~~~~~
</I>&gt;<i> 1 error generated.
</I>&gt;<i>  -----------------------------
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; &quot;bzr send&quot; unfortunately doesn't allow to specify context to be added :(
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, that is unfortunate indeed. Fortunately, &quot;bzr send&quot; is not the only
</I>&gt;&gt;<i> way to post a patch for review :-).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yes :)
</I>&gt;<i> Attached current patch.
</I>&gt;<i> If I understand correclty, that the only point to clear before merge is
</I>&gt;<i> how many lines away from a touched line should a HERE be to be removed
</I>&gt;<i> (I'll try to come up with a script to do blanket HERE removal as said
</I>&gt;<i> elsewhere in this thread).
</I>&gt;<i>
</I>&gt;<i> Thanks!
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i>     Francesco
</I>&gt;<i>
</I>


-- 
    Francesco
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150824/f902b49f/attachment-0001.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150824/f902b49f/attachment-0001.html</A>&gt;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: coverity-fixes-4-v4.patch
Type: application/octet-stream
Size: 213614 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150824/f902b49f/attachment-0001.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150824/f902b49f/attachment-0001.obj</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003130.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
	<LI>Next message: <A HREF="003136.html">[squid-dev] [PATCH] Coverity(-inspired) fixes part four, HttpHeader refactor
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3131">[ date ]</a>
              <a href="thread.html#3131">[ thread ]</a>
              <a href="subject.html#3131">[ subject ]</a>
              <a href="author.html#3131">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
