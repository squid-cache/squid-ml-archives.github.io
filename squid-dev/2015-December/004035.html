<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] Where do ACL flags belong?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Where%20do%20ACL%20flags%20belong%3F&In-Reply-To=%3C5660E81F.30209%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004034.html">
   <LINK REL="Next"  HREF="004037.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] Where do ACL flags belong?</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Where%20do%20ACL%20flags%20belong%3F&In-Reply-To=%3C5660E81F.30209%40treenet.co.nz%3E"
       TITLE="[squid-dev] [RFC] Where do ACL flags belong?">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Dec  4 01:10:55 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="004034.html">[squid-dev] [RFC] Where do ACL flags belong?
</A></li>
        <LI>Next message: <A HREF="004037.html">[squid-dev] [RFC] Where do ACL flags belong?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4035">[ date ]</a>
              <a href="thread.html#4035">[ thread ]</a>
              <a href="subject.html#4035">[ subject ]</a>
              <a href="author.html#4035">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 4/12/2015 1:02 p.m., Alex Rousskov wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i>     We are writing code to add a new ACL flag (-m) that converts opaque
</I>&gt;<i> string value comparison into a CSV list membership test. The patch is
</I>&gt;<i> going through internal polishing and will be posted soon. That work
</I>&gt;<i> exposed a design bug in ACL flags handling. We are not going to alter -m
</I>&gt;<i> code to address this bug because that -m code is almost done, but I
</I>&gt;<i> wanted to start this discussion about what to do next.
</I>&gt;<i> 
</I>&gt;<i> AFAICT, admins expect the following configuration to work as described
</I>&gt;<i> in the #comments:
</I>&gt;<i> 
</I>&gt;<i>   acl foo dstdomain    v1 # lookup/conversion allowed
</I>&gt;<i>   acl foo dstdomain -n v2 # no lookup/conversion
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> However, Squid interprets the above as:
</I>&gt;<i> 
</I>&gt;<i>   acl foo dstdomain -n v1 # no lookup/conversion
</I>&gt;<i>   acl foo dstdomain -n v2 # no lookup/conversion
</I>&gt;<i> 
</I>&gt;<i> or, if you prefer:
</I>&gt;<i> 
</I>&gt;<i>   acl foo dstdomain -n v1 v2 # no lookup/conversion
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This happens because we store one ACLFlags object per ACL object and
</I>&gt;<i> update that flags object as we parse multiple acl lines with the same
</I>&gt;<i> aclname. The only exception is the -i flag that is parsed/stored
</I>&gt;<i> specially for historical reasons; let's ignore that exception for now.
</I>
Lets not. It used to be -i was the only one that existed for many years.
So it was the authoritative pattern or how flags operated in Squid. AIUI
this is where the admins expectation comes from.

The -n flags which are breaking that pattern are the exception. Not the
other way around.


&gt;<i> 
</I>&gt;<i> The situation is further complicated by the fact that different flags
</I>&gt;<i> interpretation for different ACL parameter/data items is tricky. For
</I>&gt;<i> example, if -n disallows DNS lookups, what does it really mean that we
</I>&gt;<i> allow them for comparison with v1 but disallow them for comparison with
</I>&gt;<i> v2? Does the lookup we do before comparing with v1 violates the lookup
</I>&gt;<i> prohibition for v2?
</I>&gt;<i> 
</I>&gt;<i> In a sense, some flags like &quot;no slow DNS lookup&quot; are better to view in a
</I>&gt;<i> &quot;whole ACL&quot; scope while others like &quot;case insensitive&quot; or &quot;no DNS/IP
</I>&gt;<i> conversion&quot; are better applied to individual ACL data/parameter values.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I see two primary ways to fix this:
</I>&gt;<i> 
</I>&gt;<i> 1. Move ACLFlags from the ACL object to individual data items inside the
</I>&gt;<i> ACLData object. This move will allow multiple acl lines to have
</I>&gt;<i> different flags.
</I>&gt;<i> 
</I>&gt;<i> This approach requires serious coding. It changes how the existing
</I>&gt;<i> configurations are interpreted, but it also supports existing and future
</I>&gt;<i> configurations the way most admins expect (even though their
</I>&gt;<i> expectations do not match what actually happens right now!).
</I>&gt;<i> 
</I>&gt;<i> [ N.B. This approach can be further optimized to group same-flag data
</I>&gt;<i> items inside an ACLData object so that we do not have to store so many
</I>&gt;<i> [refcounted] ACLFlags object pointers. Even more code, more complexity,
</I>&gt;<i> but less RAM in some cases. We can discuss that optimization separately
</I>&gt;<i> if #1 is picked as the overall direction. ]
</I>&gt;<i> 
</I>
It will also work much better with the allof design you insisted on
using. Where a single ACL contains a full AND-OR boolean tree of decisions.


&gt;<i> 
</I>&gt;<i> 2. Continue to use one ACLFlags object for all acl lines with the same
</I>&gt;<i> name. Add ACLFlags equality comparison operator. Warn the admin if they
</I>&gt;<i> attempt to use different flags for different lines. Admins would have to
</I>&gt;<i> split the misleading ACL into several ACLs with different names to avoid
</I>&gt;<i> the warning.
</I>&gt;<i> 
</I>&gt;<i> This approach is much easier to implement and it matches the original
</I>&gt;<i> squid.conf &quot;multiple ACL lines with the same name are the same as a
</I>&gt;<i> single line&quot; design. However, it forces admins to write less natural(?)
</I>&gt;<i> configurations and rewrite existing configurations to get rid of the
</I>&gt;<i> warning.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> In summary, this is a tough choice between:
</I>&gt;<i> 
</I>&gt;<i> #1: Supporting what the admins thought they are configuring.
</I>&gt;<i>     Better configuration interface?
</I>&gt;<i>     More similar to how -i is handled today.
</I>&gt;<i> 
</I>&gt;<i> #2: Backward compatible (but with &quot;Is your config broken?&quot; warnings).
</I>&gt;<i>     A lot less development work.
</I>
No. You will have to fully re-implement regex parsing not to perform -i/+i.

&gt;<i>     Simpler configuration interface.
</I>&gt;<i>     Less RAM.
</I>&gt;<i> 
</I>
Not much less RAM to matter. Each of the split ACLs will have more
overhead in RAM usage

&gt;<i> 
</I>&gt;<i> I lean towards #2 because it is backward compatible and simpler (the
</I>&gt;<i> ACLs are already &quot;too complex&quot; for many admins). I would have been sure
</I>&gt;<i> that this is the best approach if -i was not handled differently already.
</I>&gt;<i> 
</I>&gt;<i> How do you think this should be fixed?
</I>
I prefer #1, because it is already familiar to admins and does not force
us all to do a non-backward-compatible manual config update (those as
you may see below that is not mandatory). We have enough config updates
happening without this.

I believe -i is a lot more widespread in historic usage than -n.


I also see no use for a flag that changes the behaviour for an entire
ACL type. We would probably be better off making a new type (dstdomain_str).

I know that has issues of its own as side effects on *access complexity.
Allowing one &quot;name&quot; to be shared between the dstdomain, dstdom_regex,
and dstdom_str types would simplify those.
 OR, using a namespace sub-type ('_' maybe?) that implies the flagged
behaviour difference. A renaming dstdom_regex to dstdomain_regex etc.
under the new model.


Although that said; AFAICS it should not be much more difficult to
re-implement -n using #1 than to re-implement regex parsing and -i to
implement #2. All that is required is that the ACL parser remembers the
-n/+n value for the duration of a single line like -i/+i does today in
order to set the per-value flag correctly on those values. Then the DNS
ACL checks with the flag from it new location before doing lookups.


Or if you are super worried about one boolean flag per ACL value adn
insist on #2 then auto-converting the lists of values between -n/+n
flags down into sub-nodes of the ACL tree would let the flag actually be
on the node rather than the value entry. Without requiring the manual
config migrations.

Amos

</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004034.html">[squid-dev] [RFC] Where do ACL flags belong?
</A></li>
	<LI>Next message: <A HREF="004037.html">[squid-dev] [RFC] Where do ACL flags belong?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4035">[ date ]</a>
              <a href="thread.html#4035">[ thread ]</a>
              <a href="subject.html#4035">[ subject ]</a>
              <a href="author.html#4035">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
