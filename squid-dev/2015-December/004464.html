<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] implement RFC3986
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3CCA%2BY8hcNVTkFzEGxHaodQ_00HxuxyAy6RmCZGO7QzgCCaqBtRMw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004463.html">
   <LINK REL="Next"  HREF="004466.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] implement RFC3986</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3CCA%2BY8hcNVTkFzEGxHaodQ_00HxuxyAy6RmCZGO7QzgCCaqBtRMw%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] implement RFC3986">gkinkie at gmail.com
       </A><BR>
    <I>Mon Dec 28 19:01:36 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="004463.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
        <LI>Next message: <A HREF="004466.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4464">[ date ]</a>
              <a href="thread.html#4464">[ thread ]</a>
              <a href="subject.html#4464">[ subject ]</a>
              <a href="author.html#4464">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!
  thanks for the super-fast review.

On Mon, Dec 28, 2015 at 5:46 PM, Alex Rousskov
&lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
&gt;<i> On 12/28/2015 07:01 AM, Kinkie wrote:
</I>
&gt;&gt;<i> +static int
</I>&gt;&gt;<i> +fromhex(char ch)
</I>&gt;<i>
</I>&gt;<i> ...
</I>&gt;<i>
</I>&gt;&gt;<i> +// return a static 2-char buffer with a hex representation of argument
</I>&gt;&gt;<i> +static char*
</I>&gt;&gt;<i> +tohex(const unsigned char c)
</I>&gt;<i>
</I>&gt;<i> Please do not add global static functions to header files unless
</I>&gt;<i> actually needed. Use inline instead to avoid duplicating these functions
</I>&gt;<i> in every file that includes this header.
</I>
Ok.

&gt;&gt;<i> +// duplicate from rfc1738.c
</I>&gt;&gt;<i> +static int
</I>&gt;&gt;<i> +fromhex(char ch)
</I>&gt;<i>
</I>&gt;<i> Missing description. &quot;Duplicate of some private function in some
</I>&gt;<i> scheduled-for-removal(?) C file&quot; is not a description.
</I>
Ok

&gt;&gt;<i> +static int
</I>&gt;&gt;<i> +fromhex(char ch)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
</I>&gt;&gt;<i> +        return ch - '0';
</I>&gt;&gt;<i> +    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')
</I>&gt;&gt;<i> +        return ch - 'a' + 10;
</I>&gt;&gt;<i> +    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')
</I>&gt;&gt;<i> +        return ch - 'A' + 10;
</I>&gt;&gt;<i> +    return -1;
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> If you are after performance, an unconditional lookup in a 256-member
</I>&gt;<i> int vector would be faster.
</I>
Performance is good, but it's not the primary objective. For now I'd
leave as-is.

&gt;&gt;<i> +// return a static 2-char buffer with a hex representation of argument
</I>&gt;&gt;<i> +static char*
</I>&gt;&gt;<i> +tohex(const unsigned char c)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    static char rv[3];
</I>&gt;&gt;<i> +    (void) snprintf ( rv, 3, &quot;%02X&quot;, c);
</I>&gt;&gt;<i> +    return rv;
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> If you are after performance, an unconditional lookup in a 256-member
</I>&gt;<i> char* vector would be much faster.
</I>
Same as above.

&gt;<i> If you can return a const pointer, please return a const pointer.
</I>
It's not possible with the current implementation. If we decide to
move to an array-based one, sure.

&gt;&gt;<i> +    for (auto in = s.begin(); in != e; ++in) {
</I>&gt;&gt;<i> +        if (*in != '%') { // normal case, copy and continue
</I>&gt;&gt;<i> +            rv.push_back(*in);
</I>&gt;&gt;<i> +            continue;
</I>&gt;&gt;<i> +        }
</I>&gt;<i> ...
</I>&gt;<i>
</I>&gt;<i> I cannot validate that low-level C code. Can you use a Tokenizer
</I>&gt;<i> instead? Is it critical to provide copy-less performance for helpers
</I>&gt;<i> using std::string instead of SBuf?
</I>
Performance for helpers is not really critical IMO.
SBuf is a lot of code and it really depends on infrastructure provided
by squid (e.g. mempools).
Outside squid it really makes not much sense to bring in that much
scaffolding - which would also have include stubs etc.
It's much better to be API-compatible and use std::string there.

&gt;&gt;<i> +public:
</I>&gt;&gt;<i> +    const static CharacterSet
</I>&gt;&gt;<i> +        Unsafe,  // RFC 1738 unsafe set
</I>&gt;&gt;<i> +        Ctrls,   // control characters (\0x00 to \0x1f)
</I>&gt;&gt;<i> +        UnsafeAndCtrls, // RFC 1738 Unsafe and Ctrls
</I>&gt;&gt;<i> +        Reserved1738, // RFC 1738 Reserved set
</I>&gt;&gt;<i> +        GenDelims,// RFC 3986 gen-delims set
</I>&gt;&gt;<i> +        SubDelims,// RFC 3986 sub-delims set
</I>&gt;&gt;<i> +        Reserved, // RFC 3986 reserved characters set
</I>&gt;&gt;<i> +        Unreserved, // RFC 3986 unreserved characters set
</I>&gt;&gt;<i> +        Unescaped,//ctrls and unsafe except for percent symbol
</I>&gt;&gt;<i> +        All;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +};
</I>&gt;<i>
</I>&gt;<i> This is not a class but a namespace.
</I>&gt;<i>
</I>&gt;<i> Please s/RFC3986/Rfc3986/ for consistency with similar &quot;let's group RFC
</I>&gt;<i> concepts in one namespace&quot; SslBump code posted by Christos earlier (IIRC).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +template &lt;class String&gt;
</I>&gt;&gt;<i> +String rfc3986_escape(const String &amp;s, const CharacterSet &amp;escapeChars = RFC3986::UnsafeAndCtrls)
</I>&gt;<i>
</I>&gt;<i> Describe and place inside the Rfc3986 namespace as &quot;Escape()&quot;. There may
</I>&gt;<i> be other names that you may want to add to the Rfc3986 namespace (I have
</I>&gt;<i> not checked).
</I>
Escape, Unescape an the masks are about all I can think of.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +const CharacterSet
</I>&gt;&gt;<i> +    RFC3986::Unsafe(&quot;rfc1738:unsafe&quot;, &quot;&lt;&gt;\&quot;# %{}|\\^~[]`'&quot;),
</I>&gt;&gt;<i> +    RFC3986::Ctrls(&quot;rfc1738:ctrls&quot;, {{0x00, 0x1f}, {0x7f,0xff}}),
</I>&gt;&gt;<i> +    RFC3986::Reserved1738(&quot;rfc1738:reserved&quot;, &quot;;/?:@=&amp;&quot;),
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    RFC3986::Unescaped = (UnsafeAndCtrls - CharacterSet(nullptr,&quot;%&quot;) ).rename(&quot;rfc1738:unescaped&quot;),
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If these are RFC 1738 sequences, why place them in the RFC 3986 namespace?
</I>
Providing callers backwards compatibility is the main reason for me.

&gt;&gt;<i> === added file 'include/rfc3986.h'
</I>&gt;<i> ...
</I>&gt;&gt;<i> +#include &quot;base/CharacterSet.h&quot;
</I>&gt;<i>
</I>&gt;<i> This is not my area of expertise, but including src/base/CharacterSet.h
</I>&gt;<i> into include/ files looks very wrong: Code that needs
</I>&gt;<i> src/base/CharacterSet, should live in src/ IMHO.
</I>
Yes, I had the same doubt. Alternatively, we could to move
CharacterSet into include/. I really have no preference.

&gt;&gt;<i> +/* Being a C library code it is best bodily included and tested with C++ type-safe techniques. */
</I>&gt;&gt;<i> +#include &quot;lib/rfc3986.cc&quot;
</I>&gt;<i>
</I>&gt;<i> lib/rfc3986.cc is not a C library code. This looks like a dirty hack to
</I>&gt;<i> work around some linking problems due to misplaced rfc3986.cc file.
</I>
I copied that from rfc1738, but you're right, it's not really needed

&gt;&gt;<i> +    // bugs.
</I>&gt;&gt;<i> +    void PercentZeroNullDecoding();
</I>&gt;&gt;<i> +    void testPerformance();
</I>&gt;<i>
</I>&gt;<i> Not sure what this misplaced description means. Are we adding bugs?
</I>
Hopefully not.

The changes are in the branch; I'm not posting a diff as there are
some open points still. As soon as they're closed I'll send a new
patch for review.

Thanks.

-- 
    Francesco
</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004463.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
	<LI>Next message: <A HREF="004466.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4464">[ date ]</a>
              <a href="thread.html#4464">[ thread ]</a>
              <a href="subject.html#4464">[ subject ]</a>
              <a href="author.html#4464">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
