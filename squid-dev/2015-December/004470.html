<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SBuf API improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56831EBD.9010000%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004469.html">
   <LINK REL="Next"  HREF="004472.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SBuf API improvements</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56831EBD.9010000%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] SBuf API improvements">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Dec 30 00:01:01 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="004469.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
        <LI>Next message: <A HREF="004472.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4470">[ date ]</a>
              <a href="thread.html#4470">[ thread ]</a>
              <a href="subject.html#4470">[ subject ]</a>
              <a href="author.html#4470">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/29/2015 02:59 PM, Kinkie wrote:
&gt;<i> On Mon, Dec 28, 2015 at 10:27 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 12/28/2015 06:41 AM, Kinkie wrote:
</I>&gt;&gt;&gt;<i> It is debateable whether reserveCapacity should be just renamed
</I>&gt;&gt;&gt;<i> instead of aliased; feedback is welcome.
</I>
&gt;&gt;<i> I do not have a strong opinion on this. reserveCapacity() is not called
</I>&gt;&gt;<i> reserve() today because we also have reserveSpace() and knowing that
</I>&gt;&gt;<i> there are two different methods is important for some callers. Once you
</I>&gt;&gt;<i> add plain reserve(), the probability that a caller will notice
</I>&gt;&gt;<i> reserveSpace() that the caller needs will go down.
</I>
&gt;<i> We could leave both and mark in the documentation that it's meant for
</I>&gt;<i> API compatibility and should not be used by code calling SBuf. what do
</I>&gt;<i> you think?
</I>
Having three methods (reserve, reserveCapacity, and reserveSpace) is a
poor solution to the problem that the two methods (reserveCapacity and
reserveSpace) were solving. Yes, adding a not-to-be-used third name
might be better than renaming the existing one, but, again, the overall
direction of your changes eliminates good options, forcing you to pick
among the bad ones.


&gt;&gt;&gt;<i> The objective of this change will be clear in the followup rfc3986
</I>&gt;&gt;&gt;<i> patch, which is templatized in order to be available both to helpers
</I>&gt;&gt;&gt;<i> who use std::string and to squid using SBuf.
</I>
&gt;&gt;<i> SBuf is already suffering from being too many things to too many
</I>&gt;&gt;<i> different callers. I suspect that requiring API compatibility with
</I>&gt;&gt;<i> std::string [in certain poorly defined areas] will make the situation
</I>&gt;&gt;<i> worse, but I cannot prove that. Same for writing templated code that can
</I>&gt;&gt;<i> work with both std::string and SBuf.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If helpers really need SBuf, give them SBuf. If helpers want to use
</I>&gt;&gt;<i> std::string, they already can. Assuring that one can be substituted with
</I>&gt;&gt;<i> another feels like a false goal that would bring more trouble in the
</I>&gt;&gt;<i> long run than it would help in the short term. Again, I cannot prove
</I>&gt;&gt;<i> that and will not veto these changes.
</I>

&gt;<i> helpers do not need SBuf, in fact they don't want it, they need
</I>&gt;<i> percent-encoding and a c++ string management system.
</I>
I doubt that all helpers are the same with regard to string needs. Many
helpers do not need C++ at all. I assume that you are thinking about
helpers maintained by the Squid Project and helpers that we decided to
make very efficient and tightly integrated with Squid code.


&gt;<i> The main benefit of SBuf over std::string is its integration with
</I>&gt;<i> support infrastructure in squid proper (mempools and cachemgr), which
</I>&gt;<i> is definitely too much to add to helpers as well. We'd end up filling
</I>&gt;<i> them with stubs which would make maintaining the build system
</I>&gt;<i> complicated - see how much effort it is to do so for unit tests.
</I>
I certainly agree that it is easier to add a few methods to SBuf and
craft a templated encoding loop than it is to make SBufs independent
from memory pools [and cache manager]. The ease of a small change does
not necessarily make it the best long-term solution though. There are
other factors to consider.

You use existing unit test build difficulties as an argument to avoid
using SBufs in helpers [because helpers will face similar difficulties].
That argument is valid _if_ those build difficulties are inherent in the
SBuf concept. However, if those difficulties are simply SBuf
implementation bugs/deficiencies, then it would be better to address
those SBuf deficiencies than to work around [and exacerbate!] them in
one more place.


&gt;<i> So IMO helpers need std::string, 
</I>
and Perl $string, and Javascript String. There are many different
helpers with very different needs...


&gt;<i> and templated code is the best
</I>&gt;<i> solution I could come up with to avoid having to maintain three
</I>&gt;<i> different implementations of percent-encoding. Suggestions on
</I>&gt;<i> alternate paths to obtain the same objective are of course welcome.
</I>
Since Squid is (or should be) using standard encodings, I suspect there
are libraries and modules (for various programming languages) that
already provide appropriate encoding support. We would not have to
maintain any of those implementations.

However, let's assume that our ultimate goal[1] is to ship fast,
production-quality helpers that are built without external dependencies
(i.e., built using Squid libraries) and that Squid code is (or will be)
using SBuf for most string and buffering operations.

Quality helpers are likely to need a variety of string and buffering
operations. Which of the following approaches is better long-term?

A. Support a growing number of templated algorithms while making SBuf
API more and more interchangeable with std::string (while at the same
time providing a growing number of SBuf methods for raw buffer operations).

B. Make SBufs and SBuf-driven algorithms easily available in helpers by
making SBuf storage/memory backing (and any other current dependencies
on Squid core) easily replaceable with something that does not need any
integration with Squid core.

To me, option B looks like the right overall direction.

------------

[1] It is a dangerous and questionable assumption: Why use something so
inefficient and awkward as the helper API if Squid-native code and
performance are the primary criteria?!

Alex.

</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004469.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
	<LI>Next message: <A HREF="004472.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4470">[ date ]</a>
              <a href="thread.html#4470">[ thread ]</a>
              <a href="subject.html#4470">[ subject ]</a>
              <a href="author.html#4470">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
