<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SBuf API improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56840676.70706%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004476.html">
   <LINK REL="Next"  HREF="004461.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SBuf API improvements</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56840676.70706%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] SBuf API improvements">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Dec 30 16:29:42 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="004476.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
        <LI>Next message: <A HREF="004461.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4475">[ date ]</a>
              <a href="thread.html#4475">[ thread ]</a>
              <a href="subject.html#4475">[ subject ]</a>
              <a href="author.html#4475">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/30/2015 03:42 AM, Kinkie wrote:
&gt;<i> reserveSpace(n) is actually just
</I>&gt;<i> reserveCapacity(n+length()); what about simply getting rid of
</I>&gt;<i> reserveSpace and rename reserveCapacity to reserve? Minimum surprise
</I>&gt;<i> here for users here.
</I>
I will use reductio ad absurdum to highlight what I perceive as a flaw
in your question:

C++ is just assembly language with a few keywords and curly braces
added. What about getting rid of those keywords and curly braces and
just using pure assembly? Minimum surprise for users!

Yes, you can remove protections, but that usually results in a different
kind of surprises -- the ones you want to avoid the most. I am pretty
sure that given a statistically significant sample, the amount of buggy
code calling reserve(length() + n) would be significantly larger than
the amount of buggy code code calling reserveSpace(n).

&gt;<i> I wouldn't call them &quot;tightly integrated&quot; but simply
</I>&gt;<i> &quot;bundled&quot;. What I'm trying to do is to make them more readable, secure
</I>&gt;<i> and adaptable first by using c++ in place of the c-with-thin-c++-paint
</I>&gt;<i> they currently are coded as. Making them more maintainable, hopefully
</I>&gt;<i> robust and readable is the main goal. In fact, as we can assume that
</I>&gt;<i> they will be used as reference by others writing their own helpers,
</I>&gt;<i> it's in everyone's best interests if they are as readable and compact
</I>&gt;<i> as possible.
</I>
If your goals are readability and adaptability combined with the ease of
distribution, a scripting language may work [much] better than C++.


&gt;<i> Let's consider mempools for instance. Having a build-time, static,
</I>&gt;<i> mechanism which can prevent linking against mempools is IMO tricky and
</I>&gt;<i> fragile;
</I>
It is difficult to argue efficiently with fuzzy characteristics like
&quot;tricky&quot; and &quot;fragile&quot;, but I think that making SBuf available without
mempools is better than making SBuf-driven algorithms generic. The
alternatives (such as generics) are not necessarily trickier or more
fragile, but nevertheless worse overall.


&gt;<i> Let me restrict the scope to &quot;the C-ish and C++ helpers we bundle&quot;
</I>
It could have been worse. Imagine us bundling helpers written in
assembly. After you reject that image as obviously absurd, I hope you
will notice a funny aftertaste questions lingering for a few seconds:
Why are we bundling *C++* helpers? If we continue to bundle C++ helpers,
what does it say about our true goals with regard to bundled helper
qualities? Are we after ease of writing? Ease of reading? Ease of
adapting? Ease of maintaining? Ease of bundling? Performance?


&gt;&gt;<i> Since Squid is (or should be) using standard encodings, I suspect there
</I>&gt;&gt;<i> are libraries and modules (for various programming languages) that
</I>&gt;&gt;<i> already provide appropriate encoding support. We would not have to
</I>&gt;&gt;<i> maintain any of those implementations.
</I>&gt;<i> 
</I>&gt;<i> There are. However:
</I>
Please note that I was only talking about &quot;libraries and modules&quot; to use
with _helpers_, not with Squid proper.


&gt;<i> - the ones I could find seem to be quite generic, we have different
</I>&gt;<i> needs in different contexts
</I>
This item is too general to agree or disagree with.


&gt;<i> - impedence mismatch. These are either C or use std::string; this
</I>&gt;<i> generally means two more data-copies if we wish to use SBuf (or
</I>&gt;<i> std::string with a custom allocator)
</I>
I lost you here. If helpers wish to use SBuf, then they do not need 3rd
party libraries and Squid does not need to make its SBuf algorithms
generic. If helpers do not wish to use SBuf, then 3rd party libraries do
not introduce any extra copies (from SBufs).


&gt;<i> - finding one which is generally available on all OSes we care about
</I>&gt;<i> seems not trivial.
</I>
Agreed. We can add portability or ease of deployment to the bundled
helper criteria. It is a topic on its own!


&gt;&gt;<i> However, let's assume that our ultimate goal[1] is to ship fast,
</I>&gt;&gt;<i> production-quality helpers that are built without external dependencies
</I>&gt;&gt;<i> (i.e., built using Squid libraries) and that Squid code is (or will be)
</I>&gt;&gt;<i> using SBuf for most string and buffering operations.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Quality helpers are likely to need a variety of string and buffering
</I>&gt;&gt;<i> operations. Which of the following approaches is better long-term?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A. Support a growing number of templated algorithms while making SBuf
</I>&gt;&gt;<i> API more and more interchangeable with std::string (while at the same
</I>&gt;&gt;<i> time providing a growing number of SBuf methods for raw buffer operations).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> B. Make SBufs and SBuf-driven algorithms easily available in helpers by
</I>&gt;&gt;<i> making SBuf storage/memory backing (and any other current dependencies
</I>&gt;&gt;<i> on Squid core) easily replaceable with something that does not need any
</I>&gt;&gt;<i> integration with Squid core.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To me, option B looks like the right overall direction.
</I>

&gt;<i> Could be, but we'd then need to redesign mempools to be stub-able, or
</I>&gt;<i> templatize SBuf with an allocator and isolate it from mempools (I
</I>&gt;<i> focus on these as these are the dependency bringing in most baggage.
</I>
I hope there are better ways to get B because, IIRC, SBufs do not know
[much] about mempools. I am oversimplifying, but I suspect that
separating SBufs from needless hard-coded dependencies requires not much
more than providing a memAllocString() and memFreeString() function
implementations that do not depend on memory pools. After a bit of
cleanup, it would be just a matter of linking with the right object file
(Squid gets trueMem.o while helpers get fakeMem.o) or internal library.


&gt;<i> Given the fact that we won't probably require many common algorithms,
</I>&gt;<i> I believe that A is not a bad an option as you do.
</I>
Glad you at least agree that A is bad. I know that is not enough to stop
you from implementing it, but I still hope that you will try to do B
instead.


Thank you,

Alex.

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004476.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
	<LI>Next message: <A HREF="004461.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4475">[ date ]</a>
              <a href="thread.html#4475">[ thread ]</a>
              <a href="subject.html#4475">[ subject ]</a>
              <a href="author.html#4475">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
