<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SBuf API improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56840B1F.3030400%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004473.html">
   <LINK REL="Next"  HREF="004475.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SBuf API improvements</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56840B1F.3030400%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] SBuf API improvements">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Dec 30 16:49:35 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="004473.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
        <LI>Next message: <A HREF="004475.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4476">[ date ]</a>
              <a href="thread.html#4476">[ thread ]</a>
              <a href="subject.html#4476">[ subject ]</a>
              <a href="author.html#4476">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/30/2015 09:05 AM, Kinkie wrote:

&gt;<i>   I've implemented the API shuffling I described earlier, and it is
</I>&gt;<i> quite a self-contained change.
</I>&gt;<i> I'm submitting it, as it makes sense regardless of the &quot;use SBuf for
</I>&gt;<i> helpers&quot; discussion.
</I>
Why does it make sense? The removal of the reserveSpace() method does
not make sense to me. Neither the intro email nor the patch preamble
provide justification for removing that method [or making any other
changes].


&gt;<i>  SBuf&amp;
</I>&gt;<i>  SBuf::assign(const char *S, size_type n)
</I>&gt;<i>  {
</I>&gt;<i>      const Locker blobKeeper(this, S);
</I>&gt;<i>      debugs(24, 6, id &lt;&lt; &quot; from c-string, n=&quot; &lt;&lt; n &lt;&lt; &quot;)&quot;);
</I>&gt;<i>      clear();
</I>&gt;<i> -    return append(S, n); //bounds checked in append()
</I>&gt;<i> +    return append(S, n); //bounds checked in push_back()
</I>&gt;<i>  }
</I>
The old comment is still the right one. The new comment does not make
sense because we are not calling push_back() in this context. Methods
currently called by append(S,n) do not matter to the reader and do not
even include push_back()!

&gt;<i>  SBuf&amp;
</I>&gt;<i> +SBuf::append(size_type n, const char c)
</I>&gt;<i> +{
</I>&gt;<i> +    reserve(length() + n);
</I>&gt;<i> +    for (size_type j = 0; j &lt; n; ++j)
</I>&gt;<i> +        lowAppend(&amp;c, 1);
</I>&gt;<i> +    return *this;
</I>&gt;<i> +}
</I>
We have a method that appends a single character. Please use it [instead
of duplicating it by calling lowAppend() directly].

It is strange that &quot;c&quot; is const and &quot;n&quot; is not. Make both const?


HTH,

Alex.



&gt;<i> On Wed, Dec 30, 2015 at 11:42 AM, Kinkie &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">gkinkie at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> On Wed, Dec 30, 2015 at 1:01 AM, Alex Rousskov
</I>&gt;&gt;<i> &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> On 12/29/2015 02:59 PM, Kinkie wrote:
</I>&gt;&gt;&gt;&gt;<i> On Mon, Dec 28, 2015 at 10:27 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> On 12/28/2015 06:41 AM, Kinkie wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> It is debateable whether reserveCapacity should be just renamed
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> instead of aliased; feedback is welcome.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> I do not have a strong opinion on this. reserveCapacity() is not called
</I>&gt;&gt;&gt;&gt;&gt;<i> reserve() today because we also have reserveSpace() and knowing that
</I>&gt;&gt;&gt;&gt;&gt;<i> there are two different methods is important for some callers. Once you
</I>&gt;&gt;&gt;&gt;&gt;<i> add plain reserve(), the probability that a caller will notice
</I>&gt;&gt;&gt;&gt;&gt;<i> reserveSpace() that the caller needs will go down.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> We could leave both and mark in the documentation that it's meant for
</I>&gt;&gt;&gt;&gt;<i> API compatibility and should not be used by code calling SBuf. what do
</I>&gt;&gt;&gt;&gt;<i> you think?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Having three methods (reserve, reserveCapacity, and reserveSpace) is a
</I>&gt;&gt;&gt;<i> poor solution to the problem that the two methods (reserveCapacity and
</I>&gt;&gt;&gt;<i> reserveSpace) were solving. Yes, adding a not-to-be-used third name
</I>&gt;&gt;&gt;<i> might be better than renaming the existing one, but, again, the overall
</I>&gt;&gt;&gt;<i> direction of your changes eliminates good options, forcing you to pick
</I>&gt;&gt;&gt;<i> among the bad ones.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ok, next option. reserveSpace(n) is actually just
</I>&gt;&gt;<i> reserveCapacity(n+length()); what about simply getting rid of
</I>&gt;&gt;<i> reserveSpace and rename reserveCapacity to reserve? Minimum surprise
</I>&gt;&gt;<i> here for users here.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> The objective of this change will be clear in the followup rfc3986
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> patch, which is templatized in order to be available both to helpers
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> who use std::string and to squid using SBuf.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> SBuf is already suffering from being too many things to too many
</I>&gt;&gt;&gt;&gt;&gt;<i> different callers. I suspect that requiring API compatibility with
</I>&gt;&gt;&gt;&gt;&gt;<i> std::string [in certain poorly defined areas] will make the situation
</I>&gt;&gt;&gt;&gt;&gt;<i> worse, but I cannot prove that. Same for writing templated code that can
</I>&gt;&gt;&gt;&gt;&gt;<i> work with both std::string and SBuf.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> If helpers really need SBuf, give them SBuf. If helpers want to use
</I>&gt;&gt;&gt;&gt;&gt;<i> std::string, they already can. Assuring that one can be substituted with
</I>&gt;&gt;&gt;&gt;&gt;<i> another feels like a false goal that would bring more trouble in the
</I>&gt;&gt;&gt;&gt;&gt;<i> long run than it would help in the short term. Again, I cannot prove
</I>&gt;&gt;&gt;&gt;&gt;<i> that and will not veto these changes.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> helpers do not need SBuf, in fact they don't want it, they need
</I>&gt;&gt;&gt;&gt;<i> percent-encoding and a c++ string management system.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I doubt that all helpers are the same with regard to string needs. Many
</I>&gt;&gt;&gt;<i> helpers do not need C++ at all. I assume that you are thinking about
</I>&gt;&gt;&gt;<i> helpers maintained by the Squid Project and helpers that we decided to
</I>&gt;&gt;&gt;<i> make very efficient and tightly integrated with Squid code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes. Although I wouldn't call them &quot;tightly integrated&quot; but simply
</I>&gt;&gt;<i> &quot;bundled&quot;. What I'm trying to do is to make them more readable, secure
</I>&gt;&gt;<i> and adaptable first by using c++ in place of the c-with-thin-c++-paint
</I>&gt;&gt;<i> they currently are coded as. Making them more maintainable, hopefully
</I>&gt;&gt;<i> robust and readable is the main goal. In fact, as we can assume that
</I>&gt;&gt;<i> they will be used as reference by others writing their own helpers,
</I>&gt;&gt;<i> it's in everyone's best interests if they are as readable and compact
</I>&gt;&gt;<i> as possible.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The main benefit of SBuf over std::string is its integration with
</I>&gt;&gt;&gt;&gt;<i> support infrastructure in squid proper (mempools and cachemgr), which
</I>&gt;&gt;&gt;&gt;<i> is definitely too much to add to helpers as well. We'd end up filling
</I>&gt;&gt;&gt;&gt;<i> them with stubs which would make maintaining the build system
</I>&gt;&gt;&gt;&gt;<i> complicated - see how much effort it is to do so for unit tests.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I certainly agree that it is easier to add a few methods to SBuf and
</I>&gt;&gt;&gt;<i> craft a templated encoding loop than it is to make SBufs independent
</I>&gt;&gt;&gt;<i> from memory pools [and cache manager]. The ease of a small change does
</I>&gt;&gt;&gt;<i> not necessarily make it the best long-term solution though. There are
</I>&gt;&gt;&gt;<i> other factors to consider.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> You use existing unit test build difficulties as an argument to avoid
</I>&gt;&gt;&gt;<i> using SBufs in helpers [because helpers will face similar difficulties].
</I>&gt;&gt;&gt;<i> That argument is valid _if_ those build difficulties are inherent in the
</I>&gt;&gt;&gt;<i> SBuf concept. However, if those difficulties are simply SBuf
</I>&gt;&gt;&gt;<i> implementation bugs/deficiencies, then it would be better to address
</I>&gt;&gt;&gt;<i> those SBuf deficiencies than to work around [and exacerbate!] them in
</I>&gt;&gt;&gt;<i> one more place.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Let's consider mempools for instance. Having a build-time, static,
</I>&gt;&gt;<i> mechanism which can prevent linking against mempools is IMO tricky and
</I>&gt;&gt;<i> fragile; and mempools carry with them a lot of extra depedencies (e.g.
</I>&gt;&gt;<i> squid_curtime - it's simple but pervasive).
</I>&gt;&gt;<i> Currently the minimum set for linking against SBuf outside Squid is:
</I>&gt;&gt;<i> base/CharacterSet.{h,cc}
</I>&gt;&gt;<i> base/InstanceId.h
</I>&gt;&gt;<i> MemBlob.{h,cc}
</I>&gt;&gt;<i> OutOfBoundsException.h
</I>&gt;&gt;<i> SBuf.{h,cc}
</I>&gt;&gt;<i> SBufExceptions.{h,cc}
</I>&gt;&gt;<i> tests/stub_debug.cc
</I>&gt;&gt;<i> tests/stub_libmem.cc
</I>&gt;&gt;<i> tests/stub_SBufDetailedStats.cc
</I>&gt;&gt;<i> base/libbase.la
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> So IMO helpers need std::string,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> and Perl $string, and Javascript String. There are many different
</I>&gt;&gt;&gt;<i> helpers with very different needs...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> right. Let me restrict the scope to &quot;the C-ish and C++ helpers we bundle&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> and templated code is the best
</I>&gt;&gt;&gt;&gt;<i> solution I could come up with to avoid having to maintain three
</I>&gt;&gt;&gt;&gt;<i> different implementations of percent-encoding. Suggestions on
</I>&gt;&gt;&gt;&gt;<i> alternate paths to obtain the same objective are of course welcome.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Since Squid is (or should be) using standard encodings, I suspect there
</I>&gt;&gt;&gt;<i> are libraries and modules (for various programming languages) that
</I>&gt;&gt;&gt;<i> already provide appropriate encoding support. We would not have to
</I>&gt;&gt;&gt;<i> maintain any of those implementations.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are. However:
</I>&gt;&gt;<i> - the ones I could find seem to be quite generic, we have different
</I>&gt;&gt;<i> needs in different contexts
</I>&gt;&gt;<i> - impedence mismatch. These are either C or use std::string; this
</I>&gt;&gt;<i> generally means two more data-copies if we wish to use SBuf (or
</I>&gt;&gt;<i> std::string with a custom allocator)
</I>&gt;&gt;<i> - finding one which is generally available on all OSes we care about
</I>&gt;&gt;<i> seems not trivial.
</I>&gt;&gt;<i> - if we don't find one, IIRC bundling was already discarded as an
</I>&gt;&gt;<i> option when talking about relying on boost.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> However, let's assume that our ultimate goal[1] is to ship fast,
</I>&gt;&gt;&gt;<i> production-quality helpers that are built without external dependencies
</I>&gt;&gt;&gt;<i> (i.e., built using Squid libraries) and that Squid code is (or will be)
</I>&gt;&gt;&gt;<i> using SBuf for most string and buffering operations.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Quality helpers are likely to need a variety of string and buffering
</I>&gt;&gt;&gt;<i> operations. Which of the following approaches is better long-term?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> A. Support a growing number of templated algorithms while making SBuf
</I>&gt;&gt;&gt;<i> API more and more interchangeable with std::string (while at the same
</I>&gt;&gt;&gt;<i> time providing a growing number of SBuf methods for raw buffer operations).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> B. Make SBufs and SBuf-driven algorithms easily available in helpers by
</I>&gt;&gt;&gt;<i> making SBuf storage/memory backing (and any other current dependencies
</I>&gt;&gt;&gt;<i> on Squid core) easily replaceable with something that does not need any
</I>&gt;&gt;&gt;<i> integration with Squid core.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> To me, option B looks like the right overall direction.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Could be, but we'd then need to redesign mempools to be stub-able, or
</I>&gt;&gt;<i> templatize SBuf with an allocator and isolate it from mempools (I
</I>&gt;&gt;<i> focus on these as these are the dependency bringing in most baggage.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Given the fact that we won't probably require many common algorithms,
</I>&gt;&gt;<i> I believe that A is not a bad an option as you do.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i>     Francesco
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004473.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
	<LI>Next message: <A HREF="004475.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4476">[ date ]</a>
              <a href="thread.html#4476">[ thread ]</a>
              <a href="subject.html#4476">[ subject ]</a>
              <a href="author.html#4476">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
