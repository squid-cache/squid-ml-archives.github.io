<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Remove cache_peer_domain
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Remove%20cache_peer_domain&In-Reply-To=%3C54CE6EF5.4000407%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="001826.html">
   <LINK REL="Next"  HREF="001592.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Remove cache_peer_domain</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Remove%20cache_peer_domain&In-Reply-To=%3C54CE6EF5.4000407%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Remove cache_peer_domain">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Feb  1 18:22:45 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001826.html">[squid-dev] Build failed in Jenkins: trunk-x64-centos-6-clang #490
</A></li>
        <LI>Next message: <A HREF="001592.html">[squid-dev] [PATCH] Remove cache_peer_domain
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1434">[ date ]</a>
              <a href="thread.html#1434">[ thread ]</a>
              <a href="subject.html#1434">[ subject ]</a>
              <a href="author.html#1434">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The cache_peer_domain directive functionality is also provided through
cache_peer_access.

While this check appears at face value to be simpler than ACLs, the
reality is that:
* the difference is simply the time it takes to initialize and destruct
an on-stack Checklist,
* processing the checks may take longer than ACLs (linked-list of string
comparisons vs single tree lookup)
* ACLs are the common case due to their extra flexibility, and
* extra work is being done per-transaction just to check which of the
two features is in use.

Overall I just dont believe it to be worth keeping. By removing we gain
less code and configuration directives to work around in the long term.

Amos
-------------- next part --------------
=== modified file 'src/CachePeer.h'
--- src/CachePeer.h	2015-01-13 07:25:36 +0000
+++ src/CachePeer.h	2015-02-01 17:07:09 +0000
@@ -5,41 +5,40 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_CACHEPEER_H_
 #define SQUID_CACHEPEER_H_
 
 #include &quot;acl/forward.h&quot;
 #include &quot;base/CbcPointer.h&quot;
 #include &quot;enums.h&quot;
 #include &quot;icp_opcode.h&quot;
 #include &quot;ip/Address.h&quot;
 
 //TODO: remove, it is unconditionally defined and always used.
 #define PEER_MULTICAST_SIBLINGS 1
 
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 
-class CachePeerDomainList;
 class NeighborTypeDomainList;
 class PconnPool;
 class PeerDigest;
 class PeerPoolMgr;
 
 // currently a POD
 class CachePeer
 {
 public:
     u_int index;
     char *name;
     char *host;
     peer_t type;
 
     Ip::Address in_addr;
 
     struct {
         int pings_sent;
         int pings_acked;
         int fetches;
@@ -54,41 +53,40 @@
         time_t last_connect_probe;
         int logged_state;   /* so we can print dead/revived msgs */
         int conn_open;      /* current opened connections */
     } stats;
 
     struct {
         int version;
         int counts[ICP_END+1];
         unsigned short port;
     } icp;
 
 #if USE_HTCP
     struct {
         double version;
         int counts[2];
         unsigned short port;
     } htcp;
 #endif
 
     unsigned short http_port;
-    CachePeerDomainList *peer_domain;
     NeighborTypeDomainList *typelist;
     acl_access *access;
 
     struct {
         bool proxy_only;
         bool no_query;
         bool background_ping;
         bool no_digest;
         bool default_parent;
         bool roundrobin;
         bool weighted_roundrobin;
         bool mcast_responder;
         bool closest_only;
 #if USE_HTCP
         bool htcp;
         bool htcp_oldsquid;
         bool htcp_no_clr;
         bool htcp_no_purge_clr;
         bool htcp_only_clr;
         bool htcp_forward_clr;

=== removed file 'src/CachePeerDomainList.h'
--- src/CachePeerDomainList.h	2015-01-13 07:25:36 +0000
+++ src/CachePeerDomainList.h	1970-01-01 00:00:00 +0000
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_CACHEPEERDOMAINLIST_H_
-#define SQUID_CACHEPEERDOMAINLIST_H_
-
-/// representation of the cache_peer_domain list. POD.
-class CachePeerDomainList
-{
-public:
-    char *domain;
-    bool do_ping;
-    CachePeerDomainList *next;
-};
-
-#endif /* SQUID_CACHEPEERDOMAINLIST_H_ */
-

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-01-29 16:09:11 +0000
+++ src/Makefile.am	2015-02-01 16:41:28 +0000
@@ -268,41 +268,40 @@
 	DescriptorSet.h \
 	SquidConfig.h \
 	SquidConfig.cc
 
 squid_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	AccessLogEntry.cc \
 	AccessLogEntry.h \
 	AsyncEngine.cc \
 	AsyncEngine.h \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	cache_manager.cc \
 	NeighborTypeDomainList.h \
-	CachePeerDomainList.h \
 	CachePeer.h \
 	CacheManager.h \
 	carp.h \
 	carp.cc \
 	cbdata.cc \
 	cbdata.h \
 	ChunkedCodingParser.cc \
 	ChunkedCodingParser.h \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side.h \
 	client_side_reply.cc \
 	client_side_reply.h \
 	client_side_request.cc \
 	client_side_request.h \
 	ClientInfo.h \
 	BodyPipe.cc \
 	BodyPipe.h \

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-01-29 19:05:24 +0000
+++ src/cache_cf.cc	2015-02-01 17:08:05 +0000
@@ -6,41 +6,40 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 03    Configuration File Parsing */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/AclAddress.h&quot;
 #include &quot;acl/AclDenyInfoList.h&quot;
 #include &quot;acl/AclNameList.h&quot;
 #include &quot;acl/AclSizeLimit.h&quot;
 #include &quot;acl/Gadgets.h&quot;
 #include &quot;acl/MethodData.h&quot;
 #include &quot;acl/Tree.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;anyp/UriScheme.h&quot;
 #include &quot;AuthReg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;CachePeer.h&quot;
-#include &quot;CachePeerDomainList.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;CpuAffinityMap.h&quot;
 #include &quot;DiskIO/DiskIOModule.h&quot;
 #include &quot;eui/Config.h&quot;
 #include &quot;ExternalACL.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;ftp/Elements.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;ident/Config.h&quot;
 #include &quot;ip/Intercept.h&quot;
 #include &quot;ip/QosConfig.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;ipc/Kids.h&quot;
 #include &quot;log/Config.h&quot;
 #include &quot;log/CustomLog.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;mgr/ActionPasswordList.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;neighbors.h&quot;
@@ -1951,61 +1950,53 @@
 
     case PEER_SIBLING:
         result = &quot;sibling&quot;;
         break;
 
     case PEER_MULTICAST:
         result = &quot;multicast&quot;;
         break;
 
     default:
         result = &quot;unknown&quot;;
         break;
     }
 
     return result;
 }
 
 static void
 dump_peer(StoreEntry * entry, const char *name, CachePeer * p)
 {
-    CachePeerDomainList *d;
     NeighborTypeDomainList *t;
     LOCAL_ARRAY(char, xname, 128);
 
     while (p != NULL) {
         storeAppendPrintf(entry, &quot;%s %s %s %d %d name=%s&quot;,
                           name,
                           p-&gt;host,
                           neighborTypeStr(p),
                           p-&gt;http_port,
                           p-&gt;icp.port,
                           p-&gt;name);
         dump_peer_options(entry, p);
 
-        for (d = p-&gt;peer_domain; d; d = d-&gt;next) {
-            storeAppendPrintf(entry, &quot;cache_peer_domain %s %s%s\n&quot;,
-                              p-&gt;host,
-                              d-&gt;do_ping ? null_string : &quot;!&quot;,
-                              d-&gt;domain);
-        }
-
         if (p-&gt;access) {
             snprintf(xname, 128, &quot;cache_peer_access %s&quot;, p-&gt;name);
             dump_acl_access(entry, xname, p-&gt;access);
         }
 
         for (t = p-&gt;typelist; t; t = t-&gt;next) {
             storeAppendPrintf(entry, &quot;neighbor_type_domain %s %s %s\n&quot;,
                               p-&gt;host,
                               peer_type_str(t-&gt;type),
                               t-&gt;domain);
         }
 
         p = p-&gt;next;
     }
 }
 
 /**
  * utility function to prevent getservbyname() being called with a numeric value
  * on Windows at least it returns garage results.
  */
@@ -2492,74 +2483,40 @@
 static void
 parse_peer_access(void)
 {
     char *host = NULL;
     CachePeer *p;
 
     if (!(host = ConfigParser::NextToken()))
         self_destruct();
 
     if ((p = peerFindByName(host)) == NULL) {
         debugs(15, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot;, line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: No cache_peer '&quot; &lt;&lt; host &lt;&lt; &quot;'&quot;);
         return;
     }
 
     std::string directive = &quot;peer_access &quot;;
     directive += host;
     aclParseAccessLine(directive.c_str(), LegacyParser, &amp;p-&gt;access);
 }
 
 static void
-parse_hostdomain(void)
-{
-    char *host = NULL;
-    char *domain = NULL;
-
-    if (!(host = ConfigParser::NextToken()))
-        self_destruct();
-
-    while ((domain = ConfigParser::NextToken())) {
-        CachePeerDomainList *l = NULL;
-        CachePeerDomainList **L = NULL;
-        CachePeer *p;
-
-        if ((p = peerFindByName(host)) == NULL) {
-            debugs(15, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot;, line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: No cache_peer '&quot; &lt;&lt; host &lt;&lt; &quot;'&quot;);
-            continue;
-        }
-
-        l = static_cast&lt;CachePeerDomainList *&gt;(xcalloc(1, sizeof(CachePeerDomainList)));
-        l-&gt;do_ping = true;
-
-        if (*domain == '!') {   /* check for !.edu */
-            l-&gt;do_ping = false;
-            ++domain;
-        }
-
-        l-&gt;domain = xstrdup(domain);
-
-        for (L = &amp;(p-&gt;peer_domain); *L; L = &amp;((*L)-&gt;next));
-        *L = l;
-    }
-}
-
-static void
 parse_hostdomaintype(void)
 {
     char *host = NULL;
     char *type = NULL;
     char *domain = NULL;
 
     if (!(host = ConfigParser::NextToken()))
         self_destruct();
 
     if (!(type = ConfigParser::NextToken()))
         self_destruct();
 
     while ((domain = ConfigParser::NextToken())) {
         NeighborTypeDomainList *l = NULL;
         NeighborTypeDomainList **L = NULL;
         CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot;, line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: No cache_peer '&quot; &lt;&lt; host &lt;&lt; &quot;'&quot;);
             return;

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-01-31 16:34:08 +0000
+++ src/cf.data.pre	2015-02-01 17:14:20 +0000
@@ -131,40 +131,47 @@
 DOC_END
 
 NAME: external_refresh_check
 TYPE: obsolete
 DOC_START
 	This option is not yet supported by Squid-3.
 DOC_END
 
 NAME: location_rewrite_program location_rewrite_access location_rewrite_children location_rewrite_concurrency
 TYPE: obsolete
 DOC_START
 	This option is not yet supported by Squid-3.
 DOC_END
 
 NAME: refresh_stale_hit
 TYPE: obsolete
 DOC_START
 	This option is not yet supported by Squid-3.
 DOC_END
 
+# Options removed in 3.6
+NAME: cache_peer_domain cache_host_domain
+TYPE: obsolete
+DOC_START
+	Replace with dstdomain ACLs and cache_peer_access.
+DOC_END
+
 # Options removed in 3.5
 NAME: hierarchy_stoplist
 TYPE: obsolete
 DOC_START
 	Remove this line. Use always_direct or cache_peer_access ACLs instead if you need to prevent cache_peer use.
 DOC_END
 
 # Options removed in 3.4
 NAME: log_access
 TYPE: obsolete
 DOC_START
 	Remove this line. Use acls with access_log directives to control access logging
 DOC_END
 
 NAME: log_icap
 TYPE: obsolete
 DOC_START
 	Remove this line. Use acls with icap_log directives to control icap logging
 DOC_END
 
@@ -3325,87 +3332,54 @@
 			connections. Default request_timeout and
 			server_idle_pconn_timeout values ensure such a
 			configuration.
 	
 	name=xxx	Unique name for the peer.
 			Required if you have multiple peers on the same host
 			but different ports.
 			This name can be used in cache_peer_access and similar
 			directives to dentify the peer.
 			Can be used by outgoing access controls through the
 			peername ACL type.
 	
 	no-tproxy	Do not use the client-spoof TPROXY support when forwarding
 			requests to this peer. Use normal address selection instead.
 			This overrides the spoof_client_ip ACL.
 	
 	proxy-only	objects fetched from the peer will not be stored locally.
 	
 DOC_END
 
-NAME: cache_peer_domain cache_host_domain
-TYPE: hostdomain
-DEFAULT: none
-LOC: none
-DOC_START
-	Use to limit the domains for which a neighbor cache will be
-	queried.
-
-	Usage:
-		cache_peer_domain cache-host domain [domain ...]
-		cache_peer_domain cache-host !domain
-
-	For example, specifying
-
-		cache_peer_domain parent.foo.net	.edu
-
-	has the effect such that UDP query packets are sent to
-	'bigserver' only when the requested object exists on a
-	server in the .edu domain.  Prefixing the domainname
-	with '!' means the cache will be queried for objects
-	NOT in that domain.
-
-	NOTE:	* Any number of domains may be given for a cache-host,
-		  either on the same or separate lines.
-		* When multiple domains are given for a particular
-		  cache-host, the first matched domain is applied.
-		* Cache hosts with no domain restrictions are queried
-		  for all requests.
-		* There are no defaults.
-		* There is also a 'cache_peer_access' tag in the ACL
-		  section.
-DOC_END
-
 NAME: cache_peer_access
 TYPE: peer_access
 DEFAULT: none
 LOC: none
 DOC_START
-	Similar to 'cache_peer_domain' but provides more flexibility by
-	using ACL elements.
+	Use to limit the requests for which a neighbor proxy will be
+	queried. Peers with no restrictions are queried for all requests.
 
 	Usage:
 		cache_peer_access cache-host allow|deny [!]aclname ...
 
 	The syntax is identical to 'http_access' and the other lists of
-	ACL elements.  See the comments for 'http_access' below, or
-	the Squid FAQ (<A HREF="http://wiki.squid-cache.org/SquidFaq/SquidAcl">http://wiki.squid-cache.org/SquidFaq/SquidAcl</A>).
+	ACL elements.  See the comments for 'http_access', or the
+	Squid FAQ (<A HREF="http://wiki.squid-cache.org/SquidFaq/SquidAcl">http://wiki.squid-cache.org/SquidFaq/SquidAcl</A>).
 DOC_END
 
 NAME: neighbor_type_domain
 TYPE: hostdomaintype
 DEFAULT: none
 DEFAULT_DOC: The peer type from cache_peer directive is used for all requests to that peer.
 LOC: none
 DOC_START
 	Modify the cache_peer neighbor type when passing requests
 	about specific domains to the peer.
 
 	Usage:
 		 neighbor_type_domain neighbor parent|sibling domain domain ...
 
 	For example:
 		cache_peer foo.example.com parent 3128 3130
 		neighbor_type_domain foo.example.com sibling .au .de
 
 	The above configuration treats all requests to foo.example.com as a
 	parent proxy unless the request is for a .au or .de ccTLD domain name.

=== modified file 'src/neighbors.cc'
--- src/neighbors.cc	2015-01-29 16:09:11 +0000
+++ src/neighbors.cc	2015-02-01 17:06:32 +0000
@@ -1,36 +1,35 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 15    Neighbor Routines */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;CacheDigest.h&quot;
 #include &quot;CachePeer.h&quot;
-#include &quot;CachePeerDomainList.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;comm/ConnOpener.h&quot;
 #include &quot;event.h&quot;
 #include &quot;FwdState.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;htcp.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;icmp/net_db.h&quot;
 #include &quot;ICP.h&quot;
 #include &quot;int.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;ipcache.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;multicast.h&quot;
 #include &quot;neighbors.h&quot;
 #include &quot;NeighborTypeDomainList.h&quot;
 #include &quot;pconn.h&quot;
 #include &quot;PeerDigest.h&quot;
@@ -120,85 +119,68 @@
         if (0 == matchDomainName(request-&gt;GetHost(), d-&gt;domain))
             if (d-&gt;type != PEER_NONE)
                 return d-&gt;type;
     }
 #if PEER_MULTICAST_SIBLINGS
     if (p-&gt;type == PEER_MULTICAST)
         if (p-&gt;options.mcast_siblings)
             return PEER_SIBLING;
 #endif
 
     return p-&gt;type;
 }
 
 /**
  * \return Whether it is appropriate to fetch REQUEST from PEER.
  */
 bool
 peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 {
 
-    const CachePeerDomainList *d = NULL;
     assert(request != NULL);
 
     if (neighborType(p, request) == PEER_SIBLING) {
 #if PEER_MULTICAST_SIBLINGS
         if (p-&gt;type == PEER_MULTICAST &amp;&amp; p-&gt;options.mcast_siblings &amp;&amp;
                 (request-&gt;flags.noCache || request-&gt;flags.refresh || request-&gt;flags.loopDetected || request-&gt;flags.needValidation))
             debugs(15, 2, &quot;peerAllowedToUse(&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot;, &quot; &lt;&lt; request-&gt;GetHost() &lt;&lt; &quot;) : multicast-siblings optimization match&quot;);
 #endif
         if (request-&gt;flags.noCache)
             return false;
 
         if (request-&gt;flags.refresh)
             return false;
 
         if (request-&gt;flags.loopDetected)
             return false;
 
         if (request-&gt;flags.needValidation)
             return false;
     }
 
     // CONNECT requests are proxy requests. Not to be forwarded to origin servers.
     // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this CachePeer.
     if (p-&gt;options.originserver &amp;&amp; request-&gt;method == Http::METHOD_CONNECT &amp;&amp; request-&gt;port != p-&gt;in_addr.port())
         return false;
 
-    if (p-&gt;peer_domain == NULL &amp;&amp; p-&gt;access == NULL)
-        return true;
-
-    bool do_ping = false;
-    for (d = p-&gt;peer_domain; d; d = d-&gt;next) {
-        if (0 == matchDomainName(request-&gt;GetHost(), d-&gt;domain)) {
-            do_ping = d-&gt;do_ping;
-            break;
-        }
-
-        do_ping = !d-&gt;do_ping;
-    }
-
-    if (p-&gt;peer_domain &amp;&amp; !do_ping)
-        return false;
-
     if (p-&gt;access == NULL)
-        return do_ping;
+        return true;
 
     ACLFilledChecklist checklist(p-&gt;access, request, NULL);
 
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
 /* Return TRUE if it is okay to send an ICP request to this CachePeer.   */
 static int
 peerWouldBePinged(const CachePeer * p, HttpRequest * request)
 {
     if (p-&gt;icp.port == 0)
         return 0;
 
     if (p-&gt;options.no_query)
         return 0;
 
     if (p-&gt;options.mcast_responder)
         return 0;
 
     if (p-&gt;n_addresses == 0)
@@ -1160,48 +1142,40 @@
     }
 
     if (p-&gt;stats.probe_start != 0 &amp;&amp;
             squid_curtime - p-&gt;stats.probe_start &gt; Config.Timeout.deadPeer) {
         debugs(15, 8, &quot;neighborUp: DOWN (dead): &quot; &lt;&lt; p-&gt;host &lt;&lt; &quot; (&quot; &lt;&lt; p-&gt;in_addr &lt;&lt; &quot;)&quot;);
         return 0;
     }
 
     debugs(15, 8, &quot;neighborUp: UP: &quot; &lt;&lt; p-&gt;host &lt;&lt; &quot; (&quot; &lt;&lt; p-&gt;in_addr &lt;&lt; &quot;)&quot;);
     return 1;
 }
 
 void
 peerDestroy(void *data)
 {
     CachePeer *p = (CachePeer *)data;
 
     if (p == NULL)
         return;
 
-    CachePeerDomainList *nl = NULL;
-
-    for (CachePeerDomainList *l = p-&gt;peer_domain; l; l = nl) {
-        nl = l-&gt;next;
-        safe_free(l-&gt;domain);
-        xfree(l);
-    }
-
     safe_free(p-&gt;host);
     safe_free(p-&gt;name);
     safe_free(p-&gt;domain);
 #if USE_CACHE_DIGESTS
 
     cbdataReferenceDone(p-&gt;digest);
 #endif
 }
 
 void
 peerNoteDigestGone(CachePeer * p)
 {
 #if USE_CACHE_DIGESTS
     cbdataReferenceDone(p-&gt;digest);
 #endif
 }
 
 static void
 peerDNSConfigure(const ipcache_addrs *ia, const Dns::LookupDetails &amp;, void *data)
 {
@@ -1588,50 +1562,48 @@
 
     if (p-&gt;options.originserver)
         storeAppendPrintf(sentry, &quot; originserver&quot;);
 
     if (p-&gt;domain)
         storeAppendPrintf(sentry, &quot; forceddomain=%s&quot;, p-&gt;domain);
 
     if (p-&gt;connection_auth == 0)
         storeAppendPrintf(sentry, &quot; connection-auth=off&quot;);
     else if (p-&gt;connection_auth == 1)
         storeAppendPrintf(sentry, &quot; connection-auth=on&quot;);
     else if (p-&gt;connection_auth == 2)
         storeAppendPrintf(sentry, &quot; connection-auth=auto&quot;);
 
     storeAppendPrintf(sentry, &quot;\n&quot;);
 }
 
 static void
 dump_peers(StoreEntry * sentry, CachePeer * peers)
 {
-    CachePeer *e = NULL;
     char ntoabuf[MAX_IPSTRLEN];
-    CachePeerDomainList *d = NULL;
     icp_opcode op;
     int i;
 
     if (peers == NULL)
         storeAppendPrintf(sentry, &quot;There are no neighbors installed.\n&quot;);
 
-    for (e = peers; e; e = e-&gt;next) {
+    for (CachePeer *e = peers; e; e = e-&gt;next) {
         assert(e-&gt;host != NULL);
         storeAppendPrintf(sentry, &quot;\n%-11.11s: %s\n&quot;,
                           neighborTypeStr(e),
                           e-&gt;name);
         storeAppendPrintf(sentry, &quot;Host       : %s/%d/%d\n&quot;,
                           e-&gt;host,
                           e-&gt;http_port,
                           e-&gt;icp.port);
         storeAppendPrintf(sentry, &quot;Flags      :&quot;);
         dump_peer_options(sentry, e);
 
         for (i = 0; i &lt; e-&gt;n_addresses; ++i) {
             storeAppendPrintf(sentry, &quot;Address[%d] : %s\n&quot;, i,
                               e-&gt;addresses[i].toStr(ntoabuf,MAX_IPSTRLEN) );
         }
 
         storeAppendPrintf(sentry, &quot;Status     : %s\n&quot;,
                           neighborUp(e) ? &quot;Up&quot; : &quot;Down&quot;);
         storeAppendPrintf(sentry, &quot;FETCHES    : %d\n&quot;, e-&gt;stats.fetches);
         storeAppendPrintf(sentry, &quot;OPEN CONNS : %d\n&quot;, e-&gt;stats.conn_open);
@@ -1676,51 +1648,40 @@
 
                     storeAppendPrintf(sentry, &quot;    %12.12s : %8d %3d%%\n&quot;,
                                       icp_opcode_str[op],
                                       e-&gt;icp.counts[op],
                                       Math::intPercent(e-&gt;icp.counts[op], e-&gt;stats.pings_acked));
                 }
 
 #if USE_HTCP
 
             }
 
 #endif
 
         }
 
         if (e-&gt;stats.last_connect_failure) {
             storeAppendPrintf(sentry, &quot;Last failed connect() at: %s\n&quot;,
                               Time::FormatHttpd(e-&gt;stats.last_connect_failure));
         }
 
-        if (e-&gt;peer_domain != NULL) {
-            storeAppendPrintf(sentry, &quot;DOMAIN LIST: &quot;);
-
-            for (d = e-&gt;peer_domain; d; d = d-&gt;next) {
-                storeAppendPrintf(sentry, &quot;%s%s &quot;,
-                                  d-&gt;do_ping ? null_string : &quot;!&quot;, d-&gt;domain);
-            }
-
-            storeAppendPrintf(sentry, &quot;\n&quot;);
-        }
-
         storeAppendPrintf(sentry, &quot;keep-alive ratio: %d%%\n&quot;, Math::intPercent(e-&gt;stats.n_keepalives_recv, e-&gt;stats.n_keepalives_sent));
     }
 }
 
 #if USE_HTCP
 void
 neighborsHtcpReply(const cache_key * key, HtcpReplyData * htcp, const Ip::Address &amp;from)
 {
     StoreEntry *e = Store::Root().get(key);
     MemObject *mem = NULL;
     CachePeer *p;
     peer_t ntype = PEER_NONE;
     debugs(15, 6, &quot;neighborsHtcpReply: &quot; &lt;&lt;
            (htcp-&gt;hit ? &quot;HIT&quot; : &quot;MISS&quot;) &lt;&lt; &quot; &quot; &lt;&lt;
            storeKeyText(key)  );
 
     if (NULL != e)
         mem = e-&gt;mem_obj;
 
     if ((p = whichPeer(from)))

</PRE>
















































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001826.html">[squid-dev] Build failed in Jenkins: trunk-x64-centos-6-clang #490
</A></li>
	<LI>Next message: <A HREF="001592.html">[squid-dev] [PATCH] Remove cache_peer_domain
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1434">[ date ]</a>
              <a href="thread.html#1434">[ thread ]</a>
              <a href="subject.html#1434">[ subject ]</a>
              <a href="author.html#1434">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
