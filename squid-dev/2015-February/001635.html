<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] sslproxy_options in peek-and-splice mode
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20sslproxy_options%20in%20peek-and-splice%20mode&In-Reply-To=%3C54DCCC05.7060205%40users.sourceforge.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="001634.html">
   <LINK REL="Next"  HREF="001639.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] sslproxy_options in peek-and-splice mode</H1>
    <B>Tsantilas Christos</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20sslproxy_options%20in%20peek-and-splice%20mode&In-Reply-To=%3C54DCCC05.7060205%40users.sourceforge.net%3E"
       TITLE="[squid-dev] [PATCH] sslproxy_options in peek-and-splice mode">chtsanti at users.sourceforge.net
       </A><BR>
    <I>Thu Feb 12 15:51:33 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001634.html">[squid-dev] [PATCH] sslproxy_options in peek-and-splice mode
</A></li>
        <LI>Next message: <A HREF="001639.html">[squid-dev] [PATCH] sslproxy_options in peek-and-splice mode
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1635">[ date ]</a>
              <a href="thread.html#1635">[ thread ]</a>
              <a href="subject.html#1635">[ subject ]</a>
              <a href="author.html#1635">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/12/2015 05:33 PM, Amos Jeffries wrote:
&gt;<i> On 13/02/2015 3:34 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;<i> On 02/12/2015 01:48 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 12/02/2015 11:31 p.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;&gt;<i> On 02/11/2015 09:48 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> On 12/02/2015 12:45 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> On 02/11/2015 01:54 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> On 9/02/2015 6:43 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> Bug description:
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>       - Squid sslproxy_options deny the use of TLSv1_2 SSL protocol:
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>                sslproxy_options NO_TLSv1_2
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>       - Squid uses peek mode for bumped connections.
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>       - Web client sends an TLSv1_2 hello message and squid in peek
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> mode,
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> forwards the client hello message to server
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>       - Web server respond with an TLSv1_2 hello message
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>       - Squid while parsing server hello message aborts with an error
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> because  sslproxy_options deny the use ot TLSv1_2 protocol.
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> This patch fixes squid to ignore sslproxy_options in peek or stare
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> bumping mode.
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> As I understand it the action of applying the options to the context
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> removes from the context cipher references etc which are not
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> possible.
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> Since peek and stare are non-final states I can easily imagine that
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> OpenSSL library negotiates ciphers which the options would otherwise
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> prohibit. Then when the options get applied to the context it find
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> itself using an algorithm which does not exist.
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> The context SSL_CTX objects are bases to create the SSL objects which
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> are responsible for the negotiation with the other side (server in
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> this
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> case).
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> The SSL created, inherits the options from CTXa nd we are adding our
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> options to SSL object.
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> The SSL library will use these options to build client hello message,
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> parse server hello message and select algorithms/ciphers and other
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> features to establish SSL connection.
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> In my patch the options applied to the squid client SSL objects
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> immediately after created, in the case of bump-server-first, or
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> bump-client-first.
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> In the cases of peek or stare we are not setting any options. This is
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> because we are sending a hello message which is the same or similar
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> with
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> the client hello message, so we can not apply options. Else the
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> peek or
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> stare will fail...
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> What I means is the code flow is roughly like this yes?
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> 1) bump
</I>&gt;&gt;&gt;&gt;&gt;<i> 2) splice
</I>&gt;&gt;&gt;&gt;&gt;<i> 3) peek then bump
</I>&gt;&gt;&gt;&gt;&gt;<i> 4) stare then bump
</I>&gt;&gt;&gt;&gt;&gt;<i> 5) peek then splice
</I>&gt;&gt;&gt;&gt;&gt;<i> 6) stare then splice
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> In which of those cases are the options set?
</I>&gt;&gt;&gt;&gt;&gt;<i>     all cases ending in bump or splice.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The important factor here is the bumping step.
</I>&gt;&gt;&gt;&gt;<i> in bump case (1,3,4)
</I>&gt;&gt;&gt;&gt;<i>    - if the decision is to bump in bumpStep1 or bumpStep2 then the squid
</I>&gt;&gt;&gt;&gt;<i> SSL client options are set.
</I>&gt;&gt;&gt;&gt;<i>    - If the decision for bumping taken in bumpStep3, the the squid SSL
</I>&gt;&gt;&gt;&gt;<i> client options are NOT set.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> in splice case (2,5 or 6) :
</I>&gt;&gt;&gt;&gt;<i>    -  if we splice on bumpStep1 or on bumpStep2, then we are not using
</I>&gt;&gt;&gt;&gt;<i> squid SSL client code at all, so the options does not play any  role on
</I>&gt;&gt;&gt;&gt;<i> this case.
</I>&gt;&gt;&gt;&gt;<i>    - If we splice on bumpStep3 we have use squid SSL client, but in this
</I>&gt;&gt;&gt;&gt;<i> case the options are not set.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> After the bumpStep2 completed we have received the client hello message,
</I>&gt;&gt;&gt;&gt;<i> but we do not sent any response (server hello). At the same time we are
</I>&gt;&gt;&gt;&gt;<i> starting to initiate the connection to the SSL server. This is mean that
</I>&gt;&gt;&gt;&gt;<i> we are going to set SSL client hello message which is depends on SSL
</I>&gt;&gt;&gt;&gt;<i> client code. So:
</I>&gt;&gt;&gt;&gt;<i>     - If we know that we will going to bump the connection, we can safely
</I>&gt;&gt;&gt;&gt;<i> set SSL client options. This is because the squid SSL client will
</I>&gt;&gt;&gt;&gt;<i> initiate a normal SSL connection.
</I>&gt;&gt;&gt;&gt;<i>     - If we are going to stare, or peek then the client hello message we
</I>&gt;&gt;&gt;&gt;<i> are going to sent must be similar to the client-to-squid SSL hello
</I>&gt;&gt;&gt;&gt;<i> message. In this case we can not control SSL features using options,
</I>&gt;&gt;&gt;&gt;<i> else the SSL negotiation will fail.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So you're saying the src/ssl/PeerConnector.cc else-condition never gets
</I>&gt;&gt;&gt;<i> run after a peek and/or stare ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do you mean the &quot;if (csd-&gt;sslBumpMode == Ssl::bumpPeek ||
</I>&gt;&gt;<i> csd-&gt;sslBumpMode == Ssl::bumpStare)&quot; ?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I mean the:
</I>&gt;<i>
</I>&gt;<i>       } else {
</I>&gt;<i> +        // Set client SSL options
</I>&gt;<i> +        SSL_set_options(ssl, ::Config.ssl_client.parsedOptions);
</I>&gt;<i> +
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes the  &quot;else&quot; never gets run when peek or stare mode selected in
</I>&gt;&gt;<i> bumpStep2 bumping step.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Then please add a Must(step &lt;= 2) check at the start of that else
</I>&gt;&gt;&gt;<i> condition right before setting the SSL client options. If that works
</I>&gt;&gt;&gt;<i> properly I am happy for this to go in.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Requires a code like the following:
</I>&gt;&gt;<i> Must(csd-&gt;sslServerBump()-&gt;step&lt;=Ssl::bumpStep2);
</I>&gt;<i>
</I>&gt;<i> Specifically:
</I>&gt;<i>
</I>&gt;<i> Must(
</I>&gt;<i>       !csd-&gt;sslServerBump() ||
</I>&gt;<i>       csd-&gt;sslServerBump()-&gt;step &lt;= Ssl::bumpStep2
</I>&gt;<i>   );
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is will not work. In client-first bumping mode or in server-first
</I>&gt;&gt;<i> bumping mode where we are not applying the peek-and-splice procedure the
</I>&gt;&gt;<i> step is not updated.
</I>&gt;<i>
</I>&gt;<i> Which would make step 0 or 1 for client-first right? that is fine.
</I>&gt;<i>
</I>&gt;<i> For server-first it does need updating at the point the server is given
</I>&gt;<i> data. A jump right to step 3, or even a new &quot;sslBumpStepServerFirst&quot;
</I>&gt;<i> value at the end of the enum.
</I>
Exactly.
But why do you beleive this Must is needed?  Specially inside &quot;else&quot; is 
completely without any interest for development or debugging. Even if 
for a reason this is not set correctly, it will not cause any problem.

The csd-&gt;sslServerBump()-&gt;step is set to Ssl::bumpStep3 in a clearly 
later step, inside Ssl::PeerConnector::checkForPeekAndSplice method, 
which called from Ssl::PeerConnector::handleNegotiateError.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Amos
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i>
</I>
</PRE>

















































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001634.html">[squid-dev] [PATCH] sslproxy_options in peek-and-splice mode
</A></li>
	<LI>Next message: <A HREF="001639.html">[squid-dev] [PATCH] sslproxy_options in peek-and-splice mode
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1635">[ date ]</a>
              <a href="thread.html#1635">[ thread ]</a>
              <a href="subject.html#1635">[ subject ]</a>
              <a href="author.html#1635">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
