<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] HTTP Response Parser upgrade
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Response%20Parser%20upgrade&In-Reply-To=%3C54C1FF94.1000202%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="001322.html">
   <LINK REL="Next"  HREF="001338.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] HTTP Response Parser upgrade</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20HTTP%20Response%20Parser%20upgrade&In-Reply-To=%3C54C1FF94.1000202%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] HTTP Response Parser upgrade">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Jan 23 08:00:20 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001322.html">[squid-dev] [PATCH] HTTP Response Parser upgrade
</A></li>
        <LI>Next message: <A HREF="001338.html">[squid-dev] [PATCH] HTTP Response Parser upgrade
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1323">[ date ]</a>
              <a href="thread.html#1323">[ thread ]</a>
              <a href="subject.html#1323">[ subject ]</a>
              <a href="author.html#1323">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 23/01/2015 6:47 a.m., Alex Rousskov wrote:
&gt;<i> On 01/20/2015 06:58 AM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Updated patch attached resolving the issues found by coadvisor in
</I>&gt;&gt;<i> the original.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +size_t +Client::needBufferSpace(const SBuf &amp;readBuf, const
</I>&gt;&gt;<i> size_t minSpace) const +{ +    size_t space =
</I>&gt;&gt;<i> readBuf.spaceSize(); // available space w/o heroic measures
</I>&gt;<i> 
</I>&gt;<i> If the above line is the only readBuf usage in this method, pass 
</I>&gt;<i> readBuf.spaceSize() as a parameter instead of the whole buffer.
</I>&gt;<i> 
</I>
Done.

&gt;<i> 
</I>&gt;&gt;<i> +    if (space &lt; minSpace) { +        const size_t maxSpace =
</I>&gt;&gt;<i> SBuf::maxSize; // absolute best +        space = min(minSpace,
</I>&gt;&gt;<i> maxSpace); // do not promise more than asked +    }
</I>&gt;<i> 
</I>&gt;<i> Here and elsewhere in Client::needBufferSpace(), the returned space
</I>&gt;<i> size may be lower than minSpace. s/minSpace/wantedSpace/ or
</I>&gt;<i> something like that.
</I>&gt;<i> 
</I>&gt;&gt;<i> +         * If the pipe is totally full, don't register the read
</I>&gt;&gt;<i> handler. +         * The BodyPipe will call our
</I>&gt;&gt;<i> noteMoreBodySpaceAvailable() method +         * when it has free
</I>&gt;&gt;<i> space again.
</I>&gt;<i> 
</I>&gt;<i> The above comment does not match the code. The code does not deal
</I>&gt;<i> with read handler registration, only size calculations.
</I>&gt;<i> 
</I>
Removed that paragraph.

&gt;<i> 
</I>&gt;&gt;<i> +        size_t adaptation_space = +
</I>&gt;&gt;<i> virginBodyDestination-&gt;buf().potentialSpaceSize();
</I>&gt;<i> 
</I>&gt;<i> Make const if possible.
</I>
Done.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    /// determine how much space the buffer needs to reserve +
</I>&gt;&gt;<i> size_t needBufferSpace(const SBuf &amp;readBuf, const size_t
</I>&gt;&gt;<i> minSpace) const;
</I>&gt;<i> 
</I>&gt;<i> need+something implies a notification or state changing method,
</I>&gt;<i> which is not what this method is about. Based on the caller, I
</I>&gt;<i> suggest to
</I>&gt;<i> 
</I>&gt;<i> s/needBufferSpace/calcReadSize/ or s/needBufferSpace/readSize/
</I>&gt;<i> 
</I>
While the current caller is only in http.cc, this is intended for use
by all Client child classes in their own ways.

I'm going with calcBufferSpaceToReserve() for now.

&gt;<i> 
</I>&gt;&gt;<i> void HttpStateData::readReply(const CommIoCbParams &amp;io) {
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    assert(!flags.do_next_read); // XXX: should have been set
</I>&gt;&gt;<i> false by mayReadVirginBody()
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    assert(Comm::IsConnOpen(serverConnection)); +
</I>&gt;&gt;<i> assert(io.conn-&gt;fd == serverConnection-&gt;fd);
</I>&gt;<i> 
</I>&gt;<i> These are all new asserts in an async job callback. Should we use 
</I>&gt;<i> Must()s instead to avoid crashing the whole Squid process when
</I>&gt;<i> dealing with what seems to be a transaction-specific problem?
</I>&gt;<i> 
</I>
Right. Fixed.

&gt;<i> 
</I>&gt;&gt;<i> +    // how much we want to read +    const int read_size =
</I>&gt;&gt;<i> needBufferSpace(inBuf, (limitBuffer - inBuf.length()));
</I>&gt;<i> 
</I>&gt;<i> Unsigned-&gt;signed conversion. Can you use size_t for read_size?
</I>&gt;<i> 
</I>&gt;&gt;<i> +    if (read_size &lt; 1) {
</I>&gt;<i> 
</I>&gt;<i> ... and then convert this to !read_size or (read_size == 0) for
</I>&gt;<i> clarity?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    /// amount of message payload/body received so far. +
</I>&gt;&gt;<i> int64_t payloadSeen; +    /// positive when we read more than we
</I>&gt;&gt;<i> wanted +    int64_t payloadTruncated;
</I>&gt;<i> 
</I>&gt;<i> Have you considered making these unsigned?
</I>&gt;<i> 
</I>
I did. We end up with a great number of casting back to signed values
for use in math calculations and if-conditionals when these members
interact with adapted, store, and memory object members. Ideally all
those other parts should be fixed, but that is outside scope of this
patch.


&gt;<i> 
</I>&gt;&gt;<i> +    /// parse scan to find the mime headers block for current
</I>&gt;&gt;<i> message +    bool findMimeBlock(const char *which, size_t
</I>&gt;&gt;<i> limit);
</I>&gt;<i> 
</I>&gt;<i> Find is a usually a const method. This method does a lot more than
</I>&gt;<i> just finding MIME headers. To fix that and to supply information
</I>&gt;<i> that the method name does not already reveal, I would do:
</I>&gt;<i> 
</I>&gt;<i> /// returns whether the header was successfully parsed bool
</I>&gt;<i> parseMimeHeader(const char *headerKind, const size_t sizeLimit);
</I>&gt;<i> 
</I>
I've adjusted the documentation to say what state changes happen on true.


I do object to the use of &quot;header&quot; other than as a modifier to the
named mime block type like I had it. This function does nothing
involving the &quot;header&quot; level of syntax/tokens in its current incarnation.

It finds a MIME block/segment terminator up to a limited distance into
the I/O buffer, and extracts the preceeding octets into an SBuf for
*later* code to parse.

One day, when the headers actually are parsed here, I do intend to
rename it. But until then it would be false and slightly confusing
documentation to imply a full parse like the other methods in this class.

NP: I would be using Tokenizer for this instead of headersEnd(),
except that Tokenizer has no way to search for multi-byte
delimiter/magic yet and merging it with headersEnd() is just as
premature as making this method action the parsing of the header lines.

Would you accept &quot;identify&quot; instead of &quot;find&quot; ?
 or maybe &quot;grab&quot; is better?


NP: just realized the new form was also dropping ICY mime header
blocks. Fixed that too.


&gt;<i> Note that the limit parameter is const.
</I>&gt;<i> 
</I>
Fixed.

&gt;<i> 
</I>&gt;&gt;<i> +        int64_t mimeHeaderBytes = 0; +        // XXX: c_str()
</I>&gt;&gt;<i> reallocates. performance regression. +        if
</I>&gt;&gt;<i> ((mimeHeaderBytes = headersEnd(buf_.c_str(), buf_.length())) ==
</I>&gt;&gt;<i> 0) { +            if (buf_.length()+firstLineSize() &gt;= limit) { +
</I>&gt;&gt;<i> debugs(33, 5, &quot;Too large &quot; &lt;&lt; which); +
</I>&gt;&gt;<i> parseStatusCode = Http::scHeaderTooLarge; +
</I>&gt;&gt;<i> parsingStage_ = HTTP_PARSE_DONE; +            } else +
</I>&gt;&gt;<i> debugs(33, 5, &quot;Incomplete &quot; &lt;&lt; which &lt;&lt; &quot;, waiting for end of
</I>&gt;&gt;<i> headers&quot;); +            return false; +        } +
</I>&gt;&gt;<i> mimeHeaderBlock_ = buf_.consume(mimeHeaderBytes); +
</I>&gt;&gt;<i> debugs(74, 5, &quot;mime header (0-&quot; &lt;&lt; mimeHeaderBytes &lt;&lt; &quot;) {&quot; &lt;&lt;
</I>&gt;&gt;<i> mimeHeaderBlock_ &lt;&lt; &quot;}&quot;);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The above is better written as
</I>&gt;<i> 
</I>&gt;<i> // XXX: c_str() reallocates. performance regression. if (const
</I>&gt;<i> int64_t mimeHeaderBytes = ...) { mimeHeaderBlock_ =
</I>&gt;<i> buf_.consume(mimeHeaderBytes); debugs(...); } else { ... return
</I>&gt;<i> false; }
</I>&gt;<i> 
</I>&gt;<i> but there is more that needs to be done in the above code:
</I>&gt;<i> 
</I>&gt;&gt;<i> +    // Squid could handle these headers, but admin does not want
</I>&gt;&gt;<i> to +    if (messageHeaderSize() &gt;= limit) { +        debugs(33,
</I>&gt;&gt;<i> 5, &quot;Too large &quot; &lt;&lt; which); +        parseStatusCode =
</I>&gt;&gt;<i> Http::scHeaderTooLarge; +        return false; +    }
</I>&gt;<i> 
</I>&gt;<i> This should be rewritten to go before we initialize
</I>&gt;<i> mimeHeaderBlock_ IMO. Otherwise, the damage of keeping the
</I>&gt;<i> admin-prohibited header is already done.
</I>&gt;<i> 
</I>
Done.

NP: This will prevent the ERR_TOO_BIG and cache.log level 11,2
displaying the mime block as part of the message when its present but
outside the desired size range.



&gt;&gt;<i> +const int 
</I>&gt;&gt;<i> +Http::One::ResponseParser::parseResponseStatusAndReason() +{ +
</I>&gt;&gt;<i> if (buf_.isEmpty()) +        return 0; +
</I>&gt;<i> 
</I>&gt;<i> Remove this check (and fix the tokenizer if it cannot handle empty
</I>&gt;<i> buffers).
</I>&gt;<i> 
</I>
Done.

&gt;&gt;<i> +        // NP: search space is &gt;3 to get terminator character) +
</I>&gt;&gt;<i> if(!tok.prefix(status, CharacterSet::DIGIT, 4)) +
</I>&gt;&gt;<i> return -1; // invalid status +        // NOTE: multiple SP or
</I>&gt;&gt;<i> non-SP bytes between version and status code are invalid. +
</I>&gt;&gt;<i> if (tok.atEnd()) +            return 0; // need more to be sure
</I>&gt;&gt;<i> we have it all +        if(!tok.skip(' ')) +            return
</I>&gt;&gt;<i> -1; // invalid status, a single SP terminator required + +
</I>&gt;&gt;<i> debugs(74, 6, &quot;found string status-code=&quot; &lt;&lt; status); + +
</I>&gt;&gt;<i> // get the actual numeric value of the 0-3 digits we found +
</I>&gt;&gt;<i> ::Parser::Tokenizer t2(status); +        int64_t statusValue; +
</I>&gt;&gt;<i> if (!t2.int64(statusValue)) +            return -1; // ouch.
</I>&gt;&gt;<i> digits not forming a valid number? +        debugs(74, 6, &quot;found
</I>&gt;&gt;<i> int64 status-code=&quot; &lt;&lt; statusValue); +        if (statusValue &lt; 0
</I>&gt;&gt;<i> || statusValue &gt; 999) +            return -1; // ouch. digits not
</I>&gt;&gt;<i> within valid status code range.
</I>&gt;<i> 
</I>&gt;<i> This sequence does not make sense to me: Incomplete status should
</I>&gt;<i> be treated the same as early atEnd(), but the former is treated as
</I>&gt;<i> an invalid status. 4-digit status should be considered as invalid
</I>&gt;<i> but it is not. Numeric value of 0 digits?! Etc., etc. It feels like
</I>&gt;<i> you are still parsing using low-level C function calls, not a
</I>&gt;<i> Tokenizer that we worked so hard to build!
</I>&gt;<i> 
</I>
Yesterday doing the request-line parser I found a bug in
Tokenizer::prefix where it was returning the entire buffer to the
caller if the match happened to be same size as the limit.

It seems I was working around that with the limit of 4, though I
didn't realize it at the time (no status-line unit tests :-( ).


&gt;<i> The correct sequence should be similar to these lines:
</I>&gt;<i> 
</I>&gt;<i> if (tok.prefix(status, CharacterSet::DIGIT, 3) &amp;&amp; tok.skip(' ')) 
</I>&gt;<i> debugs(74, 6, &quot;found string status-code=&quot; &lt;&lt; status); else if
</I>&gt;<i> (tok.atEnd()) return 0; // good so far but need more to finish 
</I>&gt;<i> else return -1; // invalid status
</I>&gt;<i> 
</I>
Done, and ...


&gt;<i> However, if Tokenizer integer parsing interface were written
</I>&gt;<i> correctly, the above would have actually looked close to this:
</I>&gt;<i> 
</I>
&lt;snip&gt;
&gt;<i> 
</I>&gt;<i> uint64_t status; if (tok.uint64(status, 3, base10) &amp;&amp; tok.skip('
</I>&gt;<i> ')) debugs(74, 6, &quot;found status-code=&quot; &lt;&lt; status); else if
</I>&gt;<i> (tok.atEnd()) return 0; // good so far but need more to finish 
</I>&gt;<i> else return -1; // invalid status
</I>&gt;<i> 
</I>
... using this style.


Added a limit as rightmost parameter to tok.int64 method.

I also added a boolean to make it reject +/- symbols.

&gt;<i> 
</I>&gt;<i> The last form (with a size limit for uint64) allows the Tokenizer
</I>&gt;<i> caller to terminate parsing earlier, without waiting for the end of
</I>&gt;<i> all-digit input, but I am not sure that is a common need.
</I>&gt;<i> 
</I>&gt;<i> I urge you to fix Tokenizer integer parsing and rewrite the parsing
</I>&gt;<i> code.
</I>
Done.

&gt;<i> 
</I>&gt;<i> That is all I had time for today. I would have to come back to
</I>&gt;<i> this later. Sorry.
</I>&gt;<i> 
</I>
Thank you very much.

&gt;<i> 
</I>&gt;&gt;<i> * This has now had several hours of regular web browsing by
</I>&gt;&gt;<i> myself (YouTube, Facebook, some news sites, and the Squid sites)
</I>&gt;&gt;<i> with nothing noticably going wrong.
</I>&gt;<i> 
</I>&gt;<i> Any ICAP tests? The HTTP-ICAP interaction has been a source of many
</I>&gt;<i> bugs before and your patch changes the relevant code. If you have
</I>&gt;<i> not tested it, please do (or ask others to do it).
</I>
No the ICAP related code is not touched. It still uses the HttpMsg
parser functions and its own original buffering. These changes only
touch the server socket (virgin reply) buffer I/O and parse function.

I was very careful about checking for that separation before going
beyond the I/O buffer conversion stage.

&gt;<i> 
</I>&gt;&gt;<i> * Polygraph shows a 7 RPS performance loss (0.36%), with trunk
</I>&gt;&gt;<i> having +/-2 RPS (0.1%) normal fluctuation. I believe this is from
</I>&gt;&gt;<i> the transitional regression to data-copy into MemBuf for chunked
</I>&gt;&gt;<i> coding.
</I>&gt;<i> 
</I>&gt;<i> Did Polygraph actually use chunked responses in these tests?
</I>
Unsure, but I think so.

Amos
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUwf+TAAoJELJo5wb/XPRjw+QH/iHzTTe8kSakrQKp3OIjavSg
HHAIatnuyuJg9/iyePC/rIW+gjHshntOw+QpAB2F++yiQyVhR3NWVDWutUZNL1zr
mR+nxZon/+eX7TN/sKHBrVmglqAzpnzn89CQdpGXs7G5NeIc8Dew1PC5FnulQTo6
SI4nvJHgs6VNsiWTaK9130/b/YsAziStFAPbIH2lVWUHr0YalVioi6EpqhLZlaLs
A6NEsTAQNr2XLdz24NALn780WdCdyV7PudK41cQpqKNLqoOY+hwG+Ze9Isf+9Eow
L2blRYSAN0Z0i5onEw1k2iwGzQTYaQ/8ksUOyKx9c5dvitaEoQxTdCL6FJpLuMY=
=eHle
-----END PGP SIGNATURE-----
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001322.html">[squid-dev] [PATCH] HTTP Response Parser upgrade
</A></li>
	<LI>Next message: <A HREF="001338.html">[squid-dev] [PATCH] HTTP Response Parser upgrade
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1323">[ date ]</a>
              <a href="thread.html#1323">[ thread ]</a>
              <a href="subject.html#1323">[ subject ]</a>
              <a href="author.html#1323">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
