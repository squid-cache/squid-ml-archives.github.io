<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20checklist-%3Econn%20assertion%20in%20DestinationIp.cc&In-Reply-To=%3C55A9E496.8060407%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002682.html">
   <LINK REL="Next"  HREF="002685.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20checklist-%3Econn%20assertion%20in%20DestinationIp.cc&In-Reply-To=%3C55A9E496.8060407%40treenet.co.nz%3E"
       TITLE="[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jul 18 05:31:02 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002682.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
        <LI>Next message: <A HREF="002685.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2684">[ date ]</a>
              <a href="thread.html#2684">[ thread ]</a>
              <a href="subject.html#2684">[ subject ]</a>
              <a href="author.html#2684">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 18/07/2015 6:09 a.m., Alex Rousskov wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i>     Intercepting Squids sometimes fail with the following assertion in
</I>&gt;<i> ACLDestinationIP::match():
</I>&gt;<i> 
</I>&gt;&gt;<i>     // Bug 3243: CVE 2009-0801
</I>&gt;&gt;<i>     // Bypass of browser same-origin access control in intercepted communication
</I>&gt;&gt;<i>     // To resolve this we will force DIRECT and only to the original client destination.
</I>&gt;&gt;<i>     // In which case, we also need this ACL to accurately match the destination
</I>&gt;&gt;<i>     if (Config.onoff.client_dst_passthru &amp;&amp; ... intercepted ...) {
</I>&gt;&gt;<i>         assert(checklist-&gt;conn() &amp;&amp; checklist-&gt;conn()-&gt;clientConnection != NULL);
</I>&gt;&gt;<i>         return ACLIP::match(checklist-&gt;conn()-&gt;clientConnection-&gt;local);
</I>&gt;&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> There are several reports about these failures on squid-users, including
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/pipermail/squid-users/2015-May/003562.html">http://lists.squid-cache.org/pipermail/squid-users/2015-May/003562.html</A>
</I>&gt;<i> 
</I>&gt;<i> The assertion makes no sense to me -- why would an ACL assert that a
</I>&gt;<i> connection is valid? A lot of things can happen between the time the ACL
</I>&gt;<i> checklist was formed and the time the ACL got evaluated. This is true
</I>&gt;<i> for all ACLs, but should be especially obvious for slow/asynchronous
</I>&gt;<i> ACLs such as &quot;dst&quot;.
</I>
What is a transaction without any existing state objects?

The connection may be closed (definition of 'invalid'?) and still pass
this test, so long as the state actually exists.


If the ConnStateData and ConnStateData::clientConnection are previously
deleted and things are still starting ACL tests something very bad has
happened. Probably broken refcount/cbdata locking on the Job-like object
holding the Checklist.


&gt;<i> 
</I>&gt;<i> Is suggest replacing the assert with an if-statement to return -1
</I>&gt;<i> (matching failure) when the connection is gone. Rationale: With the
</I>&gt;<i> connection gone, the matching result probably does not matter anymore so
</I>&gt;<i> there is little incentive for us to use alternative (and insecure!)
</I>&gt;<i> sources of destination information.
</I>&gt;<i> 
</I>&gt;<i> Any better ideas?
</I>
That would seem to work for this problem. But be careful about other
hidden side effects of trying to complete delivery of a client response
without any existing client state object(s).

CbcPointer use for FilledChecklist::conn_ should also get a look-in to
see if its possible. The hitch there IIRC, was that CbcPointer get()
still produces NULL if the object has been 'deleted' but locks are still
existing for the Checklist to be destructed.

Amos
</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002682.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
	<LI>Next message: <A HREF="002685.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2684">[ date ]</a>
              <a href="thread.html#2684">[ thread ]</a>
              <a href="subject.html#2684">[ subject ]</a>
              <a href="author.html#2684">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
