<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20checklist-%3Econn%20assertion%20in%20DestinationIp.cc&In-Reply-To=%3C55AB18F5.2030602%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002684.html">
   <LINK REL="Next"  HREF="002686.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20checklist-%3Econn%20assertion%20in%20DestinationIp.cc&In-Reply-To=%3C55AB18F5.2030602%40measurement-factory.com%3E"
       TITLE="[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Jul 19 03:26:45 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002684.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
        <LI>Next message: <A HREF="002686.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2685">[ date ]</a>
              <a href="thread.html#2685">[ thread ]</a>
              <a href="subject.html#2685">[ subject ]</a>
              <a href="author.html#2685">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/17/2015 11:31 PM, Amos Jeffries wrote:
&gt;<i> On 18/07/2015 6:09 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i>     Intercepting Squids sometimes fail with the following assertion in
</I>&gt;&gt;<i> ACLDestinationIP::match():
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     if (Config.onoff.client_dst_passthru &amp;&amp; ... intercepted ...) {
</I>&gt;&gt;&gt;<i>         assert(checklist-&gt;conn() &amp;&amp; checklist-&gt;conn()-&gt;clientConnection != NULL);
</I>&gt;&gt;&gt;<i>         return ACLIP::match(checklist-&gt;conn()-&gt;clientConnection-&gt;local);
</I>&gt;&gt;&gt;<i>     }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are several reports about these failures on squid-users, including
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/pipermail/squid-users/2015-May/003562.html">http://lists.squid-cache.org/pipermail/squid-users/2015-May/003562.html</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The assertion makes no sense to me -- why would an ACL assert that a
</I>&gt;&gt;<i> connection is valid? A lot of things can happen between the time the ACL
</I>&gt;&gt;<i> checklist was formed and the time the ACL got evaluated. This is true
</I>&gt;&gt;<i> for all ACLs, but should be especially obvious for slow/asynchronous
</I>&gt;&gt;<i> ACLs such as &quot;dst&quot;.
</I>

&gt;<i> What is a transaction without any existing state objects?
</I>
A finished/gone transaction?


&gt;<i> The connection may be closed (definition of 'invalid'?) and still pass
</I>&gt;<i> this test, so long as the state actually exists.
</I>
Evidently, the state does not exist. Judging by the number of Squid if
statements checking similar conditions, there are many situations where
the asserted condition may be false. On the other hand, it is possible
that this ACL code is exceptional or that all those other checks are in
vain, of course. That is why I am trying to understand why the above
assertion was postulated...


&gt;<i> If the ConnStateData and ConnStateData::clientConnection are previously
</I>&gt;<i> deleted and things are still starting ACL tests something very bad has
</I>&gt;<i> happened. Probably broken refcount/cbdata locking on the Job-like object
</I>&gt;<i> holding the Checklist.
</I>
AFAICT, many Checklists are not locked by Jobs. For clear examples, see
ConnStateData::postHttpsAccept() and startPeekAndSpliceDone(), but I
suspect the vast majority of nonBlockingCheck() calls do not lock
Checklist either, despite using class members (instead of local
variables) to keep the Checklist pointer.

Please note that the asserting ACL check was _resumed_ in this case
(probably after an async DNS lookup), not started from the beginning.
Since async actions are always a possibility, I do not think we can
assert anything about the transaction state at the ACL check time.


&gt;&gt;<i> Is suggest replacing the assert with an if-statement to return -1
</I>&gt;&gt;<i> (matching failure) when the connection is gone. Rationale: With the
</I>&gt;&gt;<i> connection gone, the matching result probably does not matter anymore so
</I>&gt;&gt;<i> there is little incentive for us to use alternative (and insecure!)
</I>&gt;&gt;<i> sources of destination information.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Any better ideas?
</I>

&gt;<i> That would seem to work for this problem. But be careful about other
</I>&gt;<i> hidden side effects of trying to complete delivery of a client response
</I>&gt;<i> without any existing client state object(s).
</I>
AFAICT, ACLChecklist::checkCallback() checks for callback validity
before delivering the answer to that callback.


&gt;<i> CbcPointer use for FilledChecklist::conn_ should also get a look-in to
</I>&gt;<i> see if its possible. The hitch there IIRC, was that CbcPointer get()
</I>&gt;<i> still produces NULL if the object has been 'deleted' but locks are still
</I>&gt;<i> existing for the Checklist to be destructed.
</I>
I agree that FilledChecklist::conn_ should use a CbcPointer to make its
dereference safer, but a simple replacement would probably just trigger
more [harder-to-triage] assertions because of the problem discussed below.

Virtually any existing FilledChecklist::conn()-dereferencing ACL code
that simply checks whether the pointer is NULL before dereferencing it
is a ticking time bomb -- the conn_ pointer returned by conn() may be
not NULL, but the corresponding ConnStateData destructor has been called
already. As you know, cbdata only protects raw memory from being
deleted, not the destructor from being called...


How about the following two changes?

1. Change FilledChecklist::conn() to return NULL when conn_ is invalid.
2. Change the above assertion into an if statement, returning -1.


If, after the above is done, somebody volunteers to replace the raw
conn_ pointer with a CbcPointer, they should be welcomed to do that, of
course.


Thank you,

Alex.

</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002684.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
	<LI>Next message: <A HREF="002686.html">[squid-dev] checklist-&gt;conn assertion in DestinationIp.cc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2685">[ date ]</a>
              <a href="thread.html#2685">[ thread ]</a>
              <a href="subject.html#2685">[ subject ]</a>
              <a href="author.html#2685">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
