<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AB8B6F.5050002%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002683.html">
   <LINK REL="Next"  HREF="002728.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AB8B6F.5050002%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Jul 19 11:35:11 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002683.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002728.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2688">[ date ]</a>
              <a href="thread.html#2688">[ thread ]</a>
              <a href="subject.html#2688">[ subject ]</a>
              <a href="author.html#2688">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 18/07/2015 7:08 a.m., Alex Rousskov wrote:
&gt;<i> On 07/17/2015 11:48 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 18/07/2015 3:13 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;<i> This patch adds received_encrypted ACL
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The new received_encrypted ACL matches transactions where all HTTP
</I>&gt;&gt;&gt;<i> messages were received over TLS or SSL transport connections, including
</I>&gt;&gt;&gt;<i> messages received from ICAP servers.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Use case: Sending everything to Secure ICAP services increases
</I>&gt;&gt;&gt;<i> adaptation performance overhead. Folks want to send received_encrypted
</I>&gt;&gt;&gt;<i> transactions and only those transactions to Secure ICAP services.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> -1 on principle I object to making this ACL available for this use case.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I must have read this wrong. You are not trying to block a useful
</I>&gt;<i> feature simply because you dislike a specific use case, are you?
</I>
I am debating whether this is a &quot;useful feature&quot;. The one (and only) use
case presented for its existence is flawed.


&gt;<i> 
</I>&gt;<i> Given your comments below, it sounds like you misunderstood the use case
</I>&gt;<i> itself, but even if you were right about that use case, blocking a
</I>&gt;<i> feature based on a single use case seems a bit too harsh!
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> And the (very) long answer:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is conceptually very bad.
</I>&gt;<i> 
</I>&gt;<i> What exactly is &quot;this&quot; and why is it very bad?
</I>
what: The use-case behaviour being proposed as desirable.
why: for the reasons the rest of my mail was attempting to describe.

&gt;<i> 
</I>&gt;&gt;<i> * <A HREF="https://">https://</A> scheme traffic is *supposed* to be kept secure no matter
</I>&gt;&gt;<i> what. Either they need to obey that requirement or they dont (due to
</I>&gt;&gt;<i> non-TLS security).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * <A HREF="http://">http://</A> and the other non-secure schemes are optional.
</I>&gt;<i> 
</I>&gt;&gt;<i> Please do instead encourage using the request URI scheme (&quot;proto&quot; ACL)
</I>&gt;&gt;<i> to make that determination of whether ICAP security is desirable or not.
</I>&gt;<i> 
</I>&gt;<i> Looking at the request URI scheme does not work well: For example, the
</I>&gt;<i> URI scheme may be insecure &quot;<A HREF="http://">http://</A>&quot; but the message has been received
</I>&gt;<i> via a secure channel (e.g., https_port or SslBump).
</I>
Exactly my point. ICAPS usage on these requests is *optional*. Any use
of TLS on the inbound/outbound connections is opportunistic.

If the admin want to reduce costs they are free to send it through
<A HREF="icap://">icap://</A> services with no unexpected danger. Use of received_encrypted
would unnecessarily *raise* their ICAPS load.


&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> In other news; HTTP is growing this thing called &quot;opportunistc security&quot;
</I>&gt;&gt;<i> (aka. encryption). Where <A HREF="http://">http://</A> schemed requests will be arriving over
</I>&gt;&gt;<i> TLS, and maybe even going out via it and it traverses fully secure
</I>&gt;&gt;<i> components. HTTPbis WG are already finding problems with servers not
</I>&gt;&gt;<i> handling the schemes right in these conditions. Lets not add another
</I>&gt;&gt;<i> bunch of bad assumptions to the mix. Follow the scheme.
</I>&gt;<i> 
</I>&gt;<i> That seems like a counter-example to your own argument! The
</I>&gt;<i> received_encrypted ACL should match if an <A HREF="http://">http://</A> request arrived over
</I>&gt;<i> TLS, and Squid may be able to offer better &quot;security&quot; for that
</I>&gt;<i> transaction (e.g., by sending it to a Secure ICAP service or bypassing
</I>&gt;<i> ICAP completely).
</I>
Only if you misunderstand the security requirements around
&quot;oppportunistic&quot; vs HTTPS.

Opportunistic security (<A HREF="http://">http://</A> over TLS) means if the admin is *able*
and *willing* to pay the extra overhead costs of TLS, great. Otherwise
there is no pressure to do so.
 - in these cases the proposed patch adds nothing.

HTTPS (<A HREF="https://">https://</A>) means the admin is expected (almost mandatory) to pay
those costs. Failing to do so is a vulnerability.
 - in these cases the proposed patch adds only the ability to turn a
small vulnerability, into a bigger one. Existing ACLs already allows that.
 -if we want to be strict about hard-coding these requirements inside
Squid great. But then no need for the ACL config options.

So far its looking like there is no need for the ACL ... but lets go deeper.

&gt;<i> 
</I>&gt;&gt;<i> Also;
</I>&gt;&gt;<i> 1) we know about the directly connected security. But the connections
</I>&gt;&gt;<i> beyond that may be insecure. You note this yourself about eCAP. Same
</I>&gt;&gt;<i> goes for TLS connections!!
</I>&gt;<i> 
</I>&gt;<i> Not sure what you are implying by that. Yes, the admin only knows about
</I>&gt;<i> things under his or her control. How is that related to the proposed
</I>&gt;<i> ACL? In the ICAP context, the proposed ACL simply taints transactions
</I>&gt;<i> received from un-encrypted sources.
</I>
NP: The proposed ACL implies that Squid is able to determine security
levels of different connections. (safe/unsafe, tainted/untained).

All three of these listed situations are cases where that implication
fails in subtle ways that can bite badly by *raising* the unnecessary
ICAPS usage for admin who want to avoid it.

&gt;<i> 
</I>&gt;<i> We could go further and add a &quot;this ICAP service taints messages&quot; flag
</I>&gt;<i> to [Secure] ICAP service configuration but there has not been any
</I>&gt;<i> requests for that feature so perhaps adding more flags would be premature.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> 2) Even when something is supposedly secure it can have wildly differing
</I>&gt;&gt;<i> degrees of security from other things. TLS itself has NULL-cipher with
</I>&gt;&gt;<i> zero security.
</I>&gt;<i> 
</I>&gt;<i> How is that related to the proposed ACL? Are you implying that
</I>&gt;<i> &quot;received_encrypted&quot; is the wrong name because NULL-ciphers exist? I
</I>&gt;<i> hope you would not vote -1 simply because you do not like the name, but
</I>&gt;<i> better names are welcomed, of course.
</I>&gt;<i> 
</I>
received_encrypted is being described as meaning the transaction is
secure. Unless one goes to almost ridiculous lengths to ensure the fine
grained details are all secure it can mean no such thing.

In the case of NULL-cipher use of TLS itself taints the transaction and
makes it insecure. That is the obvious cipher, other far less obvious
TLS features (like simply using SSLv or TLS/1.0) have the same tainting
effect. None of those are accounted for in the safe/unsafe description
being assumed in the patch ACL.
Its left to the admin to deal with. At which point we may as well use
the <A HREF="https://">https://</A> scheme &quot;proto&quot; ACL match in place of received_encrypted.

&gt;<i> 
</I>&gt;&gt;<i> 3) non-TLS forms of connection security exist (IPSEC, VPN, stunnel, etc)
</I>&gt;&gt;<i> and may be used today without Squid knowledge.
</I>&gt;<i> 
</I>&gt;<i> And the admin can add rules to handle that traffic specially. The
</I>&gt;<i> proposed ACL helps the admin in cases where Squid does know that the
</I>&gt;<i> traffic was received over an encrypted channel.
</I>
The knowledge Squid has is not correct enough to be used for security
decisions like this.

&gt;<i> 
</I>&gt;&gt;<i> So any determination of &quot;security&quot; based on existence or lack of TLS or
</I>&gt;&gt;<i> other assumed properties is false information. We can't be sure about
</I>&gt;&gt;<i> other components real security, and it should not matter to the
</I>&gt;&gt;<i> component (ICAP service) making its decision.
</I>&gt;<i> 
</I>&gt;<i> The proposed ACL does not determine what is &quot;secure&quot;. It only determines
</I>&gt;<i> what was received via SSL/TLS channels, which for the lack of a better
</I>&gt;<i> word, we called &quot;encrypted&quot;. Better names are welcomed, but would not
</I>&gt;<i> change what the ACL does.
</I>&gt;<i> 
</I>
The need for this ACL was defined as:
&quot;Folks want to send [messages were received over TLS or SSL transport
connections] transactions and only those transactions to Secure ICAP
services.&quot;


At REQMOD the myportname or proto ACLs meet the above criteria.

At RESPMOD the myportname, proto, and/or peername ACLs meet the above
criteria.


Whether the transaction was actually received over a TLS connection has
nothing to do with whether it is classified &quot;secure&quot; and needs to be
treated securly once it arrives.
 Its perfectly fine for a message for non-HTTPS traffic reeived over a
TLS connection to go to <A HREF="icap://.">icap://.</A>

Whether something (broken) earlier tainted it does not change its
classification to &quot;Insecure&quot; and has nothing to do with whether it needs
treating securely in ICAP(S).


&gt;<i> 
</I>&gt;&gt;<i> On the third hand (:-P), whats wrong with using a transaction annotation
</I>&gt;&gt;<i> in the HttpRequest set by insecure components if they are passed an
</I>&gt;&gt;<i> <A HREF="https://">https://</A> request?
</I>&gt;<i> 
</I>&gt;<i> The annotation (effectively provided by the proposed ACL) needs to be
</I>&gt;<i> set _before_ any [insecure] components see the message. The annotation
</I>&gt;<i> may be used to decide whether those components will _see_ the message in
</I>&gt;<i> the first place!
</I>
So does this received_encrypted ACL. The Safe/Unsafe netmask declare
&quot;safe&quot; at all points up until some taint happens.

Absence of the insecure annotation implies secure in *exact* equivalence
with the current patch implementaton.


&gt;<i> 
</I>&gt;<i> In summary, I think you misunderstood the problem the ACL is trying to
</I>&gt;<i> solve and have not suggested any viable alternative solutions. I hope my
</I>&gt;<i> response clarified things enough for you to re-consider your -1 vote.
</I>
I understand that this proposal is trying to link &quot;TLS encrypted&quot; as
implying &quot;secure transaction&quot;. The two are simply not related that way.
It is a common mistake to think so.

The logic relationshp between security and TLS is a nasty one-way
implication thing. Secure connection (HTTPS, <A HREF="https://">https://</A>) implies TLS ...
but *not* vice versa.
 Just like use of TCP implies IP protocol, but use of IP protocol
implies either UDP or TCP.

*HTTPS* (<A HREF="https://">https://</A>) already means secure transaction. Nothing else we
deal with at present does. Not even ICAPS usage.

Admin who want to minimize their ICAPS load simply configure &quot;acl HTTPS
proto HTTPS&quot; and use something like &quot;allow !HTTPS&quot; on the <A HREF="icap://">icap://</A>
service. Or &quot;deny !HTTPS&quot; on the <A HREF="icaps://">icaps://</A> service.

The tricky case is HTTPS over non-TLS connections. As you mentioned
above the admin can already add other rules to handle IPSEC, VPN,
stunnel, etc specially. Whatever those rules may use its not
received_encrypted (which will match wrongly in these cases).


Amos
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002683.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002728.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2688">[ date ]</a>
              <a href="thread.html#2688">[ thread ]</a>
              <a href="subject.html#2688">[ subject ]</a>
              <a href="author.html#2688">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
