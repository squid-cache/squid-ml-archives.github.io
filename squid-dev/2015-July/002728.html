<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AC6F32.20606%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002688.html">
   <LINK REL="Next"  HREF="002729.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AC6F32.20606%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Jul 20 03:46:58 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002688.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002729.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2728">[ date ]</a>
              <a href="thread.html#2728">[ thread ]</a>
              <a href="subject.html#2728">[ subject ]</a>
              <a href="author.html#2728">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/19/2015 05:35 AM, Amos Jeffries wrote:
&gt;<i> On 18/07/2015 7:08 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 07/17/2015 11:48 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 18/07/2015 3:13 a.m., Tsantilas Christos wrote:
</I>&gt;&gt;&gt;&gt;<i> This patch adds received_encrypted ACL
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The new received_encrypted ACL matches transactions where all HTTP
</I>&gt;&gt;&gt;&gt;<i> messages were received over TLS or SSL transport connections, including
</I>&gt;&gt;&gt;&gt;<i> messages received from ICAP servers.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Use case: Sending everything to Secure ICAP services increases
</I>&gt;&gt;&gt;&gt;<i> adaptation performance overhead. Folks want to send received_encrypted
</I>&gt;&gt;&gt;&gt;<i> transactions and only those transactions to Secure ICAP services.
</I>

&gt;&gt;&gt;<i> -1 on principle I object to making this ACL available for this use case.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I must have read this wrong. You are not trying to block a useful
</I>&gt;&gt;<i> feature simply because you dislike a specific use case, are you?
</I>

&gt;<i> I am debating whether this is a &quot;useful feature&quot;.
</I>

No, you are not. If you wanted to debate the usefulness of a feature,
then you would have not voted at all or voted -0 or above. Your -1 vote
is not a debate, it is a [blocking] resolution a.k.a. a veto.


&gt;&gt;&gt;<i> This is conceptually very bad.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What exactly is &quot;this&quot; and why is it very bad?
</I>&gt;<i> 
</I>&gt;<i> what: The use-case behaviour being proposed as desirable.
</I>
The desirability of that behavior is a fact -- Squid admins desire it.
We rarely spend a few days implementing something theoretically
desirable. The proposed feature satisfies real desires of real Squid admins.


&gt;<i> why: for the reasons the rest of my mail was attempting to describe.
</I>
I do not think the rest of your email explains why sending &quot;received
encrypted&quot; traffic to Secure ICAP services is &quot;conceptually very bad&quot;.
You talked about

* the need to keep <A HREF="https://">https://</A> traffic secure
  (no one argues against that!)

* identifying &quot;secure&quot; traffic using ports and URI schemes
  (ports/schemes do not work well enough or we would not add this ACL)

* Squid's knowledge being limited to direct connections
  (true but admins often know more and can use ACLs accordingly)


&gt;&gt;<i> Looking at the request URI scheme does not work well: For example, the
</I>&gt;&gt;<i> URI scheme may be insecure &quot;<A HREF="http://">http://</A>&quot; but the message has been received
</I>&gt;&gt;<i> via a secure channel (e.g., https_port or SslBump).
</I>
&gt;<i> Exactly my point. ICAPS usage on these requests is *optional*. Any use
</I>&gt;<i> of TLS on the inbound/outbound connections is opportunistic.
</I>
The admin needs to send messages received via a SSL/TLS channel to a
Secure ICAP service. This routing is not optional. This routing is
required! There is nothing opportunistic or optional here.

You may argue that the admin's requirement itself is wrong, but you are
unlikely to win that argument. It may not be perfect, but it is very
reasonable in many environments.


&gt;<i> If the admin want to reduce costs they are free to send it through
</I>&gt;<i> <A HREF="icap://">icap://</A> services with no unexpected danger. Use of received_encrypted
</I>&gt;<i> would unnecessarily *raise* their ICAPS load.
</I>
Perhaps you have some other use case in mind, but in the use case at
hand, the admin cannot send received-encrypted traffic to just any
service. The external requirements outside our control or knowledge
require the admin to route received-encrypted traffic to special ICAPS
services.

It is easy (IMO) to think of many other use cases for the same feature:

* Use a special adaptation service for received-encrypted traffic.
* Do not adapt received-encrypted traffic at all.
* Do not log received-encrypted traffic.
* Do not cache received-encrypted traffic.
* Do not limit received-encrypted traffic bandwidth.
* Route received-encrypted traffic to a special cache peer.
* etc.


&gt;&gt;&gt;<i> In other news; HTTP is growing this thing called &quot;opportunistc security&quot;
</I>&gt;&gt;&gt;<i> (aka. encryption). Where <A HREF="http://">http://</A> schemed requests will be arriving over
</I>&gt;&gt;&gt;<i> TLS, and maybe even going out via it and it traverses fully secure
</I>&gt;&gt;&gt;<i> components. HTTPbis WG are already finding problems with servers not
</I>&gt;&gt;&gt;<i> handling the schemes right in these conditions. Lets not add another
</I>&gt;&gt;&gt;<i> bunch of bad assumptions to the mix. Follow the scheme.
</I>
&gt;&gt;<i> That seems like a counter-example to your own argument! The
</I>&gt;&gt;<i> received_encrypted ACL should match if an <A HREF="http://">http://</A> request arrived over
</I>&gt;&gt;<i> TLS, and Squid may be able to offer better &quot;security&quot; for that
</I>&gt;&gt;<i> transaction (e.g., by sending it to a Secure ICAP service or bypassing
</I>&gt;&gt;<i> ICAP completely).
</I>

&gt;<i> Only if you misunderstand the security requirements around
</I>&gt;<i> &quot;oppportunistic&quot; vs HTTPS.
</I>
I do not think so: The proposed ACL would help the admin to extend the
&quot;security opportunity&quot; to certain traffic. Whether to do that would
still be admin's choice (it is an ACL, not a hard-coded behavior!).
Without this ACL, making that decision becomes much harder because Squid
does not supply the necessary information in an easily accessible form.
That is why admins want this ACL!


&gt;<i> Opportunistic security (<A HREF="http://">http://</A> over TLS) means if the admin is *able*
</I>&gt;<i> and *willing* to pay the extra overhead costs of TLS, great. Otherwise
</I>&gt;<i> there is no pressure to do so.
</I>
OK.

&gt;<i>  - in these cases the proposed patch adds nothing.
</I>
Except it helps the admin to decide for which traffic Squid should pay
the extra overhead. The new ACL may not be the final answer, of course.
It is just one of the variables that some admins may want to look at
when making &quot;Am I willing to pay?&quot; decisions.


&gt;<i> HTTPS (<A HREF="https://">https://</A>) means the admin is expected (almost mandatory) to pay
</I>&gt;<i> those costs. Failing to do so is a vulnerability.
</I>
As discussed earlier, &quot;<A HREF="https://">https://</A>&quot; URIs is not the only case where the
admin is expected to pay those costs. The new ACL helps the admin to pay
the costs when the payment is due (and avoid paying when the payment is
optional and not worth the gain).


&gt;<i>  - in these cases the proposed patch adds only the ability to turn a
</I>&gt;<i> small vulnerability, into a bigger one.
</I>
An ACL is just a function returning true or false. It does not make any
vulnerability worse. While anything can be abused, we should focus on
the correct/expected usage. When used correctly, the new ACL may help
the admin to reduce vulnerabilities by, for example, using ICAPS or even
avoiding adaptation completely.


&gt;<i>  -if we want to be strict about hard-coding these requirements inside
</I>&gt;<i> Squid great. But then no need for the ACL config options.
</I>
We cannot hard-code: The requirements (and the means to satisfy them)
differ from one deployment to another.


&gt;&gt;&gt;<i> Also;
</I>&gt;&gt;&gt;<i> 1) we know about the directly connected security. But the connections
</I>&gt;&gt;&gt;<i> beyond that may be insecure. You note this yourself about eCAP. Same
</I>&gt;&gt;&gt;<i> goes for TLS connections!!
</I>
&gt;&gt;<i> Not sure what you are implying by that. Yes, the admin only knows about
</I>&gt;&gt;<i> things under his or her control. How is that related to the proposed
</I>&gt;&gt;<i> ACL? In the ICAP context, the proposed ACL simply taints transactions
</I>&gt;&gt;<i> received from un-encrypted sources.
</I>

&gt;<i> NP: The proposed ACL implies that Squid is able to determine security
</I>&gt;<i> levels of different connections. (safe/unsafe, tainted/untained).
</I>
No. The ACL only knows about SSL/TLS connections. It does not know about
safety, security, or any other higher-level concepts. The word &quot;tainted&quot;
is applied here because a single non-SSL/TLS source is enough to flip
the ACL value even when the other 10 sources were TLS. I think that
wording is appropriate and does not imply too much, but better wording
is welcomed if you disagree.


&gt;<i> All three of these listed situations are cases where that implication
</I>&gt;<i> fails in subtle ways that can bite badly by *raising* the unnecessary
</I>&gt;<i> ICAPS usage for admin who want to avoid it.
</I>
Perhaps you are comparing a with-ACL configuration with some ideal case
that does not exist? Here is the correct comparison (for one of the
discussed use cases):

* Without the ACL: Send everything to ICAPS (100%)
  because we cannot easily identify what should not be sent and
  we do not want to risk missing a few important cases.

* With the ACL: Send received-encrypted to ICAPS (X%)
  because we know that covers all the important cases (at least).

In most deployment environments, X is [a lot] less than 100 so the new
ACL is [very] useful.

Please note that there is no claim here that X cannot be decreased
further. With more ACLs (existing or future), it can be.


&gt;<i> received_encrypted is being described as meaning the transaction is
</I>&gt;<i> secure. 
</I>
It was not intent to describe any transactions as secure. The proposed
commit message does not call any transactions secure. It only uses the
word secure in two contexts:

* &quot;Secure ICAP&quot; phrase, which is an existing protocol name (nothing we
can do about the word Secure there!)

* Secure eCAP services, which is a possible future concept. Since eCAP
is not a network communication protocol, it cannot use SSL/TLS
connections. Instead, the admin is going to mark eCAP services
appropriately (from the admin point of view). We can reword that eCAP
paragraph if you think the word &quot;secure&quot; is misleading there. The word
is already in &quot;quotes&quot; to indicate an imprecise meaning.

The ACL description in src/cf.data.pre does not use the word &quot;secure&quot;.

There is a NOTE in the email introducing the patch that says &quot;secure
source/request&quot;. It should have said &quot;encrypted source/request&quot;. Sorry.

None of the above changes what the ACL does, of course.


&gt;<i> In the case of NULL-cipher use of TLS itself taints the transaction and
</I>&gt;<i> makes it insecure. That is the obvious cipher, other far less obvious
</I>&gt;<i> TLS features (like simply using SSLv or TLS/1.0) have the same tainting
</I>&gt;<i> effect. None of those are accounted for in the safe/unsafe description
</I>&gt;<i> being assumed in the patch ACL.
</I>
None of those cases need to be accounted for in most real use cases AFAIK:

Yes, the current implementation does not account for unencrypted TLS
connections, but this is only a problem with the name of the ACL, not
with the implemented and documented functionality. The implementation
and documentation do not define or assume what is &quot;secure&quot; or even
&quot;encrypted&quot;. The implementation just checks whether the message was
received over the SSL/TLS channel. It does not claim to do more.

Fortunately, the proposed implementation is enough to offer the vast
majority of admins dealing with these problems what they want. If some
admin wants to discriminate null cyphers and similar features, they can
petition for parameterizing this ACL or adding another one. It would
certainly be possible to do that. The current inability of the ACL to
detect null cyphers cannot be a valid reason to reject the ACL.

Again, if you can think of a better name for the ACL, we would gladly
rename! &quot;received_encrypted&quot; is just the best we could come up with. For
example, if you think &quot;received_over_tls&quot; is much better, we can rename
to that.


&gt;<i> Its left to the admin to deal with. At which point we may as well use
</I>&gt;<i> the <A HREF="https://">https://</A> scheme &quot;proto&quot; ACL match in place of received_encrypted.
</I>
The <A HREF="https://">https://</A> scheme does not work for an important case of <A HREF="http://">http://</A> URLs
received over perfectly secure TLS connections. The admins have tried
that and did not like the outcome. That is why they requested
received_encrypted.

The lack of null cypher (and similar esoteric cases) support is going to
hurt virtually nobody. It is not a problem the [vast majority of] admins
would need to deal with! And it can be added later if needed.



&gt;&gt;&gt;<i> 3) non-TLS forms of connection security exist (IPSEC, VPN, stunnel, etc)
</I>&gt;&gt;&gt;<i> and may be used today without Squid knowledge.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> And the admin can add rules to handle that traffic specially. The
</I>&gt;&gt;<i> proposed ACL helps the admin in cases where Squid does know that the
</I>&gt;&gt;<i> traffic was received over an encrypted channel.
</I>&gt;<i> 
</I>&gt;<i> The knowledge Squid has is not correct enough to be used for security
</I>&gt;<i> decisions like this.
</I>
The admins say the functionality allows them to make the decisions they
want to make. You have provided no example where a reasonable
configuration would lead to incorrect decisions related to security.
AFAICT, the best you could imply so far is that some unencrypted traffic
received over TLS (NULL cyphers and such) will go to a Secure ICAP
service. This is not a problem admins actually worry about!


&gt;<i> The need for this ACL was defined as:
</I>&gt;<i> &quot;Folks want to send [messages were received over TLS or SSL transport
</I>&gt;<i> connections] transactions and only those transactions to Secure ICAP
</I>&gt;<i> services.&quot;
</I>

Yes, this is one of many use cases.


&gt;<i> At REQMOD the myportname or proto ACLs meet the above criteria.
</I>
No, they do not. For example, an <A HREF="http://">http://</A> request could be received on an
http_port inside a bumped TLS CONNECT tunnel. With the proposed ACL, it
is easy to route the bumped request to a Secure ICAP service, as
required. Without the new ACL, the routing decisions become complex and
error-prone.

There are other, more complex, examples where port and scheme ACLs are
not good enough.



&gt;<i> Whether the transaction was actually received over a TLS connection has
</I>&gt;<i> nothing to do with whether it is classified &quot;secure&quot; and needs to be
</I>&gt;<i> treated securly once it arrives.
</I>
Whether it has nothing or everything to do with TLS is not our decision
to make. The admin decides that. Yes, it is possible to create examples
where TLS is irrelevant. That does not matter because there are enough
examples where it is relevant [to the admin and her decisions/requirements].


&gt;<i> Its perfectly fine for a message for non-HTTPS traffic reeived over a
</I>&gt;<i> TLS connection to go to <A HREF="icap://.">icap://.</A>
</I>
Not our decision. We do not define adaptation routing rules. Admins do.


&gt;<i> Whether something (broken) earlier tainted it does not change its
</I>&gt;<i> classification to &quot;Insecure&quot; and has nothing to do with whether it needs
</I>&gt;<i> treating securely in ICAP(S).
</I>
Again, this is admin's decision, not ours. The proposed ACL does not
support such decisions (the &quot;conservative tainting&quot; logic is currently
hard-coded), but future ACL parameters can address this as needed with
little code changes. The right code infrastructure will be there.


&gt;&gt;&gt;<i> On the third hand (:-P), whats wrong with using a transaction annotation
</I>&gt;&gt;&gt;<i> in the HttpRequest set by insecure components if they are passed an
</I>&gt;&gt;&gt;<i> <A HREF="https://">https://</A> request?
</I>
&gt;&gt;<i> The annotation (effectively provided by the proposed ACL) needs to be
</I>&gt;&gt;<i> set _before_ any [insecure] components see the message. The annotation
</I>&gt;&gt;<i> may be used to decide whether those components will _see_ the message in
</I>&gt;&gt;<i> the first place!
</I>
&gt;<i> So does this received_encrypted ACL.
</I>
Perhaps I was not clear:

* received_encrypted ACL marks the transaction without exposing it to
  any adaptation services first. This &quot;early marking&quot; is an important
  requirement.

* annotations set by [insecure] components (your proposal) do not
  satisfy that requirement.


&gt;<i> Absence of the insecure annotation implies secure in *exact* equivalence
</I>&gt;<i> with the current patch implementaton.
</I>
Absence of an insecure annotation does not tell the admin whether the
transaction may or may not be sent to a given adaptation service. The
admin in our use case makes that decision based, in part, on which
channel the transaction came from (TLS or not). The annotation you
propose only tells the admin that the transaction has not been sent to
an insecure annotation service yet.


&gt;&gt;<i> In summary, I think you misunderstood the problem the ACL is trying to
</I>&gt;&gt;<i> solve and have not suggested any viable alternative solutions. I hope my
</I>&gt;&gt;<i> response clarified things enough for you to re-consider your -1 vote.
</I>
&gt;<i> I understand that this proposal is trying to link &quot;TLS encrypted&quot; as
</I>&gt;<i> implying &quot;secure transaction&quot;. 
</I>
No, it does not. The proposed ACL only marks &quot;TLS encrypted&quot;
transactions. Nothing more. It is the admin that decides what to do with
those marked transactions. Many admins want to treat them specially. If
used correctly, the ACL does not weaken security.


&gt;<i> *HTTPS* (<A HREF="https://">https://</A>) already means secure transaction. Nothing else we
</I>&gt;<i> deal with at present does. Not even ICAPS usage.
</I>
Many admins want to do X to <A HREF="https://">https://</A> and <A HREF="http://">http://</A> transactions received
over TLS channels. The proposed ACL allows them to do that. &quot;X&quot; can be a
lot of things, including sending to a Secure ICAP service.


&gt;<i> Admin who want to minimize their ICAPS load simply configure &quot;acl HTTPS
</I>&gt;<i> proto HTTPS&quot; and use something like &quot;allow !HTTPS&quot; on the <A HREF="icap://">icap://</A>
</I>&gt;<i> service. Or &quot;deny !HTTPS&quot; on the <A HREF="icaps://">icaps://</A> service.
</I>
Does not work for non-<A HREF="https://">https://</A> transactions that are received over TLS
channels and need to go to the secure ICAP service (per admin rules).


In summary:

* You seem to have constructed a simple use case that can be addressed
without received_encrypted ACL. The ACL was created for more complex
cases discussed above, and it may actually work better than a
combination of the ACLs required for all but the very simplest cases.

* You say that the new ACL defines what is &quot;secure&quot; or &quot;encrypted&quot;. It
does not. &quot;Received over SSL/TLS&quot; is as far as it goes. This limited
definition covers many known use cases well (from admins point of view).

* You might be implying that Squid can define which adaptation services
are appropriate for <A HREF="https://">https://</A> (or other) transactions. I believe that
decision lies with the admin, not us. We cannot hard-code it, and admins
need the new ACL to configure it.

* You are also trying to attack the proposed feature because it does not
know about NULL cyphers and other encryption/security exceptions. That
knowledge can be added later if somebody actually needs it. It is not
important for the known use cases.

Hope this clarifies and removes your objections.


Thank you,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002688.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002729.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2728">[ date ]</a>
              <a href="thread.html#2728">[ thread ]</a>
              <a href="subject.html#2728">[ subject ]</a>
              <a href="author.html#2728">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
