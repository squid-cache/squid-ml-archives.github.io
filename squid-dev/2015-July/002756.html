<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AD6B4D.10803%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002755.html">
   <LINK REL="Next"  HREF="002801.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AD6B4D.10803%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Jul 20 21:42:37 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002755.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002801.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2756">[ date ]</a>
              <a href="thread.html#2756">[ thread ]</a>
              <a href="subject.html#2756">[ subject ]</a>
              <a href="author.html#2756">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/20/2015 01:45 PM, Amos Jeffries wrote:
&gt;<i> On 21/07/2015 6:48 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 07/20/2015 09:27 AM, Kinkie wrote:
</I>&gt;&gt;&gt;<i> So in my opinion the easiest way to move the discussion forward is to:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1. find one use-case which cannot be covered by existing features
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Absolute impossibility is too high of a bar, IMO. A lot of things are
</I>&gt;&gt;<i> possible with excessive amount of work and mind boggling complexity.
</I>&gt;&gt;<i> However, I can suggest this configuration sketch as one example where
</I>&gt;&gt;<i> the proposed ACL would be very handy if not essential:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # A set of ports that may be changed depending on deployment.
</I>&gt;&gt;<i> # Some may be configured to bump traffic, some not. Some may intercept.
</I>&gt;&gt;<i> # The bumping ports do not bump everything (see ssl_bump below).
</I>&gt;&gt;<i> http_port port1 ssl-bump ...
</I>&gt;&gt;<i> https_port port2 ssl-bump ...
</I>&gt;&gt;<i> http_port port3 ...
</I>&gt;&gt;<i> https_port port4 ssl-bump ...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # SslBumping rules (note that some of these ACLs cannot be computed
</I>&gt;&gt;<i> # until later bumping stages, some rules create fake CONNECT requests
</I>&gt;&gt;<i> # for adaptation services, and the order of rules is significant):
</I>&gt;&gt;<i> ssl_bump splice aclBump0
</I>&gt;&gt;<i> ssl_bump peek aclBump1
</I>&gt;&gt;<i> ssl_bump stare aclBump2
</I>&gt;&gt;<i> ssl_bump splice aclBump3
</I>&gt;&gt;<i> ssl_bump bump aclBump4
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # If all transaction messages were received over SSL or TLS
</I>&gt;&gt;<i> # connections, then send it to the ICAP service icapS. Otherwise,
</I>&gt;&gt;<i> # send it to icapN. The rules apply to all transactions, including
</I>&gt;&gt;<i> #  - plain http: transactions over plain connections to http_port,
</I>&gt;&gt;<i> #  - plain http: transactions over intercepted plain connections,
</I>&gt;&gt;<i> #  + plain http: transactions from bumped TLS connections,
</I>&gt;&gt;<i> #  + plain http: transactions from direct TLS connections to https_port,
</I>&gt;&gt;<i> #  + plain http: transactions from direct TLS connections to https_port
</I>&gt;&gt;<i> #  + fake CONNECT messages generated for bumped intercepted transactions
</I>

&gt;<i> The fake connect request was not &quot;received over TLS&quot;.
</I>&gt;<i> Conceptually it was a plain-TCP SYN received prior to TLS. No different
</I>&gt;<i> in meaning to the non-fake CONNECT requests.
</I>
This is debatable for fake CONNECT requests that are based on SSL/TLS
information (SNI and such), but probably not worth discussing right now
because it is a minor issue. We should document how [different kinds of]
fake CONNECTs are classified.


&gt;&gt;<i> adaptation_access icapS aclIcap
</I>&gt;&gt;<i> adaptation_access icapN !aclIcap
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> aclIcap can be a received_encrypted ACL. What ACL expression would you
</I>&gt;&gt;<i> suggest for aclIcap if received_encrypted is not available?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>   # top 5 criteria - TLS transactions
</I>&gt;<i>   acl aclIcap allof HTTPS
</I>
What is &quot;HTTPS&quot; ACL? If it is based on the URI scheme, then AFAIK, it is
not going to work because it will not match bumped <A HREF="http://">http://</A> requests (at
least).


&gt;<i>   # last 1 - the fake-CONNECTs but not the regular CONNECTs:
</I>&gt;<i>   acl bumpPorts myportname port2 port4
</I>&gt;<i>   acl aclIcap allof CONNECT !bumpPorts
</I>
I am not sure this is correct because there may be CONNECT requests
*inside* bumped SSL/TLS streams on port1 (at least):

 1. Receive CONNECT at http_port.
 2. Bump.
 3. Parse the first bumped HTTP request on the SSL/TLS channel.
 4. It is a CONNECT request!

Sorry, I do not remember what Squid does with these nested CONNECTs
right now, but they do exist in the wild.


&gt;<i> False-negative:
</I>&gt;<i> 
</I>&gt;<i> Imagine that icapN was REQMOD and icapS a RESPMOD service. With
</I>&gt;<i> URL-rewrite, eCAP or such modification of the reply making it <A HREF="https://">https://</A>
</I>&gt;<i> (tainted).
</I>
I assume you meant &quot;making it <A HREF="http://">http://</A> (tainted)&quot;.


&gt;<i> Using received_encrypted the transactions;
</I>&gt;<i>  during request will match, so icapN does not get used.
</I>&gt;<i>  during reply will not match, so icapS does not get used.
</I>
Kinkie has not asked for false-negatives so you are moving the goal
posts. More importantly, I do not see a false negative in your example.
Yes, an eCAP adaptation will &quot;taint&quot; the transaction, but it does not
lead to a &quot;false negative&quot;, just a &quot;true negative&quot; (i.e., the negative
decision matches what the admin should expect in this case).

If those true negatives are not desirable, we will make that hard-coded
decision configurable by the admin (who knows whether the adaptation
service should &quot;taint&quot; -- Squid does not know that).


&gt;<i> False-positive:
</I>&gt;<i> 
</I>&gt;<i>  Imagine that icapS was REQMOD and icapN a RESPMOD service. Same
</I>&gt;<i> modifications by url-rewriter. This time re-writing to <A HREF="http://">http://</A> URL
</I>&gt;<i> matching cached content.
</I>&gt;<i> 
</I>&gt;<i> Using received_encrypted the transactions;
</I>&gt;<i>  during request will match, so icapS gets used.
</I>
Do you see this as a false positive? I assume you do not. If you do,
please explain why.


&gt;<i>  during reply will *still match*, so icapN does not get used
</I>
Cache hits do not go through RESPMOD services so this example does not work.

When/if somebody adds post-cache RESPMOD support, AFAICT, the icapN
_will_ get used because the current ACL implementation assumes that
cached content source corresponds to the cached URI scheme. Christos has
disclosed that simplification or shortcoming. Again, this is something
we can improve in the future if needed. We already have a blueprint for
better caching support actually.

I would not be surprised if you can create a false positive example if
you try harder. I am not sure we handle all the possible combinations of
URL rewriters, other adaptation services, and caching correctly today.
My point was not that false positives do not exist but that their
existence should not cause a patch rejection. It should cause
documentation improvements (and possible future work). False positives,
if they exist, do not make the feature not-useful to those who need it.


HTH,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002755.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002801.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2756">[ date ]</a>
              <a href="thread.html#2756">[ thread ]</a>
              <a href="subject.html#2756">[ subject ]</a>
              <a href="author.html#2756">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
