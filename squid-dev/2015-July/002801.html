<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AE1E0F.4000603%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002756.html">
   <LINK REL="Next"  HREF="002802.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AE1E0F.4000603%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Jul 21 10:25:19 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002756.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002802.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2801">[ date ]</a>
              <a href="thread.html#2801">[ thread ]</a>
              <a href="subject.html#2801">[ subject ]</a>
              <a href="author.html#2801">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 21/07/2015 9:42 a.m., Alex Rousskov wrote:
&gt;<i> On 07/20/2015 01:45 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 21/07/2015 6:48 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 07/20/2015 09:27 AM, Kinkie wrote:
</I>&gt;&gt;&gt;&gt;<i> So in my opinion the easiest way to move the discussion forward is to:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 1. find one use-case which cannot be covered by existing features
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Absolute impossibility is too high of a bar, IMO. A lot of things are
</I>&gt;&gt;&gt;<i> possible with excessive amount of work and mind boggling complexity.
</I>&gt;&gt;&gt;<i> However, I can suggest this configuration sketch as one example where
</I>&gt;&gt;&gt;<i> the proposed ACL would be very handy if not essential:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> # A set of ports that may be changed depending on deployment.
</I>&gt;&gt;&gt;<i> # Some may be configured to bump traffic, some not. Some may intercept.
</I>&gt;&gt;&gt;<i> # The bumping ports do not bump everything (see ssl_bump below).
</I>&gt;&gt;&gt;<i> http_port port1 ssl-bump ...
</I>&gt;&gt;&gt;<i> https_port port2 ssl-bump ...
</I>&gt;&gt;&gt;<i> http_port port3 ...
</I>&gt;&gt;&gt;<i> https_port port4 ssl-bump ...
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> # SslBumping rules (note that some of these ACLs cannot be computed
</I>&gt;&gt;&gt;<i> # until later bumping stages, some rules create fake CONNECT requests
</I>&gt;&gt;&gt;<i> # for adaptation services, and the order of rules is significant):
</I>&gt;&gt;&gt;<i> ssl_bump splice aclBump0
</I>&gt;&gt;&gt;<i> ssl_bump peek aclBump1
</I>&gt;&gt;&gt;<i> ssl_bump stare aclBump2
</I>&gt;&gt;&gt;<i> ssl_bump splice aclBump3
</I>&gt;&gt;&gt;<i> ssl_bump bump aclBump4
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> # If all transaction messages were received over SSL or TLS
</I>&gt;&gt;&gt;<i> # connections, then send it to the ICAP service icapS. Otherwise,
</I>&gt;&gt;&gt;<i> # send it to icapN. The rules apply to all transactions, including
</I>&gt;&gt;&gt;<i> #  - plain http: transactions over plain connections to http_port,
</I>&gt;&gt;&gt;<i> #  - plain http: transactions over intercepted plain connections,
</I>&gt;&gt;&gt;<i> #  + plain http: transactions from bumped TLS connections,
</I>&gt;&gt;&gt;<i> #  + plain http: transactions from direct TLS connections to https_port,
</I>&gt;&gt;&gt;<i> #  + plain http: transactions from direct TLS connections to https_port
</I>&gt;&gt;&gt;<i> #  + fake CONNECT messages generated for bumped intercepted transactions
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> The fake connect request was not &quot;received over TLS&quot;.
</I>&gt;&gt;<i> Conceptually it was a plain-TCP SYN received prior to TLS. No different
</I>&gt;&gt;<i> in meaning to the non-fake CONNECT requests.
</I>&gt;<i> 
</I>&gt;<i> This is debatable for fake CONNECT requests that are based on SSL/TLS
</I>&gt;<i> information (SNI and such), but probably not worth discussing right now
</I>&gt;<i> because it is a minor issue. We should document how [different kinds of]
</I>&gt;<i> fake CONNECTs are classified.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> adaptation_access icapS aclIcap
</I>&gt;&gt;&gt;<i> adaptation_access icapN !aclIcap
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> aclIcap can be a received_encrypted ACL. What ACL expression would you
</I>&gt;&gt;&gt;<i> suggest for aclIcap if received_encrypted is not available?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   # top 5 criteria - TLS transactions
</I>&gt;&gt;<i>   acl aclIcap allof HTTPS
</I>&gt;<i> 
</I>&gt;<i> What is &quot;HTTPS&quot; ACL? If it is based on the URI scheme, then AFAIK, it is
</I>&gt;<i> not going to work because it will not match bumped <A HREF="http://">http://</A> requests (at
</I>&gt;<i> least).
</I>
Good you have seen those. That is what the HTTPbis WG call
&quot;opportunistic encryption&quot; traffic.

This is where the security requirements and your ACL use-case differ.
Security requirements for those requests is that they be handled as per
any other <A HREF="http://">http://</A> - any encrytpion or security applied is *optional*.
recieved_encrypted ACL seems to assume they are broken HTTPS and matches
for them.

What I'm getting at here is that these are more good candidates for the
performance-oriented admin to skip ICAPS processing if they want. Even
though they were bumped. The new ACL fails to let that happen (in a good
way, but still).


&gt;<i> 
</I>&gt;&gt;<i>   # last 1 - the fake-CONNECTs but not the regular CONNECTs:
</I>&gt;&gt;<i>   acl bumpPorts myportname port2 port4
</I>&gt;&gt;<i>   acl aclIcap allof CONNECT !bumpPorts
</I>&gt;<i> 
</I>&gt;<i> I am not sure this is correct because there may be CONNECT requests
</I>&gt;<i> *inside* bumped SSL/TLS streams on port1 (at least):
</I>&gt;<i> 
</I>&gt;<i>  1. Receive CONNECT at http_port.
</I>&gt;<i>  2. Bump.
</I>&gt;<i>  3. Parse the first bumped HTTP request on the SSL/TLS channel.
</I>&gt;<i>  4. It is a CONNECT request!
</I>&gt;<i> 
</I>&gt;<i> Sorry, I do not remember what Squid does with these nested CONNECTs
</I>&gt;<i> right now, but they do exist in the wild.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> False-negative:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Imagine that icapN was REQMOD and icapS a RESPMOD service. With
</I>&gt;&gt;<i> URL-rewrite, eCAP or such modification of the reply making it <A HREF="https://">https://</A>
</I>&gt;&gt;<i> (tainted).
</I>&gt;<i> 
</I>&gt;<i> I assume you meant &quot;making it <A HREF="http://">http://</A> (tainted)&quot;.
</I>&gt;<i> 
</I>
No, this example eCAP taints it but leaves it as <A HREF="https://.">https://.</A> So both the
inbound and outbound connections are fully using TLS. But the ACL
matches as if it were non-TLS connections.
 This will conflict with later cached handling, and logging info. Which
properly treats is as fully TLS received.


&gt;<i> 
</I>&gt;&gt;<i> Using received_encrypted the transactions;
</I>&gt;&gt;<i>  during request will match, so icapN does not get used.
</I>&gt;&gt;<i>  during reply will not match, so icapS does not get used.
</I>&gt;<i> 
</I>&gt;<i> Kinkie has not asked for false-negatives so you are moving the goal
</I>&gt;<i> posts. More importantly, I do not see a false negative in your example.
</I>&gt;<i> Yes, an eCAP adaptation will &quot;taint&quot; the transaction, but it does not
</I>&gt;<i> lead to a &quot;false negative&quot;, just a &quot;true negative&quot; (i.e., the negative
</I>&gt;<i> decision matches what the admin should expect in this case).
</I>
They expect that two fetches of the same URL from the same client one
MISS gets marked non-TLS-received the other HIT as TLS-received ?
 I see complaints in that future.

&gt;<i> 
</I>&gt;<i> If those true negatives are not desirable, we will make that hard-coded
</I>&gt;<i> decision configurable by the admin (who knows whether the adaptation
</I>&gt;<i> service should &quot;taint&quot; -- Squid does not know that).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> False-positive:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  Imagine that icapS was REQMOD and icapN a RESPMOD service. Same
</I>&gt;&gt;<i> modifications by url-rewriter. This time re-writing to <A HREF="http://">http://</A> URL
</I>&gt;&gt;<i> matching cached content.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Using received_encrypted the transactions;
</I>&gt;&gt;<i>  during request will match, so icapS gets used.
</I>&gt;<i> 
</I>&gt;<i> Do you see this as a false positive? I assume you do not. If you do,
</I>&gt;<i> please explain why.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>  during reply will *still match*, so icapN does not get used
</I>&gt;<i> 
</I>&gt;<i> Cache hits do not go through RESPMOD services so this example does not work.
</I>
The original request that got cached never attached the ACL so whatever
processing was desired for applying to secure responses was never applied.
 The ACL is matching this insecure and tainted response as if it were
TLS received. So the non-secure processing that was suppsed to have been
omitted for it whas been done.

This is another situation where HIT vs MISS have opposite ACL reactions
for the same URL and content.


&gt;<i> 
</I>&gt;<i> When/if somebody adds post-cache RESPMOD support, AFAICT, the icapN
</I>&gt;<i> _will_ get used because the current ACL implementation assumes that
</I>&gt;<i> cached content source corresponds to the cached URI scheme. Christos has
</I>&gt;<i> disclosed that simplification or shortcoming. Again, this is something
</I>&gt;<i> we can improve in the future if needed. We already have a blueprint for
</I>&gt;<i> better caching support actually.
</I>
No. Christos wrote this:
&quot;
NOTE: Currently there is not any mechanism to indicate if a cached
object came from secure source or not, so we assume that all hits for
secure requests are secure too.
&quot;

The cache hits rely on the request markings to determine the HIT
matching. In this case we have a <A HREF="https://">https://</A> (secure, TLS-received) marked
request being re-written with non-TLS URL and delivered a HIT originated
from a non-TLS server.



Amos
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002756.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002802.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2801">[ date ]</a>
              <a href="thread.html#2801">[ thread ]</a>
              <a href="subject.html#2801">[ subject ]</a>
              <a href="author.html#2801">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
