<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AFB772.5090609%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002802.html">
   <LINK REL="Next"  HREF="002832.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55AFB772.5090609%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Jul 22 15:32:02 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002802.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002832.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2828">[ date ]</a>
              <a href="thread.html#2828">[ thread ]</a>
              <a href="subject.html#2828">[ subject ]</a>
              <a href="author.html#2828">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/21/2015 04:25 AM, Amos Jeffries wrote:
&gt;<i> On 21/07/2015 9:42 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> adaptation_access icapS aclIcap
</I>&gt;&gt;&gt;&gt;<i> adaptation_access icapN !aclIcap
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> aclIcap can be a received_encrypted ACL. What ACL expression would you
</I>&gt;&gt;&gt;&gt;<i> suggest for aclIcap if received_encrypted is not available?
</I>

&gt;&gt;&gt;<i>   # top 5 criteria - TLS transactions
</I>&gt;&gt;&gt;<i>   acl aclIcap allof HTTPS
</I>
&gt;&gt;<i> What is &quot;HTTPS&quot; ACL? If it is based on the URI scheme, then AFAIK, it is
</I>&gt;&gt;<i> not going to work because it will not match bumped <A HREF="http://">http://</A> requests (at
</I>&gt;&gt;<i> least).
</I>
&gt;<i> Good you have seen those. That is what the HTTPbis WG call
</I>&gt;<i> &quot;opportunistic encryption&quot; traffic.
</I>

I bet many (most?) of them are actually regular HTTP requests sent over
TLS/SSL connections. There is nothing opportunistic about them.


&gt;<i> This is where the security requirements and your ACL use-case differ.
</I>&gt;<i> Security requirements for those requests is that they be handled as per
</I>&gt;<i> any other <A HREF="http://">http://</A> - any encrytpion or security applied is *optional*.
</I>
No requirement can _force_ something to be optional! If the use case
demands that requests received over TLS are sent to icapS service, then
they should be sent to the icapS service, even if some of the
corresponding request owners would not mind to see their requests going
to the icapN service.


&gt;<i> recieved_encrypted ACL seems to assume they are broken HTTPS and matches
</I>&gt;<i> for them.
</I>
recieved_encrypted ACL does not assume anything in this case. It simply
says that they were received over a TLS or SSL connection.


&gt;<i> What I'm getting at here is that these are more good candidates for the
</I>&gt;<i> performance-oriented admin to skip ICAPS processing if they want. Even
</I>&gt;<i> though they were bumped.
</I>
I agree that in some deployments there may be more good candidates to
skip the icapS service.


&gt;<i> The new ACL fails to let that happen 
</I>
Nope. The new ACL is just an ACL. It does not force any requests to be
sent anywhere. If the admin finds the new ACL more useful than other
ACLs, they will use it. Some may petition for other ACLs to be added.

We are not removing the &quot;port&quot; ACL even though it does not know that
port 80 traffic is not always HTTP. Similarly, it is perfectly fine to
add an ACL that does not know that HTTP WG calls some encryption
&quot;opportunistic&quot;. In the future, received_encrypted parameters or new
ACLs will identify opportunistic encryption if there is demand for that.
This is a normal process of Squid and HTTP evolution.



&gt;&gt;&gt;<i> False-negative:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Imagine that icapN was REQMOD and icapS a RESPMOD service. With
</I>&gt;&gt;&gt;<i> URL-rewrite, eCAP or such modification of the reply making it <A HREF="https://">https://</A>
</I>&gt;&gt;&gt;<i> (tainted).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I assume you meant &quot;making it <A HREF="http://">http://</A> (tainted)&quot;.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> No, this example eCAP taints it but leaves it as <A HREF="https://.">https://.</A> So both the
</I>&gt;<i> inbound and outbound connections are fully using TLS. But the ACL
</I>&gt;<i> matches as if it were non-TLS connections.
</I>
This is not a false negative. The ACL covers more than inbound and
outbound connections. It also covers connections to adaptation services
(network connections for ICAP and loadable module calls for eCAP). In
the current implementation, adaptation connections other than those to
the Secure ICAP adaptation services taint the transaction. This tainting
is intentional -- there is no &quot;false&quot; in this &quot;negative&quot;.

If you think we should change the default for eCAP and plain ICAP from
&quot;taint&quot; to &quot;do not taint&quot;, we can discuss that. It is just a default. I
believe the current &quot;conservative&quot; settings are the best starting point,
but am happy to discuss the advantages of a different default.


&gt;<i> This will conflict with later cached handling, and logging info. Which
</I>&gt;<i> properly treats is as fully TLS received.
</I>
I do not see any conflict. The ACL just does not match if the
transaction was sent to an eCAP service. This is intentional as
discussed above. Why is that a conflict? What things are conflicting?


&gt;&gt;&gt;<i> Using received_encrypted the transactions;
</I>&gt;&gt;&gt;<i>  during request will match, so icapN does not get used.
</I>&gt;&gt;&gt;<i>  during reply will not match, so icapS does not get used.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Kinkie has not asked for false-negatives so you are moving the goal
</I>&gt;&gt;<i> posts. More importantly, I do not see a false negative in your example.
</I>&gt;&gt;<i> Yes, an eCAP adaptation will &quot;taint&quot; the transaction, but it does not
</I>&gt;&gt;<i> lead to a &quot;false negative&quot;, just a &quot;true negative&quot; (i.e., the negative
</I>&gt;&gt;<i> decision matches what the admin should expect in this case).
</I>

&gt;<i> They expect that two fetches of the same URL from the same client one
</I>&gt;<i> MISS gets marked non-TLS-received the other HIT as TLS-received ?
</I>
No. They just do not use eCAP and/or caching.


&gt;<i>  I see complaints in that future.
</I>
The new ACL caching support is limited to cases where cached responses
can be correctly classified by their URIs. We should document this
better, but the implementation covers a lot of use cases we know about.

Users that want better caching support can enhance Squid to provide that
support. The changes to do so are not trivial, there is currently no
demand for them, exact feature requirements and use cases are not yet
clear, so it is wrong to force us to implement them now.


&gt;&gt;<i> If those true negatives are not desirable, we will make that hard-coded
</I>&gt;&gt;<i> decision configurable by the admin (who knows whether the adaptation
</I>&gt;&gt;<i> service should &quot;taint&quot; -- Squid does not know that).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> False-positive:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  Imagine that icapS was REQMOD and icapN a RESPMOD service. Same
</I>&gt;&gt;&gt;<i> modifications by url-rewriter. This time re-writing to <A HREF="http://">http://</A> URL
</I>&gt;&gt;&gt;<i> matching cached content.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Using received_encrypted the transactions;
</I>&gt;&gt;&gt;<i>  during request will match, so icapS gets used.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do you see this as a false positive? I assume you do not. If you do,
</I>&gt;&gt;<i> please explain why.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  during reply will *still match*, so icapN does not get used
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cache hits do not go through RESPMOD services so this example does not work.
</I>&gt;<i> 
</I>&gt;<i> The original request that got cached never attached the ACL so whatever
</I>&gt;<i> processing was desired for applying to secure responses was never applied.
</I>&gt;<i>  The ACL is matching this insecure and tainted response as if it were
</I>&gt;<i> TLS received. So the non-secure processing that was suppsed to have been
</I>&gt;<i> omitted for it whas been done.
</I>
Sorry, but you need to formulate this example from scratch. Your
false-positive example above does not work -- icapN does not get used
not because something is wrong with the new ACL but because Squid does
not support RESPMOD services for cache hits. I cannot combine your
original broken example with the conditions you have added above without
the risk of fighting another straw man.

If you decide to construct another example, please keep my above
comments about caching support in mind. There is no need to construct an
example outside the current ACL scope.


&gt;&gt;<i> When/if somebody adds post-cache RESPMOD support, AFAICT, the icapN
</I>&gt;&gt;<i> _will_ get used because the current ACL implementation assumes that
</I>&gt;&gt;<i> cached content source corresponds to the cached URI scheme. Christos has
</I>&gt;&gt;<i> disclosed that simplification or shortcoming. Again, this is something
</I>&gt;&gt;<i> we can improve in the future if needed. We already have a blueprint for
</I>&gt;&gt;<i> better caching support actually.
</I>
&gt;<i> No. Christos wrote this:
</I>&gt;<i> &quot;
</I>&gt;<i> NOTE: Currently there is not any mechanism to indicate if a cached
</I>&gt;<i> object came from secure source or not, so we assume that all hits for
</I>&gt;<i> secure requests are secure too.
</I>&gt;<i> &quot;
</I>
This disclosure matches what I said.


&gt;<i> The cache hits rely on the request markings to determine the HIT
</I>&gt;<i> matching.
</I>
In your example, you said that there is a HIT. Thus, the requests
matched. Thus, the [rewritten] request URI is <A HREF="http://">http://</A> (not <A HREF="https://">https://</A>).
Thus, bugs notwithstanding, the new ACL will not match the HIT response
in your example.


&gt;<i> In this case we have a <A HREF="https://">https://</A> (secure, TLS-received) marked
</I>&gt;<i> request being re-written with non-TLS URL and delivered a HIT originated
</I>&gt;<i> from a non-TLS server.
</I>
Yes, such rewriting and hits are possible, with or without the new ACL.
I do not see a false positive here. Bugs notwithstanding, the new ACL
should not match the HIT response because it has an <A HREF="http://">http://</A> URI.

We do need to move the information from Christos' NOTE to
squid.conf.documented and expand it so that admins needing better
caching support know that it is not available (yet).


Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002802.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002832.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2828">[ date ]</a>
              <a href="thread.html#2828">[ thread ]</a>
              <a href="subject.html#2828">[ subject ]</a>
              <a href="author.html#2828">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
