<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55B1437B.4080307%40users.sourceforge.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002838.html">
   <LINK REL="Next"  HREF="002843.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Tsantilas Christos</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55B1437B.4080307%40users.sourceforge.net%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">chtsanti at users.sourceforge.net
       </A><BR>
    <I>Thu Jul 23 19:41:47 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002838.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002843.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2841">[ date ]</a>
              <a href="thread.html#2841">[ thread ]</a>
              <a href="subject.html#2841">[ subject ]</a>
              <a href="author.html#2841">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/23/2015 07:21 PM, Alex Rousskov wrote:
&gt;<i> On 07/23/2015 07:41 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 23/07/2015 3:32 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 07/21/2015 04:25 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> On 21/07/2015 9:42 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> adaptation_access icapS aclIcap
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> adaptation_access icapN !aclIcap
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> aclIcap can be a received_encrypted ACL. What ACL expression would you
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> suggest for aclIcap if received_encrypted is not available?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>    # top 5 criteria - TLS transactions
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>    acl aclIcap allof HTTPS
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> What is &quot;HTTPS&quot; ACL? If it is based on the URI scheme, then AFAIK, it is
</I>&gt;&gt;&gt;&gt;&gt;<i> not going to work because it will not match bumped <A HREF="http://">http://</A> requests (at
</I>&gt;&gt;&gt;&gt;&gt;<i> least).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Good you have seen those. That is what the HTTPbis WG call
</I>&gt;&gt;&gt;&gt;<i> &quot;opportunistic encryption&quot; traffic.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I bet many (most?) of them are actually regular HTTP requests sent over
</I>&gt;&gt;&gt;<i> TLS/SSL connections. There is nothing opportunistic about them.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That is the very definition of &quot;opportunistic&quot; in the related HTTP
</I>&gt;&gt;<i> documentation.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Hi Amos,
</I>&gt;<i>
</I>&gt;<i>      The opportunistic security (OS) documents you site talk about
</I>&gt;<i> optionally applying encryption to traffic X, to arrive at traffic XE. A
</I>&gt;<i> general-purpose intermediary cannot use those documents to go backwards
</I>&gt;<i> and say that any applied encryption was optional if we see traffic XE!
</I>&gt;<i> This backward direction is possible only when X or XE includes some sort
</I>&gt;<i> of an &quot;it is OK to decrypt at any time&quot; flag. Until such a flag is
</I>&gt;<i> defined for HTTP and/or TLS, and Squid learns to interpret it, the
</I>&gt;<i> discussion about opportunistic encryption is pretty much not relevant to
</I>&gt;<i> the received_encrypted ACL.
</I>&gt;<i>
</I>&gt;<i> Moreover, the received_encrypted ACL itself and the related use cases do
</I>&gt;<i> not become wrong or obsolete when/if &quot;it is OK to decrypt at any time&quot;
</I>&gt;<i> flag is supported.
</I>&gt;<i>
</I>&gt;<i> Is &quot;<A HREF="http://">http://</A>&quot; scheme such a flag? Not for Squid. That URI scheme existed
</I>&gt;<i> long before any of the HTTP WG proposals you site were written, so Squid
</I>&gt;<i> should not assume that an encrypted <A HREF="http://">http://</A> request is the result of OS.
</I>&gt;<i> Either a more reliable flag or an admin decision is required to enable
</I>&gt;<i> such behavior. All of this is orthogonal to received_encrypted.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> This is where the security requirements and your ACL use-case differ.
</I>&gt;&gt;&gt;&gt;<i> Security requirements for those requests is that they be handled as per
</I>&gt;&gt;&gt;&gt;<i> any other <A HREF="http://">http://</A> - any encrytpion or security applied is *optional*.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> No requirement can _force_ something to be optional! If the use case
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think you misunderstand me.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The forcing applied is: optional-&gt;mandatory.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is done by using the received_encrypted ACL. Apparently without admin
</I>&gt;&gt;<i> intending to.
</I>&gt;<i>
</I>&gt;<i> Any assertion that uses a &quot;received ACL forces ...&quot; pattern is wrong. An
</I>&gt;<i> ACL is a yes/no test, nothing more. Yet, you keep blaming the ACL for
</I>&gt;<i> doing something other than testing. That does not compute for me.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> demands that requests received over TLS are sent to icapS service, then
</I>&gt;&gt;&gt;<i> they should be sent to the icapS service, even if some of the
</I>&gt;&gt;&gt;<i> corresponding request owners would not mind to see their requests going
</I>&gt;&gt;&gt;<i> to the icapN service.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you recall my very first words on this thread. I question the use-case.
</I>&gt;<i>
</I>&gt;<i> What does that mean? Are you saying the use case does not exist? That I
</I>&gt;<i> made it up? Or that we should not allow the admins to do what they want
</I>&gt;<i> to do? Something else?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Look closely:
</I>&gt;<i>
</I>&gt;&gt;<i> +    if (!(filled-&gt;request-&gt;sources &amp; HttpMsg::srcUnsafe)  ||
</I>&gt;&gt;<i> +        (filled-&gt;reply &amp;&amp; !(filled-&gt;reply-&gt;sources &amp; HttpMsg::srcUnsafe)))
</I>&gt;&gt;<i> +        return 1;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>

This is a stupid bug, probably caused while I was trying to convert a 
more complex expression to a simpler....

&gt;<i>
</I>&gt;<i> That code does not make sense to me. I think it should be written like
</I>&gt;<i> this instead:
</I>&gt;<i>
</I>&gt;<i>      const bool safeRequest =
</I>&gt;<i>          !(filled-&gt;request-&gt;sources &amp; HttpMsg::srcUnsafe);
</I>&gt;<i>      const bool safeReply = !filled-&gt;reply ||
</I>&gt;<i>          !(filled-&gt;reply-&gt;sources &amp; HttpMsg::srcUnsafe);
</I>&gt;<i>      return (safeRequest &amp;&amp; safeReply) ? 1 : 0;
</I>
Yes!

&gt;<i>
</I>&gt;<i> Furthermore, the values of &quot;unsafe&quot; srcX enum constants should be
</I>&gt;<i> increased to actually match the srcUnsafe mask (16 is still smaller than
</I>&gt;<i> 0xFFFF).
</I>
This is should be OK.
The safe flags are from:
  (1 &lt;&lt; (16 + 0)) = (1 &lt;&lt; (16 + 0)) &amp; 0xFFFF0000
to:
   (1 &lt;&lt; (16 + 15)) = (1 &lt;&lt; (16 + 15)) &amp; 0xFFFF0000

Am I loosing something?
(It is late here, this is not a time for playing with bits and shifts, 
my mind is broken ...)

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> While I personally like the outcome (more security). Its clearly not
</I>&gt;&gt;<i> matching the use case presented as *sole* reason for the ACLs existence.
</I>&gt;&gt;<i> Nor the apparent admin policy in adaptation_access.
</I>&gt;<i>
</I>&gt;<i> To me, it just looks like an implementation bug. Christos, do you think
</I>&gt;<i> the code should be rewritten as in my sketch above?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> So I ask; why are we bothering with this ACL?
</I>&gt;&gt;<i>   Just use an <A HREF="https://">https://</A> scheme match, which will only be true in the top
</I>&gt;&gt;<i> line of above if()-matrix. Admin *wanting* &quot;opportunistic security&quot;
</I>&gt;&gt;<i> should not be the ones trying to avoid using icapS in the first place.
</I>&gt;<i>
</I>&gt;<i> I have answered that question several times already, including providing
</I>&gt;<i> specific examples requested by Kinkie: The URI scheme alone does not
</I>&gt;<i> match what the ACL is defined to match.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002838.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002843.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2841">[ date ]</a>
              <a href="thread.html#2841">[ thread ]</a>
              <a href="subject.html#2841">[ subject ]</a>
              <a href="author.html#2841">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
