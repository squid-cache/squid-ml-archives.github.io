<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] received_encrypted ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55B220D3.3000808%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002843.html">
   <LINK REL="Next"  HREF="002849.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] received_encrypted ACL</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20received_encrypted%20ACL&In-Reply-To=%3C55B220D3.3000808%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] received_encrypted ACL">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Jul 24 11:26:11 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002843.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
        <LI>Next message: <A HREF="002849.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2847">[ date ]</a>
              <a href="thread.html#2847">[ thread ]</a>
              <a href="subject.html#2847">[ subject ]</a>
              <a href="author.html#2847">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 24/07/2015 7:41 a.m., Tsantilas Christos wrote:
&gt;<i> On 07/23/2015 07:21 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 07/23/2015 07:41 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 23/07/2015 3:32 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> On 07/21/2015 04:25 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> On 21/07/2015 9:42 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> adaptation_access icapS aclIcap
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> adaptation_access icapN !aclIcap
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> aclIcap can be a received_encrypted ACL. What ACL expression
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> would you
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> suggest for aclIcap if received_encrypted is not available?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>    # top 5 criteria - TLS transactions
</I>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i>    acl aclIcap allof HTTPS
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> What is &quot;HTTPS&quot; ACL? If it is based on the URI scheme, then AFAIK,
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> it is
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> not going to work because it will not match bumped <A HREF="http://">http://</A>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> requests (at
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> least).
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Good you have seen those. That is what the HTTPbis WG call
</I>&gt;&gt;&gt;&gt;&gt;<i> &quot;opportunistic encryption&quot; traffic.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I bet many (most?) of them are actually regular HTTP requests sent over
</I>&gt;&gt;&gt;&gt;<i> TLS/SSL connections. There is nothing opportunistic about them.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> That is the very definition of &quot;opportunistic&quot; in the related HTTP
</I>&gt;&gt;&gt;<i> documentation.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hi Amos,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>      The opportunistic security (OS) documents you site talk about
</I>&gt;&gt;<i> optionally applying encryption to traffic X, to arrive at traffic XE. A
</I>&gt;&gt;<i> general-purpose intermediary cannot use those documents to go backwards
</I>&gt;&gt;<i> and say that any applied encryption was optional if we see traffic XE!
</I>&gt;&gt;<i> This backward direction is possible only when X or XE includes some sort
</I>&gt;&gt;<i> of an &quot;it is OK to decrypt at any time&quot; flag. Until such a flag is
</I>&gt;&gt;<i> defined for HTTP and/or TLS, and Squid learns to interpret it, the
</I>&gt;&gt;<i> discussion about opportunistic encryption is pretty much not relevant to
</I>&gt;&gt;<i> the received_encrypted ACL.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Moreover, the received_encrypted ACL itself and the related use cases do
</I>&gt;&gt;<i> not become wrong or obsolete when/if &quot;it is OK to decrypt at any time&quot;
</I>&gt;&gt;<i> flag is supported.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Is &quot;<A HREF="http://">http://</A>&quot; scheme such a flag? Not for Squid. That URI scheme existed
</I>&gt;&gt;<i> long before any of the HTTP WG proposals you site were written, so Squid
</I>&gt;&gt;<i> should not assume that an encrypted <A HREF="http://">http://</A> request is the result of OS.
</I>&gt;&gt;<i> Either a more reliable flag or an admin decision is required to enable
</I>&gt;&gt;<i> such behavior. All of this is orthogonal to received_encrypted.
</I>&gt;&gt;<i>
</I>
I think you still misunderstand the OppSec RFC meanings.

Since SSL support first went into Squid back in 1998 we have allowed
cache_peer to connect to a remote https_port and sent <A HREF="http://">http://</A> traffic
over it.
 As I hope you are aware, this has zero meaning in the end-2-end
security of the messages themselves. Only that the link between the two
proxy is somewhat private/secure against surveillance.
For example; its quite popular for Enterprise networks with remote
office to use as a pseudo-VPN to HQ, but does not mean the traffic
delivered over it can avoid the company firewall when branch office
staff browse the Internet.


 The browser guys have finally been half-convinced that its a good
thing, and &quot;opportunistic security&quot; is the new name being applied for
what Squid has been doing all along. Since the WG has to deal with many
more real-world scenarios than Squid peering there are other mechanisms
added on top for negotiation and capability advertisement,
generalizations to handle the non-HTTP web protocols, etc.

 But dont let that extra fanciness detract from the fact that the RFC
core is documenting what &quot;cache_peer ... 80 0 ssl&quot; has been doing
(manually) to the HTTP protocol all along.


Anyhow. My objections resolved below ...

&gt;&gt;&gt;<i> Look closely:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +    if (!(filled-&gt;request-&gt;sources &amp; HttpMsg::srcUnsafe)  ||
</I>&gt;&gt;&gt;<i> +        (filled-&gt;reply &amp;&amp; !(filled-&gt;reply-&gt;sources &amp;
</I>&gt;&gt;&gt;<i> HttpMsg::srcUnsafe)))
</I>&gt;&gt;&gt;<i> +        return 1;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +    return 0;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This is a stupid bug, probably caused while I was trying to convert a
</I>&gt;<i> more complex expression to a simpler....
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That code does not make sense to me. I think it should be written like
</I>&gt;&gt;<i> this instead:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>      const bool safeRequest =
</I>&gt;&gt;<i>          !(filled-&gt;request-&gt;sources &amp; HttpMsg::srcUnsafe);
</I>&gt;&gt;<i>      const bool safeReply = !filled-&gt;reply ||
</I>&gt;&gt;<i>          !(filled-&gt;reply-&gt;sources &amp; HttpMsg::srcUnsafe);
</I>&gt;&gt;<i>      return (safeRequest &amp;&amp; safeReply) ? 1 : 0;
</I>&gt;<i> 
</I>&gt;<i> Yes!
</I>
Aha! that rather dramatically changes the ACL behaviour matrix in about
half the &quot;opportunistic security&quot; cases.


&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Furthermore, the values of &quot;unsafe&quot; srcX enum constants should be
</I>&gt;&gt;<i> increased to actually match the srcUnsafe mask (16 is still smaller than
</I>&gt;&gt;<i> 0xFFFF).
</I>&gt;<i> 
</I>&gt;<i> This is should be OK.
</I>&gt;<i> The safe flags are from:
</I>&gt;<i>  (1 &lt;&lt; (16 + 0)) = (1 &lt;&lt; (16 + 0)) &amp; 0xFFFF0000
</I>&gt;<i> to:
</I>&gt;<i>   (1 &lt;&lt; (16 + 15)) = (1 &lt;&lt; (16 + 15)) &amp; 0xFFFF0000
</I>&gt;<i> 
</I>&gt;<i> Am I loosing something?
</I>&gt;<i> (It is late here, this is not a time for playing with bits and shifts,
</I>&gt;<i> my mind is broken ...)
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> While I personally like the outcome (more security). Its clearly not
</I>&gt;&gt;&gt;<i> matching the use case presented as *sole* reason for the ACLs existence.
</I>&gt;&gt;&gt;<i> Nor the apparent admin policy in adaptation_access.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To me, it just looks like an implementation bug. Christos, do you think
</I>&gt;&gt;<i> the code should be rewritten as in my sketch above?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So I ask; why are we bothering with this ACL?
</I>&gt;&gt;&gt;<i>   Just use an <A HREF="https://">https://</A> scheme match, which will only be true in the top
</I>&gt;&gt;&gt;<i> line of above if()-matrix. Admin *wanting* &quot;opportunistic security&quot;
</I>&gt;&gt;&gt;<i> should not be the ones trying to avoid using icapS in the first place.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I have answered that question several times already, including providing
</I>&gt;&gt;<i> specific examples requested by Kinkie: The URI scheme alone does not
</I>&gt;&gt;<i> match what the ACL is defined to match.
</I>
It seems our difference of opinion about what was happening was caused
by that implementation bug that made received_encrypted overlap
significantly with &quot;proto HTTPS&quot;. With that fix the overlap is now
absent which removes my objection about that.


There are some small bits still to work out.

So finally the full audit...


in cf.data.pre:

* does not say clearly whether any value is used for this ACL.
 - I imagine not, but its unclear.


* the &quot;received&quot; part of the AC type name seems a bit odd.
 - perhapse &quot;connections_encrypted&quot; makes more sense with the
description for it, and focus on TLS connections.
 - I am minded that there are now also such fun things as having
received Content-Encoding encrypted messages in plain text, which may be
as confusing as &quot;opportunistic security&quot; to some.


* you mentionend cache HITs earlier.
 - IMO you can drop all mention of cache HIT in the commit message on
grounds that no reply connection was involved with HIT at the scope
level of &quot;current transaction&quot;.
 - there is no code relating to cache in the patch anyway.


in src/HttpMsg.h:

* Unless you are going to add secure eCAP flag functionality as part of
ths patch scope I dont see why we should have the extra code or enum for
srcEcaps existing yet.
 - please remove srcEcaps, or implement the ecaps flag feature.
 - TODO in places where the ecaps flag feature would need to hook in
seems sufficient to me at present.
 - what remains is plain eCAP which does not naturally involve network
connections, TLS or otherwise.
 - marking eCAP involvement does not seem useful either until that ecaps
feature is added. Please consider turning those into TODO as well,
though I will accept the current code for srcEcap.


* can you explain the rational of doing this with a bitmask instead of a
default-true 'tlsEncrypted' boolean flag in class HttpMsg ?
 - 32-bit mask is one more thing to remember and update when adding any
new Server or Client child class.
 - we could save 24 bits of memory now (later 56 bits) on every
HttpRequest/HttpReply object with a bool.


in src/acl/*:

* please dont use &quot;\ingroup&quot; in new code.
 - for this patch where possible put ACL things inside namespace &quot;Acl&quot;
instead.
 - I'm okay if you dont want to, but avoiding more SourceLayout
shuffling is always beneficial.


* in ACLReceivedEncrypted::dump() please make the empty SBufList a
static (const?), or just &quot;return SBufList();&quot;


* in match() of course the bug fix Alex mentioned.


in gopher.cc:

* please use HttpReply::Pointer instead of HTTPMSG*() macros.
 - or HttpReplyPointer from http/forward.h
 - this goes for all newly added HttpRequest/HttpReply pointers.


Cheers
Amos
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002843.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
	<LI>Next message: <A HREF="002849.html">[squid-dev] [PATCH] received_encrypted ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2847">[ date ]</a>
              <a href="thread.html#2847">[ thread ]</a>
              <a href="subject.html#2847">[ subject ]</a>
              <a href="author.html#2847">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
