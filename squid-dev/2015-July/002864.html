<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Coverity fixes, part 3
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Coverity%20fixes%2C%20part%203&In-Reply-To=%3C55B5723B.7080807%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002863.html">
   <LINK REL="Next"  HREF="002866.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Coverity fixes, part 3</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Coverity%20fixes%2C%20part%203&In-Reply-To=%3C55B5723B.7080807%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Coverity fixes, part 3">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Jul 26 23:50:19 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002863.html">[squid-dev] [PATCH] Coverity fixes, part 3
</A></li>
        <LI>Next message: <A HREF="002866.html">[squid-dev] [PATCH] Coverity fixes, part 3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2864">[ date ]</a>
              <a href="thread.html#2864">[ thread ]</a>
              <a href="subject.html#2864">[ subject ]</a>
              <a href="author.html#2864">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 27/07/2015 8:47 a.m., Kinkie wrote:
&gt;<i> On Sun, Jul 26, 2015 at 10:23 PM, Amos Jeffries &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid3 at treenet.co.nz</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> On 27/07/2015 4:48 a.m., Kinkie wrote:
</I>&gt;&gt;&gt;<i> HI,
</I>&gt;&gt;&gt;<i>   the low-hanging fruits from Coverity's analysis have been picked, now
</I>&gt;&gt;&gt;<i> working on somewhat more complex fixes.
</I>&gt;&gt;&gt;<i> The attached patch takes a hint from two benign coverity defects to:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> - refactor Digest auth's field lookup table to use a std::map instead of
</I>&gt;&gt;&gt;<i> abusing httpHeaderFieldsInfo; this improves readability and size of the
</I>&gt;&gt;&gt;<i> code, and has the added small bonus of lowering the lookup cost from
</I>&gt;&gt;<i> linear
</I>&gt;&gt;&gt;<i> to logarithmic
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> the Digest code has been run-tested. I'd like feedback on its style, as
</I>&gt;&gt;&gt;<i> httpHeaderFieldsInfo is abused similarly elswehere and I'm considering to
</I>&gt;&gt;&gt;<i> apply it elsewhere as well; it can then be further refined to get O(1)
</I>&gt;&gt;<i> via
</I>&gt;&gt;&gt;<i> a carefully-chosen hash (via std::unsorted_map)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My thoughts: (sorry if its a bit rambling)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I dont like spawning lots of new classes for basic things. I know its
</I>&gt;&gt;<i> essentially the C++ way. But applying pattern theory can go too far
</I>&gt;&gt;<i> sometimes. And this patterns usage is one case where I can see exactly
</I>&gt;&gt;<i> that happening.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You have a struct, a class, an enum and array. Thats a lot of custom
</I>&gt;&gt;<i> infrastructure just to represent a simple set of name:id. We could as
</I>&gt;&gt;<i> easily have std::map&lt;const char*, enum&gt; holding that directly and avoid
</I>&gt;&gt;<i> all the local types except enum.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are already 5 headers currently in Squid that need these same
</I>&gt;&gt;<i> operations applied, and at least as many more that should but dont even
</I>&gt;&gt;<i> use the current HttpHeaderFieldAttrs related types yet.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> struct HttpDigestFieldAttrs should be a template class so we dont have
</I>&gt;&gt;<i> to re-implement a new little struct for each enum.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> BUT, notice that generalizing that same structure is also where the enum
</I>&gt;&gt;<i> casting hack for HttpHeaderFieldAttrs comes from in the first place.
</I>&gt;&gt;<i>  The probkem was template style breaks with C++03 compilers thinking all
</I>&gt;&gt;<i> enums are of &quot;int&quot; type. Enter lots of repeated-instantiation complaints
</I>&gt;&gt;<i> from dumb compilers.
</I>&gt;&gt;<i>  I've not tried it with current C++11 compilers which are quite a bit
</I>&gt;&gt;<i> smarter. It may work now (or not).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If *that* can be solved then refactoring HttpHeaderFieldAttrs to a
</I>&gt;&gt;<i> template is better way forward. Maybe followed by replacing or
</I>&gt;&gt;<i> refactoring the HttpHeaderFieldInfo bits to avoid the performance
</I>&gt;&gt;<i> problem you identified.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i>   no rambling, it's ok.
</I>&gt;<i> Actually, the performance improvement is just a nice byproduct, that's not
</I>&gt;<i> the objective at all, as I tried explaining in the merge proposal.
</I>&gt;<i> The actual problem I was addressing is the multiple C casts used to try and
</I>&gt;<i> coerce anything resembling a map&lt;const char *, int&gt; into an http/1 header
</I>&gt;<i> table, simply because there is code in squid which implements that map as a
</I>&gt;<i> header table (and rather naively, at that - linear scan is SO fifties ;) ).
</I>&gt;<i> 
</I>&gt;<i> In fact, I argue that the proposed version is actually simpler than the
</I>&gt;<i> previous code; it can maybe even be simplified further but not much
</I>&gt;<i> further, let's go over it a bit toghether if you want.
</I>
It looks that way for a single case. But multiply the number of
type-specific little class and structs by 5, 10, 20 and the moving
pieces get to be so many that we can't be sure all the manualy crafted
bits actually all are doing the same thing.
So when the compilers let that template simplfication happen we may
discover multiple little hacks all over needing to fix.

&gt;<i> 
</I>&gt;<i> struct HttpDigestFieldAttrs is there simply to have a convenient
</I>&gt;<i> representation of the header table DigestAttrs. It makes no attempt to be
</I>&gt;<i> anything different. Can it be turned into
</I>&gt;<i> GenericInitializerFromStringTo&lt;enum foo&gt; ? Yes. Is it worth it for 3 LOC?
</I>&gt;<i> not so sure.
</I>&gt;<i> 
</I>&gt;<i> DigestFieldslookupTable_t is probably what you are lashing out at, I bet.
</I>
Its itching. :-)

&gt;<i> Yes, it could be made generic and templatized to represent a
</I>&gt;<i> SBuf-to-anything with a static table initializer. I haven't tried that as
</I>&gt;<i> that may be PMO and it may preclude turning the index from a map to an
</I>&gt;<i> unordered_map with a table-specific hasher (gperf-generated or
</I>&gt;<i> hand-written, it's rather trivial to do it in this and in many other cases
</I>&gt;<i> we care about).
</I>
I don't think that would be a problem. Since we dont need to change the
stored node types under the maps feet. The type / header name is always
pre-known, even when generating them dynamically as part of message parsing.


Try these ...

src/base/LookupTable.h:

/**
 * SBuf -&gt; enum lookup table.
 */
template&lt;class EnumType&gt;
class LookupTable {
public:
    typedef struct Record_ {
        const char *name;
        EnumType id;
    } Record;

    LookupTable(const EnumType theInvalid, const Record data[]) :
        invalidValue(theInvalid)
    {
        for (auto i = 0; data[i].name != nullptr; ++i) {
            lookupTable[SBuf(data[i].name)] = data[i].id;
        }
    }

    EnumType lookup(const SBuf &amp;key) const {
        auto r = lookupTable.find(key);
        if (r == lookupTable.end())
            return invalidValue;
        return r-&gt;second;
    }

private:
    typedef std::map&lt;const SBuf, EnumType&gt; lookupTable_t;
    lookupTable_t lookupTable;
    EnumType invalidValue;
};




in src/auth/digest/Config.cc (or wherever else needs a table):

static const LookupTable&lt;http_digest_attr_type&gt;::Record
  DigestAttrs_Exp[] = {
    {&quot;username&quot;, DIGEST_USERNAME},
    {&quot;realm&quot;, DIGEST_REALM},
    {&quot;qop&quot;, DIGEST_QOP},
    {&quot;algorithm&quot;, DIGEST_ALGORITHM},
    {&quot;uri&quot;, DIGEST_URI},
    {&quot;nonce&quot;, DIGEST_NONCE},
    {&quot;nc&quot;, DIGEST_NC},
    {&quot;cnonce&quot;, DIGEST_CNONCE},
    {&quot;response&quot;, DIGEST_RESPONSE},
    {nullptr, DIGEST_ENUM_END}
};

LookupTable&lt;http_digest_attr_type&gt;
DigestFieldsLookupTable(DIGEST_ENUM_END, DigestAttrs_Exp);



NOTE: range based for loops require begin/end operators. The default
definitions dont work for templated things apparently.
The constructor for loop is explicit now only because I could not be
bothered creating new ones for the LookupTable&lt;DataType&gt;::Record type.

Or we could be a bit fancy and use a while loop instead. Then magically
derive the invalidValue from whatever array entry has the nullptr for
its name.


&gt;<i> 
</I>&gt;<i> The patch has been build-tested successfully on all platforms we care
</I>&gt;<i> about, and run-tested (refactoring went in two phases: add new code,
</I>&gt;<i> assert() that it behaves like the old code and run-test, rip old code out).
</I>&gt;<i> 
</I>&gt;<i> IMVHO HttpHeaderFieldAttrs is poor legacy, and deserves a thankful and
</I>&gt;<i> merciful eviction from our code-base :)
</I>
Look closer. Its doing the exact same job as your HttpDigestFieldAttrs
but for a different enum name. That job wont change so long as that
other enum exists in Squid. And in your design we have a struct per enum
either way.

So applying this patch goes from x1 to x2 custom and slightly different
instances of the pattern. They you get to the S-C header that needs its
own version, now its got x3 instances. And so on.

The code re-use is not a future need. Its already got somewhere between
4 and 10 use cases existing in Squid that need to be updated. Then
theres the headers we have not implemented specific code for yet.


With my above template the pattern remains the same. Even uses almost
all your code. But we only define the custom enum + name array, and
instantiate a LookupTable from those.

PS. You can probably even remove HttpHeaderFieldAttrs,
HttpHeaderFieldInfo and friends entirely in favour of LookupTable&lt;&gt;.
Though I saw some stats gathering also going on when I looked at those.
Which is just another reason for it all to be kept identical/consistent
- counting digest field value sightings is an (un)important as cache
control ones.

Amos

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002863.html">[squid-dev] [PATCH] Coverity fixes, part 3
</A></li>
	<LI>Next message: <A HREF="002866.html">[squid-dev] [PATCH] Coverity fixes, part 3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2864">[ date ]</a>
              <a href="thread.html#2864">[ thread ]</a>
              <a href="subject.html#2864">[ subject ]</a>
              <a href="author.html#2864">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
