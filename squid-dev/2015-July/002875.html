<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] remove old GnuRegex third-party code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20remove%20old%20GnuRegex%20third-party%20code&In-Reply-To=%3C55B77AE4.7030404%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002872.html">
   <LINK REL="Next"  HREF="002876.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] remove old GnuRegex third-party code</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20remove%20old%20GnuRegex%20third-party%20code&In-Reply-To=%3C55B77AE4.7030404%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] remove old GnuRegex third-party code">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Jul 28 12:51:48 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002872.html">[squid-dev] [PATCH] implement std::hash&lt;SBuf&gt;
</A></li>
        <LI>Next message: <A HREF="002876.html">[squid-dev] [PATCH] remove old GnuRegex third-party code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2875">[ date ]</a>
              <a href="thread.html#2875">[ thread ]</a>
              <a href="subject.html#2875">[ subject ]</a>
              <a href="author.html#2875">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Squid currently bundles a copy of the 1998 GNU Regex library for use on
systems where a C libregex (-lregex and regex.h) is not available.

The attached patch replaces all Squid code uses of regex.h C API with
std::regex C++ API and drops the libregex related detections from
./configure


* In the present day all systems using C++11 provide a std::regex API
from the STL. This means all systems Squid-4 supports will provide it.

* STL component is adequate to our performance needs, being at least as
fast as the old GNU code and potentially much faster. The regex grammer
which we are using is a more modern upgraded version of GnuRegex anyway
when building with GCC.

* STL also has a wider base of cummunity support to fix any problems
that occur inside its logic. GnuRegex.* contain a handful of known bugs
that we have been unable to fix on our own already.



There are two side effects of this change which may be user visible:

1) The GNU library apparently violated POSIX extended regex grammar
standards by accepting double-quote (&quot;) characters in both raw and
escaped forms. The standard library obeys POSIX.

Any anyone whose config used patterns actually used double-quoting will
find their squid.conf no longer loading.

Given that the syntax is technically invalid regex, and the unit tests
which identify the issue were only added to test theoretical input case
I believe we can cope wth this. In the long term it may even help us
resolve the squid.conf parser tokenization issues separating regex from
other tokens.


2) People using CXXFLAGS or LDFLAGS to swap out the system libregex for
a custom one such as -lpcre may find that it no longer works.

That is just a maybe. Several factors impact on this;

a) Any custom regex library can integrate by presenting bindings for the
STL std::regex API now. Which is possible for them to do, but I am
unsure at this time if it is actually done.

b) The STL definition on several systems is already implemented using
those faster libraries. The libc++ / libstdc++ STL is itself doing the
backend binding to -lpcre or equivalent. Based on the STL authors own
performance testing specific to that system.

c) regex library replacement is primarily based on the belief that the
custom library will operate faster that what Squid otherwise finds. This
conflicts with (b), but also assumes that common benchmarking
information is true.

 - Several prominant &quot;PCRE is better&quot; analysis are in fact using
alternative grammars (Perl or ECSMAScript) which were appropriate for
the use cases being benchmarked. Squid exclusively uses POSIX extended
grammar. This makes the visible numbers an apples vs oranges problem.

 - Past attempts to migrate Squid from GnuRegex to libpcre were focussed
on changing the actual grammar used by Squid to faster grammar which was
not supported by GnuRegex. This patch is a requirement step to
completing that goal. It enables future flags to be added that simply
swap between STL supported regex grammars.

I believe that while this (2) side effect may be a small problem and/or
surprise initially in the long term it will prove to be much better.


Amos
-------------- next part --------------
=== modified file 'CREDITS'
--- CREDITS	2015-05-22 09:59:09 +0000
+++ CREDITS	2015-07-27 16:56:19 +0000
@@ -366,80 +366,40 @@
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 ==============================================================================
 
-compat/GnuRegex.h:
-
- * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
-==============================================================================
-
-compat/GnuRegex.c:
-
- * Copyright (C) 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
-==============================================================================
-
 compat/inet_ntop.c:
 
 /*
  * Copyright (c) 2004 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)
  * Copyright (c) 1996-1999 by Internet Software Consortium.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
  *
  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ISC DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 ==============================================================================

=== modified file 'acinclude/lib-checks.m4'
--- acinclude/lib-checks.m4	2015-04-08 05:27:24 +0000
+++ acinclude/lib-checks.m4	2015-07-27 16:37:29 +0000
@@ -15,60 +15,40 @@
     AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #if HAVE_SYS_TYPES_H
 #include &lt;sys/types.h&gt;
 #endif
 #if HAVE_LIMITS_H
 #include &lt;limits.h&gt;
 #endif
 #if HAVE_DB_185_H
 #include &lt;db_185.h&gt;
 #elif HAVE_DB_H
 #include &lt;db.h&gt;
 #endif]], 
 [[dbopen(&quot;&quot;, 0, 0, DB_HASH, (void *)0L)]])],
     [ac_cv_dbopen_libdb=&quot;yes&quot;],
     [ac_cv_dbopen_libdb=&quot;no&quot;])
     SQUID_STATE_ROLLBACK(dbopen_libdb)
   ])
 ])
 
 
-dnl check whether regex works by actually compiling one
-dnl sets squid_cv_regex_works to either yes or no
-
-AC_DEFUN([SQUID_CHECK_REGEX_WORKS],[
-  AC_CACHE_CHECK([if the system-supplied regex lib actually works],squid_cv_regex_works,[
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#if HAVE_SYS_TYPES_H
-#include &lt;sys/types.h&gt;
-#endif
-#if HAVE_REGEX_H
-#include &lt;regex.h&gt; 
-#endif
-]], [[
-regex_t t; regcomp(&amp;t,&quot;&quot;,0);]])],
-    [ squid_cv_regex_works=yes ],
-    [ squid_cv_regex_works=no ])
-  ])
-])
-
-
 AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
   AC_CACHE_CHECK([for libIpHlpApi],squid_cv_have_libiphlpapi,[
     SQUID_STATE_SAVE(iphlpapi)
     LIBS=&quot;$LIBS -liphlpapi&quot;
     AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include &lt;windows.h&gt;
 #include &lt;winsock2.h&gt;
 #include &lt;iphlpapi.h&gt;
 ]], [[
   MIB_IPNETTABLE i;
   unsigned long isz=sizeof(i);
   GetIpNetTable(&amp;i,&amp;isz,FALSE);
     ]])],
     [squid_cv_have_libiphlpapi=yes
      SQUID_STATE_COMMIT(iphlpapi)],
     [squid_cv_have_libiphlpapi=no
      SQUID_STATE_ROLLBACK(iphlpapi)])
   ])
   SQUID_STATE_ROLLBACK(iphlpapi)
 ])

=== removed file 'compat/GnuRegex.c'
--- compat/GnuRegex.c	2015-01-13 07:25:36 +0000
+++ compat/GnuRegex.c	1970-01-01 00:00:00 +0000
@@ -1,4311 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* Extended regular expression matching and search library,
- * version 0.12.
- * (Implements POSIX draft P10003.2/D11.2, except for
- * internationalization features.)
- *
- * Copyright (C) 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
-
-/* AIX requires this to be the first thing in the file. */
-#if defined (_AIX) &amp;&amp; !defined(REGEX_MALLOC)
-#pragma alloca
-#endif
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE 1
-#endif
-
-#include &quot;squid.h&quot;
-
-#if USE_GNUREGEX /* only if squid needs it. Usually not */
-
-#if !HAVE_ALLOCA
-#define REGEX_MALLOC 1
-#endif
-
-/* We used to test for `BSTRING' here, but only GCC and Emacs define
- * `BSTRING', as far as I know, and neither of them use this code.  */
-#if HAVE_STRING_H || STDC_HEADERS
-#include &lt;string.h&gt;
-#else
-#include &lt;strings.h&gt;
-#endif
-
-/* Define the syntax stuff for \&lt;, \&gt;, etc.  */
-
-/* This must be nonzero for the wordchar and notwordchar pattern
- * commands in re_match_2.  */
-#ifndef Sword
-#define Sword 1
-#endif
-
-#ifdef SYNTAX_TABLE
-
-extern char *re_syntax_table;
-
-#else /* not SYNTAX_TABLE */
-
-/* How many characters in the character set.  */
-#define CHAR_SET_SIZE 256
-
-static char re_syntax_table[CHAR_SET_SIZE];
-
-static void
-init_syntax_once(void)
-{
-    register int c;
-    static int done = 0;
-
-    if (done)
-        return;
-
-    memset(re_syntax_table, 0, sizeof re_syntax_table);
-
-    for (c = 'a'; c &lt;= 'z'; c++)
-        re_syntax_table[c] = Sword;
-
-    for (c = 'A'; c &lt;= 'Z'; c++)
-        re_syntax_table[c] = Sword;
-
-    for (c = '0'; c &lt;= '9'; c++)
-        re_syntax_table[c] = Sword;
-
-    re_syntax_table['_'] = Sword;
-
-    done = 1;
-}
-
-#endif /* not SYNTAX_TABLE */
-
-/* Get the interface, including the syntax bits.  */
-#include &quot;compat/GnuRegex.h&quot;
-
-/* Compile a fastmap for the compiled pattern in BUFFER; used to
- * accelerate searches.  Return 0 if successful and -2 if was an
- * internal error.  */
-static int re_compile_fastmap(struct re_pattern_buffer * buffer);
-
-/* Search in the string STRING (with length LENGTH) for the pattern
- * compiled into BUFFER.  Start searching at position START, for RANGE
- * characters.  Return the starting position of the match, -1 for no
- * match, or -2 for an internal error.  Also return register
- * information in REGS (if REGS and BUFFER-&gt;no_sub are nonzero).  */
-static int re_search(struct re_pattern_buffer * buffer, const char *string,
-                     int length, int start, int range, struct re_registers * regs);
-
-/* Like `re_search', but search in the concatenation of STRING1 and
- * STRING2.  Also, stop searching at index START + STOP.  */
-static int re_search_2(struct re_pattern_buffer * buffer, const char *string1,
-                       int length1, const char *string2, int length2,
-                       int start, int range, struct re_registers * regs, int stop);
-
-/* Like `re_search_2', but return how many characters in STRING the regexp
- * in BUFFER matched, starting at position START.  */
-static int re_match_2(struct re_pattern_buffer * buffer, const char *string1,
-                      int length1, const char *string2, int length2,
-                      int start, struct re_registers * regs, int stop);
-
-/* isalpha etc. are used for the character classes.  */
-#include &lt;ctype.h&gt;
-
-#ifndef isascii
-#define isascii(c) 1
-#endif
-
-#ifdef isblank
-#define ISBLANK(c) (isascii ((unsigned char)c) &amp;&amp; isblank ((unsigned char)c))
-#else
-#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
-#endif
-#ifdef isgraph
-#define ISGRAPH(c) (isascii ((unsigned char)c) &amp;&amp; isgraph ((unsigned char)c))
-#else
-#define ISGRAPH(c) (isascii ((unsigned char)c) &amp;&amp; isprint ((unsigned char)c) &amp;&amp; !isspace ((unsigned char)c))
-#endif
-
-#define ISPRINT(c) (isascii ((unsigned char)c) &amp;&amp; isprint ((unsigned char)c))
-#define ISDIGIT(c) (isascii ((unsigned char)c) &amp;&amp; isdigit ((unsigned char)c))
-#define ISALNUM(c) (isascii ((unsigned char)c) &amp;&amp; isalnum ((unsigned char)c))
-#define ISALPHA(c) (isascii ((unsigned char)c) &amp;&amp; isalpha ((unsigned char)c))
-#define ISCNTRL(c) (isascii ((unsigned char)c) &amp;&amp; iscntrl ((unsigned char)c))
-#define ISLOWER(c) (isascii ((unsigned char)c) &amp;&amp; islower ((unsigned char)c))
-#define ISPUNCT(c) (isascii ((unsigned char)c) &amp;&amp; ispunct ((unsigned char)c))
-#define ISSPACE(c) (isascii ((unsigned char)c) &amp;&amp; isspace ((unsigned char)c))
-#define ISUPPER(c) (isascii ((unsigned char)c) &amp;&amp; isupper ((unsigned char)c))
-#define ISXDIGIT(c) (isascii ((unsigned char)c) &amp;&amp; isxdigit ((unsigned char)c))
-
-/* We remove any previous definition of `SIGN_EXTEND_CHAR',
- * since ours (we hope) works properly with all combinations of
- * machines, compilers, `char' and `unsigned char' argument types.
- * (Per Bothner suggested the basic approach.)  */
-#undef SIGN_EXTEND_CHAR
-#ifdef __STDC__
-#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
-#else /* not __STDC__ */
-/* As in Harbison and Steele.  */
-#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
-#endif
-
-/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
- * use `alloca' instead of `malloc'.  This is because using malloc in
- * re_search* or re_match* could cause memory leaks when C-g is used in
- * Emacs; also, malloc is slower and causes storage fragmentation.  On
- * the other hand, malloc is more portable, and easier to debug.
- *
- * Because we sometimes use alloca, some routines have to be macros,
- * not functions -- `alloca'-allocated space disappears at the end of the
- * function it is called in.  */
-
-#ifdef REGEX_MALLOC
-
-#define REGEX_ALLOCATE malloc
-#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
-
-#else /* not REGEX_MALLOC  */
-
-/* Emacs already defines alloca, sometimes.  */
-#ifndef alloca
-
-/* Make alloca work the best possible way.  */
-#ifdef __GNUC__
-#define alloca __builtin_alloca
-#else /* not __GNUC__ */
-#if HAVE_ALLOCA_H
-#include &lt;alloca.h&gt;
-#else /* not __GNUC__ or HAVE_ALLOCA_H */
-#ifndef _AIX            /* Already did AIX, up at the top.  */
-char *alloca();
-#endif /* not _AIX */
-#endif /* not HAVE_ALLOCA_H */
-#endif /* not __GNUC__ */
-
-#endif /* not alloca */
-
-#define REGEX_ALLOCATE alloca
-
-/* Assumes a `char *destination' variable.  */
-#define REGEX_REALLOCATE(source, osize, nsize)              \
-  (destination = (char *) alloca (nsize),               \
-   memcpy (destination, source, osize),             \
-   destination)
-
-#endif /* not REGEX_MALLOC */
-
-/* True if `size1' is non-NULL and PTR is pointing anywhere inside
- * `string1' or just past its end.  This works if PTR is NULL, which is
- * a good thing.  */
-#define FIRST_STRING_P(ptr)                     \
-  (size1 &amp;&amp; string1 &lt;= (ptr) &amp;&amp; (ptr) &lt;= string1 + size1)
-
-/* (Re)Allocate N items of type T using malloc, or fail.  */
-#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
-#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
-#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
-
-#define BYTEWIDTH 8     /* In bits.  */
-
-#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
-
-#if !defined(__MINGW32__)   /* MinGW defines boolean */
-typedef char boolean;
-#endif
-#define false 0
-#define true 1
-
-/* These are the command codes that appear in compiled regular
- * expressions.  Some opcodes are followed by argument bytes.  A
- * command code can specify any interpretation whatsoever for its
- * arguments.  Zero bytes may appear in the compiled regular expression.
- *
- * The value of `exactn' is needed in search.c (search_buffer) in Emacs.
- * So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
- * `exactn' we use here must also be 1.  */
-
-typedef enum {
-    no_op = 0,
-
-    /* Followed by one byte giving n, then by n literal bytes.  */
-    exactn = 1,
-
-    /* Matches any (more or less) character.  */
-    anychar,
-
-    /* Matches any one char belonging to specified set.  First
-     * following byte is number of bitmap bytes.  Then come bytes
-     * for a bitmap saying which chars are in.  Bits in each byte
-     * are ordered low-bit-first.  A character is in the set if its
-     * bit is 1.  A character too large to have a bit in the map is
-     * automatically not in the set.  */
-    charset,
-
-    /* Same parameters as charset, but match any character that is
-     * not one of those specified.  */
-    charset_not,
-
-    /* Start remembering the text that is matched, for storing in a
-     * register.  Followed by one byte with the register number, in
-     * the range 0 to one less than the pattern buffer's re_nsub
-     * field.  Then followed by one byte with the number of groups
-     * inner to this one.  (This last has to be part of the
-     * start_memory only because we need it in the on_failure_jump
-     * of re_match_2.)  */
-    start_memory,
-
-    /* Stop remembering the text that is matched and store it in a
-     * memory register.  Followed by one byte with the register
-     * number, in the range 0 to one less than `re_nsub' in the
-     * pattern buffer, and one byte with the number of inner groups,
-     * just like `start_memory'.  (We need the number of inner
-     * groups here because we don't have any easy way of finding the
-     * corresponding start_memory when we're at a stop_memory.)  */
-    stop_memory,
-
-    /* Match a duplicate of something remembered. Followed by one
-     * byte containing the register number.  */
-    duplicate,
-
-    /* Fail unless at beginning of line.  */
-    begline,
-
-    /* Fail unless at end of line.  */
-    endline,
-
-    /* Succeeds if or at beginning of string to be matched.  */
-    begbuf,
-
-    /* Analogously, for end of buffer/string.  */
-    endbuf,
-
-    /* Followed by two byte relative address to which to jump.  */
-    jump,
-
-    /* Same as jump, but marks the end of an alternative.  */
-    jump_past_alt,
-
-    /* Followed by two-byte relative address of place to resume at
-     * in case of failure.  */
-    on_failure_jump,
-
-    /* Like on_failure_jump, but pushes a placeholder instead of the
-     * current string position when executed.  */
-    on_failure_keep_string_jump,
-
-    /* Throw away latest failure point and then jump to following
-     * two-byte relative address.  */
-    pop_failure_jump,
-
-    /* Change to pop_failure_jump if know won't have to backtrack to
-     * match; otherwise change to jump.  This is used to jump
-     * back to the beginning of a repeat.  If what follows this jump
-     * clearly won't match what the repeat does, such that we can be
-     * sure that there is no use backtracking out of repetitions
-     * already matched, then we change it to a pop_failure_jump.
-     * Followed by two-byte address.  */
-    maybe_pop_jump,
-
-    /* Jump to following two-byte address, and push a dummy failure
-     * point. This failure point will be thrown away if an attempt
-     * is made to use it for a failure.  A `+' construct makes this
-     * before the first repeat.  Also used as an intermediary kind
-     * of jump when compiling an alternative.  */
-    dummy_failure_jump,
-
-    /* Push a dummy failure point and continue.  Used at the end of
-     * alternatives.  */
-    push_dummy_failure,
-
-    /* Followed by two-byte relative address and two-byte number n.
-     * After matching N times, jump to the address upon failure.  */
-    succeed_n,
-
-    /* Followed by two-byte relative address, and two-byte number n.
-     * Jump to the address N times, then fail.  */
-    jump_n,
-
-    /* Set the following two-byte relative address to the
-     * subsequent two-byte number.  The address *includes* the two
-     * bytes of number.  */
-    set_number_at,
-
-    wordchar,           /* Matches any word-constituent character.  */
-    notwordchar,        /* Matches any char that is not a word-constituent.  */
-
-    wordbeg,            /* Succeeds if at word beginning.  */
-    wordend,            /* Succeeds if at word end.  */
-
-    wordbound,          /* Succeeds if at a word boundary.  */
-    notwordbound        /* Succeeds if not at a word boundary.  */
-
-} re_opcode_t;
-
-/* Common operations on the compiled pattern.  */
-
-/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
-
-#define STORE_NUMBER(destination, number)               \
-  do {                                  \
-    (destination)[0] = (number) &amp; 0377;                 \
-    (destination)[1] = (number) &gt;&gt; 8;                   \
-  } while (0)
-
-/* Same as STORE_NUMBER, except increment DESTINATION to
- * the byte after where the number is stored.  Therefore, DESTINATION
- * must be an lvalue.  */
-
-#define STORE_NUMBER_AND_INCR(destination, number)          \
-  do {                                  \
-    STORE_NUMBER (destination, number);                 \
-    (destination) += 2;                         \
-  } while (0)
-
-/* Put into DESTINATION a number stored in two contiguous bytes starting
- * at SOURCE.  */
-
-#define EXTRACT_NUMBER(destination, source)             \
-  do {                                  \
-    (destination) = *(source) &amp; 0377;                   \
-    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) &lt;&lt; 8;       \
-  } while (0)
-
-#ifdef DEBUG
-static void
-extract_number(dest, source)
-int *dest;
-unsigned char *source;
-{
-    int temp = SIGN_EXTEND_CHAR(*(source + 1));
-    *dest = *source &amp; 0377;
-    *dest += temp &lt;&lt; 8;
-}
-
-#ifndef EXTRACT_MACROS      /* To debug the macros.  */
-#undef EXTRACT_NUMBER
-#define EXTRACT_NUMBER(dest, src) extract_number (&amp;dest, src)
-#endif /* not EXTRACT_MACROS */
-
-#endif /* DEBUG */
-
-/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
- * SOURCE must be an lvalue.  */
-
-#define EXTRACT_NUMBER_AND_INCR(destination, source)            \
-  do {                                  \
-    EXTRACT_NUMBER (destination, source);               \
-    (source) += 2;                          \
-  } while (0)
-
-#ifdef DEBUG
-static void
-extract_number_and_incr(destination, source)
-int *destination;
-unsigned char **source;
-{
-    extract_number(destination, *source);
-    *source += 2;
-}
-
-#ifndef EXTRACT_MACROS
-#undef EXTRACT_NUMBER_AND_INCR
-#define EXTRACT_NUMBER_AND_INCR(dest, src) \
-  extract_number_and_incr (&amp;dest, &amp;src)
-#endif /* not EXTRACT_MACROS */
-
-#endif /* DEBUG */
-
-/* If DEBUG is defined, Regex prints many voluminous messages about what
- * it is doing (if the variable `debug' is nonzero).  If linked with the
- * main program in `iregex.c', you can enter patterns and strings
- * interactively.  And if linked with the main program in `main.c' and
- * the other test files, you can run the already-written tests.  */
-
-#ifdef DEBUG
-
-static int debug = 0;
-
-#define DEBUG_STATEMENT(e) e
-#define DEBUG_PRINT1(x) if (debug) printf (x)
-#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
-#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
-#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
-#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)               \
-  if (debug) print_partial_compiled_pattern (s, e)
-#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)          \
-  if (debug) print_double_string (w, s1, sz1, s2, sz2)
-
-extern void printchar();
-
-/* Print the fastmap in human-readable form.  */
-
-void
-print_fastmap(fastmap)
-char *fastmap;
-{
-    unsigned was_a_range = 0;
-    unsigned i = 0;
-
-    while (i &lt; (1 &lt;&lt; BYTEWIDTH)) {
-        if (fastmap[i++]) {
-            was_a_range = 0;
-            printchar(i - 1);
-            while (i &lt; (1 &lt;&lt; BYTEWIDTH) &amp;&amp; fastmap[i]) {
-                was_a_range = 1;
-                i++;
-            }
-            if (was_a_range) {
-                printf(&quot;-&quot;);
-                printchar(i - 1);
-            }
-        }
-    }
-    putchar('\n');
-}
-
-/* Print a compiled pattern string in human-readable form, starting at
- * the START pointer into it and ending just before the pointer END.  */
-
-void
-print_partial_compiled_pattern(start, end)
-unsigned char *start;
-unsigned char *end;
-{
-    int mcnt, mcnt2;
-    unsigned char *p = start;
-    unsigned char *pend = end;
-
-    if (start == NULL) {
-        printf(&quot;(null)\n&quot;);
-        return;
-    }
-    /* Loop over pattern commands.  */
-    while (p &lt; pend) {
-        switch ((re_opcode_t) * p++) {
-        case no_op:
-            printf(&quot;/no_op&quot;);
-            break;
-
-        case exactn:
-            mcnt = *p++;
-            printf(&quot;/exactn/%d&quot;, mcnt);
-            do {
-                putchar('/');
-                printchar(*p++);
-            } while (--mcnt);
-            break;
-
-        case start_memory:
-            mcnt = *p++;
-            printf(&quot;/start_memory/%d/%d&quot;, mcnt, *p++);
-            break;
-
-        case stop_memory:
-            mcnt = *p++;
-            printf(&quot;/stop_memory/%d/%d&quot;, mcnt, *p++);
-            break;
-
-        case duplicate:
-            printf(&quot;/duplicate/%d&quot;, *p++);
-            break;
-
-        case anychar:
-            printf(&quot;/anychar&quot;);
-            break;
-
-        case charset:
-        case charset_not: {
-            register int c;
-
-            printf(&quot;/charset%s&quot;,
-                   (re_opcode_t) * (p - 1) == charset_not ? &quot;_not&quot; : &quot;&quot;);
-
-            assert(p + *p &lt; pend);
-
-            for (c = 0; c &lt; *p; c++) {
-                unsigned bit;
-                unsigned char map_byte = p[1 + c];
-
-                putchar('/');
-
-                for (bit = 0; bit &lt; BYTEWIDTH; bit++)
-                    if (map_byte &amp; (1 &lt;&lt; bit))
-                        printchar(c * BYTEWIDTH + bit);
-            }
-            p += 1 + *p;
-            break;
-        }
-
-        case begline:
-            printf(&quot;/begline&quot;);
-            break;
-
-        case endline:
-            printf(&quot;/endline&quot;);
-            break;
-
-        case on_failure_jump:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/on_failure_jump/0/%d&quot;, mcnt);
-            break;
-
-        case on_failure_keep_string_jump:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/on_failure_keep_string_jump/0/%d&quot;, mcnt);
-            break;
-
-        case dummy_failure_jump:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/dummy_failure_jump/0/%d&quot;, mcnt);
-            break;
-
-        case push_dummy_failure:
-            printf(&quot;/push_dummy_failure&quot;);
-            break;
-
-        case maybe_pop_jump:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/maybe_pop_jump/0/%d&quot;, mcnt);
-            break;
-
-        case pop_failure_jump:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/pop_failure_jump/0/%d&quot;, mcnt);
-            break;
-
-        case jump_past_alt:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/jump_past_alt/0/%d&quot;, mcnt);
-            break;
-
-        case jump:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            printf(&quot;/jump/0/%d&quot;, mcnt);
-            break;
-
-        case succeed_n:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            extract_number_and_incr(&amp;mcnt2, &amp;p);
-            printf(&quot;/succeed_n/0/%d/0/%d&quot;, mcnt, mcnt2);
-            break;
-
-        case jump_n:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            extract_number_and_incr(&amp;mcnt2, &amp;p);
-            printf(&quot;/jump_n/0/%d/0/%d&quot;, mcnt, mcnt2);
-            break;
-
-        case set_number_at:
-            extract_number_and_incr(&amp;mcnt, &amp;p);
-            extract_number_and_incr(&amp;mcnt2, &amp;p);
-            printf(&quot;/set_number_at/0/%d/0/%d&quot;, mcnt, mcnt2);
-            break;
-
-        case wordbound:
-            printf(&quot;/wordbound&quot;);
-            break;
-
-        case notwordbound:
-            printf(&quot;/notwordbound&quot;);
-            break;
-
-        case wordbeg:
-            printf(&quot;/wordbeg&quot;);
-            break;
-
-        case wordend:
-            printf(&quot;/wordend&quot;);
-
-        case wordchar:
-            printf(&quot;/wordchar&quot;);
-            break;
-
-        case notwordchar:
-            printf(&quot;/notwordchar&quot;);
-            break;
-
-        case begbuf:
-            printf(&quot;/begbuf&quot;);
-            break;
-
-        case endbuf:
-            printf(&quot;/endbuf&quot;);
-            break;
-
-        default:
-            printf(&quot;?%d&quot;, *(p - 1));
-        }
-    }
-    printf(&quot;/\n&quot;);
-}
-
-void
-print_compiled_pattern(bufp)
-struct re_pattern_buffer *bufp;
-{
-    unsigned char *buffer = bufp-&gt;buffer;
-
-    print_partial_compiled_pattern(buffer, buffer + bufp-&gt;used);
-    printf(&quot;%d bytes used/%d bytes allocated.\n&quot;, bufp-&gt;used, bufp-&gt;allocated);
-
-    if (bufp-&gt;fastmap_accurate &amp;&amp; bufp-&gt;fastmap) {
-        printf(&quot;fastmap: &quot;);
-        print_fastmap(bufp-&gt;fastmap);
-    }
-    printf(&quot;re_nsub: %d\t&quot;, bufp-&gt;re_nsub);
-    printf(&quot;regs_alloc: %d\t&quot;, bufp-&gt;regs_allocated);
-    printf(&quot;can_be_null: %d\t&quot;, bufp-&gt;can_be_null);
-    printf(&quot;newline_anchor: %d\n&quot;, bufp-&gt;newline_anchor);
-    printf(&quot;no_sub: %d\t&quot;, bufp-&gt;no_sub);
-    printf(&quot;not_bol: %d\t&quot;, bufp-&gt;not_bol);
-    printf(&quot;not_eol: %d\t&quot;, bufp-&gt;not_eol);
-    printf(&quot;syntax: %d\n&quot;, bufp-&gt;syntax);
-    /* Perhaps we should print the translate table?  */
-}
-
-void
-print_double_string(where, string1, size1, string2, size2)
-const char *where;
-const char *string1;
-const char *string2;
-int size1;
-int size2;
-{
-    unsigned this_char;
-
-    if (where == NULL)
-        printf(&quot;(null)&quot;);
-    else {
-        if (FIRST_STRING_P(where)) {
-            for (this_char = where - string1; this_char &lt; size1; this_char++)
-                printchar(string1[this_char]);
-
-            where = string2;
-        }
-        for (this_char = where - string2; this_char &lt; size2; this_char++)
-            printchar(string2[this_char]);
-    }
-}
-
-#else /* not DEBUG */
-
-#undef assert
-#define assert(e)
-
-#define DEBUG_STATEMENT(e)
-#define DEBUG_PRINT1(x)
-#define DEBUG_PRINT2(x1, x2)
-#define DEBUG_PRINT3(x1, x2, x3)
-#define DEBUG_PRINT4(x1, x2, x3, x4)
-#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
-#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
-
-#endif /* not DEBUG */
-
-/* This table gives an error message for each of the error codes listed
- * in regex.h.  Obviously the order here has to be same as there.  */
-
-static const char *re_error_msg[] = {NULL,              /* REG_NOERROR */
-                                     &quot;No match&quot;,            /* REG_NOMATCH */
-                                     &quot;Invalid regular expression&quot;,  /* REG_BADPAT */
-                                     &quot;Invalid collation character&quot;, /* REG_ECOLLATE */
-                                     &quot;Invalid character class name&quot;,    /* REG_ECTYPE */
-                                     &quot;Trailing backslash&quot;,  /* REG_EESCAPE */
-                                     &quot;Invalid back reference&quot;,  /* REG_ESUBREG */
-                                     &quot;Unmatched [ or [^&quot;,   /* REG_EBRACK */
-                                     &quot;Unmatched ( or \\(&quot;,  /* REG_EPAREN */
-                                     &quot;Unmatched \\{&quot;,       /* REG_EBRACE */
-                                     &quot;Invalid content of \\{\\}&quot;,   /* REG_BADBR */
-                                     &quot;Invalid range end&quot;,   /* REG_ERANGE */
-                                     &quot;Memory exhausted&quot;,        /* REG_ESPACE */
-                                     &quot;Invalid preceding regular expression&quot;,    /* REG_BADRPT */
-                                     &quot;Premature end of regular expression&quot;, /* REG_EEND */
-                                     &quot;Regular expression too big&quot;,  /* REG_ESIZE */
-                                     &quot;Unmatched ) or \\)&quot;,  /* REG_ERPAREN */
-                                    };
-
-/* Subroutine declarations and macros for regex_compile.  */
-
-/* Fetch the next character in the uncompiled pattern---translating it
- * if necessary.  Also cast from a signed character in the constant
- * string passed to us by the user to an unsigned char that we can use
- * as an array index (in, e.g., `translate').  */
-#define PATFETCH(c)                         \
-  do {if (p == pend) return REG_EEND;                   \
-    c = (unsigned char) *p++;                       \
-    if (translate) c = translate[c];                    \
-  } while (0)
-
-/* Fetch the next character in the uncompiled pattern, with no
- * translation.  */
-#define PATFETCH_RAW(c)                         \
-  do {if (p == pend) return REG_EEND;                   \
-    c = (unsigned char) *p++;                       \
-  } while (0)
-
-/* Go backwards one character in the pattern.  */
-#define PATUNFETCH p--
-
-/* If `translate' is non-null, return translate[D], else just D.  We
- * cast the subscript to translate because some data is declared as
- * `char *', to avoid warnings when a string constant is passed.  But
- * when we use a character as a subscript we must make it unsigned.  */
-#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
-
-/* Macros for outputting the compiled pattern into `buffer'.  */
-
-/* If the buffer isn't allocated when it comes in, use this.  */
-#define INIT_BUF_SIZE  32
-
-/* Make sure we have at least N more bytes of space in buffer.  */
-#define GET_BUFFER_SPACE(n)                     \
-    while (b - bufp-&gt;buffer + (n) &gt; bufp-&gt;allocated)            \
-      EXTEND_BUFFER ()
-
-/* Make sure we have one more byte of buffer space and then add C to it.  */
-#define BUF_PUSH(c)                         \
-  do {                                  \
-    GET_BUFFER_SPACE (1);                       \
-    *b++ = (unsigned char) (c);                     \
-  } while (0)
-
-/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
-#define BUF_PUSH_2(c1, c2)                      \
-  do {                                  \
-    GET_BUFFER_SPACE (2);                       \
-    *b++ = (unsigned char) (c1);                    \
-    *b++ = (unsigned char) (c2);                    \
-  } while (0)
-
-/* As with BUF_PUSH_2, except for three bytes.  */
-#define BUF_PUSH_3(c1, c2, c3)                      \
-  do {                                  \
-    GET_BUFFER_SPACE (3);                       \
-    *b++ = (unsigned char) (c1);                    \
-    *b++ = (unsigned char) (c2);                    \
-    *b++ = (unsigned char) (c3);                    \
-  } while (0)
-
-/* Store a jump with opcode OP at LOC to location TO.  We store a
- * relative address offset by the three bytes the jump itself occupies.  */
-#define STORE_JUMP(op, loc, to) \
-  store_op1 (op, loc, (to) - (loc) - 3)
-
-/* Likewise, for a two-argument jump.  */
-#define STORE_JUMP2(op, loc, to, arg) \
-  store_op2 (op, loc, (to) - (loc) - 3, arg)
-
-/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
-#define INSERT_JUMP(op, loc, to) \
-  insert_op1 (op, loc, (to) - (loc) - 3, b)
-
-/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
-#define INSERT_JUMP2(op, loc, to, arg) \
-  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
-
-/* This is not an arbitrary limit: the arguments which represent offsets
- * into the pattern are two bytes long.  So if 2^16 bytes turns out to
- * be too small, many things would have to change.  */
-#define MAX_BUF_SIZE (1L &lt;&lt; 16)
-
-/* Extend the buffer by twice its current size via realloc and
- * reset the pointers that pointed into the old block to point to the
- * correct places in the new one.  If extending the buffer results in it
- * being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
-#define EXTEND_BUFFER()                         \
-  do {                                  \
-    unsigned char *old_buffer = bufp-&gt;buffer;               \
-    if (bufp-&gt;allocated == MAX_BUF_SIZE)                \
-      return REG_ESIZE;                         \
-    bufp-&gt;allocated &lt;&lt;= 1;                      \
-    if (bufp-&gt;allocated &gt; MAX_BUF_SIZE)                 \
-      bufp-&gt;allocated = MAX_BUF_SIZE;                   \
-    bufp-&gt;buffer = (unsigned char *) realloc (bufp-&gt;buffer, bufp-&gt;allocated);\
-    if (bufp-&gt;buffer == NULL)                       \
-      return REG_ESPACE;                        \
-    /* If the buffer moved, move all the pointers into it.  */      \
-    if (old_buffer != bufp-&gt;buffer)                 \
-      {                                 \
-        b = (b - old_buffer) + bufp-&gt;buffer;                \
-        begalt = (begalt - old_buffer) + bufp-&gt;buffer;          \
-        if (fixup_alt_jump)                     \
-          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp-&gt;buffer;\
-        if (laststart)                          \
-          laststart = (laststart - old_buffer) + bufp-&gt;buffer;      \
-        if (pending_exact)                      \
-          pending_exact = (pending_exact - old_buffer) + bufp-&gt;buffer;  \
-      }                                 \
-  } while (0)
-
-/* Since we have one byte reserved for the register number argument to
- * {start,stop}_memory, the maximum number of groups we can report
- * things about is what fits in that byte.  */
-#define MAX_REGNUM 255
-
-/* But patterns can have more than `MAX_REGNUM' registers.  We just
- * ignore the excess.  */
-typedef unsigned regnum_t;
-
-/* Macros for the compile stack.  */
-
-/* Since offsets can go either forwards or backwards, this type needs to
- * be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
-typedef int pattern_offset_t;
-
-typedef struct {
-    pattern_offset_t begalt_offset;
-    pattern_offset_t fixup_alt_jump;
-    pattern_offset_t inner_group_offset;
-    pattern_offset_t laststart_offset;
-    regnum_t regnum;
-} compile_stack_elt_t;
-
-typedef struct {
-    compile_stack_elt_t *stack;
-    unsigned size;
-    unsigned avail;     /* Offset of next open position.  */
-} compile_stack_type;
-
-static void store_op1(re_opcode_t op, unsigned char *loc, int arg);
-static void store_op2( re_opcode_t op, unsigned char *loc, int arg1, int arg2);
-static void insert_op1(re_opcode_t op, unsigned char *loc, int arg, unsigned char *end);
-static void insert_op2(re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end);
-static boolean at_begline_loc_p(const char * pattern, const char *p, reg_syntax_t syntax);
-static boolean at_endline_loc_p(const char *p, const char *pend, int syntax);
-static boolean group_in_compile_stack(compile_stack_type compile_stack, regnum_t regnum);
-static reg_errcode_t compile_range(const char **p_ptr, const char *pend, char *translate, reg_syntax_t syntax, unsigned char *b);
-
-#define INIT_COMPILE_STACK_SIZE 32
-
-/* The next available element.  */
-#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
-
-/* Set the bit for character C in a list.  */
-#define SET_LIST_BIT(c)                               \
-  (b[((unsigned char) (c)) / BYTEWIDTH]               \
-   |= 1 &lt;&lt; (((unsigned char) c) % BYTEWIDTH))
-
-/* Get the next unsigned number in the uncompiled pattern.  */
-#define GET_UNSIGNED_NUMBER(num)                    \
-  { if (p != pend)                          \
-     {                                  \
-       PATFETCH (c);                            \
-       while (ISDIGIT (c))                      \
-         {                              \
-           if (num &lt; 0)                         \
-              num = 0;                          \
-           num = num * 10 + c - '0';                    \
-           if (p == pend)                       \
-              break;                            \
-           PATFETCH (c);                        \
-         }                              \
-       }                                \
-    }
-
-#define CHAR_CLASS_MAX_LENGTH  6    /* Namely, `xdigit'.  */
-
-#define IS_CHAR_CLASS(string)                       \
-   (STREQ (string, &quot;alpha&quot;) || STREQ (string, &quot;upper&quot;)          \
-    || STREQ (string, &quot;lower&quot;) || STREQ (string, &quot;digit&quot;)       \
-    || STREQ (string, &quot;alnum&quot;) || STREQ (string, &quot;xdigit&quot;)      \
-    || STREQ (string, &quot;space&quot;) || STREQ (string, &quot;print&quot;)       \
-    || STREQ (string, &quot;punct&quot;) || STREQ (string, &quot;graph&quot;)       \
-    || STREQ (string, &quot;cntrl&quot;) || STREQ (string, &quot;blank&quot;))
-
-/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
- * Returns one of error codes defined in `regex.h', or zero for success.
- *
- * Assumes the `allocated' (and perhaps `buffer') and `translate'
- * fields are set in BUFP on entry.
- *
- * If it succeeds, results are put in BUFP (if it returns an error, the
- * contents of BUFP are undefined):
- * `buffer' is the compiled pattern;
- * `syntax' is set to SYNTAX;
- * `used' is set to the length of the compiled pattern;
- * `fastmap_accurate' is zero;
- * `re_nsub' is the number of subexpressions in PATTERN;
- * `not_bol' and `not_eol' are zero;
- *
- * The `fastmap' and `newline_anchor' fields are neither
- * examined nor set.  */
-
-static reg_errcode_t
-regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_pattern_buffer *bufp)
-{
-    /* We fetch characters from PATTERN here.  Even though PATTERN is
-     * `char *' (i.e., signed), we declare these variables as unsigned, so
-     * they can be reliably used as array indices.  */
-    register unsigned char c, c1;
-
-    /* A random tempory spot in PATTERN.  */
-    const char *p1;
-
-    /* Points to the end of the buffer, where we should append.  */
-    register unsigned char *b;
-
-    /* Keeps track of unclosed groups.  */
-    compile_stack_type compile_stack;
-
-    /* Points to the current (ending) position in the pattern.  */
-    const char *p = pattern;
-    const char *pend = pattern + size;
-
-    /* How to translate the characters in the pattern.  */
-    char *translate = bufp-&gt;translate;
-
-    /* Address of the count-byte of the most recently inserted `exactn'
-     * command.  This makes it possible to tell if a new exact-match
-     * character can be added to that command or if the character requires
-     * a new `exactn' command.  */
-    unsigned char *pending_exact = 0;
-
-    /* Address of start of the most recently finished expression.
-     * This tells, e.g., postfix * where to find the start of its
-     * operand.  Reset at the beginning of groups and alternatives.  */
-    unsigned char *laststart = 0;
-
-    /* Address of beginning of regexp, or inside of last group.  */
-    unsigned char *begalt;
-
-    /* Place in the uncompiled pattern (i.e., the {) to
-     * which to go back if the interval is invalid.  */
-    const char *beg_interval;
-
-    /* Address of the place where a forward jump should go to the end of
-     * the containing expression.  Each alternative of an `or' -- except the
-     * last -- ends with a forward jump of this sort.  */
-    unsigned char *fixup_alt_jump = 0;
-
-    /* Counts open-groups as they are encountered.  Remembered for the
-     * matching close-group on the compile stack, so the same register
-     * number is put in the stop_memory as the start_memory.  */
-    regnum_t regnum = 0;
-
-#ifdef DEBUG
-    DEBUG_PRINT1(&quot;\nCompiling pattern: &quot;);
-    if (debug) {
-        unsigned debug_count;
-
-        for (debug_count = 0; debug_count &lt; size; debug_count++)
-            printchar(pattern[debug_count]);
-        putchar('\n');
-    }
-#endif /* DEBUG */
-
-    /* Initialize the compile stack.  */
-    compile_stack.stack = TALLOC(INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
-    if (compile_stack.stack == NULL)
-        return REG_ESPACE;
-
-    compile_stack.size = INIT_COMPILE_STACK_SIZE;
-    compile_stack.avail = 0;
-
-    /* Initialize the pattern buffer.  */
-    bufp-&gt;syntax = syntax;
-    bufp-&gt;fastmap_accurate = 0;
-    bufp-&gt;not_bol = bufp-&gt;not_eol = 0;
-
-    /* Set `used' to zero, so that if we return an error, the pattern
-     * printer (for debugging) will think there's no pattern.  We reset it
-     * at the end.  */
-    bufp-&gt;used = 0;
-
-    /* Always count groups, whether or not bufp-&gt;no_sub is set.  */
-    bufp-&gt;re_nsub = 0;
-
-#if !defined (SYNTAX_TABLE)
-    /* Initialize the syntax table.  */
-    init_syntax_once();
-#endif
-
-    if (bufp-&gt;allocated == 0) {
-        if (bufp-&gt;buffer) {
-            /* If zero allocated, but buffer is non-null, try to realloc
-                     * enough space.  This loses if buffer's address is bogus, but
-                     * that is the user's responsibility.  */
-            RETALLOC(bufp-&gt;buffer, INIT_BUF_SIZE, unsigned char);
-        } else {        /* Caller did not allocate a buffer.  Do it for them.  */
-            bufp-&gt;buffer = TALLOC(INIT_BUF_SIZE, unsigned char);
-        }
-        if (!bufp-&gt;buffer)
-            return REG_ESPACE;
-
-        bufp-&gt;allocated = INIT_BUF_SIZE;
-    }
-    begalt = b = bufp-&gt;buffer;
-
-    /* Loop through the uncompiled pattern until we're at the end.  */
-    while (p != pend) {
-        PATFETCH(c);
-
-        switch (c) {
-        case '^': {
-            if (        /* If at start of pattern, it's an operator.  */
-                p == pattern + 1
-                /* If context independent, it's an operator.  */
-                || syntax &amp; RE_CONTEXT_INDEP_ANCHORS
-                /* Otherwise, depends on what's come before.  */
-                || at_begline_loc_p(pattern, p, syntax))
-                BUF_PUSH(begline);
-            else
-                goto normal_char;
-        }
-        break;
-
-        case '$': {
-            if (        /* If at end of pattern, it's an operator.  */
-                p == pend
-                /* If context independent, it's an operator.  */
-                || syntax &amp; RE_CONTEXT_INDEP_ANCHORS
-                /* Otherwise, depends on what's next.  */
-                || at_endline_loc_p(p, pend, syntax))
-                BUF_PUSH(endline);
-            else
-                goto normal_char;
-        }
-        break;
-
-        case '+':
-        case '?':
-            if ((syntax &amp; RE_BK_PLUS_QM)
-                    || (syntax &amp; RE_LIMITED_OPS))
-                goto normal_char;
-handle_plus:
-        case '*':
-            /* If there is no previous pattern... */
-            if (!laststart) {
-                if (syntax &amp; RE_CONTEXT_INVALID_OPS)
-                    return REG_BADRPT;
-                else if (!(syntax &amp; RE_CONTEXT_INDEP_OPS))
-                    goto normal_char;
-            } {
-                /* Are we optimizing this jump?  */
-                boolean keep_string_p = false;
-
-                /* 1 means zero (many) matches is allowed.  */
-                char zero_times_ok = 0, many_times_ok = 0;
-
-                /* If there is a sequence of repetition chars, collapse it
-                 * down to just one (the right one).  We can't combine
-                 * interval operators with these because of, e.g., `a{2}*',
-                 * which should only match an even number of `a's.  */
-
-                for (;;) {
-                    zero_times_ok |= c != '+';
-                    many_times_ok |= c != '?';
-
-                    if (p == pend)
-                        break;
-
-                    PATFETCH(c);
-
-                    if (c == '*'
-                            || (!(syntax &amp; RE_BK_PLUS_QM) &amp;&amp; (c == '+' || c == '?')));
-
-                    else if (syntax &amp; RE_BK_PLUS_QM &amp;&amp; c == '\\') {
-                        if (p == pend)
-                            return REG_EESCAPE;
-
-                        PATFETCH(c1);
-                        if (!(c1 == '+' || c1 == '?')) {
-                            PATUNFETCH;
-                            PATUNFETCH;
-                            break;
-                        }
-                        c = c1;
-                    } else {
-                        PATUNFETCH;
-                        break;
-                    }
-
-                    /* If we get here, we found another repeat character.  */
-                }
-
-                /* Star, etc. applied to an empty pattern is equivalent
-                 * to an empty pattern.  */
-                if (!laststart)
-                    break;
-
-                /* Now we know whether or not zero matches is allowed
-                 * and also whether or not two or more matches is allowed.  */
-                if (many_times_ok) {
-                    /* More than one repetition is allowed, so put in at the
-                         * end a backward relative jump from `b' to before the next
-                         * jump we're going to put in below (which jumps from
-                         * laststart to after this jump).
-                         *
-                         * But if we are at the `*' in the exact sequence `.*\n',
-                         * insert an unconditional jump backwards to the .,
-                         * instead of the beginning of the loop.  This way we only
-                         * push a failure point once, instead of every time
-                         * through the loop.  */
-                    assert(p - 1 &gt; pattern);
-
-                    /* Allocate the space for the jump.  */
-                    GET_BUFFER_SPACE(3);
-
-                    /* We know we are not at the first character of the pattern,
-                     * because laststart was nonzero.  And we've already
-                     * incremented `p', by the way, to be the character after
-                     * the `*'.  Do we have to do something analogous here
-                     * for null bytes, because of RE_DOT_NOT_NULL?  */
-                    if (TRANSLATE(*(p - 2)) == TRANSLATE('.')
-                            &amp;&amp; zero_times_ok
-                            &amp;&amp; p &lt; pend &amp;&amp; TRANSLATE(*p) == TRANSLATE('\n')
-                            &amp;&amp; !(syntax &amp; RE_DOT_NEWLINE)) {    /* We have .*\n.  */
-                        STORE_JUMP(jump, b, laststart);
-                        keep_string_p = true;
-                    } else
-                        /* Anything else.  */
-                        STORE_JUMP(maybe_pop_jump, b, laststart - 3);
-
-                    /* We've added more stuff to the buffer.  */
-                    b += 3;
-                }
-                /* On failure, jump from laststart to b + 3, which will be the
-                 * end of the buffer after this jump is inserted.  */
-                GET_BUFFER_SPACE(3);
-                INSERT_JUMP(keep_string_p ? on_failure_keep_string_jump
-                            : on_failure_jump,
-                            laststart, b + 3);
-                pending_exact = 0;
-                b += 3;
-
-                if (!zero_times_ok) {
-                    /* At least one repetition is required, so insert a
-                     * `dummy_failure_jump' before the initial
-                     * `on_failure_jump' instruction of the loop. This
-                     * effects a skip over that instruction the first time
-                     * we hit that loop.  */
-                    GET_BUFFER_SPACE(3);
-                    INSERT_JUMP(dummy_failure_jump, laststart, laststart + 6);
-                    b += 3;
-                }
-            }
-            break;
-
-        case '.':
-            laststart = b;
-            BUF_PUSH(anychar);
-            break;
-
-        case '[': {
-            boolean had_char_class = false;
-
-            if (p == pend)
-                return REG_EBRACK;
-
-            /* Ensure that we have enough space to push a charset: the
-             * opcode, the length count, and the bitset; 34 bytes in all.  */
-            GET_BUFFER_SPACE(34);
-
-            laststart = b;
-
-            /* We test `*p == '^' twice, instead of using an if
-             * statement, so we only need one BUF_PUSH.  */
-            BUF_PUSH(*p == '^' ? charset_not : charset);
-            if (*p == '^')
-                p++;
-
-            /* Remember the first position in the bracket expression.  */
-            p1 = p;
-
-            /* Push the number of bytes in the bitmap.  */
-            BUF_PUSH((1 &lt;&lt; BYTEWIDTH) / BYTEWIDTH);
-
-            /* Clear the whole map.  */
-            memset(b, 0, (1 &lt;&lt; BYTEWIDTH) / BYTEWIDTH);
-
-            /* charset_not matches newline according to a syntax bit.  */
-            if ((re_opcode_t) b[-2] == charset_not
-                    &amp;&amp; (syntax &amp; RE_HAT_LISTS_NOT_NEWLINE))
-                SET_LIST_BIT('\n');
-
-            /* Read in characters and ranges, setting map bits.  */
-            for (;;) {
-                if (p == pend)
-                    return REG_EBRACK;
-
-                PATFETCH(c);
-
-                /* \ might escape characters inside [...] and [^...].  */
-                if ((syntax &amp; RE_BACKSLASH_ESCAPE_IN_LISTS) &amp;&amp; c == '\\') {
-                    if (p == pend)
-                        return REG_EESCAPE;
-
-                    PATFETCH(c1);
-                    SET_LIST_BIT(c1);
-                    continue;
-                }
-                /* Could be the end of the bracket expression.  If it's
-                 * not (i.e., when the bracket expression is `[]' so
-                 * far), the ']' character bit gets set way below.  */
-                if (c == ']' &amp;&amp; p != p1 + 1)
-                    break;
-
-                /* Look ahead to see if it's a range when the last thing
-                 * was a character class.  */
-                if (had_char_class &amp;&amp; c == '-' &amp;&amp; *p != ']')
-                    return REG_ERANGE;
-
-                /* Look ahead to see if it's a range when the last thing
-                 * was a character: if this is a hyphen not at the
-                 * beginning or the end of a list, then it's the range
-                 * operator.  */
-                if (c == '-'
-                        &amp;&amp; !(p - 2 &gt;= pattern &amp;&amp; p[-2] == '[')
-                        &amp;&amp; !(p - 3 &gt;= pattern &amp;&amp; p[-3] == '[' &amp;&amp; p[-2] == '^')
-                        &amp;&amp; *p != ']') {
-                    reg_errcode_t ret
-                        = compile_range(&amp;p, pend, translate, syntax, b);
-                    if (ret != REG_NOERROR)
-                        return ret;
-                } else if (p[0] == '-' &amp;&amp; p[1] != ']') {    /* This handles ranges made up of characters only.  */
-                    reg_errcode_t ret;
-
-                    /* Move past the `-'.  */
-                    PATFETCH(c1);
-
-                    ret = compile_range(&amp;p, pend, translate, syntax, b);
-                    if (ret != REG_NOERROR)
-                        return ret;
-                }
-                /* See if we're at the beginning of a possible character
-                 * class.  */
-
-                else if (syntax &amp; RE_CHAR_CLASSES &amp;&amp; c == '[' &amp;&amp; *p == ':') {   /* Leave room for the null.  */
-                    char str[CHAR_CLASS_MAX_LENGTH + 1];
-
-                    PATFETCH(c);
-                    c1 = 0;
-
-                    /* If pattern is `[[:'.  */
-                    if (p == pend)
-                        return REG_EBRACK;
-
-                    for (;;) {
-                        PATFETCH(c);
-                        if (c == ':' || c == ']' || p == pend
-                                || c1 == CHAR_CLASS_MAX_LENGTH)
-                            break;
-                        str[c1++] = c;
-                    }
-                    str[c1] = '\0';
-
-                    /* If isn't a word bracketed by `[:' and:`]':
-                     * undo the ending character, the letters, and leave
-                     * the leading `:' and `[' (but set bits for them).  */
-                    if (c == ':' &amp;&amp; *p == ']') {
-                        int ch;
-                        boolean is_alnum = STREQ(str, &quot;alnum&quot;);
-                        boolean is_alpha = STREQ(str, &quot;alpha&quot;);
-                        boolean is_blank = STREQ(str, &quot;blank&quot;);
-                        boolean is_cntrl = STREQ(str, &quot;cntrl&quot;);
-                        boolean is_digit = STREQ(str, &quot;digit&quot;);
-                        boolean is_graph = STREQ(str, &quot;graph&quot;);
-                        boolean is_lower = STREQ(str, &quot;lower&quot;);
-                        boolean is_print = STREQ(str, &quot;print&quot;);
-                        boolean is_punct = STREQ(str, &quot;punct&quot;);
-                        boolean is_space = STREQ(str, &quot;space&quot;);
-                        boolean is_upper = STREQ(str, &quot;upper&quot;);
-                        boolean is_xdigit = STREQ(str, &quot;xdigit&quot;);
-
-                        if (!IS_CHAR_CLASS(str))
-                            return REG_ECTYPE;
-
-                        /* Throw away the ] at the end of the character
-                         * class.  */
-                        PATFETCH(c);
-
-                        if (p == pend)
-                            return REG_EBRACK;
-
-                        for (ch = 0; ch &lt; 1 &lt;&lt; BYTEWIDTH; ch++) {
-                            if ((is_alnum &amp;&amp; ISALNUM(ch))
-                                    || (is_alpha &amp;&amp; ISALPHA(ch))
-                                    || (is_blank &amp;&amp; ISBLANK(ch))
-                                    || (is_cntrl &amp;&amp; ISCNTRL(ch))
-                                    || (is_digit &amp;&amp; ISDIGIT(ch))
-                                    || (is_graph &amp;&amp; ISGRAPH(ch))
-                                    || (is_lower &amp;&amp; ISLOWER(ch))
-                                    || (is_print &amp;&amp; ISPRINT(ch))
-                                    || (is_punct &amp;&amp; ISPUNCT(ch))
-                                    || (is_space &amp;&amp; ISSPACE(ch))
-                                    || (is_upper &amp;&amp; ISUPPER(ch))
-                                    || (is_xdigit &amp;&amp; ISXDIGIT(ch)))
-                                SET_LIST_BIT(ch);
-                        }
-                        had_char_class = true;
-                    } else {
-                        c1++;
-                        while (c1--)
-                            PATUNFETCH;
-                        SET_LIST_BIT('[');
-                        SET_LIST_BIT(':');
-                        had_char_class = false;
-                    }
-                } else {
-                    had_char_class = false;
-                    SET_LIST_BIT(c);
-                }
-            }
-
-            /* Discard any (non)matching list bytes that are all 0 at the
-             * end of the map.  Decrease the map-length byte too.  */
-            while ((int) b[-1] &gt; 0 &amp;&amp; b[b[-1] - 1] == 0)
-                b[-1]--;
-            b += b[-1];
-        }
-        break;
-
-        case '(':
-            if (syntax &amp; RE_NO_BK_PARENS)
-                goto handle_open;
-            else
-                goto normal_char;
-
-        case ')':
-            if (syntax &amp; RE_NO_BK_PARENS)
-                goto handle_close;
-            else
-                goto normal_char;
-
-        case '\n':
-            if (syntax &amp; RE_NEWLINE_ALT)
-                goto handle_alt;
-            else
-                goto normal_char;
-
-        case '|':
-            if (syntax &amp; RE_NO_BK_VBAR)
-                goto handle_alt;
-            else
-                goto normal_char;
-
-        case '{':
-            if (syntax &amp; RE_INTERVALS &amp;&amp; syntax &amp; RE_NO_BK_BRACES)
-                goto handle_interval;
-            else
-                goto normal_char;
-
-        case '\\':
-            if (p == pend)
-                return REG_EESCAPE;
-
-            /* Do not translate the character after the \, so that we can
-             * distinguish, e.g., \B from \b, even if we normally would
-             * translate, e.g., B to b.  */
-            PATFETCH_RAW(c);
-
-            switch (c) {
-            case '(':
-                if (syntax &amp; RE_NO_BK_PARENS)
-                    goto normal_backslash;
-
-handle_open:
-                bufp-&gt;re_nsub++;
-                regnum++;
-
-                if (compile_stack.avail == compile_stack.size) {
-                    RETALLOC(compile_stack.stack, compile_stack.size &lt;&lt; 1,
-                             compile_stack_elt_t);
-                    if (compile_stack.stack == NULL)
-                        return REG_ESPACE;
-
-                    compile_stack.size &lt;&lt;= 1;
-                }
-                /* These are the values to restore when we hit end of this
-                 * group.  They are all relative offsets, so that if the
-                 * whole pattern moves because of realloc, they will still
-                 * be valid.  */
-                COMPILE_STACK_TOP.begalt_offset = begalt - bufp-&gt;buffer;
-                COMPILE_STACK_TOP.fixup_alt_jump
-                    = fixup_alt_jump ? fixup_alt_jump - bufp-&gt;buffer + 1 : 0;
-                COMPILE_STACK_TOP.laststart_offset = b - bufp-&gt;buffer;
-                COMPILE_STACK_TOP.regnum = regnum;
-
-                /* We will eventually replace the 0 with the number of
-                 * groups inner to this one.  But do not push a
-                 * start_memory for groups beyond the last one we can
-                 * represent in the compiled pattern.  */
-                if (regnum &lt;= MAX_REGNUM) {
-                    COMPILE_STACK_TOP.inner_group_offset = b - bufp-&gt;buffer + 2;
-                    BUF_PUSH_3(start_memory, regnum, 0);
-                }
-                compile_stack.avail++;
-
-                fixup_alt_jump = 0;
-                laststart = 0;
-                begalt = b;
-                /* If we've reached MAX_REGNUM groups, then this open
-                 * won't actually generate any code, so we'll have to
-                 * clear pending_exact explicitly.  */
-                pending_exact = 0;
-                break;
-
-            case ')':
-                if (syntax &amp; RE_NO_BK_PARENS)
-                    goto normal_backslash;
-
-                if (compile_stack.avail == 0) {
-                    if (syntax &amp; RE_UNMATCHED_RIGHT_PAREN_ORD)
-                        goto normal_backslash;
-                    else
-                        return REG_ERPAREN;
-                }
-handle_close:
-                if (fixup_alt_jump) {
-                    /* Push a dummy failure point at the end of the
-                         * alternative for a possible future
-                         * `pop_failure_jump' to pop.  See comments at
-                         * `push_dummy_failure' in `re_match_2'.  */
-                    BUF_PUSH(push_dummy_failure);
-
-                    /* We allocated space for this jump when we assigned
-                     * to `fixup_alt_jump', in the `handle_alt' case below.  */
-                    STORE_JUMP(jump_past_alt, fixup_alt_jump, b - 1);
-                }
-                /* See similar code for backslashed left paren above.  */
-                if (compile_stack.avail == 0) {
-                    if (syntax &amp; RE_UNMATCHED_RIGHT_PAREN_ORD)
-                        goto normal_char;
-                    else
-                        return REG_ERPAREN;
-                }
-                /* Since we just checked for an empty stack above, this
-                 * ``can't happen''.  */
-                assert(compile_stack.avail != 0);
-                {
-                    /* We don't just want to restore into `regnum', because
-                     * later groups should continue to be numbered higher,
-                     * as in `(ab)c(de)' -- the second group is #2.  */
-                    regnum_t this_group_regnum;
-
-                    compile_stack.avail--;
-                    begalt = bufp-&gt;buffer + COMPILE_STACK_TOP.begalt_offset;
-                    fixup_alt_jump
-                        = COMPILE_STACK_TOP.fixup_alt_jump
-                          ? bufp-&gt;buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
-                          : 0;
-                    laststart = bufp-&gt;buffer + COMPILE_STACK_TOP.laststart_offset;
-                    this_group_regnum = COMPILE_STACK_TOP.regnum;
-                    /* If we've reached MAX_REGNUM groups, then this open
-                     * won't actually generate any code, so we'll have to
-                     * clear pending_exact explicitly.  */
-                    pending_exact = 0;
-
-                    /* We're at the end of the group, so now we know how many
-                     * groups were inside this one.  */
-                    if (this_group_regnum &lt;= MAX_REGNUM) {
-                        unsigned char *inner_group_loc
-                            = bufp-&gt;buffer + COMPILE_STACK_TOP.inner_group_offset;
-
-                        *inner_group_loc = regnum - this_group_regnum;
-                        BUF_PUSH_3(stop_memory, this_group_regnum,
-                                   regnum - this_group_regnum);
-                    }
-                }
-                break;
-
-            case '|':       /* `\|'.  */
-                if (syntax &amp; RE_LIMITED_OPS || syntax &amp; RE_NO_BK_VBAR)
-                    goto normal_backslash;
-handle_alt:
-                if (syntax &amp; RE_LIMITED_OPS)
-                    goto normal_char;
-
-                /* Insert before the previous alternative a jump which
-                 * jumps to this alternative if the former fails.  */
-                GET_BUFFER_SPACE(3);
-                INSERT_JUMP(on_failure_jump, begalt, b + 6);
-                pending_exact = 0;
-                b += 3;
-
-                /* The alternative before this one has a jump after it
-                 * which gets executed if it gets matched.  Adjust that
-                 * jump so it will jump to this alternative's analogous
-                 * jump (put in below, which in turn will jump to the next
-                 * (if any) alternative's such jump, etc.).  The last such
-                 * jump jumps to the correct final destination.  A picture:
-                 * _____ _____
-                 * |   | |   |
-                 * |   v |   v
-                 * a | b   | c
-                 *
-                 * If we are at `b', then fixup_alt_jump right now points to a
-                 * three-byte space after `a'.  We'll put in the jump, set
-                 * fixup_alt_jump to right after `b', and leave behind three
-                 * bytes which we'll fill in when we get to after `c'.  */
-
-                if (fixup_alt_jump)
-                    STORE_JUMP(jump_past_alt, fixup_alt_jump, b);
-
-                /* Mark and leave space for a jump after this alternative,
-                 * to be filled in later either by next alternative or
-                 * when know we're at the end of a series of alternatives.  */
-                fixup_alt_jump = b;
-                GET_BUFFER_SPACE(3);
-                b += 3;
-
-                laststart = 0;
-                begalt = b;
-                break;
-
-            case '{':
-                /* If \{ is a literal.  */
-                if (!(syntax &amp; RE_INTERVALS)
-                        /* If we're at `\{' and it's not the open-interval
-                         * operator.  */
-                        || ((syntax &amp; RE_INTERVALS) &amp;&amp; (syntax &amp; RE_NO_BK_BRACES))
-                        || (p - 2 == pattern &amp;&amp; p == pend))
-                    goto normal_backslash;
-
-handle_interval: {
-                    /* If got here, then the syntax allows intervals.  */
-
-                    /* At least (most) this many matches must be made.  */
-                    int lower_bound = -1, upper_bound = -1;
-
-                    beg_interval = p - 1;
-
-                    if (p == pend) {
-                        if (syntax &amp; RE_NO_BK_BRACES)
-                            goto unfetch_interval;
-                        else
-                            return REG_EBRACE;
-                    }
-                    GET_UNSIGNED_NUMBER(lower_bound);
-
-                    if (c == ',') {
-                        GET_UNSIGNED_NUMBER(upper_bound);
-                        if (upper_bound &lt; 0)
-                            upper_bound = RE_DUP_MAX;
-                    } else
-                        /* Interval such as `{1}' =&gt; match exactly once. */
-                        upper_bound = lower_bound;
-
-                    if (lower_bound &lt; 0 || upper_bound &gt; RE_DUP_MAX
-                            || lower_bound &gt; upper_bound) {
-                        if (syntax &amp; RE_NO_BK_BRACES)
-                            goto unfetch_interval;
-                        else
-                            return REG_BADBR;
-                    }
-                    if (!(syntax &amp; RE_NO_BK_BRACES)) {
-                        if (c != '\\')
-                            return REG_EBRACE;
-
-                        PATFETCH(c);
-                    }
-                    if (c != '}') {
-                        if (syntax &amp; RE_NO_BK_BRACES)
-                            goto unfetch_interval;
-                        else
-                            return REG_BADBR;
-                    }
-                    /* We just parsed a valid interval.  */
-
-                    /* If it's invalid to have no preceding re.  */
-                    if (!laststart) {
-                        if (syntax &amp; RE_CONTEXT_INVALID_OPS)
-                            return REG_BADRPT;
-                        else if (syntax &amp; RE_CONTEXT_INDEP_OPS)
-                            laststart = b;
-                        else
-                            goto unfetch_interval;
-                    }
-                    /* If the upper bound is zero, don't want to succeed at
-                     * all; jump from `laststart' to `b + 3', which will be
-                     * the end of the buffer after we insert the jump.  */
-                    if (upper_bound == 0) {
-                        GET_BUFFER_SPACE(3);
-                        INSERT_JUMP(jump, laststart, b + 3);
-                        b += 3;
-                    }
-                    /* Otherwise, we have a nontrivial interval.  When
-                     * we're all done, the pattern will look like:
-                     * set_number_at &lt;jump count&gt; &lt;upper bound&gt;
-                     * set_number_at &lt;succeed_n count&gt; &lt;lower bound&gt;
-                     * succeed_n &lt;after jump addr&gt; &lt;succed_n count&gt;
-                     * &lt;body of loop&gt;
-                     * jump_n &lt;succeed_n addr&gt; &lt;jump count&gt;
-                     * (The upper bound and `jump_n' are omitted if
-                     * `upper_bound' is 1, though.)  */
-                    else {
-                        /* If the upper bound is &gt; 1, we need to insert
-                        * more at the end of the loop.  */
-                        unsigned nbytes = 10 + (upper_bound &gt; 1) * 10;
-
-                        GET_BUFFER_SPACE(nbytes);
-
-                        /* Initialize lower bound of the `succeed_n', even
-                         * though it will be set during matching by its
-                         * attendant `set_number_at' (inserted next),
-                         * because `re_compile_fastmap' needs to know.
-                         * Jump to the `jump_n' we might insert below.  */
-                        INSERT_JUMP2(succeed_n, laststart,
-                                     b + 5 + (upper_bound &gt; 1) * 5,
-                                     lower_bound);
-                        b += 5;
-
-                        /* Code to initialize the lower bound.  Insert
-                         * before the `succeed_n'.  The `5' is the last two
-                         * bytes of this `set_number_at', plus 3 bytes of
-                         * the following `succeed_n'.  */
-                        insert_op2(set_number_at, laststart, 5, lower_bound, b);
-                        b += 5;
-
-                        if (upper_bound &gt; 1) {
-                            /* More than one repetition is allowed, so
-                             * append a backward jump to the `succeed_n'
-                             * that starts this interval.
-                             *
-                             * When we've reached this during matching,
-                             * we'll have matched the interval once, so
-                             * jump back only `upper_bound - 1' times.  */
-                            STORE_JUMP2(jump_n, b, laststart + 5,
-                                        upper_bound - 1);
-                            b += 5;
-
-                            /* The location we want to set is the second
-                             * parameter of the `jump_n'; that is `b-2' as
-                             * an absolute address.  `laststart' will be
-                             * the `set_number_at' we're about to insert;
-                             * `laststart+3' the number to set, the source
-                             * for the relative address.  But we are
-                             * inserting into the middle of the pattern --
-                             * so everything is getting moved up by 5.
-                             * Conclusion: (b - 2) - (laststart + 3) + 5,
-                             * i.e., b - laststart.
-                             *
-                             * We insert this at the beginning of the loop
-                             * so that if we fail during matching, we'll
-                             * reinitialize the bounds.  */
-                            insert_op2(set_number_at, laststart, b - laststart,
-                                       upper_bound - 1, b);
-                            b += 5;
-                        }
-                    }
-                    pending_exact = 0;
-                    beg_interval = NULL;
-                }
-                break;
-
-unfetch_interval:
-                /* If an invalid interval, match the characters as literals.  */
-                assert(beg_interval);
-                p = beg_interval;
-                beg_interval = NULL;
-
-                /* normal_char and normal_backslash need `c'.  */
-                PATFETCH(c);
-
-                if (!(syntax &amp; RE_NO_BK_BRACES)) {
-                    if (p &gt; pattern &amp;&amp; p[-1] == '\\')
-                        goto normal_backslash;
-                }
-                goto normal_char;
-
-            case 'w':
-                laststart = b;
-                BUF_PUSH(wordchar);
-                break;
-
-            case 'W':
-                laststart = b;
-                BUF_PUSH(notwordchar);
-                break;
-
-            case '&lt;':
-                BUF_PUSH(wordbeg);
-                break;
-
-            case '&gt;':
-                BUF_PUSH(wordend);
-                break;
-
-            case 'b':
-                BUF_PUSH(wordbound);
-                break;
-
-            case 'B':
-                BUF_PUSH(notwordbound);
-                break;
-
-            case '`':
-                BUF_PUSH(begbuf);
-                break;
-
-            case '\'':
-                BUF_PUSH(endbuf);
-                break;
-
-            case '1':
-            case '2':
-            case '3':
-            case '4':
-            case '5':
-            case '6':
-            case '7':
-            case '8':
-            case '9':
-                if (syntax &amp; RE_NO_BK_REFS)
-                    goto normal_char;
-
-                c1 = c - '0';
-
-                if (c1 &gt; regnum)
-                    return REG_ESUBREG;
-
-                /* Can't back reference to a subexpression if inside of it.  */
-                if (group_in_compile_stack(compile_stack, c1))
-                    goto normal_char;
-
-                laststart = b;
-                BUF_PUSH_2(duplicate, c1);
-                break;
-
-            case '+':
-            case '?':
-                if (syntax &amp; RE_BK_PLUS_QM)
-                    goto handle_plus;
-                else
-                    goto normal_backslash;
-
-            default:
-normal_backslash:
-                /* You might think it would be useful for \ to mean
-                 * not to translate; but if we don't translate it
-                 * it will never match anything.  */
-                c = TRANSLATE(c);
-                goto normal_char;
-            }
-            break;
-
-        default:
-            /* Expects the character in `c'.  */
-normal_char:
-            /* If no exactn currently being built.  */
-            if (!pending_exact
-
-                    /* If last exactn not at current position.  */
-                    || pending_exact + *pending_exact + 1 != b
-
-                    /* We have only one byte following the exactn for the count.  */
-                    || *pending_exact == (1 &lt;&lt; BYTEWIDTH) - 1
-
-                    /* If followed by a repetition operator.  */
-                    || *p == '*' || *p == '^'
-                    || ((syntax &amp; RE_BK_PLUS_QM)
-                        ? *p == '\\' &amp;&amp; (p[1] == '+' || p[1] == '?')
-                        : (*p == '+' || *p == '?'))
-                    || ((syntax &amp; RE_INTERVALS)
-                        &amp;&amp; ((syntax &amp; RE_NO_BK_BRACES)
-                            ? *p == '{'
-                            : (p[0] == '\\' &amp;&amp; p[1] == '{')))) {
-                /* Start building a new exactn.  */
-
-                laststart = b;
-
-                BUF_PUSH_2(exactn, 0);
-                pending_exact = b - 1;
-            }
-            BUF_PUSH(c);
-            (*pending_exact)++;
-            break;
-        }           /* switch (c) */
-    }               /* while p != pend */
-
-    /* Through the pattern now.  */
-
-    if (fixup_alt_jump)
-        STORE_JUMP(jump_past_alt, fixup_alt_jump, b);
-
-    if (compile_stack.avail != 0)
-        return REG_EPAREN;
-
-    free(compile_stack.stack);
-
-    /* We have succeeded; set the length of the buffer.  */
-    bufp-&gt;used = b - bufp-&gt;buffer;
-
-#ifdef DEBUG
-    if (debug) {
-        DEBUG_PRINT1(&quot;\nCompiled pattern: &quot;);
-        print_compiled_pattern(bufp);
-    }
-#endif /* DEBUG */
-
-    return REG_NOERROR;
-}               /* regex_compile */
-
-/* Subroutines for `regex_compile'.  */
-
-/* Store OP at LOC followed by two-byte integer parameter ARG.  */
-
-void store_op1(re_opcode_t op, unsigned char *loc, int arg)
-{
-    *loc = (unsigned char) op;
-    STORE_NUMBER(loc + 1, arg);
-}
-
-/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
-
-void
-store_op2( re_opcode_t op, unsigned char *loc, int arg1, int arg2)
-{
-    *loc = (unsigned char) op;
-    STORE_NUMBER(loc + 1, arg1);
-    STORE_NUMBER(loc + 3, arg2);
-}
-
-/* Copy the bytes from LOC to END to open up three bytes of space at LOC
- * for OP followed by two-byte integer parameter ARG.  */
-
-void
-insert_op1(re_opcode_t op, unsigned char *loc, int arg, unsigned char *end)
-{
-    register unsigned char *pfrom = end;
-    register unsigned char *pto = end + 3;
-
-    while (pfrom != loc)
-        *--pto = *--pfrom;
-
-    store_op1(op, loc, arg);
-}
-
-/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
-
-void
-insert_op2(re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end)
-{
-    register unsigned char *pfrom = end;
-    register unsigned char *pto = end + 5;
-
-    while (pfrom != loc)
-        *--pto = *--pfrom;
-
-    store_op2(op, loc, arg1, arg2);
-}
-
-/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
- * after an alternative or a begin-subexpression.  We assume there is at
- * least one character before the ^.  */
-
-boolean
-at_begline_loc_p(const char * pattern, const char *p, reg_syntax_t syntax)
-{
-    const char *prev = p - 2;
-    boolean prev_prev_backslash = prev &gt; pattern &amp;&amp; prev[-1] == '\\';
-
-    return
-        /* After a subexpression?  */
-        (*prev == '(' &amp;&amp; (syntax &amp; RE_NO_BK_PARENS || prev_prev_backslash))
-        /* After an alternative?  */
-        || (*prev == '|' &amp;&amp; (syntax &amp; RE_NO_BK_VBAR || prev_prev_backslash));
-}
-
-/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
- * at least one character after the $, i.e., `P &lt; PEND'.  */
-
-boolean
-at_endline_loc_p(const char *p, const char *pend, int syntax)
-{
-    const char *next = p;
-    boolean next_backslash = *next == '\\';
-    const char *next_next = p + 1 &lt; pend ? p + 1 : NULL;
-
-    return
-        /* Before a subexpression?  */
-        (syntax &amp; RE_NO_BK_PARENS ? *next == ')'
-         : next_backslash &amp;&amp; next_next &amp;&amp; *next_next == ')')
-        /* Before an alternative?  */
-        || (syntax &amp; RE_NO_BK_VBAR ? *next == '|'
-            : next_backslash &amp;&amp; next_next &amp;&amp; *next_next == '|');
-}
-
-/* Returns true if REGNUM is in one of COMPILE_STACK's elements and
- * false if it's not.  */
-
-boolean
-group_in_compile_stack(compile_stack_type compile_stack, regnum_t regnum)
-{
-    int this_element;
-
-    for (this_element = compile_stack.avail - 1;
-            this_element &gt;= 0;
-            this_element--)
-        if (compile_stack.stack[this_element].regnum == regnum)
-            return true;
-
-    return false;
-}
-
-/* Read the ending character of a range (in a bracket expression) from the
- * uncompiled pattern *P_PTR (which ends at PEND).  We assume the
- * starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
- * Then we set the translation of all bits between the starting and
- * ending characters (inclusive) in the compiled pattern B.
- *
- * Return an error code.
- *
- * We use these short variable names so we can use the same macros as
- * `regex_compile' itself.  */
-
-reg_errcode_t
-compile_range(const char **p_ptr, const char *pend, char *translate, reg_syntax_t syntax, unsigned char *b)
-{
-    unsigned this_char;
-
-    const char *p = *p_ptr;
-    int range_start, range_end;
-
-    if (p == pend)
-        return REG_ERANGE;
-
-    /* Even though the pattern is a signed `char *', we need to fetch
-     * with unsigned char *'s; if the high bit of the pattern character
-     * is set, the range endpoints will be negative if we fetch using a
-     * signed char *.
-     *
-     * We also want to fetch the endpoints without translating them; the
-     * appropriate translation is done in the bit-setting loop below.  */
-    range_start = ((unsigned char *) p)[-2];
-    range_end = ((unsigned char *) p)[0];
-
-    /* Have to increment the pointer into the pattern string, so the
-     * caller isn't still at the ending character.  */
-    (*p_ptr)++;
-
-    /* If the start is after the end, the range is empty.  */
-    if (range_start &gt; range_end)
-        return syntax &amp; RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
-
-    /* Here we see why `this_char' has to be larger than an `unsigned
-     * char' -- the range is inclusive, so if `range_end' == 0xff
-     * (assuming 8-bit characters), we would otherwise go into an infinite
-     * loop, since all characters &lt;= 0xff.  */
-    for (this_char = range_start; this_char &lt;= range_end; this_char++) {
-        SET_LIST_BIT(TRANSLATE(this_char));
-    }
-
-    return REG_NOERROR;
-}
-
-/* Failure stack declarations and macros; both re_compile_fastmap and
- * re_match_2 use a failure stack.  These have to be macros because of
- * REGEX_ALLOCATE.  */
-
-/* Number of failure points for which to initially allocate space
- * when matching.  If this number is exceeded, we allocate more
- * space, so it is not a hard limit.  */
-#ifndef INIT_FAILURE_ALLOC
-#define INIT_FAILURE_ALLOC 5
-#endif
-
-/* Roughly the maximum number of failure points on the stack.  Would be
- * exactly that if always used MAX_FAILURE_SPACE each time we failed.
- * This is a variable only so users of regex can assign to it; we never
- * change it ourselves.  */
-int re_max_failures = 2000;
-
-typedef const unsigned char *fail_stack_elt_t;
-
-typedef struct {
-    fail_stack_elt_t *stack;
-    unsigned size;
-    unsigned avail;     /* Offset of next open position.  */
-} fail_stack_type;
-
-#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
-#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr-&gt;avail == 0)
-#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
-#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
-
-/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
-
-#define INIT_FAIL_STACK()                       \
-  do {                                  \
-    fail_stack.stack = (fail_stack_elt_t *)             \
-      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));  \
-                                    \
-    if (fail_stack.stack == NULL)                   \
-      return -2;                            \
-                                    \
-    fail_stack.size = INIT_FAILURE_ALLOC;               \
-    fail_stack.avail = 0;                       \
-  } while (0)
-
-/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
- *
- * Return 1 if succeeds, and 0 if either ran out of memory
- * allocating space for it or it was already too large.
- *
- * REGEX_REALLOCATE requires `destination' be declared.   */
-
-#define DOUBLE_FAIL_STACK(fail_stack)                   \
-  ((fail_stack).size &gt; re_max_failures * MAX_FAILURE_ITEMS      \
-   ? 0                                  \
-   : ((fail_stack).stack = (fail_stack_elt_t *)             \
-        REGEX_REALLOCATE ((fail_stack).stack,               \
-          (fail_stack).size * sizeof (fail_stack_elt_t),        \
-          ((fail_stack).size &lt;&lt; 1) * sizeof (fail_stack_elt_t)),    \
-                                    \
-      (fail_stack).stack == NULL                    \
-      ? 0                               \
-      : ((fail_stack).size &lt;&lt;= 1,                   \
-         1)))
-
-/* Push PATTERN_OP on FAIL_STACK.
- *
- * Return 1 if was able to do so and 0 if ran out of memory allocating
- * space to do so.  */
-#define PUSH_PATTERN_OP(pattern_op, fail_stack)             \
-  ((FAIL_STACK_FULL ()                          \
-    &amp;&amp; !DOUBLE_FAIL_STACK (fail_stack))                 \
-    ? 0                                 \
-    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,       \
-       1))
-
-/* This pushes an item onto the failure stack.  Must be a four-byte
- * value.  Assumes the variable `fail_stack'.  Probably should only
- * be called from within `PUSH_FAILURE_POINT'.  */
-#define PUSH_FAILURE_ITEM(item)                     \
-  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
-
-/* The complement operation.  Assumes `fail_stack' is nonempty.  */
-#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
-
-/* Used to omit pushing failure point id's when we're not debugging.  */
-#ifdef DEBUG
-#define DEBUG_PUSH PUSH_FAILURE_ITEM
-#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
-#else
-#define DEBUG_PUSH(item)
-#define DEBUG_POP(item_addr)
-#endif
-
-/* Push the information about the state we will need
- * if we ever fail back to it.
- *
- * Requires variables fail_stack, regstart, regend, reg_info, and
- * num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
- * declared.
- *
- * Does `return FAILURE_CODE' if runs out of memory.  */
-
-#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)   \
-  do {                                  \
-    char *destination;                          \
-    /* Must be int, so when we don't save any registers, the arithmetic \
-       of 0 + -1 isn't done as unsigned.  */                \
-    int this_reg;                           \
-                                        \
-    DEBUG_STATEMENT (failure_id++);                 \
-    DEBUG_STATEMENT (nfailure_points_pushed++);             \
-    DEBUG_PRINT2 (&quot;\nPUSH_FAILURE_POINT #%u:\n&quot;, failure_id);       \
-    DEBUG_PRINT2 (&quot;  Before push, next avail: %d\n&quot;, (fail_stack).avail);\
-    DEBUG_PRINT2 (&quot;                     size: %d\n&quot;, (fail_stack).size);\
-                                    \
-    DEBUG_PRINT2 (&quot;  slots needed: %d\n&quot;, NUM_FAILURE_ITEMS);       \
-    DEBUG_PRINT2 (&quot;     available: %d\n&quot;, REMAINING_AVAIL_SLOTS);   \
-                                    \
-    /* Ensure we have enough space allocated for what we will push.  */ \
-    while (REMAINING_AVAIL_SLOTS &lt; NUM_FAILURE_ITEMS)           \
-      {                                 \
-        if (!DOUBLE_FAIL_STACK (fail_stack))            \
-          return failure_code;                      \
-                                    \
-        DEBUG_PRINT2 (&quot;\n  Doubled stack; size now: %d\n&quot;,      \
-               (fail_stack).size);              \
-        DEBUG_PRINT2 (&quot;  slots available: %d\n&quot;, REMAINING_AVAIL_SLOTS);\
-      }                                 \
-                                    \
-    /* Push the info, starting with the registers.  */          \
-    DEBUG_PRINT1 (&quot;\n&quot;);                        \
-                                    \
-    for (this_reg = lowest_active_reg; this_reg &lt;= highest_active_reg;  \
-         this_reg++)                            \
-      {                                 \
-    DEBUG_PRINT2 (&quot;  Pushing reg: %d\n&quot;, this_reg);         \
-        DEBUG_STATEMENT (num_regs_pushed++);                \
-                                    \
-    DEBUG_PRINT2 (&quot;    start: 0x%x\n&quot;, regstart[this_reg]);     \
-        PUSH_FAILURE_ITEM (regstart[this_reg]);             \
-                                                                        \
-    DEBUG_PRINT2 (&quot;    end: 0x%x\n&quot;, regend[this_reg]);     \
-        PUSH_FAILURE_ITEM (regend[this_reg]);               \
-                                    \
-    DEBUG_PRINT2 (&quot;    info: 0x%x\n      &quot;, reg_info[this_reg]);    \
-        DEBUG_PRINT2 (&quot; match_null=%d&quot;,                 \
-                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));    \
-        DEBUG_PRINT2 (&quot; active=%d&quot;, IS_ACTIVE (reg_info[this_reg]));    \
-        DEBUG_PRINT2 (&quot; matched_something=%d&quot;,              \
-                      MATCHED_SOMETHING (reg_info[this_reg]));      \
-        DEBUG_PRINT2 (&quot; ever_matched=%d&quot;,               \
-                      EVER_MATCHED_SOMETHING (reg_info[this_reg])); \
-    DEBUG_PRINT1 (&quot;\n&quot;);                        \
-        PUSH_FAILURE_ITEM (reg_info[this_reg].word);            \
-      }                                 \
-                                    \
-    DEBUG_PRINT2 (&quot;  Pushing  low active reg: %d\n&quot;, lowest_active_reg);\
-    PUSH_FAILURE_ITEM (lowest_active_reg);              \
-                                    \
-    DEBUG_PRINT2 (&quot;  Pushing high active reg: %d\n&quot;, highest_active_reg);\
-    PUSH_FAILURE_ITEM (highest_active_reg);             \
-                                    \
-    DEBUG_PRINT2 (&quot;  Pushing pattern 0x%x: &quot;, pattern_place);       \
-    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);       \
-    PUSH_FAILURE_ITEM (pattern_place);                  \
-                                    \
-    DEBUG_PRINT2 (&quot;  Pushing string 0x%x: `&quot;, string_place);        \
-    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
-                 size2);                \
-    DEBUG_PRINT1 (&quot;'\n&quot;);                       \
-    PUSH_FAILURE_ITEM (string_place);                   \
-                                    \
-    DEBUG_PRINT2 (&quot;  Pushing failure id: %u\n&quot;, failure_id);        \
-    DEBUG_PUSH (failure_id);                        \
-  } while (0)
-
-/* This is the number of items that are pushed and popped on the stack
- * for each register.  */
-#define NUM_REG_ITEMS  3
-
-/* Individual items aside from the registers.  */
-#ifdef DEBUG
-#define NUM_NONREG_ITEMS 5  /* Includes failure point id.  */
-#else
-#define NUM_NONREG_ITEMS 4
-#endif
-
-/* We push at most this many items on the stack.  */
-#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
-
-/* We actually push this many items.  */
-#define NUM_FAILURE_ITEMS                       \
-  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS     \
-    + NUM_NONREG_ITEMS)
-
-/* How many items can still be added to the stack without overflowing it.  */
-#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
-
-/* Pops what PUSH_FAIL_STACK pushes.
- *
- * We restore into the parameters, all of which should be lvalues:
- * STR -- the saved data position.
- * PAT -- the saved pattern position.
- * LOW_REG, HIGH_REG -- the highest and lowest active registers.
- * REGSTART, REGEND -- arrays of string positions.
- * REG_INFO -- array of information about each subexpression.
- *
- * Also assumes the variables `fail_stack' and (if debugging), `bufp',
- * `pend', `string1', `size1', `string2', and `size2'.  */
-
-#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
-{                                   \
-  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)            \
-  int this_reg;                             \
-  const unsigned char *string_temp;                 \
-                                    \
-  assert (!FAIL_STACK_EMPTY ());                    \
-                                    \
-  /* Remove failure points and point to how many regs pushed.  */   \
-  DEBUG_PRINT1 (&quot;POP_FAILURE_POINT:\n&quot;);                \
-  DEBUG_PRINT2 (&quot;  Before pop, next avail: %d\n&quot;, fail_stack.avail);    \
-  DEBUG_PRINT2 (&quot;                    size: %d\n&quot;, fail_stack.size); \
-                                    \
-  assert (fail_stack.avail &gt;= NUM_NONREG_ITEMS);            \
-                                    \
-  DEBUG_POP (&amp;failure_id);                      \
-  DEBUG_PRINT2 (&quot;  Popping failure id: %u\n&quot;, failure_id);      \
-                                    \
-  /* If the saved string location is NULL, it came from an      \
-     on_failure_keep_string_jump opcode, and we want to throw away the  \
-     saved NULL, thus retaining our current position in the string.  */ \
-  string_temp = POP_FAILURE_ITEM ();                    \
-  if (string_temp != NULL)                      \
-    str = (const char *) string_temp;                   \
-                                    \
-  DEBUG_PRINT2 (&quot;  Popping string 0x%x: `&quot;, str);           \
-  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);  \
-  DEBUG_PRINT1 (&quot;'\n&quot;);                         \
-                                    \
-  pat = (unsigned char *) POP_FAILURE_ITEM ();              \
-  DEBUG_PRINT2 (&quot;  Popping pattern 0x%x: &quot;, pat);           \
-  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);           \
-                                    \
-  /* Restore register info.  */                     \
-  high_reg = (unsigned long) POP_FAILURE_ITEM ();           \
-  DEBUG_PRINT2 (&quot;  Popping high active reg: %d\n&quot;, high_reg);       \
-                                    \
-  low_reg = (unsigned long) POP_FAILURE_ITEM ();            \
-  DEBUG_PRINT2 (&quot;  Popping  low active reg: %d\n&quot;, low_reg);        \
-                                    \
-  for (this_reg = high_reg; this_reg &gt;= low_reg; this_reg--)        \
-    {                                   \
-      DEBUG_PRINT2 (&quot;    Popping reg: %d\n&quot;, this_reg);         \
-                                    \
-      reg_info[this_reg].word = POP_FAILURE_ITEM ();            \
-      DEBUG_PRINT2 (&quot;      info: 0x%x\n&quot;, reg_info[this_reg]);      \
-                                    \
-      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();        \
-      DEBUG_PRINT2 (&quot;      end: 0x%x\n&quot;, regend[this_reg]);     \
-                                    \
-      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();      \
-      DEBUG_PRINT2 (&quot;      start: 0x%x\n&quot;, regstart[this_reg]);     \
-    }                                   \
-                                    \
-  DEBUG_STATEMENT (nfailure_points_popped++);               \
-}               /* POP_FAILURE_POINT */
-
-/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
- * BUFP.  A fastmap records which of the (1 &lt;&lt; BYTEWIDTH) possible
- * characters can start a string that matches the pattern.  This fastmap
- * is used by re_search to skip quickly over impossible starting points.
- *
- * The caller must supply the address of a (1 &lt;&lt; BYTEWIDTH)-byte data
- * area as BUFP-&gt;fastmap.
- *
- * We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
- * the pattern buffer.
- *
- * Returns 0 if we succeed, -2 if an internal error.   */
-#ifdef STDC_HEADERS
-int
-re_compile_fastmap(struct re_pattern_buffer *bufp)
-#else
-int
-re_compile_fastmap(bufp)
-struct re_pattern_buffer *bufp;
-#endif
-{
-    int j, k;
-    fail_stack_type fail_stack;
-#ifndef REGEX_MALLOC
-    char *destination;
-#endif
-    /* We don't push any register information onto the failure stack.  */
-    unsigned num_regs = 0;
-
-    register char *fastmap = bufp-&gt;fastmap;
-    unsigned char *pattern = bufp-&gt;buffer;
-    unsigned long size = bufp-&gt;used;
-    const unsigned char *p = pattern;
-    register unsigned char *pend = pattern + size;
-
-    /* Assume that each path through the pattern can be null until
-     * proven otherwise.  We set this false at the bottom of switch
-     * statement, to which we get only if a particular path doesn't
-     * match the empty string.  */
-    boolean path_can_be_null = true;
-
-    /* We aren't doing a `succeed_n' to begin with.  */
-    boolean succeed_n_p = false;
-
-    assert(fastmap != NULL &amp;&amp; p != NULL);
-
-    INIT_FAIL_STACK();
-    memset(fastmap, 0, 1 &lt;&lt; BYTEWIDTH);     /* Assume nothing's valid.  */
-    bufp-&gt;fastmap_accurate = 1; /* It will be when we're done.  */
-    bufp-&gt;can_be_null = 0;
-
-    while (p != pend || !FAIL_STACK_EMPTY()) {
-        if (p == pend) {
-            bufp-&gt;can_be_null |= path_can_be_null;
-
-            /* Reset for next path.  */
-            path_can_be_null = true;
-
-            p = fail_stack.stack[--fail_stack.avail];
-        }
-        /* We should never be about to go beyond the end of the pattern.  */
-        assert(p &lt; pend);
-
-#ifdef SWITCH_ENUM_BUG
-        switch ((int) ((re_opcode_t) * p++))
-#else
-        switch ((re_opcode_t) * p++)
-#endif
-        {
-
-        /* I guess the idea here is to simply not bother with a fastmap
-         * if a backreference is used, since it's too hard to figure out
-         * the fastmap for the corresponding group.  Setting
-         * `can_be_null' stops `re_search_2' from using the fastmap, so
-         * that is all we do.  */
-        case duplicate:
-            bufp-&gt;can_be_null = 1;
-            return 0;
-
-        /* Following are the cases which match a character.  These end
-         * with `break'.  */
-
-        case exactn:
-            fastmap[p[1]] = 1;
-            break;
-
-        case charset:
-            for (j = *p++ * BYTEWIDTH - 1; j &gt;= 0; j--)
-                if (p[j / BYTEWIDTH] &amp; (1 &lt;&lt; (j % BYTEWIDTH)))
-                    fastmap[j] = 1;
-            break;
-
-        case charset_not:
-            /* Chars beyond end of map must be allowed.  */
-            for (j = *p * BYTEWIDTH; j &lt; (1 &lt;&lt; BYTEWIDTH); j++)
-                fastmap[j] = 1;
-
-            for (j = *p++ * BYTEWIDTH - 1; j &gt;= 0; j--)
-                if (!(p[j / BYTEWIDTH] &amp; (1 &lt;&lt; (j % BYTEWIDTH))))
-                    fastmap[j] = 1;
-            break;
-
-        case wordchar:
-            for (j = 0; j &lt; (1 &lt;&lt; BYTEWIDTH); j++)
-                if (re_syntax_table[j] == Sword)
-                    fastmap[j] = 1;
-            break;
-
-        case notwordchar:
-            for (j = 0; j &lt; (1 &lt;&lt; BYTEWIDTH); j++)
-                if (re_syntax_table[j] != Sword)
-                    fastmap[j] = 1;
-            break;
-
-        case anychar:
-            /* `.' matches anything ...  */
-            for (j = 0; j &lt; (1 &lt;&lt; BYTEWIDTH); j++)
-                fastmap[j] = 1;
-
-            /* ... except perhaps newline.  */
-            if (!(bufp-&gt;syntax &amp; RE_DOT_NEWLINE))
-                fastmap['\n'] = 0;
-
-            /* Return if we have already set `can_be_null'; if we have,
-             * then the fastmap is irrelevant.  Something's wrong here.  */
-            else if (bufp-&gt;can_be_null)
-                return 0;
-
-            /* Otherwise, have to check alternative paths.  */
-            break;
-
-        case no_op:
-        case begline:
-        case endline:
-        case begbuf:
-        case endbuf:
-        case wordbound:
-        case notwordbound:
-        case wordbeg:
-        case wordend:
-        case push_dummy_failure:
-            continue;
-
-        case jump_n:
-        case pop_failure_jump:
-        case maybe_pop_jump:
-        case jump:
-        case jump_past_alt:
-        case dummy_failure_jump:
-            EXTRACT_NUMBER_AND_INCR(j, p);
-            p += j;
-            if (j &gt; 0)
-                continue;
-
-            /* Jump backward implies we just went through the body of a
-             * loop and matched nothing.  Opcode jumped to should be
-             * `on_failure_jump' or `succeed_n'.  Just treat it like an
-             * ordinary jump.  For a * loop, it has pushed its failure
-             * point already; if so, discard that as redundant.  */
-            if ((re_opcode_t) * p != on_failure_jump
-                    &amp;&amp; (re_opcode_t) * p != succeed_n)
-                continue;
-
-            p++;
-            EXTRACT_NUMBER_AND_INCR(j, p);
-            p += j;
-
-            /* If what's on the stack is where we are now, pop it.  */
-            if (!FAIL_STACK_EMPTY()
-                    &amp;&amp; fail_stack.stack[fail_stack.avail - 1] == p)
-                fail_stack.avail--;
-
-            continue;
-
-        case on_failure_jump:
-        case on_failure_keep_string_jump:
-handle_on_failure_jump:
-            EXTRACT_NUMBER_AND_INCR(j, p);
-
-            /* For some patterns, e.g., `(a?)?', `p+j' here points to the
-             * end of the pattern.  We don't want to push such a point,
-             * since when we restore it above, entering the switch will
-             * increment `p' past the end of the pattern.  We don't need
-             * to push such a point since we obviously won't find any more
-             * fastmap entries beyond `pend'.  Such a pattern can match
-             * the null string, though.  */
-            if (p + j &lt; pend) {
-                if (!PUSH_PATTERN_OP(p + j, fail_stack))
-                    return -2;
-            } else
-                bufp-&gt;can_be_null = 1;
-
-            if (succeed_n_p) {
-                EXTRACT_NUMBER_AND_INCR(k, p);  /* Skip the n.  */
-                succeed_n_p = false;
-            }
-            continue;
-
-        case succeed_n:
-            /* Get to the number of times to succeed.  */
-            p += 2;
-
-            /* Increment p past the n for when k != 0.  */
-            EXTRACT_NUMBER_AND_INCR(k, p);
-            if (k == 0) {
-                p -= 4;
-                succeed_n_p = true; /* Spaghetti code alert.  */
-                goto handle_on_failure_jump;
-            }
-            continue;
-
-        case set_number_at:
-            p += 4;
-            continue;
-
-        case start_memory:
-        case stop_memory:
-            p += 2;
-            continue;
-
-        default:
-            abort();        /* We have listed all the cases.  */
-        }           /* switch *p++ */
-
-        /* Getting here means we have found the possible starting
-         * characters for one path of the pattern -- and that the empty
-         * string does not match.  We need not follow this path further.
-         * Instead, look at the next alternative (remembered on the
-         * stack), or quit if no more.  The test at the top of the loop
-         * does these things.  */
-        path_can_be_null = false;
-        p = pend;
-    }               /* while p */
-
-    /* Set `can_be_null' for the last path (also the first path, if the
-     * pattern is empty).  */
-    bufp-&gt;can_be_null |= path_can_be_null;
-    return 0;
-}               /* re_compile_fastmap */
-
-/* Searching routines.  */
-
-/* Like re_search_2, below, but only one string is specified, and
- * doesn't let you say where to stop matching. */
-
-static int
-re_search(bufp, string, size, startpos, range, regs)
-struct re_pattern_buffer *bufp;
-const char *string;
-int size, startpos, range;
-struct re_registers *regs;
-{
-    return re_search_2(bufp, NULL, 0, string, size, startpos, range,
-                       regs, size);
-}
-
-/* Using the compiled pattern in BUFP-&gt;buffer, first tries to match the
- * virtual concatenation of STRING1 and STRING2, starting first at index
- * STARTPOS, then at STARTPOS + 1, and so on.
- *
- * STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
- *
- * RANGE is how far to scan while trying to match.  RANGE = 0 means try
- * only at STARTPOS; in general, the last start tried is STARTPOS +
- * RANGE.
- *
- * In REGS, return the indices of the virtual concatenation of STRING1
- * and STRING2 that matched the entire BUFP-&gt;buffer and its contained
- * subexpressions.
- *
- * Do not consider matching one past the index STOP in the virtual
- * concatenation of STRING1 and STRING2.
- *
- * We return either the position in the strings at which the match was
- * found, -1 if no match, or -2 if error (such as failure
- * stack overflow).  */
-
-static int
-re_search_2(bufp, string1, size1, string2, size2, startpos, range, regs, stop)
-struct re_pattern_buffer *bufp;
-const char *string1, *string2;
-int size1, size2;
-int startpos;
-int range;
-struct re_registers *regs;
-int stop;
-{
-    int val;
-    register char *fastmap = bufp-&gt;fastmap;
-    register char *translate = bufp-&gt;translate;
-    int total_size = size1 + size2;
-    int endpos = startpos + range;
-
-    /* Check for out-of-range STARTPOS.  */
-    if (startpos &lt; 0 || startpos &gt; total_size)
-        return -1;
-
-    /* Fix up RANGE if it might eventually take us outside
-     * the virtual concatenation of STRING1 and STRING2.  */
-    if (endpos &lt; -1)
-        range = -1 - startpos;
-    else if (endpos &gt; total_size)
-        range = total_size - startpos;
-
-    /* If the search isn't to be a backwards one, don't waste time in a
-     * search for a pattern that must be anchored.  */
-    if (bufp-&gt;used &gt; 0 &amp;&amp; (re_opcode_t) bufp-&gt;buffer[0] == begbuf &amp;&amp; range &gt; 0) {
-        if (startpos &gt; 0)
-            return -1;
-        else
-            range = 1;
-    }
-    /* Update the fastmap now if not correct already.  */
-    if (fastmap &amp;&amp; !bufp-&gt;fastmap_accurate)
-        if (re_compile_fastmap(bufp) == -2)
-            return -2;
-
-    /* Loop through the string, looking for a place to start matching.  */
-    for (;;) {
-        /* If a fastmap is supplied, skip quickly over characters that
-         * cannot be the start of a match.  If the pattern can match the
-         * null string, however, we don't need to skip characters; we want
-         * the first null string.  */
-        if (fastmap &amp;&amp; startpos &lt; total_size &amp;&amp; !bufp-&gt;can_be_null) {
-            if (range &gt; 0) {    /* Searching forwards.  */
-                register const char *d;
-                register int lim = 0;
-                int irange = range;
-
-                if (startpos &lt; size1 &amp;&amp; startpos + range &gt;= size1)
-                    lim = range - (size1 - startpos);
-
-                d = (startpos &gt;= size1 ? string2 - size1 : string1) + startpos;
-
-                /* Written out as an if-else to avoid testing `translate'
-                 * inside the loop.  */
-                if (translate)
-                    while (range &gt; lim
-                            &amp;&amp; !fastmap[(unsigned char)
-                                        translate[(unsigned char) *d++]])
-                        range--;
-                else
-                    while (range &gt; lim &amp;&amp; !fastmap[(unsigned char) *d++])
-                        range--;
-
-                startpos += irange - range;
-            } else {        /* Searching backwards.  */
-                register char c = (size1 == 0 || startpos &gt;= size1
-                                   ? string2[startpos - size1]
-                                   : string1[startpos]);
-
-                if (!fastmap[(unsigned char) TRANSLATE(c)])
-                    goto advance;
-            }
-        }
-        /* If can't match the null string, and that's all we have left, fail.  */
-        if (range &gt;= 0 &amp;&amp; startpos == total_size &amp;&amp; fastmap
-                &amp;&amp; !bufp-&gt;can_be_null)
-            return -1;
-
-        val = re_match_2(bufp, string1, size1, string2, size2,
-                         startpos, regs, stop);
-        if (val &gt;= 0)
-            return startpos;
-
-        if (val == -2)
-            return -2;
-
-advance:
-        if (!range)
-            break;
-        else if (range &gt; 0) {
-            range--;
-            startpos++;
-        } else {
-            range++;
-            startpos--;
-        }
-    }
-    return -1;
-}               /* re_search_2 */
-
-/* Declarations and macros for re_match_2.  */
-
-/* Structure for per-register (a.k.a. per-group) information.
- * This must not be longer than one word, because we push this value
- * onto the failure stack.  Other register information, such as the
- * starting and ending positions (which are addresses), and the list of
- * inner groups (which is a bits list) are maintained in separate
- * variables.
- *
- * We are making a (strictly speaking) nonportable assumption here: that
- * the compiler will pack our bit fields into something that fits into
- * the type of `word', i.e., is something that fits into one item on the
- * failure stack.  */
-typedef union {
-    fail_stack_elt_t word;
-    struct {
-        /* This field is one if this group can match the empty string,
-         * zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
-#define MATCH_NULL_UNSET_VALUE 3
-        unsigned match_null_string_p:2;
-        unsigned is_active:1;
-        unsigned matched_something:1;
-        unsigned ever_matched_something:1;
-    } bits;
-} register_info_type;
-static boolean alt_match_null_string_p(unsigned char *p, unsigned char *end, register_info_type *reg_info);
-static boolean common_op_match_null_string_p( unsigned char **p, unsigned char *end, register_info_type *reg_info);
-static int bcmp_translate(unsigned char const *s1, unsigned char const *s2, register int len, char *translate);
-static boolean group_match_null_string_p(unsigned char **p, unsigned char *end, register_info_type *reg_info);
-
-#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
-#define IS_ACTIVE(R)  ((R).bits.is_active)
-#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
-#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
-
-/* Call this when have matched a real character; it sets `matched' flags
- * for the subexpressions which we are currently inside.  Also records
- * that those subexprs have matched.  */
-#define SET_REGS_MATCHED()                      \
-  do                                    \
-    {                                   \
-      unsigned r;                           \
-      for (r = lowest_active_reg; r &lt;= highest_active_reg; r++)     \
-        {                               \
-          MATCHED_SOMETHING (reg_info[r])               \
-            = EVER_MATCHED_SOMETHING (reg_info[r])          \
-            = 1;                            \
-        }                               \
-    }                                   \
-  while (0)
-
-/* This converts PTR, a pointer into one of the search strings `string1'
- * and `string2' into an offset from the beginning of that string.  */
-#define POINTER_TO_OFFSET(ptr)                      \
-  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
-
-/* Registers are set to a sentinel when they haven't yet matched.  */
-#define REG_UNSET_VALUE ((char *) -1)
-#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
-
-/* Macros for dealing with the split strings in re_match_2.  */
-
-#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
-
-/* Call before fetching a character with *d.  This switches over to
- * string2 if necessary.  */
-#define PREFETCH()                          \
-  while (d == dend)                             \
-    {                                   \
-      /* End of string2 =&gt; fail.  */                    \
-      if (dend == end_match_2)                      \
-        goto fail;                          \
-      /* End of string1 =&gt; advance to string2.  */          \
-      d = string2;                              \
-      dend = end_match_2;                       \
-    }
-
-/* Test if at very beginning or at very end of the virtual concatenation
- * of `string1' and `string2'.  If only one string, it's `string2'.  */
-#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
-static int at_strings_end(const char *d, const char *end2)
-{
-    return d == end2;
-}
-
-/* Test if D points to a character which is word-constituent.  We have
- * two special cases to check for: if past the end of string1, look at
- * the first character in string2; and if before the beginning of
- * string2, look at the last character in string1.  */
-#define WORDCHAR_P(d)                           \
-  (re_syntax_table[(d) == end1 ? *string2                   \
-           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]           \
-   == Sword)
-static int
-wordchar_p(const char *d, const char *end1, const char *string2)
-{
-    return re_syntax_table[(d) == end1 ? *string2
-                           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]
-           == Sword;
-}
-
-/* Test if the character before D and the one at D differ with respect
- * to being word-constituent.  */
-#define AT_WORD_BOUNDARY(d)                     \
-  (AT_STRINGS_BEG (d) || at_strings_end(d,end2)             \
-   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
-
-/* Free everything we malloc.  */
-#ifdef REGEX_MALLOC
-#define FREE_VAR(var) if (var) free (var); var = NULL
-#define FREE_VARIABLES()                        \
-  do {                                  \
-    FREE_VAR (fail_stack.stack);                    \
-    FREE_VAR (regstart);                        \
-    FREE_VAR (regend);                          \
-    FREE_VAR (old_regstart);                        \
-    FREE_VAR (old_regend);                      \
-    FREE_VAR (best_regstart);                       \
-    FREE_VAR (best_regend);                     \
-    FREE_VAR (reg_info);                        \
-    FREE_VAR (reg_dummy);                       \
-    FREE_VAR (reg_info_dummy);                      \
-  } while (0)
-#else /* not REGEX_MALLOC */
-/* Some MIPS systems (at least) want this to free alloca'd storage.  */
-#define FREE_VARIABLES() alloca (0)
-#endif /* not REGEX_MALLOC */
-
-/* These values must meet several constraints.  They must not be valid
- * register values; since we have a limit of 255 registers (because
- * we use only one byte in the pattern for the register number), we can
- * use numbers larger than 255.  They must differ by 1, because of
- * NUM_FAILURE_ITEMS above.  And the value for the lowest register must
- * be larger than the value for the highest register, so we do not try
- * to actually save any registers when none are active.  */
-#define NO_HIGHEST_ACTIVE_REG (1 &lt;&lt; BYTEWIDTH)
-#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
-
-/* Matching routines.  */
-
-/* re_match_2 matches the compiled pattern in BUFP against the
- * the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
- * and SIZE2, respectively).  We start matching at POS, and stop
- * matching at STOP.
- *
- * If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
- * store offsets for the substring each group matched in REGS.  See the
- * documentation for exactly how many groups we fill.
- *
- * We return -1 if no match, -2 if an internal error (such as the
- * failure stack overflowing).  Otherwise, we return the length of the
- * matched substring.  */
-
-int
-re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop)
-struct re_pattern_buffer *bufp;
-const char *string1, *string2;
-int size1, size2;
-int pos;
-struct re_registers *regs;
-int stop;
-{
-    /* General temporaries.  */
-    int mcnt;
-    unsigned char *p1;
-
-    /* Just past the end of the corresponding string.  */
-    const char *end1, *end2;
-
-    /* Pointers into string1 and string2, just past the last characters in
-     * each to consider matching.  */
-    const char *end_match_1, *end_match_2;
-
-    /* Where we are in the data, and the end of the current string.  */
-    const char *d, *dend;
-
-    /* Where we are in the pattern, and the end of the pattern.  */
-    unsigned char *p = bufp-&gt;buffer;
-    register unsigned char *pend = p + bufp-&gt;used;
-
-    /* We use this to map every character in the string.  */
-    char *translate = bufp-&gt;translate;
-
-    /* Failure point stack.  Each place that can handle a failure further
-     * down the line pushes a failure point on this stack.  It consists of
-     * restart, regend, and reg_info for all registers corresponding to
-     * the subexpressions we're currently inside, plus the number of such
-     * registers, and, finally, two char *'s.  The first char * is where
-     * to resume scanning the pattern; the second one is where to resume
-     * scanning the strings.  If the latter is zero, the failure point is
-     * a ``dummy''; if a failure happens and the failure point is a dummy,
-     * it gets discarded and the next next one is tried.  */
-    fail_stack_type fail_stack;
-#ifdef DEBUG
-    static unsigned failure_id = 0;
-    unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
-#endif
-
-    /* We fill all the registers internally, independent of what we
-     * return, for use in backreferences.  The number here includes
-     * an element for register zero.  */
-    unsigned num_regs = bufp-&gt;re_nsub + 1;
-
-    /* The currently active registers.  */
-    unsigned long lowest_active_reg = NO_LOWEST_ACTIVE_REG;
-    unsigned long highest_active_reg = NO_HIGHEST_ACTIVE_REG;
-
-    /* Information on the contents of registers. These are pointers into
-     * the input strings; they record just what was matched (on this
-     * attempt) by a subexpression part of the pattern, that is, the
-     * regnum-th regstart pointer points to where in the pattern we began
-     * matching and the regnum-th regend points to right after where we
-     * stopped matching the regnum-th subexpression.  (The zeroth register
-     * keeps track of what the whole pattern matches.)  */
-    const char **regstart = NULL, **regend = NULL;
-
-    /* If a group that's operated upon by a repetition operator fails to
-     * match anything, then the register for its start will need to be
-     * restored because it will have been set to wherever in the string we
-     * are when we last see its open-group operator.  Similarly for a
-     * register's end.  */
-    const char **old_regstart = NULL, **old_regend = NULL;
-
-    /* The is_active field of reg_info helps us keep track of which (possibly
-     * nested) subexpressions we are currently in. The matched_something
-     * field of reg_info[reg_num] helps us tell whether or not we have
-     * matched any of the pattern so far this time through the reg_num-th
-     * subexpression.  These two fields get reset each time through any
-     * loop their register is in.  */
-    register_info_type *reg_info = NULL;
-
-    /* The following record the register info as found in the above
-     * variables when we find a match better than any we've seen before.
-     * This happens as we backtrack through the failure points, which in
-     * turn happens only if we have not yet matched the entire string. */
-    unsigned best_regs_set = false;
-    const char **best_regstart = NULL, **best_regend = NULL;
-
-    /* Logically, this is `best_regend[0]'.  But we don't want to have to
-     * allocate space for that if we're not allocating space for anything
-     * else (see below).  Also, we never need info about register 0 for
-     * any of the other register vectors, and it seems rather a kludge to
-     * treat `best_regend' differently than the rest.  So we keep track of
-     * the end of the best match so far in a separate variable.  We
-     * initialize this to NULL so that when we backtrack the first time
-     * and need to test it, it's not garbage.  */
-    const char *match_end = NULL;
-
-    /* Used when we pop values we don't care about.  */
-    const char **reg_dummy = NULL;
-    register_info_type *reg_info_dummy = NULL;
-
-#ifdef DEBUG
-    /* Counts the total number of registers pushed.  */
-    unsigned num_regs_pushed = 0;
-#endif
-
-    DEBUG_PRINT1(&quot;\n\nEntering re_match_2.\n&quot;);
-
-    INIT_FAIL_STACK();
-
-    /* Do not bother to initialize all the register variables if there are
-     * no groups in the pattern, as it takes a fair amount of time.  If
-     * there are groups, we include space for register 0 (the whole
-     * pattern), even though we never use it, since it simplifies the
-     * array indexing.  We should fix this.  */
-    if (bufp-&gt;re_nsub) {
-        regstart = REGEX_TALLOC(num_regs, const char *);
-        regend = REGEX_TALLOC(num_regs, const char *);
-        old_regstart = REGEX_TALLOC(num_regs, const char *);
-        old_regend = REGEX_TALLOC(num_regs, const char *);
-        best_regstart = REGEX_TALLOC(num_regs, const char *);
-        best_regend = REGEX_TALLOC(num_regs, const char *);
-        reg_info = REGEX_TALLOC(num_regs, register_info_type);
-        reg_dummy = REGEX_TALLOC(num_regs, const char *);
-        reg_info_dummy = REGEX_TALLOC(num_regs, register_info_type);
-
-        if (!(regstart &amp;&amp; regend &amp;&amp; old_regstart &amp;&amp; old_regend &amp;&amp; reg_info
-                &amp;&amp; best_regstart &amp;&amp; best_regend &amp;&amp; reg_dummy &amp;&amp; reg_info_dummy)) {
-            FREE_VARIABLES();
-            return -2;
-        }
-    }
-#ifdef REGEX_MALLOC
-    else {
-        /* We must initialize all our variables to NULL, so that
-         * `FREE_VARIABLES' doesn't try to free them.  */
-        regstart = regend = old_regstart = old_regend = best_regstart
-                                           = best_regend = reg_dummy = NULL;
-        reg_info = reg_info_dummy = (register_info_type *) NULL;
-    }
-#endif /* REGEX_MALLOC */
-
-    /* The starting position is bogus.  */
-    if (pos &lt; 0 || pos &gt; size1 + size2) {
-        FREE_VARIABLES();
-        return -1;
-    }
-    /* Initialize subexpression text positions to -1 to mark ones that no
-     * start_memory/stop_memory has been seen for. Also initialize the
-     * register information struct.  */
-    for (mcnt = 1; mcnt &lt; num_regs; mcnt++) {
-        regstart[mcnt] = regend[mcnt]
-                         = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
-
-        REG_MATCH_NULL_STRING_P(reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
-        IS_ACTIVE(reg_info[mcnt]) = 0;
-        MATCHED_SOMETHING(reg_info[mcnt]) = 0;
-        EVER_MATCHED_SOMETHING(reg_info[mcnt]) = 0;
-    }
-
-    /* We move `string1' into `string2' if the latter's empty -- but not if
-     * `string1' is null.  */
-    if (size2 == 0 &amp;&amp; string1 != NULL) {
-        string2 = string1;
-        size2 = size1;
-        string1 = 0;
-        size1 = 0;
-    }
-    end1 = string1 + size1;
-    end2 = string2 + size2;
-
-    /* Compute where to stop matching, within the two strings.  */
-    if (stop &lt;= size1) {
-        end_match_1 = string1 + stop;
-        end_match_2 = string2;
-    } else {
-        end_match_1 = end1;
-        end_match_2 = string2 + stop - size1;
-    }
-
-    /* `p' scans through the pattern as `d' scans through the data.
-     * `dend' is the end of the input string that `d' points within.  `d'
-     * is advanced into the following input string whenever necessary, but
-     * this happens before fetching; therefore, at the beginning of the
-     * loop, `d' can be pointing at the end of a string, but it cannot
-     * equal `string2'.  */
-    if (size1 &gt; 0 &amp;&amp; pos &lt;= size1) {
-        d = string1 + pos;
-        dend = end_match_1;
-    } else {
-        d = string2 + pos - size1;
-        dend = end_match_2;
-    }
-
-    DEBUG_PRINT1(&quot;The compiled pattern is: &quot;);
-    DEBUG_PRINT_COMPILED_PATTERN(bufp, p, pend);
-    DEBUG_PRINT1(&quot;The string to match is: `&quot;);
-    DEBUG_PRINT_DOUBLE_STRING(d, string1, size1, string2, size2);
-    DEBUG_PRINT1(&quot;'\n&quot;);
-
-    /* This loops over pattern commands.  It exits by returning from the
-     * function if the match is complete, or it drops through if the match
-     * fails at this starting point in the input data.  */
-    for (;;) {
-        DEBUG_PRINT2(&quot;\n0x%x: &quot;, p);
-
-        if (p == pend) {    /* End of pattern means we might have succeeded.  */
-            DEBUG_PRINT1(&quot;end of pattern ... &quot;);
-
-            /* If we haven't matched the entire string, and we want the
-             * longest match, try backtracking.  */
-            if (d != end_match_2) {
-                DEBUG_PRINT1(&quot;backtracking.\n&quot;);
-
-                if (!FAIL_STACK_EMPTY()) {  /* More failure points to try.  */
-                    boolean same_str_p = (FIRST_STRING_P(match_end)
-                                          == MATCHING_IN_FIRST_STRING);
-
-                    /* If exceeds best match so far, save it.  */
-                    if (!best_regs_set
-                            || (same_str_p &amp;&amp; d &gt; match_end)
-                            || (!same_str_p &amp;&amp; !MATCHING_IN_FIRST_STRING)) {
-                        best_regs_set = true;
-                        match_end = d;
-
-                        DEBUG_PRINT1(&quot;\nSAVING match as best so far.\n&quot;);
-
-                        for (mcnt = 1; mcnt &lt; num_regs; mcnt++) {
-                            best_regstart[mcnt] = regstart[mcnt];
-                            best_regend[mcnt] = regend[mcnt];
-                        }
-                    }
-                    goto fail;
-                }
-                /* If no failure points, don't restore garbage.  */
-                else if (best_regs_set) {
-restore_best_regs:
-                    /* Restore best match.  It may happen that `dend ==
-                     * end_match_1' while the restored d is in string2.
-                     * For example, the pattern `x.*y.*z' against the
-                     * strings `x-' and `y-z-', if the two strings are
-                     * not consecutive in memory.  */
-                    DEBUG_PRINT1(&quot;Restoring best registers.\n&quot;);
-
-                    d = match_end;
-                    dend = ((d &gt;= string1 &amp;&amp; d &lt;= end1)
-                            ? end_match_1 : end_match_2);
-
-                    for (mcnt = 1; mcnt &lt; num_regs; mcnt++) {
-                        regstart[mcnt] = best_regstart[mcnt];
-                        regend[mcnt] = best_regend[mcnt];
-                    }
-                }
-            }           /* d != end_match_2 */
-            DEBUG_PRINT1(&quot;Accepting match.\n&quot;);
-
-            /* If caller wants register contents data back, do it.  */
-            if (regs &amp;&amp; !bufp-&gt;no_sub) {
-                /* Have the register data arrays been allocated?  */
-                if (bufp-&gt;regs_allocated == REGS_UNALLOCATED) {
-                    /* No.  So allocate them with malloc.  We need one
-                                         * extra element beyond `num_regs' for the `-1' marker
-                                         * GNU code uses.  */
-                    regs-&gt;num_regs = max(RE_NREGS, num_regs + 1);
-                    regs-&gt;start = TALLOC(regs-&gt;num_regs, regoff_t);
-                    regs-&gt;end = TALLOC(regs-&gt;num_regs, regoff_t);
-                    if (regs-&gt;start == NULL || regs-&gt;end == NULL)
-                        return -2;
-                    bufp-&gt;regs_allocated = REGS_REALLOCATE;
-                } else if (bufp-&gt;regs_allocated == REGS_REALLOCATE) {
-                    /* Yes.  If we need more elements than were already
-                                         * allocated, reallocate them.  If we need fewer, just
-                                         * leave it alone.  */
-                    if (regs-&gt;num_regs &lt; num_regs + 1) {
-                        regs-&gt;num_regs = num_regs + 1;
-                        RETALLOC(regs-&gt;start, regs-&gt;num_regs, regoff_t);
-                        RETALLOC(regs-&gt;end, regs-&gt;num_regs, regoff_t);
-                        if (regs-&gt;start == NULL || regs-&gt;end == NULL)
-                            return -2;
-                    }
-                } else
-                    assert(bufp-&gt;regs_allocated == REGS_FIXED);
-
-                /* Convert the pointer data in `regstart' and `regend' to
-                 * indices.  Register zero has to be set differently,
-                 * since we haven't kept track of any info for it.  */
-                if (regs-&gt;num_regs &gt; 0) {
-                    regs-&gt;start[0] = pos;
-                    regs-&gt;end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
-                                    : d - string2 + size1);
-                }
-                /* Go through the first `min (num_regs, regs-&gt;num_regs)'
-                 * registers, since that is all we initialized.  */
-                for (mcnt = 1; mcnt &lt; min(num_regs, regs-&gt;num_regs); mcnt++) {
-                    if (REG_UNSET(regstart[mcnt]) || REG_UNSET(regend[mcnt]))
-                        regs-&gt;start[mcnt] = regs-&gt;end[mcnt] = -1;
-                    else {
-                        regs-&gt;start[mcnt] = POINTER_TO_OFFSET(regstart[mcnt]);
-                        regs-&gt;end[mcnt] = POINTER_TO_OFFSET(regend[mcnt]);
-                    }
-                }
-
-                /* If the regs structure we return has more elements than
-                 * were in the pattern, set the extra elements to -1.  If
-                 * we (re)allocated the registers, this is the case,
-                 * because we always allocate enough to have at least one
-                 * -1 at the end.  */
-                for (mcnt = num_regs; mcnt &lt; regs-&gt;num_regs; mcnt++)
-                    regs-&gt;start[mcnt] = regs-&gt;end[mcnt] = -1;
-            }           /* regs &amp;&amp; !bufp-&gt;no_sub */
-            FREE_VARIABLES();
-            DEBUG_PRINT4(&quot;%u failure points pushed, %u popped (%u remain).\n&quot;,
-                         nfailure_points_pushed, nfailure_points_popped,
-                         nfailure_points_pushed - nfailure_points_popped);
-            DEBUG_PRINT2(&quot;%u registers pushed.\n&quot;, num_regs_pushed);
-
-            mcnt = d - pos - (MATCHING_IN_FIRST_STRING
-                              ? string1
-                              : string2 - size1);
-
-            DEBUG_PRINT2(&quot;Returning %d from re_match_2.\n&quot;, mcnt);
-
-            return mcnt;
-        }
-        /* Otherwise match next pattern command.  */
-#ifdef SWITCH_ENUM_BUG
-        switch ((int) ((re_opcode_t) * p++))
-#else
-        switch ((re_opcode_t) * p++)
-#endif
-        {
-        /* Ignore these.  Used to ignore the n of succeed_n's which
-         * currently have n == 0.  */
-        case no_op:
-            DEBUG_PRINT1(&quot;EXECUTING no_op.\n&quot;);
-            break;
-
-        /* Match the next n pattern characters exactly.  The following
-         * byte in the pattern defines n, and the n bytes after that
-         * are the characters to match.  */
-        case exactn:
-            mcnt = *p++;
-            DEBUG_PRINT2(&quot;EXECUTING exactn %d.\n&quot;, mcnt);
-
-            /* This is written out as an if-else so we don't waste time
-             * testing `translate' inside the loop.  */
-            if (translate) {
-                do {
-                    PREFETCH();
-                    if (translate[(unsigned char) *d++] != (char) *p++)
-                        goto fail;
-                } while (--mcnt);
-            } else {
-                do {
-                    PREFETCH();
-                    if (*d++ != (char) *p++)
-                        goto fail;
-                } while (--mcnt);
-            }
-            SET_REGS_MATCHED();
-            break;
-
-        /* Match any character except possibly a newline or a null.  */
-        case anychar:
-            DEBUG_PRINT1(&quot;EXECUTING anychar.\n&quot;);
-
-            PREFETCH();
-
-            if ((!(bufp-&gt;syntax &amp; RE_DOT_NEWLINE) &amp;&amp; TRANSLATE(*d) == '\n')
-                    || (bufp-&gt;syntax &amp; RE_DOT_NOT_NULL &amp;&amp; TRANSLATE(*d) == '\000'))
-                goto fail;
-
-            SET_REGS_MATCHED();
-            DEBUG_PRINT2(&quot;  Matched `%d'.\n&quot;, *d);
-            d++;
-            break;
-
-        case charset:
-        case charset_not: {
-            register unsigned char c;
-            boolean not = (re_opcode_t) * (p - 1) == charset_not;
-
-            DEBUG_PRINT2(&quot;EXECUTING charset%s.\n&quot;, not ? &quot;_not&quot; : &quot;&quot;);
-
-            PREFETCH();
-            c = TRANSLATE(*d);  /* The character to match.  */
-
-            /* Cast to `unsigned' instead of `unsigned char' in case the
-             * bit list is a full 32 bytes long.  */
-            if (c &lt; (unsigned) (*p * BYTEWIDTH)
-                    &amp;&amp; p[1 + c / BYTEWIDTH] &amp; (1 &lt;&lt; (c % BYTEWIDTH)))
-                not = !not;
-
-            p += 1 + *p;
-
-            if (!not)
-                goto fail;
-
-            SET_REGS_MATCHED();
-            d++;
-            break;
-        }
-
-        /* The beginning of a group is represented by start_memory.
-         * The arguments are the register number in the next byte, and the
-         * number of groups inner to this one in the next.  The text
-         * matched within the group is recorded (in the internal
-         * registers data structure) under the register number.  */
-        case start_memory:
-            DEBUG_PRINT3(&quot;EXECUTING start_memory %d (%d):\n&quot;, *p, p[1]);
-
-            /* Find out if this group can match the empty string.  */
-            p1 = p;     /* To send to group_match_null_string_p.  */
-
-            if (REG_MATCH_NULL_STRING_P(reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
-                REG_MATCH_NULL_STRING_P(reg_info[*p])
-                    = group_match_null_string_p(&amp;p1, pend, reg_info);
-
-            /* Save the position in the string where we were the last time
-             * we were at this open-group operator in case the group is
-             * operated upon by a repetition operator, e.g., with `(a*)*b'
-             * against `ab'; then we want to ignore where we are now in
-             * the string in case this attempt to match fails.  */
-            old_regstart[*p] = REG_MATCH_NULL_STRING_P(reg_info[*p])
-                               ? REG_UNSET(regstart[*p]) ? d : regstart[*p]
-                               : regstart[*p];
-            DEBUG_PRINT2(&quot;  old_regstart: %d\n&quot;,
-                         POINTER_TO_OFFSET(old_regstart[*p]));
-
-            regstart[*p] = d;
-            DEBUG_PRINT2(&quot;  regstart: %d\n&quot;, POINTER_TO_OFFSET(regstart[*p]));
-
-            IS_ACTIVE(reg_info[*p]) = 1;
-            MATCHED_SOMETHING(reg_info[*p]) = 0;
-
-            /* This is the new highest active register.  */
-            highest_active_reg = *p;
-
-            /* If nothing was active before, this is the new lowest active
-             * register.  */
-            if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
-                lowest_active_reg = *p;
-
-            /* Move past the register number and inner group count.  */
-            p += 2;
-            break;
-
-        /* The stop_memory opcode represents the end of a group.  Its
-         * arguments are the same as start_memory's: the register
-         * number, and the number of inner groups.  */
-        case stop_memory:
-            DEBUG_PRINT3(&quot;EXECUTING stop_memory %d (%d):\n&quot;, *p, p[1]);
-
-            /* We need to save the string position the last time we were at
-             * this close-group operator in case the group is operated
-             * upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
-             * against `aba'; then we want to ignore where we are now in
-             * the string in case this attempt to match fails.  */
-            old_regend[*p] = REG_MATCH_NULL_STRING_P(reg_info[*p])
-                             ? REG_UNSET(regend[*p]) ? d : regend[*p]
-                             : regend[*p];
-            DEBUG_PRINT2(&quot;      old_regend: %d\n&quot;,
-                         POINTER_TO_OFFSET(old_regend[*p]));
-
-            regend[*p] = d;
-            DEBUG_PRINT2(&quot;      regend: %d\n&quot;, POINTER_TO_OFFSET(regend[*p]));
-
-            /* This register isn't active anymore.  */
-            IS_ACTIVE(reg_info[*p]) = 0;
-
-            /* If this was the only register active, nothing is active
-             * anymore.  */
-            if (lowest_active_reg == highest_active_reg) {
-                lowest_active_reg = NO_LOWEST_ACTIVE_REG;
-                highest_active_reg = NO_HIGHEST_ACTIVE_REG;
-            } else {
-                /* We must scan for the new highest active register, since
-                     * it isn't necessarily one less than now: consider
-                     * (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
-                     * new highest active register is 1.  */
-                unsigned char r = *p - 1;
-                while (r &gt; 0 &amp;&amp; !IS_ACTIVE(reg_info[r]))
-                    r--;
-
-                /* If we end up at register zero, that means that we saved
-                 * the registers as the result of an `on_failure_jump', not
-                 * a `start_memory', and we jumped to past the innermost
-                 * `stop_memory'.  For example, in ((.)*) we save
-                 * registers 1 and 2 as a result of the *, but when we pop
-                 * back to the second ), we are at the stop_memory 1.
-                 * Thus, nothing is active.  */
-                if (r == 0) {
-                    lowest_active_reg = NO_LOWEST_ACTIVE_REG;
-                    highest_active_reg = NO_HIGHEST_ACTIVE_REG;
-                } else
-                    highest_active_reg = r;
-            }
-
-            /* If just failed to match something this time around with a
-             * group that's operated on by a repetition operator, try to
-             * force exit from the ``loop'', and restore the register
-             * information for this group that we had before trying this
-             * last match.  */
-            if ((!MATCHED_SOMETHING(reg_info[*p])
-                    || (re_opcode_t) p[-3] == start_memory)
-                    &amp;&amp; (p + 2) &lt; pend) {
-                boolean is_a_jump_n = false;
-
-                p1 = p + 2;
-                mcnt = 0;
-                switch ((re_opcode_t) * p1++) {
-                case jump_n:
-                    is_a_jump_n = true;
-                case pop_failure_jump:
-                case maybe_pop_jump:
-                case jump:
-                case dummy_failure_jump:
-                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-                    if (is_a_jump_n)
-                        p1 += 2;
-                    break;
-
-                default:
-                    /* do nothing */
-                    ;
-                }
-                p1 += mcnt;
-
-                /* If the next operation is a jump backwards in the pattern
-                 * to an on_failure_jump right before the start_memory
-                 * corresponding to this stop_memory, exit from the loop
-                 * by forcing a failure after pushing on the stack the
-                 * on_failure_jump's jump in the pattern, and d.  */
-                if (mcnt &lt; 0 &amp;&amp; (re_opcode_t) * p1 == on_failure_jump
-                        &amp;&amp; (re_opcode_t) p1[3] == start_memory &amp;&amp; p1[4] == *p) {
-                    /* If this group ever matched anything, then restore
-                     * what its registers were before trying this last
-                     * failed match, e.g., with `(a*)*b' against `ab' for
-                     * regstart[1], and, e.g., with `((a*)*(b*)*)*'
-                     * against `aba' for regend[3].
-                     *
-                     * Also restore the registers for inner groups for,
-                     * e.g., `((a*)(b*))*' against `aba' (register 3 would
-                     * otherwise get trashed).  */
-
-                    if (EVER_MATCHED_SOMETHING(reg_info[*p])) {
-                        unsigned r;
-
-                        EVER_MATCHED_SOMETHING(reg_info[*p]) = 0;
-
-                        /* Restore this and inner groups' (if any) registers.  */
-                        for (r = *p; r &lt; *p + *(p + 1); r++) {
-                            regstart[r] = old_regstart[r];
-
-                            /* xx why this test?  */
-                            if ((long) old_regend[r] &gt;= (long) regstart[r])
-                                regend[r] = old_regend[r];
-                        }
-                    }
-                    p1++;
-                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-                    PUSH_FAILURE_POINT(p1 + mcnt, d, -2);
-
-                    goto fail;
-                }
-            }
-            /* Move past the register number and the inner group count.  */
-            p += 2;
-            break;
-
-        /* \&lt;digit&gt; has been turned into a `duplicate' command which is
-         * followed by the numeric value of &lt;digit&gt; as the register number.  */
-        case duplicate: {
-            register const char *d2, *dend2;
-            int regno = *p++;   /* Get which register to match against.  */
-            DEBUG_PRINT2(&quot;EXECUTING duplicate %d.\n&quot;, regno);
-
-            /* Can't back reference a group which we've never matched.  */
-            if (REG_UNSET(regstart[regno]) || REG_UNSET(regend[regno]))
-                goto fail;
-
-            /* Where in input to try to start matching.  */
-            d2 = regstart[regno];
-
-            /* Where to stop matching; if both the place to start and
-             * the place to stop matching are in the same string, then
-             * set to the place to stop, otherwise, for now have to use
-             * the end of the first string.  */
-
-            dend2 = ((FIRST_STRING_P(regstart[regno])
-                      == FIRST_STRING_P(regend[regno]))
-                     ? regend[regno] : end_match_1);
-            for (;;) {
-                /* If necessary, advance to next segment in register
-                 * contents.  */
-                while (d2 == dend2) {
-                    if (dend2 == end_match_2)
-                        break;
-                    if (dend2 == regend[regno])
-                        break;
-
-                    /* End of string1 =&gt; advance to string2. */
-                    d2 = string2;
-                    dend2 = regend[regno];
-                }
-                /* At end of register contents =&gt; success */
-                if (d2 == dend2)
-                    break;
-
-                /* If necessary, advance to next segment in data.  */
-                PREFETCH();
-
-                /* How many characters left in this segment to match.  */
-                mcnt = dend - d;
-
-                /* Want how many consecutive characters we can match in
-                 * one shot, so, if necessary, adjust the count.  */
-                if (mcnt &gt; dend2 - d2)
-                    mcnt = dend2 - d2;
-
-                /* Compare that many; failure if mismatch, else move
-                 * past them.  */
-                if (translate
-                        ? bcmp_translate((unsigned char *)d, (unsigned char *)d2, mcnt, translate)
-                        : memcmp(d, d2, mcnt))
-                    goto fail;
-                d += mcnt, d2 += mcnt;
-            }
-        }
-        break;
-
-        /* begline matches the empty string at the beginning of the string
-         * (unless `not_bol' is set in `bufp'), and, if
-         * `newline_anchor' is set, after newlines.  */
-        case begline:
-            DEBUG_PRINT1(&quot;EXECUTING begline.\n&quot;);
-
-            if (AT_STRINGS_BEG(d)) {
-                if (!bufp-&gt;not_bol)
-                    break;
-            } else if (d[-1] == '\n' &amp;&amp; bufp-&gt;newline_anchor) {
-                break;
-            }
-            /* In all other cases, we fail.  */
-            goto fail;
-
-        /* endline is the dual of begline.  */
-        case endline:
-            DEBUG_PRINT1(&quot;EXECUTING endline.\n&quot;);
-
-            if (at_strings_end(d,end2)) {
-                if (!bufp-&gt;not_eol)
-                    break;
-            }
-            /* We have to ``prefetch'' the next character.  */
-            else if ((d == end1 ? *string2 : *d) == '\n'
-                     &amp;&amp; bufp-&gt;newline_anchor) {
-                break;
-            }
-            goto fail;
-
-        /* Match at the very beginning of the data.  */
-        case begbuf:
-            DEBUG_PRINT1(&quot;EXECUTING begbuf.\n&quot;);
-            if (AT_STRINGS_BEG(d))
-                break;
-            goto fail;
-
-        /* Match at the very end of the data.  */
-        case endbuf:
-            DEBUG_PRINT1(&quot;EXECUTING endbuf.\n&quot;);
-            if (at_strings_end(d,end2))
-                break;
-            goto fail;
-
-        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
-         * pushes NULL as the value for the string on the stack.  Then
-         * `pop_failure_point' will keep the current value for the
-         * string, instead of restoring it.  To see why, consider
-         * matching `foo\nbar' against `.*\n'.  The .* matches the foo;
-         * then the . fails against the \n.  But the next thing we want
-         * to do is match the \n against the \n; if we restored the
-         * string value, we would be back at the foo.
-         *
-         * Because this is used only in specific cases, we don't need to
-         * check all the things that `on_failure_jump' does, to make
-         * sure the right things get saved on the stack.  Hence we don't
-         * share its code.  The only reason to push anything on the
-         * stack at all is that otherwise we would have to change
-         * `anychar's code to do something besides goto fail in this
-         * case; that seems worse than this.  */
-        case on_failure_keep_string_jump:
-            DEBUG_PRINT1(&quot;EXECUTING on_failure_keep_string_jump&quot;);
-
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);
-            DEBUG_PRINT3(&quot; %d (to 0x%x):\n&quot;, mcnt, p + mcnt);
-
-            PUSH_FAILURE_POINT(p + mcnt, NULL, -2);
-            break;
-
-        /* Uses of on_failure_jump:
-         *
-         * Each alternative starts with an on_failure_jump that points
-         * to the beginning of the next alternative.  Each alternative
-         * except the last ends with a jump that in effect jumps past
-         * the rest of the alternatives.  (They really jump to the
-         * ending jump of the following alternative, because tensioning
-         * these jumps is a hassle.)
-         *
-         * Repeats start with an on_failure_jump that points past both
-         * the repetition text and either the following jump or
-         * pop_failure_jump back to this on_failure_jump.  */
-        case on_failure_jump:
-on_failure:
-            DEBUG_PRINT1(&quot;EXECUTING on_failure_jump&quot;);
-
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);
-            DEBUG_PRINT3(&quot; %d (to 0x%x)&quot;, mcnt, p + mcnt);
-
-            /* If this on_failure_jump comes right before a group (i.e.,
-             * the original * applied to a group), save the information
-             * for that group and all inner ones, so that if we fail back
-             * to this point, the group's information will be correct.
-             * For example, in \(a*\)*\1, we need the preceding group,
-             * and in \(\(a*\)b*\)\2, we need the inner group.  */
-
-            /* We can't use `p' to check ahead because we push
-             * a failure point to `p + mcnt' after we do this.  */
-            p1 = p;
-
-            /* We need to skip no_op's before we look for the
-             * start_memory in case this on_failure_jump is happening as
-             * the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
-             * against aba.  */
-            while (p1 &lt; pend &amp;&amp; (re_opcode_t) * p1 == no_op)
-                p1++;
-
-            if (p1 &lt; pend &amp;&amp; (re_opcode_t) * p1 == start_memory) {
-                /* We have a new highest active register now.  This will
-                 * get reset at the start_memory we are about to get to,
-                 * but we will have saved all the registers relevant to
-                 * this repetition op, as described above.  */
-                highest_active_reg = *(p1 + 1) + *(p1 + 2);
-                if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
-                    lowest_active_reg = *(p1 + 1);
-            }
-            DEBUG_PRINT1(&quot;:\n&quot;);
-            PUSH_FAILURE_POINT(p + mcnt, d, -2);
-            break;
-
-        /* A smart repeat ends with `maybe_pop_jump'.
-         * We change it to either `pop_failure_jump' or `jump'.  */
-        case maybe_pop_jump:
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);
-            DEBUG_PRINT2(&quot;EXECUTING maybe_pop_jump %d.\n&quot;, mcnt);
-            {
-                register unsigned char *p2 = p;
-
-                /* Compare the beginning of the repeat with what in the
-                 * pattern follows its end. If we can establish that there
-                 * is nothing that they would both match, i.e., that we
-                 * would have to backtrack because of (as in, e.g., `a*a')
-                 * then we can change to pop_failure_jump, because we'll
-                 * never have to backtrack.
-                 *
-                 * This is not true in the case of alternatives: in
-                 * `(a|ab)*' we do need to backtrack to the `ab' alternative
-                 * (e.g., if the string was `ab').  But instead of trying to
-                 * detect that here, the alternative has put on a dummy
-                 * failure point which is what we will end up popping.  */
-
-                /* Skip over open/close-group commands.  */
-                while (p2 + 2 &lt; pend
-                        &amp;&amp; ((re_opcode_t) * p2 == stop_memory
-                            || (re_opcode_t) * p2 == start_memory))
-                    p2 += 3;    /* Skip over args, too.  */
-
-                /* If we're at the end of the pattern, we can change.  */
-                if (p2 == pend) {
-                    /* Consider what happens when matching &quot;:\(.*\)&quot;
-                     * against &quot;:/&quot;.  I don't really understand this code
-                     * yet.  */
-                    p[-3] = (unsigned char) pop_failure_jump;
-                    DEBUG_PRINT1
-                    (&quot;  End of pattern: change to `pop_failure_jump'.\n&quot;);
-                } else if ((re_opcode_t) * p2 == exactn
-                           || (bufp-&gt;newline_anchor &amp;&amp; (re_opcode_t) * p2 == endline)) {
-                    register unsigned char c
-                        = *p2 == (unsigned char) endline ? '\n' : p2[2];
-                    p1 = p + mcnt;
-
-                    /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
-                     * to the `maybe_finalize_jump' of this case.  Examine what
-                     * follows.  */
-                    if ((re_opcode_t) p1[3] == exactn &amp;&amp; p1[5] != c) {
-                        p[-3] = (unsigned char) pop_failure_jump;
-                        DEBUG_PRINT3(&quot;  %c != %c =&gt; pop_failure_jump.\n&quot;,
-                                     c, p1[5]);
-                    } else if ((re_opcode_t) p1[3] == charset
-                               || (re_opcode_t) p1[3] == charset_not) {
-                        int not = (re_opcode_t) p1[3] == charset_not;
-
-                        if (c &lt; (unsigned char) (p1[4] * BYTEWIDTH)
-                                &amp;&amp; p1[5 + c / BYTEWIDTH] &amp; (1 &lt;&lt; (c % BYTEWIDTH)))
-                            not = !not;
-
-                        /* `not' is equal to 1 if c would match, which means
-                         * that we can't change to pop_failure_jump.  */
-                        if (!not) {
-                            p[-3] = (unsigned char) pop_failure_jump;
-                            DEBUG_PRINT1(&quot;  No match =&gt; pop_failure_jump.\n&quot;);
-                        }
-                    }
-                }
-            }
-            p -= 2;     /* Point at relative address again.  */
-            if ((re_opcode_t) p[-1] != pop_failure_jump) {
-                p[-1] = (unsigned char) jump;
-                DEBUG_PRINT1(&quot;  Match =&gt; jump.\n&quot;);
-                goto unconditional_jump;
-            }
-        /* Note fall through.  */
-
-        /* The end of a simple repeat has a pop_failure_jump back to
-         * its matching on_failure_jump, where the latter will push a
-         * failure point.  The pop_failure_jump takes off failure
-         * points put on by this pop_failure_jump's matching
-         * on_failure_jump; we got through the pattern to here from the
-         * matching on_failure_jump, so didn't fail.  */
-        case pop_failure_jump: {
-            /* We need to pass separate storage for the lowest and
-             * highest registers, even though we don't care about the
-             * actual values.  Otherwise, we will restore only one
-             * register from the stack, since lowest will == highest in
-             * `pop_failure_point'.  */
-            unsigned long dummy_low_reg, dummy_high_reg;
-            unsigned char *pdummy;
-            const char *sdummy;
-
-            DEBUG_PRINT1(&quot;EXECUTING pop_failure_jump.\n&quot;);
-            POP_FAILURE_POINT(sdummy, pdummy,
-                              dummy_low_reg, dummy_high_reg,
-                              reg_dummy, reg_dummy, reg_info_dummy);
-            /* avoid GCC 4.6 set but unused variables warning. Does not matter here. */
-            if (pdummy || sdummy)
-                (void)0;
-        }
-        /* Note fall through.  */
-
-        /* Unconditionally jump (without popping any failure points).  */
-        case jump:
-unconditional_jump:
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);   /* Get the amount to jump.  */
-            DEBUG_PRINT2(&quot;EXECUTING jump %d &quot;, mcnt);
-            p += mcnt;      /* Do the jump.  */
-            DEBUG_PRINT2(&quot;(to 0x%x).\n&quot;, p);
-            break;
-
-        /* We need this opcode so we can detect where alternatives end
-         * in `group_match_null_string_p' et al.  */
-        case jump_past_alt:
-            DEBUG_PRINT1(&quot;EXECUTING jump_past_alt.\n&quot;);
-            goto unconditional_jump;
-
-        /* Normally, the on_failure_jump pushes a failure point, which
-         * then gets popped at pop_failure_jump.  We will end up at
-         * pop_failure_jump, also, and with a pattern of, say, `a+', we
-         * are skipping over the on_failure_jump, so we have to push
-         * something meaningless for pop_failure_jump to pop.  */
-        case dummy_failure_jump:
-            DEBUG_PRINT1(&quot;EXECUTING dummy_failure_jump.\n&quot;);
-            /* It doesn't matter what we push for the string here.  What
-             * the code at `fail' tests is the value for the pattern.  */
-            PUSH_FAILURE_POINT(0, 0, -2);
-            goto unconditional_jump;
-
-        /* At the end of an alternative, we need to push a dummy failure
-         * point in case we are followed by a `pop_failure_jump', because
-         * we don't want the failure point for the alternative to be
-         * popped.  For example, matching `(a|ab)*' against `aab'
-         * requires that we match the `ab' alternative.  */
-        case push_dummy_failure:
-            DEBUG_PRINT1(&quot;EXECUTING push_dummy_failure.\n&quot;);
-            /* See comments just above at `dummy_failure_jump' about the
-             * two zeroes.  */
-            PUSH_FAILURE_POINT(0, 0, -2);
-            break;
-
-        /* Have to succeed matching what follows at least n times.
-         * After that, handle like `on_failure_jump'.  */
-        case succeed_n:
-            EXTRACT_NUMBER(mcnt, p + 2);
-            DEBUG_PRINT2(&quot;EXECUTING succeed_n %d.\n&quot;, mcnt);
-
-            assert(mcnt &gt;= 0);
-            /* Originally, this is how many times we HAVE to succeed.  */
-            if (mcnt &gt; 0) {
-                mcnt--;
-                p += 2;
-                STORE_NUMBER_AND_INCR(p, mcnt);
-                DEBUG_PRINT3(&quot;  Setting 0x%x to %d.\n&quot;, p, mcnt);
-            } else if (mcnt == 0) {
-                DEBUG_PRINT2(&quot;  Setting two bytes from 0x%x to no_op.\n&quot;, p + 2);
-                p[2] = (unsigned char) no_op;
-                p[3] = (unsigned char) no_op;
-                goto on_failure;
-            }
-            break;
-
-        case jump_n:
-            EXTRACT_NUMBER(mcnt, p + 2);
-            DEBUG_PRINT2(&quot;EXECUTING jump_n %d.\n&quot;, mcnt);
-
-            /* Originally, this is how many times we CAN jump.  */
-            if (mcnt) {
-                mcnt--;
-                STORE_NUMBER(p + 2, mcnt);
-                goto unconditional_jump;
-            }
-            /* If don't have to jump any more, skip over the rest of command.  */
-            else
-                p += 4;
-            break;
-
-        case set_number_at: {
-            DEBUG_PRINT1(&quot;EXECUTING set_number_at.\n&quot;);
-
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);
-            p1 = p + mcnt;
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);
-            DEBUG_PRINT3(&quot;  Setting 0x%x to %d.\n&quot;, p1, mcnt);
-            STORE_NUMBER(p1, mcnt);
-            break;
-        }
-
-        case wordbound:
-            DEBUG_PRINT1(&quot;EXECUTING wordbound.\n&quot;);
-            if (AT_WORD_BOUNDARY(d))
-                break;
-            goto fail;
-
-        case notwordbound:
-            DEBUG_PRINT1(&quot;EXECUTING notwordbound.\n&quot;);
-            if (AT_WORD_BOUNDARY(d))
-                goto fail;
-            break;
-
-        case wordbeg:
-            DEBUG_PRINT1(&quot;EXECUTING wordbeg.\n&quot;);
-            if (wordchar_p(d,end1,string2) &amp;&amp; (AT_STRINGS_BEG(d) || !WORDCHAR_P(d - 1)))
-                break;
-            goto fail;
-
-        case wordend:
-            DEBUG_PRINT1(&quot;EXECUTING wordend.\n&quot;);
-            if (!AT_STRINGS_BEG(d) &amp;&amp; WORDCHAR_P(d - 1)
-                    &amp;&amp; (!wordchar_p(d,end1,string2) || at_strings_end(d,end2)))
-                break;
-            goto fail;
-
-        case wordchar:
-            DEBUG_PRINT1(&quot;EXECUTING non-Emacs wordchar.\n&quot;);
-            PREFETCH();
-            if (!wordchar_p(d,end1,string2))
-                goto fail;
-            SET_REGS_MATCHED();
-            d++;
-            break;
-
-        case notwordchar:
-            DEBUG_PRINT1(&quot;EXECUTING non-Emacs notwordchar.\n&quot;);
-            PREFETCH();
-            if (wordchar_p(d,end1,string2))
-                goto fail;
-            SET_REGS_MATCHED();
-            d++;
-            break;
-
-        default:
-            abort();
-        }
-        continue;       /* Successfully executed one pattern command; keep going.  */
-
-        /* We goto here if a matching operation fails. */
-fail:
-        if (!FAIL_STACK_EMPTY()) {  /* A restart point is known.  Restore to that state.  */
-            DEBUG_PRINT1(&quot;\nFAIL:\n&quot;);
-            POP_FAILURE_POINT(d, p,
-                              lowest_active_reg, highest_active_reg,
-                              regstart, regend, reg_info);
-
-            /* If this failure point is a dummy, try the next one.  */
-            if (!p)
-                goto fail;
-
-            /* If we failed to the end of the pattern, don't examine *p.  */
-            assert(p &lt;= pend);
-            if (p &lt; pend) {
-                boolean is_a_jump_n = false;
-
-                /* If failed to a backwards jump that's part of a repetition
-                 * loop, need to pop this failure point and use the next one.  */
-                switch ((re_opcode_t) * p) {
-                case jump_n:
-                    is_a_jump_n = true;
-                case maybe_pop_jump:
-                case pop_failure_jump:
-                case jump:
-                    p1 = p + 1;
-                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-                    p1 += mcnt;
-
-                    if ((is_a_jump_n &amp;&amp; (re_opcode_t) * p1 == succeed_n)
-                            || (!is_a_jump_n
-                                &amp;&amp; (re_opcode_t) * p1 == on_failure_jump))
-                        goto fail;
-                    break;
-                default:
-                    /* do nothing */
-                    ;
-                }
-            }
-            if (d &gt;= string1 &amp;&amp; d &lt;= end1)
-                dend = end_match_1;
-        } else
-            break;      /* Matching at this starting point really fails.  */
-    }               /* for (;;) */
-
-    if (best_regs_set)
-        goto restore_best_regs;
-
-    FREE_VARIABLES();
-
-    return -1;          /* Failure to match.  */
-}               /* re_match_2 */
-
-/* Subroutine definitions for re_match_2.  */
-
-/* We are passed P pointing to a register number after a start_memory.
- *
- * Return true if the pattern up to the corresponding stop_memory can
- * match the empty string, and false otherwise.
- *
- * If we find the matching stop_memory, sets P to point to one past its number.
- * Otherwise, sets P to an undefined byte less than or equal to END.
- *
- * We don't handle duplicates properly (yet).  */
-
-boolean
-group_match_null_string_p(unsigned char **p, unsigned char *end, register_info_type *reg_info)
-{
-    int mcnt;
-    /* Point to after the args to the start_memory.  */
-    unsigned char *p1 = *p + 2;
-
-    while (p1 &lt; end) {
-        /* Skip over opcodes that can match nothing, and return true or
-         * false, as appropriate, when we get to one that can't, or to the
-         * matching stop_memory.  */
-
-        switch ((re_opcode_t) * p1) {
-        /* Could be either a loop or a series of alternatives.  */
-        case on_failure_jump:
-            p1++;
-            EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-
-            /* If the next operation is not a jump backwards in the
-             * pattern.  */
-
-            if (mcnt &gt;= 0) {
-                /* Go through the on_failure_jumps of the alternatives,
-                 * seeing if any of the alternatives cannot match nothing.
-                 * The last alternative starts with only a jump,
-                 * whereas the rest start with on_failure_jump and end
-                 * with a jump, e.g., here is the pattern for `a|b|c':
-                 *
-                 * /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
-                 * /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
-                 * /exactn/1/c
-                 *
-                 * So, we have to first go through the first (n-1)
-                 * alternatives and then deal with the last one separately.  */
-
-                /* Deal with the first (n-1) alternatives, which start
-                 * with an on_failure_jump (see above) that jumps to right
-                 * past a jump_past_alt.  */
-
-                while ((re_opcode_t) p1[mcnt - 3] == jump_past_alt) {
-                    /* `mcnt' holds how many bytes long the alternative
-                     * is, including the ending `jump_past_alt' and
-                     * its number.  */
-
-                    if (!alt_match_null_string_p(p1, p1 + mcnt - 3,
-                                                 reg_info))
-                        return false;
-
-                    /* Move to right after this alternative, including the
-                     * jump_past_alt.  */
-                    p1 += mcnt;
-
-                    /* Break if it's the beginning of an n-th alternative
-                     * that doesn't begin with an on_failure_jump.  */
-                    if ((re_opcode_t) * p1 != on_failure_jump)
-                        break;
-
-                    /* Still have to check that it's not an n-th
-                     * alternative that starts with an on_failure_jump.  */
-                    p1++;
-                    EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-                    if ((re_opcode_t) p1[mcnt - 3] != jump_past_alt) {
-                        /* Get to the beginning of the n-th alternative.  */
-                        p1 -= 3;
-                        break;
-                    }
-                }
-
-                /* Deal with the last alternative: go back and get number
-                 * of the `jump_past_alt' just before it.  `mcnt' contains
-                 * the length of the alternative.  */
-                EXTRACT_NUMBER(mcnt, p1 - 2);
-
-                if (!alt_match_null_string_p(p1, p1 + mcnt, reg_info))
-                    return false;
-
-                p1 += mcnt; /* Get past the n-th alternative.  */
-            }           /* if mcnt &gt; 0 */
-            break;
-
-        case stop_memory:
-            assert(p1[1] == **p);
-            *p = p1 + 2;
-            return true;
-
-        default:
-            if (!common_op_match_null_string_p(&amp;p1, end, reg_info))
-                return false;
-        }
-    }               /* while p1 &lt; end */
-
-    return false;
-}               /* group_match_null_string_p */
-
-/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
- * It expects P to be the first byte of a single alternative and END one
- * byte past the last. The alternative can contain groups.  */
-
-boolean
-alt_match_null_string_p(unsigned char *p, unsigned char *end, register_info_type *reg_info)
-{
-    int mcnt;
-    unsigned char *p1 = p;
-
-    while (p1 &lt; end) {
-        /* Skip over opcodes that can match nothing, and break when we get
-         * to one that can't.  */
-
-        switch ((re_opcode_t) * p1) {
-        /* It's a loop.  */
-        case on_failure_jump:
-            p1++;
-            EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-            p1 += mcnt;
-            break;
-
-        default:
-            if (!common_op_match_null_string_p(&amp;p1, end, reg_info))
-                return false;
-        }
-    }               /* while p1 &lt; end */
-
-    return true;
-}               /* alt_match_null_string_p */
-
-/* Deals with the ops common to group_match_null_string_p and
- * alt_match_null_string_p.
- *
- * Sets P to one after the op and its arguments, if any.  */
-
-boolean
-common_op_match_null_string_p( unsigned char **p, unsigned char *end, register_info_type *reg_info)
-{
-    int mcnt;
-    boolean ret;
-    int reg_no;
-    unsigned char *p1 = *p;
-
-    switch ((re_opcode_t) * p1++) {
-    case no_op:
-    case begline:
-    case endline:
-    case begbuf:
-    case endbuf:
-    case wordbeg:
-    case wordend:
-    case wordbound:
-    case notwordbound:
-        break;
-
-    case start_memory:
-        reg_no = *p1;
-        assert(reg_no &gt; 0 &amp;&amp; reg_no &lt;= MAX_REGNUM);
-        ret = group_match_null_string_p(&amp;p1, end, reg_info);
-
-        /* Have to set this here in case we're checking a group which
-         * contains a group and a back reference to it.  */
-
-        if (REG_MATCH_NULL_STRING_P(reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
-            REG_MATCH_NULL_STRING_P(reg_info[reg_no]) = ret;
-
-        if (!ret)
-            return false;
-        break;
-
-    /* If this is an optimized succeed_n for zero times, make the jump.  */
-    case jump:
-        EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-        if (mcnt &gt;= 0)
-            p1 += mcnt;
-        else
-            return false;
-        break;
-
-    case succeed_n:
-        /* Get to the number of times to succeed.  */
-        p1 += 2;
-        EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-
-        if (mcnt == 0) {
-            p1 -= 4;
-            EXTRACT_NUMBER_AND_INCR(mcnt, p1);
-            p1 += mcnt;
-        } else
-            return false;
-        break;
-
-    case duplicate:
-        if (!REG_MATCH_NULL_STRING_P(reg_info[*p1]))
-            return false;
-        break;
-
-    case set_number_at:
-        p1 += 4;
-
-    default:
-        /* All other opcodes mean we cannot match the empty string.  */
-        return false;
-    }
-
-    *p = p1;
-    return true;
-}               /* common_op_match_null_string_p */
-
-/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
- * bytes; nonzero otherwise.  */
-
-int
-bcmp_translate(unsigned char const *s1, unsigned char const*s2, register int len, char *translate)
-{
-    register unsigned char const *p1 = s1, *p2 = s2;
-    while (len) {
-        if (translate[*p1++] != translate[*p2++])
-            return 1;
-        len--;
-    }
-    return 0;
-}
-
-/* Entry points for GNU code.  */
-
-/* POSIX.2 functions */
-
-/* regcomp takes a regular expression as a string and compiles it.
- *
- * PREG is a regex_t *.  We do not expect any fields to be initialized,
- * since POSIX says we shouldn't.  Thus, we set
- *
- * `buffer' to the compiled pattern;
- * `used' to the length of the compiled pattern;
- * `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
- * REG_EXTENDED bit in CFLAGS is set; otherwise, to
- * RE_SYNTAX_POSIX_BASIC;
- * `newline_anchor' to REG_NEWLINE being set in CFLAGS;
- * `fastmap' and `fastmap_accurate' to zero;
- * `re_nsub' to the number of subexpressions in PATTERN.
- *
- * PATTERN is the address of the pattern string.
- *
- * CFLAGS is a series of bits which affect compilation.
- *
- * If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
- * use POSIX basic syntax.
- *
- * If REG_NEWLINE is set, then . and [^...] don't match newline.
- * Also, regexec will try a match beginning after every newline.
- *
- * If REG_ICASE is set, then we considers upper- and lowercase
- * versions of letters to be equivalent when matching.
- *
- * If REG_NOSUB is set, then when PREG is passed to regexec, that
- * routine will report only success or failure, and nothing about the
- * registers.
- *
- * It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
- * the return codes and their meanings.)  */
-
-int
-regcomp(preg, pattern, cflags)
-regex_t *preg;
-const char *pattern;
-int cflags;
-{
-    reg_errcode_t ret;
-    unsigned syntax
-        = (cflags &amp; REG_EXTENDED) ?
-          RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
-
-    /* regex_compile will allocate the space for the compiled pattern.  */
-    preg-&gt;buffer = 0;
-    preg-&gt;allocated = 0;
-
-    /* Don't bother to use a fastmap when searching.  This simplifies the
-     * REG_NEWLINE case: if we used a fastmap, we'd have to put all the
-     * characters after newlines into the fastmap.  This way, we just try
-     * every character.  */
-    preg-&gt;fastmap = 0;
-
-    if (cflags &amp; REG_ICASE) {
-        unsigned i;
-
-        preg-&gt;translate = (char *) malloc(CHAR_SET_SIZE);
-        if (preg-&gt;translate == NULL)
-            return (int) REG_ESPACE;
-
-        /* Map uppercase characters to corresponding lowercase ones.  */
-        for (i = 0; i &lt; CHAR_SET_SIZE; i++)
-            preg-&gt;translate[i] = ISUPPER(i) ? tolower(i) : i;
-    } else
-        preg-&gt;translate = NULL;
-
-    /* If REG_NEWLINE is set, newlines are treated differently.  */
-    if (cflags &amp; REG_NEWLINE) { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
-        syntax &amp;= ~RE_DOT_NEWLINE;
-        syntax |= RE_HAT_LISTS_NOT_NEWLINE;
-        /* It also changes the matching behavior.  */
-        preg-&gt;newline_anchor = 1;
-    } else
-        preg-&gt;newline_anchor = 0;
-
-    preg-&gt;no_sub = !!(cflags &amp; REG_NOSUB);
-
-    /* POSIX says a null character in the pattern terminates it, so we
-     * can use strlen here in compiling the pattern.  */
-    ret = regex_compile(pattern, strlen(pattern), syntax, preg);
-
-    /* POSIX doesn't distinguish between an unmatched open-group and an
-     * unmatched close-group: both are REG_EPAREN.  */
-    if (ret == REG_ERPAREN)
-        ret = REG_EPAREN;
-
-    return (int) ret;
-}
-
-/* regexec searches for a given pattern, specified by PREG, in the
- * string STRING.
- *
- * If NMATCH is zero or REG_NOSUB was set in the cflags argument to
- * `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
- * least NMATCH elements, and we set them to the offsets of the
- * corresponding matched substrings.
- *
- * EFLAGS specifies `execution flags' which affect matching: if
- * REG_NOTBOL is set, then ^ does not match at the beginning of the
- * string; if REG_NOTEOL is set, then $ does not match at the end.
- *
- * We return 0 if we find a match and REG_NOMATCH if not.  */
-
-int
-regexec(preg, string, nmatch, pmatch, eflags)
-const regex_t *preg;
-const char *string;
-size_t nmatch;
-regmatch_t pmatch[];
-int eflags;
-{
-    int ret;
-    struct re_registers regs;
-    regex_t private_preg;
-    int len = strlen(string);
-    boolean want_reg_info = !preg-&gt;no_sub &amp;&amp; nmatch &gt; 0;
-
-    private_preg = *preg;
-
-    private_preg.not_bol = !!(eflags &amp; REG_NOTBOL);
-    private_preg.not_eol = !!(eflags &amp; REG_NOTEOL);
-
-    /* The user has told us exactly how many registers to return
-     * information about, via `nmatch'.  We have to pass that on to the
-     * matching routines.  */
-    private_preg.regs_allocated = REGS_FIXED;
-
-    if (want_reg_info) {
-        regs.num_regs = nmatch;
-        regs.start = TALLOC(nmatch, regoff_t);
-        regs.end = TALLOC(nmatch, regoff_t);
-        if (regs.start == NULL || regs.end == NULL)
-            return (int) REG_NOMATCH;
-    }
-    /* Perform the searching operation.  */
-    ret = re_search(&amp;private_preg, string, len,
-                    /* start: */ 0, /* range: */ len,
-                    want_reg_info ? &amp;regs : (struct re_registers *) 0);
-
-    /* Copy the register information to the POSIX structure.  */
-    if (want_reg_info) {
-        if (ret &gt;= 0) {
-            unsigned r;
-
-            for (r = 0; r &lt; nmatch; r++) {
-                pmatch[r].rm_so = regs.start[r];
-                pmatch[r].rm_eo = regs.end[r];
-            }
-        }
-        /* If we needed the temporary register info, free the space now.  */
-        free(regs.start);
-        free(regs.end);
-    }
-    /* We want zero return to mean success, unlike `re_search'.  */
-    return ret &gt;= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
-}
-
-/* Returns a message corresponding to an error code, ERRCODE, returned
- * from either regcomp or regexec.   We don't use PREG here.  */
-
-size_t
-regerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
-{
-    const char *msg;
-    size_t msg_size;
-
-    if (errcode &lt; 0
-            || errcode &gt;= (sizeof(re_error_msg) / sizeof(re_error_msg[0])))
-        /* Only error codes returned by the rest of the code should be passed
-         * to this routine.  If we are given anything else, or if other regex
-         * code generates an invalid error code, then the program has a bug.
-         * Dump core so we can fix it.  */
-        abort();
-
-    msg = re_error_msg[errcode];
-
-    /* POSIX doesn't require that we do anything in this case, but why
-     * not be nice.  */
-    if (!msg)
-        msg = &quot;Success&quot;;
-
-    msg_size = strlen(msg) + 1; /* Includes the null.  */
-
-    if (errbuf_size != 0) {
-        if (msg_size &gt; errbuf_size) {
-            strncpy(errbuf, msg, errbuf_size - 1);
-            errbuf[errbuf_size - 1] = 0;
-        } else
-            strcpy(errbuf, msg);
-    }
-    return msg_size;
-}
-
-/* Free dynamically allocated space used by PREG.  */
-
-void
-regfree(preg)
-regex_t *preg;
-{
-    if (preg-&gt;buffer != NULL)
-        free(preg-&gt;buffer);
-    preg-&gt;buffer = NULL;
-
-    preg-&gt;allocated = 0;
-    preg-&gt;used = 0;
-
-    if (preg-&gt;fastmap != NULL)
-        free(preg-&gt;fastmap);
-    preg-&gt;fastmap = NULL;
-    preg-&gt;fastmap_accurate = 0;
-
-    if (preg-&gt;translate != NULL)
-        free(preg-&gt;translate);
-    preg-&gt;translate = NULL;
-}
-#endif /* USE_GNUREGEX */
-
-/*
- * Local variables:
- * make-backup-files: t
- * version-control: t
- * trim-versions-without-asking: nil
- * End:
- */
-

=== removed file 'compat/GnuRegex.h'
--- compat/GnuRegex.h	2015-01-13 07:25:36 +0000
+++ compat/GnuRegex.h	1970-01-01 00:00:00 +0000
@@ -1,413 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_REGEXP_LIBRARY_H
-#define SQUID_REGEXP_LIBRARY_H
-
-#if !USE_GNUREGEX /* try the system one by default */
-
-/* POSIX says that &lt;sys/types.h&gt; must be included (by the caller) before
- * &lt;regex.h&gt;.  */
-#if HAVE_SYS_TYPES_H
-#include &lt;sys/types.h&gt;
-#endif
-#if HAVE_REGEX_H
-#include &lt;regex.h&gt;
-#endif
-
-#else  /* USE_GNUREGEX */
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* Definitions for data structures and routines for the regular
- * expression library, version 0.12.
- *
- * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
-
-/* POSIX says that &lt;sys/types.h&gt; must be included (by the caller) before
- * &lt;regex.h&gt;.  */
-
-/* The following bits are used to determine the regexp syntax we
- * recognize.  The set/not-set meanings are chosen so that Emacs syntax
- * remains the value 0.  The bits are given in alphabetical order, and
- * the definitions shifted by one from the previous bit; thus, when we
- * add or remove a bit, only one other definition need change.  */
-typedef unsigned reg_syntax_t;
-
-/* If this bit is not set, then \ inside a bracket expression is literal.
- * If set, then such a \ quotes the following character.  */
-#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
-
-/* If this bit is not set, then + and ? are operators, and \+ and \? are
- * literals.
- * If set, then \+ and \? are operators and + and ? are literals.  */
-#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS &lt;&lt; 1)
-
-/* If this bit is set, then character classes are supported.  They are:
- * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
- * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
- * If not set, then character classes are not supported.  */
-#define RE_CHAR_CLASSES (RE_BK_PLUS_QM &lt;&lt; 1)
-
-/* If this bit is set, then ^ and $ are always anchors (outside bracket
- * expressions, of course).
- * If this bit is not set, then it depends:
- * ^  is an anchor if it is at the beginning of a regular
- * expression or after an open-group or an alternation operator;
- * $  is an anchor if it is at the end of a regular expression, or
- * before a close-group or an alternation operator.
- *
- * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
- * POSIX draft 11.2 says that * etc. in leading positions is undefined.
- * We already implemented a previous draft which made those constructs
- * invalid, though, so we haven't changed the code back.  */
-#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES &lt;&lt; 1)
-
-/* If this bit is set, then special characters are always special
- * regardless of where they are in the pattern.
- * If this bit is not set, then special characters are special only in
- * some contexts; otherwise they are ordinary.  Specifically,
- * * + ? and intervals are only special when not after the beginning,
- * open-group, or alternation operator.  */
-#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS &lt;&lt; 1)
-
-/* If this bit is set, then *, +, ?, and { cannot be first in an re or
- * immediately after an alternation or begin-group operator.  */
-#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS &lt;&lt; 1)
-
-/* If this bit is set, then . matches newline.
- * If not set, then it doesn't.  */
-#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS &lt;&lt; 1)
-
-/* If this bit is set, then . doesn't match NUL.
- * If not set, then it does.  */
-#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE &lt;&lt; 1)
-
-/* If this bit is set, nonmatching lists [^...] do not match newline.
- * If not set, they do.  */
-#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL &lt;&lt; 1)
-
-/* If this bit is set, either \{...\} or {...} defines an
- * interval, depending on RE_NO_BK_BRACES.
- * If not set, \{, \}, {, and } are literals.  */
-#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE &lt;&lt; 1)
-
-/* If this bit is set, +, ? and | aren't recognized as operators.
- * If not set, they are.  */
-#define RE_LIMITED_OPS (RE_INTERVALS &lt;&lt; 1)
-
-/* If this bit is set, newline is an alternation operator.
- * If not set, newline is literal.  */
-#define RE_NEWLINE_ALT (RE_LIMITED_OPS &lt;&lt; 1)
-
-/* If this bit is set, then `{...}' defines an interval, and \{ and \}
- * are literals.
- * If not set, then `\{...\}' defines an interval.  */
-#define RE_NO_BK_BRACES (RE_NEWLINE_ALT &lt;&lt; 1)
-
-/* If this bit is set, (...) defines a group, and \( and \) are literals.
- * If not set, \(...\) defines a group, and ( and ) are literals.  */
-#define RE_NO_BK_PARENS (RE_NO_BK_BRACES &lt;&lt; 1)
-
-/* If this bit is set, then \&lt;digit&gt; matches &lt;digit&gt;.
- * If not set, then \&lt;digit&gt; is a back-reference.  */
-#define RE_NO_BK_REFS (RE_NO_BK_PARENS &lt;&lt; 1)
-
-/* If this bit is set, then | is an alternation operator, and \| is literal.
- * If not set, then \| is an alternation operator, and | is literal.  */
-#define RE_NO_BK_VBAR (RE_NO_BK_REFS &lt;&lt; 1)
-
-/* If this bit is set, then an ending range point collating higher
- * than the starting range point, as in [z-a], is invalid.
- * If not set, then when ending range point collates higher than the
- * starting range point, the range is ignored.  */
-#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR &lt;&lt; 1)
-
-/* If this bit is set, then an unmatched ) is ordinary.
- * If not set, then an unmatched ) is invalid.  */
-#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES &lt;&lt; 1)
-
-/* Define combinations of the above bits for the standard possibilities.
- * (The [[[ comments delimit what gets put into the Texinfo file, so
- * don't delete them!)  */
-/* [[[begin syntaxes]]] */
-#define RE_SYNTAX_EMACS 0
-
-#define RE_SYNTAX_AWK                           \
-  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL           \
-   | RE_NO_BK_PARENS            | RE_NO_BK_REFS             \
-   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES           \
-   | RE_UNMATCHED_RIGHT_PAREN_ORD)
-
-#define RE_SYNTAX_POSIX_AWK                         \
-  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
-
-#define RE_SYNTAX_GREP                          \
-  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES             \
-   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS                \
-   | RE_NEWLINE_ALT)
-
-#define RE_SYNTAX_EGREP                         \
-  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS            \
-   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE            \
-   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS             \
-   | RE_NO_BK_VBAR)
-
-#define RE_SYNTAX_POSIX_EGREP                       \
-  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
-
-/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
-#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
-
-#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
-
-/* Syntax bits common to both basic and extended POSIX regex syntax.  */
-#define _RE_SYNTAX_POSIX_COMMON                     \
-  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL      \
-   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
-
-#define RE_SYNTAX_POSIX_BASIC                       \
-  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
-
-/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
- * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
- * isn't minimal, since other operators, such as \`, aren't disabled.  */
-#define RE_SYNTAX_POSIX_MINIMAL_BASIC                   \
-  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
-
-#define RE_SYNTAX_POSIX_EXTENDED                    \
-  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS           \
-   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES                \
-   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR              \
-   | RE_UNMATCHED_RIGHT_PAREN_ORD)
-
-/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
- * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
-#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED                \
-  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS          \
-   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES               \
-   | RE_NO_BK_PARENS        | RE_NO_BK_REFS             \
-   | RE_NO_BK_VBAR      | RE_UNMATCHED_RIGHT_PAREN_ORD)
-/* [[[end syntaxes]]] */
-
-/* Maximum number of duplicates an interval can allow.  Some systems
- * (erroneously) define this in other header files, but we want our
- * value, so remove any previous define.  */
-#ifdef RE_DUP_MAX
-#undef RE_DUP_MAX
-#endif
-#define RE_DUP_MAX ((1 &lt;&lt; 15) - 1)
-
-/* POSIX `cflags' bits (i.e., information for `regcomp').  */
-
-/* If this bit is set, then use extended regular expression syntax.
- * If not set, then use basic regular expression syntax.  */
-#define REG_EXTENDED 1
-
-/* If this bit is set, then ignore case when matching.
- * If not set, then case is significant.  */
-#define REG_ICASE (REG_EXTENDED &lt;&lt; 1)
-
-/* If this bit is set, then anchors do not match at newline
- * characters in the string.
- * If not set, then anchors do match at newlines.  */
-#define REG_NEWLINE (REG_ICASE &lt;&lt; 1)
-
-/* If this bit is set, then report only success or fail in regexec.
- * If not set, then returns differ between not matching and errors.  */
-#define REG_NOSUB (REG_NEWLINE &lt;&lt; 1)
-
-/* POSIX `eflags' bits (i.e., information for regexec).  */
-
-/* If this bit is set, then the beginning-of-line operator doesn't match
- * the beginning of the string (presumably because it's not the
- * beginning of a line).
- * If not set, then the beginning-of-line operator does match the
- * beginning of the string.  */
-#define REG_NOTBOL 1
-
-/* Like REG_NOTBOL, except for the end-of-line.  */
-#define REG_NOTEOL (1 &lt;&lt; 1)
-
-/* If any error codes are removed, changed, or added, update the
- * `re_error_msg' table in regex.c.  */
-typedef enum {
-    REG_NOERROR = 0,        /* Success.  */
-    REG_NOMATCH,        /* Didn't find a match (for regexec).  */
-
-    /* POSIX regcomp return error codes.  (In the order listed in the
-     * standard.)  */
-    REG_BADPAT,         /* Invalid pattern.  */
-    REG_ECOLLATE,       /* Not implemented.  */
-    REG_ECTYPE,         /* Invalid character class name.  */
-    REG_EESCAPE,        /* Trailing backslash.  */
-    REG_ESUBREG,        /* Invalid back reference.  */
-    REG_EBRACK,         /* Unmatched left bracket.  */
-    REG_EPAREN,         /* Parenthesis imbalance.  */
-    REG_EBRACE,         /* Unmatched \{.  */
-    REG_BADBR,          /* Invalid contents of \{\}.  */
-    REG_ERANGE,         /* Invalid range end.  */
-    REG_ESPACE,         /* Ran out of memory.  */
-    REG_BADRPT,         /* No preceding re for repetition op.  */
-
-    /* Error codes we've added.  */
-    REG_EEND,           /* Premature end.  */
-    REG_ESIZE,          /* Compiled pattern bigger than 2^16 bytes.  */
-    REG_ERPAREN         /* Unmatched ) or \); not returned from regcomp.  */
-} reg_errcode_t;
-
-/* This data structure represents a compiled pattern.  Before calling
- * the pattern compiler, the fields `buffer', `allocated', `fastmap',
- * `translate', and `no_sub' can be set.  After the pattern has been
- * compiled, the `re_nsub' field is available.  All other fields are
- * private to the regex routines.  */
-
-struct re_pattern_buffer {
-    /* [[[begin pattern_buffer]]] */
-    /* Space that holds the compiled pattern.  It is declared as
-     * `unsigned char *' because its elements are
-     * sometimes used as array indexes.  */
-    unsigned char *buffer;
-
-    /* Number of bytes to which `buffer' points.  */
-    unsigned long allocated;
-
-    /* Number of bytes actually used in `buffer'.  */
-    unsigned long used;
-
-    /* Syntax setting with which the pattern was compiled.  */
-    reg_syntax_t syntax;
-
-    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
-     * the fastmap, if there is one, to skip over impossible
-     * starting points for matches.  */
-    char *fastmap;
-
-    /* Either a translate table to apply to all characters before
-     * comparing them, or zero for no translation.  The translation
-     * is applied to a pattern when it is compiled and to a string
-     * when it is matched.  */
-    char *translate;
-
-    /* Number of subexpressions found by the compiler.  */
-    size_t re_nsub;
-
-    /* Zero if this pattern cannot match the empty string, one else.
-     * Well, in truth it's used only in `re_search_2', to see
-     * whether or not we should use the fastmap, so we don't set
-     * this absolutely perfectly; see `re_compile_fastmap' (the
-     * `duplicate' case).  */
-    unsigned can_be_null:1;
-
-    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
-     * for `max (RE_NREGS, re_nsub + 1)' groups.
-     * If REGS_REALLOCATE, reallocate space if necessary.
-     * If REGS_FIXED, use what's there.  */
-#define REGS_UNALLOCATED 0
-#define REGS_REALLOCATE 1
-#define REGS_FIXED 2
-    unsigned regs_allocated:2;
-
-    /* Set to zero when `regex_compile' compiles a pattern; set to one
-     * by `re_compile_fastmap' if it updates the fastmap.  */
-    unsigned fastmap_accurate:1;
-
-    /* If set, `re_match_2' does not return information about
-     * subexpressions.  */
-    unsigned no_sub:1;
-
-    /* If set, a beginning-of-line anchor doesn't match at the
-     * beginning of the string.  */
-    unsigned not_bol:1;
-
-    /* Similarly for an end-of-line anchor.  */
-    unsigned not_eol:1;
-
-    /* If true, an anchor at a newline matches.  */
-    unsigned newline_anchor:1;
-
-    /* [[[end pattern_buffer]]] */
-};
-
-typedef struct re_pattern_buffer regex_t;
-
-/* search.c (search_buffer) in Emacs needs this one opcode value.  It is
- * defined both in `regex.c' and here.  */
-#define RE_EXACTN_VALUE 1
-
-/* Type for byte offsets within the string.  POSIX mandates this.  */
-typedef int regoff_t;
-
-/* This is the structure we store register match data in.  See
- * regex.texinfo for a full description of what registers match.  */
-struct re_registers {
-    unsigned num_regs;
-    regoff_t *start;
-    regoff_t *end;
-};
-
-/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
- * `re_match_2' returns information about at least this many registers
- * the first time a `regs' structure is passed.  */
-#ifndef RE_NREGS
-#define RE_NREGS 30
-#endif
-
-/* POSIX specification for registers.  Aside from the different names than
- * `re_registers', POSIX uses an array of structures, instead of a
- * structure of arrays.  */
-typedef struct {
-    regoff_t rm_so;     /* Byte offset from string's start to substring's start.  */
-    regoff_t rm_eo;     /* Byte offset from string's start to substring's end.  */
-} regmatch_t;
-
-/* Declarations for routines.  */
-
-/* To avoid duplicating every routine declaration -- once with a
- * prototype (if we are ANSI), and once without (if we aren't) -- we
- * use the following macro to declare argument types.  This
- * unfortunately clutters up the declarations a bit, but I think it's
- * worth it.  */
-
-/* POSIX compatibility.  */
-extern int regcomp(regex_t * preg, const char *pattern, int cflags);
-extern int regexec(const regex_t * preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
-extern size_t regerror(int errcode, const regex_t * preg, char *errbuf, size_t errbuf_size);
-extern void regfree(regex_t * preg);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* USE_GNUREGEX */
-#endif /* SQUID_REGEXP_LIBRARY_H */
-
-/*
- * Local variables:
- * make-backup-files: t
- * version-control: t
- * trim-versions-without-asking: nil
- * End:
- */
-

=== modified file 'compat/Makefile.am'
--- compat/Makefile.am	2015-02-08 02:25:10 +0000
+++ compat/Makefile.am	2015-07-27 16:23:57 +0000
@@ -18,42 +18,40 @@
 
 noinst_LTLIBRARIES = libcompat-squid.la
 libcompat_squid_la_SOURCES = \
 	assert.cc \
 	assert.h \
 	cmsg.h \
 	compat.cc \
 	compat.h \
 	compat_shared.h \
 	cpu.h \
 	cppunit.h \
 	debug.cc \
 	debug.h \
 	eui64_aton.h \
 	eui64_aton.c \
 	fdsetsize.h \
 	getaddrinfo.cc \
 	getaddrinfo.h \
 	getnameinfo.cc \
 	getnameinfo.h \
-	GnuRegex.c \
-	GnuRegex.h \
 	inet_ntop.cc \
 	inet_ntop.h \
 	inet_pton.cc \
 	inet_pton.h \
 	initgroups.h \
 	memrchr.cc \
 	memrchr.h \
 	osdetect.h \
 	psignal.h \
 	shm.cc \
 	shm.h \
 	statvfs.h \
 	statvfs.cc \
 	stdio.h \
 	stdvarargs.h \
 	strnstr.cc \
 	strtoll.h \
 	strnrchr.h \
 	strnrchr.c \
 	tempnam.h \

=== modified file 'compat/compat.h'
--- compat/compat.h	2015-01-13 07:25:36 +0000
+++ compat/compat.h	2015-07-27 16:57:12 +0000
@@ -103,32 +103,25 @@
 #include &quot;compat/inet_ntop.h&quot;
 #include &quot;compat/inet_pton.h&quot;
 #include &quot;compat/stdvarargs.h&quot;
 
 /* cstdio has a bunch of problems with 64-bit definitions */
 #include &quot;compat/stdio.h&quot;
 
 /* POSIX statvfs() is still not universal */
 #include &quot;compat/statvfs.h&quot;
 
 /*****************************************************/
 /* component-specific portabilities                  */
 /*****************************************************/
 
 /* helper debugging requires some hacks to be clean */
 #include &quot;compat/debug.h&quot;
 
 /* Valgrind API macros changed between two versions squid supports */
 #include &quot;compat/valgrind.h&quot;
 
-/**
- * A Regular Expression library is bundled with Squid.
- * Default is to use a system provided one, but the bundle
- * may be used instead with explicit configuration.
- */
-#include &quot;compat/GnuRegex.h&quot;
-
 /* cppunit is not quite C++0x compatible yet */
 #include &quot;compat/cppunit.h&quot;
 
 #endif /* _SQUID_COMPAT_H */
 

=== modified file 'configure.ac'
--- configure.ac	2015-07-26 06:45:25 +0000
+++ configure.ac	2015-07-27 16:25:43 +0000
@@ -2771,41 +2771,40 @@
   gnumalloc.h \
   grp.h \
   ipl.h \
   lber.h \
   ldap.h \
   libc.h \
   limits.h \
   linux/posix_types.h \
   linux/types.h \
   malloc.h \
   math.h \
   memory.h \
   mount.h \
   netdb.h \
   netinet/in.h \
   netinet/in_systm.h \
   netinet/tcp.h \
   paths.h \
   poll.h \
   pwd.h \
-  regex.h \
   sched.h \
   siginfo.h \
   signal.h \
   stdarg.h \
   stddef.h \
   stdio.h \
   stdlib.h \
   string.h \
   strings.h \
   sys/bitypes.h \
   sys/file.h \
   sys/ioctl.h \
   sys/ipc.cc \
   sys/param.h \
   sys/prctl.h \
   sys/md5.h \
   sys/mman.h \
   sys/msg.h \
   sys/resource.h \
   sys/select.h \
@@ -3317,43 +3316,40 @@
 	getrusage \
 	getspnam \
 	gettimeofday \
 	glob \
 	mallocblksize \
 	mallopt \
 	memcpy \
 	memmove \
 	memrchr \
 	memset \
 	mkstemp \
 	mktime \
 	mstats \
 	poll \
 	prctl \
 	pthread_attr_setschedparam \
 	pthread_attr_setscope \
 	pthread_setschedparam \
 	pthread_sigmask \
 	putenv \
-	regcomp \
-	regexec \
-	regfree \
 	res_init \
 	__res_init \
 	rint \
 	sched_getaffinity \
 	sched_setaffinity \
 	select \
 	seteuid \
 	setgroups \
 	setpgrp \
 	setsid \
 	sigaction \
 	snprintf \
 	socketpair \
 	sysconf \
 	syslog \
 	timegm \
 	vsnprintf \
 )
 dnl ... and some we provide local replacements for
 AC_REPLACE_FUNCS(\
@@ -3605,85 +3601,40 @@
     with_netfilter_conntrack=no
 fi
 AC_MSG_NOTICE([Linux Netfilter Conntrack support enabled: ${with_netfilter_conntrack} ${squid_opt_netfilterconntrackpath}])
 
 
 AC_ARG_ENABLE(zph-qos,
   AS_HELP_STRING([--enable-zph-qos],[Enable ZPH QOS support]), [
 SQUID_YESNO([$enableval],
             [unrecognized argument to --enable-zph-qos: $enableval])
 ])
 SQUID_DEFINE_BOOL(USE_QOS_TOS,${enable_zph_qos:=yes},
           [Enable Zero Penalty Hit QOS. When set, Squid will alter the
            TOS field of HIT responses to help policing network traffic])
 AC_MSG_NOTICE([ZPH QOS enabled: $enable_zph_qos])
 if test x&quot;$enable_zph_qos&quot; = &quot;xyes&quot; ; then
         AC_MSG_NOTICE([QOS netfilter mark preservation enabled: $with_netfilter_conntrack])
         SQUID_DEFINE_BOOL(USE_LIBNETFILTERCONNTRACK,${with_netfilter_conntrack:=no},
                       [Enable support for QOS netfilter mark preservation])
 fi
 
-
-AC_CHECK_LIB(regex, regexec, [REGEXLIB=&quot;-lregex&quot;],[REGEXLIB=''])
-AC_ARG_ENABLE(gnuregex,
-  AS_HELP_STRING([--enable-gnuregex],
-                 [Compile GNUregex.  Unless you have reason to use 
-                 this option, you should not enable it.
-                 This library file is usually only required on Windows and 
-                 very old Unix boxes which do not have their own regex 
-                 library built in.]), [
-SQUID_YESNO([$enableval],[unrecognized argument to --enable-gnuregex: $enableval])
-])
-# force-enable on old solaris and nextstep
-if test &quot;x${enable_gnuregex:=auto}&quot; = &quot;xauto&quot; ; then
-    case &quot;$host&quot; in
-    *-sun-solaris2.[[0-4]])
-	  enable_gnuregex=&quot;yes&quot;
-	  ;;
-    *-next-nextstep*)
-	  enable_gnuregex=&quot;yes&quot;
-	  ;;
-    esac
-fi
-
-# try detecting if it is needed
-if test &quot;x$enable_gnuregex&quot; = &quot;xauto&quot; ; then
-  SQUID_CHECK_REGEX_WORKS
-  if test &quot;x$squid_cv_regex_works&quot; = &quot;xyes&quot; ; then
-    enable_gnuregex=no
-  else
-    enable_gnuregex=yes
-  fi
-fi
-AC_MSG_CHECKING(if GNUregex needs to be compiled)
-AC_MSG_RESULT($enable_gnuregex)
-if test &quot;x$enable_gnuregex&quot; = &quot;xyes&quot;; then
-  # for some reason (force-enable, test..) gnuregex was found as needed. Override any system lib
-  REGEXLIB=&quot;&quot;
-fi
-#if no reason was found to enable gnuregex, disable it
-if test &quot;x$enable_gnuregex&quot; = &quot;xauto&quot; ; then
-  enable_gnuregex=no
-fi
-SQUID_DEFINE_BOOL(USE_GNUREGEX,$enable_gnuregex,[Define if we should use GNU regex])
-AC_SUBST(REGEXLIB)
-
 SQUID_DETECT_UDP_SND_BUFSIZE
 SQUID_DETECT_UDP_RECV_BUFSIZE
 SQUID_DETECT_TCP_SND_BUFSIZE
 SQUID_DETECT_TCP_RECV_BUFSIZE
 
 SQUID_CHECK_RECV_ARG_TYPE
 SQUID_CHECK_NEED_SYS_ERRLIST
 SQUID_CHECK_MAXPATHLEN
 
 SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
 SQUID_CHECK_RESOLVER_FIELDS
 
 AC_CHECK_HEADERS(sys/statvfs.h)
 if test &quot;x$ac_cv_header_sys_statvfs_h&quot; = &quot;xyes&quot; ; then
   SQUID_CHECK_WORKING_STATVFS
 fi
 if test &quot;x$ac_cv_func_statvfs&quot; != &quot;xyes&quot; ; then
   AC_CHECK_HEADERS(sys/param.h sys/mount.h sys/vfs.h sys/statfs.h)
   AC_CHECK_FUNCS(statfs)
   SQUID_CHECK_F_FRSIZE_IN_STATFS

=== modified file 'doc/release-notes/release-4.sgml'
--- doc/release-notes/release-4.sgml	2015-06-29 12:57:04 +0000
+++ doc/release-notes/release-4.sgml	2015-07-27 16:29:51 +0000
@@ -101,80 +101,87 @@
 &lt;/itemize&gt;
 &lt;p&gt;
 
 &lt;sect1&gt;New tags&lt;label id=&quot;newtags&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
 	&lt;tag&gt;tls_outgoing_options&lt;/tag&gt;
 	&lt;p&gt;New tag to define TLS security context options for outgoing
 	   connections. For example to HTTPS servers.
 
 	&lt;tag&gt;url_rewrite_timeout&lt;/tag&gt;
 	&lt;p&gt;Squid times active requests to redirector. This option sets
 	   the timeout value and the Squid reaction to a timed out
 	   request.
 
 &lt;/descrip&gt;
 
 &lt;sect1&gt;Changes to existing tags&lt;label id=&quot;modifiedtags&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
+	&lt;tag&gt;acl&lt;/tag&gt;
+	&lt;p&gt;Due to differences between GNU Regex and libc regular expressions
+	   patterns using the double quote (&quot;) character may now be rejected
+	   by *_regex and regular expression based ACL types.
+
 	&lt;tag&gt;auth_param&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 	&lt;tag&gt;cache_peer&lt;/tag&gt;
 	&lt;p&gt;New option &lt;em&gt;tls-min-version=1.N&lt;/em&gt; to set minimum TLS version allowed.
 	&lt;p&gt;All &lt;em&gt;ssloptions=&lt;/em&gt; values for SSLv2 configuration or disabling
 	   have been removed.
 	&lt;p&gt;Removed &lt;em&gt;sslversion=&lt;/em&gt; option. Use &lt;em&gt;tls-options=&lt;/em&gt; instead.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.
 
 	&lt;tag&gt;external_acl_type&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 	&lt;tag&gt;http_port&lt;/tag&gt;
 	&lt;p&gt;New option &lt;em&gt;tls-min-version=1.N&lt;/em&gt; to set minimum TLS version allowed.
 	&lt;p&gt;All &lt;em&gt;option=&lt;/em&gt; values for SSLv2 configuration or disabling
 	   have been removed.
 	&lt;p&gt;Removed &lt;em&gt;version=&lt;/em&gt; option. Use &lt;em&gt;tls-options=&lt;/em&gt; instead.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.
 
 	&lt;tag&gt;https_port&lt;/tag&gt;
 	&lt;p&gt;New option &lt;em&gt;tls-min-version=1.N&lt;/em&gt; to set minimum TLS version allowed.
 	&lt;p&gt;All &lt;em&gt;options=&lt;/em&gt; values for SSLv2
 	   configuration or disabling have been removed.
 	&lt;p&gt;Removed &lt;em&gt;version=&lt;/em&gt; option. Use &lt;em&gt;tls-options=&lt;/em&gt; instead.
 	&lt;p&gt;New &lt;em&gt;options=SINGLE_ECDH_USE&lt;/em&gt; parameter to enable ephemeral
 	   ECDH key exchange.
 	&lt;p&gt;Deprecated &lt;em&gt;dhparams=&lt;/em&gt; option. Use &lt;em&gt;tls-dh=&lt;/em&gt; instead.
 	   The new option allows to optionally specify an elliptic curve for
 	   ephemeral ECDH by adding &lt;em&gt;curve-name:&lt;/em&gt; in front of the
 	   parameter file name.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.
 
 	&lt;tag&gt;refresh_pattern&lt;/tag&gt;
 	&lt;p&gt;Removed &lt;em&gt;ignore-auth&lt;/em&gt;. Its commonly desired behaviour is
 	   performed by default with correct HTTP/1.1 revalidation.
 	&lt;p&gt;Removed &lt;em&gt;ignore-must-revalidate&lt;/em&gt;. Other more HTTP compliant
 	   directives can be used to prevent objects from caching.
+	&lt;p&gt;Due to differences between GNURegex and libc regular expressions
+	   patterns using the double quote (&quot;) character may now be rejected.
 
 	&lt;tag&gt;sslcrtd_children&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 	&lt;tag&gt;sslcrtvalidator_children&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 	&lt;tag&gt;url_rewrite_children&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 &lt;/descrip&gt;
 
 &lt;sect1&gt;Removed tags&lt;label id=&quot;removedtags&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
 	&lt;tag&gt;cache_peer_domain&lt;/tag&gt;
 	&lt;p&gt;Superceded by &lt;em&gt;cache_peer_access&lt;/em&gt;. Use dstdomain ACL
@@ -230,40 +237,42 @@
 
 
 &lt;sect1&gt;New options&lt;label id=&quot;newoptions&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
 
 &lt;/descrip&gt;
 
 &lt;sect1&gt;Changes to existing options&lt;label id=&quot;modifiedoptions&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
 	&lt;tag&gt;--enable-auth-basic&lt;/tag&gt;
 	&lt;p&gt;The &lt;em&gt;MSNT-multi-domain&lt;/em&gt; helper has been removed.
 
 &lt;/descrip&gt;
 &lt;/p&gt;
 
 &lt;sect1&gt;Removed options&lt;label id=&quot;removedoptions&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
+	&lt;tag&gt;--enable-gnuregex&lt;/tag&gt;
+	&lt;p&gt;Squid now uses C++11 std::regex instead of GNU Regex. Removed.
 
 &lt;/descrip&gt;
 
 
 &lt;sect&gt;Regressions since Squid-2.7
 
 &lt;p&gt;Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-4
 
 &lt;p&gt;If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.
 
 &lt;sect1&gt;Missing squid.conf options available in Squid-2.7
 &lt;p&gt;
 &lt;descrip&gt;
 	&lt;tag&gt;broken_vary_encoding&lt;/tag&gt;
 	&lt;p&gt;Not yet ported from 2.6
 
 	&lt;tag&gt;cache_peer&lt;/tag&gt;
 	&lt;p&gt;&lt;em&gt;monitorinterval=&lt;/em&gt; not yet ported from 2.6
 	&lt;p&gt;&lt;em&gt;monitorsize=&lt;/em&gt; not yet ported from 2.6
 	&lt;p&gt;&lt;em&gt;monitortimeout=&lt;/em&gt; not yet ported from 2.6

=== modified file 'squid3.dox'
--- squid3.dox	2015-01-13 07:25:36 +0000
+++ squid3.dox	2015-07-27 16:30:37 +0000
@@ -1258,41 +1258,40 @@
 # or name=definition (no spaces). If the definition and the = are 
 # omitted =1 is assumed. To prevent a macro definition from being 
 # undefined via #undef or recursively expanded use the := operator 
 # instead of the = operator.
 
 PREDEFINED             = __cplusplus \
                          USE_HTTP_VIOLATIONS \
                          WITH_VALGRIND \
                          ICAP_CLIENT \
                          FORW_VIA_DB \
                          SQUID_SNMP \
                          X_ACCELERATOR_VARY \
                          USE_ARP_ACL \
                          USE_ASYNC_IO \
                          USE_AUTH \
                          USE_CACHE_DIGESTS \
                          USE_CLASSFUL \
                          USE_DELAY_POOLS \
                          USE_DLMALLOC \
                          USE_EPOLL \
-                         USE_GNUREGEX \
                          USE_HEXDUMP \
                          USE_HTCP \
                          USE_ICMP \
                          USE_IDENT \
                          USE_IPV6 \
                          USE_KQUEUE \
                          USE_LEAKFINDER \
                          USE_OPENSSL \
                          USE_POLL \
                          USE_REFERER_LOG \
                          USE_SELECT \
                          USE_SELECT_WIN32 \
                          USE_SQUID_ESI \
                          USE_OPENSSL \
                          USE_LINUX_TPROXY2 \
                          USE_LINUX_TPROXY4 \
                          USE_UNLINKD \
                          USE_USERAGENT_LOG \
                          USE_WCCP \
                          USE_WCCPv2 \

=== modified file 'src/AclRegs.cc'
--- src/AclRegs.cc	2015-04-10 08:54:13 +0000
+++ src/AclRegs.cc	2015-07-27 06:29:28 +0000
@@ -79,40 +79,41 @@
 #include &quot;acl/SslErrorData.h&quot;
 #endif
 #include &quot;acl/Strategised.h&quot;
 #include &quot;acl/Strategy.h&quot;
 #include &quot;acl/StringData.h&quot;
 #if USE_OPENSSL
 #include &quot;acl/ServerCertificate.h&quot;
 #endif
 #include &quot;acl/Tag.h&quot;
 #include &quot;acl/Time.h&quot;
 #include &quot;acl/TimeData.h&quot;
 #include &quot;acl/Url.h&quot;
 #include &quot;acl/UrlLogin.h&quot;
 #include &quot;acl/UrlPath.h&quot;
 #include &quot;acl/UrlPort.h&quot;
 #include &quot;acl/UserData.h&quot;
 #if USE_AUTH
 #include &quot;auth/AclMaxUserIp.h&quot;
 #include &quot;auth/AclProxyAuth.h&quot;
 #endif
+#include &quot;base/RegexPattern.h&quot;
 #if USE_IDENT
 #include &quot;ident/AclIdent.h&quot;
 #endif
 
 ACL::Prototype ACLBrowser::RegistryProtoype(&amp;ACLBrowser::RegistryEntry_, &quot;browser&quot;);
 ACLStrategised&lt;char const *&gt; ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy&lt;HDR_USER_AGENT&gt;::Instance(), &quot;browser&quot;);
 ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
 ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&amp;ACLDestinationDomain::LiteralRegistryEntry_, &quot;dstdomain&quot;);
 ACLStrategised&lt;char const *&gt; ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), &quot;dstdomain&quot;, DestinationDomainFlags);
 ACL::Prototype ACLDestinationDomain::RegexRegistryProtoype(&amp;ACLDestinationDomain::RegexRegistryEntry_, &quot;dstdom_regex&quot;);
 ACLFlag  DestinationDomainRegexFlags[] = {ACL_F_NO_LOOKUP, ACL_F_REGEX_CASE, ACL_F_END};
 ACLStrategised&lt;char const *&gt; ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,&quot;dstdom_regex&quot;, DestinationDomainRegexFlags);
 ACL::Prototype ACLDestinationIP::RegistryProtoype(&amp;ACLDestinationIP::RegistryEntry_, &quot;dst&quot;);
 ACLDestinationIP ACLDestinationIP::RegistryEntry_;
 #if USE_AUTH
 ACL::Prototype ACLExtUser::UserRegistryProtoype(&amp;ACLExtUser::UserRegistryEntry_, &quot;ext_user&quot;);
 ACLExtUser ACLExtUser::UserRegistryEntry_(new ACLUserData, &quot;ext_user&quot;);
 ACL::Prototype ACLExtUser::RegexRegistryProtoype(&amp;ACLExtUser::RegexRegistryEntry_, &quot;ext_user_regex&quot; );
 ACLExtUser ACLExtUser::RegexRegistryEntry_(new ACLRegexData, &quot;ext_user_regex&quot;);
 #endif

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-07-27 16:25:09 +0000
+++ src/Makefile.am	2015-07-28 12:11:18 +0000
@@ -562,41 +562,40 @@
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	DiskIO/libdiskio.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
 	security/libsecurity.la \
 	comm/libcomm.la \
 	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(XTRA_OBJS) \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
-	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SNMP_LIBS) \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SSLLIB) \
 	$(EPOLL_LIBS) \
 	$(MINGW_LIBS) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 if ENABLE_LOADABLE_MODULES
 squid_SOURCES += $(LOADABLE_MODULES_SOURCES)
 squid_LDADD += -L$(top_builddir) $(LIBLTDL)
 squid_LDFLAGS = -export-dynamic -dlopen force
 ## when static module linking is supported and enabled:
 ## squid_LDFLAGS = -all-static -dlopen self
@@ -660,41 +659,40 @@
 	RemovalPolicy.cc \
 	$(WIN32_SOURCE) \
 	fd.h \
 	tests/stub_fd.cc
 ufsdump_LDADD = \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(XTRA_OBJS) \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(EPOLL_LIBS) \
 	$(MINGW_LIBS) \
 	$(XTRA_LIBS)
 ufsdump_DEPENDENCIES = \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	DiskIO/libdiskio.la \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS)
@@ -969,42 +967,40 @@
 	HttpHdrContRange.cc \
 	HttpHdrContRange.h \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrSc.h \
 	HttpHdrScTarget.cc \
 	HttpHdrScTarget.h \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpControlMsg.h \
 	HttpMsg.cc \
 	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
 	MasterXaction.cc \
 	MasterXaction.h \
-	RegexList.h \
-	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
 	mime_header.h \
 	mime_header.cc \
 	Notes.h \
 	Notes.cc \
 	SquidString.h \
 	SquidTime.h \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
@@ -1174,41 +1170,40 @@
 tests_testACLMaxUserIP_LDADD= \
 	libsquid.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testACLMaxUserIP_LDFLAGS = $(LIBADD_DL)
 ##tests_testACLMaxUserIP_DEPENDENCIES = \
 ##	$(SQUID_CPPUNIT_LA)
 
 ## a demonstration test that does nothing but shows the salient points
 ## involved in writing tests.
 tests_testBoilerplate_SOURCES = \
 	tests/testBoilerplate.cc \
 	tests/testBoilerplate.h \
 	tests/stub_debug.cc \
 	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	tests/stub_cbdata.cc \
 	tests/stub_MemBuf.cc \
 	$(TESTSOURCES)
 tests_testBoilerplate_LDADD= \
@@ -1435,41 +1430,40 @@
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
 	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	anyp/libanyp.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testCacheManager_LDFLAGS = $(LIBADD_DL)
 tests_testCacheManager_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_testDiskIO_SOURCES = \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	client_db.h \
 	ClientInfo.h \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
@@ -1613,41 +1607,40 @@
 	acl/libacls.la \
 	acl/libstate.la \
 	comm/libcomm.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	$(REPL_OBJS) \
 	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	mgr/libmgr.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	dns/libdns.la \
 	base/libbase.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 tests_testDiskIO_LDFLAGS = $(LIBADD_DL)
 tests_testDiskIO_DEPENDENCIES = \
 	DiskIO/libdiskio.la \
 	$(SWAP_TEST_DS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_testDns_SOURCES= \
 	tests/testRFC1035.cc \
 	tests/testRFC1035.h
 nodist_tests_testDns_SOURCES= \
 	tests/stub_debug.cc \
 	tests/stub_SBuf.cc \
 	tests/stub_tools.cc
 tests_testDns_LDADD= \
 	dns/libdns.la \
@@ -1872,41 +1865,40 @@
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testEvent_LDFLAGS = $(LIBADD_DL)
 tests_testEvent_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests of the EventLoop module.
 tests_testEventLoop_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -2114,41 +2106,40 @@
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testEventLoop_LDFLAGS = $(LIBADD_DL)
 tests_testEventLoop_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_test_http_range_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
@@ -2352,41 +2343,40 @@
 	ip/libip.la \
 	fs/libfs.la \
 	anyp/libanyp.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	dns/libdns.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_test_http_range_LDFLAGS = $(LIBADD_DL)
 tests_test_http_range_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 tests_testHttp1Parser_SOURCES = \
 	Debug.h \
 	MemBuf.cc \
 	MemBuf.h \
 	tests/stub_MemObject.cc \
 	tests/stub_libmem.cc \
 	mime_header.cc \
 	mime_header.h \
 	String.cc \
 	cache_cf.h \
@@ -2640,41 +2630,40 @@
 	fs/libfs.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	parser/libsquid-parser.la \
 	dns/libdns.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpRequest_LDFLAGS = $(LIBADD_DL)
 tests_testHttpRequest_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 ## why so many sources? well httpHeaderTools requites ACLChecklist &amp; friends.
 ## first line - what we are testing.
 tests_testStore_SOURCES= \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	ClientInfo.h \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
@@ -2813,41 +2802,40 @@
 	libsquid.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	mem/libmem.la \
 	DiskIO/libdiskio.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testStore_LDFLAGS = $(LIBADD_DL)
 tests_testStore_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 ## string needs mem.cc.
 ## mem.cc needs ClientInfo.h
 ## libsquid pulls in SquidConfig and children. stub them.
 tests_testString_SOURCES = \
 	ClientInfo.h \
 	tests/stub_libmem.cc \
 	MemBuf.cc \
 	String.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
@@ -2855,41 +2843,40 @@
 	tests/testString.h \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/stub_time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testString_SOURCES = \
 	$(TESTSOURCES)
 tests_testString_LDADD = \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testString_LDFLAGS = $(LIBADD_DL)
 tests_testString_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 SWAP_TEST_DS =\
 	repl_modules.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	DiskIO/libdiskio.la \
 	ipc/libipc.la \
@@ -3046,41 +3033,40 @@
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
 	$(REPL_OBJS) \
 	acl/libacls.la \
 	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
 tests_testUfs_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
 check_PROGRAMS += testRefCount
 testRefCount_SOURCES= \
 	base/Lock.h \
 	base/RefCount.h \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_MemBuf.cc \
 	tests/testRefCount.cc
 testRefCount_LDADD = \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
@@ -3221,41 +3207,40 @@
 	libsquid.la \
 	comm/libcomm.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(COMMON_LIBS) \
 	$(REPL_OBJS) \
 	DiskIO/libdiskio.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	anyp/libanyp.la \
 	eui/libeui.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testRock_LDFLAGS = $(AM_CPPFLAGS) $(LIBADD_DL)
 tests_testRock_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
 ## Tests of the URL module.
 ## TODO: Trim this down once the insanity is over.
 tests_testURL_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	tests/stub_cache_manager.cc \
@@ -3454,41 +3439,40 @@
 	ftp/libftp.la \
 	parser/libsquid-parser.la \
 	anyp/libanyp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
-	$(REGEXLIB) \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testURL_LDFLAGS = $(LIBADD_DL)
 tests_testURL_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_testSBuf_SOURCES= \
@@ -3506,41 +3490,40 @@
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_libmem.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_tools.cc \
 	SquidString.h \
 	String.cc \
 	tests/stub_wordlist.cc \
 	tests/stub_MemBuf.cc
 nodist_tests_testSBuf_SOURCES=$(TESTSOURCES)
 tests_testSBuf_LDFLAGS = $(LIBADD_DL)
 tests_testSBuf_LDADD=\
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testSBuf_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
 
 tests_testSBufList_SOURCES= \
 	tests/testSBufList.h \
 	tests/testSBufList.cc \
 	$(SBUF_SOURCE) \
 	SBufList.h \
 	SBufList.cc \
 	SBufAlgos.h \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	SBufStream.h \
 	tests/stub_time.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_comm.cc \
 	tests/stub_debug.cc \
@@ -3588,41 +3571,40 @@
 	tests/testConfigParser.cc \
 	tests/testConfigParser.h \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testConfigParser_SOURCES = \
 	$(TESTSOURCES)
 tests_testConfigParser_LDADD = \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testConfigParser_LDFLAGS = $(LIBADD_DL)
 tests_testConfigParser_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 	
 tests_testStatHist_SOURCES = \
 	tests/stub_cbdata.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	tests/stub_MemBuf.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	StatHist.cc \
 	StatHist.h \
 	String.cc \
 	tests/stub_cache_manager.cc \

=== modified file 'src/RefreshPattern.h'
--- src/RefreshPattern.h	2015-06-19 07:13:57 +0000
+++ src/RefreshPattern.h	2015-07-27 15:12:35 +0000
@@ -1,49 +1,78 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_REFRESHPATTERN_H_
 #define SQUID_REFRESHPATTERN_H_
 
-#include &quot;compat/GnuRegex.h&quot;
+#include &quot;base/RegexPattern.h&quot;
 
-/// a representation of a refresh pattern. Currently a POD.
+/// a representation of a refresh pattern.
 class RefreshPattern
 {
+    MEMPROXY_CLASS(RefreshPattern);
+
 public:
-    const char *pattern;
-    regex_t compiled_pattern;
+
+    /*
+     * Defaults:
+     *      MIN     NONE
+     *      PCT     20%
+     *      MAX     3 days
+     */
+#define REFRESH_DEFAULT_MAX static_cast&lt;time_t&gt;(259200)
+
+    RefreshPattern(const char *aPattern, const decltype(RegexPattern::flags) &amp;reFlags) :
+        pattern(reFlags, aPattern),
+        min(0), pct(0.20), max(REFRESH_DEFAULT_MAX),
+        next(NULL),
+        max_stale(0)
+    {
+        memset(&amp;flags, 0, sizeof(flags));
+    }
+
+    ~RefreshPattern() {
+        while (RefreshPattern *t = next) {
+            next = t-&gt;next;
+            t-&gt;next = nullptr;
+            delete t;
+        }
+    }
+    // ~RefreshPattern() default destructor is fine
+
+    RegexPattern pattern;
     time_t min;
     double pct;
     time_t max;
     RefreshPattern *next;
 
     struct {
-        bool icase;
         bool refresh_ims;
         bool store_stale;
 #if USE_HTTP_VIOLATIONS
         bool override_expire;
         bool override_lastmod;
         bool reload_into_ims;
         bool ignore_reload;
         bool ignore_no_store;
         bool ignore_private;
 #endif
     } flags;
     int max_stale;
 
     // statistics about how many matches this pattern has had
     mutable struct stats_ {
+        stats_() : matchTests(0), matchCount(0) {}
+
         uint64_t matchTests;
         uint64_t matchCount;
         // TODO: some stats to indicate how useful/less the flags are would be nice.
     } stats;
 };
 
 #endif /* SQUID_REFRESHPATTERN_H_ */
 

=== modified file 'src/acl/HttpHeaderData.cc'
--- src/acl/HttpHeaderData.cc	2015-01-29 19:05:24 +0000
+++ src/acl/HttpHeaderData.cc	2015-07-27 06:25:10 +0000
@@ -1,35 +1,36 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/HttpHeaderData.h&quot;
 #include &quot;acl/RegexData.h&quot;
+#include &quot;base/RegexPattern.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;SBuf.h&quot;
 
 /* Construct an ACLHTTPHeaderData that uses an ACLRegex rule with the value of the
  * selected header from a given request.
  *
  * TODO: This can be generalised by making the type of the regex_rule into a
  * template parameter - so that we can use different rules types in future.
  */
 ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(HDR_BAD_HDR), regex_rule(new ACLRegexData)
 {}
 
 ACLHTTPHeaderData::~ACLHTTPHeaderData()
 {
     delete regex_rule;
 }
 
 bool

=== modified file 'src/acl/RegexData.cc'
--- src/acl/RegexData.cc	2015-01-13 07:25:36 +0000
+++ src/acl/RegexData.cc	2015-07-27 20:09:24 +0000
@@ -1,342 +1,266 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /*
  * Portions of this code are copyrighted and released under GPLv2+ by:
  * Copyright (c) 2011, Marcus Kool
  * Please add new claims to the CONTRIBUTORS file instead.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/RegexData.h&quot;
+#include &quot;base/RegexPattern.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;Debug.h&quot;
-#include &quot;RegexList.h&quot;
 #include &quot;wordlist.h&quot;
 
-static void
-aclDestroyRegexList(RegexList * data)
-{
-    RegexList *next = NULL;
-
-    for (; data; data = next) {
-        next = data-&gt;next;
-        regfree(&amp;data-&gt;regex);
-        safe_free(data-&gt;pattern);
-        memFree(data, MEM_RELIST);
-    }
-}
-
 ACLRegexData::~ACLRegexData()
 {
-    aclDestroyRegexList(data);
 }
 
 bool
 ACLRegexData::match(char const *word)
 {
-    if (word == NULL)
+    if (!word)
         return 0;
 
-    debugs(28, 3, &quot;aclRegexData::match: checking '&quot; &lt;&lt; word &lt;&lt; &quot;'&quot;);
-
-    RegexList *first, *prev;
-
-    first = data;
-
-    prev = NULL;
+    debugs(28, 3, &quot;checking '&quot; &lt;&lt; word &lt;&lt; &quot;'&quot;);
 
-    RegexList *current = first;
-
-    while (current) {
-        debugs(28, 3, &quot;aclRegexData::match: looking for '&quot; &lt;&lt; current-&gt;pattern &lt;&lt; &quot;'&quot;);
-
-        if (regexec(&amp;current-&gt;regex, word, 0, 0, 0) == 0) {
-            if (prev != NULL) {
-                /* shift the element just found to the second position
-                 * in the list */
-                prev-&gt;next = current-&gt;next;
-                current-&gt;next = first-&gt;next;
-                first-&gt;next = current;
-            }
-
-            debugs(28, 2, &quot;aclRegexData::match: match '&quot; &lt;&lt; current-&gt;pattern &lt;&lt; &quot;' found in '&quot; &lt;&lt; word &lt;&lt; &quot;'&quot;);
+    // walk the list of patterns to see if one matches
+    for (auto &amp;i : data) {
+        if (i.match(word)) {
+            debugs(28, 2, &quot;'&quot; &lt;&lt; i.c_str() &lt;&lt; &quot;' found in '&quot; &lt;&lt; word &lt;&lt; &quot;'&quot;);
+            // TODO: old code also popped the pattern to second place of the list
+            // in order to reduce patterns search times.
             return 1;
         }
-
-        prev = current;
-        current = current-&gt;next;
     }
 
     return 0;
 }
 
 SBufList
 ACLRegexData::dump() const
 {
     SBufList sl;
-    RegexList *temp = data;
-    int flags = REG_EXTENDED | REG_NOSUB;
+    auto flags = std::regex::extended | std::regex::nosubs;
 
-    while (temp != NULL) {
-        if (temp-&gt;flags != flags) {
-            if ((temp-&gt;flags&amp;REG_ICASE) != 0) {
+    // walk and dump the list
+    // keeping the flags values consistent
+    for (auto &amp;i : data) {
+        if (i.flags != flags) {
+            if ((i.flags &amp; std::regex::icase)) {
                 sl.push_back(SBuf(&quot;-i&quot;));
             } else {
                 sl.push_back(SBuf(&quot;+i&quot;));
             }
-            flags = temp-&gt;flags;
+            flags = i.flags;
         }
 
-        sl.push_back(SBuf(temp-&gt;pattern));
-        temp = temp-&gt;next;
+        sl.push_back(SBuf(i.c_str()));
     }
 
     return sl;
 }
 
 static const char *
 removeUnnecessaryWildcards(char * t)
 {
     char * orig = t;
 
     if (strncmp(t, &quot;^.*&quot;, 3) == 0)
         t += 3;
 
     /* NOTE: an initial '.' might seem unnessary but is not;
      * it can be a valid requirement that cannot be optimised
      */
     while (*t == '.'  &amp;&amp;  *(t+1) == '*') {
         t += 2;
     }
 
     if (*t == '\0') {
         debugs(28, DBG_IMPORTANT, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
         debugs(28, DBG_IMPORTANT, &quot;WARNING: regular expression '&quot; &lt;&lt; orig &lt;&lt; &quot;' has only wildcards and matches all strings. Using '.*' instead.&quot;);
         return &quot;.*&quot;;
     }
     if (t != orig) {
         debugs(28, DBG_IMPORTANT, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
         debugs(28, DBG_IMPORTANT, &quot;WARNING: regular expression '&quot; &lt;&lt; orig &lt;&lt; &quot;' has unnecessary wildcard(s). Using '&quot; &lt;&lt; t &lt;&lt; &quot;' instead.&quot;);
     }
 
     return t;
 }
 
-static RegexList **
-compileRE(RegexList **Tail, char * RE, int flags)
+static bool
+compileRE(std::list&lt;RegexPattern&gt; &amp;curlist, const char * RE, const decltype(RegexPattern::flags) &amp;flags)
 {
-    int errcode;
-    RegexList *q;
-    regex_t comp;
-
-    if (RE == NULL  ||  *RE == '\0')
-        return Tail;
-
-    if ((errcode = regcomp(&amp;comp, RE, flags)) != 0) {
-        char errbuf[256];
-        regerror(errcode, &amp;comp, errbuf, sizeof errbuf);
+    if (RE == NULL || *RE == '\0')
+        return curlist.empty(); // XXX: old code did this. It looks wrong.
+
+    // std::regex constructor does the actual compile and throws on invalid patterns
+    try {
+        curlist.emplace_back(flags, RE);
+
+    } catch(std::regex_error &amp;e) {
         debugs(28, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
-        debugs(28, DBG_CRITICAL, &quot;ERROR: invalid regular expression: '&quot; &lt;&lt; RE &lt;&lt; &quot;': &quot; &lt;&lt; errbuf);
-        return NULL;
-    }
-    debugs(28, 2, &quot;compileRE: compiled '&quot; &lt;&lt; RE &lt;&lt; &quot;' with flags &quot; &lt;&lt; flags );
+        debugs(28, DBG_CRITICAL, &quot;ERROR: invalid regular expression: '&quot; &lt;&lt; RE &lt;&lt; &quot;': &quot; &lt;&lt; e.code());
+        return false;
 
-    q = (RegexList *) memAllocate(MEM_RELIST);
-    q-&gt;pattern = xstrdup(RE);
-    q-&gt;regex = comp;
-    q-&gt;flags = flags;
-    *(Tail) = q;
-    Tail = &amp;q-&gt;next;
+    } catch(...) {
+        debugs(28, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
+        debugs(28, DBG_CRITICAL, &quot;ERROR: invalid regular expression: '&quot; &lt;&lt; RE &lt;&lt; &quot;': (unknown error)&quot;);
+        return false;
+    }
 
-    return Tail;
+    debugs(28, 2, &quot;compiled '&quot; &lt;&lt; RE &lt;&lt; &quot;' with flags &quot; &lt;&lt; flags);
+    return true;
 }
 
 /** Compose and compile one large RE from a set of (small) REs.
- * The ultimate goal is to have only one RE per ACL so that regexec() is
+ * The ultimate goal is to have only one RE per ACL so that match() is
  * called only once per ACL.
  */
 static int
-compileOptimisedREs(RegexList **curlist, wordlist * wl)
+compileOptimisedREs(std::list&lt;RegexPattern&gt; &amp;curlist, wordlist * wl)
 {
-    RegexList **Tail;
-    RegexList *newlist;
-    RegexList **newlistp;
+    std::list&lt;RegexPattern&gt; newlist;
     int numREs = 0;
-    int flags = REG_EXTENDED | REG_NOSUB;
+    auto flags = std::regex::extended | std::regex::nosubs;
     int largeREindex = 0;
     char largeRE[BUFSIZ];
-
-    newlist = NULL;
-    newlistp = &newlist;
-
-    largeRE[0] = '\0';
+    *largeRE = 0;
 
     while (wl != NULL) {
         int RElen;
         RElen = strlen( wl-&gt;key );
 
         if (strcmp(wl-&gt;key, &quot;-i&quot;) == 0) {
-            if (flags &amp; REG_ICASE) {
+            if ((flags &amp; std::regex::icase)) {
                 /* optimisation of  -i ... -i */
-                debugs(28, 2, &quot;compileOptimisedREs: optimisation of -i ... -i&quot; );
+                debugs(28, 2, &quot;optimisation of -i ... -i&quot; );
             } else {
-                debugs(28, 2, &quot;compileOptimisedREs: -i&quot; );
-                newlistp = compileRE( newlistp, largeRE, flags );
-                if (newlistp == NULL) {
-                    aclDestroyRegexList( newlist );
+                debugs(28, 2, &quot;-i&quot; );
+                if (!compileRE(newlist, largeRE, flags))
                     return 0;
-                }
-                flags |= REG_ICASE;
+                flags |= std::regex::icase;
                 largeRE[largeREindex=0] = '\0';
             }
         } else if (strcmp(wl-&gt;key, &quot;+i&quot;) == 0) {
-            if ((flags &amp; REG_ICASE) == 0) {
+            if (!(flags &amp; std::regex::icase)) {
                 /* optimisation of  +i ... +i */
-                debugs(28, 2, &quot;compileOptimisedREs: optimisation of +i ... +i&quot;);
+                debugs(28, 2, &quot;optimisation of +i ... +i&quot;);
             } else {
-                debugs(28, 2, &quot;compileOptimisedREs: +i&quot;);
-                newlistp = compileRE( newlistp, largeRE, flags );
-                if (newlistp == NULL) {
-                    aclDestroyRegexList( newlist );
+                debugs(28, 2, &quot;+i&quot;);
+                if (!compileRE(newlist, largeRE, flags))
                     return 0;
-                }
-                flags &amp;= ~REG_ICASE;
+                flags &amp;= ~std::regex::icase;
                 largeRE[largeREindex=0] = '\0';
             }
         } else if (RElen + largeREindex + 3 &lt; BUFSIZ-1) {
-            debugs(28, 2, &quot;compileOptimisedREs: adding RE '&quot; &lt;&lt; wl-&gt;key &lt;&lt; &quot;'&quot;);
+            debugs(28, 2, &quot;adding RE '&quot; &lt;&lt; wl-&gt;key &lt;&lt; &quot;'&quot;);
             if (largeREindex &gt; 0) {
                 largeRE[largeREindex] = '|';
                 ++largeREindex;
             }
             largeRE[largeREindex] = '(';
             ++largeREindex;
             for (char * t = wl-&gt;key; *t != '\0'; ++t) {
                 largeRE[largeREindex] = *t;
                 ++largeREindex;
             }
             largeRE[largeREindex] = ')';
             ++largeREindex;
             largeRE[largeREindex] = '\0';
             ++numREs;
         } else {
-            debugs(28, 2, &quot;compileOptimisedREs: buffer full, generating new optimised RE...&quot; );
-            newlistp = compileRE( newlistp, largeRE, flags );
-            if (newlistp == NULL) {
-                aclDestroyRegexList( newlist );
+            debugs(28, 2, &quot;buffer full, generating new optimised RE...&quot; );
+            if (!compileRE(newlist, largeRE, flags))
                 return 0;
-            }
             largeRE[largeREindex=0] = '\0';
             continue;    /* do the loop again to add the RE to largeRE */
         }
         wl = wl-&gt;next;
     }
 
-    newlistp = compileRE( newlistp, largeRE, flags );
-    if (newlistp == NULL) {
-        aclDestroyRegexList( newlist );
+    if (!compileRE(newlist, largeRE, flags))
         return 0;
-    }
 
     /* all was successful, so put the new list at the tail */
-    if (*curlist == NULL) {
-        *curlist = newlist;
-    } else {
-        for (Tail = curlist; *Tail != NULL; Tail = &amp;((*Tail)-&gt;next))
-            ;
-        (*Tail) = newlist;
-    }
+    curlist.splice(curlist.end(), newlist);
 
-    debugs(28, 2, &quot;compileOptimisedREs: &quot; &lt;&lt; numREs &lt;&lt; &quot; REs are optimised into one RE.&quot;);
+    debugs(28, 2, numREs &lt;&lt; &quot; REs are optimised into one RE.&quot;);
     if (numREs &gt; 100) {
         debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
         debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), &quot;WARNING: there are more than 100 regular expressions. &quot; &lt;&lt;
                &quot;Consider using less REs or use rules without expressions like 'dstdomain'.&quot;);
     }
 
     return 1;
 }
 
 static void
-compileUnoptimisedREs(RegexList **curlist, wordlist * wl)
+compileUnoptimisedREs(std::list&lt;RegexPattern&gt; &amp;curlist, wordlist * wl)
 {
-    RegexList **Tail;
-    RegexList **newTail;
-    int flags = REG_EXTENDED | REG_NOSUB;
-
-    for (Tail = curlist; *Tail != NULL; Tail = &amp;((*Tail)-&gt;next))
-        ;
+    auto flags = std::regex::extended | std::regex::nosubs;
 
     while (wl != NULL) {
         if (strcmp(wl-&gt;key, &quot;-i&quot;) == 0) {
-            flags |= REG_ICASE;
+            flags |= std::regex::icase;
         } else if (strcmp(wl-&gt;key, &quot;+i&quot;) == 0) {
-            flags &amp;= ~REG_ICASE;
+            flags &amp;= ~std::regex::icase;
         } else {
-            newTail = compileRE( Tail, wl-&gt;key , flags );
-            if (newTail == NULL)
+            if (!compileRE(curlist, wl-&gt;key , flags))
                 debugs(28, DBG_CRITICAL, &quot;ERROR: Skipping regular expression. Compile failed: '&quot; &lt;&lt; wl-&gt;key &lt;&lt; &quot;'&quot;);
-            else
-                Tail = newTail;
         }
         wl = wl-&gt;next;
     }
 }
 
-static void
-aclParseRegexList(RegexList **curlist)
+void
+ACLRegexData::parse()
 {
-    char *t;
-    wordlist *wl = NULL;
-
-    debugs(28, 2, HERE &lt;&lt; &quot;aclParseRegexList: new Regex line or file&quot;);
+    debugs(28, 2, &quot;new Regex line or file&quot;);
 
-    while ((t = ConfigParser::RegexStrtokFile()) != NULL) {
+    wordlist *wl = NULL;
+    while (char *t = ConfigParser::RegexStrtokFile()) {
         const char *clean = removeUnnecessaryWildcards(t);
         if (strlen(clean) &gt; BUFSIZ-1) {
             debugs(28, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
             debugs(28, DBG_CRITICAL, &quot;ERROR: Skipping regular expression. Larger than &quot; &lt;&lt; BUFSIZ-1 &lt;&lt; &quot; characters: '&quot; &lt;&lt; clean &lt;&lt; &quot;'&quot;);
         } else {
-            debugs(28, 3, &quot;aclParseRegexList: buffering RE '&quot; &lt;&lt; clean &lt;&lt; &quot;'&quot;);
+            debugs(28, 3, &quot;buffering RE '&quot; &lt;&lt; clean &lt;&lt; &quot;'&quot;);
             wordlistAdd(&amp;wl, clean);
         }
     }
 
-    if (!compileOptimisedREs(curlist, wl)) {
+    if (!compileOptimisedREs(data, wl)) {
         debugs(28, DBG_IMPORTANT, &quot;WARNING: optimisation of regular expressions failed; using fallback method without optimisation&quot;);
-        compileUnoptimisedREs(curlist, wl);
+        compileUnoptimisedREs(data, wl);
     }
 
     wordlistDestroy(&amp;wl);
 }
 
-void
-ACLRegexData::parse()
-{
-    aclParseRegexList(&amp;data);
-}
-
 bool
 ACLRegexData::empty() const
 {
-    return data == NULL;
+    return data.empty();
 }
 
 ACLData&lt;char const *&gt; *
 ACLRegexData::clone() const
 {
     /* Regex's don't clone yet. */
-    assert (!data);
+    assert(data.empty());
     return new ACLRegexData;
 }
 

=== modified file 'src/acl/RegexData.h'
--- src/acl/RegexData.h	2015-01-13 07:25:36 +0000
+++ src/acl/RegexData.h	2015-07-27 05:38:34 +0000
@@ -1,33 +1,35 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLREGEXDATA_H
 #define SQUID_ACLREGEXDATA_H
 
 #include &quot;acl/Data.h&quot;
 
-class RegexList;
+#include &lt;list&gt;
+
+class RegexPattern;
 
 class ACLRegexData : public ACLData&lt;char const *&gt;
 {
     MEMPROXY_CLASS(ACLRegexData);
 
 public:
     virtual ~ACLRegexData();
     virtual bool match(char const *user);
     virtual SBufList dump() const;
     virtual void parse();
     virtual bool empty() const;
     virtual ACLData&lt;char const *&gt; *clone() const;
 
 private:
-    RegexList *data;
+    std::list&lt;RegexPattern&gt; data;
 };
 
 #endif /* SQUID_ACLREGEXDATA_H */
 

=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2015-07-27 09:30:32 +0000
+++ src/base/Makefile.am	2015-07-28 12:11:18 +0000
@@ -11,40 +11,42 @@
 noinst_LTLIBRARIES = libbase.la
 
 libbase_la_SOURCES = \
 	AsyncCall.cc \
 	AsyncCall.h \
 	AsyncCbdataCalls.h \
 	AsyncJob.h \
 	AsyncJob.cc \
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
 	CbcPointer.h \
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
 	LruMap.h \
 	Packable.h \
+	RegexPattern.cc \
+	RegexPattern.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
 	TidyPointer.h
 
 EXTRA_PROGRAMS = \
 	testCharacterSet
 
 check_PROGRAMS += testCharacterSet
 TESTS += testCharacterSet
 
 testCharacterSet_SOURCES = \
 	CharacterSet.h \
 	testCharacterSet.h \
 	testCharacterSet.cc
 nodist_testCharacterSet_SOURCES = \
 	$(top_srcdir)/src/tests/stub_debug.cc \
 	$(top_srcdir)/src/tests/stub_MemBuf.cc \

=== renamed file 'src/RegexList.cc' =&gt; 'src/base/RegexPattern.cc'
--- src/RegexList.cc	2015-01-13 07:25:36 +0000
+++ src/base/RegexPattern.cc	2015-07-27 13:51:55 +0000
@@ -1,11 +1,21 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
-#include &quot;RegexList.h&quot;
+#include &quot;base/RegexPattern.h&quot;
 
+RegexPattern::RegexPattern(const std::regex_constants::syntax_option_type &amp;aFlags, const char *aPattern) :
+        flags(aFlags),
+        pattern(xstrdup(aPattern)),
+        regex(pattern, flags)
+{}
+
+RegexPattern::~RegexPattern()
+{
+    xfree(pattern);
+}

=== renamed file 'src/RegexList.h' =&gt; 'src/base/RegexPattern.h'
--- src/RegexList.h	2015-01-13 07:25:36 +0000
+++ src/base/RegexPattern.h	2015-07-27 14:25:54 +0000
@@ -1,23 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_REGEXLIST_H_
-#define SQUID_REGEXLIST_H_
+#ifndef SQUID_SRC_BASE_REGEXPATTERN_H
+#define SQUID_SRC_BASE_REGEXPATTERN_H
 
-/// list of regular expressions. Currently a POD.
-class RegexList
+#include &quot;mem/forward.h&quot;
+
+#include &lt;regex&gt;
+
+/**
+ * A regular expression,
+ * plain text and compiled representations
+ */
+class RegexPattern
 {
+    MEMPROXY_CLASS(RegexPattern);
+
 public:
-    int flags;
+    RegexPattern() = delete;
+    RegexPattern(const std::regex_constants::syntax_option_type &amp;aFlags, const char *aPattern); // throws std::regex_error
+    RegexPattern(const RegexPattern &amp;) = delete;
+    RegexPattern(RegexPattern &amp;&amp;) = default; // throws std::regex_error
+    ~RegexPattern();
+
+    const char * c_str() const {return pattern;}
+    bool match(const char *str) const {return std::regex_search(str, regex);}
+
+public:
+    std::regex_constants::syntax_option_type flags;
+
+private:
     char *pattern;
-    regex_t regex;
-    RegexList *next;
+    std::regex regex;
 };
 
-#endif /* SQUID_REGEXLIST_H_ */
+#endif /* SQUID_SRC_BASE_REGEXPATTERN_H */
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-07-15 16:09:06 +0000
+++ src/cache_cf.cc	2015-07-27 15:04:06 +0000
@@ -2540,42 +2540,42 @@
         //pop the token
         (void)ConfigParser::NextToken();
     } else if (!strcmp(token, &quot;off&quot;)) {
         debugs(0, DBG_PARSE_NOTE(2), &quot;WARNING: 'pipeline_prefetch off' is deprecated. Please update to use '0'.&quot;);
         *var = 0;
         //pop the token
         (void)ConfigParser::NextToken();
     } else
         parse_int(var);
 }
 
 #define free_pipelinePrefetch free_int
 #define dump_pipelinePrefetch dump_int
 
 static void
 dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 {
     while (head != NULL) {
         storeAppendPrintf(entry, &quot;%s%s %s %d %d%% %d&quot;,
                           name,
-                          head-&gt;flags.icase ? &quot; -i&quot; : null_string,
-                          head-&gt;pattern,
+                          head-&gt;pattern.flags &amp; std::regex::icase ? &quot; -i&quot; : null_string,
+                          head-&gt;pattern.c_str(),
                           (int) head-&gt;min / 60,
                           (int) (100.0 * head-&gt;pct + 0.5),
                           (int) head-&gt;max / 60);
 
         if (head-&gt;max_stale &gt;= 0)
             storeAppendPrintf(entry, &quot; max-stale=%d&quot;, head-&gt;max_stale);
 
         if (head-&gt;flags.refresh_ims)
             storeAppendPrintf(entry, &quot; refresh-ims&quot;);
 
         if (head-&gt;flags.store_stale)
             storeAppendPrintf(entry, &quot; store-stale&quot;);
 
 #if USE_HTTP_VIOLATIONS
 
         if (head-&gt;flags.override_expire)
             storeAppendPrintf(entry, &quot; override-expire&quot;);
 
         if (head-&gt;flags.override_lastmod)
             storeAppendPrintf(entry, &quot; override-lastmod&quot;);
@@ -2586,85 +2586,78 @@
         if (head-&gt;flags.ignore_reload)
             storeAppendPrintf(entry, &quot; ignore-reload&quot;);
 
         if (head-&gt;flags.ignore_no_store)
             storeAppendPrintf(entry, &quot; ignore-no-store&quot;);
 
         if (head-&gt;flags.ignore_private)
             storeAppendPrintf(entry, &quot; ignore-private&quot;);
 #endif
 
         storeAppendPrintf(entry, &quot;\n&quot;);
 
         head = head-&gt;next;
     }
 }
 
 static void
 parse_refreshpattern(RefreshPattern ** head)
 {
     char *token;
-    char *pattern;
     time_t min = 0;
     double pct = 0.0;
     time_t max = 0;
     int refresh_ims = 0;
     int store_stale = 0;
     int max_stale = -1;
 
 #if USE_HTTP_VIOLATIONS
 
     int override_expire = 0;
     int override_lastmod = 0;
     int reload_into_ims = 0;
     int ignore_reload = 0;
     int ignore_no_store = 0;
     int ignore_private = 0;
 #endif
 
-    int i;
-    RefreshPattern *t;
-    regex_t comp;
-    int errcode;
-    int flags = REG_EXTENDED | REG_NOSUB;
+    auto flags = std::regex::extended | std::regex::nosubs;
 
     if ((token = ConfigParser::RegexPattern()) != NULL) {
-
         if (strcmp(token, &quot;-i&quot;) == 0) {
-            flags |= REG_ICASE;
+            flags |= std::regex::icase;
             token = ConfigParser::RegexPattern();
         } else if (strcmp(token, &quot;+i&quot;) == 0) {
-            flags &amp;= ~REG_ICASE;
+            flags &amp;= ~std::regex::icase;
             token = ConfigParser::RegexPattern();
         }
-
     }
 
     if (token == NULL) {
         debugs(3, DBG_CRITICAL, &quot;FATAL: refresh_pattern missing the regex pattern parameter&quot;);
         self_destruct();
         return;
     }
 
-    pattern = xstrdup(token);
+    char *pattern = xstrdup(token);
 
-    i = GetInteger();       /* token: min */
+    int i = GetInteger();       /* token: min */
 
     /* catch negative and insanely huge values close to 32-bit wrap */
     if (i &lt; 0) {
         debugs(3, DBG_IMPORTANT, &quot;WARNING: refresh_pattern minimum age negative. Cropped back to zero.&quot;);
         i = 0;
     }
     if (i &gt; 60*24*365) {
         debugs(3, DBG_IMPORTANT, &quot;WARNING: refresh_pattern minimum age too high. Cropped back to 1 year.&quot;);
         i = 60*24*365;
     }
 
     min = (time_t) (i * 60);    /* convert minutes to seconds */
 
     i = GetPercentage();    /* token: pct */
 
     pct = (double) i / 100.0;
 
     i = GetInteger();       /* token: max */
 
     /* catch negative and insanely huge values close to 32-bit wrap */
@@ -2700,111 +2693,101 @@
             ignore_private = 1;
         else if (!strcmp(token, &quot;reload-into-ims&quot;)) {
             reload_into_ims = 1;
             refresh_nocache_hack = 1;
             /* tell client_side.c that this is used */
         } else if (!strcmp(token, &quot;ignore-reload&quot;)) {
             ignore_reload = 1;
             refresh_nocache_hack = 1;
             /* tell client_side.c that this is used */
 #endif
 
         } else if (!strcmp(token, &quot;ignore-no-cache&quot;) ||
                    !strcmp(token, &quot;ignore-must-revalidate&quot;) ||
                    !strcmp(token, &quot;ignore-auth&quot;)
                   ) {
             debugs(22, DBG_PARSE_NOTE(2), &quot;UPGRADE: refresh_pattern option '&quot; &lt;&lt; token &lt;&lt; &quot;' is obsolete. Remove it.&quot;);
         } else
             debugs(22, DBG_CRITICAL, &quot;refreshAddToList: Unknown option '&quot; &lt;&lt; pattern &lt;&lt; &quot;': &quot; &lt;&lt; token);
     }
 
-    if ((errcode = regcomp(&amp;comp, pattern, flags)) != 0) {
-        char errbuf[256];
-        regerror(errcode, &amp;comp, errbuf, sizeof errbuf);
+    RefreshPattern *t = nullptr;
+    try { // RegexPattern constructor throws on pattern errors
+        t = new RefreshPattern(pattern, flags);
+
+    } catch (std::regex_error &amp;e) {
         debugs(22, DBG_CRITICAL, &quot;&quot; &lt;&lt; cfg_filename &lt;&lt; &quot; line &quot; &lt;&lt; config_lineno &lt;&lt; &quot;: &quot; &lt;&lt; config_input_line);
-        debugs(22, DBG_CRITICAL, &quot;refreshAddToList: Invalid regular expression '&quot; &lt;&lt; pattern &lt;&lt; &quot;': &quot; &lt;&lt; errbuf);
+        debugs(22, DBG_CRITICAL, &quot;ERROR: Invalid regular expression '&quot; &lt;&lt; pattern &lt;&lt; &quot;': &quot; &lt;&lt; e.code());
         xfree(pattern);
         return;
     }
 
     pct = pct &lt; 0.0 ? 0.0 : pct;
     max = max &lt; 0 ? 0 : max;
-    t = static_cast&lt;RefreshPattern *&gt;(xcalloc(1, sizeof(RefreshPattern)));
-    t-&gt;pattern = (char *) xstrdup(pattern);
-    t-&gt;compiled_pattern = comp;
     t-&gt;min = min;
     t-&gt;pct = pct;
     t-&gt;max = max;
 
-    if (flags &amp; REG_ICASE)
-        t-&gt;flags.icase = true;
-
     if (refresh_ims)
         t-&gt;flags.refresh_ims = true;
 
     if (store_stale)
         t-&gt;flags.store_stale = true;
 
     t-&gt;max_stale = max_stale;
 
 #if USE_HTTP_VIOLATIONS
 
     if (override_expire)
         t-&gt;flags.override_expire = true;
 
     if (override_lastmod)
         t-&gt;flags.override_lastmod = true;
 
     if (reload_into_ims)
         t-&gt;flags.reload_into_ims = true;
 
     if (ignore_reload)
         t-&gt;flags.ignore_reload = true;
 
     if (ignore_no_store)
         t-&gt;flags.ignore_no_store = true;
 
     if (ignore_private)
         t-&gt;flags.ignore_private = true;
 #endif
 
     t-&gt;next = NULL;
 
     while (*head)
         head = &amp;(*head)-&gt;next;
 
     *head = t;
 
-    safe_free(pattern);
+    xfree(pattern);
 }
 
 static void
 free_refreshpattern(RefreshPattern ** head)
 {
-    RefreshPattern *t;
-
-    while ((t = *head) != NULL) {
-        *head = t-&gt;next;
-        safe_free(t-&gt;pattern);
-        regfree(&amp;t-&gt;compiled_pattern);
-        safe_free(t);
-    }
+    delete *head;
+    *head = nullptr;
 
 #if USE_HTTP_VIOLATIONS
     refresh_nocache_hack = 0;
 
 #endif
 }
 
 static void
 dump_string(StoreEntry * entry, const char *name, char *var)
 {
     if (var != NULL)
         storeAppendPrintf(entry, &quot;%s %s\n&quot;, name, var);
 }
 
 static void
 parse_string(char **var)
 {
     char *token = ConfigParser::NextToken();
     safe_free(*var);
 

=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-07-22 00:12:08 +0000
+++ src/clients/FtpGateway.cc	2015-07-27 18:14:33 +0000
@@ -31,40 +31,41 @@
 #include &quot;ip/tools.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;mime.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidString.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;StatCounters.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;tools.h&quot;
 #include &quot;URL.h&quot;
 #include &quot;util.h&quot;
 #include &quot;wordlist.h&quot;
 
 #if USE_DELAY_POOLS
 #include &quot;DelayPools.h&quot;
 #include &quot;MemObject.h&quot;
 #endif
 
 #include &lt;cerrno&gt;
+#include &lt;regex&gt;
 
 namespace Ftp
 {
 
 struct GatewayFlags {
 
     /* passive mode */
     bool pasv_supported;  ///&lt; PASV command is allowed
     bool epsv_all_sent;   ///&lt; EPSV ALL has been used. Must abort on failures.
     bool pasv_only;
     bool pasv_failed;  // was FwdState::flags.ftp_pasv_failed
 
     /* authentication */
     bool authenticated;         ///&lt; authentication success
     bool tried_auth_anonymous;  ///&lt; auth has tried to use anonymous credentials already.
     bool tried_auth_nopass;     ///&lt; auth tried username with no password already.
 
     /* other */
     bool isdir;
     bool skip_whitespace;
@@ -506,107 +507,100 @@
             return 1;
 
     return 0;
 }
 
 static void
 ftpListPartsFree(ftpListParts ** parts)
 {
     safe_free((*parts)-&gt;date);
     safe_free((*parts)-&gt;name);
     safe_free((*parts)-&gt;showname);
     safe_free((*parts)-&gt;link);
     safe_free(*parts);
 }
 
 #define MAX_TOKENS 64
 
 static ftpListParts *
 ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
 {
+    static const std::regex scan_ftp_integer(&quot;^[0-9]+$&quot;, std::regex::extended | std::regex::nosubs);
+    static const std::regex scan_ftp_time(&quot;^[0-9:]+$&quot;, std::regex::extended | std::regex::nosubs);
+    static const std::regex scan_ftp_dostime(&quot;^[0-9]+-[0-9]+-[0-9]+$&quot;, std::regex::extended | std::regex::nosubs);
+    static const std::regex scan_ftp_dosdate(&quot;^[0-9]+:[0-9]+[AP]M$&quot;, std::regex::extended | std::regex::nosubs | std::regex::icase);
+
     ftpListParts *p = NULL;
     char *t = NULL;
     const char *ct = NULL;
     char *tokens[MAX_TOKENS];
     int i;
     int n_tokens;
     static char tbuf[128];
     char *xbuf = NULL;
-    static int scan_ftp_initialized = 0;
-    static regex_t scan_ftp_integer;
-    static regex_t scan_ftp_time;
-    static regex_t scan_ftp_dostime;
-    static regex_t scan_ftp_dosdate;
-
-    if (!scan_ftp_initialized) {
-        scan_ftp_initialized = 1;
-        regcomp(&amp;scan_ftp_integer, &quot;^[0123456789]+$&quot;, REG_EXTENDED | REG_NOSUB);
-        regcomp(&amp;scan_ftp_time, &quot;^[0123456789:]+$&quot;, REG_EXTENDED | REG_NOSUB);
-        regcomp(&amp;scan_ftp_dosdate, &quot;^[0123456789]+-[0123456789]+-[0123456789]+$&quot;, REG_EXTENDED | REG_NOSUB);
-        regcomp(&amp;scan_ftp_dostime, &quot;^[0123456789]+:[0123456789]+[AP]M$&quot;, REG_EXTENDED | REG_NOSUB | REG_ICASE);
-    }
 
     if (buf == NULL)
         return NULL;
 
     if (*buf == '\0')
         return NULL;
 
     p = (ftpListParts *)xcalloc(1, sizeof(ftpListParts));
 
     n_tokens = 0;
 
     memset(tokens, 0, sizeof(tokens));
 
     xbuf = xstrdup(buf);
 
     if (flags.tried_nlst) {
         /* Machine readable format, one name per line */
         p-&gt;name = xbuf;
         p-&gt;type = '\0';
         return p;
     }
 
     for (t = strtok(xbuf, w_space); t &amp;&amp; n_tokens &lt; MAX_TOKENS; t = strtok(NULL, w_space)) {
         tokens[n_tokens] = xstrdup(t);
         ++n_tokens;
     }
 
     xfree(xbuf);
 
     /* locate the Month field */
     for (i = 3; i &lt; n_tokens - 2; ++i) {
         char *size = tokens[i - 1];
         char *month = tokens[i];
         char *day = tokens[i + 1];
         char *year = tokens[i + 2];
 
+        // checking that the other bits are all of the right pattern...
         if (!is_month(month))
             continue;
 
-        if (regexec(&amp;scan_ftp_integer, size, 0, NULL, 0) != 0)
+        if (!std::regex_match(size, scan_ftp_integer))
             continue;
 
-        if (regexec(&amp;scan_ftp_integer, day, 0, NULL, 0) != 0)
+        if (!std::regex_match(day, scan_ftp_integer))
             continue;
 
-        if (regexec(&amp;scan_ftp_time, year, 0, NULL, 0) != 0) /* Yr | hh:mm */
+        if (!std::regex_match(year, scan_ftp_time)) /* Yr | hh:mm */
             continue;
 
         snprintf(tbuf, 128, &quot;%s %2s %5s&quot;,
                  month, day, year);
 
         if (!strstr(buf, tbuf))
             snprintf(tbuf, 128, &quot;%s %2s %-5s&quot;,
                      month, day, year);
 
         char const *copyFrom = NULL;
 
         if ((copyFrom = strstr(buf, tbuf))) {
             p-&gt;type = *tokens[0];
             p-&gt;size = strtoll(size, NULL, 10);
             p-&gt;date = xstrdup(tbuf);
 
             if (flags.skip_whitespace) {
                 copyFrom += strlen(tbuf);
 
                 while (strchr(w_space, *copyFrom))
@@ -616,42 +610,42 @@
                  * suggested by:  <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">Nathan.Bailey at cc.monash.edu.au</A> and
                  * Mike Battersby &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">mike at starbug.bofh.asn.au</A>&gt; */
                 copyFrom += strlen(tbuf) + 1;
             }
 
             p-&gt;name = xstrdup(copyFrom);
 
             if (p-&gt;type == 'l' &amp;&amp; (t = strstr(p-&gt;name, &quot; -&gt; &quot;))) {
                 *t = '\0';
                 p-&gt;link = xstrdup(t + 4);
             }
 
             goto found;
         }
 
         break;
     }
 
     /* try it as a DOS listing, 04-05-70 09:33PM ... */
     if (n_tokens &gt; 3 &amp;&amp;
-            regexec(&amp;scan_ftp_dosdate, tokens[0], 0, NULL, 0) == 0 &amp;&amp;
-            regexec(&amp;scan_ftp_dostime, tokens[1], 0, NULL, 0) == 0) {
+            std::regex_match(tokens[0], scan_ftp_dosdate) &amp;&amp;
+            std::regex_match(tokens[1], scan_ftp_dostime)) {
         if (!strcasecmp(tokens[2], &quot;&lt;dir&gt;&quot;)) {
             p-&gt;type = 'd';
         } else {
             p-&gt;type = '-';
             p-&gt;size = strtoll(tokens[2], NULL, 10);
         }
 
         snprintf(tbuf, 128, &quot;%s %s&quot;, tokens[0], tokens[1]);
         p-&gt;date = xstrdup(tbuf);
 
         if (p-&gt;type == 'd') {
             /* Directory.. name begins with first printable after &lt;dir&gt; */
             ct = strstr(buf, tokens[2]);
             ct += strlen(tokens[2]);
 
             while (xisspace(*ct))
                 ++ct;
 
             if (!*ct)
                 ct = NULL;

=== modified file 'src/mem/forward.h'
--- src/mem/forward.h	2015-01-13 07:25:36 +0000
+++ src/mem/forward.h	2015-07-26 07:08:45 +0000
@@ -39,41 +39,40 @@
     MEM_2K_BUF,
     MEM_4K_BUF,
     MEM_8K_BUF,
     MEM_16K_BUF,
     MEM_32K_BUF,
     MEM_64K_BUF,
     MEM_ACL_DENY_INFO_LIST,
     MEM_ACL_NAME_LIST,
 #if USE_CACHE_DIGESTS
     MEM_CACHE_DIGEST,
 #endif
     MEM_CLIENT_INFO,
     MEM_LINK_LIST,
     MEM_DLINK_NODE,
     MEM_DREAD_CTRL,
     MEM_DWRITE_Q,
     MEM_HTTP_HDR_CONTENT_RANGE,
     MEM_MD5_DIGEST,
     MEM_NETDBENTRY,
     MEM_NET_DB_NAME,
-    MEM_RELIST,
     // IMPORTANT: leave this here. pools above are initialized early with memInit()
     MEM_DONTFREE,
     // following pools are initialized late by their component if needed (or never)
     MEM_FQDNCACHE_ENTRY,
     MEM_FWD_SERVER,
     MEM_IDNS_QUERY,
     MEM_IPCACHE_ENTRY,
     MEM_MAX
 } mem_type;
 
 void memClean(void);
 void memInitModule(void);
 void memCleanModule(void);
 void memConfigure(void);
 void *memAllocate(mem_type);
 void *memAllocString(size_t net_size, size_t * gross_size);
 void *memAllocBuf(size_t net_size, size_t * gross_size);
 void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
 void memFree(void *, int type);
 void memFreeString(size_t size, void *);

=== modified file 'src/mem/old_api.cc'
--- src/mem/old_api.cc	2015-01-13 07:25:36 +0000
+++ src/mem/old_api.cc	2015-07-27 04:27:40 +0000
@@ -6,41 +6,40 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 13    High Level Memory Pool Management */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/AclDenyInfoList.h&quot;
 #include &quot;acl/AclNameList.h&quot;
 #include &quot;CacheDigest.h&quot;
 #include &quot;ClientInfo.h&quot;
 #include &quot;disk.h&quot;
 #include &quot;dlink.h&quot;
 #include &quot;event.h&quot;
 #include &quot;icmp/net_db.h&quot;
 #include &quot;md5.h&quot;
 #include &quot;mem/forward.h&quot;
 #include &quot;mem/Pool.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;memMeter.h&quot;
 #include &quot;mgr/Registration.h&quot;
-#include &quot;RegexList.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidList.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;StoreEntryStream.h&quot;
 
 #include &lt;iomanip&gt;
 #include &lt;ostream&gt;
 
 /* forward declarations */
 static void memFree2K(void *);
 static void memFree4K(void *);
 static void memFree8K(void *);
 static void memFree16K(void *);
 static void memFree32K(void *);
 static void memFree64K(void *);
 
 /* module globals */
 const size_t squidSystemPageSize=getpagesize();
 
@@ -428,41 +427,40 @@
     memDataInit(MEM_4K_BUF, &quot;4K Buffer&quot;, 4096, 10, false);
     memDataInit(MEM_8K_BUF, &quot;8K Buffer&quot;, 8192, 10, false);
     memDataInit(MEM_16K_BUF, &quot;16K Buffer&quot;, 16384, 10, false);
     memDataInit(MEM_32K_BUF, &quot;32K Buffer&quot;, 32768, 10, false);
     memDataInit(MEM_64K_BUF, &quot;64K Buffer&quot;, 65536, 10, false);
     memDataInit(MEM_ACL_DENY_INFO_LIST, &quot;AclDenyInfoList&quot;,
                 sizeof(AclDenyInfoList), 0);
     memDataInit(MEM_ACL_NAME_LIST, &quot;acl_name_list&quot;, sizeof(AclNameList), 0);
 #if USE_CACHE_DIGESTS
 
     memDataInit(MEM_CACHE_DIGEST, &quot;CacheDigest&quot;, sizeof(CacheDigest), 0);
 #endif
 
     memDataInit(MEM_LINK_LIST, &quot;link_list&quot;, sizeof(link_list), 10);
     memDataInit(MEM_DLINK_NODE, &quot;dlink_node&quot;, sizeof(dlink_node), 10);
     memDataInit(MEM_DREAD_CTRL, &quot;dread_ctrl&quot;, sizeof(dread_ctrl), 0);
     memDataInit(MEM_DWRITE_Q, &quot;dwrite_q&quot;, sizeof(dwrite_q), 0);
     memDataInit(MEM_HTTP_HDR_CONTENT_RANGE, &quot;HttpHdrContRange&quot;, sizeof(HttpHdrContRange), 0);
     memDataInit(MEM_NETDBENTRY, &quot;netdbEntry&quot;, sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, &quot;net_db_name&quot;, sizeof(net_db_name), 0);
-    memDataInit(MEM_RELIST, &quot;RegexList&quot;, sizeof(RegexList), 0);
     memDataInit(MEM_CLIENT_INFO, &quot;ClientInfo&quot;, sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, &quot;MD5 digest&quot;, SQUID_MD5_DIGEST_LENGTH, 0);
     MemPools[MEM_MD5_DIGEST]-&gt;setChunkSize(512 * 1024);
 
     /** Lastly init the string pools. */
     for (i = 0; i &lt; mem_str_pool_count; ++i) {
         StrPools[i].pool = memPoolCreate(StrPoolsAttrs[i].name, StrPoolsAttrs[i].obj_size);
         StrPools[i].pool-&gt;zeroBlocks(false);
 
         if (StrPools[i].pool-&gt;objectSize() != StrPoolsAttrs[i].obj_size)
             debugs(13, DBG_IMPORTANT, &quot;Notice: &quot; &lt;&lt; StrPoolsAttrs[i].name &lt;&lt; &quot; is &quot; &lt;&lt; StrPools[i].pool-&gt;objectSize() &lt;&lt; &quot; bytes instead of requested &quot; &lt;&lt; StrPoolsAttrs[i].obj_size &lt;&lt; &quot; bytes&quot;);
     }
 
     MemIsInitialized = true;
 
     // finally register with the cache manager
     Mgr::RegisterAction(&quot;mem&quot;, &quot;Memory Utilization&quot;, Mem::Stats, 0, 1);
 }
 
 void

=== modified file 'src/mgr/QueryParams.cc'
--- src/mgr/QueryParams.cc	2015-01-13 07:25:36 +0000
+++ src/mgr/QueryParams.cc	2015-07-27 20:20:55 +0000
@@ -1,37 +1,39 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 16    Cache Manager API */
 
 #include &quot;squid.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;ipc/TypedMsgHdr.h&quot;
 #include &quot;mgr/IntParam.h&quot;
 #include &quot;mgr/QueryParams.h&quot;
 #include &quot;mgr/StringParam.h&quot;
 
+#include &lt;regex&gt;
+
 Mgr::QueryParam::Pointer
 Mgr::QueryParams::get(const String&amp; name) const
 {
     Must(name.size() != 0);
     Params::const_iterator pos = find(name);
     return (pos == params.end() ? NULL : pos-&gt;second);
 }
 
 void
 Mgr::QueryParams::pack(Ipc::TypedMsgHdr&amp; msg) const
 {
     msg.putInt(params.size());
     for (Params::const_iterator iter = params.begin(); iter != params.end(); ++iter) {
         Must(iter-&gt;first.size() != 0);
         msg.putString(iter-&gt;first);
         Must(iter-&gt;second != NULL);
         iter-&gt;second-&gt;pack(msg);
     }
 }
 
@@ -51,68 +53,74 @@
         value-&gt;unpackValue(msg);
         params.push_back(Param(name, value));
     }
 }
 
 Mgr::QueryParams::Params::const_iterator
 Mgr::QueryParams::find(const String&amp; name) const
 {
     Must(name.size() != 0);
     Params::const_iterator iter = params.begin();
     for ( ; iter != params.end(); ++iter) {
         if (name.caseCmp(iter-&gt;first) == 0)
             break;
     }
     return iter;
 }
 
 bool
 Mgr::QueryParams::ParseParam(const String&amp; paramStr, Param&amp; param)
 {
-    bool parsed = false;
-    regmatch_t pmatch[3];
-    regex_t intExpr;
-    regcomp(&amp;intExpr, &quot;^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$&quot;, REG_EXTENDED | REG_ICASE);
-    regex_t stringExpr;
-    regcomp(&amp;stringExpr, &quot;^([a-z][a-z0-9_]*)=([^&amp;= ]+)$&quot;, REG_EXTENDED | REG_ICASE);
-    if (regexec(&amp;intExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
-        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
+    std::regex intExpr(&quot;^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$&quot;, std::regex::extended | std::regex::icase);
+    std::regex stringExpr(&quot;^([a-z][a-z0-9_]*)=([^&amp;= ]+)$&quot;, std::regex::extended | std::regex::icase);
+    std::smatch pmatch;
+
+    std::string temp(paramStr.termedBuf());
+    if (std::regex_match(temp, pmatch, intExpr)) {
+
+        auto itr = pmatch.begin();
+        ++itr; // move to [1] - first actual sub-match
+
+        // match [1] is the key name
+        param.first = itr-&gt;str().c_str();
+        ++itr;
+
+        // match [2] and later are a series of N,N,N,N,N values
         std::vector&lt;int&gt; array;
-        int n = pmatch[2].rm_so;
-        for (int i = n; i &lt; pmatch[2].rm_eo; ++i) {
-            if (paramStr[i] == ',') {
-                array.push_back(atoi(paramStr.substr(n, i).termedBuf()));
-                n = i + 1;
-            }
+        while (itr != pmatch.end()) {
+            if (itr-&gt;str().c_str()[0] == ',')
+                array.push_back(atoi(itr-&gt;str().c_str()+1));
+            else
+                array.push_back(atoi(itr-&gt;str().c_str()));
+            ++itr;
         }
-        if (n &lt; pmatch[2].rm_eo)
-            array.push_back(atoi(paramStr.substr(n, pmatch[2].rm_eo).termedBuf()));
         param.second = new IntParam(array);
-        parsed = true;
-    } else if (regexec(&amp;stringExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
-        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
-        param.second = new StringParam(paramStr.substr(pmatch[2].rm_so, pmatch[2].rm_eo));
-        parsed = true;
+        return true;
     }
-    regfree(&amp;stringExpr);
-    regfree(&amp;intExpr);
-    return parsed;
+
+    if (std::regex_match(temp, pmatch, stringExpr)) {
+        param.first = pmatch[1].str().c_str();
+        param.second = new StringParam(pmatch[2].str().c_str());
+        return true;
+    }
+
+    return false;
 }
 
 bool
 Mgr::QueryParams::Parse(const String&amp; aParamsStr, QueryParams&amp; aParams)
 {
     if (aParamsStr.size() != 0) {
         Param param;
         size_t n = 0;
         size_t len = aParamsStr.size();
         for (size_t i = n; i &lt; len; ++i) {
             if (aParamsStr[i] == '&amp;') {
                 if (!ParseParam(aParamsStr.substr(n, i), param))
                     return false;
                 aParams.params.push_back(param);
                 n = i + 1;
             }
         }
         if (n &lt; len) {
             if (!ParseParam(aParamsStr.substr(n, len), param))
                 return false;

=== modified file 'src/mime.cc'
--- src/mime.cc	2015-07-07 11:53:08 +0000
+++ src/mime.cc	2015-07-27 20:28:13 +0000
@@ -1,31 +1,32 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 25    MIME Parsing and Internal Icons */
 
 #include &quot;squid.h&quot;
+#include &quot;base/RegexPattern.h&quot;
 #include &quot;disk.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpHdrCc.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;internal.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mime.h&quot;
 #include &quot;RequestFlags.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;StoreClient.h&quot;
 
 #if HAVE_SYS_STAT_H
 #include &lt;sys/stat.h&gt;
 #endif
 
 /* forward declarations */
@@ -39,73 +40,74 @@
 public:
     explicit MimeIcon(const char *aName);
     ~MimeIcon();
     void setName(char const *);
     SBuf getName() const;
     void load();
 
     /* StoreClient API */
     virtual void created(StoreEntry *);
 
 private:
     SBuf icon_;
     char *url_;
 };
 
 class MimeEntry
 {
     MEMPROXY_CLASS(MimeEntry);
 
 public:
-    explicit MimeEntry(const char *aPattern, const regex_t &amp;compiledPattern,
+    MimeEntry(const char *aPattern, const decltype(RegexPattern::flags) &amp;reFlags,
                        const char *aContentType,
                        const char *aContentEncoding, const char *aTransferMode,
                        bool optionViewEnable, bool optionDownloadEnable,
                        const char *anIconName);
+    MimeEntry(const MimeEntry &amp;) = delete;
+    MimeEntry(const MimeEntry &amp;&amp;) = delete;
     ~MimeEntry();
 
-    const char *pattern;
-    regex_t compiled_pattern;
+    RegexPattern pattern;
     const char *content_type;
     const char *content_encoding;
     char transfer_mode;
     bool view_option;
     bool download_option;
     MimeIcon theIcon;
     MimeEntry *next;
 };
 
 static MimeEntry *MimeTable = NULL;
 static MimeEntry **MimeTableTail = &MimeTable;
 
 static MimeEntry *
 mimeGetEntry(const char *fn, int skip_encodings)
 {
     MimeEntry *m;
     char *t;
     char *name = xstrdup(fn);
 
     do {
         t = NULL;
 
         for (m = MimeTable; m; m = m-&gt;next) {
-            if (regexec(&amp;m-&gt;compiled_pattern, name, 0, 0, 0) == 0)
+            if (m-&gt;pattern.match(name))
                 break;
         }
 
         if (!skip_encodings)
             (void) 0;
         else if (m == NULL)
             (void) 0;
         else if (strcmp(m-&gt;content_type, dash_str))
             (void) 0;
         else if (!strcmp(m-&gt;content_encoding, dash_str))
             (void) 0;
         else {
             /* Assume we matched /\.\w$/ and cut off the last extension */
             if ((t = strrchr(name, '.'))) {
                 *t = '\0';
             } else {
                 /* What? A encoding without a extension? */
                 m = NULL;
             }
         }
@@ -214,126 +216,126 @@
 
 bool
 mimeGetViewOption(const char *fn)
 {
     MimeEntry *m = mimeGetEntry(fn, 0);
     return m != 0 ? m-&gt;view_option : false;
 }
 
 /* Initializes/reloads the mime table
  * Note: Due to Solaris STDIO problems the caller should NOT
  * call mimeFreeMemory on reconfigure. This way, if STDIO
  * fails we at least have the old copy loaded.
  */
 void
 mimeInit(char *filename)
 {
     FILE *fp;
     char buf[BUFSIZ];
     char chopbuf[BUFSIZ];
     char *t;
-    char *pattern;
     char *icon;
     char *type;
     char *encoding;
     char *mode;
     char *option;
     int view_option;
     int download_option;
-    regex_t re;
     MimeEntry *m;
-    int re_flags = REG_EXTENDED | REG_NOSUB | REG_ICASE;
 
     if (filename == NULL)
         return;
 
     if ((fp = fopen(filename, &quot;r&quot;)) == NULL) {
         debugs(25, DBG_IMPORTANT, &quot;mimeInit: &quot; &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; xstrerror());
         return;
     }
 
 #if _SQUID_WINDOWS_
     setmode(fileno(fp), O_TEXT);
 #endif
 
     mimeFreeMemory();
 
+    const auto re_flags = std::regex::extended | std::regex::nosubs | std::regex::icase;
+
     while (fgets(buf, BUFSIZ, fp)) {
         if ((t = strchr(buf, '#')))
             *t = '\0';
 
         if ((t = strchr(buf, '\r')))
             *t = '\0';
 
         if ((t = strchr(buf, '\n')))
             *t = '\0';
 
         if (buf[0] == '\0')
             continue;
 
         xstrncpy(chopbuf, buf, BUFSIZ);
 
+        char *pattern;
         if ((pattern = strtok(chopbuf, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, &quot;mimeInit: parse error: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
             continue;
         }
 
         if ((type = strtok(NULL, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, &quot;mimeInit: parse error: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
             continue;
         }
 
         if ((icon = strtok(NULL, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, &quot;mimeInit: parse error: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
             continue;
         }
 
         if ((encoding = strtok(NULL, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, &quot;mimeInit: parse error: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
             continue;
         }
 
         if ((mode = strtok(NULL, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, &quot;mimeInit: parse error: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
             continue;
         }
 
         download_option = 0;
         view_option = 0;
 
         while ((option = strtok(NULL, w_space)) != NULL) {
             if (!strcmp(option, &quot;+download&quot;))
                 download_option = 1;
             else if (!strcmp(option, &quot;+view&quot;))
                 view_option = 1;
             else
                 debugs(25, DBG_IMPORTANT, &quot;mimeInit: unknown option: '&quot; &lt;&lt; buf &lt;&lt; &quot;' (&quot; &lt;&lt; option &lt;&lt; &quot;)&quot;);
         }
 
-        if (regcomp(&amp;re, pattern, re_flags) != 0) {
-            debugs(25, DBG_IMPORTANT, &quot;mimeInit: regcomp error: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
+        try {
+            m = new MimeEntry(pattern, re_flags, type, encoding, mode, view_option, download_option, icon);
+
+        } catch (std::regex_error &amp;e) {
+            debugs(25, DBG_IMPORTANT, &quot;mimeInit: invalid regular expression: '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
             continue;
         }
 
-        m = new MimeEntry(pattern,re,type,encoding,mode,view_option,
-                          download_option,icon);
-
         *MimeTableTail = m;
 
         MimeTableTail = &amp;m-&gt;next;
 
         debugs(25, 5, &quot;mimeInit: added '&quot; &lt;&lt; buf &lt;&lt; &quot;'&quot;);
     }
 
     fclose(fp);
 
     for (m = MimeTable; m != NULL; m = m-&gt;next)
         m-&gt;theIcon.load();
     debugs(25, DBG_IMPORTANT, &quot;Finished loading MIME types and icons.&quot;);
 }
 
 void
 mimeFreeMemory(void)
 {
     MimeEntry *m;
 
     while ((m = MimeTable)) {
@@ -421,46 +423,44 @@
     if (status == Http::scOkay) {
         /* read the file into the buffer and append it to store */
         int n;
         char *buf = (char *)memAllocate(MEM_4K_BUF);
         while ((n = FD_READ_METHOD(fd, buf, sizeof(*buf))) &gt; 0)
             e-&gt;append(buf, n);
 
         file_close(fd);
         memFree(buf, MEM_4K_BUF);
     }
 
     e-&gt;flush();
     e-&gt;complete();
     e-&gt;timestampsSet();
     e-&gt;unlock(&quot;MimeIcon::created&quot;);
     debugs(25, 3, &quot;Loaded icon &quot; &lt;&lt; url_);
 }
 
 MimeEntry::~MimeEntry()
 {
-    xfree(pattern);
     xfree(content_type);
     xfree(content_encoding);
-    regfree(&amp;compiled_pattern);
 }
 
-MimeEntry::MimeEntry(const char *aPattern, const regex_t &amp;compiledPattern,
+MimeEntry::MimeEntry(const char *aPattern, const decltype(RegexPattern::flags) &amp;reFlags,
                      const char *aContentType, const char *aContentEncoding,
                      const char *aTransferMode, bool optionViewEnable,
                      bool optionDownloadEnable, const char *anIconName) :
-    pattern(xstrdup(aPattern)),
-    compiled_pattern(compiledPattern),
+    pattern(reFlags, aPattern),
     content_type(xstrdup(aContentType)),
     content_encoding(xstrdup(aContentEncoding)),
     view_option(optionViewEnable),
     download_option(optionDownloadEnable),
-    theIcon(anIconName), next(NULL)
+    theIcon(anIconName),
+    next(nullptr)
 {
     if (!strcasecmp(aTransferMode, &quot;ascii&quot;))
         transfer_mode = 'A';
     else if (!strcasecmp(aTransferMode, &quot;text&quot;))
         transfer_mode = 'A';
     else
         transfer_mode = 'I';
 }
 

=== modified file 'src/refresh.cc'
--- src/refresh.cc	2015-07-19 13:23:01 +0000
+++ src/refresh.cc	2015-07-27 15:44:36 +0000
@@ -1,34 +1,30 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 22    Refresh Calculation */
 
-#ifndef USE_POSIX_REGEX
-#define USE_POSIX_REGEX     /* put before includes; always use POSIX */
-#endif
-
 #include &quot;squid.h&quot;
 #include &quot;HttpHdrCc.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;RefreshPattern.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;URL.h&quot;
 #include &quot;util.h&quot;
 
 typedef enum {
     rcHTTP,
     rcICP,
 #if USE_HTCP
     rcHTCP,
 #endif
 #if USE_CACHE_DIGESTS
@@ -62,97 +58,81 @@
     FRESH_MIN_RULE,
     FRESH_OVERRIDE_EXPIRES,
     FRESH_OVERRIDE_LASTMOD,
     STALE_MUST_REVALIDATE = 200,
     STALE_RELOAD_INTO_IMS,
     STALE_FORCED_RELOAD,
     STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE,
     STALE_EXPIRES,
     STALE_MAX_RULE,
     STALE_LMFACTOR_RULE,
     STALE_MAX_STALE,
     STALE_DEFAULT = 299
 };
 
 static struct RefreshCounts {
     const char *proto;
     int total;
     int status[STALE_DEFAULT + 1];
 } refreshCounts[rcCount];
 
-/*
- * Defaults:
- *      MIN     NONE
- *      PCT     20%
- *      MAX     3 days
- */
-#define REFRESH_DEFAULT_MIN (time_t)0
-#define REFRESH_DEFAULT_PCT 0.20
-#define REFRESH_DEFAULT_MAX (time_t)259200
-
 static const RefreshPattern *refreshUncompiledPattern(const char *);
 static OBJH refreshStats;
 static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf);
 
-static RefreshPattern DefaultRefresh;
+static RefreshPattern DefaultRefresh(&quot;.&quot;,std::regex_constants::syntax_option_type());
 
 /** Locate the first refresh_pattern rule that matches the given URL by regex.
  *
- * \note regexec() returns 0 if matched, and REG_NOMATCH otherwise
- *
- * \return A pointer to the refresh_pattern parameters to use, or NULL if there is no match.
+ * \return A pointer to the refresh_pattern parameters to use, or nullptr if there is no match.
  */
 const RefreshPattern *
 refreshLimits(const char *url)
 {
-    const RefreshPattern *R;
-
-    for (R = Config.Refresh; R; R = R-&gt;next) {
+    for (auto R = Config.Refresh; R; R = R-&gt;next) {
         ++(R-&gt;stats.matchTests);
-        if (!regexec(&amp;(R-&gt;compiled_pattern), url, 0, 0, 0)) {
+        if (R-&gt;pattern.match(url)) {
             ++(R-&gt;stats.matchCount);
             return R;
         }
     }
 
-    return NULL;
+    return nullptr;
 }
 
 /** Locate the first refresh_pattern rule that has the given uncompiled regex.
  *
  * \note There is only one reference to this function, below. It always passes &quot;.&quot; as the pattern.
  * This function is only ever called if there is no URI. Because a regex match is impossible, Squid
  * forces the &quot;.&quot; rule to apply (if it exists)
  *
- * \return A pointer to the refresh_pattern parameters to use, or NULL if there is no match.
+ * \return A pointer to the refresh_pattern parameters to use, or nullptr if there is no match.
  */
 static const RefreshPattern *
 refreshUncompiledPattern(const char *pat)
 {
-    const RefreshPattern *R;
-
-    for (R = Config.Refresh; R; R = R-&gt;next) {
-        if (0 == strcmp(R-&gt;pattern, pat))
+    for (auto R = Config.Refresh; R; R = R-&gt;next) {
+        if (0 == strcmp(R-&gt;pattern.c_str(), pat))
             return R;
     }
 
-    return NULL;
+    return nullptr;
 }
 
 /**
  * Calculate how stale the response is (or will be at the check_time).
  *
  * We try the following ways until one gives a result:
  *
  * 1. response expiration time, if one was set
  * 2. age greater than configured maximum
  * 3. last-modified factor algorithm
  * 4. age less than configured minimum
  * 5. default (stale)
  *
  * \param entry       the StoreEntry being examined
  * \param check_time  the time (maybe future) at which we want to know whether $
  * \param age         the age of the entry at check_time
  * \param R           the refresh_pattern rule that matched this entry
  * \param sf          small struct to indicate reason for stale/fresh decision
  *
  * \retval -1  If the response is fresh.
@@ -301,41 +281,41 @@
     debugs(22, 3, &quot;checking freshness of URI: &quot; &lt;&lt; uri);
 
     // age is not necessarily the age now, but the age at the given check_time
     if (check_time &gt; entry-&gt;timestamp)
         age = check_time - entry-&gt;timestamp;
 
     // FIXME: what to do when age &lt; 0 or counter overflow?
     assert(age &gt;= 0);
 
     /* We need a refresh rule. In order of preference:
      *
      *   1. the rule that matches this URI by regex
      *   2. the &quot;.&quot; rule from the config file
      *   3. the default &quot;.&quot; rule
      */
     // XXX: performance regression. c_str() reallocates
     const RefreshPattern *R = (uri != nilUri) ? refreshLimits(uri.c_str()) : refreshUncompiledPattern(&quot;.&quot;);
     if (NULL == R)
         R = &DefaultRefresh;
 
-    debugs(22, 3, &quot;Matched '&quot; &lt;&lt; R-&gt;pattern &lt;&lt; &quot; &quot; &lt;&lt;
+    debugs(22, 3, &quot;Matched '&quot; &lt;&lt; R-&gt;pattern.c_str() &lt;&lt; &quot; &quot; &lt;&lt;
            (int) R-&gt;min &lt;&lt; &quot; &quot; &lt;&lt; (int) (100.0 * R-&gt;pct) &lt;&lt; &quot;%% &quot; &lt;&lt;
            (int) R-&gt;max &lt;&lt; &quot;'&quot;);
 
     debugs(22, 3, &quot;\tage:\t&quot; &lt;&lt; age);
 
     debugs(22, 3, &quot;\tcheck_time:\t&quot; &lt;&lt; mkrfc1123(check_time));
 
     debugs(22, 3, &quot;\tentry-&gt;timestamp:\t&quot; &lt;&lt; mkrfc1123(entry-&gt;timestamp));
 
     if (request &amp;&amp; !request-&gt;flags.ignoreCc) {
         const HttpHdrCc *const cc = request-&gt;cache_control;
         if (cc &amp;&amp; cc-&gt;hasMinFresh()) {
             const int32_t minFresh=cc-&gt;minFresh();
             debugs(22, 3, &quot;\tage + min-fresh:\t&quot; &lt;&lt; age &lt;&lt; &quot; + &quot; &lt;&lt;
                    minFresh &lt;&lt; &quot; = &quot; &lt;&lt; age + minFresh);
             debugs(22, 3, &quot;\tcheck_time + min-fresh:\t&quot; &lt;&lt; check_time &lt;&lt; &quot; + &quot;
                    &lt;&lt; minFresh &lt;&lt; &quot; = &quot; &lt;&lt;
                    mkrfc1123(check_time + minFresh));
             age += minFresh;
             check_time += minFresh;
@@ -692,42 +672,42 @@
     sum += refreshCountsStatsEntry(sentry, rc, STALE_FORCED_RELOAD, &quot;Stale: request has no-cache directive&quot;);
     sum += refreshCountsStatsEntry(sentry, rc, STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE, &quot;Stale: age exceeds request max-age value&quot;);
     sum += refreshCountsStatsEntry(sentry, rc, STALE_EXPIRES, &quot;Stale: expires time reached&quot;);
     sum += refreshCountsStatsEntry(sentry, rc, STALE_MAX_RULE, &quot;Stale: refresh_pattern max age rule&quot;);
     sum += refreshCountsStatsEntry(sentry, rc, STALE_LMFACTOR_RULE, &quot;Stale: refresh_pattern last-mod factor percentage&quot;);
     sum += refreshCountsStatsEntry(sentry, rc, STALE_DEFAULT, &quot;Stale: by default&quot;);
     storeAppendPrintf(sentry, &quot;\n&quot;);
 }
 
 static void
 refreshStats(StoreEntry * sentry)
 {
     // display per-rule counts of usage and tests
     storeAppendPrintf(sentry, &quot;\nRefresh pattern usage:\n\n&quot;);
     storeAppendPrintf(sentry, &quot;  Used      \tChecks    \t%% Matches\tPattern\n&quot;);
     for (const RefreshPattern *R = Config.Refresh; R; R = R-&gt;next) {
         storeAppendPrintf(sentry, &quot;  %10&quot; PRIu64 &quot;\t%10&quot; PRIu64 &quot;\t%6.2f\t%s%s\n&quot;,
                           R-&gt;stats.matchCount,
                           R-&gt;stats.matchTests,
                           xpercent(R-&gt;stats.matchCount, R-&gt;stats.matchTests),
-                          (R-&gt;flags.icase ? &quot;-i &quot; : &quot;&quot;),
-                          R-&gt;pattern);
+                          (R-&gt;pattern.flags &amp; std::regex::icase ? &quot;-i &quot; : &quot;&quot;),
+                          R-&gt;pattern.c_str());
     }
 
     int i;
     int total = 0;
 
     /* get total usage count */
 
     for (i = 0; i &lt; rcCount; ++i)
         total += refreshCounts[i].total;
 
     /* protocol usage histogram */
     storeAppendPrintf(sentry, &quot;\nRefreshCheck calls per protocol\n\n&quot;);
 
     storeAppendPrintf(sentry, &quot;Protocol\t#Calls\t%%Calls\n&quot;);
 
     for (i = 0; i &lt; rcCount; ++i)
         storeAppendPrintf(sentry, &quot;%10s\t%6d\t%6.2f\n&quot;,
                           refreshCounts[i].proto,
                           refreshCounts[i].total,
                           xpercent(refreshCounts[i].total, total));
@@ -745,29 +725,23 @@
     Mgr::RegisterAction(&quot;refresh&quot;, &quot;Refresh Algorithm Statistics&quot;, refreshStats, 0, 1);
 }
 
 void
 refreshInit(void)
 {
     memset(refreshCounts, 0, sizeof(refreshCounts));
     refreshCounts[rcHTTP].proto = &quot;HTTP&quot;;
     refreshCounts[rcICP].proto = &quot;ICP&quot;;
 #if USE_HTCP
 
     refreshCounts[rcHTCP].proto = &quot;HTCP&quot;;
 #endif
 
     refreshCounts[rcStore].proto = &quot;On Store&quot;;
 #if USE_CACHE_DIGESTS
 
     refreshCounts[rcCDigest].proto = &quot;Cache Digests&quot;;
 #endif
 
-    memset(&amp;DefaultRefresh, '\0', sizeof(DefaultRefresh));
-    DefaultRefresh.pattern = &quot;&lt;none&gt;&quot;;
-    DefaultRefresh.min = REFRESH_DEFAULT_MIN;
-    DefaultRefresh.pct = REFRESH_DEFAULT_PCT;
-    DefaultRefresh.max = REFRESH_DEFAULT_MAX;
-
     refreshRegisterWithCacheManager();
 }
 

=== modified file 'test-suite/buildtests/layer-01-minimal.opts'
--- test-suite/buildtests/layer-01-minimal.opts	2015-01-13 07:25:36 +0000
+++ test-suite/buildtests/layer-01-minimal.opts	2015-07-27 16:55:28 +0000
@@ -21,41 +21,40 @@
 # followed by insertion of '	--disable-' and '\' strings
 #
 # 	grep -E &quot;^AC_ARG_WITH&quot; ./configure.ac | grep -o -E &quot;[0-9a-z\-]+[,]&quot; | grep -o -E &quot;[^,]+&quot; &gt;without.opts
 # followed by insertion of '	--without-' and ' \' strings
 #
 # sometimes it's just too automatic.. Following options should be just stripped
 #
 #   --without-default-user \
 #   --without-aufs-threads \
 #   --without-filedescriptors \
 #   --without-cppunit-basedir \
 #   --without-build-environment \
 #
 #
 # NP: DISTCHECK_CONFIGURE_FLAGS is a magic automake macro for the 
 #     distcheck target recursive tests beteen scripted runs.
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=&quot; \
 	--disable-build-info \
 	--disable-loadable-modules \
-	--disable-gnuregex \
 	--disable-optimizations \
 	--disable-inline \
 	--disable-debug-cbdata \
 	--disable-xmalloc-statistics \
 	--disable-async-io \
 	--disable-storeio \
 	--disable-disk-io \
 	--disable-removal-policies \
 	--disable-icmp \
 	--disable-delay-pools \
 	--disable-esi \
 	--disable-icap-client \
 	--disable-ecap \
 	--disable-useragent-log \
 	--disable-referer-log \
 	--disable-wccp \
 	--disable-wccpv2 \
 	--disable-kill-parent-hack \
 	--disable-snmp \
 	--disable-cachemgr-hostname \

=== modified file 'test-suite/buildtests/layer-02-maximus.opts'
--- test-suite/buildtests/layer-02-maximus.opts	2015-01-13 07:25:36 +0000
+++ test-suite/buildtests/layer-02-maximus.opts	2015-07-27 16:55:48 +0000
@@ -35,41 +35,40 @@
 #   --with-tags=TAGS \
 #
 #	Following features require special support from other optional packages.
 #	We can't test them automatically everywhere without detecting those
 #	optional packages first.
 #
 #   --enable-ecap \
 #   --enable-epoll \
 #   --enable-kqueue \
 #   --enable-win32-service \
 #   --with-valgrind-debug \
 #
 #   --enable-cpu-profiling \  Requires CPU support.
 #
 #
 # NP: DISTCHECK_CONFIGURE_FLAGS is a magic automake macro for the 
 #     distcheck target recursive tests beteen scripted runs.
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=&quot; \
 	--enable-loadable-modules \
-	--enable-gnuregex \
 	--enable-optimizations \
 	--enable-inline \
 	--enable-debug-cbdata \
 	--enable-xmalloc-statistics \
 	--enable-async-io \
 	--enable-storeio \
 	--enable-disk-io \
 	--enable-removal-policies \
 	--enable-icmp \
 	--enable-delay-pools \
 	--enable-icap-client \
 	--enable-useragent-log \
 	--enable-referer-log \
 	--enable-wccp \
 	--enable-wccpv2 \
 	--enable-kill-parent-hack \
 	--enable-snmp \
 	--enable-cachemgr-hostname \
 	--enable-eui \
 	--enable-htcp \

=== modified file 'test-suite/buildtests/layer-04-noauth-everything.opts'
--- test-suite/buildtests/layer-04-noauth-everything.opts	2015-01-13 07:25:36 +0000
+++ test-suite/buildtests/layer-04-noauth-everything.opts	2015-07-27 16:55:51 +0000
@@ -36,41 +36,40 @@
 #   --with-tags=TAGS \
 #
 #	Following features require special support from other optional packages.
 #	We can't test them automatically everywhere without detecting those
 #	optional packages first.
 #
 #   --enable-ecap \
 #   --enable-epoll \
 #   --enable-kqueue \
 #   --enable-win32-service \
 #   --with-valgrind-debug \
 #
 #   --enable-cpu-profiling \  Requires CPU support.
 #
 #
 # NP: DISTCHECK_CONFIGURE_FLAGS is a magic automake macro for the 
 #     distcheck target recursive tests beteen scripted runs.
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=&quot; \
 	--enable-loadable-modules \
-	--enable-gnuregex \
 	--enable-optimizations \
 	--enable-inline \
 	--enable-debug-cbdata \
 	--enable-xmalloc-statistics \
 	--enable-async-io \
 	--enable-storeio \
 	--enable-disk-io \
 	--enable-removal-policies \
 	--enable-icmp \
 	--enable-delay-pools \
 	--enable-icap-client \
 	--enable-useragent-log \
 	--enable-referer-log \
 	--enable-wccp \
 	--enable-wccpv2 \
 	--enable-kill-parent-hack \
 	--enable-snmp \
 	--enable-cachemgr-hostname \
 	--enable-eui \
 	--enable-htcp \

=== added file 'test-suite/squidconf/regex'
--- test-suite/squidconf/regex	1970-01-01 00:00:00 +0000
+++ test-suite/squidconf/regex	2015-07-27 13:20:28 +0000
@@ -0,0 +1,24 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+#
+# This file contains the list of regular expression syntaxes used
+# it covers various uses of:
+#	unoptimized multi-line patterns
+#
+# Some other regression related patterns are tested in regressions-3.4.0.1
+#
+
+acl G dstdom_regex \.g...l\.com$
+acl G dstdom_regex \.g...le\.com$
+
+acl B browser ^Mozilla
+acl B browser ^Java/[0-9]+(\.[0-9]+)?
+
+
+# invalid pattern - this whold abort
+acl foo browser *

=== modified file 'tools/purge/conffile.cc'
--- tools/purge/conffile.cc	2015-01-13 07:25:36 +0000
+++ tools/purge/conffile.cc	2015-07-27 19:36:57 +0000
@@ -30,158 +30,120 @@
 //
 // IN NO EVENT SHALL THE LEHRGEBIET RECHNERNETZE UND VERTEILTE SYSTEME OR
 // THE UNIVERSITY OF HANNOVER BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 // INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES
 // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT
 // ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY,
 // ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 // SOFTWARE.
 //
 // Revision 1.1  2000/09/21 09:44:53  voeckler
 // Initial revision
 //
 
 #include &quot;squid.h&quot;
 #include &quot;conffile.hh&quot;
 
 #include &lt;cerrno&gt;
 #include &lt;cstdlib&gt;
 #include &lt;cstring&gt;
 #include &lt;fstream&gt;
+#include &lt;regex&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;memory.h&gt;
 
 int
 readConfigFile( CacheDirVector&amp; cachedir, const char* fn, FILE* debug )
 // purpose: read squid.conf file and extract cache_dir entries
 // paramtr: cachedir (OUT): vector with an entry for each cache_dir found
 //          fn (IN): file name of squid.conf to use
 // returns: number of entries, or negative to warn of errors
 {
-    static const char* expression =
-        &quot;^[ \t]*cache_dir([ \t]+([[:alpha:]]+))?[ \t]+([[:graph:]]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)&quot;;
-
     // try to open file
     if ( debug ) fprintf( debug, &quot;# trying to open %s\n&quot;, fn ? fn : &quot;(null)&quot; );
     std::ifstream cfgin(fn);
     if (!cfgin) {
         fprintf( stderr, &quot;fopen %s: %s\n&quot;, fn, strerror(errno) );
         return -1;
     }
 
     // prepare regular expression for matching
+    static const char * expression = &quot;^[ \t]*cache_dir([ \t]+([[:alpha:]]+))?[ \t]+([[:graph:]]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)&quot;;
     if ( debug ) fprintf( debug, &quot;# trying to compile \&quot;%s\&quot;\n&quot;, expression );
-    regex_t rexp;
-    int result = regcomp( &amp;rexp, expression, REG_EXTENDED );
-    if ( result != 0 ) {
-        char buffer[256];
-        regerror( result, &amp;rexp, buffer, sizeof(buffer) );
-        fprintf( stderr, &quot;regular expression \&quot;%s\&quot;: %s\n&quot;, expression, buffer );
-        return -1;
-    }
+
+    static const std::regex rexp(expression, std::regex::extended);
 
     // read line by line
     if ( debug ) fputs( &quot;# trying to read lines\n&quot;, debug );
 
-    regmatch_t subs[8];
+    std::smatch subs; // set of std::string so we can use ==
     char *s, line[1024];
     CacheDir cd;
     while ( cfgin.getline( line, sizeof(line)) ) {
         // FIXME: overly long lines
 
         // terminate line at start of comment
         if ( (s = (char*) memchr( line, '#', sizeof(line) )) ) *s = '\0';
 
         // quick skip
         if ( *line == '\0' || *line == '\n' ) continue;
 
         // test line
-        if ( (result=regexec( &amp;rexp, line, 7, subs, 0 )) != 0 ) {
-            // error or no match
-            if ( result != REG_NOMATCH ) {
-                char buffer[256];
-                regerror( result, &amp;rexp, buffer, sizeof(buffer) );
-                fprintf( stderr, &quot;while matching \&quot;%s\&quot; against %s%s\n&quot;,
-                         expression, line, buffer );
-                regfree(&amp;rexp);
-                cfgin.close();
-                return -1;
-            }
+        std::string tmpLine(line);
+        if (!std::regex_search(tmpLine, subs, rexp))
+            continue;
+
+        // match, please record
+        memset( &amp;cd, 0, sizeof(cd) );
+        if ( debug ) fprintf( debug, &quot;# match '%s' on line %s&quot;, subs[0].str().c_str(), line);
+
+        // extract information. If 6th parenthesis is filled, this is
+        // a new squid with disk types, otherwise it is an older version
+        int offset = 2;
+        if (subs[6].str().empty()) {
+            // old version, disk type at position 2 is always UFS
+            cd.type = CacheDir::CDT_UFS;
         } else {
-            // match, please record
-            memset( &amp;cd, 0, sizeof(cd) );
-            if ( debug ) fprintf( debug, &quot;# match from %d-%d on line %s&quot;,
-                                      (int)subs[0].rm_so, (int)subs[0].rm_eo,
-                                      line );
-
-            // terminate line after matched expression
-            line[ subs[0].rm_eo ] = '\0';
-
-            // extract information. If 6th parenthesis is filled, this is
-            // a new squid with disk types, otherwise it is an older version
-            int offset = 2;
-            if ( subs[6].rm_so == -1 ) {
-                // old version, disk type at position 2 is always UFS
+            // new version, disk type at position 2
+            if ( debug ) fprintf( debug, &quot;# match '%s' in \&quot;%s\&quot;\n&quot;, subs[offset].str().c_str(), subs[0].str().c_str());
+            static const std::string ufsDir(&quot;ufs&quot;,3);
+            static const std::string aufsDir(&quot;aufs&quot;,4);
+            static const std::string asyncUfsDir(&quot;asyncufs&quot;,8);
+            static const std::string diskdDir(&quot;diskd&quot;,5);
+            if (subs[offset] == ufsDir)
                 cd.type = CacheDir::CDT_UFS;
-            } else {
-                // new version, disk type at position 2
-                line[ subs[offset].rm_eo ] = '\0';
-                if ( debug ) fprintf( debug, &quot;# match from %d-%d on \&quot;%s\&quot;\n&quot;,
-                                          (int)subs[offset].rm_so,
-                                          (int)subs[offset].rm_eo,
-                                          line+subs[offset].rm_so );
-                if ( strcmp( line + subs[offset].rm_so, &quot;ufs&quot; ) == 0 )
-                    cd.type = CacheDir::CDT_UFS;
-                else if ( strcmp( line + subs[offset].rm_so, &quot;asyncufs&quot; ) == 0 )
-                    cd.type = CacheDir::CDT_AUFS;
-                else if ( strcmp( line + subs[offset].rm_so, &quot;diskd&quot; ) == 0 )
-                    cd.type = CacheDir::CDT_DISKD;
-                else
-                    cd.type = CacheDir::CDT_OTHER;
-                ++offset;
-            }
-
-            // extract base directory
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, &quot;# match from %d-%d on \&quot;%s\&quot;\n&quot;,
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.base = xstrdup( line+subs[offset].rm_so );
-            ++offset;
-
-            // extract size information
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, &quot;# match from %d-%d on \&quot;%s\&quot;\n&quot;,
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.size = strtoul( line+subs[offset].rm_so, 0, 10 );
+            else if (subs[offset] == aufsDir || subs[offset] == asyncUfsDir)
+                cd.type = CacheDir::CDT_AUFS;
+            else if (subs[offset] == diskdDir)
+                cd.type = CacheDir::CDT_DISKD;
+            else
+                cd.type = CacheDir::CDT_OTHER;
             ++offset;
+        }
 
-            // extract 1st level directories
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, &quot;# match from %d-%d on \&quot;%s\&quot;\n&quot;,
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.level[0] = strtoul( line+subs[offset].rm_so, 0, 10 );
-            ++offset;
+        // extract base directory
+        if ( debug ) fprintf( debug, &quot;# match '%s' in \&quot;%s\&quot;\n&quot;, subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.base = xstrdup(subs[offset].str().c_str());
+        ++offset;
+
+        // extract size information
+        if ( debug ) fprintf( debug, &quot;# match '%s' in \&quot;%s\&quot;\n&quot;, subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.size = strtoul(subs[offset].str().c_str(), 0, 10);
+        ++offset;
+
+        // extract 1st level directories
+        if ( debug ) fprintf( debug, &quot;# match '%s' in \&quot;%s\&quot;\n&quot;, subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.level[0] = strtoul(subs[offset].str().c_str(), 0, 10);
+        ++offset;
+
+        // extract 2nd level directories
+        if ( debug ) fprintf( debug, &quot;# match '%s' in \&quot;%s\&quot;\n&quot;, subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.level[1] = strtoul(subs[offset].str().c_str(), 0, 10);
+        ++offset;
 
-            // extract 2nd level directories
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, &quot;# match from %d-%d on \&quot;%s\&quot;\n&quot;,
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.level[1] = strtoul( line+subs[offset].rm_so, 0, 10 );
-            ++offset;
-
-            cachedir.push_back( cd );
-        }
+        cachedir.push_back( cd );
     }
 
     cfgin.close();
-    regfree(&amp;rexp);
     return cachedir.size();
 }
 

=== modified file 'tools/purge/purge.cc'
--- tools/purge/purge.cc	2015-01-13 07:25:36 +0000
+++ tools/purge/purge.cc	2015-07-27 20:03:46 +0000
@@ -91,40 +91,41 @@
 // added a few assertions, changed policy to enforce the definition of at
 // least one regular expression, and catch a few signals.
 //
 // Revision 1.2  1999/01/15 23:06:28  voeckler
 // downgraded to simple C strings...
 //
 // Revision 1.1  1999/01/14 12:05:32  voeckler
 // Initial revision
 //
 //
 #include &quot;squid.h&quot;
 #include &quot;util.h&quot;
 
 #include &lt;cerrno&gt;
 #include &lt;climits&gt;
 #include &lt;csignal&gt;
 #include &lt;cstdarg&gt;
 #include &lt;cstdlib&gt;
 #include &lt;cstring&gt;
 #include &lt;dirent.h&gt;
+#include &lt;regex&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;sys/wait.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;unistd.h&gt;
 
 #if HAVE_SIGINFO_H
 #include &lt;siginfo.h&gt;
 #endif
 
 #include &lt;netinet/in.h&gt;
 #include &lt;netinet/tcp.h&gt;
 #include &lt;arpa/inet.h&gt;
 #include &lt;netdb.h&gt;
 
 #include &quot;conffile.hh&quot;
 #include &quot;convert.hh&quot;
 #include &quot;copyout.hh&quot;
 #include &quot;signal.hh&quot;
 #include &quot;socket.hh&quot;
 #include &quot;squid-tlv.hh&quot;
@@ -135,83 +136,62 @@
 
 #ifndef DEFAULTPORT
 #define DEFAULTPORT 3128
 #endif // DEFAULTPORT
 
 volatile sig_atomic_t term_flag = 0; // 'terminate' is a gcc 2.8.x internal...
 char*  linebuffer = 0;
 size_t buffersize = 128*1024;
 static char* copydir = 0;
 static uint32_t debugFlag = 0;
 static unsigned purgeMode = 0;
 static bool iamalive = false;
 static bool reminder = false;
 static bool verbose  = false;
 static bool envelope = false;
 static bool no_fork  = false;
 static const char* programname = 0;
 
 // ----------------------------------------------------------------------
 
-struct REList {
-    REList( const char* what, bool doCase );
-    ~REList();
-    bool match( const char* check ) const;
-
-    REList*     next;
-    const char* data;
-    regex_t     rexp;
-};
-
-REList::REList( const char* what, bool doCase )
-    :next(0),data(xstrdup(what))
+class REList
 {
-    int result = regcomp( &amp;rexp, what,
-                          REG_EXTENDED | REG_NOSUB | (doCase ? 0 : REG_ICASE) );
-    if ( result != 0 ) {
-        char buffer[256];
-        regerror( result, &amp;rexp, buffer, 256 );
-        fprintf( stderr, &quot;unable to compile re \&quot;%s\&quot;: %s\n&quot;, what, buffer );
-        exit(1);
+public:
+    REList( const char* what, bool doCase ) :
+        next(nullptr),
+        data(xstrdup(what)),
+        rexp(data, std::regex::extended | std::regex::nosubs |
+             (doCase ? std::regex_constants::syntax_option_type() : std::regex::icase) )
+    {}
+
+    ~REList() {
+        if (next) delete next;
+        xfree(data);
     }
-}
 
-REList::~REList()
-{
-    if ( next ) delete next;
-    if ( data ) xfree((void*) data);
-    regfree(&amp;rexp);
-}
+    bool match(const char *check) const {return std::regex_match(check, rexp);}
 
-bool
-REList::match( const char* check ) const
-{
-    int result = regexec( &amp;rexp, check, 0, 0, 0 );
-    if ( result != 0 &amp;&amp; result != REG_NOMATCH ) {
-        char buffer[256];
-        regerror( result, &amp;rexp, buffer, 256 );
-        fprintf( stderr, &quot;unable to execute re \&quot;%s\&quot;\n+ on line \&quot;%s\&quot;: %s\n&quot;,
-                 data, check, buffer );
-        exit(1);
-    }
-    return ( result == 0 );
-}
+    REList*     next;
+    const char* data;
+private:
+    std::regex  rexp;
+};
 
 // ----------------------------------------------------------------------
 
 char*
 concat( const char* start, ... )
 // purpose: concatinate an arbitrary number of C strings.
 // paramtr: start (IN): first C string
 //          ... (IN): further C strings, terminated with a NULL pointer
 // returns: memory allocated via new(), containing the concatinated string.
 {
     va_list ap;
     const char* s;
 
     // first run: determine size
     unsigned size = strlen(start)+1;
     va_start( ap, start );
     while ( (s=va_arg(ap,const char*)) != NULL )
         size += strlen(s);
     va_end(ap);
 
@@ -433,46 +413,46 @@
                 if (size+offset &lt; size) {
                     fputs(&quot;WARNING: file corruption detected. 32-bit overflow in size field.\n&quot;, stderr);
                     break;
                 }
                 if (size+offset &gt; readLen) {
                     fputs( &quot;WARNING: Partial meta data loaded.\n&quot;, stderr );
                     break;
                 }
                 meta.append( SquidMetaType(*(linebuffer+offset)),
                              size, linebuffer+offset+addon );
                 offset += ( addon + size );
             }
 
             // Now extract the key URL from the meta data.
             const SquidTLV* urlmeta = meta.search( STORE_META_URL );
             if ( urlmeta ) {
                 // found URL in meta data. Try to process the URL
                 if ( list == 0 )
                     flag = action( fd, datastart, fn, (char*) urlmeta-&gt;data, meta );
                 else {
-                    REList* head = (REList*) list; // YUCK!
-                    while ( head != 0 ) {
+                    const REList * head = list;
+                    while (head) {
                         if ( head-&gt;match( (char*) urlmeta-&gt;data ) ) break;
                         head = head-&gt;next;
                     }
-                    if ( head != 0 )
+                    if (head)
                         flag = action( fd, datastart, fn, (char*) urlmeta-&gt;data, meta );
                     else flag = true;
                 }
             }
 
             // &quot;meta&quot; will be deleted when exiting from this block
         } else {
             // weird file, FIXME: stat() it!
             struct stat st;
             long size = ( fstat(fd,&amp;st) == -1 ? -1 : st.st_size );
             if ( ::verbose ) flag = ( log_extended( fn, -1, size, 0 ) &gt;= 0 );
             else flag = ( log_output( fn, -1, size, &quot;strange file&quot; ) &gt;= 0 );
 
             if ( (::purgeMode &amp; 0x04) ) {
                 reminder = true;
                 if ( unlink(fn) == -1 )
                     // error while unlinking file, this may happen due to the cache
                     // unlinking a file while it is in the readdir() cache of purge.
                     fprintf( stderr, &quot;WARNING: unable to unlink %s: %s\n&quot;,
                              fn, strerror(errno) );
@@ -623,115 +603,126 @@
 parseCommandline( int argc, char* argv[], REList*&amp; head,
                   char*&amp; conffile, char*&amp; copyDirPath,
                   struct in_addr&amp; serverHostIp, unsigned short&amp; serverHostPort )
 // paramtr: argc: see ::main().
 //          argv: see ::main().
 // returns: Does terminate the program on errors!
 // purpose: suck in any commandline options, and set the global vars.
 {
     int option, port, showme = 0;
     char* ptr, *colon;
     FILE* rfile;
 
     // program basename
     if ( (ptr = strrchr(argv[0],'/')) == NULL )
         ptr=argv[0];
     else
         ++ptr;
     ::programname = ptr;
 
     // extract commandline parameters
-    REList* tail = head = 0;
+    REList* tail = head = nullptr;
     opterr = 0;
     while ( (option = getopt( argc, argv, &quot;ac:C:d:E:e:F:f:Hnp:P:sv&quot; )) != -1 ) {
         switch ( option ) {
         case 'a':
             ::iamalive = ! ::iamalive;
             break;
         case 'C':
             if ( optarg &amp;&amp; *optarg ) {
                 if ( copyDirPath ) xfree( (void*) copyDirPath );
                 copyDirPath = xstrdup(optarg);
                 assert(copyDirPath);
             }
             break;
         case 'c':
             if ( !optarg || !*optarg ) {
                 fprintf( stderr, &quot;%c requires a regex pattern argument!\n&quot;, option );
                 exit(1);
             }
             if ( *conffile ) xfree((void*) conffile);
             conffile = xstrdup(optarg);
             assert(conffile);
             break;
 
         case 'd':
             if ( !optarg || !*optarg ) {
                 fprintf( stderr, &quot;%c expects a mask parameter. Debug disabled.\n&quot;, option );
                 ::debugFlag = 0;
             } else
                 ::debugFlag = (strtoul(optarg, NULL, 0) &amp; 0xFFFFFFFF);
             break;
 
         case 'E':
         case 'e':
             if ( !optarg || !*optarg ) {
                 fprintf( stderr, &quot;%c requires a regex pattern argument!\n&quot;, option );
                 exit(1);
             }
-            if ( head == 0 )
-                tail = head = new REList( optarg, option=='E' );
-            else {
-                tail-&gt;next = new REList( optarg, option=='E' );
-                tail = tail-&gt;next;
+            try { // std::regex constructor throws on pattern errors
+                if (!head)
+                    tail = head = new REList( optarg, option=='E' );
+                else {
+                    tail-&gt;next = new REList( optarg, option=='E' );
+                    tail = tail-&gt;next;
+                }
+            } catch (std::regex_error &amp;e) {
+                fprintf(stderr, &quot;%c contains invalid regular expression: %s\n&quot;, option, optarg);
+                exit(1);
             }
             break;
 
         case 'f':
             if ( !optarg || !*optarg ) {
                 fprintf( stderr, &quot;%c requires a filename argument!\n&quot;, option );
                 exit(1);
             }
             if ( (rfile = fopen( optarg, &quot;r&quot; )) != NULL ) {
                 unsigned long lineno = 0;
 #define LINESIZE 512
                 char line[LINESIZE];
                 while ( fgets( line, LINESIZE, rfile ) != NULL ) {
                     ++lineno;
                     int len = strlen(line)-1;
                     if ( len+2 &gt;= LINESIZE ) {
                         fprintf( stderr, &quot;%s:%lu: line too long, sorry.\n&quot;,
                                  optarg, lineno );
                         exit(1);
                     }
 
                     // remove trailing line breaks
                     while ( len &gt; 0 &amp;&amp; ( line[len] == '\n' || line[len] == '\r' ) ) {
                         line[len] = '\0';
                         --len;
                     }
 
-                    // insert into list of expressions
-                    if ( head == 0 ) tail = head = new REList(line,option=='F');
-                    else {
-                        tail-&gt;next = new REList(line,option=='F');
-                        tail = tail-&gt;next;
+                    try { // std::regex constructor throws on pattern errors
+                        // insert into list of expressions
+                        if (!head)
+                            tail = head = new REList(line,option=='F');
+                        else {
+                            tail-&gt;next = new REList(line,option=='F');
+                            tail = tail-&gt;next;
+                        }
+                    } catch (std::regex_error &amp;e) {
+                        fprintf(stderr, &quot;%s:%lu: invalid regular expression\n&quot;, optarg, lineno);
+                        exit(1);
                     }
                 }
                 fclose(rfile);
             } else
                 fprintf( stderr, &quot;unable to open %s: %s\n&quot;, optarg, strerror(errno));
             break;
 
         case 'H':
             ::envelope = ! ::envelope;
             break;
         case 'n':
             ::no_fork = ! ::no_fork;
             break;
         case 'p':
             if ( !optarg || !*optarg ) {
                 fprintf( stderr, &quot;%c requires a port argument!\n&quot;, option );
                 exit(1);
             }
             colon = strchr( optarg, ':' );
             if ( colon == 0 ) {
@@ -872,41 +863,41 @@
 // paramtr: fp (IO): file pointer which to put into line buffer mode
 //          fn (IN): name of file to print in case of error
 // returns: 0 is ok, -1 to indicate an error
 // warning: error messages will already be printed
 {
     if ( setvbuf( fp, 0, _IOLBF, 0 ) == 0 ) {
         // ok
         return 0;
     } else {
         // error
         fprintf( stderr, &quot;unable to make \&quot;%s\&quot; line buffered: %s\n&quot;,
                  fn ? fn : &quot;&quot;, strerror(errno) );
         return -1;
     }
 }
 
 int
 main( int argc, char* argv[] )
 {
     // setup variables
-    REList* list = 0;
+    REList* list = nullptr;
     char* conffile = xstrdup( DEFAULT_SQUID_CONF );
     serverPort = htons(DEFAULTPORT);
     if ( convertHostname(DEFAULTHOST,serverHost) == -1 ) {
         fprintf( stderr, &quot;unable to resolve host %s!\n&quot;, DEFAULTHOST );
         return 1;
     }
 
     // setup line buffer
     ::linebuffer = new char[ ::buffersize ];
     assert( ::linebuffer != 0 );
 
     // parse commandline
     puts( &quot;### Use at your own risk! No guarantees whatsoever. You were warned. ###&quot;);
     parseCommandline( argc, argv, list, conffile, ::copydir,
                       serverHost, serverPort );
 
     // prepare execution
     if ( atexit( exiter ) != 0 ||
             Signal( SIGTERM, handler, true ) == SIG_ERR ||
             Signal( SIGINT, handler, true ) == SIG_ERR ||

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002872.html">[squid-dev] [PATCH] implement std::hash&lt;SBuf&gt;
</A></li>
	<LI>Next message: <A HREF="002876.html">[squid-dev] [PATCH] remove old GnuRegex third-party code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2875">[ date ]</a>
              <a href="thread.html#2875">[ thread ]</a>
              <a href="subject.html#2875">[ subject ]</a>
              <a href="author.html#2875">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
