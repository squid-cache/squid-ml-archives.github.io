<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] Refactor HttpHeader
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Refactor%20HttpHeader&In-Reply-To=%3CCA%2BY8hcO0a6V9vgVs20cASkDWgZoAZaN77yMr6BAcTq6MeK4nsQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002880.html">
   <LINK REL="Next"  HREF="002882.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] Refactor HttpHeader</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Refactor%20HttpHeader&In-Reply-To=%3CCA%2BY8hcO0a6V9vgVs20cASkDWgZoAZaN77yMr6BAcTq6MeK4nsQ%40mail.gmail.com%3E"
       TITLE="[squid-dev] [RFC] Refactor HttpHeader">gkinkie at gmail.com
       </A><BR>
    <I>Thu Jul 30 07:44:32 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002880.html">[squid-dev] [RFC] Refactor HttpHeader
</A></li>
        <LI>Next message: <A HREF="002882.html">[squid-dev] [RFC] Refactor HttpHeader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2881">[ date ]</a>
              <a href="thread.html#2881">[ thread ]</a>
              <a href="subject.html#2881">[ subject ]</a>
              <a href="author.html#2881">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Jul 29, 2015 at 11:31 PM, Amos Jeffries &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid3 at treenet.co.nz</A>&gt;
wrote:

&gt;<i> On 30/07/2015 9:10 a.m., Kinkie wrote:
</I>&gt;<i> &gt; Hi all,
</I>&gt;<i> &gt;    I'm starting to work on refactoring HttpHeader to use LookupTable, and
</I>&gt;<i> &gt; boy that code is a mess..
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Since it's going to take significant effort, I'd like to get feedback on
</I>&gt;<i> &gt; the changes I'd like to implement, so not to end in long discussions
</I>&gt;<i> later.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Current data structures:
</I>&gt;<i> &gt; HeadersAttrs: static declaration of header name, header ID, header type
</I>&gt;<i> &gt; (string/int/etc). Must be sorted by numeric value of ID
</I>&gt;<i> &gt; Headers: built at initialization time from HeadersAttrs, it's an array of
</I>&gt;<i> &gt; (name, id, type, stats) structs
</I>&gt;<i> &gt; ListHeadersArr, GeneralHeadersArr, EntityHeadersArr, RequestHeadersArr,
</I>&gt;<i> &gt; ReplyHeadersArr, etc: lists of headers ID (possibly overlapping) which
</I>&gt;<i> are
</I>&gt;<i> &gt; used to generate..
</I>&gt;<i> &gt; ListHeadersMask, GeneralHeadersArr, EntityHeadersArr etc: bitmaps used
</I>&gt;<i> &gt; (only) by HttpHeaderStats to assemble different stats sets
</I>&gt;<i>
</I>&gt;<i> I seem to recall a hop-by-hop headers lists as well and the
</I>&gt;<i> request/reply lists being used by message filtering logic to strip away
</I>&gt;<i> invalid and hop-by-hop headers ?
</I>&gt;<i>
</I>
That was a partial list. But yes, we need a quick way to understand some
spec characteristics of any given header, defined by ID. Current approach
is very effective at packing the information but very low-level, but very
low-level and probably not very much effective.


&gt;<i> &gt; I would like to turn these into:
</I>&gt;<i> &gt; headerTable: LookupTable&lt;&gt;::Record mapping header name to header ID, used
</I>&gt;<i> &gt; to generate ...
</I>&gt;<i> &gt; headerLookupTable: a fast lookup table of header names to ids
</I>&gt;<i> &gt; headerStatsTable: a std::vector&lt;HttpHeaderFieldStat&gt; indexed by header ID
</I>&gt;<i> &gt; to collect the statistics currently in Headers[id].stats.
</I>&gt;<i> &gt; headerDescription: a std::vector keyed by header ID containing header
</I>&gt;<i> type
</I>&gt;<i> &gt; (currently in Headers[id].type), possibly header name (if useful), a
</I>&gt;<i> &gt; bitfield noting if HTTP_HDR{LIST,GENERAL,REQUEST,REPLY,...}.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; There are some possible optimizations, but at a minimum this should help
</I>&gt;<i> &gt; keep information more organized while introducing no performance
</I>&gt;<i> &gt; regressions.
</I>&gt;<i> &gt; What do you think?
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> In my brief look the other day I thought a small struct {ID, type, group
</I>&gt;<i> bitmask} could be used as the EnumType on LookupTable.
</I>&gt;<i>
</I>
I don't like the idea, as it makes the header name the primary key. We want
the primary key to be header ID, and header name just an index. It really
is two different users: 1. given a header name, get the ID; 2. given an ID,
get the header's characteristics.

We can do it by changing LookupType to be parametric on Record

template &lt;typename EnumType&gt;
typedef struct LookupTableRecord
{
   const char *name;
   EnumType id;
}

template&lt;typename Enumtype, typename RecordType =
LookupTableRecord&lt;EnumType&gt; &gt;
class LookupTable
{
   //...
}

This would make it so that someone could define a custom Record type, and
as long as that record type matches the signature of LookupTableRecord,
LookupTable won't care.

This also has the advantate of not needing to fill in different data
structures from the static initializer table. As long as the id of each row
in the initializer table is equal to the index of that row (which is an
already-present requirement), then the initializer table will carry all the
read-only information we need.

Plan #2: change the LookupTable API to allow filling it in from the
outside, and initialize it from the module init code (just like now). This
way we can have a single big table with all the relevant information and
fill in different data structures during the initialization loop.


&gt;<i> LookupTable really only needs a POD type that can be copied cheaply for
</I>&gt;<i> its stored type. Enum / int is the simplest of those but not mandatory.
</I>&gt;<i>
</I>&gt;<i> If that works then you can collapse headerLookupTable and
</I>&gt;<i> headerDescription into one list that efficiently looks up all data for
</I>&gt;<i> the header. Getting rid of the multiple sub-list type arrays.
</I>&gt;<i>
</I>

The proposed change to LookupTable seems more elegant to me and is tested
working; what do you think?

-- 
    Kinkie
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150730/0840aba0/attachment.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20150730/0840aba0/attachment.html</A>&gt;
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002880.html">[squid-dev] [RFC] Refactor HttpHeader
</A></li>
	<LI>Next message: <A HREF="002882.html">[squid-dev] [RFC] Refactor HttpHeader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2881">[ date ]</a>
              <a href="thread.html#2881">[ thread ]</a>
              <a href="subject.html#2881">[ subject ]</a>
              <a href="author.html#2881">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
