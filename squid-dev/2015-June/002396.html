<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Parser-NG: Transfer-Encoding:chunked Parser
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Parser-NG%3A%20Transfer-Encoding%3Achunked%20Parser&In-Reply-To=%3C556CE8EF.1050604%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   
   <LINK REL="Next"  HREF="002415.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Parser-NG: Transfer-Encoding:chunked Parser</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Parser-NG%3A%20Transfer-Encoding%3Achunked%20Parser&In-Reply-To=%3C556CE8EF.1050604%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Parser-NG: Transfer-Encoding:chunked Parser">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Jun  1 23:21:19 UTC 2015</I>
    <P><UL>
        
        <LI>Next message: <A HREF="002415.html">[squid-dev] [PATCH] Parser-NG: Transfer-Encoding:chunked Parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2396">[ date ]</a>
              <a href="thread.html#2396">[ thread ]</a>
              <a href="subject.html#2396">[ subject ]</a>
              <a href="author.html#2396">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Remove several performance regressions incurred in earlier Parser-NG
updates by refactoring the class ChunkedCodingParser to a class
Http1::TeChunkedParser which parses an SBuf I/O buffer for chunked
encoding data and (for now) copies the chunk payloads into a MemBuf buffer.

The new class is inherited from Http1::Parser and presents the same API.
Chunk Trailers are now available via the Parser API mimeHeader() method
- although none of the rest of Squid makes use of that data yet. It
implements parsing using a ::Parser::Tokenizer for (nearly) compliant
protocol tokenization. With enumerated states instead of a dynamic
function-pointer chain.


Measurements:
 Co-Advisor shows no compliance change.
 Polygraph shows approx 1% speed improvement over trunk.

PS. earlier bugs being investigated turned out to be inherited from
trunk and are now fixed there already.

Amos
-------------- next part --------------
=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-05-26 09:18:13 +0000
+++ src/Makefile.am	2015-06-01 06:21:35 +0000
@@ -274,42 +274,40 @@
 	AccessLogEntry.h \
 	AsyncEngine.cc \
 	AsyncEngine.h \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	cache_manager.cc \
 	NeighborTypeDomainList.h \
 	CachePeer.cc \
 	CachePeer.h \
 	CacheManager.h \
 	carp.h \
 	carp.cc \
 	cbdata.cc \
 	cbdata.h \
-	ChunkedCodingParser.cc \
-	ChunkedCodingParser.h \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side.h \
 	client_side_reply.cc \
 	client_side_reply.h \
 	client_side_request.cc \
 	client_side_request.h \
 	ClientInfo.h \
 	BodyPipe.cc \
 	BodyPipe.h \
 	ClientInfo.h \
 	ClientRequestContext.h \
 	clientStream.cc \
 	clientStream.h \
 	clientStreamForward.h \
 	CollapsedForwarding.cc \
 	CollapsedForwarding.h \
 	CompletionDispatcher.cc \
@@ -1385,41 +1383,40 @@
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
 	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
@@ -1815,41 +1812,40 @@
 	$(SQUID_CPPUNIT_LIBS)
 tests_testDns_LDFLAGS= $(LIBADD_DL)
 
 tests_testEvent_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	cache_manager.cc \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
@@ -2061,41 +2057,40 @@
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests of the EventLoop module.
 tests_testEventLoop_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
@@ -2305,41 +2300,40 @@
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_test_http_range_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	cache_manager.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	$(DISKIO_SOURCE) \
 	disk.h \
 	disk.cc \
@@ -2611,41 +2605,40 @@
 	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	debug.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
@@ -3418,41 +3411,40 @@
 
 ## Tests of the URL module.
 ## TODO: Trim this down once the insanity is over.
 tests_testURL_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
-	ChunkedCodingParser.cc \
 	client_db.h \
 	client_db.cc \
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	DiskIO/ReadRequest.cc \
 	DiskIO/WriteRequest.cc \

=== modified file 'src/adaptation/icap/ModXact.cc'
--- src/adaptation/icap/ModXact.cc	2015-04-27 09:52:02 +0000
+++ src/adaptation/icap/ModXact.cc	2015-06-01 19:48:35 +0000
@@ -5,44 +5,44 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 93    ICAP (RFC 3507) Client */
 
 #include &quot;squid.h&quot;
 #include &quot;AccessLogEntry.h&quot;
 #include &quot;adaptation/Answer.h&quot;
 #include &quot;adaptation/History.h&quot;
 #include &quot;adaptation/icap/Client.h&quot;
 #include &quot;adaptation/icap/Config.h&quot;
 #include &quot;adaptation/icap/History.h&quot;
 #include &quot;adaptation/icap/Launcher.h&quot;
 #include &quot;adaptation/icap/ModXact.h&quot;
 #include &quot;adaptation/icap/ServiceRep.h&quot;
 #include &quot;adaptation/Initiator.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;base64.h&quot;
-#include &quot;ChunkedCodingParser.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;err_detail_type.h&quot;
+#include &quot;http/one/TeChunkedParser.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;HttpMsg.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;URL.h&quot;
 
 // flow and terminology:
 //     HTTP| --&gt; receive --&gt; encode --&gt; write --&gt; |network
 //     end | &lt;-- send    &lt;-- parse  &lt;-- read  &lt;-- |end
 
 // TODO: replace gotEncapsulated() with something faster; we call it often
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ModXact);
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ModXactLauncher);
 
 static const size_t TheBackupLimit = BodyPipe::MaxCapacity;
 
 Adaptation::Icap::ModXact::State::State()
 {
@@ -1087,68 +1087,62 @@
     if (!parsed) { // need more data
         debugs(93, 5, HERE &lt;&lt; &quot;parse failed, need more data, return false&quot;);
         head-&gt;reset();
         return false;
     }
 
     if (HttpRequest *r = dynamic_cast&lt;HttpRequest*&gt;(head))
         urlCanonical(r); // parse does not set HttpRequest::canonical
 
     debugs(93, 5, HERE &lt;&lt; &quot;parse success, consume &quot; &lt;&lt; head-&gt;hdr_sz &lt;&lt; &quot; bytes, return true&quot;);
     readBuf.consume(head-&gt;hdr_sz);
     return true;
 }
 
 void Adaptation::Icap::ModXact::decideOnParsingBody()
 {
     if (gotEncapsulated(&quot;res-body&quot;) || gotEncapsulated(&quot;req-body&quot;)) {
         debugs(93, 5, HERE &lt;&lt; &quot;expecting a body&quot;);
         state.parsing = State::psBody;
         replyHttpBodySize = 0;
-        bodyParser = new ChunkedCodingParser;
+        bodyParser = new Http1::TeChunkedParser;
         makeAdaptedBodyPipe(&quot;adapted response from the ICAP server&quot;);
         Must(state.sending == State::sendingAdapted);
     } else {
         debugs(93, 5, HERE &lt;&lt; &quot;not expecting a body&quot;);
         stopParsing();
         stopSending(true);
     }
 }
 
 void Adaptation::Icap::ModXact::parseBody()
 {
     Must(state.parsing == State::psBody);
     Must(bodyParser);
 
     debugs(93, 5, &quot;have &quot; &lt;&lt; readBuf.length() &lt;&lt; &quot; body bytes to parse&quot;);
 
     // the parser will throw on errors
     BodyPipeCheckout bpc(*adapted.body_pipe);
-    // XXX: performance regression. SBuf-convert (or Parser-convert?) the chunked decoder.
-    MemBuf encodedData;
-    encodedData.init();
-    // NP: we must do this instead of pointing encodedData at the SBuf::rawContent
-    // because chunked decoder uses MemBuf::consume, which shuffles buffer bytes around.
-    encodedData.append(readBuf.rawContent(), readBuf.length());
-    const bool parsed = bodyParser-&gt;parse(&amp;encodedData, &amp;bpc.buf);
-    // XXX: httpChunkDecoder has consumed from MemBuf.
-    readBuf.consume(readBuf.length() - encodedData.contentSize());
+    bodyParser-&gt;setPayloadBuffer(&amp;bpc.buf);
+    const bool parsed = bodyParser-&gt;parse(readBuf);
+    readBuf = bodyParser-&gt;remaining(); // sync buffers after parse
     bpc.checkIn();
 
     debugs(93, 5, &quot;have &quot; &lt;&lt; readBuf.length() &lt;&lt; &quot; body bytes after parsed all: &quot; &lt;&lt; parsed);
     replyHttpBodySize += adapted.body_pipe-&gt;buf().contentSize();
 
     // TODO: expose BodyPipe::putSize() to make this check simpler and clearer
     // TODO: do we really need this if we disable when sending headers?
     if (adapted.body_pipe-&gt;buf().contentSize() &gt; 0) { // parsed something sometime
         disableRepeats(&quot;sent adapted content&quot;);
         disableBypass(&quot;sent adapted content&quot;, true);
     }
 
     if (parsed) {
         if (state.readyForUob &amp;&amp; bodyParser-&gt;useOriginBody &gt;= 0) {
             prepPartialBodyEchoing(
                 static_cast&lt;uint64_t&gt;(bodyParser-&gt;useOriginBody));
             stopParsing();
             return;
         }
 

=== modified file 'src/adaptation/icap/ModXact.h'
--- src/adaptation/icap/ModXact.h	2015-01-13 07:25:36 +0000
+++ src/adaptation/icap/ModXact.h	2015-06-01 19:48:29 +0000
@@ -1,49 +1,48 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ICAPMODXACT_H
 #define SQUID_ICAPMODXACT_H
 
 #include &quot;AccessLogEntry.h&quot;
 #include &quot;adaptation/icap/InOut.h&quot;
 #include &quot;adaptation/icap/Launcher.h&quot;
 #include &quot;adaptation/icap/Xaction.h&quot;
 #include &quot;BodyPipe.h&quot;
+#include &quot;http/one/forward.h&quot;
 
 /*
  * ICAPModXact implements ICAP REQMOD and RESPMOD transaction using
  * ICAPXaction as the base. The ICAPModXact receives a virgin HTTP message
  * from an ICAP vecoring point, (a.k.a., initiator), communicates with the
  * ICAP server, and sends the adapted HTTP message headers back.
  * Virgin/adapted HTTP message body is reveived/sent using BodyPipe
  * interface. The initiator (or its associate) is expected to send and/or
  * receive the HTTP body.
  */
 
-class ChunkedCodingParser;
-
 namespace Adaptation
 {
 namespace Icap
 {
 
 // estimated future presence and size of something (e.g., HTTP body)
 
 class SizedEstimate
 {
 
 public:
     SizedEstimate(); // not expected by default
     void expect(int64_t aSize); // expect with any, even unknown size
     bool expected() const;
 
     /* other members can be accessed iff expected() */
 
     bool knownSize() const;
     uint64_t size() const; // can be accessed iff knownSize()
 
@@ -233,41 +232,41 @@
     void stopBackup();
 
     virtual void fillPendingStatus(MemBuf &amp;buf) const;
     virtual void fillDoneStatus(MemBuf &amp;buf) const;
     virtual bool fillVirginHttpHeader(MemBuf&amp;) const;
 
 private:
     void packHead(MemBuf &amp;httpBuf, const HttpMsg *head);
     void encapsulateHead(MemBuf &amp;icapBuf, const char *section, MemBuf &amp;httpBuf, const HttpMsg *head);
     bool gotEncapsulated(const char *section) const;
     void checkConsuming();
 
     virtual void finalizeLogInfo();
 
     SizedEstimate virginBody;
     VirginBodyAct virginBodyWriting; // virgin body writing state
     VirginBodyAct virginBodySending;  // virgin body sending state
     uint64_t virginConsumed;        // virgin data consumed so far
     Preview preview; // use for creating (writing) the preview
 
-    ChunkedCodingParser *bodyParser; // ICAP response body parser
+    Http1::TeChunkedParser *bodyParser; // ICAP response body parser
 
     bool canStartBypass; // enables bypass of transaction failures
     bool protectGroupBypass; // protects ServiceGroup-wide bypass of failures
 
     /**
      * size of HTTP header in ICAP reply or -1 if there is not any encapsulated
      * message data
      */
     int64_t replyHttpHeaderSize;
     /**
      * size of dechunked HTTP body in ICAP reply or -1 if there is not any
      * encapsulated message data
      */
     int64_t replyHttpBodySize;
 
     int adaptHistoryId; ///&lt; adaptation history slot reservation
 
     class State
     {
 

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-05-26 17:25:04 +0000
+++ src/client_side.cc	2015-06-01 19:48:10 +0000
@@ -46,64 +46,64 @@
  * The request is *immediately* kicked off, and data flows through
  * to clientSocketRecipient.
  *
  \par
  * If the data that arrives at clientSocketRecipient is not for the current
  * request, clientSocketRecipient simply returns, without requesting more
  * data, or sending it.
  *
  \par
  * ClientKeepAliveNextRequest will then detect the presence of data in
  * the next ClientHttpRequest, and will send it, restablishing the
  * data flow.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;base/Subscription.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;CachePeer.h&quot;
-#include &quot;ChunkedCodingParser.h&quot;
 #include &quot;client_db.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;client_side_reply.h&quot;
 #include &quot;client_side_request.h&quot;
 #include &quot;ClientRequestContext.h&quot;
 #include &quot;clientStream.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;comm/Loops.h&quot;
 #include &quot;comm/Read.h&quot;
 #include &quot;comm/TcpAcceptor.h&quot;
 #include &quot;comm/Write.h&quot;
 #include &quot;CommCalls.h&quot;
 #include &quot;errorpage.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;fqdncache.h&quot;
 #include &quot;FwdState.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;helper.h&quot;
 #include &quot;helper/Reply.h&quot;
 #include &quot;http.h&quot;
 #include &quot;http/one/RequestParser.h&quot;
+#include &quot;http/one/TeChunkedParser.h&quot;
 #include &quot;HttpHdrContRange.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;ident/Config.h&quot;
 #include &quot;ident/Ident.h&quot;
 #include &quot;internal.h&quot;
 #include &quot;ipc/FdNotes.h&quot;
 #include &quot;ipc/StartListening.h&quot;
 #include &quot;log/access_log.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mime_header.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 #include &quot;profiler/Profiler.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;servers/forward.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;StatCounters.h&quot;
@@ -3188,96 +3188,89 @@
 ConnStateData::handleReadData()
 {
     // if we are reading a body, stuff data into the body pipe
     if (bodyPipe != NULL)
         return handleRequestBodyData();
     return true;
 }
 
 /**
  * called when new request body data has been buffered in in.buf
  * may close the connection if we were closing and piped everything out
  *
  * \retval false called comm_close or setReplyToError (the caller should bail)
  * \retval true  we did not call comm_close or setReplyToError
  */
 bool
 ConnStateData::handleRequestBodyData()
 {
     assert(bodyPipe != NULL);
 
-    size_t putSize = 0;
-
     if (in.bodyParser) { // chunked encoding
-        if (const err_type error = handleChunkedRequestBody(putSize)) {
+        if (const err_type error = handleChunkedRequestBody()) {
             abortChunkedRequestBody(error);
             return false;
         }
     } else { // identity encoding
         debugs(33,5, HERE &lt;&lt; &quot;handling plain request body for &quot; &lt;&lt; clientConnection);
-        putSize = bodyPipe-&gt;putMoreData(in.buf.c_str(), in.buf.length());
+        const size_t putSize = bodyPipe-&gt;putMoreData(in.buf.c_str(), in.buf.length());
+        if (putSize &gt; 0)
+            consumeInput(putSize);
+
         if (!bodyPipe-&gt;mayNeedMoreData()) {
             // BodyPipe will clear us automagically when we produced everything
             bodyPipe = NULL;
         }
     }
 
-    if (putSize &gt; 0)
-        consumeInput(putSize);
-
     if (!bodyPipe) {
         debugs(33,5, HERE &lt;&lt; &quot;produced entire request body for &quot; &lt;&lt; clientConnection);
 
         if (const char *reason = stoppedSending()) {
             /* we've finished reading like good clients,
              * now do the close that initiateClose initiated.
              */
             debugs(33, 3, HERE &lt;&lt; &quot;closing for earlier sending error: &quot; &lt;&lt; reason);
             clientConnection-&gt;close();
             return false;
         }
     }
 
     return true;
 }
 
 /// parses available chunked encoded body bytes, checks size, returns errors
 err_type
-ConnStateData::handleChunkedRequestBody(size_t &amp;putSize)
+ConnStateData::handleChunkedRequestBody()
 {
     debugs(33, 7, &quot;chunked from &quot; &lt;&lt; clientConnection &lt;&lt; &quot;: &quot; &lt;&lt; in.buf.length());
 
     try { // the parser will throw on errors
 
         if (in.buf.isEmpty()) // nothing to do
             return ERR_NONE;
 
-        MemBuf raw; // ChunkedCodingParser only works with MemBufs
-        // add one because MemBuf will assert if it cannot 0-terminate
-        raw.init(in.buf.length(), in.buf.length()+1);
-        raw.append(in.buf.c_str(), in.buf.length());
-
-        const mb_size_t wasContentSize = raw.contentSize();
         BodyPipeCheckout bpc(*bodyPipe);
-        const bool parsed = in.bodyParser-&gt;parse(&amp;raw, &amp;bpc.buf);
+        in.bodyParser-&gt;setPayloadBuffer(&amp;bpc.buf);
+        const bool parsed = in.bodyParser-&gt;parse(in.buf);
+        in.buf = in.bodyParser-&gt;remaining(); // sync buffers
         bpc.checkIn();
-        putSize = wasContentSize - raw.contentSize();
 
         // dechunk then check: the size limit applies to _dechunked_ content
         if (clientIsRequestBodyTooLargeForPolicy(bodyPipe-&gt;producedSize()))
             return ERR_TOO_BIG;
 
         if (parsed) {
             finishDechunkingRequest(true);
             Must(!bodyPipe);
             return ERR_NONE; // nil bodyPipe implies body end for the caller
         }
 
         // if chunk parser needs data, then the body pipe must need it too
         Must(!in.bodyParser-&gt;needsMoreData() || bodyPipe-&gt;mayNeedMoreData());
 
         // if parser needs more space and we can consume nothing, we will stall
         Must(!in.bodyParser-&gt;needsMoreSpace() || bodyPipe-&gt;buf().hasContent());
     } catch (...) { // TODO: be more specific
         debugs(33, 3, HERE &lt;&lt; &quot;malformed chunks&quot; &lt;&lt; bodyPipe-&gt;status());
         return ERR_INVALID_REQ;
     }
@@ -4692,41 +4685,41 @@
         clientConnection-&gt;close();
     }
 }
 
 void
 ConnStateData::expectNoForwarding()
 {
     if (bodyPipe != NULL) {
         debugs(33, 4, HERE &lt;&lt; &quot;no consumer for virgin body &quot; &lt;&lt; bodyPipe-&gt;status());
         bodyPipe-&gt;expectNoConsumption();
     }
 }
 
 /// initialize dechunking state
 void
 ConnStateData::startDechunkingRequest()
 {
     Must(bodyPipe != NULL);
     debugs(33, 5, HERE &lt;&lt; &quot;start dechunking&quot; &lt;&lt; bodyPipe-&gt;status());
     assert(!in.bodyParser);
-    in.bodyParser = new ChunkedCodingParser;
+    in.bodyParser = new Http1::TeChunkedParser;
 }
 
 /// put parsed content into input buffer and clean up
 void
 ConnStateData::finishDechunkingRequest(bool withSuccess)
 {
     debugs(33, 5, HERE &lt;&lt; &quot;finish dechunking: &quot; &lt;&lt; withSuccess);
 
     if (bodyPipe != NULL) {
         debugs(33, 7, HERE &lt;&lt; &quot;dechunked tail: &quot; &lt;&lt; bodyPipe-&gt;status());
         BodyPipe::Pointer myPipe = bodyPipe;
         stopProducingFor(bodyPipe, withSuccess); // sets bodyPipe-&gt;bodySize()
         Must(!bodyPipe); // we rely on it being nil after we are done with body
         if (withSuccess) {
             Must(myPipe-&gt;bodySizeKnown());
             ClientSocketContext::Pointer context = getCurrentContext();
             if (context != NULL &amp;&amp; context-&gt;http &amp;&amp; context-&gt;http-&gt;request)
                 context-&gt;http-&gt;request-&gt;setContentLength(myPipe-&gt;bodySize());
         }
     }

=== modified file 'src/client_side.h'
--- src/client_side.h	2015-04-10 08:54:13 +0000
+++ src/client_side.h	2015-06-01 19:48:21 +0000
@@ -11,41 +11,40 @@
 #ifndef SQUID_CLIENTSIDE_H
 #define SQUID_CLIENTSIDE_H
 
 #include &quot;clientStreamForward.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;helper/forward.h&quot;
 #include &quot;http/forward.h&quot;
 #include &quot;HttpControlMsg.h&quot;
 #include &quot;ipc/FdNotes.h&quot;
 #include &quot;SBuf.h&quot;
 #if USE_AUTH
 #include &quot;auth/UserRequest.h&quot;
 #endif
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
-class ChunkedCodingParser;
 namespace AnyP
 {
 class PortCfg;
 } // namespace Anyp
 
 /**
  * Badly named.
  * This is in fact the processing context for a single HTTP request.
  *
  * Managing what has been done, and what happens next to the data buffer
  * holding what we hope is an HTTP request.
  *
  * Parsing is still a mess of global functions done in conjunction with the
  * real socket controller which generated ClientHttpRequest.
  * It also generates one of us and passes us control from there based on
  * the results of the parse.
  *
  * After that all the request interpretation and adaptation is in our scope.
  * Then finally the reply fetcher is created by this and we get the result
  * back. Which we then have to manage writing of it to the ConnStateData.
@@ -191,41 +190,41 @@
     void receivedFirstByte();
 
     // HttpControlMsgSink API
     virtual void sendControlMsg(HttpControlMsg msg);
 
     // Client TCP connection details from comm layer.
     Comm::ConnectionPointer clientConnection;
 
     /**
      * The transfer protocol currently being spoken on this connection.
      * HTTP/1 CONNECT and HTTP/2 SETTINGS offers the ability to change
      * protocols on the fly.
      */
     AnyP::ProtocolVersion transferProtocol;
 
     struct In {
         In();
         ~In();
         bool maybeMakeSpaceAvailable();
 
-        ChunkedCodingParser *bodyParser; ///&lt; parses chunked request body
+        Http1::TeChunkedParser *bodyParser; ///&lt; parses chunked request body
         SBuf buf;
     } in;
 
     /** number of body bytes we need to comm_read for the &quot;current&quot; request
      *
      * \retval 0         We do not need to read any [more] body bytes
      * \retval negative  May need more but do not know how many; could be zero!
      * \retval positive  Need to read exactly that many more body bytes
      */
     int64_t mayNeedToReadMoreBody() const;
 
 #if USE_AUTH
     /**
      * Fetch the user details for connection based authentication
      * NOTE: this is ONLY connection based because NTLM and Negotiate is against HTTP spec.
      */
     const Auth::UserRequest::Pointer &amp;getAuth() const { return auth_; }
 
     /**
      * Set the user details for connection-based authentication to use from now until connection closure.
@@ -406,41 +405,41 @@
 
     /// ClientStream calls this to supply response header (once) and data
     /// for the current ClientSocketContext.
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData) = 0;
 
     /// remove no longer needed leading bytes from the input buffer
     void consumeInput(const size_t byteCount);
 
     /* TODO: Make the methods below (at least) non-public when possible. */
 
     /// stop parsing the request and create context for relaying error info
     ClientSocketContext *abortRequestParsing(const char *const errUri);
 
     /// client data which may need to forward as-is to server after an
     /// on_unsupported_protocol tunnel decision.
     SBuf preservedClientData;
 protected:
     void startDechunkingRequest();
     void finishDechunkingRequest(bool withSuccess);
     void abortChunkedRequestBody(const err_type error);
-    err_type handleChunkedRequestBody(size_t &amp;putSize);
+    err_type handleChunkedRequestBody();
 
     void startPinnedConnectionMonitoring();
     void clientPinnedConnectionRead(const CommIoCbParams &amp;io);
 
     /// parse input buffer prefix into a single transfer protocol request
     /// return NULL to request more header bytes (after checking any limits)
     /// use abortRequestParsing() to handle parsing errors w/o creating request
     virtual ClientSocketContext *parseOneRequest() = 0;
 
     /// start processing a freshly parsed request
     virtual void processParsedRequest(ClientSocketContext *context) = 0;
 
     /// returning N allows a pipeline of 1+N requests (see pipeline_prefetch)
     virtual int pipelinePrefetchMax() const;
 
     /// timeout to use when waiting for the next request
     virtual time_t idleTimeout() const = 0;
 
     BodyPipe::Pointer bodyPipe; ///&lt; set when we are reading request body
 

=== modified file 'src/http.cc'
--- src/http.cc	2015-04-27 09:52:02 +0000
+++ src/http.cc	2015-06-01 19:47:47 +0000
@@ -2,53 +2,53 @@
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 11    Hypertext Transfer Protocol (HTTP) */
 
 /*
  * Anonymizing patch by <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">lutz at as-node.jena.thur.de</A>
  * have a look into http-anon.c to get more informations.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;base/AsyncJobCalls.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;base64.h&quot;
 #include &quot;CachePeer.h&quot;
-#include &quot;ChunkedCodingParser.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;comm/Read.h&quot;
 #include &quot;comm/Write.h&quot;
 #include &quot;CommRead.h&quot;
 #include &quot;err_detail_type.h&quot;
 #include &quot;errorpage.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;http.h&quot;
 #include &quot;http/one/ResponseParser.h&quot;
+#include &quot;http/one/TeChunkedParser.h&quot;
 #include &quot;HttpControlMsg.h&quot;
 #include &quot;HttpHdrCc.h&quot;
 #include &quot;HttpHdrContRange.h&quot;
 #include &quot;HttpHdrSc.h&quot;
 #include &quot;HttpHdrScTarget.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;HttpStateFlags.h&quot;
 #include &quot;log/access_log.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;neighbors.h&quot;
 #include &quot;peer_proxy_negotiate_auth.h&quot;
 #include &quot;profiler/Profiler.h&quot;
 #include &quot;refresh.h&quot;
 #include &quot;RefreshPattern.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
@@ -771,41 +771,41 @@
         newrep-&gt;sline.version.protocol = hp-&gt;messageProtocol().protocol;
         newrep-&gt;sline.version.major = hp-&gt;messageProtocol().major;
         newrep-&gt;sline.version.minor = hp-&gt;messageProtocol().minor;
         debugs(11, 2, &quot;error parsing response headers mime block&quot;);
     }
 
     // done with Parser, now process using the HttpReply
     hp = NULL;
 
     newrep-&gt;removeStaleWarnings();
 
     if (newrep-&gt;sline.protocol == AnyP::PROTO_HTTP &amp;&amp; newrep-&gt;sline.status() &gt;= 100 &amp;&amp; newrep-&gt;sline.status() &lt; 200) {
         handle1xx(newrep);
         ctx_exit(ctx);
         return;
     }
 
     flags.chunked = false;
     if (newrep-&gt;sline.protocol == AnyP::PROTO_HTTP &amp;&amp; newrep-&gt;header.chunked()) {
         flags.chunked = true;
-        httpChunkDecoder = new ChunkedCodingParser;
+        httpChunkDecoder = new Http1::TeChunkedParser;
     }
 
     if (!peerSupportsConnectionPinning())
         request-&gt;flags.connectionAuthDisabled = true;
 
     HttpReply *vrep = setVirginReply(newrep);
     flags.headers_parsed = true;
 
     keepaliveAccounting(vrep);
 
     checkDateSkew(vrep);
 
     processSurrogateControl (vrep);
 
     request-&gt;hier.peer_reply_status = newrep-&gt;sline.status();
 
     ctx_exit(ctx);
 }
 
 /// ignore or start forwarding the 1xx response (a.k.a., control message)
@@ -1376,49 +1376,43 @@
 HttpStateData::writeReplyBody()
 {
     truncateVirginBody(); // if needed
     const char *data = inBuf.rawContent();
     int len = inBuf.length();
     addVirginReplyBody(data, len);
     inBuf.consume(len);
 }
 
 bool
 HttpStateData::decodeAndWriteReplyBody()
 {
     const char *data = NULL;
     int len;
     bool wasThereAnException = false;
     assert(flags.chunked);
     assert(httpChunkDecoder);
     SQUID_ENTER_THROWING_CODE();
     MemBuf decodedData;
     decodedData.init();
-    // XXX: performance regression. SBuf-convert (or Parser-convert?) the chunked decoder.
-    MemBuf encodedData;
-    encodedData.init();
-    // NP: we must do this instead of pointing encodedData at the SBuf::rawContent
-    // because chunked decoder uses MemBuf::consume, which shuffles buffer bytes around.
-    encodedData.append(inBuf.rawContent(), inBuf.length());
-    const bool doneParsing = httpChunkDecoder-&gt;parse(&amp;encodedData,&amp;decodedData);
-    // XXX: httpChunkDecoder has consumed from MemBuf.
-    inBuf.consume(inBuf.length() - encodedData.contentSize());
+    httpChunkDecoder-&gt;setPayloadBuffer(&amp;decodedData);
+    const bool doneParsing = httpChunkDecoder-&gt;parse(inBuf);
+    inBuf = httpChunkDecoder-&gt;remaining(); // sync buffers after parse
     len = decodedData.contentSize();
     data=decodedData.content();
     addVirginReplyBody(data, len);
     if (doneParsing) {
         lastChunk = 1;
         flags.do_next_read = false;
     }
     SQUID_EXIT_THROWING_CODE(wasThereAnException);
     return wasThereAnException;
 }
 
 /**
  * processReplyBody has two purposes:
  *  1 - take the reply body data, if any, and put it into either
  *      the StoreEntry, or give it over to ICAP.
  *  2 - see if we made it to the end of the response (persistent
  *      connections and such)
  */
 void
 HttpStateData::processReplyBody()

=== modified file 'src/http.h'
--- src/http.h	2015-03-17 02:53:05 +0000
+++ src/http.h	2015-06-01 19:47:33 +0000
@@ -1,36 +1,36 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTP_H
 #define SQUID_HTTP_H
 
 #include &quot;clients/Client.h&quot;
 #include &quot;comm.h&quot;
+#include &quot;http/forward.h&quot;
 #include &quot;HttpStateFlags.h&quot;
 
-class ChunkedCodingParser;
 class FwdState;
 class HttpHeader;
 
 class HttpStateData : public Client
 {
     CBDATA_CLASS(HttpStateData);
 
 public:
     HttpStateData(FwdState *);
     ~HttpStateData();
 
     static void httpBuildRequestHeader(HttpRequest * request,
                                        StoreEntry * entry,
                                        const AccessLogEntryPointer &amp;al,
                                        HttpHeader * hdr_out,
                                        const HttpStateFlags &amp;flags);
 
     virtual const Comm::ConnectionPointer &amp; dataConnection() const;
     /* should be private */
     bool sendRequest();
@@ -103,34 +103,34 @@
     virtual void handleRequestBodyProducerAborted();
 
     void writeReplyBody();
     bool decodeAndWriteReplyBody();
     bool finishingBrokenPost();
     bool finishingChunkedRequest();
     void doneSendingRequestBody();
     void requestBodyHandler(MemBuf &amp;);
     virtual void sentRequestBody(const CommIoCbParams &amp;io);
     void wroteLast(const CommIoCbParams &amp;io);
     void sendComplete();
     void httpStateConnClosed(const CommCloseCbParams &amp;params);
     void httpTimeout(const CommTimeoutCbParams &amp;params);
 
     mb_size_t buildRequestPrefix(MemBuf * mb);
     static bool decideIfWeDoRanges (HttpRequest * orig_request);
     bool peerSupportsConnectionPinning() const;
 
     /// Parser being used at present to parse the HTTP/ICY server response.
     Http1::ResponseParserPointer hp;
-    ChunkedCodingParser *httpChunkDecoder;
+    Http1::TeChunkedParser *httpChunkDecoder;
 
     /// amount of message payload/body received so far.
     int64_t payloadSeen;
     /// positive when we read more than we wanted
     int64_t payloadTruncated;
 };
 
 int httpCachable(const HttpRequestMethod&amp;);
 void httpStart(FwdState *);
 const char *httpMakeVaryMark(HttpRequest * request, HttpReply const * reply);
 
 #endif /* SQUID_HTTP_H */
 

=== modified file 'src/http/one/Makefile.am'
--- src/http/one/Makefile.am	2015-01-20 12:33:23 +0000
+++ src/http/one/Makefile.am	2015-06-01 19:43:57 +0000
@@ -1,20 +1,22 @@
 ## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
 ##
 ## Squid software is distributed under GPLv2+ license and includes
 ## contributions from numerous individuals and organizations.
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
 noinst_LTLIBRARIES = libhttp1.la
 
 libhttp1_la_SOURCES = \
 	forward.h \
 	Parser.cc \
 	Parser.h \
 	RequestParser.cc \
 	RequestParser.h \
 	ResponseParser.cc \
-	ResponseParser.h
+	ResponseParser.h \
+	TeChunkedParser.cc \
+	TeChunkedParser.h

=== modified file 'src/http/one/Parser.h'
--- src/http/one/Parser.h	2015-02-20 03:25:12 +0000
+++ src/http/one/Parser.h	2015-04-12 11:05:50 +0000
@@ -6,44 +6,47 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_SRC_HTTP_ONE_PARSER_H
 #define _SQUID_SRC_HTTP_ONE_PARSER_H
 
 #include &quot;anyp/ProtocolVersion.h&quot;
 #include &quot;http/one/forward.h&quot;
 #include &quot;http/StatusCode.h&quot;
 #include &quot;SBuf.h&quot;
 
 namespace Parser {
 class Tokenizer;
 }
 
 namespace Http {
 namespace One {
 
 // Parser states
 enum ParseState {
-    HTTP_PARSE_NONE,     ///&lt; initialized, but nothing usefully parsed yet
-    HTTP_PARSE_FIRST,    ///&lt; HTTP/1 message first-line
-    HTTP_PARSE_MIME,     ///&lt; HTTP/1 mime-header block
-    HTTP_PARSE_DONE      ///&lt; parsed a message header, or reached a terminal syntax error
+    HTTP_PARSE_NONE,      ///&lt; initialized, but nothing usefully parsed yet
+    HTTP_PARSE_FIRST,     ///&lt; HTTP/1 message first-line
+    HTTP_PARSE_CHUNK_SZ,  ///&lt; HTTP/1.1 chunked encoding chunk-size
+    HTTP_PARSE_CHUNK_EXT, ///&lt; HTTP/1.1 chunked encoding chunk-ext
+    HTTP_PARSE_CHUNK,     ///&lt; HTTP/1.1 chunked encoding chunk-data
+    HTTP_PARSE_MIME,      ///&lt; HTTP/1 mime-header block
+    HTTP_PARSE_DONE       ///&lt; parsed a message header, or reached a terminal syntax error
 };
 
 /** HTTP/1.x protocol parser
  *
  * Works on a raw character I/O buffer and tokenizes the content into
  * the major CRLF delimited segments of an HTTP/1 procotol message:
  *
  * \item first-line (request-line / simple-request / status-line)
  * \item mime-header 0*( header-name ':' SP field-value CRLF)
  */
 class Parser : public RefCountable
 {
 public:
     typedef SBuf::size_type size_type;
 
     Parser() : parseStatusCode(Http::scNone), parsingStage_(HTTP_PARSE_NONE) {}
     virtual ~Parser() {}
 
     /// Set this parser back to a default state.
     /// Will DROP any reference to a buffer (does not free).

=== renamed file 'src/ChunkedCodingParser.cc' =&gt; 'src/http/one/TeChunkedParser.cc'
--- src/ChunkedCodingParser.cc	2015-01-13 07:25:36 +0000
+++ src/http/one/TeChunkedParser.cc	2015-06-01 19:45:00 +0000
@@ -1,311 +1,214 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;base/TextException.h&quot;
-#include &quot;ChunkedCodingParser.h&quot;
 #include &quot;Debug.h&quot;
+#include &quot;http/one/TeChunkedParser.h&quot;
+#include &quot;http/ProtocolVersion.h&quot;
 #include &quot;MemBuf.h&quot;
+#include &quot;parser/Tokenizer.h&quot;
 #include &quot;Parsing.h&quot;
 
-ChunkedCodingParser::Step ChunkedCodingParser::psChunkSize = &amp;ChunkedCodingParser::parseChunkSize;
-ChunkedCodingParser::Step ChunkedCodingParser::psUnusedChunkExtension = &amp;ChunkedCodingParser::parseUnusedChunkExtension;
-ChunkedCodingParser::Step ChunkedCodingParser::psLastChunkExtension = &amp;ChunkedCodingParser::parseLastChunkExtension;
-ChunkedCodingParser::Step ChunkedCodingParser::psChunkBody = &amp;ChunkedCodingParser::parseChunkBody;
-ChunkedCodingParser::Step ChunkedCodingParser::psChunkEnd = &amp;ChunkedCodingParser::parseChunkEnd;
-ChunkedCodingParser::Step ChunkedCodingParser::psTrailer = &amp;ChunkedCodingParser::parseTrailer;
-ChunkedCodingParser::Step ChunkedCodingParser::psMessageEnd = &amp;ChunkedCodingParser::parseMessageEnd;
-
-ChunkedCodingParser::ChunkedCodingParser()
+Http::One::TeChunkedParser::TeChunkedParser()
 {
-    reset();
+    // chunked encoding only exists in HTTP/1.1
+    Http1::Parser::msgProtocol_ = Http::ProtocolVersion(1,1);
+
+    clear();
 }
 
-void ChunkedCodingParser::reset()
+void
+Http::One::TeChunkedParser::clear()
 {
-    theStep = psChunkSize;
+    parsingStage_ = Http1::HTTP_PARSE_NONE;
+    buf_.clear();
     theChunkSize = theLeftBodySize = 0;
-    doNeedMoreData = false;
-    theIn = theOut = NULL;
+    theOut = NULL;
     useOriginBody = -1;
-    inQuoted = inSlashed = false;
 }
 
-bool ChunkedCodingParser::parse(MemBuf *rawData, MemBuf *parsedContent)
+bool
+Http::One::TeChunkedParser::parse(const SBuf &amp;aBuf)
 {
-    Must(rawData &amp;&amp; parsedContent);
-    theIn = rawData;
-    theOut = parsedContent;
-
-    // we must reset this all the time so that mayContinue() lets us
-    // output more content if we stopped due to needsMoreSpace() before
-    doNeedMoreData = !theIn-&gt;hasContent();
+    buf_ = aBuf; // sync buffers first so calls to remaining() work properly if nothing done.
 
-    while (mayContinue()) {
-        (this-&gt;*theStep)();
-    }
+    if (buf_.isEmpty()) // nothing to do (yet)
+        return false;
 
-    return theStep == psMessageEnd;
-}
+    debugs(74, DBG_DATA, &quot;Parse buf={length=&quot; &lt;&lt; aBuf.length() &lt;&lt; &quot;, data='&quot; &lt;&lt; aBuf &lt;&lt; &quot;'}&quot;);
 
-bool ChunkedCodingParser::needsMoreData() const
-{
-    return doNeedMoreData;
-}
+    Must(!buf_.isEmpty() &amp;&amp; theOut);
 
-bool ChunkedCodingParser::needsMoreSpace() const
-{
-    assert(theOut);
-    return theStep == psChunkBody &amp;&amp; !theOut-&gt;hasPotentialSpace();
+    if (parsingStage_ == Http1::HTTP_PARSE_NONE)
+        parsingStage_ = Http1::HTTP_PARSE_CHUNK_SZ;
+
+    ::Parser::Tokenizer tok(buf_);
+
+    // loop for as many chunks as we can
+    // use do-while instead of while so that we can incrementally
+    // restart in the middle of a chunk/frame
+    do {
+
+        if (parsingStage_ == Http1::HTTP_PARSE_CHUNK_EXT &amp;&amp; !parseChunkExtension(tok, theChunkSize))
+            return false;
+
+        if (parsingStage_ == Http1::HTTP_PARSE_CHUNK &amp;&amp; !parseChunkBody(tok))
+            return false;
+
+        if (parsingStage_ == Http1::HTTP_PARSE_MIME &amp;&amp; !grabMimeBlock(&quot;Trailers&quot;, 64*1024 /* 64KB max */))
+            return false;
+
+        // loop for as many chunks as we can
+    } while (parsingStage_ == Http1::HTTP_PARSE_CHUNK_SZ &amp;&amp; parseChunkSize(tok));
+
+    return !needsMoreData() &amp;&amp; !needsMoreSpace();
 }
 
-bool ChunkedCodingParser::mayContinue() const
+bool
+Http::One::TeChunkedParser::needsMoreSpace() const
 {
-    return !needsMoreData() &amp;&amp; !needsMoreSpace() &amp;&amp; theStep != psMessageEnd;
+    assert(theOut);
+    return parsingStage_ == Http1::HTTP_PARSE_CHUNK &amp;&amp; !theOut-&gt;hasPotentialSpace();
 }
 
-void ChunkedCodingParser::parseChunkSize()
+/// RFC 7230 section 4.1 chunk-size
+bool
+Http::One::TeChunkedParser::parseChunkSize(::Parser::Tokenizer &amp;tok)
 {
     Must(theChunkSize &lt;= 0); // Should(), really
 
-    const char *p = theIn-&gt;content();
-    while (p &lt; theIn-&gt;space() &amp;&amp; xisxdigit(*p)) ++p;
-    if (p &gt;= theIn-&gt;space()) {
-        doNeedMoreData = true;
-        return;
-    }
-
     int64_t size = -1;
-    if (StringToInt64(theIn-&gt;content(), size, &amp;p, 16)) {
+    if (tok.int64(size, 16, false) &amp;&amp; !tok.atEnd()) {
         if (size &lt; 0)
             throw TexcHere(&quot;negative chunk size&quot;);
 
         theChunkSize = theLeftBodySize = size;
         debugs(94,7, &quot;found chunk: &quot; &lt;&lt; theChunkSize);
-        // parse chunk extensions only in the last-chunk
-        if (theChunkSize)
-            theStep = psUnusedChunkExtension;
-        else {
-            theIn-&gt;consume(p - theIn-&gt;content());
-            theStep = psLastChunkExtension;
-        }
-    } else
-        throw TexcHere(&quot;corrupted chunk size&quot;);
-}
+        buf_ = tok.remaining(); // parse checkpoint
+        parsingStage_ = Http1::HTTP_PARSE_CHUNK_EXT;
+        return true;
 
-void ChunkedCodingParser::parseUnusedChunkExtension()
-{
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-    if (findCrlf(crlfBeg, crlfEnd, inQuoted, inSlashed)) {
-        inQuoted = inSlashed = false;
-        theIn-&gt;consume(crlfEnd);
-        theStep = theChunkSize ? psChunkBody : psTrailer;
-    } else {
-        theIn-&gt;consume(theIn-&gt;contentSize());
-        doNeedMoreData = true;
+    } else if (tok.atEnd()) {
+        return false; // need more data
     }
+
+    // else error
+    throw TexcHere(&quot;corrupted chunk size&quot;);
+    return false; // should not be reachable
 }
 
-void ChunkedCodingParser::parseChunkBody()
+/**
+ * Parses a set of RFC 7230 section 4.1.1 chunk-ext
+ * <A HREF="http://tools.ietf.org/html/rfc7230#section-4.1.1">http://tools.ietf.org/html/rfc7230#section-4.1.1</A>
+ *
+ *   chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
+ *   chunk-ext-name = token
+ *   chunk-ext-val  = token / quoted-string
+ *
+ * ICAP 'use-original-body=N' extension is supported.
+ */
+bool
+Http::One::TeChunkedParser::parseChunkExtension(::Parser::Tokenizer &amp;tok, bool skipKnown)
 {
-    Must(theLeftBodySize &gt; 0); // Should, really
+    // TODO implement a proper quoted-string Tokenizer method
+    static const CharacterSet qString = CharacterSet(&quot;qString&quot;,&quot;\&quot;\r\n&quot;).add('\0').complement();
 
-    const size_t availSize = min(theLeftBodySize, (uint64_t)theIn-&gt;contentSize());
-    const size_t safeSize = min(availSize, (size_t)theOut-&gt;potentialSpaceSize());
+    SBuf ext;
+    while (tok.skip(';') &amp;&amp; tok.prefix(ext, CharacterSet::TCHAR)) {
 
-    doNeedMoreData = availSize &lt; theLeftBodySize;
-    // and we may also need more space
+        // whole value part is optional. if no '=' expect next chunk-ext
+        if (tok.skip('=')) {
+
+            if (!skipKnown) {
+                if (ext.cmp(&quot;use-original-body&quot;,17) == 0 &amp;&amp; tok.int64(useOriginBody, 10)) {
+                    debugs(94, 3, &quot;Found chunk extension &quot; &lt;&lt; ext &lt;&lt; &quot;=&quot; &lt;&lt; useOriginBody);
+                    buf_ = tok.remaining(); // parse checkpoint
+                    continue;
+                }
+            }
 
-    theOut-&gt;append(theIn-&gt;content(), safeSize);
-    theIn-&gt;consume(safeSize);
-    theLeftBodySize -= safeSize;
+            debugs(94, 5, &quot;skipping unknown chunk extension &quot; &lt;&lt; ext);
 
-    if (theLeftBodySize == 0)
-        theStep = psChunkEnd;
-    else
-        Must(needsMoreData() || needsMoreSpace());
-}
-
-void ChunkedCodingParser::parseChunkEnd()
-{
-    Must(theLeftBodySize == 0); // Should(), really
+            // unknown might have a value token ...
+            if (tok.skipAll(CharacterSet::TCHAR) &amp;&amp; !tok.atEnd()) {
+                buf_ = tok.remaining(); // parse checkpoint
+                continue;
+            }
 
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
+            // ... or a quoted-string
+            if (tok.skipOne(CharacterSet::DQUOTE) &amp;&amp; tok.skipAll(qString) &amp;&amp; tok.skipOne(CharacterSet::DQUOTE)) {
+                buf_ = tok.remaining(); // parse checkpoint
+                continue;
+            }
 
-    if (findCrlf(crlfBeg, crlfEnd)) {
-        if (crlfBeg != 0) {
-            throw TexcHere(&quot;found data between chunk end and CRLF&quot;);
-            return;
+            // otherwise need more data OR corrupt syntax
+            break;
         }
 
-        theIn-&gt;consume(crlfEnd);
-        theChunkSize = 0; // done with the current chunk
-        theStep = psChunkSize;
-        return;
+        if (!tok.atEnd())
+            buf_ = tok.remaining(); // parse checkpoint (unless there might be more token name)
     }
 
-    doNeedMoreData = true;
-}
-
-void ChunkedCodingParser::parseTrailer()
-{
-    Must(theChunkSize == 0); // Should(), really
-
-    while (mayContinue())
-        parseTrailerHeader();
-}
-
-void ChunkedCodingParser::parseTrailerHeader()
-{
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-
-    if (findCrlf(crlfBeg, crlfEnd)) {
+    if (tok.atEnd())
+        return false;
 
-#if TRAILERS_ARE_SUPPORTED
-        if (crlfBeg &gt; 0)
-            theTrailer.append(theIn-&gt;content(), crlfEnd);
-#endif
-
-        theIn-&gt;consume(crlfEnd);
-
-        if (crlfBeg == 0)
-            theStep = psMessageEnd;
-
-        return;
+    if (skipLineTerminator(tok)) {
+        buf_ = tok.remaining(); // checkpoint
+        // non-0 chunk means data, 0-size means optional Trailer follows
+        parsingStage_ = theChunkSize ? Http1::HTTP_PARSE_CHUNK : Http1::HTTP_PARSE_MIME;
+        return true;
     }
 
-    doNeedMoreData = true;
-}
-
-void ChunkedCodingParser::parseMessageEnd()
-{
-    // termination step, should not be called
-    Must(false); // Should(), really
-}
-
-/// Finds next CRLF. Does not store parsing state.
-bool ChunkedCodingParser::findCrlf(size_t &amp;crlfBeg, size_t &amp;crlfEnd)
-{
-    bool quoted = false;
-    bool slashed = false;
-    return findCrlf(crlfBeg, crlfEnd, quoted, slashed);
+    throw TexcHere(&quot;corrupted chunk extension value&quot;);
+    return false;
 }
 
-/// Finds next CRLF. Parsing state stored in quoted and slashed
-/// parameters. Incremental: can resume when more data is available.
-bool ChunkedCodingParser::findCrlf(size_t &amp;crlfBeg, size_t &amp;crlfEnd, bool &amp;quoted, bool &amp;slashed)
+bool
+Http::One::TeChunkedParser::parseChunkBody(::Parser::Tokenizer &amp;tok)
 {
-    // XXX: This code was copied, with permission, from another software.
-    // There is a similar and probably better code inside httpHeaderParse
-    // but it seems difficult to isolate due to parsing-unrelated bloat.
-    // Such isolation should probably be done before this class is used
-    // for handling of traffic &quot;more external&quot; than ICAP.
-
-    const char *buf = theIn-&gt;content();
-    size_t size = theIn-&gt;contentSize();
-
-    ssize_t crOff = -1;
-
-    for (size_t i = 0; i &lt; size; ++i) {
-        if (slashed) {
-            slashed = false;
-            continue;
-        }
+    Must(theLeftBodySize &gt; 0); // Should, really
 
-        const char c = buf[i];
+    buf_ = tok.remaining(); // sync buffers before buf_ use
 
-        // handle quoted strings
-        if (quoted) {
-            if (c == '\\')
-                slashed = true;
-            else if (c == '&quot;')
-                quoted = false;
-
-            continue;
-        } else if (c == '&quot;') {
-            quoted = true;
-            crOff = -1;
-            continue;
-        }
-
-        if (crOff &lt; 0) { // looking for the first CR or LF
+    // TODO fix type mismatches and casting for these
+    const size_t availSize = min(theLeftBodySize, (uint64_t)buf_.length());
+    const size_t safeSize = min(availSize, (size_t)theOut-&gt;potentialSpaceSize());
 
-            if (c == '\n') {
-                crlfBeg = i;
-                crlfEnd = ++i;
-                return true;
-            }
+    theOut-&gt;append(buf_.rawContent(), safeSize);
+    buf_.consume(safeSize);
+    theLeftBodySize -= safeSize;
 
-            if (c == '\r')
-                crOff = i;
-        } else { // skipping CRs, looking for the first LF
-
-            if (c == '\n') {
-                crlfBeg = crOff;
-                crlfEnd = ++i;
-                return true;
-            }
+    tok.reset(buf_); // sync buffers after consume()
 
-            if (c != '\r')
-                crOff = -1;
-        }
-    }
+    if (theLeftBodySize == 0)
+        return parseChunkEnd(tok);
+    else
+        Must(needsMoreData() || needsMoreSpace());
 
-    return false;
+    return true;
 }
 
-// chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
-void ChunkedCodingParser::parseLastChunkExtension()
+bool
+Http::One::TeChunkedParser::parseChunkEnd(::Parser::Tokenizer &amp;tok)
 {
-    size_t crlfBeg = 0;
-    size_t crlfEnd = 0;
-
-    if (!findCrlf(crlfBeg, crlfEnd)) {
-        doNeedMoreData = true;
-        return;
-    }
-
-    const char *const startExt = theIn-&gt;content();
-    const char *const endExt = theIn-&gt;content() + crlfBeg;
-
-    // chunk-extension starts at startExt and ends with LF at endEx
-    for (const char *p = startExt; p &lt; endExt;) {
-
-        while (*p == ' ' || *p == '\t') ++p; // skip spaces before ';'
-
-        if (*p++ != ';') // each ext name=value pair is preceded with ';'
-            break;
-
-        while (*p == ' ' || *p == '\t') ++p; // skip spaces before name
+    Must(theLeftBodySize == 0); // Should(), really
 
-        if (p &gt;= endExt)
-            break; // malformed extension: ';' without ext name=value pair
+    if (skipLineTerminator(tok)) {
+        buf_ = tok.remaining(); // parse checkpoint
+        theChunkSize = 0; // done with the current chunk
+        parsingStage_ = Http1::HTTP_PARSE_CHUNK_SZ;
+        return true;
 
-        const int extSize = endExt - p;
-        // TODO: we need debugData() stream manipulator to dump data
-        debugs(94,7, &quot;Found chunk extension; size=&quot; &lt;&lt; extSize);
-
-        // TODO: support implied *LWS around '='
-        if (extSize &gt; 18 &amp;&amp; strncmp(p, &quot;use-original-body=&quot;, 18) == 0) {
-            (void)StringToInt64(p+18, useOriginBody, &amp;p, 10);
-            debugs(94, 3, HERE &lt;&lt; &quot;use-original-body=&quot; &lt;&lt; useOriginBody);
-            break; // remove to support more than just use-original-body
-        } else {
-            debugs(94, 5, HERE &lt;&lt; &quot;skipping unknown chunk extension&quot;);
-            // TODO: support quoted-string chunk-ext-val
-            while (p &lt; endExt &amp;&amp; *p != ';') ++p; // skip until the next ';'
-        }
+    } else if (!tok.atEnd()) {
+        throw TexcHere(&quot;found data between chunk end and CRLF&quot;);
     }
 
-    theIn-&gt;consume(crlfEnd);
-    theStep = theChunkSize ? psChunkBody : psTrailer;
+    return false;
 }
 

=== renamed file 'src/ChunkedCodingParser.h' =&gt; 'src/http/one/TeChunkedParser.h'
--- src/ChunkedCodingParser.h	2015-01-13 07:25:36 +0000
+++ src/http/one/TeChunkedParser.h	2015-06-01 19:46:19 +0000
@@ -1,84 +1,65 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_CHUNKEDCODINGPARSER_H
-#define SQUID_CHUNKEDCODINGPARSER_H
+#ifndef SQUID_SRC_HTTP_ONE_TeChunkedParser_H
+#define SQUID_SRC_HTTP_ONE_TeChunkedParser_H
+
+#include &quot;http/one/Parser.h&quot;
 
 class MemBuf;
 
+namespace Http
+{
+namespace One
+{
+
 /**
- \ingroup ChunkEncodingAPI Chunked Encoding API
- \par
- * ChunkedCodingParser is an incremental parser for chunked transfer coding
- * used by HTTP and ICAP. The parser shovels content bytes from the raw
+ * An incremental parser for chunked transfer coding
+ * defined in RFC 7230 section 4.1.
+ * <A HREF="http://tools.ietf.org/html/rfc7230#section-4.1">http://tools.ietf.org/html/rfc7230#section-4.1</A>
+ *
+ * The parser shovels content bytes from the raw
  * input buffer into the content output buffer, both caller-supplied.
  * Ignores chunk extensions except for ICAP's ieof.
- * Has a trailer-handling placeholder.
+ * Trailers are available via mimeHeader() if wanted.
  */
-class ChunkedCodingParser
+class TeChunkedParser : public Http1::Parser
 {
-
 public:
-    ChunkedCodingParser();
-
-    void reset();
+    TeChunkedParser();
+    virtual ~TeChunkedParser() {theOut=NULL;/* we dont own this object */}
 
-    /**
-     \retval true    complete success
-     \retval false   needs more data
-     \throws ??      error.
-     */
-    bool parse(MemBuf *rawData, MemBuf *parsedContent);
+    /// set the buffer to be used to store decoded chunk data
+    void setPayloadBuffer(MemBuf *parsedContent) {theOut = parsedContent;}
 
-    bool needsMoreData() const;
     bool needsMoreSpace() const;
 
-private:
-    typedef void (ChunkedCodingParser::*Step)();
+    /* Http1::Parser API */
+    virtual void clear();
+    virtual bool parse(const SBuf &amp;);
+    virtual Parser::size_type firstLineSize() const {return 0;} // has no meaning with multiple chunks
 
 private:
-    bool mayContinue() const;
-
-    void parseChunkSize();
-    void parseUnusedChunkExtension();
-    void parseLastChunkExtension();
-    void parseChunkBeg();
-    void parseChunkBody();
-    void parseChunkEnd();
-    void parseTrailer();
-    void parseTrailerHeader();
-    void parseMessageEnd();
+    bool parseChunkSize(::Parser::Tokenizer &amp;tok);
+    bool parseChunkExtension(::Parser::Tokenizer &amp;tok, bool skipKnown);
+    bool parseChunkBody(::Parser::Tokenizer &amp;tok);
+    bool parseChunkEnd(::Parser::Tokenizer &amp;tok);
 
-    bool findCrlf(size_t &amp;crlfBeg, size_t &amp;crlfEnd);
-    bool findCrlf(size_t &amp;crlfBeg, size_t &amp;crlfEnd, bool &amp;quoted, bool &amp;slashed);
-
-private:
-    static Step psChunkSize;
-    static Step psUnusedChunkExtension;
-    static Step psLastChunkExtension;
-    static Step psChunkBody;
-    static Step psChunkEnd;
-    static Step psTrailer;
-    static Step psMessageEnd;
-
-    MemBuf *theIn;
     MemBuf *theOut;
-
-    Step theStep;
     uint64_t theChunkSize;
     uint64_t theLeftBodySize;
-    bool doNeedMoreData;
-    bool inQuoted; ///&lt; stores parsing state for incremental findCrlf
-    bool inSlashed; ///&lt; stores parsing state for incremental findCrlf
 
 public:
     int64_t useOriginBody;
 };
 
-#endif /* SQUID_CHUNKEDCODINGPARSER_H */
+} // namespace One
+} // namespace Http
+
+#endif /* SQUID_SRC_HTTP_ONE_TeChunkedParser_H */
 

=== modified file 'src/http/one/forward.h'
--- src/http/one/forward.h	2015-01-20 12:33:23 +0000
+++ src/http/one/forward.h	2015-06-01 19:44:26 +0000
@@ -1,32 +1,34 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_HTTP_ONE_FORWARD_H
 #define SQUID_SRC_HTTP_ONE_FORWARD_H
 
 #include &quot;base/RefCount.h&quot;
 
 namespace Http {
 namespace One {
 
 class Parser;
 typedef RefCount&lt;Http::One::Parser&gt; ParserPointer;
 
+class TeChunkedParser;
+
 class RequestParser;
 typedef RefCount&lt;Http::One::RequestParser&gt; RequestParserPointer;
 
 class ResponseParser;
 typedef RefCount&lt;Http::One::ResponseParser&gt; ResponseParserPointer;
 
 } // namespace One
 } // namespace Http
 
 namespace Http1 = Http::One;
 
 #endif /* SQUID_SRC_HTTP_ONE_FORWARD_H */
 

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="002415.html">[squid-dev] [PATCH] Parser-NG: Transfer-Encoding:chunked Parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2396">[ date ]</a>
              <a href="thread.html#2396">[ thread ]</a>
              <a href="subject.html#2396">[ subject ]</a>
              <a href="author.html#2396">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
