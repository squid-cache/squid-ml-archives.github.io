<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Temporary%20fix%20to%20restore%20compatibility%20with%0A%20Amazon&In-Reply-To=%3C558C0C81.6070509%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002454.html">
   <LINK REL="Next"  HREF="002464.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Temporary%20fix%20to%20restore%20compatibility%20with%0A%20Amazon&In-Reply-To=%3C558C0C81.6070509%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Jun 25 14:13:21 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002454.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
        <LI>Next message: <A HREF="002464.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2459">[ date ]</a>
              <a href="thread.html#2459">[ thread ]</a>
              <a href="subject.html#2459">[ subject ]</a>
              <a href="author.html#2459">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 25/06/2015 4:05 p.m., Alex Rousskov wrote:
&gt;<i> On 06/24/2015 02:24 PM, Kinkie wrote:
</I>&gt;&gt;<i> My 2c: I vote for reality; possibly with a shaming announce message;
</I>&gt;<i> 
</I>&gt;<i> I would recommend against shaming any particular company unless somebody
</I>&gt;<i> can personally vouch that that specific company is the one to blame. I
</I>&gt;<i> cannot (without a lot more triage work which I have no time for).
</I>&gt;<i> 
</I>&gt;<i> The benefits of shaming in this case are tiny, but the danger of hurting
</I>&gt;<i> an innocent person (or even company) is always there.
</I>&gt;<i> 
</I>
Indeed. Which is why I want to go the route of HTTP/0.9 handling. Its
clear when products encounter it and cause themselves problems. But we
dont need to name and shame any particular source.

pPS. in my testing the URIs you presented as reason for the patch were
accepted by Squid and handled as HTTP/0.9.


&gt;<i> 
</I>&gt;&gt;<i> I wouldn't even recommend logging the violation: there is nothing the
</I>&gt;&gt;<i> average admin can do about it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> An admin has reminded me privately that Squid already has a mechanism
</I>&gt;<i> that can be used here if somebody wants to enforce strict parsing [and
</I>&gt;<i> wants to see violations]:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> NAME: relaxed_header_parser
</I>&gt;&gt;<i>     In the default &quot;on&quot; setting Squid accepts certain forms
</I>&gt;&gt;<i>     of non-compliant HTTP messages where it is unambiguous
</I>&gt;&gt;<i>     what the sending application intended
</I>&gt;<i> 
</I>&gt;&gt;<i>     If set to &quot;warn&quot; then a warning will be emitted in cache.log
</I>&gt;&gt;<i>     each time such HTTP error is encountered.
</I>&gt;<i> 
</I>&gt;&gt;<i>     If set to &quot;off&quot; then such HTTP errors will cause the request
</I>&gt;&gt;<i>     or response to be rejected.
</I>&gt;<i> 
</I>&gt;<i> The temporary fix can be enhanced to include all &quot;unwise&quot; URI characters
</I>&gt;<i> if (and only if) relaxed_header_parser is &quot;on&quot;, and also to warn about
</I>&gt;<i> those characters when relaxed_header_parser is &quot;warn&quot;.
</I>&gt;<i> 
</I>
That would be better than always doing it in the strict parsing pathway.
And is a useful temporary workaround for people having this issue you
found since related parse should be on by default IIRC.


&gt;&gt;<i> On Wed, Jun 24, 2015 at 10:12 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 06/24/2015 05:26 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> On 24/06/2015 5:55 p.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i>     This temporary trunk fix adds support for request URIs containing
</I>&gt;&gt;&gt;&gt;&gt;<i> '|' characters. Such URIs are used by popular Amazon product (and
</I>&gt;&gt;&gt;&gt;&gt;<i> probably other) sites: /images/I/ID1._RC|ID2.js,ID3.js,ID4.js_.js
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Without this fix, all requests for affected URIs timeout while Squid
</I>&gt;&gt;&gt;&gt;&gt;<i> waits for the end of request headers it has already received(*).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> This is not right. Squid should be identifying the message as
</I>&gt;&gt;&gt;&gt;<i> non-HTTP/1.x (which it isn't due to the URI syntax violation) and
</I>&gt;&gt;&gt;&gt;<i> treating it as such.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I agree that Amazon violates URI syntax. On the other hand, the message
</I>&gt;&gt;&gt;<i> can be interpreted as HTTP/1.x for all practical purposes AFAICT. If you
</I>&gt;&gt;&gt;<i> want to implement a different fix, please do so. Meanwhile, folks
</I>&gt;&gt;&gt;<i> suffering from this serious regression can try the temporary fix I posted.
</I>
SMTP messages can be interpreted as HTTP/1.1 for all intents and
purposes as well. That does not make it a good idea to do so.

I don't care who it is sending the broken messages (AIUI, its not the
company anyway, its the particular UA software you found). They need to
stop getting away with it and the best incentive is bad behaviour
leading to bad performance. Loosing the benefits of HTTP/1.1 does that
cleanly.


NP: We have a track record of several vendors who fixed their products
after this type of bug was reported to them.  Was the '|' character
non-compliance bug reported against the product? They are probably able
to roll out the proper fix faster than we can anyway.


Anyhow. I've thrown the URI you mentioned through my test copy of trunk
and its not hanging looking for the end of mime headers like you said.
Its waiting for the end of the URI:
&quot;
RequestParser.cc(390) parse: request-line: method: GET
RequestParser.cc(391) parse: request-line: url:
RequestParser.cc(392) parse: request-line: proto: NONE/0.0
RequestParser.cc(393) parse: Parser: bytes processed=4
SBuf.cc(149) assign: assigning SBuf1845 from SBuf1850
parseHttpRequest: Incomplete request, waiting for end of request line
&quot;

Attached is a patch that replaces the hang behaviour with an
invalid-request error page on standards compliant builds. But, when
--enable-http-violations is used it accepts the invalid characters we
know are in use and passes the request through as HTTP/0.9.


&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> The proper long-term fix is to allow any character in URI as long as we
</I>&gt;&gt;&gt;&gt;&gt;<i> can reliably parse the request line (and, later, URI components). There
</I>&gt;&gt;&gt;&gt;&gt;<i> is no point in hurting users by rejecting requests while slowly
</I>&gt;&gt;&gt;&gt;&gt;<i> accumulating the list of benign characters used by web sites but
</I>&gt;&gt;&gt;&gt;&gt;<i> prohibited by some RFC.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The *proper* long term fix is to obey the standards in regard to message
</I>&gt;&gt;&gt;&gt;<i> syntax so applications stop using these invalid (when un-encoded)
</I>&gt;&gt;&gt;&gt;<i> characters and claiming HTTP/1.1 support.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> We had &quot;standards vs reality&quot; and &quot;policing traffic&quot; discussions several
</I>&gt;&gt;&gt;<i> times in the past, with no signs of convergence towards a single
</I>&gt;&gt;&gt;<i> approach, so I am not going to revisit that discussion now. We continue
</I>&gt;&gt;&gt;<i> to disagree [while Squid users continue to suffer].
</I>
Yes. And things like &lt;<A HREF="http://bugs.squid-cache.org/show_bug.cgi?id=4222">http://bugs.squid-cache.org/show_bug.cgi?id=4222</A>&gt;
are what happens if we accept that particular &quot;reality&quot;. (We get screwed
both ways.)

Amos

-------------- next part --------------
=== modified file 'src/http/one/RequestParser.cc'
--- src/http/one/RequestParser.cc	2015-04-10 11:02:44 +0000
+++ src/http/one/RequestParser.cc	2015-06-25 13:01:39 +0000
@@ -244,40 +244,41 @@
  * \retval  0  more data is needed to complete the parse
  */
 int
 Http::One::RequestParser::parseRequestFirstLine()
 {
     Http1::Tokenizer tok(buf_);
 
     debugs(74, 5, &quot;parsing possible request: buf.length=&quot; &lt;&lt; buf_.length());
     debugs(74, DBG_DATA, buf_);
 
     // NP: would be static, except it need to change with reconfigure
     CharacterSet WspDelim = CharacterSet::SP; // strict parse only accepts SP
 
     if (Config.onoff.relaxed_header_parser) {
         // RFC 7230 section 3.5
         // tolerant parser MAY accept any of SP, HTAB, VT (%x0B), FF (%x0C), or bare CR
         // as whitespace between request-line fields
         WspDelim += CharacterSet::HTAB
                     + CharacterSet(&quot;VT,FF&quot;,&quot;\x0B\x0C&quot;)
                     + CharacterSet::CR;
+        debugs(74, 5, &quot;using Parser relaxed WSP characters&quot;);
     }
 
     // only search for method if we have not yet found one
     if (method_ == Http::METHOD_NONE) {
         const int res = parseMethodField(tok, WspDelim);
         if (res &lt; 1)
             return res;
         // else keep going...
     }
 
     // tolerant parser allows multiple whitespace characters between request-line fields
     if (Config.onoff.relaxed_header_parser) {
         const size_t garbage = tok.skipAll(WspDelim);
         if (garbage &gt; 0) {
             firstLineGarbage_ += garbage;
             buf_ = tok.remaining(); // re-checkpoint after garbage
         }
     }
     if (tok.atEnd()) {
         debugs(74, 5, &quot;Parser needs more data&quot;);
@@ -313,40 +314,72 @@
                 parseStatusCode = Http::scOkay;
                 buf_ = tok.remaining(); // incremental parse checkpoint
                 return 1;
 
             } else if (method_ == Http::METHOD_GET) {
                 // RFC 1945 - for GET the line terminator may follow URL instead of a delimiter
                 debugs(33, 5, &quot;HTTP/0.9 syntax request-line detected&quot;);
                 msgProtocol_ = Http::ProtocolVersion(0,9);
                 static const SBuf cr(&quot;\r&quot;,1);
                 uri_ = line.trim(cr,false,true);
                 parseStatusCode = Http::scOkay;
                 buf_ = tok.remaining(); // incremental parse checkpoint
                 return 1;
             }
 
             debugs(33, 5, &quot;invalid request-line. not HTTP&quot;);
             parseStatusCode = Http::scBadRequest;
             return -1;
         }
 
+        if (!tok.atEnd()) {
+#if USE_HTTP_VIOLATIONS
+            // invalid character somewhere in the line.
+            // As long as we can find the LF, accept the characters
+            // which we know are invalid in any URI, but actively used
+            LfDelim.add('\0'); // Java
+            LfDelim.add(' ');  // IIS
+            LfDelim.add('\&quot;'); // Bing
+            LfDelim.add('\\'); // MSIE, Firefox
+            LfDelim.add('|');  // Amazon
+
+            // reset the tokenizer from anything the above did, then seek the LF character.
+            tok.reset(buf_);
+            if (tok.prefix(line, LfDelim) &amp;&amp; tok.skip('\n')) {
+                msgProtocol_ = Http::ProtocolVersion(0,9);
+                static const SBuf cr(&quot;\r&quot;,1);
+                uri_ = line.trim(cr,false,true);
+                parseStatusCode = Http::scOkay;
+                buf_ = tok.remaining(); // incremental parse checkpoint
+                return 1;
+
+            } else if (tok.atEnd()) {
+                debugs(74, 5, &quot;Parser needs more data&quot;);
+                return 0;
+            }
+            // else, drop back to invalid request-line handling
+#endif
+            const SBuf t = tok.remaining();
+            debugs(33, 5, &quot;invalid request-line characters.&quot; &lt;&lt; Raw(&quot;data&quot;, t.rawContent(), t.length()));
+            parseStatusCode = Http::scBadRequest;
+            return -1;
+        }
         debugs(74, 5, &quot;Parser needs more data&quot;);
         return 0;
     }
     // else strict non-whitespace tolerant parse
 
     // only search for request-target (URL) if we have not yet found one
     if (uri_.isEmpty()) {
         const int res = parseUriField(tok);
         if (res &lt; 1 || msgProtocol_.protocol == AnyP::PROTO_HTTP)
             return res;
         // else keep going...
     }
 
     if (tok.atEnd()) {
         debugs(74, 5, &quot;Parser needs more data&quot;);
         return 0;
     }
 
     // HTTP/1 version suffix (protocol magic) followed by CR*LF
     if (msgProtocol_.protocol == AnyP::PROTO_NONE) {

</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002454.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
	<LI>Next message: <A HREF="002464.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2459">[ date ]</a>
              <a href="thread.html#2459">[ thread ]</a>
              <a href="subject.html#2459">[ subject ]</a>
              <a href="author.html#2459">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
