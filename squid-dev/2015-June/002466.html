<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Temporary%20fix%20to%20restore%20compatibility%20with%0A%20Amazon&In-Reply-To=%3C558D4941.7060604%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002464.html">
   <LINK REL="Next"  HREF="002468.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Temporary%20fix%20to%20restore%20compatibility%20with%0A%20Amazon&In-Reply-To=%3C558D4941.7060604%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Jun 26 12:44:49 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002464.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
        <LI>Next message: <A HREF="002468.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2466">[ date ]</a>
              <a href="thread.html#2466">[ thread ]</a>
              <a href="subject.html#2466">[ subject ]</a>
              <a href="author.html#2466">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 26/06/2015 7:55 a.m., Alex Rousskov wrote:
&gt;<i> On 06/25/2015 08:13 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> Which is why I want to go the route of HTTP/0.9 handling. Its
</I>&gt;&gt;<i> clear when products encounter it and cause themselves problems.
</I>&gt;<i> 
</I>&gt;<i> Sigh. You are repeating essentially the same argument as before. Any
</I>&gt;<i> &quot;let's create problems for something that appears to work without Squid&quot;
</I>&gt;<i> approach often results in *us* wasting time on workarounds for those
</I>&gt;<i> problems.
</I>&gt;<i> 
</I>&gt;<i> You may be convinced that creating short-term problems for others will
</I>&gt;<i> make the world a better place long-term, but there is no way to prove or
</I>&gt;<i> disprove that assumption, and there is no objective way to even compare
</I>&gt;<i> the possible long-term gain with the likely short-term pain (especially
</I>&gt;<i> when it is somebody else who is hurting).
</I>&gt;<i> 
</I>&gt;<i> The history is full of examples where the &quot;future happiness justifies
</I>&gt;<i> short-term suffering&quot; approach either works great or fails miserably. I
</I>&gt;<i> doubt we can come up with a formula that predicts the outcome.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Was the '|' character
</I>&gt;&gt;<i> non-compliance bug reported against the product?
</I>&gt;<i> 
</I>&gt;<i> Unknown to me, but I suspect folks suffering from this do not report
</I>&gt;<i> bugs to companies they have no relationship with (and may not even know
</I>&gt;<i> what the &quot;product&quot; is!).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Anyhow. I've thrown the URI you mentioned through my test copy of trunk
</I>&gt;&gt;<i> and its not hanging looking for the end of mime headers like you said.
</I>&gt;&gt;<i> Its waiting for the end of the URI:
</I>&gt;<i> 
</I>&gt;&gt;<i> parseHttpRequest: Incomplete request, waiting for end of request line
</I>&gt;<i> 
</I>&gt;<i> Please forgive me for misinterpreting the Squid log line that lies about
</I>&gt;<i> an &quot;Incomplete request&quot; and &quot;waiting for end of request line&quot;.
</I>
No lie there. It hasn't got near starting to search for URL yet. When
relaxed parser is enabled (ie by default) it has to find the end of the
request-line first and work backwards. It found characters that are
invalid anywhere in the HTTP first-line / request-line before it found
the LF. It just happens that they are in the URI portion of the
request-line.
 It would report the same thing on receiving &quot;GET / HTTP/1.0|\r\n&quot;

&gt;<i> 
</I>&gt;<i> If you prefer the &quot;waiting for the end of the URI&quot; description of the
</I>&gt;<i> broken state (where the complete URI, the complete request line, and the
</I>&gt;<i> complete request are all available), I am not going to argue that it is
</I>&gt;<i> also inaccurate.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Attached is a patch that replaces the hang behaviour with an
</I>&gt;&gt;<i> invalid-request error page on standards compliant builds. But, when
</I>&gt;&gt;<i> --enable-http-violations is used it accepts the invalid characters we
</I>&gt;&gt;<i> know are in use and passes the request through as HTTP/0.9.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ... which does not work because the request does not actually use the
</I>&gt;<i> HTTP/0.9 format. You end up with:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Forwarding client request ... url=<A HREF="http://localhost:8080/path|with|unwise|charactersHTTP/1.1">http://localhost:8080/path|with|unwise|charactersHTTP/1.1</A>
</I>&gt;<i> 
</I>&gt;&gt;<i> GET /path|with|unwise|charactersHTTP/1.1 HTTP/1.1
</I>&gt;&gt;<i> Via: 0.9 protofroot (squid/4.0.0-BZR)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The trailing &quot; HTTP/1.1&quot; part of the request line is not a part of the
</I>&gt;<i> URI but your changes make it so.
</I>
Sorry. Attached is a patch which fixes that and resolves accel/intercept
issues with the mime block as well.



&gt;<i> 
</I>&gt;<i> Tokenizer cannot handle URIs with whitespaces directly, like your patch
</I>&gt;<i> attempts to do: Tokenizer alone cannot handle ambiguous grammars. To
</I>&gt;<i> handle such URIs well, you have two options IMO:
</I>&gt;<i> 
</I>&gt;<i> A. The old &quot;do it by hand&quot; way:
</I>&gt;<i> 
</I>&gt;<i>   0. Trim request line to remove trailing whitespace and CR*LF.
</I>&gt;<i>   1. Find the *last* whitespace on the trimmed request line.
</I>&gt;<i>   2. To get the request method and URI, apply the tokenizer to the
</I>&gt;<i>      request line prefix before that last whitespace.
</I>&gt;<i>   3. To get the protocol parts, apply the tokenizer to the
</I>&gt;<i>      request line suffix after that last whitespace.
</I>&gt;<i>   4. Make the code even messier to handle HTTP/0.9 cases if needed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> B. The new optimized and simplified &quot;optimistic Tokenizer&quot; way:
</I>&gt;<i> 
</I>&gt;<i> Here is a sketch:
</I>&gt;<i> 
</I>&gt;<i>     SBuf uri; // accumulates request URI characters
</I>&gt;<i>     if (!tok.prefix(uri, StrictUriChars))
</I>&gt;<i>         return false; // URI does not start with a valid character
</I>&gt;<i> 
</I>&gt;<i>     // in the order of correctness (and popularity!):
</I>&gt;<i>     const bool parsedSuffix =
</I>&gt;<i>         // canonical HTTP/1 format
</I>&gt;<i>         parseCanonicalReqLineTail(uri, tok) ||
</I>&gt;<i>         // HTTP/1 format but with bad characters in URI
</I>&gt;<i>         parseBadUriReqLineTail(uri, tok) ||
</I>&gt;<i>         // HTTP/1 format but with bad characters and spaces in URI
</I>&gt;<i>         parseSpacedReqLineTail(uri, tok) ||
</I>&gt;<i>         // HTTP/0 format (without the protocol part at all)
</I>&gt;<i>         parseHttpZeroReqLineTail(uri, tok);
</I>&gt;<i> 
</I>&gt;<i>     Assert(parsedSuffix); // parseHttpZeroReqLineTail() cannot fail
</I>&gt;<i>     ...
</I>
C. locate LF character and parse in reverse. HTTP-Version label, WSP
then remainder is URI.


(B) is Interesting alternative to what we have now (C). Although you are
missing the relaxed vs strict characters which the RFC mandates (for
both URI and whitspace separately permutating). That complicates things
a bit.

If I can find some time I'll give this (B) style a bit of testing and
see how it matches up against the current code. Could prove faster on
very long URIs.

Amos
-------------- next part --------------
=== modified file 'src/http/one/Parser.cc'
--- src/http/one/Parser.cc	2015-04-10 11:02:44 +0000
+++ src/http/one/Parser.cc	2015-06-26 12:15:52 +0000
@@ -26,41 +26,42 @@
 }
 
 bool
 Http::One::Parser::skipLineTerminator(Http1::Tokenizer &amp;tok) const
 {
     static const SBuf crlf(&quot;\r\n&quot;);
     if (tok.skip(crlf))
         return true;
 
     if (Config.onoff.relaxed_header_parser &amp;&amp; tok.skipOne(CharacterSet::LF))
         return true;
 
     return false;
 }
 
 bool
 Http::One::Parser::grabMimeBlock(const char *which, const size_t limit)
 {
     // MIME headers block exist in (only) HTTP/1.x and ICY
     const bool expectMime = (msgProtocol_.protocol == AnyP::PROTO_HTTP &amp;&amp; msgProtocol_.major == 1) ||
-                            msgProtocol_.protocol == AnyP::PROTO_ICY;
+                            msgProtocol_.protocol == AnyP::PROTO_ICY ||
+                            hackExpectsMime_;
 
     if (expectMime) {
         /* NOTE: HTTP/0.9 messages do not have a mime header block.
          *       So the rest of the code will need to deal with '0'-byte headers
          *       (ie, none, so don't try parsing em)
          */
         // XXX: c_str() reallocates. performance regression.
         if (SBuf::size_type mimeHeaderBytes = headersEnd(buf_.c_str(), buf_.length())) {
 
             // Squid could handle these headers, but admin does not want to
             if (firstLineSize() + mimeHeaderBytes &gt;= limit) {
                 debugs(33, 5, &quot;Too large &quot; &lt;&lt; which);
                 parseStatusCode = Http::scHeaderTooLarge;
                 buf_.consume(mimeHeaderBytes);
                 parsingStage_ = HTTP_PARSE_DONE;
                 return false;
             }
 
             mimeHeaderBlock_ = buf_.consume(mimeHeaderBytes);
             debugs(74, 5, &quot;mime header (0-&quot; &lt;&lt; mimeHeaderBytes &lt;&lt; &quot;) {&quot; &lt;&lt; mimeHeaderBlock_ &lt;&lt; &quot;}&quot;);

=== modified file 'src/http/one/Parser.h'
--- src/http/one/Parser.h	2015-06-09 01:59:58 +0000
+++ src/http/one/Parser.h	2015-06-26 12:02:35 +0000
@@ -24,41 +24,41 @@
     HTTP_PARSE_CHUNK_SZ,  ///&lt; HTTP/1.1 chunked encoding chunk-size
     HTTP_PARSE_CHUNK_EXT, ///&lt; HTTP/1.1 chunked encoding chunk-ext
     HTTP_PARSE_CHUNK,     ///&lt; HTTP/1.1 chunked encoding chunk-data
     HTTP_PARSE_MIME,      ///&lt; HTTP/1 mime-header block
     HTTP_PARSE_DONE       ///&lt; parsed a message header, or reached a terminal syntax error
 };
 
 /** HTTP/1.x protocol parser
  *
  * Works on a raw character I/O buffer and tokenizes the content into
  * the major CRLF delimited segments of an HTTP/1 procotol message:
  *
  * \item first-line (request-line / simple-request / status-line)
  * \item mime-header 0*( header-name ':' SP field-value CRLF)
  */
 class Parser : public RefCountable
 {
 public:
     typedef SBuf::size_type size_type;
 
-    Parser() : parseStatusCode(Http::scNone), parsingStage_(HTTP_PARSE_NONE) {}
+    Parser() : parseStatusCode(Http::scNone), parsingStage_(HTTP_PARSE_NONE), hackExpectsMime_(false) {}
     virtual ~Parser() {}
 
     /// Set this parser back to a default state.
     /// Will DROP any reference to a buffer (does not free).
     virtual void clear() = 0;
 
     /// attempt to parse a message from the buffer
     /// \retval true if a full message was found and parsed
     /// \retval false if incomplete, invalid or no message was found
     virtual bool parse(const SBuf &amp;aBuf) = 0;
 
     /** Whether the parser is waiting on more data to complete parsing a message.
      * Use to distinguish between incomplete data and error results
      * when parse() returns false.
      */
     bool needsMoreData() const {return parsingStage_!=HTTP_PARSE_DONE;}
 
     /// size in bytes of the first line including CRLF terminator
     virtual size_type firstLineSize() const = 0;
 
@@ -114,27 +114,30 @@
      *                mimeHeaderBlock_ has been updated and buf_ consumed.
      *
      * \retval false  An error occured, or no mime terminator found within limit.
      */
     bool grabMimeBlock(const char *which, const size_t limit);
 
     /// RFC 7230 section 2.6 - 7 magic octets
     static const SBuf Http1magic;
 
     /// bytes remaining to be parsed
     SBuf buf_;
 
     /// what stage the parser is currently up to
     ParseState parsingStage_;
 
     /// what protocol label has been found in the first line (if any)
     AnyP::ProtocolVersion msgProtocol_;
 
     /// buffer holding the mime headers (if any)
     SBuf mimeHeaderBlock_;
+
+    /// Whether the invalid HTTP as HTTP/0.9 hack expects a mime header block
+    bool hackExpectsMime_;
 };
 
 } // namespace One
 } // namespace Http
 
 #endif /*  _SQUID_SRC_HTTP_ONE_PARSER_H */
 

=== modified file 'src/http/one/RequestParser.cc'
--- src/http/one/RequestParser.cc	2015-04-10 11:02:44 +0000
+++ src/http/one/RequestParser.cc	2015-06-26 12:02:28 +0000
@@ -244,109 +244,166 @@
  * \retval  0  more data is needed to complete the parse
  */
 int
 Http::One::RequestParser::parseRequestFirstLine()
 {
     Http1::Tokenizer tok(buf_);
 
     debugs(74, 5, &quot;parsing possible request: buf.length=&quot; &lt;&lt; buf_.length());
     debugs(74, DBG_DATA, buf_);
 
     // NP: would be static, except it need to change with reconfigure
     CharacterSet WspDelim = CharacterSet::SP; // strict parse only accepts SP
 
     if (Config.onoff.relaxed_header_parser) {
         // RFC 7230 section 3.5
         // tolerant parser MAY accept any of SP, HTAB, VT (%x0B), FF (%x0C), or bare CR
         // as whitespace between request-line fields
         WspDelim += CharacterSet::HTAB
                     + CharacterSet(&quot;VT,FF&quot;,&quot;\x0B\x0C&quot;)
                     + CharacterSet::CR;
+        debugs(74, 5, &quot;using Parser relaxed WSP characters&quot;);
     }
 
     // only search for method if we have not yet found one
     if (method_ == Http::METHOD_NONE) {
         const int res = parseMethodField(tok, WspDelim);
         if (res &lt; 1)
             return res;
         // else keep going...
     }
 
     // tolerant parser allows multiple whitespace characters between request-line fields
     if (Config.onoff.relaxed_header_parser) {
         const size_t garbage = tok.skipAll(WspDelim);
         if (garbage &gt; 0) {
             firstLineGarbage_ += garbage;
             buf_ = tok.remaining(); // re-checkpoint after garbage
         }
     }
     if (tok.atEnd()) {
         debugs(74, 5, &quot;Parser needs more data&quot;);
         return 0;
     }
 
     // from here on, we have two possible parse paths: whitespace tolerant, and strict
     if (Config.onoff.relaxed_header_parser) {
         // whitespace tolerant
 
+        int warnOnError = (Config.onoff.relaxed_header_parser &lt;= 0 ? DBG_IMPORTANT : 2);
+
         // NOTES:
         // * this would be static, except WspDelim changes with reconfigure
         // * HTTP-version charset is included by uriValidCharacters()
         // * terminal CR is included by WspDelim here in relaxed parsing
         CharacterSet LfDelim = uriValidCharacters() + WspDelim;
 
         // seek the LF character, then tokenize the line in reverse
         SBuf line;
         if (tok.prefix(line, LfDelim) &amp;&amp; tok.skip('\n')) {
             Http1::Tokenizer rTok(line);
             SBuf nil;
             (void)rTok.suffix(nil,CharacterSet::CR); // optional CR in terminator
             SBuf digit;
             if (rTok.suffix(digit,CharacterSet::DIGIT) &amp;&amp; rTok.skipSuffix(Http1magic) &amp;&amp; rTok.suffix(nil,WspDelim)) {
                 uri_ = rTok.remaining();
                 msgProtocol_ = Http::ProtocolVersion(1, (*digit.rawContent() - '0'));
                 if (uri_.isEmpty()) {
-                    debugs(33, 5, &quot;invalid request-line. missing URL&quot;);
+                    debugs(33, warnOnError, &quot;invalid request-line. missing URL&quot;);
                     parseStatusCode = Http::scBadRequest;
                     return -1;
                 }
 
                 parseStatusCode = Http::scOkay;
                 buf_ = tok.remaining(); // incremental parse checkpoint
                 return 1;
 
             } else if (method_ == Http::METHOD_GET) {
                 // RFC 1945 - for GET the line terminator may follow URL instead of a delimiter
                 debugs(33, 5, &quot;HTTP/0.9 syntax request-line detected&quot;);
                 msgProtocol_ = Http::ProtocolVersion(0,9);
                 static const SBuf cr(&quot;\r&quot;,1);
                 uri_ = line.trim(cr,false,true);
                 parseStatusCode = Http::scOkay;
                 buf_ = tok.remaining(); // incremental parse checkpoint
                 return 1;
             }
 
-            debugs(33, 5, &quot;invalid request-line. not HTTP&quot;);
+            debugs(33, warnOnError, &quot;invalid request-line. not HTTP&quot;);
             parseStatusCode = Http::scBadRequest;
             return -1;
         }
 
+        if (!tok.atEnd()) {
+
+#if USE_HTTP_VIOLATIONS
+            // invalid character somewhere in the line.
+            // As long as we can find the LF, accept the characters
+            // which we know are invalid in any URI, but actively used
+            LfDelim.add('\0'); // Java
+            LfDelim.add(' ');  // IIS
+            LfDelim.add('\&quot;'); // Bing
+            LfDelim.add('\\'); // MSIE, Firefox
+            LfDelim.add('|');  // Amazon
+
+            // reset the tokenizer from anything the above did, then seek the LF character.
+            tok.reset(buf_);
+
+            if (tok.prefix(line, LfDelim) &amp;&amp; tok.skip('\n')) {
+
+                Http1::Tokenizer rTok(line);
+
+                // strip terminating CR (if any)
+                SBuf nil;
+                (void)rTok.suffix(nil,CharacterSet::CR); // optional CR in terminator
+                line = rTok.remaining();
+
+                // strip terminating 'WSP HTTP-version' (if any)
+                if (rTok.suffix(nil,CharacterSet::DIGIT) &amp;&amp; rTok.skipSuffix(Http1magic) &amp;&amp; rTok.suffix(nil,WspDelim)) {
+                    hackExpectsMime_ = true; // client thinks its speaking HTTP, probably sent a mime block.
+                    uri_ = rTok.remaining();
+                } else
+                    uri_ = line; // no HTTP/1.x label found. Use the whole line.
+
+                if (uri_.isEmpty()) {
+                    debugs(33, warnOnError, &quot;invalid request-line. missing URL&quot;);
+                    parseStatusCode = Http::scBadRequest;
+                    return -1;
+                }
+
+                debugs(33, warnOnError, &quot;invalid request-line. treating as HTTP/0.9&quot; &lt;&lt; (hackExpectsMime_?&quot; (with mime)&quot;:&quot;&quot;));
+                msgProtocol_ = Http::ProtocolVersion(0,9);
+                parseStatusCode = Http::scOkay;
+                buf_ = tok.remaining(); // incremental parse checkpoint
+                return 1;
+
+            } else if (tok.atEnd()) {
+                debugs(74, 5, &quot;Parser needs more data&quot;);
+                return 0;
+            }
+            // else, drop back to invalid request-line handling
+#endif
+            const SBuf t = tok.remaining();
+            debugs(33, warnOnError, &quot;invalid request-line characters.&quot; &lt;&lt; Raw(&quot;data&quot;, t.rawContent(), t.length()));
+            parseStatusCode = Http::scBadRequest;
+            return -1;
+        }
         debugs(74, 5, &quot;Parser needs more data&quot;);
         return 0;
     }
     // else strict non-whitespace tolerant parse
 
     // only search for request-target (URL) if we have not yet found one
     if (uri_.isEmpty()) {
         const int res = parseUriField(tok);
         if (res &lt; 1 || msgProtocol_.protocol == AnyP::PROTO_HTTP)
             return res;
         // else keep going...
     }
 
     if (tok.atEnd()) {
         debugs(74, 5, &quot;Parser needs more data&quot;);
         return 0;
     }
 
     // HTTP/1 version suffix (protocol magic) followed by CR*LF
     if (msgProtocol_.protocol == AnyP::PROTO_NONE) {

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002464.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
	<LI>Next message: <A HREF="002468.html">[squid-dev] [PATCH] Temporary fix to restore compatibility with Amazon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2466">[ date ]</a>
              <a href="thread.html#2466">[ thread ]</a>
              <a href="subject.html#2466">[ subject ]</a>
              <a href="author.html#2466">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
