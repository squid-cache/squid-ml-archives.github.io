<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Refactor path strings into class URL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Refactor%20path%20strings%20into%20class%20URL&In-Reply-To=%3C558FD8D2.4020405%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="002470.html">
   <LINK REL="Next"  HREF="002476.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Refactor path strings into class URL</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Refactor%20path%20strings%20into%20class%20URL&In-Reply-To=%3C558FD8D2.4020405%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Refactor path strings into class URL">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Jun 28 11:21:54 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002470.html">[squid-dev] [PATCH] SBuf case-change operations are safe against OutOfBoundsEception
</A></li>
        <LI>Next message: <A HREF="002476.html">[squid-dev] [PATCH] Crypto-NG: Use Security::PeerOptions for listening port TLS settings
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2471">[ date ]</a>
              <a href="thread.html#2471">[ thread ]</a>
              <a href="subject.html#2471">[ subject ]</a>
              <a href="author.html#2471">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This takes another step towards bug 1961 closure by shuffling the
HttpRequest::urlpath member into class URL.

These changes appear to work nicely. But I have not been able to test
all code paths that have logic change so a second pair of eyes on it
would be appreciated.

Amos
-------------- next part --------------
=== modified file 'src/HttpRequest.cc'
--- src/HttpRequest.cc	2015-06-09 06:14:43 +0000
+++ src/HttpRequest.cc	2015-06-28 06:32:00 +0000
@@ -44,49 +44,48 @@
 HttpRequest::HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
     HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE &lt;&lt; &quot;constructed, this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; ++id);
     init();
     initHTTP(aMethod, aProtocol, aUrlpath);
 }
 
 HttpRequest::~HttpRequest()
 {
     clean();
     debugs(93,7, HERE &lt;&lt; &quot;destructed, this=&quot; &lt;&lt; this);
 }
 
 void
 HttpRequest::initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
 {
     method = aMethod;
     url.setScheme(aProtocol);
-    urlpath = aUrlpath;
+    url.path(aUrlpath);
 }
 
 void
 HttpRequest::init()
 {
     method = Http::METHOD_NONE;
     url.clear();
-    urlpath = NULL;
 #if USE_AUTH
     auth_user_request = NULL;
 #endif
     canonical = NULL;
     memset(&amp;flags, '\0', sizeof(flags));
     range = NULL;
     ims = -1;
     imslen = 0;
     lastmod = -1;
     client_addr.setEmpty();
     my_addr.setEmpty();
     body_pipe = NULL;
     // hier
     dnsWait = -1;
     errType = ERR_NONE;
     errDetail = ERR_DETAIL_NONE;
     peer_login = NULL;      // not allocated/deallocated by this class
     peer_domain = NULL;     // not allocated/deallocated by this class
     peer_host = NULL;
     vary_headers = NULL;
@@ -109,41 +108,40 @@
     icapHistory_ = NULL;
 #endif
     rangeOffsetLimit = -2; //a value of -2 means not checked yet
     forcedBodyContinuation = false;
 }
 
 void
 HttpRequest::clean()
 {
     // we used to assert that the pipe is NULL, but now the request only
     // points to a pipe that is owned and initiated by another object.
     body_pipe = NULL;
 #if USE_AUTH
     auth_user_request = NULL;
 #endif
     safe_free(canonical);
 
     safe_free(vary_headers);
 
     url.clear();
-    urlpath.clean();
 
     header.clean();
 
     if (cache_control) {
         delete cache_control;
         cache_control = NULL;
     }
 
     if (range) {
         delete range;
         range = NULL;
     }
 
     myportname.clean();
 
     notes = NULL;
 
     tag.clean();
 #if USE_AUTH
     extacl_user.clean();
@@ -156,52 +154,55 @@
     etag.clean();
 
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
 #endif
 #if ICAP_CLIENT
     icapHistory_ = NULL;
 #endif
 }
 
 void
 HttpRequest::reset()
 {
     clean();
     init();
 }
 
 HttpRequest *
 HttpRequest::clone() const
 {
-    HttpRequest *copy = new HttpRequest(method, url.getScheme(), urlpath.termedBuf());
+    HttpRequest *copy = new HttpRequest();
+    copy-&gt;method = method;
     // TODO: move common cloning clone to Msg::copyTo() or copy ctor
     copy-&gt;header.append(&amp;header);
     copy-&gt;hdrCacheInit();
     copy-&gt;hdr_sz = hdr_sz;
     copy-&gt;http_ver = http_ver;
     copy-&gt;pstate = pstate; // TODO: should we assert a specific state here?
     copy-&gt;body_pipe = body_pipe;
 
+    copy-&gt;url.setScheme(url.getScheme());
     copy-&gt;url.userInfo(url.userInfo());
     copy-&gt;url.host(url.host());
     copy-&gt;url.port(url.port());
+    copy-&gt;url.path(url.path());
 
     // urlPath handled in ctor
     copy-&gt;canonical = canonical ? xstrdup(canonical) : NULL;
 
     // range handled in hdrCacheInit()
     copy-&gt;ims = ims;
     copy-&gt;imslen = imslen;
     copy-&gt;hier = hier; // Is it safe to copy? Should we?
 
     copy-&gt;errType = errType;
 
     // XXX: what to do with copy-&gt;peer_login?
 
     copy-&gt;lastmod = lastmod;
     copy-&gt;etag = etag;
     copy-&gt;vary_headers = vary_headers ? xstrdup(vary_headers) : NULL;
     // XXX: what to do with copy-&gt;peer_domain?
 
     copy-&gt;tag = tag;
     copy-&gt;extacl_log = extacl_log;
@@ -355,65 +356,65 @@
         hdrCacheInit();
 
     return result;
 }
 
 /* swaps out request using httpRequestPack */
 void
 HttpRequest::swapOut(StoreEntry * e)
 {
     assert(e);
     e-&gt;buffer();
     pack(e);
 }
 
 /* packs request-line and headers, appends &lt;crlf&gt; terminator */
 void
 HttpRequest::pack(Packable * p)
 {
     assert(p);
     /* pack request-line */
-    p-&gt;appendf(SQUIDSBUFPH &quot; &quot; SQUIDSTRINGPH &quot; HTTP/%d.%d\r\n&quot;,
-               SQUIDSBUFPRINT(method.image()), SQUIDSTRINGPRINT(urlpath),
+    p-&gt;appendf(SQUIDSBUFPH &quot; &quot; SQUIDSBUFPH &quot; HTTP/%d.%d\r\n&quot;,
+               SQUIDSBUFPRINT(method.image()), SQUIDSBUFPRINT(url.path()),
                http_ver.major, http_ver.minor);
     /* headers */
     header.packInto(p);
     /* trailer */
     p-&gt;append(&quot;\r\n&quot;, 2);
 }
 
 /*
  * A wrapper for debugObj()
  */
 void
 httpRequestPack(void *obj, Packable *p)
 {
     HttpRequest *request = static_cast&lt;HttpRequest*&gt;(obj);
     request-&gt;pack(p);
 }
 
 /* returns the length of request line + headers + crlf */
 int
-HttpRequest::prefixLen()
+HttpRequest::prefixLen() const
 {
     return method.image().length() + 1 +
-           urlpath.size() + 1 +
+           url.path().length() + 1 +
            4 + 1 + 3 + 2 +
            header.len + 2;
 }
 
 /* sync this routine when you update HttpRequest struct */
 void
 HttpRequest::hdrCacheInit()
 {
     HttpMsg::hdrCacheInit();
 
     assert(!range);
     range = header.getRange();
 }
 
 #if ICAP_CLIENT
 Adaptation::Icap::History::Pointer
 HttpRequest::icapHistory() const
 {
     if (!icapHistory_) {
         if (Log::TheConfig.hasIcapToken || IcapLogfileStatus == LOG_ENABLE) {
@@ -474,57 +475,53 @@
 {
     if (errType || errDetail)
         debugs(11, 5, HERE &lt;&lt; &quot;old error details: &quot; &lt;&lt; errType &lt;&lt; '/' &lt;&lt; errDetail);
     debugs(11, 5, HERE &lt;&lt; &quot;current error details: &quot; &lt;&lt; aType &lt;&lt; '/' &lt;&lt; aDetail);
     // checking type and detail separately may cause inconsistency, but
     // may result in more details available if they only become available later
     if (!errType)
         errType = aType;
     if (!errDetail)
         errDetail = aDetail;
 }
 
 void
 HttpRequest::clearError()
 {
     debugs(11, 7, HERE &lt;&lt; &quot;old error details: &quot; &lt;&lt; errType &lt;&lt; '/' &lt;&lt; errDetail);
     errType = ERR_NONE;
     errDetail = ERR_DETAIL_NONE;
 }
 
-const char *HttpRequest::packableURI(bool full_uri) const
+void
+HttpRequest::packFirstLineInto(Packable * p, bool full_uri) const
 {
+    SBuf tmp;
     if (full_uri)
-        return urlCanonical((HttpRequest*)this);
-
-    if (urlpath.size())
-        return urlpath.termedBuf();
+        tmp = urlCanonical((HttpRequest*)this);
+    else
+        tmp = url.path();
 
-    return &quot;/&quot;;
-}
-
-void HttpRequest::packFirstLineInto(Packable * p, bool full_uri) const
-{
     // form HTTP request-line
-    p-&gt;appendf(SQUIDSBUFPH &quot; %s HTTP/%d.%d\r\n&quot;,
+    p-&gt;appendf(SQUIDSBUFPH &quot; &quot; SQUIDSBUFPH &quot; HTTP/%d.%d\r\n&quot;,
                SQUIDSBUFPRINT(method.image()),
-               packableURI(full_uri),
+               SQUIDSBUFPRINT(tmp),
                http_ver.major, http_ver.minor);
 }
 
 /*
  * Indicate whether or not we would expect an entity-body
  * along with this request
  */
 bool
 HttpRequest::expectingBody(const HttpRequestMethod &amp;, int64_t &amp;theSize) const
 {
     bool expectBody = false;
 
     /*
      * Note: Checks for message validity is in clientIsContentLengthValid().
      * this just checks if a entity-body is expected based on HTTP message syntax
      */
     if (header.chunked()) {
         expectBody = true;
         theSize = -1;
     } else if (content_length &gt;= 0) {

=== modified file 'src/HttpRequest.h'
--- src/HttpRequest.h	2015-06-09 06:14:43 +0000
+++ src/HttpRequest.h	2015-06-15 03:50:46 +0000
@@ -99,42 +99,40 @@
 
     void init();
 
 public:
     HttpRequestMethod method;
     URL url; ///&lt; the request URI
 
 private:
 #if USE_ADAPTATION
     mutable Adaptation::History::Pointer adaptHistory_; ///&lt; per-HTTP transaction info
 #endif
 #if ICAP_CLIENT
     mutable Adaptation::Icap::History::Pointer icapHistory_; ///&lt; per-HTTP transaction info
 #endif
 
 public:
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
 
-    String urlpath;
-
     char *canonical;
 
     /**
      * If defined, store_id_program mapped the request URL to this ID.
      * Store uses this ID (and not the URL) to find and store entries,
      * avoiding caching duplicate entries when different URLs point to
      * &quot;essentially the same&quot; cachable resource.
      */
     String store_id;
 
     RequestFlags flags;
 
     HttpHdrRange *range;
 
     time_t ims;
 
     int imslen;
 
     Ip::Address client_addr;
 
@@ -179,70 +177,68 @@
     String x_forwarded_for_iterator; /* XXX a list of IP addresses */
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
     /// A strong etag of the cached entry. Used for refreshing that entry.
     String etag;
 
     /// whether we have responded with HTTP 100 or FTP 150 already
     bool forcedBodyContinuation;
 
 public:
     bool multipartRangeRequest() const;
 
     bool parseFirstLine(const char *start, const char *end);
 
     bool parseHeader(Http1::RequestParser &amp;hp); // TODO move this function to the parser
 
     virtual bool expectingBody(const HttpRequestMethod&amp; unused, int64_t&amp;) const;
 
     bool bodyNibbled() const; // the request has a [partially] consumed body
 
-    int prefixLen();
+    int prefixLen() const;
 
     void swapOut(StoreEntry * e);
 
     void pack(Packable * p);
 
     static void httpRequestPack(void *obj, Packable *p);
 
     static HttpRequest * CreateFromUrlAndMethod(char * url, const HttpRequestMethod&amp; method);
 
     static HttpRequest * CreateFromUrl(char * url);
 
     ConnStateData *pinnedConnection();
 
     /**
      * Returns the current StoreID for the request as a nul-terminated char*.
      * Always returns the current id for the request
      * (either the request canonical url or modified ID by the helper).
      * Does not return NULL.
      */
     const char *storeId();
 
     /**
      * The client connection manager, if known;
      * Used for any response actions needed directly to the client.
      * ie 1xx forwarding or connection pinning state changes
      */
     CbcPointer&lt;ConnStateData&gt; clientConnectionManager;
 
     /// forgets about the cached Range header (for a reason)
     void ignoreRange(const char *reason);
     int64_t getRangeOffsetLimit(); /* the result of this function gets cached in rangeOffsetLimit */
 
 private:
-    const char *packableURI(bool full_uri) const;
-
     mutable int64_t rangeOffsetLimit;  /* caches the result of getRangeOffsetLimit */
 
 protected:
     virtual void packFirstLineInto(Packable * p, bool full_uri) const;
 
     virtual bool sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error);
 
     virtual void hdrCacheInit();
 
     virtual bool inheritProperties(const HttpMsg *aMsg);
 };
 
 #endif /* SQUID_HTTPREQUEST_H */
 

=== modified file 'src/URL.h'
--- src/URL.h	2015-06-09 06:14:43 +0000
+++ src/URL.h	2015-06-28 06:35:45 +0000
@@ -1,75 +1,84 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_URL_H
 #define SQUID_SRC_URL_H
 
 #include &quot;anyp/UriScheme.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;rfc2181.h&quot;
 #include &quot;SBuf.h&quot;
 
+#include &lt;iosfwd&gt;
+
 /**
  * The URL class represents a Uniform Resource Location
  *
  * Governed by RFC 3986
  */
 class URL
 {
     MEMPROXY_CLASS(URL);
 
 public:
     URL() : scheme_(), hostIsNumeric_(false), port_(0) {*host_=0;}
     URL(AnyP::UriScheme const &amp;aScheme) : scheme_(aScheme), hostIsNumeric_(false), port_(0) {*host_=0;}
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
         hostIsNumeric_ = false;
         *host_ = 0;
         hostAddr_.setEmpty();
         port_ = 0;
         touch();
     }
     void touch(); ///&lt; clear the cached URI display forms
 
     AnyP::UriScheme const &amp; getScheme() const {return scheme_;}
 
     /// convert the URL scheme to that given
     void setScheme(const AnyP::ProtocolType &amp;p) {scheme_=p; touch();}
 
     void userInfo(const SBuf &amp;s) {userInfo_=s; touch();}
     const SBuf &amp;userInfo() const {return userInfo_;}
 
     void host(const char *src);
     const char *host(void) const {return host_;}
     int hostIsNumeric(void) const {return hostIsNumeric_;}
     Ip::Address const &amp; hostIP(void) const {return hostAddr_;}
 
     void port(unsigned short p) {port_=p; touch();}
     unsigned short port() const {return port_;}
 
+    void path(const char *p) {path_=p; touch();}
+    void path(const SBuf &amp;p) {path_=p; touch();}
+    const SBuf &amp;path() const;
+
+    /// the static '/' default URL-path
+    static const SBuf &amp;SlashPath();
+
     /// the static '*' pseudo-URL
     static const SBuf &amp;Asterisk();
 
     /**
      * The authority-form URI for currently stored values.
      *
      * As defined by RFC 7230 section 5.3.3 this form omits the
      * userinfo@ field from RFC 3986 defined authority segment.
      *
      * \param requirePort when true the port will be included, otherwise
      *                    port will be elided when it is the default for
      *                    the current scheme.
      */
     SBuf &amp;authority(bool requirePort = false) const;
 
 private:
     /**
      \par
      * The scheme of this URL. This has the 'type code' smell about it.
      * In future we may want to make the methods that dispatch based on
@@ -84,45 +93,58 @@
      * class for each manner of treating the scheme : a Hierarchical URL, a
      * non-hierarchical URL etc.
      \par
      * Deferring the decision, its a type code for now. RBC 20060507.
      \par
      * In order to make taking any of these routes easy, scheme is private
      * and immutable, only settable at construction time,
      */
     AnyP::UriScheme scheme_;
 
     SBuf userInfo_; // aka 'URL-login'
 
     // XXX: uses char[] instead of SBUf to reduce performance regressions
     //      from c_str() since most code using this is not yet using SBuf
     char host_[SQUIDHOSTNAMELEN];   ///&lt; string representation of the URI authority name or IP
     bool hostIsNumeric_;            ///&lt; whether the authority 'host' is a raw-IP
     Ip::Address hostAddr_;          ///&lt; binary representation of the URI authority if it is a raw-IP
 
     unsigned short port_;   ///&lt; URL port
 
+    // XXX: for now includes query-string.
+    SBuf path_;     ///&lt; URL path segment
+
     // pre-assembled URL forms
     mutable SBuf authorityHttp_;     ///&lt; RFC 7230 section 5.3.3 authority, maybe without default-port
     mutable SBuf authorityWithPort_; ///&lt; RFC 7230 section 5.3.3 authority with explicit port
+    mutable SBuf canonical_;         ///&lt; full absolute-URI
 };
 
+inline std::ostream &amp;
+operator &lt;&lt;(std::ostream &amp;os, const URL &amp;url)
+{
+    if (const char *sc = url.getScheme().c_str())
+        os &lt;&lt; sc &lt;&lt; &quot;:&quot;;
+    os &lt;&lt; &quot;//&quot; &lt;&lt; url.authority() &lt;&lt; url.path();
+    return os;
+}
+
 class HttpRequest;
 class HttpRequestMethod;
 
 AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
 void urlInitialize(void);
 HttpRequest *urlParse(const HttpRequestMethod&amp;, char *, HttpRequest *request = NULL);
 const char *urlCanonical(HttpRequest *);
 char *urlCanonicalClean(const HttpRequest *);
 const char *urlCanonicalFakeHttps(const HttpRequest * request);
 bool urlIsRelative(const char *);
 char *urlMakeAbsolute(const HttpRequest *, const char *);
 char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
 char *urlInternal(const char *dir, const char *name);
 
 /**
  * matchDomainName() compares a hostname (usually extracted from traffic)
  * with a domainname (usually from an ACL) according to the following rules:
  *
  *    HOST      |   DOMAIN    |   MATCH?
  * -------------|-------------|------

=== modified file 'src/acl/UrlPath.cc'
--- src/acl/UrlPath.cc	2015-01-13 07:25:36 +0000
+++ src/acl/UrlPath.cc	2015-06-09 11:52:48 +0000
@@ -1,38 +1,39 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Checklist.h&quot;
 #include &quot;acl/RegexData.h&quot;
 #include &quot;acl/UrlPath.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;rfc1738.h&quot;
 
 int
 ACLUrlPathStrategy::match (ACLData&lt;char const *&gt; * &amp;data, ACLFilledChecklist *checklist, ACLFlags &amp;)
 {
-    if (!checklist-&gt;request-&gt;urlpath.size())
+    if (checklist-&gt;request-&gt;url.path().isEmpty())
         return -1;
 
-    char *esc_buf = xstrdup(checklist-&gt;request-&gt;urlpath.termedBuf());
+    SBuf tmp = checklist-&gt;request-&gt;url.path();
+    char *esc_buf = xstrndup(tmp.rawContent(), tmp.length());
     rfc1738_unescape(esc_buf);
     int result = data-&gt;match(esc_buf);
-    safe_free(esc_buf);
+    xfree(esc_buf);
     return result;
 }
 
 ACLUrlPathStrategy *
 ACLUrlPathStrategy::Instance()
 {
     return &amp;Instance_;
 }
 
 ACLUrlPathStrategy ACLUrlPathStrategy::Instance_;
 

=== modified file 'src/adaptation/Service.cc'
--- src/adaptation/Service.cc	2015-01-13 07:25:36 +0000
+++ src/adaptation/Service.cc	2015-06-14 19:02:01 +0000
@@ -32,41 +32,41 @@
     return probed() &amp;&amp; !up();
 }
 
 bool
 Adaptation::Service::wants(const ServiceFilter &amp;filter) const
 {
     if (cfg().method != filter.method)
         return false;
 
     if (cfg().point != filter.point)
         return false;
 
     // sending a message to a broken service is likely to cause errors
     if (cfg().bypass &amp;&amp; broken())
         return false;
 
     if (up()) {
         // Sending a message to a service that does not want it is useless.
         // note that we cannot check wantsUrl for service that is not &quot;up&quot;
         // note that even essential services are skipped on unwanted URLs!
-        return wantsUrl(filter.request-&gt;urlpath);
+        return wantsUrl(filter.request-&gt;url.path());
     }
 
     // The service is down and is either not bypassable or not probed due
     // to the bypass &amp;&amp; broken() test above. Thus, we want to use it!
     return true;
 }
 
 Adaptation::Services &amp;
 Adaptation::AllServices()
 {
     static Services *TheServices = new Services;
     return *TheServices;
 }
 
 Adaptation::ServicePointer
 Adaptation::FindService(const Service::Id&amp; key)
 {
     typedef Services::iterator SI;
     for (SI i = AllServices().begin(); i != AllServices().end(); ++i) {
         if ((*i)-&gt;cfg().key == key)

=== modified file 'src/adaptation/Service.h'
--- src/adaptation/Service.h	2015-01-13 07:25:36 +0000
+++ src/adaptation/Service.h	2015-06-14 19:14:27 +0000
@@ -28,41 +28,41 @@
 // specific adaptation mechanisms extend this class
 class Service: public RefCountable
 {
 public:
     typedef RefCount&lt;Service&gt; Pointer;
     typedef String Id;
 
 public:
     explicit Service(const ServiceConfigPointer &amp;aConfig);
     virtual ~Service();
 
     virtual bool probed() const = 0; // see comments above
     virtual bool broken() const;
     virtual bool up() const = 0; // see comments above
 
     virtual Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &amp;alp) = 0;
 
     bool wants(const ServiceFilter &amp;filter) const;
 
     // the methods below can only be called on an up() service
-    virtual bool wantsUrl(const String &amp;urlPath) const = 0;
+    virtual bool wantsUrl(const SBuf &amp;urlPath) const = 0;
 
     // called by transactions to report service failure
     virtual void noteFailure() = 0;
 
     const ServiceConfig &amp;cfg() const { return *theConfig; }
 
     virtual void finalize(); // called after creation
 
     /// called when removed from the config; the service will be
     /// auto-destroyed when the last refcounting user leaves
     virtual void detach() = 0;
     /// whether detached() was called
     virtual bool detached() const = 0;
 
 protected:
     ServiceConfig &amp;writeableCfg() { return *theConfig; }
 
 private:
     ServiceConfigPointer theConfig;
 };

=== modified file 'src/adaptation/ecap/ServiceRep.cc'
--- src/adaptation/ecap/ServiceRep.cc	2015-01-13 07:25:36 +0000
+++ src/adaptation/ecap/ServiceRep.cc	2015-06-14 19:24:48 +0000
@@ -220,44 +220,46 @@
         return false; // we cannot handle the problem; the caller may escalate
 
     // make up() false, preventing new adaptation requests and enabling bypass
     theService.reset();
     debugs(93, level, &quot;WARNING: &quot; &lt;&lt; kind &lt;&lt; &quot; eCAP service is &quot; &lt;&lt;
            &quot;down after initialization failure: &quot; &lt;&lt; cfg().uri);
 
     return true; // tell the caller to ignore the problem because we handled it
 }
 
 bool Adaptation::Ecap::ServiceRep::probed() const
 {
     return true; // we &quot;probe&quot; the adapter in finalize().
 }
 
 bool Adaptation::Ecap::ServiceRep::up() const
 {
     return theService != NULL;
 }
 
-bool Adaptation::Ecap::ServiceRep::wantsUrl(const String &amp;urlPath) const
+bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &amp;urlPath) const
 {
     Must(up());
-    return theService-&gt;wantsUrl(urlPath.termedBuf());
+    SBuf nonConstUrlPath = urlPath;
+    // c_str() reallocates and terminates for libecap API
+    return theService-&gt;wantsUrl(nonConstUrlPath.c_str());
 }
 
 Adaptation::Initiate *
 Adaptation::Ecap::ServiceRep::makeXactLauncher(HttpMsg *virgin,
         HttpRequest *cause, AccessLogEntry::Pointer &amp;alp)
 {
     Must(up());
 
     // register now because (a) we need EventLoop::Running and (b) we do not
     // want to add more main loop overheads unless an async service is used.
     static AsyncEngine *TheEngine = NULL;
     if (AsyncServices.size() &amp;&amp; !TheEngine &amp;&amp; EventLoop::Running) {
         TheEngine = new Engine;
         EventLoop::Running-&gt;registerEngine(TheEngine);
         debugs(93, 3, &quot;asyncs: &quot; &lt;&lt; AsyncServices.size() &lt;&lt; ' ' &lt;&lt; TheEngine);
     }
 
     XactionRep *rep = new XactionRep(virgin, cause, alp, Pointer(this));
     XactionRep::AdapterXaction x(theService-&gt;makeXaction(rep));
     rep-&gt;master(x);

=== modified file 'src/adaptation/ecap/ServiceRep.h'
--- src/adaptation/ecap/ServiceRep.h	2015-01-13 07:25:36 +0000
+++ src/adaptation/ecap/ServiceRep.h	2015-06-14 19:07:28 +0000
@@ -21,41 +21,41 @@
 namespace Ecap
 {
 
 /* The eCAP service representative maintains information about a single eCAP
    service that Squid communicates with. One eCAP module may register many
    eCAP services. */
 
 class ServiceRep : public Adaptation::Service
 {
 public:
     explicit ServiceRep(const ServiceConfigPointer &amp;aConfig);
     virtual ~ServiceRep();
 
     typedef libecap::shared_ptr&lt;libecap::adapter::Service&gt; AdapterService;
 
     /* Adaptation::Service API */
     virtual void finalize();
     virtual bool probed() const;
     virtual bool up() const;
     virtual Adaptation::Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &amp;alp);
-    virtual bool wantsUrl(const String &amp;urlPath) const;
+    virtual bool wantsUrl(const SBuf &amp;urlPath) const;
     virtual void noteFailure();
     virtual const char *status() const;
     virtual void detach();
     virtual bool detached() const;
 
 protected:
     void tryConfigureAndStart();
     bool handleFinalizeFailure(const char *error);
 
 private:
     AdapterService theService; // the actual adaptation service we represent
     bool           isDetached;
 };
 
 /// register loaded eCAP module service
 void RegisterAdapterService(const ServiceRep::AdapterService&amp; adapterService);
 /// unregister loaded eCAP module service by service uri
 void UnregisterAdapterService(const String&amp; serviceUri);
 
 /// returns loaded eCAP module service by service uri

=== modified file 'src/adaptation/icap/ModXact.cc'
--- src/adaptation/icap/ModXact.cc	2015-06-01 21:41:37 +0000
+++ src/adaptation/icap/ModXact.cc	2015-06-28 06:37:43 +0000
@@ -1372,43 +1372,41 @@
         Adaptation::History::Pointer ah = request-&gt;adaptHistory(false);
         if (ah != NULL) {
             String name, value;
             if (ah-&gt;getXxRecord(name, value)) {
                 buf.appendf(SQUIDSTRINGPH &quot;: &quot; SQUIDSTRINGPH &quot;\r\n&quot;, SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
             }
         }
     }
 
     buf.append(&quot;Encapsulated: &quot;, 14);
 
     MemBuf httpBuf;
 
     httpBuf.init();
 
     // build HTTP request header, if any
     ICAP::Method m = s.method;
 
     // to simplify, we could assume that request is always available
 
-    String urlPath;
     if (request) {
-        urlPath = request-&gt;urlpath;
         if (ICAP::methodRespmod == m)
             encapsulateHead(buf, &quot;req-hdr&quot;, httpBuf, request);
         else if (ICAP::methodReqmod == m)
             encapsulateHead(buf, &quot;req-hdr&quot;, httpBuf, virgin.header);
     }
 
     if (ICAP::methodRespmod == m)
         if (const HttpMsg *prime = virgin.header)
             encapsulateHead(buf, &quot;res-hdr&quot;, httpBuf, prime);
 
     if (!virginBody.expected())
         buf.appendf(&quot;null-body=%d&quot;, (int) httpBuf.contentSize());
     else if (ICAP::methodReqmod == m)
         buf.appendf(&quot;req-body=%d&quot;, (int) httpBuf.contentSize());
     else
         buf.appendf(&quot;res-body=%d&quot;, (int) httpBuf.contentSize());
 
     buf.append(ICAP::crlf, 2); // terminate Encapsulated line
 
     if (preview.enabled()) {
@@ -1566,44 +1564,44 @@
 
     // pack polished HTTP header
     packHead(httpBuf, headClone.getRaw());
 
     // headClone unlocks and, hence, deletes the message we packed
 }
 
 void Adaptation::Icap::ModXact::packHead(MemBuf &amp;httpBuf, const HttpMsg *head)
 {
     head-&gt;packInto(&amp;httpBuf, true);
 }
 
 // decides whether to offer a preview and calculates its size
 void Adaptation::Icap::ModXact::decideOnPreview()
 {
     if (!TheConfig.preview_enable) {
         debugs(93, 5, HERE &lt;&lt; &quot;preview disabled by squid.conf&quot;);
         return;
     }
 
-    const String urlPath = virginRequest().urlpath;
+    const SBuf urlPath(virginRequest().url.path());
     size_t wantedSize;
     if (!service().wantsPreview(urlPath, wantedSize)) {
-        debugs(93, 5, HERE &lt;&lt; &quot;should not offer preview for &quot; &lt;&lt; urlPath);
+        debugs(93, 5, &quot;should not offer preview for &quot; &lt;&lt; urlPath);
         return;
     }
 
     // we decided to do preview, now compute its size
 
     // cannot preview more than we can backup
     size_t ad = min(wantedSize, TheBackupLimit);
 
     if (!virginBody.expected())
         ad = 0;
     else if (virginBody.knownSize())
         ad = min(static_cast&lt;uint64_t&gt;(ad), virginBody.size()); // not more than we have
 
     debugs(93, 5, HERE &lt;&lt; &quot;should offer &quot; &lt;&lt; ad &lt;&lt; &quot;-byte preview &quot; &lt;&lt;
            &quot;(service wanted &quot; &lt;&lt; wantedSize &lt;&lt; &quot;)&quot;);
 
     preview.enable(ad);
     Must(preview.enabled());
 }
 

=== modified file 'src/adaptation/icap/Options.cc'
--- src/adaptation/icap/Options.cc	2015-01-13 07:25:36 +0000
+++ src/adaptation/icap/Options.cc	2015-06-14 19:06:59 +0000
@@ -26,52 +26,53 @@
 {
     theTransfers.preview.name = &quot;Transfer-Preview&quot;;
     theTransfers.preview.kind = xferPreview;
     theTransfers.ignore.name = &quot;Transfer-Ignore&quot;;
     theTransfers.ignore.kind = xferIgnore;
     theTransfers.complete.name = &quot;Transfer-Complete&quot;;
     theTransfers.complete.kind = xferComplete;
 
     // Section 4.10.2 of RFC 3507 says that default is no Preview
     // TODO: provide a squid.conf option to overwrite the default
     theTransfers.byDefault = &amp;theTransfers.complete;
 }
 
 Adaptation::Icap::Options::~Options()
 {
 }
 
 // future optimization note: this method is called by ICAP ACL code at least
 // twice for each HTTP message to see if the message should be ignored. For any
 // non-ignored HTTP message, ICAP calls to check whether a preview is needed.
-Adaptation::Icap::Options::TransferKind Adaptation::Icap::Options::transferKind(const String &amp;urlPath) const
+Adaptation::Icap::Options::TransferKind
+Adaptation::Icap::Options::transferKind(const SBuf &amp;urlPath) const
 {
     if (theTransfers.preview.matches(urlPath))
         return xferPreview;
 
     if (theTransfers.complete.matches(urlPath))
         return xferComplete;
 
     if (theTransfers.ignore.matches(urlPath))
         return xferIgnore;
 
-    debugs(93,7, HERE &lt;&lt; &quot;url &quot; &lt;&lt; urlPath &lt;&lt; &quot; matches no extensions; &quot; &lt;&lt;
+    debugs(93,7, &quot;url &quot; &lt;&lt; urlPath &lt;&lt; &quot; matches no extensions; &quot; &lt;&lt;
            &quot;using default: &quot; &lt;&lt; theTransfers.byDefault-&gt;name);
     return theTransfers.byDefault-&gt;kind;
 }
 
 bool Adaptation::Icap::Options::valid() const
 {
     return !error;
 }
 
 bool Adaptation::Icap::Options::fresh() const
 {
     return squid_curtime &lt;= expire();
 }
 
 int Adaptation::Icap::Options::ttl() const
 {
     Must(valid());
     return theTTL &gt;= 0 ? theTTL : TheConfig.default_options_ttl;
 }
 
@@ -167,60 +168,58 @@
     list.report(5, &quot;Adaptation::Icap::Options::cfgTransferList: &quot;);
 }
 
 /* Adaptation::Icap::Options::TransferList */
 
 Adaptation::Icap::Options::TransferList::TransferList(): extensions(NULL), name(NULL),
     kind(xferNone)
 {
 };
 
 Adaptation::Icap::Options::TransferList::~TransferList()
 {
     wordlistDestroy(&amp;extensions);
 };
 
 void Adaptation::Icap::Options::TransferList::add(const char *extension)
 {
     wordlistAdd(&amp;extensions, extension);
 };
 
-bool Adaptation::Icap::Options::TransferList::matches(const String &amp;urlPath) const
+bool Adaptation::Icap::Options::TransferList::matches(const SBuf &amp;urlPath) const
 {
-    const int urlLen = urlPath.size();
+    const SBuf::size_type urlLen = urlPath.length();
     for (wordlist *e = extensions; e; e = e-&gt;next) {
         // optimize: store extension lengths
-        const int eLen = strlen(e-&gt;key);
+        const size_t eLen = strlen(e-&gt;key);
 
         // assume URL contains at least '/' before the extension
         if (eLen &lt; urlLen) {
-            const int eOff = urlLen - eLen;
+            const size_t eOff = urlLen - eLen;
             // RFC 3507 examples imply that extensions come without leading '.'
-            if (urlPath[eOff-1] == '.' &amp;&amp;
-                    strcmp(urlPath.termedBuf() + eOff, e-&gt;key) == 0) {
-                debugs(93,7, HERE &lt;&lt; &quot;url &quot; &lt;&lt; urlPath &lt;&lt; &quot; matches &quot; &lt;&lt;
-                       name &lt;&lt; &quot; extension &quot; &lt;&lt; e-&gt;key);
+            if (urlPath[eOff-1] == '.' &amp;&amp; urlPath.substr(eOff).cmp(e-&gt;key, eLen) == 0) {
+                debugs(93,7, &quot;url &quot; &lt;&lt; urlPath &lt;&lt; &quot; matches &quot; &lt;&lt; name &lt;&lt; &quot; extension &quot; &lt;&lt; e-&gt;key);
                 return true;
             }
         }
     }
-    debugs(93,8, HERE &lt;&lt; &quot;url &quot; &lt;&lt; urlPath &lt;&lt; &quot; matches no &quot; &lt;&lt; name &lt;&lt; &quot; extensions&quot;);
+    debugs(93,8, &quot;url &quot; &lt;&lt; urlPath &lt;&lt; &quot; matches no &quot; &lt;&lt; name &lt;&lt; &quot; extensions&quot;);
     return false;
 }
 
 void Adaptation::Icap::Options::TransferList::parse(const String &amp;buf, bool &amp;foundStar)
 {
     foundStar = false;
 
     const char *item;
     const char *pos = NULL;
     int ilen;
     while (strListGetItem(&amp;buf, ',', &amp;item, &amp;ilen, &amp;pos)) {
         if (ilen == 1 &amp;&amp; *item == '*')
             foundStar = true;
         else {
             const char *tmp = xstrndup(item, ilen+1);
             add(tmp);
             xfree(tmp);
         }
     }
 }

=== modified file 'src/adaptation/icap/Options.h'
--- src/adaptation/icap/Options.h	2015-01-13 07:25:36 +0000
+++ src/adaptation/icap/Options.h	2015-06-14 19:16:30 +0000
@@ -25,67 +25,67 @@
 class Options
 {
 
 public:
     typedef void GetCallback(void *data, Options *options);
     static void Get(ServiceRep::Pointer &amp;service, GetCallback *cb, void *data);
 
 public:
     Options();
     ~Options();
 
     void configure(const HttpReply *reply);
 
     bool valid() const;
     bool fresh() const;
     int ttl() const;
     time_t expire() const;
     time_t timestamp() const { return theTimestamp; };
 
     typedef enum { xferNone, xferPreview, xferIgnore, xferComplete } TransferKind;
-    TransferKind transferKind(const String &amp;urlPath) const;
+    TransferKind transferKind(const SBuf &amp;urlPath) const;
 
 public:
     const char *error; // human-readable information; set iff !valid()
 
     // ICAP server MUST supply this info
     std::vector&lt;ICAP::Method&gt; methods;
     String istag;
 
     // ICAP server MAY supply this info. If not, Squid supplies defaults.
     String service;
     String serviceId;
     int max_connections;
     bool allow204;
     bool allow206;
     int preview;
 
 protected:
     // Transfer-* extension list representation
     // maintains wordlist and does parsing/matching
     class TransferList
     {
     public:
         TransferList();
         ~TransferList();
 
-        bool matches(const String &amp;urlPath) const;
+        bool matches(const SBuf &amp;urlPath) const;
 
         void parse(const String &amp;buf, bool &amp;foundStar);
         void add(const char *extension);
         void report(int level, const char *prefix) const;
 
     public:
         wordlist *extensions; // TODO: optimize with a hash of some sort
         const char *name;  // header name, mostly for debugging
         TransferKind kind; // to simplify caller's life
     };
 
     // varios Transfer-* lists
     struct Transfers {
         TransferList preview;
         TransferList ignore;
         TransferList complete;
         TransferList *byDefault;  // Transfer-X that has '*'
     } theTransfers;
 
     int theTTL;

=== modified file 'src/adaptation/icap/ServiceRep.cc'
--- src/adaptation/icap/ServiceRep.cc	2015-05-26 17:25:04 +0000
+++ src/adaptation/icap/ServiceRep.cc	2015-06-14 19:10:43 +0000
@@ -304,47 +304,47 @@
 }
 
 bool Adaptation::Icap::ServiceRep::availableForNew() const
 {
     Must(up());
     int available = availableConnections();
     if (available &lt; 0)
         return true;
     else
         return (available - theAllWaiters &gt; 0);
 }
 
 bool Adaptation::Icap::ServiceRep::availableForOld() const
 {
     Must(up());
 
     int available = availableConnections();
     return (available != 0); // it is -1 (no limit) or has available slots
 }
 
-bool Adaptation::Icap::ServiceRep::wantsUrl(const String &amp;urlPath) const
+bool Adaptation::Icap::ServiceRep::wantsUrl(const SBuf &amp;urlPath) const
 {
     Must(hasOptions());
     return theOptions-&gt;transferKind(urlPath) != Adaptation::Icap::Options::xferIgnore;
 }
 
-bool Adaptation::Icap::ServiceRep::wantsPreview(const String &amp;urlPath, size_t &amp;wantedSize) const
+bool Adaptation::Icap::ServiceRep::wantsPreview(const SBuf &amp;urlPath, size_t &amp;wantedSize) const
 {
     Must(hasOptions());
 
     if (theOptions-&gt;preview &lt; 0)
         return false;
 
     if (theOptions-&gt;transferKind(urlPath) != Adaptation::Icap::Options::xferPreview)
         return false;
 
     wantedSize = theOptions-&gt;preview;
 
     return true;
 }
 
 bool Adaptation::Icap::ServiceRep::allows204() const
 {
     Must(hasOptions());
     return true; // in the future, we may have ACLs to prevent 204s
 }
 

=== modified file 'src/adaptation/icap/ServiceRep.h'
--- src/adaptation/icap/ServiceRep.h	2015-05-05 09:09:27 +0000
+++ src/adaptation/icap/ServiceRep.h	2015-06-14 19:10:55 +0000
@@ -64,42 +64,42 @@
 public:
     typedef RefCount&lt;ServiceRep&gt; Pointer;
 
 public:
     explicit ServiceRep(const ServiceConfigPointer &amp;aConfig);
     virtual ~ServiceRep();
 
     virtual void finalize();
 
     virtual bool probed() const; // see comments above
     virtual bool up() const; // see comments above
     bool availableForNew() const; ///&lt; a new transaction may start communicating with the service
     bool availableForOld() const; ///&lt; a transaction notified about connection slot availability may start communicating with the service
 
     virtual Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &amp;alp);
 
     void callWhenAvailable(AsyncCall::Pointer &amp;cb, bool priority = false);
     void callWhenReady(AsyncCall::Pointer &amp;cb);
 
     // the methods below can only be called on an up() service
-    bool wantsUrl(const String &amp;urlPath) const;
-    bool wantsPreview(const String &amp;urlPath, size_t &amp;wantedSize) const;
+    bool wantsUrl(const SBuf &amp;urlPath) const;
+    bool wantsPreview(const SBuf &amp;urlPath, size_t &amp;wantedSize) const;
     bool allows204() const;
     bool allows206() const;
     Comm::ConnectionPointer getConnection(bool isRetriable, bool &amp;isReused);
     void putConnection(const Comm::ConnectionPointer &amp;conn, bool isReusable, bool sendReset, const char *comment);
     void noteConnectionUse(const Comm::ConnectionPointer &amp;conn);
     void noteConnectionFailed(const char *comment);
 
     void noteFailure(); // called by transactions to report service failure
 
     void noteNewWaiter() {theAllWaiters++;} ///&lt; New xaction waiting for service to be up or available
     void noteGoneWaiter(); ///&lt; An xaction is not waiting any more for service to be available
     bool existWaiters() const {return (theAllWaiters &gt; 0);} ///&lt; if there are xactions waiting for the service to be available
 
     //AsyncJob virtual methods
     virtual bool doneAll() const { return Adaptation::Initiator::doneAll() &amp;&amp; false;}
     virtual void callException(const std::exception &amp;e);
 
     virtual void detach();
     virtual bool detached() const;
 

=== modified file 'src/carp.cc'
--- src/carp.cc	2015-06-09 06:14:43 +0000
+++ src/carp.cc	2015-06-28 06:43:45 +0000
@@ -161,50 +161,48 @@
 
     /* select CachePeer */
     for (k = 0; k &lt; n_carp_peers; ++k) {
         SBuf key;
         tp = carp_peers[k];
         if (tp-&gt;options.carp_key.set) {
             //this code follows urlCanonical's pattern.
             //   corner cases should use the canonical URL
             if (tp-&gt;options.carp_key.scheme) {
                 key.append(request-&gt;url.getScheme().c_str());
                 if (key.length()) //if the scheme is not empty
                     key.append(&quot;://&quot;);
             }
             if (tp-&gt;options.carp_key.host) {
                 key.append(request-&gt;url.host());
             }
             if (tp-&gt;options.carp_key.port) {
                 key.appendf(&quot;:%u&quot;, request-&gt;url.port());
             }
             if (tp-&gt;options.carp_key.path) {
-                String::size_type pos;
-                if ((pos=request-&gt;urlpath.find('?'))!=String::npos)
-                    key.append(SBuf(request-&gt;urlpath.substr(0,pos)));
-                else
-                    key.append(SBuf(request-&gt;urlpath));
+                // XXX: fix when path and query are separate
+                key.append(request-&gt;url.path().substr(0,request-&gt;url.path().find('?'))); // 0..N
             }
             if (tp-&gt;options.carp_key.params) {
-                String::size_type pos;
-                if ((pos=request-&gt;urlpath.find('?'))!=String::npos)
-                    key.append(SBuf(request-&gt;urlpath.substr(pos,request-&gt;urlpath.size())));
+                // XXX: fix when path and query are separate
+                SBuf::size_type pos;
+                if ((pos=request-&gt;url.path().find('?')) != SBuf::npos)
+                    key.append(request-&gt;url.path().substr(pos)); // N..npos
             }
         }
         // if the url-based key is empty, e.g. because the user is
         // asking to balance on the path but the request doesn't supply any,
         // then fall back to canonical URL
 
         if (key.isEmpty())
             key=SBuf(urlCanonical(request));
 
         for (const char *c = key.rawContent(), *e=key.rawContent()+key.length(); c &lt; e; ++c)
             user_hash += ROTATE_LEFT(user_hash, 19) + *c;
         combined_hash = (user_hash ^ tp-&gt;carp.hash);
         combined_hash += combined_hash * 0x62531965;
         combined_hash = ROTATE_LEFT(combined_hash, 21);
         score = combined_hash * tp-&gt;carp.load_multiplier;
         debugs(39, 3, &quot;carpSelectParent: key=&quot; &lt;&lt; key &lt;&lt; &quot; name=&quot; &lt;&lt; tp-&gt;name &lt;&lt; &quot; combined_hash=&quot; &lt;&lt; combined_hash  &lt;&lt;
                &quot; score=&quot; &lt;&lt; std::setprecision(0) &lt;&lt; score);
 
         if ((score &gt; high_score) &amp;&amp; peerHTTPOkay(tp, request)) {
             p = tp;

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-06-09 06:14:43 +0000
+++ src/client_side.cc	2015-06-18 09:50:39 +0000
@@ -2186,83 +2186,80 @@
            &quot;, mime-header-size=&quot; &lt;&lt; hp-&gt;headerBlockSize() &lt;&lt;
            &quot;, mime header block:\n&quot; &lt;&lt; hp-&gt;mimeHeader() &lt;&lt; &quot;\n----------&quot;);
 
     /* Ok, all headers are received */
     ClientHttpRequest *http = new ClientHttpRequest(csd);
 
     http-&gt;req_sz = hp-&gt;messageHeaderSize();
     ClientSocketContext *result = new ClientSocketContext(csd-&gt;clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result-&gt;reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
 
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
                      clientSocketDetach, newClient, tempBuffer);
 
     /* set url */
-    // XXX: c_str() does re-allocate but here replaces explicit malloc/free.
-    // when internalCheck() accepts SBuf removing this will be a net gain for performance.
-    SBuf tmp(hp-&gt;requestUri());
-    const char *url = tmp.c_str();
-
     debugs(33,5, &quot;Prepare absolute URL from &quot; &lt;&lt;
            (csd-&gt;transparent()?&quot;intercept&quot;:(csd-&gt;port-&gt;flags.accelSurrogate ? &quot;accel&quot;:&quot;&quot;)));
     /* Rewrite the URL in transparent or accelerator mode */
     /* NP: there are several cases to traverse here:
      *  - standard mode (forward proxy)
      *  - transparent mode (TPROXY)
      *  - transparent mode with failures
      *  - intercept mode (NAT)
      *  - intercept mode with failures
      *  - accelerator mode (reverse proxy)
-     *  - internal URL
+     *  - internal relative-URL
      *  - mixed combos of the above with internal URL
      *  - remote interception with PROXY protocol
      *  - remote reverse-proxy with PROXY protocol
      */
     if (csd-&gt;transparent()) {
         /* intercept or transparent mode, properly working with no failures */
         prepareTransparentURL(csd, http, hp);
 
-    } else if (internalCheck(url)) {
+    } else if (internalCheck(hp-&gt;requestUri())) { // NP: only matches relative-URI
         /* internal URL mode */
         /* prepend our name &amp; port */
-        http-&gt;uri = xstrdup(internalLocalUri(NULL, url));
+        http-&gt;uri = xstrdup(internalLocalUri(NULL, hp-&gt;requestUri()));
         // We just re-wrote the URL. Must replace the Host: header.
         //  But have not parsed there yet!! flag for local-only handling.
         http-&gt;flags.internal = true;
 
     } else if (csd-&gt;port-&gt;flags.accelSurrogate || csd-&gt;switchedToHttps()) {
         /* accelerator mode */
         prepareAcceleratedURL(csd, http, hp);
     }
 
     if (!http-&gt;uri) {
         /* No special rewrites have been applied above, use the
          * requested url. may be rewritten later, so make extra room */
         int url_sz = hp-&gt;requestUri().length() + Config.appendDomainLen + 5;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
-        strcpy(http-&gt;uri, url);
+        // XXX: c_str() does re-allocate but here replaces explicit malloc/free.
+        SBuf tmp(hp-&gt;requestUri());
+        strcpy(http-&gt;uri, tmp.c_str());
     }
 
     result-&gt;flags.parsed_ok = 1;
     return result;
 }
 
 bool
 ConnStateData::In::maybeMakeSpaceAvailable()
 {
     if (buf.spaceSize() &lt; 2) {
         const SBuf::size_type haveCapacity = buf.length() + buf.spaceSize();
         if (haveCapacity &gt;= Config.maxRequestBufferSize) {
             debugs(33, 4, &quot;request buffer full: client_request_buffer_max_size=&quot; &lt;&lt; Config.maxRequestBufferSize);
             return false;
         }
         if (haveCapacity == 0) {
             // haveCapacity is based on the SBuf visible window of the MemBlob buffer, which may fill up.
             // at which point bump the buffer back to default. This allocates a new MemBlob with any un-parsed bytes.
             buf.reserveCapacity(CLIENT_REQ_BUF_SZ);
         } else {
@@ -2546,45 +2543,45 @@
 
     /** \par
      * If transparent or interception mode is working clone the transparent and interception flags
      * from the port settings to the request.
      */
     if (http-&gt;clientConnection != NULL) {
         request-&gt;flags.intercepted = ((http-&gt;clientConnection-&gt;flags &amp; COMM_INTERCEPTION) != 0);
         request-&gt;flags.interceptTproxy = ((http-&gt;clientConnection-&gt;flags &amp; COMM_TRANSPARENT) != 0 ) ;
         static const bool proxyProtocolPort = (conn-&gt;port != NULL) ? conn-&gt;port-&gt;flags.proxySurrogate : false;
         if (request-&gt;flags.interceptTproxy &amp;&amp; !proxyProtocolPort) {
             if (Config.accessList.spoof_client_ip) {
                 ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.spoof_client_ip, http);
                 request-&gt;flags.spoofClientIp = (checklist-&gt;fastCheck() == ACCESS_ALLOWED);
                 delete checklist;
             } else
                 request-&gt;flags.spoofClientIp = true;
         } else
             request-&gt;flags.spoofClientIp = false;
     }
 
-    if (internalCheck(request-&gt;urlpath.termedBuf())) {
+    if (internalCheck(request-&gt;url.path())) {
         if (internalHostnameIs(request-&gt;url.host()) &amp;&amp; request-&gt;url.port() == getMyPort()) {
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true));
             http-&gt;flags.internal = true;
-        } else if (Config.onoff.global_internal_static &amp;&amp; internalStaticCheck(request-&gt;urlpath.termedBuf())) {
+        } else if (Config.onoff.global_internal_static &amp;&amp; internalStaticCheck(request-&gt;url.path())) {
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true) &lt;&lt; &quot; (global_internal_static on)&quot;);
             request-&gt;url.setScheme(AnyP::PROTO_HTTP);
             request-&gt;SetHost(internalHostname());
             request-&gt;url.port(getMyPort());
             http-&gt;flags.internal = true;
         } else
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true) &lt;&lt; &quot; (not this proxy)&quot;);
     }
 
     request-&gt;flags.internal = http-&gt;flags.internal;
     setLogUri (http, urlCanonicalClean(request.getRaw()));
     request-&gt;client_addr = conn-&gt;clientConnection-&gt;remote; // XXX: remove reuest-&gt;client_addr member.
 #if FOLLOW_X_FORWARDED_FOR
     // indirect client gets stored here because it is an HTTP header result (from X-Forwarded-For:)
     // not a details about teh TCP connection itself
     request-&gt;indirect_client_addr = conn-&gt;clientConnection-&gt;remote;
 #endif /* FOLLOW_X_FORWARDED_FOR */
     request-&gt;my_addr = conn-&gt;clientConnection-&gt;local;
     request-&gt;myportname = conn-&gt;port-&gt;name;
 

=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-06-22 11:52:31 +0000
+++ src/clients/FtpGateway.cc	2015-06-28 06:51:22 +0000
@@ -1064,127 +1064,125 @@
     if (password[0])
         return 1;
 
     /* Setup default FTP password settings */
     /* this has to be done last so that we can have a no-password case above. */
     if (!password[0]) {
         if (strcmp(user, &quot;anonymous&quot;) == 0 &amp;&amp; !flags.tried_auth_anonymous) {
             xstrncpy(password, Config.Ftp.anon_user, MAX_URL);
             flags.tried_auth_anonymous=1;
             return 1;
         } else if (!flags.tried_auth_nopass) {
             xstrncpy(password, null_string, MAX_URL);
             flags.tried_auth_nopass=1;
             return 1;
         }
     }
 
     return 0;           /* different username */
 }
 
-static String str_type_eq;
 void
 Ftp::Gateway::checkUrlpath()
 {
-    int l;
-    size_t t;
+    static SBuf str_type_eq(&quot;type=&quot;);
+    auto t = request-&gt;url.path().rfind(';');
 
-    if (str_type_eq.size()==0) //hack. String doesn't support global-static
-        str_type_eq=&quot;type=&quot;;
-
-    if ((t = request-&gt;urlpath.rfind(';')) != String::npos) {
-        if (request-&gt;urlpath.substr(t+1,t+1+str_type_eq.size())==str_type_eq) {
-            typecode = (char)xtoupper(request-&gt;urlpath[t+str_type_eq.size()+1]);
-            request-&gt;urlpath.cut(t);
+    if (t != SBuf::npos) {
+        auto filenameEnd = t-1;
+        if (request-&gt;url.path().substr(++t).cmp(str_type_eq, str_type_eq.length()) == 0) {
+            t += str_type_eq.length();
+            typecode = (char)xtoupper(request-&gt;url.path()[t]);
+            request-&gt;url.path(request-&gt;url.path().substr(0,filenameEnd));
         }
     }
 
-    l = request-&gt;urlpath.size();
+    int l = request-&gt;url.path().length();
     /* check for null path */
 
     if (!l) {
         flags.isdir = 1;
         flags.root_dir = 1;
         flags.need_base_href = 1;   /* Work around broken browsers */
-    } else if (!request-&gt;urlpath.cmp(&quot;/%2f/&quot;)) {
+    } else if (!request-&gt;url.path().cmp(&quot;/%2f/&quot;)) {
         /* UNIX root directory */
         flags.isdir = 1;
         flags.root_dir = 1;
-    } else if ((l &gt;= 1) &amp;&amp; (request-&gt;urlpath[l - 1] == '/')) {
+    } else if ((l &gt;= 1) &amp;&amp; (request-&gt;url.path()[l-1] == '/')) {
         /* Directory URL, ending in / */
         flags.isdir = 1;
 
         if (l == 1)
             flags.root_dir = 1;
     } else {
         flags.dir_slash = 1;
     }
 }
 
 void
 Ftp::Gateway::buildTitleUrl()
 {
     title_url = &quot;<A HREF="ftp://">ftp://</A>&quot;;
 
     if (strcmp(user, &quot;anonymous&quot;)) {
         title_url.append(user);
         title_url.append(&quot;@&quot;);
     }
 
     SBuf authority = request-&gt;url.authority(request-&gt;url.getScheme() != AnyP::PROTO_FTP);
 
     title_url.append(authority.rawContent(), authority.length());
-    title_url.append(request-&gt;urlpath);
+    title_url.append(request-&gt;url.path().rawContent(), request-&gt;url.path().length());
 
     base_href = &quot;<A HREF="ftp://">ftp://</A>&quot;;
 
     if (strcmp(user, &quot;anonymous&quot;) != 0) {
         base_href.append(rfc1738_escape_part(user));
 
         if (password_url) {
             base_href.append(&quot;:&quot;);
             base_href.append(rfc1738_escape_part(password));
         }
 
         base_href.append(&quot;@&quot;);
     }
 
     base_href.append(authority.rawContent(), authority.length());
-    base_href.append(request-&gt;urlpath);
+    base_href.append(request-&gt;url.path().rawContent(), request-&gt;url.path().length());
     base_href.append(&quot;/&quot;);
 }
 
 void
 Ftp::Gateway::start()
 {
     if (!checkAuth(&amp;request-&gt;header)) {
         /* create appropriate reply */
         HttpReply *reply = ftpAuthRequired(request, ftpRealm());
         entry-&gt;replaceHttpReply(reply);
         serverComplete();
         return;
     }
 
     checkUrlpath();
     buildTitleUrl();
-    debugs(9, 5, HERE &lt;&lt; &quot;FD &quot; &lt;&lt; ctrl.conn-&gt;fd &lt;&lt; &quot; : host=&quot; &lt;&lt; request-&gt;url.host() &lt;&lt;
-           &quot;, path=&quot; &lt;&lt; request-&gt;urlpath &lt;&lt; &quot;, user=&quot; &lt;&lt; user &lt;&lt; &quot;, passwd=&quot; &lt;&lt; password);
+    debugs(9, 5, &quot;FD &quot; &lt;&lt; ctrl.conn-&gt;fd &lt;&lt; &quot; : host=&quot; &lt;&lt; request-&gt;url.host() &lt;&lt;
+           &quot;, path=&quot; &lt;&lt; request-&gt;url.path() &lt;&lt; &quot;, user=&quot; &lt;&lt; user &lt;&lt; &quot;, passwd=&quot; &lt;&lt; password);
     state = BEGIN;
     Ftp::Client::start();
 }
 
 /* ====================================================================== */
 
 void
 Ftp::Gateway::handleControlReply()
 {
     Ftp::Client::handleControlReply();
     if (ctrl.message == NULL)
         return; // didn't get complete reply yet
 
     /* Copy the message except for the last line to cwd_message to be
      * printed in error messages.
      */
     for (wordlist *w = ctrl.message; w &amp;&amp; w-&gt;next; w = w-&gt;next) {
         cwd_message.append('\n');
         cwd_message.append(w-&gt;key);
     }
@@ -1348,99 +1346,98 @@
     ftpState-&gt;writeCommand(cbuf);
     ftpState-&gt;state = Ftp::Client::SENT_PASS;
 }
 
 static void
 ftpReadPass(Ftp::Gateway * ftpState)
 {
     int code = ftpState-&gt;ctrl.replycode;
     debugs(9, 3, HERE &lt;&lt; &quot;code=&quot; &lt;&lt; code);
 
     if (code == 230) {
         ftpSendType(ftpState);
     } else {
         ftpState-&gt;loginFailed();
     }
 }
 
 static void
 ftpSendType(Ftp::Gateway * ftpState)
 {
-    const char *t;
-    const char *filename;
-    char mode;
-
     /* check the server control channel is still available */
     if (!ftpState || !ftpState-&gt;haveControlChannel(&quot;ftpSendType&quot;))
         return;
 
     /*
      * Ref section 3.2.2 of RFC 1738
      */
-    mode = ftpState-&gt;typecode;
+    char mode = ftpState-&gt;typecode;
 
     switch (mode) {
 
     case 'D':
         mode = 'A';
         break;
 
     case 'A':
 
     case 'I':
         break;
 
     default:
 
         if (ftpState-&gt;flags.isdir) {
             mode = 'A';
         } else {
-            t = ftpState-&gt;request-&gt;urlpath.rpos('/');
-            filename = t ? t + 1 : ftpState-&gt;request-&gt;urlpath.termedBuf();
-            mode = mimeGetTransferMode(filename);
+            auto t = ftpState-&gt;request-&gt;url.path().rfind('/');
+            // XXX: performance regression, c_str() may reallocate
+            SBuf filename = ftpState-&gt;request-&gt;url.path().substr(t != SBuf::npos ? t + 1 : 0);
+            mode = mimeGetTransferMode(filename.c_str());
         }
 
         break;
     }
 
     if (mode == 'I')
         ftpState-&gt;flags.binary = 1;
     else
         ftpState-&gt;flags.binary = 0;
 
     snprintf(cbuf, CTRL_BUFLEN, &quot;TYPE %c\r\n&quot;, mode);
 
     ftpState-&gt;writeCommand(cbuf);
 
     ftpState-&gt;state = Ftp::Client::SENT_TYPE;
 }
 
 static void
 ftpReadType(Ftp::Gateway * ftpState)
 {
     int code = ftpState-&gt;ctrl.replycode;
     char *path;
     char *d, *p;
     debugs(9, 3, HERE &lt;&lt; &quot;code=&quot; &lt;&lt; code);
 
     if (code == 200) {
-        p = path = xstrdup(ftpState-&gt;request-&gt;urlpath.termedBuf());
+        // XXX: performance regression, c_str() may reallocate
+        SBuf tmp = ftpState-&gt;request-&gt;url.path();
+        p = path = xstrndup(tmp.c_str(),tmp.length());
 
         if (*p == '/')
             ++p;
 
         while (*p) {
             d = p;
             p += strcspn(p, &quot;/&quot;);
 
             if (*p) {
                 *p = '\0';
                 ++p;
             }
 
             rfc1738_unescape(d);
 
             if (*d)
                 wordlistAdd(&amp;ftpState-&gt;pathcomps, d);
         }
 
         xfree(path);
@@ -2351,41 +2348,43 @@
 ftpReadQuit(Ftp::Gateway * ftpState)
 {
     ftpState-&gt;serverComplete();
 }
 
 static void
 ftpTrySlashHack(Ftp::Gateway * ftpState)
 {
     char *path;
     ftpState-&gt;flags.try_slash_hack = 1;
     /* Free old paths */
 
     debugs(9, 3, HERE);
 
     if (ftpState-&gt;pathcomps)
         wordlistDestroy(&amp;ftpState-&gt;pathcomps);
 
     safe_free(ftpState-&gt;filepath);
 
     /* Build the new path (urlpath begins with /) */
-    path = xstrdup(ftpState-&gt;request-&gt;urlpath.termedBuf());
+    // XXX: performance regression. c_str() may reallocate, then xstrdup repeats.
+    SBuf tmp = ftpState-&gt;request-&gt;url.path();
+    path = xstrdup(tmp.c_str());
 
     rfc1738_unescape(path);
 
     ftpState-&gt;filepath = path;
 
     /* And off we go */
     ftpGetFile(ftpState);
 }
 
 /**
  * Forget hack status. Next error is shown to the user
  */
 void
 Ftp::Gateway::unhack()
 {
     debugs(9, 3, HERE);
 
     if (old_request != NULL) {
         safe_free(old_request);
         safe_free(old_reply);
@@ -2402,51 +2401,51 @@
 
     debugs(9, 3, HERE);
 
     if (old_request == NULL) {
         old_request = ctrl.last_command;
         ctrl.last_command = NULL;
         old_reply = ctrl.last_reply;
         ctrl.last_reply = NULL;
 
         if (pathcomps == NULL &amp;&amp; filepath != NULL)
             old_filepath = xstrdup(filepath);
     }
 
     /* Jump to the &quot;hack&quot; state */
     nextState(this);
 }
 
 static void
 ftpFail(Ftp::Gateway *ftpState)
 {
-    debugs(9, 6, HERE &lt;&lt; &quot;flags(&quot; &lt;&lt;
+    const bool slashHack = ftpState-&gt;request-&gt;url.path().caseCmp(&quot;/%2f&quot;, 4)==0;
+    debugs(9, 6, &quot;flags(&quot; &lt;&lt;
            (ftpState-&gt;flags.isdir?&quot;IS_DIR,&quot;:&quot;&quot;) &lt;&lt;
            (ftpState-&gt;flags.try_slash_hack?&quot;TRY_SLASH_HACK&quot;:&quot;&quot;) &lt;&lt; &quot;), &quot; &lt;&lt;
            &quot;mdtm=&quot; &lt;&lt; ftpState-&gt;mdtm &lt;&lt; &quot;, size=&quot; &lt;&lt; ftpState-&gt;theSize &lt;&lt;
-           &quot;slashhack=&quot; &lt;&lt; (ftpState-&gt;request-&gt;urlpath.caseCmp(&quot;/%2f&quot;, 4)==0? &quot;T&quot;:&quot;F&quot;) );
+           &quot;slashhack=&quot; &lt;&lt; (slashHack? &quot;T&quot;:&quot;F&quot;) );
 
     /* Try the / hack to support &quot;Netscape&quot; FTP URL's for retreiving files */
     if (!ftpState-&gt;flags.isdir &amp;&amp;   /* Not a directory */
-            !ftpState-&gt;flags.try_slash_hack &amp;&amp;  /* Not in slash hack */
-            ftpState-&gt;mdtm &lt;= 0 &amp;&amp; ftpState-&gt;theSize &lt; 0 &amp;&amp; /* Not known as a file */
-            ftpState-&gt;request-&gt;urlpath.caseCmp(&quot;/%2f&quot;, 4) != 0) {   /* No slash encoded */
+            !ftpState-&gt;flags.try_slash_hack &amp;&amp; !slashHack &amp;&amp; /* Not doing slash hack */
+            ftpState-&gt;mdtm &lt;= 0 &amp;&amp; ftpState-&gt;theSize &lt; 0) { /* Not known as a file */
 
         switch (ftpState-&gt;state) {
 
         case Ftp::Client::SENT_CWD:
 
         case Ftp::Client::SENT_RETR:
             /* Try the / hack */
             ftpState-&gt;hackShortcut(ftpTrySlashHack);
             return;
 
         default:
             break;
         }
     }
 
     ftpState-&gt;failed(ERR_NONE, 0);
     /* failed() closes ctrl.conn and frees this */
 }
 
 Http::StatusCode
@@ -2515,80 +2514,81 @@
         err.ftp.request = xstrdup(ftpState-&gt;ctrl.last_command);
 
     if (ftpState-&gt;old_reply)
         err.ftp.reply = xstrdup(ftpState-&gt;old_reply);
     else if (ftpState-&gt;ctrl.last_reply)
         err.ftp.reply = xstrdup(ftpState-&gt;ctrl.last_reply);
     else
         err.ftp.reply = xstrdup(&quot;&quot;);
 
     // TODO: interpret as FTP-specific error code
     err.detailError(code);
 
     ftpState-&gt;entry-&gt;replaceHttpReply( err.BuildHttpReply() );
 
     ftpSendQuit(ftpState);
 }
 
 void
 Ftp::Gateway::appendSuccessHeader()
 {
-    const char *mime_type = NULL;
-    const char *mime_enc = NULL;
-    String urlpath = request-&gt;urlpath;
-    const char *filename = NULL;
-    const char *t = NULL;
-
     debugs(9, 3, HERE);
 
     if (flags.http_header_sent)
         return;
 
     HttpReply *reply = new HttpReply;
 
     flags.http_header_sent = 1;
 
     assert(entry-&gt;isEmpty());
 
     EBIT_CLR(entry-&gt;flags, ENTRY_FWD_HDR_WAIT);
 
     entry-&gt;buffer();    /* released when done processing current data payload */
 
-    filename = (t = urlpath.rpos('/')) ? t + 1 : urlpath.termedBuf();
+    SBuf urlPath = request-&gt;url.path();
+    auto t = urlPath.rfind('/');
+    SBuf filename = urlPath.substr(t != SBuf::npos ? t : 0);
+
+    const char *mime_type = NULL;
+    const char *mime_enc = NULL;
 
     if (flags.isdir) {
         mime_type = &quot;text/html&quot;;
     } else {
         switch (typecode) {
 
         case 'I':
             mime_type = &quot;application/octet-stream&quot;;
-            mime_enc = mimeGetContentEncoding(filename);
+            // XXX: performance regression, c_str() may reallocate
+            mime_enc = mimeGetContentEncoding(filename.c_str());
             break;
 
         case 'A':
             mime_type = &quot;text/plain&quot;;
             break;
 
         default:
-            mime_type = mimeGetContentType(filename);
-            mime_enc = mimeGetContentEncoding(filename);
+            // XXX: performance regression, c_str() may reallocate
+            mime_type = mimeGetContentType(filename.c_str());
+            mime_enc = mimeGetContentEncoding(filename.c_str());
             break;
         }
     }
 
     /* set standard stuff */
 
     if (0 == getCurrentOffset()) {
         /* Full reply */
         reply-&gt;setHeaders(Http::scOkay, &quot;Gatewaying&quot;, mime_type, theSize, mdtm, -2);
     } else if (theSize &lt; getCurrentOffset()) {
         /*
          * DPW 2007-05-04
          * offset should not be larger than theSize.  We should
          * not be seeing this condition any more because we'll only
          * send REST if we know the theSize and if it is less than theSize.
          */
         debugs(0,DBG_CRITICAL,HERE &lt;&lt; &quot;Whoops! &quot; &lt;&lt;
                &quot; current offset=&quot; &lt;&lt; getCurrentOffset() &lt;&lt;
                &quot;, but theSize=&quot; &lt;&lt; theSize &lt;&lt;
                &quot;.  assuming full content response&quot;);
@@ -2629,52 +2629,52 @@
     } else {
         e-&gt;release();
     }
 }
 
 HttpReply *
 Ftp::Gateway::ftpAuthRequired(HttpRequest * request, const char *realm)
 {
     ErrorState err(ERR_CACHE_ACCESS_DENIED, Http::scUnauthorized, request);
     HttpReply *newrep = err.BuildHttpReply();
 #if HAVE_AUTH_MODULE_BASIC
     /* add Authenticate header */
     newrep-&gt;header.putAuth(&quot;Basic&quot;, realm);
 #endif
     return newrep;
 }
 
 const char *
 Ftp::UrlWith2f(HttpRequest * request)
 {
-    String newbuf = &quot;%2f&quot;;
+    SBuf newbuf(&quot;%2f&quot;);
 
     if (request-&gt;url.getScheme() != AnyP::PROTO_FTP)
         return NULL;
 
-    if ( request-&gt;urlpath[0]=='/' ) {
-        newbuf.append(request-&gt;urlpath);
-        request-&gt;urlpath.absorb(newbuf);
+    if (request-&gt;url.path()[0] == '/') {
+        newbuf.append(request-&gt;url.path());
+        request-&gt;url.path(newbuf);
         safe_free(request-&gt;canonical);
-    } else if ( !strncmp(request-&gt;urlpath.termedBuf(), &quot;%2f&quot;, 3) ) {
-        newbuf.append(request-&gt;urlpath.substr(1,request-&gt;urlpath.size()));
-        request-&gt;urlpath.absorb(newbuf);
+    } else if (!request-&gt;url.path().cmp(newbuf, 3)) {
+        newbuf.append(request-&gt;url.path().substr(1));
+        request-&gt;url.path(newbuf);
         safe_free(request-&gt;canonical);
     }
 
     return urlCanonical(request);
 }
 
 void
 Ftp::Gateway::printfReplyBody(const char *fmt, ...)
 {
     va_list args;
     va_start (args, fmt);
     static char buf[4096];
     buf[0] = '\0';
     vsnprintf(buf, 4096, fmt, args);
     writeReplyBody(buf, strlen(buf));
     va_end(args);
 }
 
 /**
  * Call this when there is data from the origin server

=== modified file 'src/errorpage.cc'
--- src/errorpage.cc	2015-06-09 06:14:43 +0000
+++ src/errorpage.cc	2015-06-28 07:04:07 +0000
@@ -718,52 +718,44 @@
 #if USE_AUTH
     if (auth_user_request.getRaw() &amp;&amp; auth_user_request-&gt;denyMessage())
         str.appendf(&quot;Auth ErrMsg: %s\r\n&quot;, auth_user_request-&gt;denyMessage());
 #endif
     if (dnsError.size() &gt; 0)
         str.appendf(&quot;DNS ErrMsg: %s\r\n&quot;, dnsError.termedBuf());
 
     /* - TimeStamp */
     str.appendf(&quot;TimeStamp: %s\r\n\r\n&quot;, mkrfc1123(squid_curtime));
 
     /* - IP stuff */
     str.appendf(&quot;ClientIP: %s\r\n&quot;, src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
 
     if (request &amp;&amp; request-&gt;hier.host[0] != '\0') {
         str.appendf(&quot;ServerIP: %s\r\n&quot;, request-&gt;hier.host);
     }
 
     str.append(&quot;\r\n&quot;, 2);
     /* - HTTP stuff */
     str.append(&quot;HTTP Request:\r\n&quot;, 15);
-
-    if (NULL != request) {
-        String urlpath_or_slash;
-
-        if (request-&gt;urlpath.size() != 0)
-            urlpath_or_slash = request-&gt;urlpath;
-        else
-            urlpath_or_slash = &quot;/&quot;;
-
-        str.appendf(SQUIDSBUFPH &quot; &quot; SQUIDSTRINGPH &quot; %s/%d.%d\n&quot;,
+    if (request) {
+        str.appendf(SQUIDSBUFPH &quot; &quot; SQUIDSBUFPH &quot; %s/%d.%d\n&quot;,
                     SQUIDSBUFPRINT(request-&gt;method.image()),
-                    SQUIDSTRINGPRINT(urlpath_or_slash),
+                    SQUIDSBUFPRINT(request-&gt;url.path()),
                     AnyP::ProtocolType_str[request-&gt;http_ver.protocol],
                     request-&gt;http_ver.major, request-&gt;http_ver.minor);
         request-&gt;header.packInto(&amp;str);
     }
 
     str.append(&quot;\r\n&quot;, 2);
     /* - FTP stuff */
 
     if (ftp.request) {
         str.appendf(&quot;FTP Request: %s\r\n&quot;, ftp.request);
         str.appendf(&quot;FTP Reply: %s\r\n&quot;, (ftp.reply? ftp.reply:&quot;[none]&quot;));
         str.append(&quot;FTP Msg: &quot;, 9);
         wordlistCat(ftp.server_msg, &amp;str);
         str.append(&quot;\r\n&quot;, 2);
     }
 
     str.append(&quot;\r\n&quot;, 2);
     mb-&gt;appendf(&quot;&amp;body=%s&quot;, rfc1738_escape_part(str.buf));
     str.clean();
     return 0;
@@ -936,57 +928,51 @@
 
     case 'p':
         if (request) {
             mb.appendf(&quot;%u&quot;, request-&gt;url.port());
         } else if (!building_deny_info_url) {
             p = &quot;[unknown port]&quot;;
         }
         break;
 
     case 'P':
         if (request) {
             p = request-&gt;url.getScheme().c_str();
         } else if (!building_deny_info_url) {
             p = &quot;[unknown protocol]&quot;;
         }
         break;
 
     case 'R':
         if (building_deny_info_url) {
             if (request != NULL) {
-                p = (request-&gt;urlpath.size() != 0 ? request-&gt;urlpath.termedBuf() : &quot;/&quot;);
+                SBuf tmp = request-&gt;url.path();
+                p = tmp.c_str();
                 no_urlescape = 1;
             } else
                 p = &quot;[no request]&quot;;
             break;
         }
-        if (NULL != request) {
-            String urlpath_or_slash;
-
-            if (request-&gt;urlpath.size() != 0)
-                urlpath_or_slash = request-&gt;urlpath;
-            else
-                urlpath_or_slash = &quot;/&quot;;
-
-            mb.appendf(SQUIDSBUFPH &quot; &quot; SQUIDSTRINGPH &quot; %s/%d.%d\n&quot;,
+        if (request != NULL) {
+            mb.appendf(SQUIDSBUFPH &quot; &quot; SQUIDSBUFPH &quot; %s/%d.%d\n&quot;,
                        SQUIDSBUFPRINT(request-&gt;method.image()),
-                       SQUIDSTRINGPRINT(urlpath_or_slash),
+                       SQUIDSBUFPRINT(request-&gt;url.path()),
                        AnyP::ProtocolType_str[request-&gt;http_ver.protocol],
                        request-&gt;http_ver.major, request-&gt;http_ver.minor);
             request-&gt;header.packInto(&amp;mb, true); //hide authorization data
         } else if (request_hdrs) {
             p = request_hdrs;
         } else {
             p = &quot;[no request]&quot;;
         }
         break;
 
     case 's':
         /* for backward compat we make %s show the full URL. Drop this in some future release. */
         if (building_deny_info_url) {
             p = request ? urlCanonical(request) : url;
             debugs(0, DBG_CRITICAL, &quot;WARNING: deny_info now accepts coded tags. Use %u to get the full URL instead of %s&quot;);
         } else
             p = visible_appname_string;
         break;
 
     case 'S':

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-06-09 06:14:43 +0000
+++ src/external_acl.cc	2015-06-28 07:03:42 +0000
@@ -961,42 +961,44 @@
             str = buf;
             break;
 
         case Format::LFT_CLIENT_REQ_URI:
             str = urlCanonical(request);
             break;
 
         case Format::LFT_CLIENT_REQ_URLDOMAIN:
             str = request-&gt;url.host();
             break;
 
         case Format::LFT_CLIENT_REQ_URLSCHEME:
             str = request-&gt;url.getScheme().c_str();
             break;
 
         case Format::LFT_CLIENT_REQ_URLPORT:
             snprintf(buf, sizeof(buf), &quot;%u&quot;, request-&gt;url.port());
             str = buf;
             break;
 
-        case Format::LFT_CLIENT_REQ_URLPATH:
-            str = request-&gt;urlpath.termedBuf();
+        case Format::LFT_CLIENT_REQ_URLPATH: {
+                SBuf tmp = request-&gt;url.path();
+                str = tmp.c_str();
+            }
             break;
 
         case Format::LFT_CLIENT_REQ_METHOD: {
             const SBuf &amp;s = request-&gt;method.image();
             sb.append(s.rawContent(), s.length());
         }
         str = sb.termedBuf();
         break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER:
             if (format-&gt;header_id == -1)
                 sb = request-&gt;header.getByName(format-&gt;header);
             else
                 sb = request-&gt;header.getStrOrList(format-&gt;header_id);
             str = sb.termedBuf();
             break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
             if (format-&gt;header_id == -1)
                 sb = request-&gt;header.getByNameListMember(format-&gt;header, format-&gt;member, format-&gt;separator);

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2015-06-09 06:14:43 +0000
+++ src/format/Format.cc	2015-06-09 12:13:49 +0000
@@ -954,41 +954,42 @@
             }
             break;
 
         case LFT_CLIENT_REQ_URLDOMAIN:
             if (al-&gt;request) {
                 out = al-&gt;request-&gt;url.host();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_URLPORT:
             if (al-&gt;request) {
                 outint = al-&gt;request-&gt;url.port();
                 doint = 1;
             }
             break;
 
         case LFT_REQUEST_URLPATH_OLD_31:
         case LFT_CLIENT_REQ_URLPATH:
             if (al-&gt;request) {
-                out = al-&gt;request-&gt;urlpath.termedBuf();
+                SBuf s = al-&gt;request-&gt;url.path();
+                out = s.c_str();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_VERSION:
             if (al-&gt;request) {
                 snprintf(tmp, sizeof(tmp), &quot;%d.%d&quot;, (int) al-&gt;request-&gt;http_ver.major, (int) al-&gt;request-&gt;http_ver.minor);
                 out = tmp;
             }
             break;
 
         case LFT_REQUEST_METHOD:
             if (al-&gt;_private.method_str) // ICP, HTCP method code
                 out = al-&gt;_private.method_str;
             else {
                 const SBuf &amp;s = al-&gt;http.method.image();
                 sb.append(s.rawContent(), s.length());
                 out = sb.termedBuf();
                 quote = 1;
             }
@@ -1027,41 +1028,42 @@
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLDOMAIN:
             if (al-&gt;adapted_request) {
                 out = al-&gt;adapted_request-&gt;url.host();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLPORT:
             if (al-&gt;adapted_request) {
                 outint = al-&gt;adapted_request-&gt;url.port();
                 doint = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLPATH:
             if (al-&gt;adapted_request) {
-                out = al-&gt;adapted_request-&gt;urlpath.termedBuf();
+                SBuf s = al-&gt;adapted_request-&gt;url.path();
+                out = s.c_str();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_VERSION:
             if (al-&gt;adapted_request) {
                 snprintf(tmp, sizeof(tmp), &quot;%d.%d&quot;,
                          (int) al-&gt;adapted_request-&gt;http_ver.major,
                          (int) al-&gt;adapted_request-&gt;http_ver.minor);
                 out = tmp;
             }
             break;
 
         case LFT_CLIENT_REQUEST_SIZE_TOTAL:
             outoff = al-&gt;http.clientRequestSz.messageTotal();
             dooff = 1;
             break;
 
         case LFT_CLIENT_REQUEST_SIZE_HEADERS:
             outoff = al-&gt;http.clientRequestSz.header;

=== modified file 'src/gopher.cc'
--- src/gopher.cc	2015-06-09 06:14:43 +0000
+++ src/gopher.cc	2015-06-14 22:04:38 +0000
@@ -4,40 +4,41 @@
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 10    Gopher */
 
 #include &quot;squid.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;comm/Read.h&quot;
 #include &quot;comm/Write.h&quot;
 #include &quot;errorpage.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;FwdState.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;html_quote.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;mime.h&quot;
+#include &quot;parser/Tokenizer.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;StatCounters.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;tools.h&quot;
 
 #if USE_DELAY_POOLS
 #include &quot;DelayPools.h&quot;
 #include &quot;MemObject.h&quot;
 #endif
 
 /* gopher type code from rfc. Anawat. */
 #define GOPHER_FILE         '0'
 #define GOPHER_DIRECTORY    '1'
 #define GOPHER_CSO          '2'
 #define GOPHER_ERROR        '3'
 #define GOPHER_MACBINHEX    '4'
 #define GOPHER_DOSBIN       '5'
 #define GOPHER_UUENCODED    '6'
@@ -236,57 +237,61 @@
     }
 
     assert(entry-&gt;isEmpty());
     EBIT_CLR(entry-&gt;flags, ENTRY_FWD_HDR_WAIT);
 
     HttpReply *reply = new HttpReply;
     entry-&gt;buffer();
     reply-&gt;setHeaders(Http::scOkay, &quot;Gatewaying&quot;, mime_type, -1, -1, -2);
     if (mime_enc)
         reply-&gt;header.putStr(HDR_CONTENT_ENCODING, mime_enc);
 
     entry-&gt;replaceHttpReply(reply);
 }
 
 /**
  * Parse a gopher request into components.  By Anawat.
  */
 static void
 gopher_request_parse(const HttpRequest * req, char *type_id, char *request)
 {
-    const char *path = req-&gt;urlpath.termedBuf();
+    ::Parser::Tokenizer tok(req-&gt;url.path());
 
     if (request)
-        request[0] = '\0';
+        *request = 0;
 
-    if (path &amp;&amp; (*path == '/'))
-        ++path;
+    tok.skip('/'); // ignore failures? path could be ab-empty
 
-    if (!path || !*path) {
+    if (tok.atEnd()) {
         *type_id = GOPHER_DIRECTORY;
         return;
     }
 
-    *type_id = path[0];
+    static const CharacterSet anyByte(&quot;UTF-8&quot;,0x00, 0xFF);
+
+    SBuf typeId;
+    (void)tok.prefix(typeId, anyByte, 1); // never fails since !atEnd()
+    *type_id = typeId[0];
 
     if (request) {
-        xstrncpy(request, path + 1, MAX_URL);
+        SBuf path = tok.remaining();
+        xstrncpy(request, path.c_str(), MAX_URL);
         /* convert %xx to char */
         rfc1738_unescape(request);
     }
 }
 
 /**
  * Parse the request to determine whether it is cachable.
  *
  * \param req   Request data.
  * \retval 0    Not cachable.
  * \retval 1    Cachable.
  */
 int
 gopherCachable(const HttpRequest * req)
 {
     int cachable = 1;
     char type_id;
     /* parse to see type */
     gopher_request_parse(req,
                          &amp;type_id,

=== modified file 'src/http.cc'
--- src/http.cc	2015-06-19 07:13:57 +0000
+++ src/http.cc	2015-06-19 07:20:11 +0000
@@ -1292,62 +1292,61 @@
     if (!flags.headers_parsed &amp;&amp; !eof) {
         debugs(11, 9, &quot;needs more at &quot; &lt;&lt; inBuf.length());
         flags.do_next_read = true;
         /** \retval false If we have not finished parsing the headers and may get more data.
          *                Schedules more reads to retrieve the missing data.
          */
         maybeReadVirginBody(); // schedules all kinds of reads; TODO: rename
         return false;
     }
 
     /** If we are done with parsing, check for errors */
 
     err_type error = ERR_NONE;
 
     if (flags.headers_parsed) { // parsed headers, possibly with errors
         // check for header parsing errors
         if (HttpReply *vrep = virginReply()) {
             const Http::StatusCode s = vrep-&gt;sline.status();
             const AnyP::ProtocolVersion &amp;v = vrep-&gt;sline.version;
             if (s == Http::scInvalidHeader &amp;&amp; v != Http::ProtocolVersion(0,9)) {
-                debugs(11, DBG_IMPORTANT, &quot;WARNING: HTTP: Invalid Response: Bad header encountered from &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url.host() &lt;&lt; request-&gt;urlpath.termedBuf());
+                debugs(11, DBG_IMPORTANT, &quot;WARNING: HTTP: Invalid Response: Bad header encountered from &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url);
                 error = ERR_INVALID_RESP;
             } else if (s == Http::scHeaderTooLarge) {
                 fwd-&gt;dontRetry(true);
                 error = ERR_TOO_BIG;
             } else {
                 return true; // done parsing, got reply, and no error
             }
         } else {
             // parsed headers but got no reply
-            debugs(11, DBG_IMPORTANT, &quot;WARNING: HTTP: Invalid Response: No reply at all for &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url.host() &lt;&lt; request-&gt;urlpath.termedBuf());
+            debugs(11, DBG_IMPORTANT, &quot;WARNING: HTTP: Invalid Response: No reply at all for &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url);
             error = ERR_INVALID_RESP;
         }
     } else {
         assert(eof);
         if (inBuf.length()) {
             error = ERR_INVALID_RESP;
-            debugs(11, DBG_IMPORTANT, &quot;WARNING: HTTP: Invalid Response: Headers did not parse at all for &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url.host() &lt;&lt; request-&gt;urlpath.termedBuf());
+            debugs(11, DBG_IMPORTANT, &quot;WARNING: HTTP: Invalid Response: Headers did not parse at all for &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url);
         } else {
             error = ERR_ZERO_SIZE_OBJECT;
-            debugs(11, (request-&gt;flags.accelerated?DBG_IMPORTANT:2), &quot;WARNING: HTTP: Invalid Response: No object data received for &quot; &lt;&lt;
-                   entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url.host() &lt;&lt; request-&gt;urlpath.termedBuf());
+            debugs(11, (request-&gt;flags.accelerated?DBG_IMPORTANT:2), &quot;WARNING: HTTP: Invalid Response: No object data received for &quot; &lt;&lt; entry-&gt;url() &lt;&lt; &quot; AKA &quot; &lt;&lt; request-&gt;url);
         }
     }
 
     assert(error != ERR_NONE);
     entry-&gt;reset();
     fwd-&gt;fail(new ErrorState(error, Http::scBadGateway, fwd-&gt;request));
     flags.do_next_read = false;
     serverConnection-&gt;close();
     return false; // quit on error
 }
 
 /** truncate what we read if we read too much so that writeReplyBody()
     writes no more than what we should have read */
 void
 HttpStateData::truncateVirginBody()
 {
     assert(flags.headers_parsed);
 
     HttpReply *vrep = virginReply();
     int64_t clen = -1;
@@ -2150,45 +2149,48 @@
 
     return result;
 }
 
 /* build request prefix and append it to a given MemBuf;
  * return the length of the prefix */
 mb_size_t
 HttpStateData::buildRequestPrefix(MemBuf * mb)
 {
     const int offset = mb-&gt;size;
     /* Uses a local httpver variable to print the HTTP label
      * since the HttpRequest may have an older version label.
      * XXX: This could create protocol bugs as the headers sent and
      * flow control should all be based on the HttpRequest version
      * not the one we are sending. Needs checking.
      */
     const AnyP::ProtocolVersion httpver = Http::ProtocolVersion();
     const char * url;
     if (_peer &amp;&amp; !_peer-&gt;options.originserver)
         url = urlCanonical(request);
-    else
-        url = request-&gt;urlpath.termedBuf();
+    else {
+        // XXX: performance regression, c_str() reallocates
+        SBuf tmp = request-&gt;url.path();
+        url = tmp.c_str();
+    }
     mb-&gt;appendf(SQUIDSBUFPH &quot; %s %s/%d.%d\r\n&quot;,
                 SQUIDSBUFPRINT(request-&gt;method.image()),
-                url &amp;&amp; *url ? url : &quot;/&quot;,
+                url,
                 AnyP::ProtocolType_str[httpver.protocol],
                 httpver.major,httpver.minor);
     /* build and pack headers */
     {
         HttpHeader hdr(hoRequest);
         httpBuildRequestHeader(request, entry, fwd-&gt;al, &amp;hdr, flags);
 
         if (request-&gt;flags.pinned &amp;&amp; request-&gt;flags.connectionAuth)
             request-&gt;flags.authSent = true;
         else if (hdr.has(HDR_AUTHORIZATION))
             request-&gt;flags.authSent = true;
 
         hdr.packInto(mb);
         hdr.clean();
     }
     /* append header terminator */
     mb-&gt;append(crlf, 2);
     return mb-&gt;size - offset;
 }
 

=== modified file 'src/icmp/net_db.cc'
--- src/icmp/net_db.cc	2015-06-09 06:14:43 +0000
+++ src/icmp/net_db.cc	2015-06-19 11:45:11 +0000
@@ -1272,41 +1272,42 @@
     }
 
     assert(0 == i);
     s-&gt;flush();
     memFree(buf, MEM_4K_BUF);
 #else
 
     reply-&gt;setHeaders(Http::scBadRequest, &quot;Bad Request&quot;, NULL, -1, squid_curtime, -2);
     s-&gt;replaceHttpReply(reply);
     storeAppendPrintf(s, &quot;NETDB support not compiled into this Squid cache.\n&quot;);
 #endif
 
     s-&gt;complete();
 }
 
 void
 netdbExchangeStart(void *data)
 {
 #if USE_ICMP
     CachePeer *p = (CachePeer *)data;
-    char *uri = internalRemoteUri(p-&gt;host, p-&gt;http_port, &quot;/squid-internal-dynamic/&quot;, &quot;netdb&quot;);
+    static const SBuf netDB(&quot;netdb&quot;);
+    char *uri = internalRemoteUri(p-&gt;host, p-&gt;http_port, &quot;/squid-internal-dynamic/&quot;, netDB);
     debugs(38, 3, &quot;netdbExchangeStart: Requesting '&quot; &lt;&lt; uri &lt;&lt; &quot;'&quot;);
     assert(NULL != uri);
     HttpRequest *req = HttpRequest::CreateFromUrl(uri);
 
     if (req == NULL) {
         debugs(38, DBG_IMPORTANT, &quot;netdbExchangeStart: Bad URI &quot; &lt;&lt; uri);
         return;
     }
 
     netdbExchangeState *ex = new netdbExchangeState(p, req);
     ex-&gt;e = storeCreateEntry(uri, uri, RequestFlags(), Http::METHOD_GET);
     assert(NULL != ex-&gt;e);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.length = ex-&gt;buf_sz;
     tempBuffer.data = ex-&gt;buf;
 
     ex-&gt;sc = storeClientListAdd(ex-&gt;e, ex);
 
     storeClientCopy(ex-&gt;sc, ex-&gt;e, tempBuffer,

=== modified file 'src/internal.cc'
--- src/internal.cc	2015-06-09 06:14:43 +0000
+++ src/internal.cc	2015-06-28 07:19:47 +0000
@@ -15,134 +15,140 @@
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;icmp/net_db.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;tools.h&quot;
 #include &quot;URL.h&quot;
 #include &quot;util.h&quot;
 #include &quot;wordlist.h&quot;
 
 /* called when we &quot;miss&quot; on an internal object;
  * generate known dynamic objects,
  * return Http::scNotFound for others
  */
 void
 internalStart(const Comm::ConnectionPointer &amp;clientConn, HttpRequest * request, StoreEntry * entry)
 {
     ErrorState *err;
-    const char *upath = request-&gt;urlpath.termedBuf();
-    debugs(76, 3, HERE &lt;&lt; clientConn &lt;&lt; &quot; requesting '&quot; &lt;&lt; upath &lt;&lt; &quot;'&quot;);
+    const SBuf upath = request-&gt;url.path();
+    debugs(76, 3, clientConn &lt;&lt; &quot; requesting '&quot; &lt;&lt; upath &lt;&lt; &quot;'&quot;);
 
-    if (0 == strcmp(upath, &quot;/squid-internal-dynamic/netdb&quot;)) {
+    static const SBuf netdbUri(&quot;/squid-internal-dynamic/netdb&quot;);
+    static const SBuf storeDigestUri(&quot;/squid-internal-periodic/store_digest&quot;);
+    static const SBuf mgrPfx(&quot;/squid-internal-mgr/&quot;);
+
+    if (upath.cmp(netdbUri) == 0) {
         netdbBinaryExchange(entry);
-    } else if (0 == strcmp(upath, &quot;/squid-internal-periodic/store_digest&quot;)) {
+    } else if (upath.cmp(storeDigestUri) == 0) {
 #if USE_CACHE_DIGESTS
         const char *msgbuf = &quot;This cache is currently building its digest.\n&quot;;
 #else
 
         const char *msgbuf = &quot;This cache does not support Cache Digests.\n&quot;;
 #endif
 
         HttpReply *reply = new HttpReply;
         reply-&gt;setHeaders(Http::scNotFound, &quot;Not Found&quot;, &quot;text/plain&quot;, strlen(msgbuf), squid_curtime, -2);
         entry-&gt;replaceHttpReply(reply);
         entry-&gt;append(msgbuf, strlen(msgbuf));
         entry-&gt;complete();
-    } else if (0 == strncmp(upath, &quot;/squid-internal-mgr/&quot;, 20)) {
-        debugs(17, 2, &quot;calling CacheManager due to URL-path /squid-internal-mgr/&quot;);
+    } else if (upath.cmp(mgrPfx, mgrPfx.length()) == 0) {
+        debugs(17, 2, &quot;calling CacheManager due to URL-path &quot; &lt;&lt; mgrPfx);
         CacheManager::GetInstance()-&gt;Start(clientConn, request, entry);
     } else {
         debugObj(76, 1, &quot;internalStart: unknown request:\n&quot;,
                  request, (ObjPackMethod) &amp; httpRequestPack);
         err = new ErrorState(ERR_INVALID_REQ, Http::scNotFound, request);
         errorAppendEntry(entry, err);
     }
 }
 
-int
-internalCheck(const char *urlpath)
+bool
+internalCheck(const SBuf &amp;urlPath)
 {
-    return (0 == strncmp(urlpath, &quot;/squid-internal-&quot;, 16));
+    static const SBuf InternalPfx(&quot;/squid-internal-&quot;);
+    return urlPath.cmp(InternalPfx, InternalPfx.length()) == 0;
 }
 
-int
-internalStaticCheck(const char *urlpath)
+bool
+internalStaticCheck(const SBuf &amp;urlPath)
 {
-    return (0 == strncmp(urlpath, &quot;/squid-internal-static&quot;, 22));
+    static const SBuf InternalStaticPfx(&quot;/squid-internal-static&quot;);
+    return urlPath.cmp(InternalStaticPfx, InternalStaticPfx.length()) == 0;
 }
 
 /*
  * makes internal url with a given host and port (remote internal url)
  */
 char *
-internalRemoteUri(const char *host, unsigned short port, const char *dir, const char *name)
+internalRemoteUri(const char *host, unsigned short port, const char *dir, const SBuf &amp;name)
 {
     static char lc_host[SQUIDHOSTNAMELEN];
-    assert(host &amp;&amp; name);
+    assert(host &amp;&amp; !name.isEmpty());
     /* convert host name to lower case */
     xstrncpy(lc_host, host, SQUIDHOSTNAMELEN);
     Tolower(lc_host);
 
     /* check for an IP address and format appropriately if found */
     Ip::Address test = lc_host;
     if ( !test.isAnyAddr() ) {
         test.toHostStr(lc_host,SQUIDHOSTNAMELEN);
     }
 
     /*
      * append the domain in order to mirror the requests with appended
      * domains
      */
 
     /* For IPv6 addresses also check for a colon */
     if (Config.appendDomain &amp;&amp; !strchr(lc_host, '.') &amp;&amp; !strchr(lc_host, ':'))
         strncat(lc_host, Config.appendDomain, SQUIDHOSTNAMELEN -
                 strlen(lc_host) - 1);
 
     /* build URI */
     URL tmp(AnyP::PROTO_HTTP);
     tmp.host(lc_host);
     if (port)
         tmp.port(port);
 
     static MemBuf mb;
 
     mb.reset();
     mb.appendf(&quot;<A HREF="http://">http://</A>&quot; SQUIDSBUFPH, SQUIDSBUFPRINT(tmp.authority()));
 
     if (dir)
         mb.append(dir, strlen(dir));
 
-    mb.append(name, strlen(name));
+    mb.append(name.rawContent(), name.length());
 
     /* return a pointer to a local static buffer */
     return mb.buf;
 }
 
 /*
  * makes internal url with local host and port
  */
 char *
-internalLocalUri(const char *dir, const char *name)
+internalLocalUri(const char *dir, const SBuf &amp;name)
 {
     return internalRemoteUri(getMyHostname(),
                              getMyPort(), dir, name);
 }
 
 const char *
 internalHostname(void)
 {
     LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
     xstrncpy(host, getMyHostname(), SQUIDHOSTNAMELEN);
 
     /* For IPv6 addresses also check for a colon */
     if (Config.appendDomain &amp;&amp; !strchr(host, '.') &amp;&amp; !strchr(host, ':'))
         strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN -
                 strlen(host) - 1);
 
     Tolower(host);
 
     return host;
 }

=== modified file 'src/internal.h'
--- src/internal.h	2015-01-13 07:25:36 +0000
+++ src/internal.h	2015-06-19 11:44:31 +0000
@@ -1,30 +1,32 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /*
  * DEBUG: section 76    Internal Squid Object handling
  * AUTHOR: Duane, Alex, Henrik
  */
 
 #ifndef SQUID_INTERNAL_H_
 #define SQUID_INTERNAL_H_
 
 #include &quot;comm/forward.h&quot;
+
 class HttpRequest;
+class SBuf;
 class StoreEntry;
 
 void internalStart(const Comm::ConnectionPointer &amp;clientConn, HttpRequest *, StoreEntry *);
-int internalCheck(const char *urlpath);
-int internalStaticCheck(const char *urlpath);
-char *internalLocalUri(const char *dir, const char *name);
-char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
+bool internalCheck(const SBuf &amp;urlPath);
+bool internalStaticCheck(const SBuf &amp;urlPath);
+char *internalLocalUri(const char *dir, const SBuf &amp;name);
+char *internalRemoteUri(const char *, unsigned short, const char *, const SBuf &amp;);
 const char *internalHostname(void);
 int internalHostnameIs(const char *);
 
 #endif /* SQUID_INTERNAL_H_ */
 

=== modified file 'src/mime.cc'
--- src/mime.cc	2015-06-18 15:11:24 +0000
+++ src/mime.cc	2015-06-18 16:36:22 +0000
@@ -101,89 +101,89 @@
         else if (!strcmp(m-&gt;content_encoding, dash_str))
             (void) 0;
         else {
             /* Assume we matched /\.\w$/ and cut off the last extension */
             if ((t = strrchr(name, '.'))) {
                 *t = '\0';
             } else {
                 /* What? A encoding without a extension? */
                 m = NULL;
             }
         }
     } while (t);
 
     xfree(name);
     return m;
 }
 
 MimeIcon::MimeIcon(const char *aName) :
     icon_(aName)
 {
-    url_ = xstrdup(internalLocalUri(&quot;/squid-internal-static/icons/&quot;, icon_.c_str()));
+    url_ = xstrdup(internalLocalUri(&quot;/squid-internal-static/icons/&quot;, icon_));
 }
 
 MimeIcon::~MimeIcon()
 {
     xfree(url_);
 }
 
 void
 MimeIcon::setName(char const *aString)
 {
     xfree(url_);
     icon_ = aString;
-    url_ = xstrdup(internalLocalUri(&quot;/squid-internal-static/icons/&quot;, icon_.c_str()));
+    url_ = xstrdup(internalLocalUri(&quot;/squid-internal-static/icons/&quot;, icon_));
 }
 
 SBuf
 MimeIcon::getName() const
 {
     return icon_;
 }
 
 const SBuf
 mimeGetIcon(const char *fn)
 {
     MimeEntry *m = mimeGetEntry(fn, 1);
 
     if (!m || !m-&gt;theIcon.getName().cmp(dash_str))
         return SBuf();
 
     return m-&gt;theIcon.getName();
 }
 
 const char *
 mimeGetIconURL(const char *fn)
 {
     SBuf icon(mimeGetIcon(fn));
 
     if (icon.isEmpty())
         return null_string;
 
     if (Config.icons.use_short_names) {
         static SBuf mb;
         mb.clear();
         mb.append(&quot;/squid-internal-static/icons/&quot;);
         mb.append(icon);
         return mb.c_str();
     } else {
-        return internalLocalUri(&quot;/squid-internal-static/icons/&quot;, icon.c_str());
+        return internalLocalUri(&quot;/squid-internal-static/icons/&quot;, icon);
     }
 }
 
 const char *
 mimeGetContentType(const char *fn)
 {
     MimeEntry *m = mimeGetEntry(fn, 1);
 
     if (m == NULL)
         return NULL;
 
     if (!strcmp(m-&gt;content_type, dash_str))
         return NULL;
 
     return m-&gt;content_type;
 }
 
 const char *
 mimeGetContentEncoding(const char *fn)
 {

=== modified file 'src/peer_digest.cc'
--- src/peer_digest.cc	2015-02-04 03:22:38 +0000
+++ src/peer_digest.cc	2015-06-19 11:45:55 +0000
@@ -313,41 +313,41 @@
 
 /* ask store for a digest */
 static void
 peerDigestRequest(PeerDigest * pd)
 {
     CachePeer *p = pd-&gt;peer;
     StoreEntry *e, *old_e;
     char *url = NULL;
     const cache_key *key;
     HttpRequest *req;
     StoreIOBuffer tempBuffer;
 
     pd-&gt;req_result = NULL;
     pd-&gt;flags.requested = true;
 
     /* compute future request components */
 
     if (p-&gt;digest_url)
         url = xstrdup(p-&gt;digest_url);
     else
-        url = xstrdup(internalRemoteUri(p-&gt;host, p-&gt;http_port, &quot;/squid-internal-periodic/&quot;, StoreDigestFileName));
+        url = xstrdup(internalRemoteUri(p-&gt;host, p-&gt;http_port, &quot;/squid-internal-periodic/&quot;, SBuf(StoreDigestFileName)));
 
     req = HttpRequest::CreateFromUrl(url);
 
     assert(req);
 
     key = storeKeyPublicByRequest(req);
 
     debugs(72, 2, &quot;peerDigestRequest: &quot; &lt;&lt; url &lt;&lt; &quot; key: &quot; &lt;&lt; storeKeyText(key));
 
     /* add custom headers */
     assert(!req-&gt;header.len);
 
     req-&gt;header.putStr(HDR_ACCEPT, StoreDigestMimeStr);
 
     req-&gt;header.putStr(HDR_ACCEPT, &quot;text/html&quot;);
 
     if (p-&gt;login &amp;&amp;
             p-&gt;login[0] != '*' &amp;&amp;
             strcmp(p-&gt;login, &quot;PASS&quot;) != 0 &amp;&amp;
             strcmp(p-&gt;login, &quot;PASSTHRU&quot;) != 0 &amp;&amp;

=== modified file 'src/tests/testHttpRequest.cc'
--- src/tests/testHttpRequest.cc	2015-06-09 06:14:43 +0000
+++ src/tests/testHttpRequest.cc	2015-06-23 11:16:56 +0000
@@ -32,138 +32,138 @@
 {
     Mem::Init();
     httpHeaderInitModule();
 }
 
 /*
  * Test creating an HttpRequest object from a Url and method
  */
 void
 testHttpRequest::testCreateFromUrlAndMethod()
 {
     /* vanilla url */
     unsigned short expected_port;
     char * url = xstrdup(&quot;<A HREF="http://foo:90/bar">http://foo:90/bar</A>&quot;);
     HttpRequest *aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 90;
     HttpRequest *nullRequest = NULL;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;/bar&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;/bar&quot;), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;<A HREF="http://foo:90/bar">http://foo:90/bar</A>&quot;), String(url));
     xfree(url);
 
     /* vanilla url, different method */
     url = xstrdup(&quot;<A HREF="http://foo/bar">http://foo/bar</A>&quot;);
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_PUT);
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_PUT);
     CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;/bar&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;/bar&quot;), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;<A HREF="http://foo/bar">http://foo/bar</A>&quot;), String(url));
     xfree(url);
 
     /* a connect url with non-CONNECT data */
     url = xstrdup(&quot;:foo/bar&quot;);
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_CONNECT);
     xfree(url);
     CPPUNIT_ASSERT_EQUAL(nullRequest, aRequest);
 
     /* a CONNECT url with CONNECT data */
     url = xstrdup(&quot;foo:45&quot;);
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_CONNECT);
     expected_port = 45;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_CONNECT);
     CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;foo:45&quot;), String(url));
     xfree(url);
 }
 
 /*
  * Test creating an HttpRequest object from a Url alone.
  */
 void
 testHttpRequest::testCreateFromUrl()
 {
     /* vanilla url */
     unsigned short expected_port;
     char * url = xstrdup(&quot;<A HREF="http://foo:90/bar">http://foo:90/bar</A>&quot;);
     HttpRequest *aRequest = HttpRequest::CreateFromUrl(url);
     expected_port = 90;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;/bar&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;/bar&quot;), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;<A HREF="http://foo:90/bar">http://foo:90/bar</A>&quot;), String(url));
     xfree(url);
 }
 
 /*
  * Test BUG: URL '2000:800:45' opens host 2000 port 800 !!
  */
 void
 testHttpRequest::testIPv6HostColonBug()
 {
     unsigned short expected_port;
     char * url = NULL;
     HttpRequest *aRequest = NULL;
 
     /* valid IPv6 address without port */
     url = xstrdup(&quot;<A HREF="http://[2000:800::45">http://[2000:800::45</A>]/foo&quot;);
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String(&quot;[2000:800::45]&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;/foo&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;/foo&quot;), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;<A HREF="http://[2000:800::45">http://[2000:800::45</A>]/foo&quot;), String(url));
     xfree(url);
 
     /* valid IPv6 address with port */
     url = xstrdup(&quot;<A HREF="http://[2000:800::45">http://[2000:800::45</A>]:90/foo&quot;);
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 90;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String(&quot;[2000:800::45]&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;/foo&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;/foo&quot;), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;<A HREF="http://[2000:800::45">http://[2000:800::45</A>]:90/foo&quot;), String(url));
     xfree(url);
 
     /* IPv6 address as invalid (bug trigger) */
     url = xstrdup(&quot;<A HREF="http://2000:800::45/foo">http://2000:800::45/foo</A>&quot;);
     aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest-&gt;url.port());
     CPPUNIT_ASSERT(aRequest-&gt;method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String(&quot;[2000:800::45]&quot;), String(aRequest-&gt;url.host()));
-    CPPUNIT_ASSERT_EQUAL(String(&quot;/foo&quot;), aRequest-&gt;urlpath);
+    CPPUNIT_ASSERT_EQUAL(SBuf(&quot;/foo&quot;), aRequest-&gt;url.path());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast&lt;AnyP::ProtocolType&gt;(aRequest-&gt;url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String(&quot;<A HREF="http://2000:800::45/foo">http://2000:800::45/foo</A>&quot;), String(url));
     xfree(url);
 }
 
 void
 testHttpRequest::testSanityCheckStartLine()
 {
     MemBuf input;
     PrivateHttpRequest engine;
     Http::StatusCode error = Http::scNone;
     size_t hdr_len;
     input.init();
 
     // a valid request line
     input.append(&quot;GET / HTTP/1.1\n\n&quot;, 16);
     hdr_len = headersEnd(input.content(), input.contentSize());
     CPPUNIT_ASSERT(engine.doSanityCheckStartLine(input.content(), hdr_len, &amp;error) );
     CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();

=== modified file 'src/url.cc'
--- src/url.cc	2015-06-09 06:14:43 +0000
+++ src/url.cc	2015-06-15 10:46:18 +0000
@@ -27,56 +27,75 @@
 static const char valid_hostname_chars_u[] =
     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
     &quot;abcdefghijklmnopqrstuvwxyz&quot;
     &quot;0123456789-._&quot;
     &quot;[:]&quot;
     ;
 static const char valid_hostname_chars[] =
     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
     &quot;abcdefghijklmnopqrstuvwxyz&quot;
     &quot;0123456789-.&quot;
     &quot;[:]&quot;
     ;
 
 const SBuf &amp;
 URL::Asterisk()
 {
     static SBuf star(&quot;*&quot;);
     return star;
 }
 
+const SBuf &amp;
+URL::SlashPath()
+{
+    static SBuf slash(&quot;/&quot;);
+    return slash;
+}
+
 void
 URL::host(const char *src)
 {
     hostAddr_.setEmpty();
     hostAddr_ = src;
     if (hostAddr_.isAnyAddr()) {
         xstrncpy(host_, src, sizeof(host_));
         hostIsNumeric_ = false;
     } else {
         hostAddr_.toHostStr(host_, sizeof(host_));
         debugs(23, 3, &quot;given IP: &quot; &lt;&lt; hostAddr_);
         hostIsNumeric_ = 1;
     }
     touch();
 }
 
+const SBuf &amp;
+URL::path() const
+{
+    // RFC 3986 section 3.3 says path can be empty (path-abempty).
+    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to &quot;/&quot;
+    // at least when sending and using. We must still accept path-abempty as input.
+    if (path_.isEmpty() &amp;&amp; (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))
+        return SlashPath();
+
+    return path_;
+}
+
 void
 urlInitialize(void)
 {
     debugs(23, 5, &quot;urlInitialize: Initializing...&quot;);
     /* this ensures that the number of protocol strings is the same as
      * the enum slots allocated because the last enum is always 'MAX'.
      */
     assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], &quot;MAX&quot;) == 0);
     /*
      * These test that our matchDomainName() function works the
      * way we expect it to.
      */
     assert(0 == matchDomainName(&quot;foo.com&quot;, &quot;foo.com&quot;));
     assert(0 == matchDomainName(&quot;.foo.com&quot;, &quot;foo.com&quot;));
     assert(0 == matchDomainName(&quot;foo.com&quot;, &quot;.foo.com&quot;));
     assert(0 == matchDomainName(&quot;.foo.com&quot;, &quot;.foo.com&quot;));
     assert(0 == matchDomainName(&quot;x.foo.com&quot;, &quot;.foo.com&quot;));
     assert(0 != matchDomainName(&quot;x.foo.com&quot;, &quot;foo.com&quot;));
     assert(0 != matchDomainName(&quot;foo.com&quot;, &quot;x.foo.com&quot;));
     assert(0 != matchDomainName(&quot;bar.com&quot;, &quot;foo.com&quot;));
@@ -469,96 +488,96 @@
         authorityHttp_ = authorityWithPort_;
 
         // authorityForm_ only has :port if it is non-default
         authorityWithPort_.appendf(&quot;:%u&quot;,port());
         if (port() != getScheme().defaultPort())
             authorityHttp_ = authorityWithPort_;
     }
 
     return requirePort ? authorityWithPort_ : authorityHttp_;
 }
 
 const char *
 urlCanonical(HttpRequest * request)
 {
     LOCAL_ARRAY(char, urlbuf, MAX_URL);
 
     if (request-&gt;canonical)
         return request-&gt;canonical;
 
     if (request-&gt;url.getScheme() == AnyP::PROTO_URN) {
-        snprintf(urlbuf, MAX_URL, &quot;urn:&quot; SQUIDSTRINGPH,
-                 SQUIDSTRINGPRINT(request-&gt;urlpath));
+        snprintf(urlbuf, MAX_URL, &quot;urn:&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(request-&gt;url.path()));
     } else {
         SBuf authorityForm;
         switch (request-&gt;method.id()) {
 
         case Http::METHOD_CONNECT:
             authorityForm = request-&gt;url.authority(true); // host:port
             snprintf(urlbuf, MAX_URL, SQUIDSBUFPH, SQUIDSBUFPRINT(authorityForm));
             break;
 
         default: {
             authorityForm = request-&gt;url.authority(); // host[:port]
-            snprintf(urlbuf, MAX_URL, &quot;%<A HREF="s://">s://</A>&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH SQUIDSTRINGPH,
+            snprintf(urlbuf, MAX_URL, &quot;%<A HREF="s://">s://</A>&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH SQUIDSBUFPH,
                      request-&gt;url.getScheme().c_str(),
                      SQUIDSBUFPRINT(request-&gt;url.userInfo()),
                      !request-&gt;url.userInfo().isEmpty() ? &quot;@&quot; : &quot;&quot;,
                      SQUIDSBUFPRINT(authorityForm),
-                     SQUIDSTRINGPRINT(request-&gt;urlpath));
+                     SQUIDSBUFPRINT(request-&gt;url.path()));
         }
         }
     }
 
     return (request-&gt;canonical = xstrdup(urlbuf));
 }
 
 /** \todo AYJ: Performance: This is an *almost* duplicate of urlCanonical. But elides the query-string.
  *        After copying it on in the first place! Would be less code to merge the two with a flag parameter.
  *        and never copy the query-string part in the first place
  */
 char *
 urlCanonicalClean(const HttpRequest * request)
 {
     LOCAL_ARRAY(char, buf, MAX_URL);
     char *t;
 
     if (request-&gt;url.getScheme() == AnyP::PROTO_URN) {
-        snprintf(buf, MAX_URL, &quot;urn:&quot; SQUIDSTRINGPH,
-                 SQUIDSTRINGPRINT(request-&gt;urlpath));
+        snprintf(buf, MAX_URL, &quot;urn:&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(request-&gt;url.path()));
     } else {
         SBuf authorityForm;
         switch (request-&gt;method.id()) {
 
         case Http::METHOD_CONNECT:
             authorityForm = request-&gt;url.authority(true); // host:port
             snprintf(buf, MAX_URL, SQUIDSBUFPH, SQUIDSBUFPRINT(authorityForm));
             break;
 
         default: {
             authorityForm = request-&gt;url.authority(); // host[:port]
-            snprintf(buf, MAX_URL, &quot;%<A HREF="s://">s://</A>&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH SQUIDSTRINGPH,
+            snprintf(buf, MAX_URL, &quot;%<A HREF="s://">s://</A>&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH SQUIDSBUFPH,
                      request-&gt;url.getScheme().c_str(),
                      SQUIDSBUFPRINT(request-&gt;url.userInfo()),
                      !request-&gt;url.userInfo().isEmpty() ? &quot;@&quot; : &quot;&quot;,
                      SQUIDSBUFPRINT(authorityForm),
-                     SQUIDSTRINGPRINT(request-&gt;urlpath));
+                     SQUIDSBUFPRINT(request-&gt;url.path()));
 
             // strip arguments AFTER a question-mark
             if (Config.onoff.strip_query_terms)
                 if ((t = strchr(buf, '?')))
                     *(++t) = '\0';
         }
         } // switch
     }
 
     if (stringHasCntl(buf))
         xstrncpy(buf, rfc1738_escape_unescaped(buf), MAX_URL);
 
     return buf;
 }
 
 /**
  * Yet another alternative to urlCanonical.
  * This one adds the <A HREF="https://">https://</A> parts to Http::METHOD_CONNECT URL
  * for use in error page outputs.
  * Luckily we can leverage the others instead of duplicating.
@@ -611,70 +630,75 @@
  * It is assumed that you have already ensured that the URL is relative.
  *
  * If NULL is returned it is an indication that the method in use in the
  * request does not distinguish between relative and absolute and you should
  * use the url unchanged.
  *
  * If non-NULL is returned, it is up to the caller to free the resulting
  * memory using safe_free().
  */
 char *
 urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 {
 
     if (req-&gt;method.id() == Http::METHOD_CONNECT) {
         return (NULL);
     }
 
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
     if (req-&gt;url.getScheme() == AnyP::PROTO_URN) {
-        snprintf(urlbuf, MAX_URL, &quot;urn:&quot; SQUIDSTRINGPH,
-                 SQUIDSTRINGPRINT(req-&gt;urlpath));
+        snprintf(urlbuf, MAX_URL, &quot;urn:&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(req-&gt;url.path()));
         return (urlbuf);
     }
 
     SBuf authorityForm = req-&gt;url.authority(); // host[:port]
     size_t urllen = snprintf(urlbuf, MAX_URL, &quot;%<A HREF="s://">s://</A>&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH,
                              req-&gt;url.getScheme().c_str(),
                              SQUIDSBUFPRINT(req-&gt;url.userInfo()),
                              !req-&gt;url.userInfo().isEmpty() ? &quot;@&quot; : &quot;&quot;,
                              SQUIDSBUFPRINT(authorityForm));
 
+    // if the first char is '/' assume its a relative path
+    // XXX: this breaks on scheme-relative URLs,
+    // but we should not see those outside ESI, and rarely there.
     if (relUrl[0] == '/') {
         strncpy(&amp;urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
     } else {
-        const char *path = req-&gt;urlpath.termedBuf();
-        const char *last_slash = strrchr(path, '/');
+        SBuf path = req-&gt;url.path();
+        SBuf::size_type lastSlashPos = path.rfind('/');
 
-        if (last_slash == NULL) {
+        if (lastSlashPos == SBuf::npos) {
+            // replace the whole path with the given bit(s)
             urlbuf[urllen] = '/';
             ++urllen;
             strncpy(&amp;urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
         } else {
-            ++last_slash;
-            size_t pathlen = last_slash - path;
-            if (pathlen &gt; MAX_URL - urllen - 1) {
-                pathlen = MAX_URL - urllen - 1;
+            // replace only the last (file?) segment with the given bit(s)
+            ++lastSlashPos;
+            if (lastSlashPos &gt; MAX_URL - urllen - 1) {
+                // XXX: crops bits in the middle of the combined URL.
+                lastSlashPos = MAX_URL - urllen - 1;
             }
-            strncpy(&amp;urlbuf[urllen], path, pathlen);
-            urllen += pathlen;
+            strncpy(&amp;urlbuf[urllen], path.rawContent(), lastSlashPos);
+            urllen += lastSlashPos;
             if (urllen + 1 &lt; MAX_URL) {
                 strncpy(&amp;urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
             }
         }
     }
 
     return (urlbuf);
 }
 
 int
 matchDomainName(const char *h, const char *d, bool honorWildcards)
 {
     int dl;
     int hl;
 
     while ('.' == *h)
         ++h;
 
     hl = strlen(h);
 
@@ -753,41 +777,41 @@
 urlCheckRequest(const HttpRequest * r)
 {
     int rc = 0;
     /* protocol &quot;independent&quot; methods
      *
      * actually these methods are specific to HTTP:
      * they are methods we recieve on our HTTP port,
      * and if we had a FTP listener would not be relevant
      * there.
      *
      * So, we should delegate them to HTTP. The problem is that we
      * do not have a default protocol from the client side of HTTP.
      */
 
     if (r-&gt;method == Http::METHOD_CONNECT)
         return 1;
 
     // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)
     // we also support forwarding OPTIONS and TRACE, except for the *-URI ones
     if (r-&gt;method == Http::METHOD_OPTIONS || r-&gt;method == Http::METHOD_TRACE)
-        return (r-&gt;header.getInt64(HDR_MAX_FORWARDS) == 0 || URL::Asterisk().cmp(r-&gt;urlpath.rawBuf(), r-&gt;urlpath.size()) != 0);
+        return (r-&gt;header.getInt64(HDR_MAX_FORWARDS) == 0 || URL::Asterisk().cmp(r-&gt;url.path()) != 0);
 
     if (r-&gt;method == Http::METHOD_PURGE)
         return 1;
 
     /* does method match the protocol? */
     switch (r-&gt;url.getScheme()) {
 
     case AnyP::PROTO_URN:
 
     case AnyP::PROTO_HTTP:
 
     case AnyP::PROTO_CACHE_OBJECT:
         rc = 1;
         break;
 
     case AnyP::PROTO_FTP:
 
         if (r-&gt;method == Http::METHOD_PUT)
             rc = 1;
 

=== modified file 'src/urn.cc'
--- src/urn.cc	2015-05-26 18:12:08 +0000
+++ src/urn.cc	2015-06-15 11:06:49 +0000
@@ -18,45 +18,43 @@
 #include &quot;icmp/net_db.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;mime_header.h&quot;
 #include &quot;RequestFlags.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;StoreClient.h&quot;
 #include &quot;tools.h&quot;
 #include &quot;URL.h&quot;
 #include &quot;urn.h&quot;
 
 #define URN_REQBUF_SZ   4096
 
 class UrnState : public StoreClient
 {
     CBDATA_CLASS(UrnState);
 
 public:
     void created (StoreEntry *newEntry);
     void start (HttpRequest *, StoreEntry *);
-    char *getHost (String &amp;urlpath);
+    char *getHost(SBuf &amp;urlpath);
     void setUriResFromRequest(HttpRequest *);
     bool RequestNeedsMenu(HttpRequest *r);
-    void updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len);
-    void createUriResRequest (String &amp;uri);
 
     virtual ~UrnState();
 
     StoreEntry *entry;
     store_client *sc;
     StoreEntry *urlres_e;
     HttpRequest::Pointer request;
     HttpRequest::Pointer urlres_r;
 
     struct {
         bool force_menu;
     } flags;
     char reqbuf[URN_REQBUF_SZ];
     int reqofs;
 
 private:
     char *urlres;
 };
 
 typedef struct {
@@ -111,94 +109,80 @@
 
         if (u-&gt;rtt &gt; min_rtt &amp;&amp; min_rtt != 0)
             continue;
 
         min_rtt = u-&gt;rtt;
 
         min_u = u;
     }
 
     if (rtt_ret)
         *rtt_ret = min_rtt;
 
     debugs(52, DBG_IMPORTANT, &quot;urnFindMinRtt: Returning '&quot; &lt;&lt;
            (min_u ? min_u-&gt;url : &quot;NONE&quot;) &lt;&lt; &quot;' RTT &quot; &lt;&lt;
            min_rtt  );
 
     return min_u;
 }
 
 char *
-UrnState::getHost (String &amp;urlpath)
+UrnState::getHost(SBuf &amp;urlpath)
 {
     char * result;
     size_t p;
 
     /** FIXME: this appears to be parsing the URL. *very* badly. */
     /*   a proper encapsulated URI/URL type needs to clear this up. */
-    if ((p=urlpath.find(':')) != String::npos) {
-        result=xstrndup(urlpath.rawBuf(),p-1);
+    if ((p=urlpath.find(':')) != SBuf::npos) {
+        result=xstrndup(urlpath.rawContent(),p-1);
     } else {
-        result = xstrndup(urlpath.rawBuf(),urlpath.size());
+        result = xstrndup(urlpath.rawContent(),urlpath.length());
     }
     return result;
 }
 
 bool
 UrnState::RequestNeedsMenu(HttpRequest *r)
 {
-    if (r-&gt;urlpath.size() &lt; 5)
+    if (r-&gt;url.path().length() &lt; 5)
         return false;
     //now we're sure it's long enough
-    return strncasecmp(r-&gt;urlpath.rawBuf(), &quot;menu.&quot;, 5) == 0;
+    return r-&gt;url.path().caseCmp(&quot;menu.&quot;, 5) == 0;
 }
 
 void
-UrnState::updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len)
+UrnState::setUriResFromRequest(HttpRequest *r)
 {
-    char *new_path = xstrndup (newPath, newPath_len);
-    r-&gt;urlpath = new_path;
-    xfree(new_path);
-}
+    if (RequestNeedsMenu(r)) {
+        r-&gt;url.path(r-&gt;url.path().substr(5)); // strip prefix &quot;menu.&quot;
+        flags.force_menu = true;
+    }
 
-void
-UrnState::createUriResRequest (String &amp;uri)
-{
+    SBuf uri = r-&gt;url.path();
     LOCAL_ARRAY(char, local_urlres, 4096);
-    char *host = getHost (uri);
-    snprintf(local_urlres, 4096, &quot;<A HREF="http://%s/uri-res/N2L?urn:">http://%s/uri-res/N2L?urn:</A>&quot; SQUIDSTRINGPH,
-             host, SQUIDSTRINGPRINT(uri));
+    char *host = getHost(uri);
+    snprintf(local_urlres, 4096, &quot;<A HREF="http://%s/uri-res/N2L?urn:">http://%s/uri-res/N2L?urn:</A>&quot; SQUIDSBUFPH, host, SQUIDSBUFPRINT(uri));
     safe_free(host);
     safe_free(urlres);
     urlres = xstrdup(local_urlres);
     urlres_r = HttpRequest::CreateFromUrl(urlres);
-}
-
-void
-UrnState::setUriResFromRequest(HttpRequest *r)
-{
-    if (RequestNeedsMenu(r)) {
-        updateRequestURL(r, r-&gt;urlpath.rawBuf() + 5, r-&gt;urlpath.size() - 5 );
-        flags.force_menu = true;
-    }
-
-    createUriResRequest (r-&gt;urlpath);
 
     if (urlres_r == NULL) {
         debugs(52, 3, &quot;urnStart: Bad uri-res URL &quot; &lt;&lt; urlres);
         ErrorState *err = new ErrorState(ERR_URN_RESOLVE, Http::scNotFound, r);
         err-&gt;url = urlres;
         urlres = NULL;
         errorAppendEntry(entry, err);
         return;
     }
 
     urlres_r-&gt;header.putStr(HDR_ACCEPT, &quot;text/plain&quot;);
 }
 
 void
 UrnState::start(HttpRequest * r, StoreEntry * e)
 {
     debugs(52, 3, &quot;urnStart: '&quot; &lt;&lt; e-&gt;url() &lt;&lt; &quot;'&quot; );
     entry = e;
     request = r;
 

=== modified file 'src/whois.cc'
--- src/whois.cc	2015-01-13 07:25:36 +0000
+++ src/whois.cc	2015-06-15 11:09:45 +0000
@@ -39,57 +39,54 @@
     bool dataWritten;
 };
 
 CBDATA_CLASS_INIT(WhoisState);
 
 static CLCB whoisClose;
 static CTCB whoisTimeout;
 static IOCB whoisReadReply;
 
 /* PUBLIC */
 
 static void
 whoisWriteComplete(const Comm::ConnectionPointer &amp;, char *buf, size_t, Comm::Flag, int, void *)
 {
     xfree(buf);
 }
 
 void
 whoisStart(FwdState * fwd)
 {
-    char *buf;
-    size_t l;
     WhoisState *p = new WhoisState;
     p-&gt;request = fwd-&gt;request;
     p-&gt;entry = fwd-&gt;entry;
     p-&gt;fwd = fwd;
     p-&gt;dataWritten = false;
 
     p-&gt;entry-&gt;lock(&quot;whoisStart&quot;);
     comm_add_close_handler(fwd-&gt;serverConnection()-&gt;fd, whoisClose, p);
 
-    l = p-&gt;request-&gt;urlpath.size() + 3;
+    size_t l = p-&gt;request-&gt;url.path().length() + 3;
+    char *buf = (char *)xmalloc(l);
 
-    buf = (char *)xmalloc(l);
-
-    String str_print=p-&gt;request-&gt;urlpath.substr(1,p-&gt;request-&gt;urlpath.size());
-    snprintf(buf, l, SQUIDSTRINGPH&quot;\r\n&quot;, SQUIDSTRINGPRINT(str_print));
+    SBuf str_print = p-&gt;request-&gt;url.path().substr(1);
+    snprintf(buf, l, SQUIDSBUFPH &quot;\r\n&quot;, SQUIDSBUFPRINT(str_print));
 
     AsyncCall::Pointer writeCall = commCbCall(5,5, &quot;whoisWriteComplete&quot;,
                                    CommIoCbPtrFun(whoisWriteComplete, p));
     Comm::Write(fwd-&gt;serverConnection(), buf, strlen(buf), writeCall, NULL);
     AsyncCall::Pointer readCall = commCbCall(5,4, &quot;whoisReadReply&quot;,
                                   CommIoCbPtrFun(whoisReadReply, p));
     comm_read(fwd-&gt;serverConnection(), p-&gt;buf, BUFSIZ, readCall);
     AsyncCall::Pointer timeoutCall = commCbCall(5, 4, &quot;whoisTimeout&quot;,
                                      CommTimeoutCbPtrFun(whoisTimeout, p));
     commSetConnTimeout(fwd-&gt;serverConnection(), Config.Timeout.read, timeoutCall);
 }
 
 /* PRIVATE */
 
 static void
 whoisTimeout(const CommTimeoutCbParams &amp;io)
 {
     WhoisState *p = static_cast&lt;WhoisState *&gt;(io.data);
     debugs(75, 3, HERE &lt;&lt; io.conn &lt;&lt; &quot;, URL &quot; &lt;&lt; p-&gt;entry-&gt;url());
     io.conn-&gt;close();

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002470.html">[squid-dev] [PATCH] SBuf case-change operations are safe against OutOfBoundsEception
</A></li>
	<LI>Next message: <A HREF="002476.html">[squid-dev] [PATCH] Crypto-NG: Use Security::PeerOptions for listening port TLS settings
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2471">[ date ]</a>
              <a href="thread.html#2471">[ thread ]</a>
              <a href="subject.html#2471">[ subject ]</a>
              <a href="author.html#2471">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
