<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] convert CacheDigest to C++ and MEMPROXY
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20convert%20CacheDigest%20to%20C%2B%2B%20and%20MEMPROXY&In-Reply-To=%3C563CEF46.6080609%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003700.html">
   <LINK REL="Next"  HREF="003691.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] convert CacheDigest to C++ and MEMPROXY</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20convert%20CacheDigest%20to%20C%2B%2B%20and%20MEMPROXY&In-Reply-To=%3C563CEF46.6080609%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] convert CacheDigest to C++ and MEMPROXY">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Nov  6 18:19:50 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003700.html">[squid-dev] [PATCH] Handshake Problem during Renegotiation
</A></li>
        <LI>Next message: <A HREF="003691.html">[squid-dev] [PATCH] convert CacheDigest to C++ and MEMPROXY
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3682">[ date ]</a>
              <a href="thread.html#3682">[ thread ]</a>
              <a href="subject.html#3682">[ subject ]</a>
              <a href="author.html#3682">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Convert the gobal C-style functions that operate on class CacheDigest to
class methods in C++ style.

This is largely a symbol renaming change. But there are two relatively
small logic changes:

1) convert the class to MEMPROXY_CLASS.

Which alters the pool creation timing from general memory pool
initialization time, to whenever the CacheDigest object is first used.

A nice side effect is removal the macro conditional within the old pool
type enumeration. Macros like that in enumeration lists such as this one
have been causing some builds to have run-time errors accessing memory
arrays out-of-bounds or incorrect postions when the build-time
dependency detection issues caused build objects to link with different
./configure'd versions.


2) Constructor logic sequence alteration.

The old *Create function used to set some members then call the *Init
function which would re-set some of them, and initialize most of the
rest (but not all).
The old *UpdateCap function would call a helper that emulated
safe_free(mask) then *Init to alter the objects mask related members
whether they needed it or not.

The class constructor now initializes all members via initialization
list then calls updateCapacity(), which calls a simplified init(). This
altered sequence contains the same operational acts while the new order
avoids repeated or unnecesarily setting members on create and update.


Amos
-------------- next part --------------
=== modified file 'src/CacheDigest.cc'
--- src/CacheDigest.cc	2015-01-13 07:25:36 +0000
+++ src/CacheDigest.cc	2015-11-06 10:06:29 +0000
@@ -17,219 +17,202 @@
 #if USE_CACHE_DIGESTS
 
 #include &quot;CacheDigest.h&quot;
 #include &quot;util.h&quot;
 
 /* local types */
 
 typedef struct {
     int bit_count;      /* total number of bits */
     int bit_on_count;       /* #bits turned on */
     int bseq_len_sum;       /* sum of all bit seq length */
     int bseq_count;     /* number of bit seqs */
 } CacheDigestStats;
 
 /* local functions */
 static void cacheDigestHashKey(const CacheDigest * cd, const cache_key * key);
 
 /* static array used by cacheDigestHashKey for optimization purposes */
 static uint32_t hashed_keys[4];
 
-static void
-cacheDigestInit(CacheDigest * cd, int capacity, int bpe)
+void
+CacheDigest::init(int newCapacity)
 {
-    const size_t mask_size = cacheDigestCalcMaskSize(capacity, bpe);
-    assert(cd);
-    assert(capacity &gt; 0 &amp;&amp; bpe &gt; 0);
-    assert(mask_size &gt; 0);
-    cd-&gt;capacity = capacity;
-    cd-&gt;bits_per_entry = bpe;
-    cd-&gt;mask_size = mask_size;
-    cd-&gt;mask = (char *)xcalloc(cd-&gt;mask_size, 1);
-    debugs(70, 2, &quot;cacheDigestInit: capacity: &quot; &lt;&lt; cd-&gt;capacity &lt;&lt; &quot; entries, bpe: &quot; &lt;&lt; cd-&gt;bits_per_entry &lt;&lt; &quot;; size: &quot;
-           &lt;&lt; cd-&gt;mask_size &lt;&lt; &quot; bytes&quot;);
-}
-
-CacheDigest *
-cacheDigestCreate(int capacity, int bpe)
+    const auto newMaskSz = CacheDigest::CalcMaskSize(newCapacity, bits_per_entry);
+    assert(newCapacity &gt; 0 &amp;&amp; bits_per_entry &gt; 0);
+    assert(newMaskSz &gt; 0);
+    capacity = newCapacity;
+    mask_size = newMaskSz;
+    mask = static_cast&lt;char *&gt;(xcalloc(mask_size,1));
+    debugs(70, 2, &quot;capacity: &quot; &lt;&lt; capacity &lt;&lt; &quot; entries, bpe: &quot; &lt;&lt; bits_per_entry &lt;&lt; &quot;; size: &quot;
+           &lt;&lt; mask_size &lt;&lt; &quot; bytes&quot;);
+}
+
+CacheDigest::CacheDigest(int aCapacity, int bpe) :
+        mask(nullptr),
+        mask_size(0),
+        capacity(0),
+        bits_per_entry(bpe),
+        count(0),
+        del_count(0)
 {
-    CacheDigest *cd = (CacheDigest *)memAllocate(MEM_CACHE_DIGEST);
     assert(SQUID_MD5_DIGEST_LENGTH == 16);  /* our hash functions rely on 16 byte keys */
-    cacheDigestInit(cd, capacity, bpe);
-    return cd;
+    updateCapacity(aCapacity);
 }
 
-static void
-cacheDigestClean(CacheDigest * cd)
+CacheDigest::~CacheDigest()
 {
-    assert(cd);
-    xfree(cd-&gt;mask);
-    cd-&gt;mask = NULL;
-}
-
-void
-cacheDigestDestroy(CacheDigest * cd)
-{
-    assert(cd);
-    cacheDigestClean(cd);
-    memFree(cd, MEM_CACHE_DIGEST);
+    xfree(mask);
 }
 
 CacheDigest *
-cacheDigestClone(const CacheDigest * cd)
+CacheDigest::clone() const
 {
-    CacheDigest *clone;
-    assert(cd);
-    clone = cacheDigestCreate(cd-&gt;capacity, cd-&gt;bits_per_entry);
-    clone-&gt;count = cd-&gt;count;
-    clone-&gt;del_count = cd-&gt;del_count;
-    assert(cd-&gt;mask_size == clone-&gt;mask_size);
-    memcpy(clone-&gt;mask, cd-&gt;mask, cd-&gt;mask_size);
-    return clone;
+    CacheDigest *cl = new CacheDigest(capacity, bits_per_entry);
+    cl-&gt;count = count;
+    cl-&gt;del_count = del_count;
+    assert(mask_size == cl-&gt;mask_size);
+    memcpy(cl-&gt;mask, mask, mask_size);
+    return cl;
 }
 
 void
-cacheDigestClear(CacheDigest * cd)
+CacheDigest::clear()
 {
-    assert(cd);
-    cd-&gt;count = cd-&gt;del_count = 0;
-    memset(cd-&gt;mask, 0, cd-&gt;mask_size);
+    count = del_count = 0;
+    memset(mask, 0, mask_size);
 }
 
-/* changes mask size, resets bits to 0, preserves &quot;cd&quot; pointer */
 void
-cacheDigestChangeCap(CacheDigest * cd, int new_cap)
+CacheDigest::updateCapacity(int newCapacity)
 {
-    assert(cd);
-    cacheDigestClean(cd);
-    cacheDigestInit(cd, new_cap, cd-&gt;bits_per_entry);
+    safe_free(mask);
+    init(newCapacity); // will re-init mask and mask_size
 }
 
-/* returns true if the key belongs to the digest */
-int
-cacheDigestTest(const CacheDigest * cd, const cache_key * key)
+bool
+CacheDigest::test(const cache_key * key) const
 {
-    assert(cd &amp;&amp; key);
+    assert(key);
     /* hash */
-    cacheDigestHashKey(cd, key);
+    cacheDigestHashKey(this, key);
     /* test corresponding bits */
     return
-        CBIT_TEST(cd-&gt;mask, hashed_keys[0]) &amp;&amp;
-        CBIT_TEST(cd-&gt;mask, hashed_keys[1]) &amp;&amp;
-        CBIT_TEST(cd-&gt;mask, hashed_keys[2]) &amp;&amp;
-        CBIT_TEST(cd-&gt;mask, hashed_keys[3]);
+        CBIT_TEST(mask, hashed_keys[0]) &amp;&amp;
+        CBIT_TEST(mask, hashed_keys[1]) &amp;&amp;
+        CBIT_TEST(mask, hashed_keys[2]) &amp;&amp;
+        CBIT_TEST(mask, hashed_keys[3]);
 }
 
 void
-cacheDigestAdd(CacheDigest * cd, const cache_key * key)
+CacheDigest::add(const cache_key * key)
 {
-    assert(cd &amp;&amp; key);
+    assert(key);
     /* hash */
-    cacheDigestHashKey(cd, key);
+    cacheDigestHashKey(this, key);
     /* turn on corresponding bits */
 #if CD_FAST_ADD
 
-    CBIT_SET(cd-&gt;mask, hashed_keys[0]);
-    CBIT_SET(cd-&gt;mask, hashed_keys[1]);
-    CBIT_SET(cd-&gt;mask, hashed_keys[2]);
-    CBIT_SET(cd-&gt;mask, hashed_keys[3]);
+    CBIT_SET(mask, hashed_keys[0]);
+    CBIT_SET(mask, hashed_keys[1]);
+    CBIT_SET(mask, hashed_keys[2]);
+    CBIT_SET(mask, hashed_keys[3]);
 #else
 
     {
         int on_xition_cnt = 0;
 
-        if (!CBIT_TEST(cd-&gt;mask, hashed_keys[0])) {
-            CBIT_SET(cd-&gt;mask, hashed_keys[0]);
+        if (!CBIT_TEST(mask, hashed_keys[0])) {
+            CBIT_SET(mask, hashed_keys[0]);
             ++on_xition_cnt;
         }
 
-        if (!CBIT_TEST(cd-&gt;mask, hashed_keys[1])) {
-            CBIT_SET(cd-&gt;mask, hashed_keys[1]);
+        if (!CBIT_TEST(mask, hashed_keys[1])) {
+            CBIT_SET(mask, hashed_keys[1]);
             ++on_xition_cnt;
         }
 
-        if (!CBIT_TEST(cd-&gt;mask, hashed_keys[2])) {
-            CBIT_SET(cd-&gt;mask, hashed_keys[2]);
+        if (!CBIT_TEST(mask, hashed_keys[2])) {
+            CBIT_SET(mask, hashed_keys[2]);
             ++on_xition_cnt;
         }
 
-        if (!CBIT_TEST(cd-&gt;mask, hashed_keys[3])) {
-            CBIT_SET(cd-&gt;mask, hashed_keys[3]);
+        if (!CBIT_TEST(mask, hashed_keys[3])) {
+            CBIT_SET(mask, hashed_keys[3]);
             ++on_xition_cnt;
         }
 
         statCounter.cd.on_xition_count.count(on_xition_cnt);
     }
 #endif
-    ++ cd-&gt;count;
+    ++count;
 }
 
 void
-cacheDigestDel(CacheDigest * cd, const cache_key * key)
+CacheDigest::remove(const cache_key * key)
 {
-    assert(cd &amp;&amp; key);
-    ++ cd-&gt;del_count;
+    assert(key);
+    ++del_count;
     /* we do not support deletions from the digest */
 }
 
 /* returns mask utilization parameters */
 static void
 cacheDigestStats(const CacheDigest * cd, CacheDigestStats * stats)
 {
     int on_count = 0;
     int pos = cd-&gt;mask_size * 8;
     int seq_len_sum = 0;
     int seq_count = 0;
     int cur_seq_len = 0;
     int cur_seq_type = 1;
     assert(stats);
     memset(stats, 0, sizeof(*stats));
 
     while (pos-- &gt; 0) {
         const int is_on = 0 != CBIT_TEST(cd-&gt;mask, pos);
 
         if (is_on)
             ++on_count;
 
         if (is_on != cur_seq_type || !pos) {
             seq_len_sum += cur_seq_len;
             ++seq_count;
             cur_seq_type = is_on;
             cur_seq_len = 0;
         }
 
         ++cur_seq_len;
     }
 
     stats-&gt;bit_count = cd-&gt;mask_size * 8;
     stats-&gt;bit_on_count = on_count;
     stats-&gt;bseq_len_sum = seq_len_sum;
     stats-&gt;bseq_count = seq_count;
 }
 
-int
-cacheDigestBitUtil(const CacheDigest * cd)
+double
+CacheDigest::usedMaskPercent() const
 {
     CacheDigestStats stats;
-    assert(cd);
-    cacheDigestStats(cd, &amp;stats);
-    return xpercentInt(stats.bit_on_count, stats.bit_count);
+    cacheDigestStats(this, &amp;stats);
+    return xpercent(stats.bit_on_count, stats.bit_count);
 }
 
 void
 cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit)
 {
     assert(stats);
 
     if (real_hit) {
         if (guess_hit)
             ++stats-&gt;trueHits;
         else
             ++stats-&gt;falseMisses;
     } else {
         if (guess_hit)
             ++stats-&gt;falseHits;
         else
             ++stats-&gt;trueMisses;
     }
 }
 
@@ -281,42 +264,43 @@
     storeAppendPrintf(e, &quot;\t entries: count: %d capacity: %d util: %d%%\n&quot;,
                       cd-&gt;count,
                       cd-&gt;capacity,
                       xpercentInt(cd-&gt;count, cd-&gt;capacity)
                      );
     storeAppendPrintf(e, &quot;\t deletion attempts: %d\n&quot;,
                       cd-&gt;del_count
                      );
     storeAppendPrintf(e, &quot;\t bits: per entry: %d on: %d capacity: %d util: %d%%\n&quot;,
                       cd-&gt;bits_per_entry,
                       stats.bit_on_count, stats.bit_count,
                       xpercentInt(stats.bit_on_count, stats.bit_count)
                      );
     storeAppendPrintf(e, &quot;\t bit-seq: count: %d avg.len: %.2f\n&quot;,
                       stats.bseq_count,
                       xdiv(stats.bseq_len_sum, stats.bseq_count)
                      );
 }
 
 size_t
-cacheDigestCalcMaskSize(int cap, int bpe)
+CacheDigest::CalcMaskSize(int cap, int bpe)
 {
+    // XXX: might 32-bit overflow during multiply
     return (size_t) (cap * bpe + 7) / 8;
 }
 
 static void
 cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 {
     const unsigned int bit_count = cd-&gt;mask_size * 8;
     unsigned int tmp_keys[4];
     /* we must memcpy to ensure alignment */
     memcpy(tmp_keys, key, sizeof(tmp_keys));
     hashed_keys[0] = htonl(tmp_keys[0]) % bit_count;
     hashed_keys[1] = htonl(tmp_keys[1]) % bit_count;
     hashed_keys[2] = htonl(tmp_keys[2]) % bit_count;
     hashed_keys[3] = htonl(tmp_keys[3]) % bit_count;
     debugs(70, 9, &quot;cacheDigestHashKey: &quot; &lt;&lt; storeKeyText(key) &lt;&lt; &quot; -(&quot; &lt;&lt;
            bit_count &lt;&lt; &quot;)-&gt; &quot; &lt;&lt; hashed_keys[0] &lt;&lt; &quot; &quot; &lt;&lt; hashed_keys[1] &lt;&lt;
            &quot; &quot; &lt;&lt; hashed_keys[2] &lt;&lt; &quot; &quot; &lt;&lt; hashed_keys[3]);
 }
 
 #endif

=== modified file 'src/CacheDigest.h'
--- src/CacheDigest.h	2015-08-31 06:17:22 +0000
+++ src/CacheDigest.h	2015-11-06 09:12:28 +0000
@@ -1,47 +1,68 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 70    Cache Digest */
 
 #ifndef SQUID_CACHEDIGEST_H_
 #define SQUID_CACHEDIGEST_H_
 
+#include &quot;mem/forward.h&quot;
 #include &quot;store_key_md5.h&quot;
 
 class CacheDigestGuessStats;
 class StoreEntry;
 
-// currently a POD
 class CacheDigest
 {
+    MEMPROXY_CLASS(CacheDigest);
+public:
+    CacheDigest(int capacity, int bpe);
+    ~CacheDigest();
+
+    // NP: only used by broken unit-test
+    /// produce a new identical copy of the digest object
+    CacheDigest *clone() const;
+
+    /// reset the digest mask and counters
+    void clear();
+
+    /// changes mask size to fit newCapacity, resets bits to 0
+    void updateCapacity(int newCapacity);
+
+    void add(const cache_key * key);
+    void remove(const cache_key * key);
+
+    /// \returns true if the key belongs to the digest
+    bool test(const cache_key * key) const;
+
+    /// percentage of mask bits which are used
+    double usedMaskPercent() const;
+
+    /// calculate the size of mask required to digest up to
+    /// a specified capacity and bitsize.
+    static size_t CalcMaskSize(int cap, int bpe);
+
+private:
+    void init(int newCapacity);
+
 public:
     /* public, read-only */
     char *mask;         /* bit mask */
     int mask_size;      /* mask size in bytes */
     int capacity;       /* expected maximum for .count, not a hard limit */
     int bits_per_entry;     /* number of bits allocated for each entry from capacity */
     int count;          /* number of digested entries */
     int del_count;      /* number of deletions performed so far */
 };
 
-CacheDigest *cacheDigestCreate(int capacity, int bpe);
-void cacheDigestDestroy(CacheDigest * cd);
-CacheDigest *cacheDigestClone(const CacheDigest * cd);
-void cacheDigestClear(CacheDigest * cd);
-void cacheDigestChangeCap(CacheDigest * cd, int new_cap);
-int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
-void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
-void cacheDigestDel(CacheDigest * cd, const cache_key * key);
-size_t cacheDigestCalcMaskSize(int cap, int bpe);
-int cacheDigestBitUtil(const CacheDigest * cd);
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
 void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
 
 #endif /* SQUID_CACHEDIGEST_H_ */
 

=== modified file 'src/mem/forward.h'
--- src/mem/forward.h	2015-08-31 08:01:10 +0000
+++ src/mem/forward.h	2015-11-05 11:59:44 +0000
@@ -29,43 +29,40 @@
 void Report(std::ostream &amp;);
 void PoolReport(const MemPoolStats * mp_st, const MemPoolMeter * AllMeter, std::ostream &amp;);
 };
 
 extern const size_t squidSystemPageSize;
 
 /// \deprecated use MEMPROXY_CLASS instead.
 typedef void FREE(void *);
 
 /// Types of memory pool which do not yet use MEMPROXY_CLASS() API
 typedef enum {
     MEM_NONE,
     MEM_2K_BUF,
     MEM_4K_BUF,
     MEM_8K_BUF,
     MEM_16K_BUF,
     MEM_32K_BUF,
     MEM_64K_BUF,
     MEM_ACL_DENY_INFO_LIST,
     MEM_ACL_NAME_LIST,
-#if USE_CACHE_DIGESTS
-    MEM_CACHE_DIGEST,
-#endif
     MEM_CLIENT_INFO,
     MEM_LINK_LIST,
     MEM_DLINK_NODE,
     MEM_DREAD_CTRL,
     MEM_DWRITE_Q,
     MEM_HTTP_HDR_CONTENT_RANGE,
     MEM_MD5_DIGEST,
     MEM_NETDBENTRY,
     MEM_NET_DB_NAME,
     // IMPORTANT: leave this here. pools above are initialized early with memInit()
     MEM_DONTFREE,
     // following pools are initialized late by their component if needed (or never)
     MEM_FQDNCACHE_ENTRY,
     MEM_FWD_SERVER,
     MEM_IDNS_QUERY,
     MEM_IPCACHE_ENTRY,
     MEM_MAX
 } mem_type;
 
 void memClean(void);

=== modified file 'src/mem/old_api.cc'
--- src/mem/old_api.cc	2015-08-31 09:38:51 +0000
+++ src/mem/old_api.cc	2015-11-05 13:27:09 +0000
@@ -1,35 +1,34 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 13    High Level Memory Pool Management */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/AclDenyInfoList.h&quot;
 #include &quot;acl/AclNameList.h&quot;
 #include &quot;base/PackableStream.h&quot;
-#include &quot;CacheDigest.h&quot;
 #include &quot;ClientInfo.h&quot;
 #include &quot;disk.h&quot;
 #include &quot;dlink.h&quot;
 #include &quot;event.h&quot;
 #include &quot;icmp/net_db.h&quot;
 #include &quot;md5.h&quot;
 #include &quot;mem/forward.h&quot;
 #include &quot;mem/Meter.h&quot;
 #include &quot;mem/Pool.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidList.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 
 #include &lt;iomanip&gt;
 
 /* forward declarations */
 static void memFree2K(void *);
@@ -411,45 +410,40 @@
     memset(MemPools, '\0', sizeof(MemPools));
     /**
      * Then initialize all pools.
      * \par
      * Starting with generic 2kB - 64kB buffr pools, then specific object types.
      * \par
      * It does not hurt much to have a lot of pools since sizeof(MemPool) is
      * small; someday we will figure out what to do with all the entries here
      * that are never used or used only once; perhaps we should simply use
      * malloc() for those? @?@
      */
     memDataInit(MEM_2K_BUF, &quot;2K Buffer&quot;, 2048, 10, false);
     memDataInit(MEM_4K_BUF, &quot;4K Buffer&quot;, 4096, 10, false);
     memDataInit(MEM_8K_BUF, &quot;8K Buffer&quot;, 8192, 10, false);
     memDataInit(MEM_16K_BUF, &quot;16K Buffer&quot;, 16384, 10, false);
     memDataInit(MEM_32K_BUF, &quot;32K Buffer&quot;, 32768, 10, false);
     memDataInit(MEM_64K_BUF, &quot;64K Buffer&quot;, 65536, 10, false);
     memDataInit(MEM_ACL_DENY_INFO_LIST, &quot;AclDenyInfoList&quot;,
                 sizeof(AclDenyInfoList), 0);
     memDataInit(MEM_ACL_NAME_LIST, &quot;acl_name_list&quot;, sizeof(AclNameList), 0);
-#if USE_CACHE_DIGESTS
-
-    memDataInit(MEM_CACHE_DIGEST, &quot;CacheDigest&quot;, sizeof(CacheDigest), 0);
-#endif
-
     memDataInit(MEM_LINK_LIST, &quot;link_list&quot;, sizeof(link_list), 10);
     memDataInit(MEM_DLINK_NODE, &quot;dlink_node&quot;, sizeof(dlink_node), 10);
     memDataInit(MEM_DREAD_CTRL, &quot;dread_ctrl&quot;, sizeof(dread_ctrl), 0);
     memDataInit(MEM_DWRITE_Q, &quot;dwrite_q&quot;, sizeof(dwrite_q), 0);
     memDataInit(MEM_HTTP_HDR_CONTENT_RANGE, &quot;HttpHdrContRange&quot;, sizeof(HttpHdrContRange), 0);
     memDataInit(MEM_NETDBENTRY, &quot;netdbEntry&quot;, sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, &quot;net_db_name&quot;, sizeof(net_db_name), 0);
     memDataInit(MEM_CLIENT_INFO, &quot;ClientInfo&quot;, sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, &quot;MD5 digest&quot;, SQUID_MD5_DIGEST_LENGTH, 0);
     MemPools[MEM_MD5_DIGEST]-&gt;setChunkSize(512 * 1024);
 
     /** Lastly init the string pools. */
     for (i = 0; i &lt; mem_str_pool_count; ++i) {
         StrPools[i].pool = memPoolCreate(StrPoolsAttrs[i].name, StrPoolsAttrs[i].obj_size);
         StrPools[i].pool-&gt;zeroBlocks(false);
 
         if (StrPools[i].pool-&gt;objectSize() != StrPoolsAttrs[i].obj_size)
             debugs(13, DBG_IMPORTANT, &quot;Notice: &quot; &lt;&lt; StrPoolsAttrs[i].name &lt;&lt; &quot; is &quot; &lt;&lt; StrPools[i].pool-&gt;objectSize() &lt;&lt; &quot; bytes instead of requested &quot; &lt;&lt; StrPoolsAttrs[i].obj_size &lt;&lt; &quot; bytes&quot;);
     }
 

=== modified file 'src/neighbors.cc'
--- src/neighbors.cc	2015-09-05 11:28:21 +0000
+++ src/neighbors.cc	2015-11-05 17:12:38 +0000
@@ -745,41 +745,41 @@
 
     if (!p-&gt;digest) {
         debugs(15, 5, &quot;peerDigestLookup: gone!&quot;);
         return LOOKUP_NONE;
     } else if (!peerHTTPOkay(p, request)) {
         debugs(15, 5, &quot;peerDigestLookup: !peerHTTPOkay&quot;);
         return LOOKUP_NONE;
     } else if (!p-&gt;digest-&gt;flags.needed) {
         debugs(15, 5, &quot;peerDigestLookup: note need&quot;);
         peerDigestNeeded(p-&gt;digest);
         return LOOKUP_NONE;
     } else if (!p-&gt;digest-&gt;flags.usable) {
         debugs(15, 5, &quot;peerDigestLookup: !ready &amp;&amp; &quot; &lt;&lt; (p-&gt;digest-&gt;flags.requested ? &quot;&quot; : &quot;!&quot;) &lt;&lt; &quot;requested&quot;);
         return LOOKUP_NONE;
     }
 
     debugs(15, 5, &quot;peerDigestLookup: OK to lookup peer &quot; &lt;&lt; p-&gt;host);
     assert(p-&gt;digest-&gt;cd);
     /* does digest predict a hit? */
 
-    if (!cacheDigestTest(p-&gt;digest-&gt;cd, key))
+    if (!p-&gt;digest-&gt;cd-&gt;test(key))
         return LOOKUP_MISS;
 
     debugs(15, 5, &quot;peerDigestLookup: peer &quot; &lt;&lt; p-&gt;host &lt;&lt; &quot; says HIT!&quot;);
 
     return LOOKUP_HIT;
 
 #endif
 
     return LOOKUP_NONE;
 }
 
 /* select best CachePeer based on cache digests */
 CachePeer *
 neighborsDigestSelect(HttpRequest * request)
 {
     CachePeer *best_p = NULL;
 #if USE_CACHE_DIGESTS
 
     int best_rtt = 0;
     int choice_count = 0;

=== modified file 'src/peer_digest.cc'
--- src/peer_digest.cc	2015-10-26 02:53:30 +0000
+++ src/peer_digest.cc	2015-11-06 08:58:47 +0000
@@ -18,41 +18,40 @@
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;internal.h&quot;
 #include &quot;MemObject.h&quot;
 #include &quot;mime_header.h&quot;
 #include &quot;neighbors.h&quot;
 #include &quot;PeerDigest.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;store_key_md5.h&quot;
 #include &quot;StoreClient.h&quot;
 #include &quot;tools.h&quot;
 #include &quot;util.h&quot;
 
 /* local types */
 
 /* local prototypes */
 static time_t peerDigestIncDelay(const PeerDigest * pd);
 static time_t peerDigestNewDelay(const StoreEntry * e);
 static void peerDigestSetCheck(PeerDigest * pd, time_t delay);
-static void peerDigestClean(PeerDigest *);
 static EVH peerDigestCheck;
 static void peerDigestRequest(PeerDigest * pd);
 static STCB peerDigestHandleReply;
 static int peerDigestFetchReply(void *, char *, ssize_t);
 int peerDigestSwapInHeaders(void *, char *, ssize_t);
 int peerDigestSwapInCBlock(void *, char *, ssize_t);
 int peerDigestSwapInMask(void *, char *, ssize_t);
 static int peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const char *step_name);
 static void peerDigestFetchStop(DigestFetchState * fetch, char *buf, const char *reason);
 static void peerDigestFetchAbort(DigestFetchState * fetch, char *buf, const char *reason);
 static void peerDigestReqFinish(DigestFetchState * fetch, char *buf, int, int, int, const char *reason, int err);
 static void peerDigestPDFinish(DigestFetchState * fetch, int pcb_valid, int err);
 static void peerDigestFetchFinish(DigestFetchState * fetch, int err);
 static void peerDigestFetchSetStats(DigestFetchState * fetch);
 static int peerDigestSetCBlock(PeerDigest * pd, const char *buf);
 static int peerDigestUseful(const PeerDigest * pd);
 
 /* local constants */
 Version const CacheDigestVer = { 5, 3 };
 
@@ -69,51 +68,40 @@
 
 /* initialize peer digest */
 static void
 peerDigestInit(PeerDigest * pd, CachePeer * p)
 {
     assert(pd &amp;&amp; p);
 
     memset(pd, 0, sizeof(*pd));
     /*
      * DPW 2007-04-12
      * Lock on to the peer here.  The corresponding cbdataReferenceDone()
      * is in peerDigestDestroy().
      */
     pd-&gt;peer = cbdataReference(p);
     /* if peer disappears, we will know it's name */
     pd-&gt;host = p-&gt;host;
 
     pd-&gt;times.initialized = squid_curtime;
 }
 
-static void
-peerDigestClean(PeerDigest * pd)
-{
-    assert(pd);
-
-    if (pd-&gt;cd)
-        cacheDigestDestroy(pd-&gt;cd);
-
-    pd-&gt;host.clean();
-}
-
 CBDATA_CLASS_INIT(PeerDigest);
 
 CBDATA_CLASS_INIT(DigestFetchState);
 
 DigestFetchState::DigestFetchState(PeerDigest *aPd, HttpRequest *req) :
     pd(cbdataReference(aPd)),
     entry(NULL),
     old_entry(NULL),
     sc(NULL),
     old_sc(NULL),
     request(req),
     offset(0),
     mask_offset(0),
     start_time(squid_curtime),
     resp_time(0),
     expires(0),
     bufofs(0),
     state(DIGEST_READ_REPLY)
 {
     HTTPMSGLOCK(request);
@@ -154,73 +142,72 @@
     return cbdataReference(pd);
 }
 
 /* call Clean and free/unlock everything */
 static void
 peerDigestDestroy(PeerDigest * pd)
 {
     void *p;
     assert(pd);
     void * peerTmp = pd-&gt;peer;
 
     /*
      * DPW 2007-04-12
      * We locked the peer in peerDigestInit(), this is
      * where we unlock it.  If the peer is still valid,
      * tell it that the digest is gone.
      */
     if (cbdataReferenceValidDone(peerTmp, &amp;p))
         peerNoteDigestGone((CachePeer *)p);
 
-    peerDigestClean(pd);
+    delete pd-&gt;cd;
+    pd-&gt;host.clean();
 
     delete pd;
 }
 
 /* called by peer to indicate that somebody actually needs this digest */
 void
 peerDigestNeeded(PeerDigest * pd)
 {
     assert(pd);
     assert(!pd-&gt;flags.needed);
     assert(!pd-&gt;cd);
 
     pd-&gt;flags.needed = true;
     pd-&gt;times.needed = squid_curtime;
     peerDigestSetCheck(pd, 0);  /* check asap */
 }
 
 /* currently we do not have a reason to disable without destroying */
 #if FUTURE_CODE
 /* disables peer for good */
 static void
 peerDigestDisable(PeerDigest * pd)
 {
     debugs(72, 2, &quot;peerDigestDisable: peer &quot; &lt;&lt; pd-&gt;host.buf() &lt;&lt; &quot; disabled for good&quot;);
     pd-&gt;times.disabled = squid_curtime;
     pd-&gt;times.next_check = -1;  /* never */
     pd-&gt;flags.usable = 0;
 
-    if (pd-&gt;cd) {
-        cacheDigestDestroy(pd-&gt;cd);
-        pd-&gt;cd = NULL;
-    }
+    delete pd-&gt;cd
+    pd-&gt;cd = nullptr;
 
     /* we do not destroy the pd itself to preserve its &quot;history&quot; and stats */
 }
 
 #endif
 
 /* increment retry delay [after an unsuccessful attempt] */
 static time_t
 peerDigestIncDelay(const PeerDigest * pd)
 {
     assert(pd);
     return pd-&gt;times.retry_delay &gt; 0 ?
            2 * pd-&gt;times.retry_delay :  /* exponential backoff */
            PeerDigestReqMinGap; /* minimal delay */
 }
 
 /* artificially increases Expires: setting to avoid race conditions
  * returns the delay till that [increased] expiration time */
 static time_t
 peerDigestNewDelay(const StoreEntry * e)
@@ -844,44 +831,42 @@
 }
 
 /* destroys digest if peer disappeared
  * must be called only when fetch and pd cbdata are valid */
 static void
 peerDigestPDFinish(DigestFetchState * fetch, int pcb_valid, int err)
 {
     PeerDigest *pd = fetch-&gt;pd;
     const char *host = pd-&gt;host.termedBuf();
 
     pd-&gt;times.received = squid_curtime;
     pd-&gt;times.req_delay = fetch-&gt;resp_time;
     pd-&gt;stats.sent.kbytes += fetch-&gt;sent.bytes;
     pd-&gt;stats.recv.kbytes += fetch-&gt;recv.bytes;
     pd-&gt;stats.sent.msgs += fetch-&gt;sent.msg;
     pd-&gt;stats.recv.msgs += fetch-&gt;recv.msg;
 
     if (err) {
         debugs(72, DBG_IMPORTANT, &quot;&quot; &lt;&lt; (pcb_valid ? &quot;temporary &quot; : &quot;&quot; ) &lt;&lt; &quot;disabling (&quot; &lt;&lt; pd-&gt;req_result &lt;&lt; &quot;) digest from &quot; &lt;&lt; host);
 
-        if (pd-&gt;cd) {
-            cacheDigestDestroy(pd-&gt;cd);
-            pd-&gt;cd = NULL;
-        }
+        delete pd-&gt;cd;
+        pd-&gt;cd = nullptr;
 
         pd-&gt;flags.usable = false;
 
         if (!pcb_valid)
             peerDigestNotePeerGone(pd);
     } else {
         assert(pcb_valid);
 
         pd-&gt;flags.usable = true;
 
         /* XXX: ugly condition, but how? */
 
         if (fetch-&gt;entry-&gt;store_status == STORE_OK)
             debugs(72, 2, &quot;re-used old digest from &quot; &lt;&lt; host);
         else
             debugs(72, 2, &quot;received valid digest from &quot; &lt;&lt; host);
     }
 
     cbdataReferenceDone(fetch-&gt;pd);
 }
@@ -975,93 +960,92 @@
         return 0;
     }
 
     if (cblock.ver.current &lt; CacheDigestVer.required) {
         debugs(72, DBG_IMPORTANT, &quot;&quot; &lt;&lt; host &lt;&lt; &quot; digest is version &quot; &lt;&lt;
                cblock.ver.current &lt;&lt; &quot;; we require: &quot; &lt;&lt;
                CacheDigestVer.required);
 
         return 0;
     }
 
     /* check consistency */
     if (cblock.ver.required &gt; cblock.ver.current ||
             cblock.mask_size &lt;= 0 || cblock.capacity &lt;= 0 ||
             cblock.bits_per_entry &lt;= 0 || cblock.hash_func_count &lt;= 0) {
         debugs(72, DBG_CRITICAL, &quot;&quot; &lt;&lt; host &lt;&lt; &quot; digest cblock is corrupted.&quot;);
         return 0;
     }
 
     /* check consistency further */
-    if ((size_t)cblock.mask_size != cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry)) {
+    if ((size_t)cblock.mask_size != CacheDigest::CalcMaskSize(cblock.capacity, cblock.bits_per_entry)) {
         debugs(72, DBG_CRITICAL, host &lt;&lt; &quot; digest cblock is corrupted &quot; &lt;&lt;
                &quot;(mask size mismatch: &quot; &lt;&lt; cblock.mask_size &lt;&lt; &quot; ? &quot; &lt;&lt;
-               cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry)
+               CacheDigest::CalcMaskSize(cblock.capacity, cblock.bits_per_entry)
                &lt;&lt; &quot;).&quot;);
         return 0;
     }
 
     /* there are some things we cannot do yet */
     if (cblock.hash_func_count != CacheDigestHashFuncCount) {
         debugs(72, DBG_CRITICAL, &quot;&quot; &lt;&lt; host &lt;&lt; &quot; digest: unsupported #hash functions: &quot; &lt;&lt;
                cblock.hash_func_count &lt;&lt; &quot; ? &quot; &lt;&lt; CacheDigestHashFuncCount &lt;&lt; &quot;.&quot;);
         return 0;
     }
 
     /*
      * no cblock bugs below this point
      */
     /* check size changes */
     if (pd-&gt;cd &amp;&amp; cblock.mask_size != (ssize_t)pd-&gt;cd-&gt;mask_size) {
         debugs(72, 2, host &lt;&lt; &quot; digest changed size: &quot; &lt;&lt; cblock.mask_size &lt;&lt;
                &quot; -&gt; &quot; &lt;&lt; pd-&gt;cd-&gt;mask_size);
         freed_size = pd-&gt;cd-&gt;mask_size;
-        cacheDigestDestroy(pd-&gt;cd);
-        pd-&gt;cd = NULL;
+        delete pd-&gt;cd;
+        pd-&gt;cd = nullptr;
     }
 
     if (!pd-&gt;cd) {
         debugs(72, 2, &quot;creating &quot; &lt;&lt; host &lt;&lt; &quot; digest; size: &quot; &lt;&lt; cblock.mask_size &lt;&lt; &quot; (&quot; &lt;&lt;
                std::showpos &lt;&lt;  (int) (cblock.mask_size - freed_size) &lt;&lt; &quot;) bytes&quot;);
-        pd-&gt;cd = cacheDigestCreate(cblock.capacity, cblock.bits_per_entry);
+        pd-&gt;cd = new CacheDigest(cblock.capacity, cblock.bits_per_entry);
 
         if (cblock.mask_size &gt;= freed_size)
             statCounter.cd.memory += (cblock.mask_size - freed_size);
     }
 
     assert(pd-&gt;cd);
     /* these assignments leave us in an inconsistent state until we finish reading the digest */
     pd-&gt;cd-&gt;count = cblock.count;
     pd-&gt;cd-&gt;del_count = cblock.del_count;
     return 1;
 }
 
 static int
 peerDigestUseful(const PeerDigest * pd)
 {
     /* TODO: we should calculate the prob of a false hit instead of bit util */
-    const int bit_util = cacheDigestBitUtil(pd-&gt;cd);
+    const auto bit_util = pd-&gt;cd-&gt;usedMaskPercent();
 
-    if (bit_util &gt; 65) {
+    if (bit_util &gt; 65.0) {
         debugs(72, DBG_CRITICAL, &quot;Warning: &quot; &lt;&lt; pd-&gt;host &lt;&lt;
-               &quot; peer digest has too many bits on (&quot; &lt;&lt; bit_util &lt;&lt; &quot;%%).&quot;);
-
+               &quot; peer digest has too many bits on (&quot; &lt;&lt; bit_util &lt;&lt; &quot;%).&quot;);
         return 0;
     }
 
     return 1;
 }
 
 static int
 saneDiff(time_t diff)
 {
     return abs((int) diff) &gt; squid_curtime / 2 ? 0 : diff;
 }
 
 void
 peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e)
 {
 #define f2s(flag) (pd-&gt;flags.flag ? &quot;yes&quot; : &quot;no&quot;)
 #define appendTime(tm) storeAppendPrintf(e, &quot;%s\t %10ld\t %+d\t %+d\n&quot;, \
     &quot;&quot;#tm, (long int)pd-&gt;times.tm, \
     saneDiff(pd-&gt;times.tm - squid_curtime), \
     saneDiff(pd-&gt;times.tm - pd-&gt;times.initialized))

=== modified file 'src/store.cc'
--- src/store.cc	2015-09-21 14:02:38 +0000
+++ src/store.cc	2015-11-05 13:12:15 +0000
@@ -1504,46 +1504,42 @@
  */
 void
 StoreEntry::negativeCache()
 {
     // XXX: should make the default for expires 0 instead of -1
     //      so we can distinguish &quot;Expires: -1&quot; from nothing.
     if (expires &lt;= 0)
 #if USE_HTTP_VIOLATIONS
         expires = squid_curtime + Config.negativeTtl;
 #else
         expires = squid_curtime;
 #endif
     EBIT_SET(flags, ENTRY_NEGCACHED);
 }
 
 void
 storeFreeMemory(void)
 {
     Store::Root(NULL);
 #if USE_CACHE_DIGESTS
-
-    if (store_digest)
-        cacheDigestDestroy(store_digest);
-
+    delete store_digest;
 #endif
-
     store_digest = NULL;
 }
 
 int
 expiresMoreThan(time_t expires, time_t when)
 {
     if (expires &lt; 0)            /* No Expires given */
         return 1;
 
     return (expires &gt; (squid_curtime + when));
 }
 
 int
 StoreEntry::validToSend() const
 {
     if (EBIT_TEST(flags, RELEASE_REQUEST))
         return 0;
 
     if (EBIT_TEST(flags, ENTRY_NEGCACHED))
         if (expires &lt;= squid_curtime)

=== modified file 'src/store_digest.cc'
--- src/store_digest.cc	2015-07-07 16:35:58 +0000
+++ src/store_digest.cc	2015-11-05 18:19:08 +0000
@@ -90,86 +90,86 @@
 }
 
 /*
  * PUBLIC FUNCTIONS
  */
 
 void
 storeDigestInit(void)
 {
     storeDigestRegisterWithCacheManager();
 
 #if USE_CACHE_DIGESTS
     const int cap = storeDigestCalcCap();
 
     if (!Config.onoff.digest_generation) {
         store_digest = NULL;
         debugs(71, 3, &quot;Local cache digest generation disabled&quot;);
         return;
     }
 
-    store_digest = cacheDigestCreate(cap, Config.digest.bits_per_entry);
+    store_digest = new CacheDigest(cap, Config.digest.bits_per_entry);
     debugs(71, DBG_IMPORTANT, &quot;Local cache digest enabled; rebuild/rewrite every &quot; &lt;&lt;
            (int) Config.digest.rebuild_period &lt;&lt; &quot;/&quot; &lt;&lt;
            (int) Config.digest.rewrite_period &lt;&lt; &quot; sec&quot;);
 
     memset(&amp;sd_state, 0, sizeof(sd_state));
 #else
     store_digest = NULL;
     debugs(71, 3, &quot;Local cache digest is 'off'&quot;);
 #endif
 }
 
 /* called when store_rebuild completes */
 void
 storeDigestNoteStoreReady(void)
 {
 #if USE_CACHE_DIGESTS
 
     if (Config.onoff.digest_generation) {
         storeDigestRebuildStart(NULL);
         storeDigestRewriteStart(NULL);
     }
 
 #endif
 }
 
 //TODO: this seems to be dead code. Is it needed?
 void
 storeDigestDel(const StoreEntry * entry)
 {
 #if USE_CACHE_DIGESTS
 
     if (!Config.onoff.digest_generation) {
         return;
     }
 
     assert(entry &amp;&amp; store_digest);
     debugs(71, 6, &quot;storeDigestDel: checking entry, key: &quot; &lt;&lt; entry-&gt;getMD5Text());
 
     if (!EBIT_TEST(entry-&gt;flags, KEY_PRIVATE)) {
-        if (!cacheDigestTest(store_digest,  (const cache_key *)entry-&gt;key)) {
+        if (!store_digest-&gt;test(static_cast&lt;const cache_key *&gt;(entry-&gt;key))) {
             ++sd_stats.del_lost_count;
             debugs(71, 6, &quot;storeDigestDel: lost entry, key: &quot; &lt;&lt; entry-&gt;getMD5Text() &lt;&lt; &quot; url: &quot; &lt;&lt; entry-&gt;url()  );
         } else {
             ++sd_stats.del_count;
-            cacheDigestDel(store_digest,  (const cache_key *)entry-&gt;key);
+            store_digest-&gt;remove(static_cast&lt;const cache_key *&gt;(entry-&gt;key));
             debugs(71, 6, &quot;storeDigestDel: deled entry, key: &quot; &lt;&lt; entry-&gt;getMD5Text());
         }
     }
 #endif //USE_CACHE_DIGESTS
 }
 
 void
 storeDigestReport(StoreEntry * e)
 {
 #if USE_CACHE_DIGESTS
 
     if (!Config.onoff.digest_generation) {
         return;
     }
 
     if (store_digest) {
         cacheDigestReport(store_digest, &quot;store&quot;, e);
         storeAppendPrintf(e, &quot;\t added: %d rejected: %d ( %.2f %%) del-ed: %d\n&quot;,
                           sd_stats.add_count,
                           sd_stats.rej_count,
@@ -237,88 +237,88 @@
     /*
      * idea: how about also skipping very fresh (thus, potentially
      * unstable) entries? Should be configurable through
      * cd_refresh_pattern, of course.
      */
     /*
      * idea: skip objects that are going to be purged before the next
      * update.
      */
     return 1;
 }
 
 static void
 storeDigestAdd(const StoreEntry * entry)
 {
     assert(entry &amp;&amp; store_digest);
 
     if (storeDigestAddable(entry)) {
         ++sd_stats.add_count;
 
-        if (cacheDigestTest(store_digest, (const cache_key *)entry-&gt;key))
+        if (store_digest-&gt;test(static_cast&lt;const cache_key *&gt;(entry-&gt;key)))
             ++sd_stats.add_coll_count;
 
-        cacheDigestAdd(store_digest,  (const cache_key *)entry-&gt;key);
+        store_digest-&gt;add(static_cast&lt;const cache_key *&gt;(entry-&gt;key));
 
         debugs(71, 6, &quot;storeDigestAdd: added entry, key: &quot; &lt;&lt; entry-&gt;getMD5Text());
     } else {
         ++sd_stats.rej_count;
 
-        if (cacheDigestTest(store_digest,  (const cache_key *)entry-&gt;key))
+        if (store_digest-&gt;test(static_cast&lt;const cache_key *&gt;(entry-&gt;key)))
             ++sd_stats.rej_coll_count;
     }
 }
 
 /* rebuilds digest from scratch */
 static void
 storeDigestRebuildStart(void *datanotused)
 {
     assert(store_digest);
     /* prevent overlapping if rebuild schedule is too tight */
 
     if (sd_state.rebuild_lock) {
         debugs(71, DBG_IMPORTANT, &quot;storeDigestRebuildStart: overlap detected, consider increasing rebuild period&quot;);
         return;
     }
 
     sd_state.rebuild_lock = 1;
     debugs(71, 2, &quot;storeDigestRebuildStart: rebuild #&quot; &lt;&lt; sd_state.rebuild_count + 1);
 
     if (sd_state.rewrite_lock) {
         debugs(71, 2, &quot;storeDigestRebuildStart: waiting for Rewrite to finish.&quot;);
         return;
     }
 
     storeDigestRebuildResume();
 }
 
 /* called be Rewrite to push Rebuild forward */
 static void
 storeDigestRebuildResume(void)
 {
     assert(sd_state.rebuild_lock);
     assert(!sd_state.rewrite_lock);
     sd_state.theSearch = Store::Root().search(NULL, NULL);
     /* resize or clear */
 
     if (!storeDigestResize())
-        cacheDigestClear(store_digest);     /* not clean()! */
+        store_digest-&gt;clear();     /* not clean()! */
 
     memset(&amp;sd_stats, 0, sizeof(sd_stats));
 
     eventAdd(&quot;storeDigestRebuildStep&quot;, storeDigestRebuildStep, NULL, 0.0, 1);
 }
 
 /* finishes swap out sequence for the digest; schedules next rebuild */
 static void
 storeDigestRebuildFinish(void)
 {
     assert(sd_state.rebuild_lock);
     sd_state.rebuild_lock = 0;
     ++sd_state.rebuild_count;
     debugs(71, 2, &quot;storeDigestRebuildFinish: done.&quot;);
     eventAdd(&quot;storeDigestRebuildStart&quot;, storeDigestRebuildStart, NULL, (double)
              Config.digest.rebuild_period, 1);
     /* resume pending Rewrite if any */
 
     if (sd_state.rewrite_lock)
         storeDigestRewriteResume();
@@ -501,27 +501,27 @@
 }
 
 /* returns true if we actually resized the digest */
 static int
 storeDigestResize(void)
 {
     const int cap = storeDigestCalcCap();
     int diff;
     assert(store_digest);
     diff = abs(cap - store_digest-&gt;capacity);
     debugs(71, 2, &quot;storeDigestResize: &quot; &lt;&lt;
            store_digest-&gt;capacity &lt;&lt; &quot; -&gt; &quot; &lt;&lt; cap &lt;&lt; &quot;; change: &quot; &lt;&lt;
            diff &lt;&lt; &quot; (&quot; &lt;&lt; xpercentInt(diff, store_digest-&gt;capacity) &lt;&lt; &quot;%)&quot; );
     /* avoid minor adjustments */
 
     if (diff &lt;= store_digest-&gt;capacity / 10) {
         debugs(71, 2, &quot;storeDigestResize: small change, will not resize.&quot;);
         return 0;
     } else {
         debugs(71, 2, &quot;storeDigestResize: big change, resizing.&quot;);
-        cacheDigestChangeCap(store_digest, cap);
+        store_digest-&gt;updateCapacity(cap);
         return 1;
     }
 }
 
 #endif /* USE_CACHE_DIGESTS */
 

=== modified file 'src/test_cache_digest.cc'
--- src/test_cache_digest.cc	2015-01-13 07:25:36 +0000
+++ src/test_cache_digest.cc	2015-11-05 18:19:40 +0000
@@ -216,102 +216,98 @@
 }
 
 static void
 cacheDestroy(Cache * cache)
 {
     CacheEntry *e = NULL;
     hash_table *hash;
     assert(cache);
     hash = cache-&gt;hash;
     /* destroy hash table contents */
     hash_first(hash);
 
     while ((e = (CacheEntry *)hash_next(hash))) {
         hash_remove_link(hash, (hash_link *) e);
         cacheEntryDestroy(e);
     }
 
     /* destroy the hash table itself */
     hashFreeMemory(hash);
 
-    if (cache-&gt;digest)
-        cacheDigestDestroy(cache-&gt;digest);
-
+    delete cache-&gt;digest;
     xfree(cache);
 }
 
 /* re-digests currently hashed entries */
 static void
 cacheResetDigest(Cache * cache)
 {
     CacheEntry *e = NULL;
     hash_table *hash;
 
     struct timeval t_start, t_end;
 
     assert(cache);
     fprintf(stderr, &quot;%s: init-ing digest with %d entries\n&quot;, cache-&gt;name, cache-&gt;count);
 
-    if (cache-&gt;digest)
-        cacheDigestDestroy(cache-&gt;digest);
-
     hash = cache-&gt;hash;
 
-    cache-&gt;digest = cacheDigestCreate(cache-&gt;count + 1, 6);
+    delete cache-&gt;digest;
+    cache-&gt;digest = new CacheDigest(cache-&gt;count + 1, 6);
 
     if (!cache-&gt;count)
         return;
 
     gettimeofday(&amp;t_start, NULL);
 
     hash_first(hash);
 
     while ((e = (CacheEntry *)hash_next(hash))) {
-        cacheDigestAdd(cache-&gt;digest, e-&gt;key);
+        cache-&gt;digest-&gt;add(e-&gt;key);
     }
 
     gettimeofday(&amp;t_end, NULL);
     assert(cache-&gt;digest-&gt;count == cache-&gt;count);
     fprintf(stderr, &quot;%s: init-ed  digest with %d entries\n&quot;,
             cache-&gt;name, cache-&gt;digest-&gt;count);
     fprintf(stderr, &quot;%s: init took: %f sec, %f sec/M\n&quot;,
             cache-&gt;name,
             tvSubDsec(t_start, t_end),
             (double) 1e6 * tvSubDsec(t_start, t_end) / cache-&gt;count);
     /* check how long it takes to traverse the hash */
     gettimeofday(&amp;t_start, NULL);
     hash_first(hash);
 
     for (e = (CacheEntry *)hash_next(hash); e; e = (CacheEntry *)hash_next(hash)) {}
 
     gettimeofday(&amp;t_end, NULL);
     fprintf(stderr, &quot;%s: hash scan took: %f sec, %f sec/M\n&quot;,
             cache-&gt;name,
             tvSubDsec(t_start, t_end),
             (double) 1e6 * tvSubDsec(t_start, t_end) / cache-&gt;count);
 }
 
 static void
 cacheQueryPeer(Cache * cache, const cache_key * key)
 {
     const int peer_has_it = hash_lookup(cache-&gt;peer-&gt;hash, key) != NULL;
-    const int we_think_we_have_it = cacheDigestTest(cache-&gt;digest, key);
+    const int we_think_we_have_it = cache-&gt;digest-&gt;test(key);
 
     ++ cache-&gt;qstats.query_count;
 
     if (peer_has_it) {
         if (we_think_we_have_it)
             ++ cache-&gt;qstats.true_hit_count;
         else
             ++ cache-&gt;qstats.false_miss_count;
     } else {
         if (we_think_we_have_it)
             ++ cache-&gt;qstats.false_hit_count;
         else
             ++ cache-&gt;qstats.true_miss_count;
     }
 }
 
 static void
 cacheQueryReport(Cache * cache, CacheQueryStats * stats)
 {
     fprintf(stdout, &quot;%s: peer queries: %d (%d%%)\n&quot;,
@@ -457,62 +453,62 @@
      */
     memcpy(entry-&gt;key, storeKeyPublic(url, method_id), sizeof(entry-&gt;key));
 
     /*fprintf(stdout, &quot;%s:%d: %s %s %s %s\n&quot;,
      * fname, count, method, storeKeyText(entry-&gt;key), url, hier); */
     return frOk;
 }
 
 static void
 cachePurge(Cache * cache, storeSwapLogData * s, int update_digest)
 {
     CacheEntry *olde = (CacheEntry *) hash_lookup(cache-&gt;hash, s-&gt;key);
 
     if (!olde) {
         ++ cache-&gt;bad_del_count;
     } else {
         assert(cache-&gt;count);
         hash_remove_link(cache-&gt;hash, (hash_link *) olde);
 
         if (update_digest)
-            cacheDigestDel(cache-&gt;digest, s-&gt;key);
+            cache-&gt;digest-&gt;remove(s-&gt;key);
 
         cacheEntryDestroy(olde);
 
         -- cache-&gt;count;
     }
 }
 
 static void
 cacheStore(Cache * cache, storeSwapLogData * s, int update_digest)
 {
     CacheEntry *olde = (CacheEntry *) hash_lookup(cache-&gt;hash, s-&gt;key);
 
     if (olde) {
         ++ cache-&gt;bad_add_count;
     } else {
         CacheEntry *e = cacheEntryCreate(s);
         hash_join(cache-&gt;hash, (hash_link *)&amp;e-&gt;key);
         ++ cache-&gt;count;
 
         if (update_digest)
-            cacheDigestAdd(cache-&gt;digest, e-&gt;key);
+            cache-&gt;digest-&gt;add(e-&gt;key);
     }
 }
 
 static void
 cacheUpdateStore(Cache * cache, storeSwapLogData * s, int update_digest)
 {
     switch (s-&gt;op) {
 
     case SWAP_LOG_ADD:
         cacheStore(cache, s, update_digest);
         break;
 
     case SWAP_LOG_DEL:
         cachePurge(cache, s, update_digest);
         break;
 
     default:
         assert(0);
     }
 }
@@ -568,41 +564,41 @@
         while (fi-&gt;inner_time &gt; 0) {
             if (((storeSwapLogData *) fi-&gt;entry)-&gt;op == SWAP_LOG_DEL) {
                 cachePurge(them, (storeSwapLogData *)fi-&gt;entry, 0);
 
                 if (ready_time &lt; 0)
                     ready_time = fi-&gt;inner_time;
             } else {
                 if (ready_time &gt; 0 &amp;&amp; fi-&gt;inner_time &gt; ready_time)
                     break;
 
                 cacheStore(them, (storeSwapLogData *)fi-&gt;entry, 0);
             }
 
             fileIteratorAdvance(fi);
         }
     }
 
     /* digest peer cache content */
     cacheResetDigest(them);
 
-    us-&gt;digest = cacheDigestClone(them-&gt;digest);    /* @netw@ */
+    us-&gt;digest = them-&gt;digest-&gt;clone();
 
     /* shift the time in access log to match ready_time */
     fileIteratorSetCurTime(fis[0], ready_time);
 
     /* iterate, use the iterator with the smallest positive inner_time */
     cur_time = -1;
 
     do {
         int next_i = -1;
         time_t next_time = -1;
         active_fi_count = 0;
 
         for (i = 0; i &lt; fi_count; ++i) {
             if (fis[i]-&gt;inner_time &gt;= 0) {
                 if (!active_fi_count || fis[i]-&gt;inner_time &lt; next_time) {
                     next_i = i;
                     next_time = fis[i]-&gt;inner_time;
                 }
 
                 ++active_fi_count;

=== modified file 'src/tests/stub_CacheDigest.cc'
--- src/tests/stub_CacheDigest.cc	2015-08-31 06:17:22 +0000
+++ src/tests/stub_CacheDigest.cc	2015-11-06 08:58:47 +0000
@@ -1,32 +1,33 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;store_key_md5.h&quot;
 
 #define STUB_API &quot;CacheDigest.cc&quot;
 #include &quot;tests/STUB.h&quot;
 
 class CacheDigest;
 class CacheDigestGuessStats;
 class StoreEntry;
 
-CacheDigest * cacheDigestCreate(int, int) STUB_RETVAL(NULL)
-void cacheDigestDestroy(CacheDigest *) STUB
-CacheDigest * cacheDigestClone(const CacheDigest *) STUB_RETVAL(NULL)
-void cacheDigestClear(CacheDigest * ) STUB
-void cacheDigestChangeCap(CacheDigest *,int) STUB
-int cacheDigestTest(const CacheDigest *, const cache_key *) STUB_RETVAL(1)
-void cacheDigestAdd(CacheDigest *, const cache_key *) STUB
-void cacheDigestDel(CacheDigest *, const cache_key *) STUB
-int cacheDigestBitUtil(const CacheDigest *) STUB_RETVAL(0)
+#include &quot;CacheDigest.h&quot;
+CacheDigest::CacheDigest(int, int) {STUB}
+CacheDigest::~CacheDigest() {STUB}
+CacheDigest *CacheDigest::clone() const STUB_RETVAL(nullptr)
+void CacheDigest::clear() STUB
+void CacheDigest::updateCapacity(int) STUB
+bool CacheDigest::test(const cache_key *) const STUB_RETVAL(false)
+void CacheDigest::add(const cache_key *) STUB
+void CacheDigest::remove(const cache_key *) STUB
+double CacheDigest::usedMaskPercent() const STUB_RETVAL(0.0)
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats *, int, int) STUB
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats *, StoreEntry *, const char *) STUB
 void cacheDigestReport(CacheDigest *, const char *, StoreEntry *) STUB
-size_t cacheDigestCalcMaskSize(int, int) STUB_RETVAL(1)
+size_t CacheDigest::CalcMaskSize(int, int) STUB_RETVAL(1)
 

</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003700.html">[squid-dev] [PATCH] Handshake Problem during Renegotiation
</A></li>
	<LI>Next message: <A HREF="003691.html">[squid-dev] [PATCH] convert CacheDigest to C++ and MEMPROXY
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3682">[ date ]</a>
              <a href="thread.html#3682">[ thread ]</a>
              <a href="subject.html#3682">[ subject ]</a>
              <a href="author.html#3682">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
