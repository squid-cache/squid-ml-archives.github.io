<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] refactor ConnStateData pipeline handling
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20refactor%20ConnStateData%20pipeline%20handling&In-Reply-To=%3C564B07C8.5070701%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003759.html">
   <LINK REL="Next"  HREF="003916.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] refactor ConnStateData pipeline handling</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20refactor%20ConnStateData%20pipeline%20handling&In-Reply-To=%3C564B07C8.5070701%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] refactor ConnStateData pipeline handling">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Nov 17 10:56:08 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003759.html">[squid-dev] Jenkins build is back to normal : trunk-full-matrix Â» gcc,d-debian-unstable #46
</A></li>
        <LI>Next message: <A HREF="003916.html">[squid-dev] [PATCH] refactor ConnStateData pipeline handling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3764">[ date ]</a>
              <a href="thread.html#3764">[ thread ]</a>
              <a href="subject.html#3764">[ subject ]</a>
              <a href="author.html#3764">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Updated patch attached. AFAICS this contains all the previously
requested changes.

To recap:

This refactors the request pipeline management API to use std::list
instead of a custom linked-list with accessors spread over both
ConnStateData and ClientSocketContext.

To do this a new class Pipeline is created with methods wrapping
std::list API and extending it slightly to meet the HTTP/1.1 pipeline
behaviours and perform basic stats gathering. The pipeline management
methods and state variables are moved inside this class.

ClientSocketContext was performing several layering violations in
relation to ConnStateData when one transaction ended and the next needed
starting. Treating the pipeline properly as a std::list forced removal
of that violation.

* actions for starting or resuming a transaction on the connection are
now moved to ConnStateData::kick(). Which gets called after each
transaction completes.
 - with some further cleanup it can be called at any point the
ConnStateData needs to resume processing. However, that is left out of
scope for this patch.

* the ClientSocketContext scope now ends when the finished() method is
used to mark completion of these contexts transactions. Which will mark
itself done and de-register from the Pipeline queue. The ConnStateData
kick() method still needs to be called to resume other transactions
processing.

* the queue is now holding RefCounted Pointers. So that the
ClientSocketContext destructor no longer needs to be careful of
registrations, and the queue entries are guaranteed to still exist while
queued.

* The old freeAllContexts() and notifyAllContexts(int) members of
ConnStateData have been combined into Pipeline::terminateAll(int).



The ClientSocketContext and ConnStateData documentation is updated to
describe what they do in regards to connection and transaction processing.


Initial testing revealed CONNECT tunnels always being logged as ABORTED.
This turns out to be techincally correct, since the only way a tunnel
can finish is for client or server to just close the connection.
However, it is not right to log these as abnormal aborts. Instead, I
have now made the context be finished() just prior to the
TunnelStateData being destroyed. That way normal closure should show up
only as TUNNEL, but timeouts and I/O errors should still be recorded as
abnormal.

Potential BUGS:

* The on_unsupported_protocol handling function appears to be a bit
broken. It pop()'s contexts off the pipeline directly without going
through the proper finished() process to release their state data. I
have highlighted that with an XXX and comment.

* The ssl-bump handling logic begins with a terminateAll(0) begin run on
all active contexts. It does not check whether there is any existing
pipeline of requests waiting to be processed. And the action prematurely
purges the CONNECT message context, even though it may be a) still
useful for splice to resume as a blind tunnel, and b) is actually still
being processed (albeit as bumping).


Neither of those are new breakage though, so markgin wit XXX and leaving
for a followup when the SSL handling logis get cleaned up.


Amos

-------------- next part --------------
=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-11-08 15:09:16 +0000
+++ src/Makefile.am	2015-11-15 09:12:02 +0000
@@ -394,40 +394,42 @@
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	Parsing.h \
 	$(XPROF_STATS_SOURCE) \
 	pconn.cc \
 	pconn.h \
 	PeerDigest.h \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	PeerSelectState.h \
 	PingData.h \
+	Pipeline.cc \
+	Pipeline.h \
 	protos.h \
 	redirect.h \
 	redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	RemovalPolicy.h \
 	send-announce.h \
 	send-announce.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	SBufDetailedStats.cc \
 	SBufStatsAction.h \
 	SBufStatsAction.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
 	SquidNew.cc \
@@ -1362,40 +1364,42 @@
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
+	Pipeline.cc \
+	Pipeline.h \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
 	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
 	StrList.h \
@@ -1801,40 +1805,42 @@
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	Pipeline.cc \
+	Pipeline.h \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	StrList.h \
 	StrList.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
 	StatCounters.cc \
@@ -2046,40 +2052,42 @@
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	Pipeline.cc \
+	Pipeline.h \
 	RemovalPolicy.cc \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
 	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
 	StatHist.cc \
@@ -2286,40 +2294,42 @@
 	mem_node.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
 	Parsing.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	Pipeline.cc \
+	Pipeline.h \
 	pconn.cc \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
 	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -2614,40 +2624,42 @@
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
+	Pipeline.cc \
+	Pipeline.h \
 	redirect.h \
 	tests/stub_libauth_acls.cc \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
 	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -3475,40 +3487,42 @@
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	Pipeline.cc \
+	Pipeline.h \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
 	SBufAlgos.h \
 	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
 	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
 	tests/stub_StatHist.cc \

=== added file 'src/Pipeline.cc'
--- src/Pipeline.cc	1970-01-01 00:00:00 +0000
+++ src/Pipeline.cc	2015-11-17 06:06:41 +0000
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/*
+ * DEBUG: section 33    Client Request Pipeline
+ */
+#include &quot;squid.h&quot;
+#include &quot;client_side.h&quot;
+#include &quot;Debug.h&quot;
+#include &quot;Pipeline.h&quot;
+
+void
+Pipeline::add(const ClientSocketContextPointer &amp;c)
+{
+    requests.push_back(c);
+    ++nrequests;
+    debugs(33, 3, &quot;Pipeline &quot; &lt;&lt; (void*)this &lt;&lt; &quot; add request &quot; &lt;&lt; nrequests &lt;&lt; ' ' &lt;&lt; c);
+}
+
+ClientSocketContextPointer
+Pipeline::front() const
+{
+    if (requests.empty()) {
+        debugs(33, 3, &quot;Pipeline &quot; &lt;&lt; (void*)this &lt;&lt; &quot; empty&quot;);
+        return ClientSocketContextPointer();
+    }
+
+    debugs(33, 3, &quot;Pipeline &quot; &lt;&lt; (void*)this &lt;&lt; &quot; front &quot; &lt;&lt; requests.front());
+    return requests.front();
+}
+
+void
+Pipeline::terminateAll(int xerrno)
+{
+    while (!requests.empty()) {
+        ClientSocketContextPointer context = requests.front();
+        debugs(33, 3, &quot;Pipeline &quot; &lt;&lt; (void*)this &lt;&lt; &quot; notify(&quot; &lt;&lt; xerrno &lt;&lt; &quot;) &quot; &lt;&lt; context);
+        context-&gt;noteIoError(xerrno);
+        context-&gt;finished();  // cleanup and self-deregister
+        assert(context != requests.front());
+    }
+}
+
+void
+Pipeline::popMe(const ClientSocketContextPointer &amp;which)
+{
+    if (requests.empty())
+        return;
+
+    debugs(33, 3, &quot;Pipeline &quot; &lt;&lt; (void*)this &lt;&lt; &quot; drop &quot; &lt;&lt; requests.front());
+    // in reality there may be multiple contexts doing processing in parallel.
+    // XXX: pipeline still assumes HTTP/1 FIFO semantics are obeyed.
+    assert(which == requests.front());
+    requests.pop_front();
+}
+

=== added file 'src/Pipeline.h'
--- src/Pipeline.h	1970-01-01 00:00:00 +0000
+++ src/Pipeline.h	2015-11-17 06:58:01 +0000
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_PIPELINE_H
+#define SQUID_SRC_PIPELINE_H
+
+#include &quot;base/RefCount.h&quot;
+
+#include &lt;list&gt;
+
+class ClientSocketContext;
+typedef RefCount&lt;ClientSocketContext&gt; ClientSocketContextPointer;
+
+/**
+ * A queue of transactions awaiting completion.
+ *
+ * Transactions in the queue may be fully processed, but not yet delivered,
+ * or only partially processed.
+ *
+ * - HTTP/1 pipelined requests can be processed out of order but
+ *   responses MUST be written to the client in-order.
+ *   The front() context is for the response writing transaction.
+ *   The back context may still be reading a request payload/body.
+ *   Other contexts are in deferred I/O state, but may be accumulating
+ *   payload/body data to be written later.
+ *
+ * - HTTP/2 multiplexed streams can be processed and delivered in any order.
+ *
+ * For consistency we treat the pipeline as a FIFO queue in both cases.
+ */
+class Pipeline
+{
+    Pipeline(const Pipeline &amp;) = delete;
+    Pipeline &amp; operator =(const Pipeline &amp;) = delete;
+
+public:
+    Pipeline() : nrequests(0) {}
+    ~Pipeline() = default;
+
+    /// register a new request context to the pipeline
+    void add(const ClientSocketContextPointer &amp;);
+
+    /// get the first request context in the pipeline
+    ClientSocketContextPointer front() const;
+
+    /// how many requests are currently pipelined
+    size_t count() const {return requests.size();}
+
+    /// whether there are none or any requests currently pipelined
+    bool empty() const {return requests.empty();}
+
+    /// tell everybody about the err, and abort all waiting requests
+    void terminateAll(const int xerrno);
+
+    /// deregister the front request from the pipeline
+    void popMe(const ClientSocketContextPointer &amp;);
+
+    /// Number of requests seen in this pipeline (so far).
+    /// Includes incomplete transactions.
+    uint32_t nrequests;
+
+private:
+    /// requests parsed from the connection but not yet completed.
+    std::list&lt;ClientSocketContextPointer&gt; requests;
+};
+
+#endif /* SQUID_SRC_PIPELINE_H */
+

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-11-09 18:12:10 +0000
+++ src/client_side.cc	2015-11-17 08:13:04 +0000
@@ -35,41 +35,41 @@
  * Tell client_side_reply that we *want* an error page before any
  * stream calls occur. Then we simply read as normal.
  *
  *
  \section pconn_logic Persistent connection logic:
  *
  \par
  * requests (httpClientRequest structs) get added to the connection
  * list, with the current one being chr
  *
  \par
  * The request is *immediately* kicked off, and data flows through
  * to clientSocketRecipient.
  *
  \par
  * If the data that arrives at clientSocketRecipient is not for the current
  * request, clientSocketRecipient simply returns, without requesting more
  * data, or sending it.
  *
  \par
- * ClientKeepAliveNextRequest will then detect the presence of data in
+ * ConnStateData::kick() will then detect the presence of data in
  * the next ClientHttpRequest, and will send it, restablishing the
  * data flow.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;base/Subscription.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;CachePeer.h&quot;
 #include &quot;client_db.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;client_side_reply.h&quot;
 #include &quot;client_side_request.h&quot;
 #include &quot;ClientRequestContext.h&quot;
 #include &quot;clientStream.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;comm/Loops.h&quot;
 #include &quot;comm/Read.h&quot;
@@ -203,117 +203,87 @@
 ClientSocketContext::getTail() const
 {
     if (http-&gt;client_stream.tail)
         return (clientStreamNode *)http-&gt;client_stream.tail-&gt;data;
 
     return NULL;
 }
 
 clientStreamNode *
 ClientSocketContext::getClientReplyContext() const
 {
     return (clientStreamNode *)http-&gt;client_stream.tail-&gt;prev-&gt;data;
 }
 
 ConnStateData *
 ClientSocketContext::getConn() const
 {
     return http-&gt;getConn();
 }
 
-void
-ClientSocketContext::removeFromConnectionList(ConnStateData * conn)
-{
-    ClientSocketContext::Pointer *tempContextPointer;
-    assert(conn != NULL &amp;&amp; cbdataReferenceValid(conn));
-    assert(conn-&gt;getCurrentContext() != NULL);
-    /* Unlink us from the connection request list */
-    tempContextPointer = &amp; conn-&gt;currentobject;
-
-    while (tempContextPointer-&gt;getRaw()) {
-        if (*tempContextPointer == this)
-            break;
-
-        tempContextPointer = &amp;(*tempContextPointer)-&gt;next;
-    }
-
-    assert(tempContextPointer-&gt;getRaw() != NULL);
-    *tempContextPointer = next;
-    next = NULL;
-}
-
 ClientSocketContext::~ClientSocketContext()
 {
     clientStreamNode *node = getTail();
 
     if (node) {
         ClientSocketContext *streamContext = dynamic_cast&lt;ClientSocketContext *&gt; (node-&gt;data.getRaw());
 
         if (streamContext) {
             /* We are *always* the tail - prevent recursive free */
             assert(this == streamContext);
             node-&gt;data = NULL;
         }
     }
 
-    if (connRegistered_)
-        deRegisterWithConn();
-
     httpRequestFree(http);
-
-    /* clean up connection links to us */
-    assert(this != next.getRaw());
 }
 
 void
 ClientSocketContext::registerWithConn()
 {
     assert (!connRegistered_);
     assert (http);
     assert (http-&gt;getConn() != NULL);
     connRegistered_ = true;
-    http-&gt;getConn()-&gt;addContextToQueue(this);
-}
-
-void
-ClientSocketContext::deRegisterWithConn()
-{
-    assert (connRegistered_);
-    removeFromConnectionList(http-&gt;getConn());
-    connRegistered_ = false;
+    http-&gt;getConn()-&gt;pipeline.add(ClientSocketContext::Pointer(this));
 }
 
 void
-ClientSocketContext::connIsFinished()
+ClientSocketContext::finished()
 {
     assert (http);
     assert (http-&gt;getConn() != NULL);
-    deRegisterWithConn();
+    ConnStateData *conn = http-&gt;getConn();
+
     /* we can't handle any more stream data - detach */
     clientStreamDetach(getTail(), http);
+
+    assert(connRegistered_);
+    connRegistered_ = false;
+    assert(conn-&gt;pipeline.front() == this); // XXX: still assumes HTTP/1 semantics
+    conn-&gt;pipeline.popMe(ClientSocketContext::Pointer(this));
 }
 
 ClientSocketContext::ClientSocketContext(const Comm::ConnectionPointer &amp;aConn, ClientHttpRequest *aReq) :
     clientConnection(aConn),
     http(aReq),
     reply(NULL),
-    next(NULL),
     writtenToSocket(0),
     mayUseConnection_ (false),
     connRegistered_ (false)
 {
     assert(http != NULL);
     memset (reqbuf, '\0', sizeof (reqbuf));
     flags.deferred = 0;
     flags.parsed_ok = 0;
     deferredparams.node = NULL;
     deferredparams.rep = NULL;
 }
 
 void
 ClientSocketContext::writeControlMsg(HttpControlMsg &amp;msg)
 {
     HttpReply::Pointer rep(msg.reply);
     Must(rep != NULL);
 
     // remember the callback
     cbControlMsgSent = msg.cbSuccess;
@@ -641,77 +611,40 @@
 ClientHttpRequest::freeResources()
 {
     safe_free(uri);
     safe_free(log_uri);
     safe_free(redirect.location);
     range_iter.boundary.clean();
     HTTPMSGUNLOCK(request);
 
     if (client_stream.tail)
         clientStreamAbort((clientStreamNode *)client_stream.tail-&gt;data, this);
 }
 
 void
 httpRequestFree(void *data)
 {
     ClientHttpRequest *http = (ClientHttpRequest *)data;
     assert(http != NULL);
     delete http;
 }
 
-bool
-ConnStateData::areAllContextsForThisConnection() const
-{
-    ClientSocketContext::Pointer context = getCurrentContext();
-
-    while (context.getRaw()) {
-        if (context-&gt;http-&gt;getConn() != this)
-            return false;
-
-        context = context-&gt;next;
-    }
-
-    return true;
-}
-
-void
-ConnStateData::freeAllContexts()
-{
-    ClientSocketContext::Pointer context;
-
-    while ((context = getCurrentContext()).getRaw() != NULL) {
-        assert(getCurrentContext() !=
-               getCurrentContext()-&gt;next);
-        context-&gt;connIsFinished();
-        assert (context != currentobject);
-    }
-}
-
-/// propagates abort event to all contexts
-void
-ConnStateData::notifyAllContexts(int xerrno)
-{
-    typedef ClientSocketContext::Pointer CSCP;
-    for (CSCP c = getCurrentContext(); c.getRaw(); c = c-&gt;next)
-        c-&gt;noteIoError(xerrno);
-}
-
 /* This is a handler normally called by comm_close() */
 void ConnStateData::connStateClosed(const CommCloseCbParams &amp;)
 {
     deleteThis(&quot;ConnStateData::connStateClosed&quot;);
 }
 
 #if USE_AUTH
 void
 ConnStateData::setAuth(const Auth::UserRequest::Pointer &amp;aur, const char *by)
 {
     if (auth_ == NULL) {
         if (aur != NULL) {
             debugs(33, 2, &quot;Adding connection-auth to &quot; &lt;&lt; clientConnection &lt;&lt; &quot; from &quot; &lt;&lt; by);
             auth_ = aur;
         }
         return;
     }
 
     // clobered with self-pointer
     // NP: something nasty is going on in Squid, but harmless.
@@ -773,42 +706,41 @@
         auth_-&gt;releaseAuthServer();
         auth_ = NULL;
         // this is a fatal type of problem.
         // Close the connection immediately with TCP RST to abort all traffic flow
         comm_reset_close(clientConnection);
         return;
     }
 
     /* NOT REACHABLE */
 }
 #endif
 
 // cleans up before destructor is called
 void
 ConnStateData::swanSong()
 {
     debugs(33, 2, HERE &lt;&lt; clientConnection);
     flags.readMore = false;
     DeregisterRunner(this);
     clientdbEstablished(clientConnection-&gt;remote, -1);  /* decrement */
-    assert(areAllContextsForThisConnection());
-    freeAllContexts();
+    pipeline.terminateAll(0);
 
     unpinConnection(true);
 
     Server::swanSong(); // closes the client connection
 
 #if USE_AUTH
     // NP: do this bit after closing the connections to avoid side effects from unwanted TCP RST
     setAuth(NULL, &quot;ConnStateData::SwanSong cleanup&quot;);
 #endif
 
     flags.swanSang = true;
 }
 
 bool
 ConnStateData::isOpen() const
 {
     return cbdataReferenceValid(this) &amp;&amp; // XXX: checking &quot;this&quot; in a method
            Comm::IsConnOpen(clientConnection) &amp;&amp;
            !fd_table[clientConnection-&gt;fd].closing();
 }
@@ -869,47 +801,40 @@
         return (r-&gt;content_length &lt;= 0 || Config.onoff.request_entities);
 
     default:
         /* For other types of requests we don't care */
         return 1;
     }
 
     /* NOT REACHED */
 }
 
 int
 clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength)
 {
     if (Config.maxRequestBodySize &amp;&amp;
             bodyLength &gt; Config.maxRequestBodySize)
         return 1;       /* too large */
 
     return 0;
 }
 
-// careful: the &quot;current&quot; context may be gone if we wrote an early response
-ClientSocketContext::Pointer
-ConnStateData::getCurrentContext() const
-{
-    return currentobject;
-}
-
 void
 ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData)
 {
     debugs(33, 2, &quot;clientSocketRecipient: Deferring request &quot; &lt;&lt; http-&gt;uri);
     assert(flags.deferred == 0);
     flags.deferred = 1;
     deferredparams.node = node;
     deferredparams.rep = rep;
     deferredparams.queuedBuffer = receivedData;
     return;
 }
 
 bool
 ClientSocketContext::startOfOutput() const
 {
     return http-&gt;out.size == 0;
 }
 
 size_t
 ClientSocketContext::lengthToSend(Range&lt;int64_t&gt; const &amp;available)
@@ -1402,41 +1327,42 @@
 {
     // dont tryt to deliver if client already ABORTED
     if (!http-&gt;getConn() || !cbdataReferenceValid(http-&gt;getConn()) || !Comm::IsConnOpen(http-&gt;getConn()-&gt;clientConnection))
         return;
 
     /* Test preconditions */
     assert(node != NULL);
     PROF_start(clientSocketRecipient);
     /* TODO: handle this rather than asserting
      * - it should only ever happen if we cause an abort and
      * the callback chain loops back to here, so we can simply return.
      * However, that itself shouldn't happen, so it stays as an assert for now.
      */
     assert(cbdataReferenceValid(node));
     assert(node-&gt;node.next == NULL);
     ClientSocketContext::Pointer context = dynamic_cast&lt;ClientSocketContext *&gt;(node-&gt;data.getRaw());
     assert(context != NULL);
 
     /* TODO: check offset is what we asked for */
 
-    if (context != http-&gt;getConn()-&gt;getCurrentContext())
+    // TODO: enforces HTTP/1 MUST on pipeline order, but is irrelevant to HTTP/2
+    if (context != http-&gt;getConn()-&gt;pipeline.front())
         context-&gt;deferRecipientForLater(node, rep, receivedData);
     else
         http-&gt;getConn()-&gt;handleReply(rep, receivedData);
 
     PROF_stop(clientSocketRecipient);
 }
 
 /**
  * Called when a downstream node is no longer interested in
  * our data. As we are a terminal node, this means on aborts
  * only
  */
 void
 clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
 {
     /* Test preconditions */
     assert(node != NULL);
     /* TODO: handle this rather than asserting
      * - it should only ever happen if we cause an abort and
      * the callback chain loops back to here, so we can simply return.
@@ -1483,121 +1409,118 @@
 {
     debugs(33, 2, HERE &lt;&lt; conn-&gt;clientConnection &lt;&lt; &quot; Sending next&quot;);
 
     /** If the client stream is waiting on a socket write to occur, then */
 
     if (deferredRequest-&gt;flags.deferred) {
         /** NO data is allowed to have been sent. */
         assert(deferredRequest-&gt;http-&gt;out.size == 0);
         /** defer now. */
         clientSocketRecipient(deferredRequest-&gt;deferredparams.node,
                               deferredRequest-&gt;http,
                               deferredRequest-&gt;deferredparams.rep,
                               deferredRequest-&gt;deferredparams.queuedBuffer);
     }
 
     /** otherwise, the request is still active in a callbacksomewhere,
      * and we are done
      */
 }
 
-/// called when we have successfully finished writing the response
 void
-ClientSocketContext::keepaliveNextRequest()
+ConnStateData::kick()
 {
-    ConnStateData * conn = http-&gt;getConn();
-
-    debugs(33, 3, HERE &lt;&lt; &quot;ConnnStateData(&quot; &lt;&lt; conn-&gt;clientConnection &lt;&lt; &quot;), Context(&quot; &lt;&lt; clientConnection &lt;&lt; &quot;)&quot;);
-    connIsFinished();
+    if (!Comm::IsConnOpen(clientConnection)) {
+        debugs(33, 2, clientConnection &lt;&lt; &quot; Connection was closed&quot;);
+        return;
+    }
 
-    if (conn-&gt;pinning.pinned &amp;&amp; !Comm::IsConnOpen(conn-&gt;pinning.serverConnection)) {
-        debugs(33, 2, HERE &lt;&lt; conn-&gt;clientConnection &lt;&lt; &quot; Connection was pinned but server side gone. Terminating client connection&quot;);
-        conn-&gt;clientConnection-&gt;close();
+    if (pinning.pinned &amp;&amp; !Comm::IsConnOpen(pinning.serverConnection)) {
+        debugs(33, 2, clientConnection &lt;&lt; &quot; Connection was pinned but server side gone. Terminating client connection&quot;);
+        clientConnection-&gt;close();
         return;
     }
 
     /** \par
      * We are done with the response, and we are either still receiving request
      * body (early response!) or have already stopped receiving anything.
      *
      * If we are still receiving, then clientParseRequest() below will fail.
      * (XXX: but then we will call readNextRequest() which may succeed and
      * execute a smuggled request as we are not done with the current request).
      *
      * If we stopped because we got everything, then try the next request.
      *
      * If we stopped receiving because of an error, then close now to avoid
      * getting stuck and to prevent accidental request smuggling.
      */
 
-    if (const char *reason = conn-&gt;stoppedReceiving()) {
-        debugs(33, 3, HERE &lt;&lt; &quot;closing for earlier request error: &quot; &lt;&lt; reason);
-        conn-&gt;clientConnection-&gt;close();
+    if (const char *reason = stoppedReceiving()) {
+        debugs(33, 3, &quot;closing for earlier request error: &quot; &lt;&lt; reason);
+        clientConnection-&gt;close();
         return;
     }
 
     /** \par
      * Attempt to parse a request from the request buffer.
      * If we've been fed a pipelined request it may already
      * be in our read buffer.
      *
      \par
      * This needs to fall through - if we're unlucky and parse the _last_ request
      * from our read buffer we may never re-register for another client read.
      */
 
-    if (conn-&gt;clientParseRequests()) {
-        debugs(33, 3, HERE &lt;&lt; conn-&gt;clientConnection &lt;&lt; &quot;: parsed next request from buffer&quot;);
+    if (clientParseRequests()) {
+        debugs(33, 3, clientConnection &lt;&lt; &quot;: parsed next request from buffer&quot;);
     }
 
     /** \par
      * Either we need to kick-start another read or, if we have
      * a half-closed connection, kill it after the last request.
      * This saves waiting for half-closed connections to finished being
      * half-closed _AND_ then, sometimes, spending &quot;Timeout&quot; time in
      * the keepalive &quot;Waiting for next request&quot; state.
      */
-    if (commIsHalfClosed(conn-&gt;clientConnection-&gt;fd) &amp;&amp; (conn-&gt;getConcurrentRequestCount() == 0)) {
-        debugs(33, 3, &quot;ClientSocketContext::keepaliveNextRequest: half-closed client with no pending requests, closing&quot;);
-        conn-&gt;clientConnection-&gt;close();
+    if (commIsHalfClosed(clientConnection-&gt;fd) &amp;&amp; pipeline.empty()) {
+        debugs(33, 3, &quot;half-closed client with no pending requests, closing&quot;);
+        clientConnection-&gt;close();
         return;
     }
 
-    ClientSocketContext::Pointer deferredRequest;
-
     /** \par
      * At this point we either have a parsed request (which we've
      * kicked off the processing for) or not. If we have a deferred
      * request (parsed but deferred for pipeling processing reasons)
      * then look at processing it. If not, simply kickstart
      * another read.
      */
-
-    if ((deferredRequest = conn-&gt;getCurrentContext()).getRaw()) {
-        debugs(33, 3, HERE &lt;&lt; conn-&gt;clientConnection &lt;&lt; &quot;: calling PushDeferredIfNeeded&quot;);
-        ClientSocketContextPushDeferredIfNeeded(deferredRequest, conn);
-    } else if (conn-&gt;flags.readMore) {
-        debugs(33, 3, HERE &lt;&lt; conn-&gt;clientConnection &lt;&lt; &quot;: calling conn-&gt;readNextRequest()&quot;);
-        conn-&gt;readNextRequest();
+    ClientSocketContext::Pointer deferredRequest = pipeline.front();
+    if (deferredRequest != nullptr) {
+        debugs(33, 3, clientConnection &lt;&lt; &quot;: calling PushDeferredIfNeeded&quot;);
+        ClientSocketContextPushDeferredIfNeeded(deferredRequest, this);
+    } else if (flags.readMore) {
+        debugs(33, 3, clientConnection &lt;&lt; &quot;: calling readNextRequest()&quot;);
+        readNextRequest();
     } else {
         // XXX: Can this happen? CONNECT tunnels have deferredRequest set.
-        debugs(33, DBG_IMPORTANT, HERE &lt;&lt; &quot;abandoning &quot; &lt;&lt; conn-&gt;clientConnection);
+        debugs(33, DBG_IMPORTANT, MYNAME &lt;&lt; &quot;abandoning &quot; &lt;&lt; clientConnection);
     }
 }
 
 void
 clientUpdateSocketStats(const LogTags &amp;logType, size_t size)
 {
     if (size == 0)
         return;
 
     statCounter.client_http.kbytes_out += size;
 
     if (logType.isTcpHit())
         statCounter.client_http.hit_kbytes_out += size;
 }
 
 /**
  * increments iterator &quot;i&quot;
  * used by clientPackMoreRanges
  *
  \retval true    there is still data available to pack more ranges
@@ -1758,40 +1681,41 @@
 void
 ClientSocketContext::noteIoError(const int xerrno)
 {
     if (http) {
         http-&gt;logType.err.timedout = (xerrno == ETIMEDOUT);
         // aborted even if xerrno is zero (which means read abort/eof)
         http-&gt;logType.err.aborted = (xerrno != ETIMEDOUT);
     }
 }
 
 void
 ClientSocketContext::doClose()
 {
     clientConnection-&gt;close();
 }
 
 /// called when we encounter a response-related error
 void
 ClientSocketContext::initiateClose(const char *reason)
 {
+    debugs(33, 4, clientConnection &lt;&lt; &quot; because &quot; &lt;&lt; reason);
     http-&gt;getConn()-&gt;stopSending(reason); // closes ASAP
 }
 
 void
 ConnStateData::stopSending(const char *error)
 {
     debugs(33, 4, HERE &lt;&lt; &quot;sending error (&quot; &lt;&lt; clientConnection &lt;&lt; &quot;): &quot; &lt;&lt; error &lt;&lt;
            &quot;; old receiving error: &quot; &lt;&lt;
            (stoppedReceiving() ? stoppedReceiving_ : &quot;none&quot;));
 
     if (const char *oldError = stoppedSending()) {
         debugs(33, 3, HERE &lt;&lt; &quot;already stopped sending: &quot; &lt;&lt; oldError);
         return; // nothing has changed as far as this connection is concerned
     }
     stoppedSending_ = error;
 
     if (!stoppedReceiving()) {
         if (const int64_t expecting = mayNeedToReadMoreBody()) {
             debugs(33, 5, HERE &lt;&lt; &quot;must still read &quot; &lt;&lt; expecting &lt;&lt;
                    &quot; request body bytes with &quot; &lt;&lt; inBuf.length() &lt;&lt; &quot; unused&quot;);
@@ -1812,86 +1736,88 @@
            (entry ? entry-&gt;objectLen() : 0));
     clientUpdateSocketStats(http-&gt;logType, size);
 
     /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */
 
     if (errflag == Comm::ERR_CLOSING || !Comm::IsConnOpen(conn))
         return;
 
     if (errflag || clientHttpRequestStatus(conn-&gt;fd, http)) {
         initiateClose(&quot;failure or true request status&quot;);
         /* Do we leak here ? */
         return;
     }
 
     switch (socketState()) {
 
     case STREAM_NONE:
         pullData();
         break;
 
-    case STREAM_COMPLETE:
+    case STREAM_COMPLETE: {
         debugs(33, 5, conn &lt;&lt; &quot; Stream complete, keepalive is &quot; &lt;&lt; http-&gt;request-&gt;flags.proxyKeepalive);
-        if (http-&gt;request-&gt;flags.proxyKeepalive)
-            keepaliveNextRequest();
-        else
-            initiateClose(&quot;STREAM_COMPLETE NOKEEPALIVE&quot;);
+        ConnStateData *c = http-&gt;getConn();
+        if (!http-&gt;request-&gt;flags.proxyKeepalive)
+            clientConnection-&gt;close();
+        finished();
+        c-&gt;kick();
+        }
         return;
 
     case STREAM_UNPLANNED_COMPLETE:
         initiateClose(&quot;STREAM_UNPLANNED_COMPLETE&quot;);
         return;
 
     case STREAM_FAILED:
         initiateClose(&quot;STREAM_FAILED&quot;);
         return;
 
     default:
         fatal(&quot;Hit unreachable code in clientWriteComplete\n&quot;);
     }
 }
 
 ClientSocketContext *
 ConnStateData::abortRequestParsing(const char *const uri)
 {
     ClientHttpRequest *http = new ClientHttpRequest(this);
     http-&gt;req_sz = inBuf.length();
     http-&gt;uri = xstrdup(uri);
     setLogUri (http, uri);
     ClientSocketContext *context = new ClientSocketContext(clientConnection, http);
     StoreIOBuffer tempBuffer;
     tempBuffer.data = context-&gt;reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, new clientReplyContext(http), clientSocketRecipient,
                      clientSocketDetach, context, tempBuffer);
     return context;
 }
 
 void
 ConnStateData::startShutdown()
 {
     // RegisteredRunner API callback - Squid has been shut down
 
     // if connection is idle terminate it now,
     // otherwise wait for grace period to end
-    if (getConcurrentRequestCount() == 0)
+    if (pipeline.empty())
         endingShutdown();
 }
 
 void
 ConnStateData::endingShutdown()
 {
     // RegisteredRunner API callback - Squid shutdown grace period is over
 
     // force the client connection to close immediately
     // swanSong() in the close handler will cleanup.
     if (Comm::IsConnOpen(clientConnection))
         clientConnection-&gt;close();
 
     // deregister now to ensure finalShutdown() does not kill us prematurely.
     // fd_table purge will cleanup if close handler was not fast enough.
     DeregisterRunner(this);
 }
 
 char *
 skipLeadingSpace(char *aString)
@@ -2243,75 +2169,52 @@
         //  But have not parsed there yet!! flag for local-only handling.
         http-&gt;flags.internal = true;
 
     } else if (csd-&gt;port-&gt;flags.accelSurrogate || csd-&gt;switchedToHttps()) {
         /* accelerator mode */
         prepareAcceleratedURL(csd, http, hp);
     }
 
     if (!http-&gt;uri) {
         /* No special rewrites have been applied above, use the
          * requested url. may be rewritten later, so make extra room */
         int url_sz = hp-&gt;requestUri().length() + Config.appendDomainLen + 5;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         SBufToCstring(http-&gt;uri, hp-&gt;requestUri());
     }
 
     result-&gt;flags.parsed_ok = 1;
     return result;
 }
 
-void
-ConnStateData::addContextToQueue(ClientSocketContext * context)
-{
-    ClientSocketContext::Pointer *S;
-
-    for (S = (ClientSocketContext::Pointer *) &amp; currentobject; S-&gt;getRaw();
-            S = &amp;(*S)-&gt;next);
-    *S = context;
-
-    ++nrequests;
-}
-
-int
-ConnStateData::getConcurrentRequestCount() const
-{
-    int result = 0;
-    ClientSocketContext::Pointer *T;
-
-    for (T = (ClientSocketContext::Pointer *) &currentobject;
-            T-&gt;getRaw(); T = &amp;(*T)-&gt;next, ++result);
-    return result;
-}
-
 bool
 ConnStateData::connFinishedWithConn(int size)
 {
     if (size == 0) {
-        if (getConcurrentRequestCount() == 0 &amp;&amp; inBuf.isEmpty()) {
+        if (pipeline.empty() &amp;&amp; inBuf.isEmpty()) {
             /* no current or pending requests */
             debugs(33, 4, HERE &lt;&lt; clientConnection &lt;&lt; &quot; closed&quot;);
             return true;
         } else if (!Config.onoff.half_closed_clients) {
             /* admin doesn't want to support half-closed client sockets */
             debugs(33, 3, HERE &lt;&lt; clientConnection &lt;&lt; &quot; aborted (half_closed_clients disabled)&quot;);
-            notifyAllContexts(0); // no specific error implies abort
+            pipeline.terminateAll(0);
             return true;
         }
     }
 
     return false;
 }
 
 void
 ConnStateData::consumeInput(const size_t byteCount)
 {
     assert(byteCount &gt; 0 &amp;&amp; byteCount &lt;= inBuf.length());
     inBuf.consume(byteCount);
     debugs(33, 5, &quot;inBuf has &quot; &lt;&lt; inBuf.length() &lt;&lt; &quot; unused bytes&quot;);
 }
 
 void
 ConnStateData::clientAfterReadingRequests()
 {
     // Were we expecting to read more request body from half-closed connection?
     if (mayNeedToReadMoreBody() &amp;&amp; commIsHalfClosed(clientConnection-&gt;fd)) {
@@ -2413,51 +2316,56 @@
                 repContext-&gt;setReplyToError(request-&gt;method, err);
                 assert(context-&gt;http-&gt;out.offset == 0);
                 context-&gt;pullData();
                 return true;
             }
         }
     }
 
     return false;
 }
 #endif // USE_OPENSSL
 
 /**
  * Check on_unsupported_protocol checklist and return true if tunnel mode selected
  * or false otherwise
  */
 bool
 clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod&amp; method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
 {
     if (conn-&gt;port-&gt;flags.isIntercepted() &amp;&amp;
-            Config.accessList.on_unsupported_protocol &amp;&amp; conn-&gt;nrequests &lt;= 1) {
+            Config.accessList.on_unsupported_protocol &amp;&amp; conn-&gt;pipeline.nrequests &lt;= 1) {
         ACLFilledChecklist checklist(Config.accessList.on_unsupported_protocol, request, NULL);
         checklist.requestErrorType = requestError;
         checklist.src_addr = conn-&gt;clientConnection-&gt;remote;
         checklist.my_addr = conn-&gt;clientConnection-&gt;local;
         checklist.conn(conn);
         allow_t answer = checklist.fastCheck();
         if (answer == ACCESS_ALLOWED &amp;&amp; answer.kind == 1) {
             debugs(33, 3, &quot;Request will be tunneled to server&quot;);
-            if (context)
-                context-&gt;removeFromConnectionList(conn);
+            if (context) {
+                // XXX: Either the context is finished() or it should stay queued.
+                // The below may leak client streams BodyPipe objects. BUT, we need
+                // to check if client-streams detatch is safe to do here (finished() will detatch).
+                assert(conn-&gt;pipeline.front() == context); // XXX: still assumes HTTP/1 semantics
+                conn-&gt;pipeline.popMe(ClientSocketContextPointer(context));
+            }
             Comm::SetSelect(conn-&gt;clientConnection-&gt;fd, COMM_SELECT_READ, NULL, NULL, 0);
             conn-&gt;fakeAConnectRequest(&quot;unknown-protocol&quot;, conn-&gt;preservedClientData);
             return true;
         } else {
             debugs(33, 3, &quot;Continue with returning the error: &quot; &lt;&lt; requestError);
         }
     }
 
     if (context) {
         conn-&gt;quitAfterError(request);
         clientStreamNode *node = context-&gt;getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
         assert (repContext);
 
         repContext-&gt;setReplyToError(requestError, errStatusCode, method, context-&gt;http-&gt;uri, conn-&gt;clientConnection-&gt;remote, NULL, requestErrorBytes, NULL);
 
         assert(context-&gt;http-&gt;out.offset == 0);
         context-&gt;pullData();
     } // else Probably an ERR_REQUEST_START_TIMEOUT error so just return.
     return false;
@@ -2668,41 +2576,41 @@
     clientProcessRequestFinished(conn, request);
 }
 
 int
 ConnStateData::pipelinePrefetchMax() const
 {
     // TODO: Support pipelined requests through pinned connections.
     if (pinning.pinned)
         return 0;
     return Config.pipeline_max_prefetch;
 }
 
 /**
  * Limit the number of concurrent requests.
  * \return true  when there are available position(s) in the pipeline queue for another request.
  * \return false when the pipeline queue is full or disabled.
  */
 bool
 ConnStateData::concurrentRequestQueueFilled() const
 {
-    const int existingRequestCount = getConcurrentRequestCount();
+    const int existingRequestCount = pipeline.count();
 
     // default to the configured pipeline size.
     // add 1 because the head of pipeline is counted in concurrent requests and not prefetch queue
 #if USE_OPENSSL
     const int internalRequest = (transparent() &amp;&amp; sslBumpMode == Ssl::bumpSplice) ? 1 : 0;
 #else
     const int internalRequest = 0;
 #endif
     const int concurrentRequestLimit = pipelinePrefetchMax() + 1 + internalRequest;
 
     // when queue filled already we cant add more.
     if (existingRequestCount &gt;= concurrentRequestLimit) {
         debugs(33, 3, clientConnection &lt;&lt; &quot; max concurrent requests reached (&quot; &lt;&lt; concurrentRequestLimit &lt;&lt; &quot;)&quot;);
         debugs(33, 5, clientConnection &lt;&lt; &quot; deferring new request until one is done&quot;);
         return true;
     }
 
     return false;
 }
 
@@ -3032,55 +2940,55 @@
             if (context-&gt;mayUseConnection()) {
                 debugs(33, 3, HERE &lt;&lt; &quot;Not parsing new requests, as this request may need the connection&quot;);
                 break;
             }
         } else {
             debugs(33, 5, clientConnection &lt;&lt; &quot;: not enough request data: &quot; &lt;&lt;
                    inBuf.length() &lt;&lt; &quot; &lt; &quot; &lt;&lt; Config.maxRequestHeaderSize);
             Must(inBuf.length() &lt; Config.maxRequestHeaderSize);
             break;
         }
     }
 
     /* XXX where to 'finish' the parsing pass? */
     return parsed_req;
 }
 
 void
 ConnStateData::afterClientRead()
 {
     /* Process next request */
-    if (getConcurrentRequestCount() == 0)
+    if (pipeline.empty())
         fd_note(clientConnection-&gt;fd, &quot;Reading next request&quot;);
 
     if (!clientParseRequests()) {
         if (!isOpen())
             return;
         /*
          * If the client here is half closed and we failed
          * to parse a request, close the connection.
          * The above check with connFinishedWithConn() only
          * succeeds _if_ the buffer is empty which it won't
          * be if we have an incomplete request.
-         * XXX: This duplicates ClientSocketContext::keepaliveNextRequest
+         * XXX: This duplicates ConnStateData::kick
          */
-        if (getConcurrentRequestCount() == 0 &amp;&amp; commIsHalfClosed(clientConnection-&gt;fd)) {
+        if (pipeline.empty() &amp;&amp; commIsHalfClosed(clientConnection-&gt;fd)) {
             debugs(33, 5, clientConnection &lt;&lt; &quot;: half-closed connection, no completed request parsed, connection closing.&quot;);
             clientConnection-&gt;close();
             return;
         }
     }
 
     if (!isOpen())
         return;
 
     clientAfterReadingRequests();
 }
 
 /**
  * called when new request data has been read from the socket
  *
  * \retval false called comm_close or setReplyToError (the caller should bail)
  * \retval true  we did not call comm_close or setReplyToError
  */
 bool
 ConnStateData::handleReadData()
@@ -3170,41 +3078,41 @@
         Must(!bodyParser-&gt;needsMoreSpace() || bodyPipe-&gt;buf().hasContent());
     } catch (...) { // TODO: be more specific
         debugs(33, 3, HERE &lt;&lt; &quot;malformed chunks&quot; &lt;&lt; bodyPipe-&gt;status());
         return ERR_INVALID_REQ;
     }
 
     debugs(33, 7, HERE &lt;&lt; &quot;need more chunked data&quot; &lt;&lt; *bodyPipe-&gt;status());
     return ERR_NONE;
 }
 
 /// quit on errors related to chunked request body handling
 void
 ConnStateData::abortChunkedRequestBody(const err_type error)
 {
     finishDechunkingRequest(false);
 
     // XXX: The code below works if we fail during initial request parsing,
     // but if we fail when the server connection is used already, the server may send
     // us its response too, causing various assertions. How to prevent that?
 #if WE_KNOW_HOW_TO_SEND_ERRORS
-    ClientSocketContext::Pointer context = getCurrentContext();
+    ClientSocketContext::Pointer context = pipeline.front();
     if (context != NULL &amp;&amp; !context-&gt;http-&gt;out.offset) { // output nothing yet
         clientStreamNode *node = context-&gt;getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast&lt;clientReplyContext*&gt;(node-&gt;data.getRaw());
         assert(repContext);
         const Http::StatusCode scode = (error == ERR_TOO_BIG) ?
                                        Http::scPayloadTooLarge : HTTP_BAD_REQUEST;
         repContext-&gt;setReplyToError(error, scode,
                                     repContext-&gt;http-&gt;request-&gt;method,
                                     repContext-&gt;http-&gt;uri,
                                     CachePeer,
                                     repContext-&gt;http-&gt;request,
                                     inBuf, NULL);
         context-&gt;pullData();
     } else {
         // close or otherwise we may get stuck as nobody will notice the error?
         comm_reset_close(clientConnection);
     }
 #else
     debugs(33, 3, HERE &lt;&lt; &quot;aborting chunked request without error &quot; &lt;&lt; error);
     comm_reset_close(clientConnection);
@@ -3257,41 +3165,40 @@
     */
     debugs(33, 3, &quot;requestTimeout: FD &quot; &lt;&lt; io.fd &lt;&lt; &quot;: lifetime is expired.&quot;);
     io.conn-&gt;close();
 }
 
 static void
 clientLifetimeTimeout(const CommTimeoutCbParams &amp;io)
 {
     ClientHttpRequest *http = static_cast&lt;ClientHttpRequest *&gt;(io.data);
     debugs(33, DBG_IMPORTANT, &quot;WARNING: Closing client connection due to lifetime timeout&quot;);
     debugs(33, DBG_IMPORTANT, &quot;\t&quot; &lt;&lt; http-&gt;uri);
     http-&gt;logType.err.timedout = true;
     if (Comm::IsConnOpen(io.conn))
         io.conn-&gt;close();
 }
 
 ConnStateData::ConnStateData(const MasterXaction::Pointer &amp;xact) :
     AsyncJob(&quot;ConnStateData&quot;), // kids overwrite
     Server(xact),
     bodyParser(nullptr),
-    nrequests(0),
 #if USE_OPENSSL
     sslBumpMode(Ssl::bumpEnd),
 #endif
     needProxyProtocolHeader_(false),
 #if USE_OPENSSL
     switchedToHttps_(false),
     sslServerBump(NULL),
     signAlgorithm(Ssl::algSignTrusted),
 #endif
     stoppedSending_(NULL),
     stoppedReceiving_(NULL)
 {
     flags.readMore = true; // kids may overwrite
     flags.swanSang = false;
 
     pinning.host = NULL;
     pinning.port = -1;
     pinning.pinned = false;
     pinning.auth = false;
     pinning.zeroReply = false;
@@ -3806,43 +3713,44 @@
 
     if (certProperties.signAlgorithm == Ssl::algSignUntrusted) {
         assert(port-&gt;untrustedSigningCert.get());
         certProperties.signWithX509.resetAndLock(port-&gt;untrustedSigningCert.get());
         certProperties.signWithPkey.resetAndLock(port-&gt;untrustedSignPkey.get());
     } else {
         assert(port-&gt;signingCert.get());
         certProperties.signWithX509.resetAndLock(port-&gt;signingCert.get());
 
         if (port-&gt;signPkey.get())
             certProperties.signWithPkey.resetAndLock(port-&gt;signPkey.get());
     }
     signAlgorithm = certProperties.signAlgorithm;
 
     certProperties.signHash = Ssl::DefaultSignHash;
 }
 
 void
 ConnStateData::getSslContextStart()
 {
-    assert(areAllContextsForThisConnection());
-    freeAllContexts();
-    /* careful: freeAllContexts() above frees request, host, etc. */
+    // XXX starting SSL with a pipeline of requests still waiting for non-SSL replies?
+    assert(pipeline.count() &lt; 2); // the CONNECT is okay for now. Anything else is a bug.
+    pipeline.terminateAll(0);
+    /* careful: terminateAll(0) above frees request, host, etc. */
 
     if (port-&gt;generateHostCertificates) {
         Ssl::CertificateProperties certProperties;
         buildSslCertGenerationParams(certProperties);
         sslBumpCertKey = certProperties.dbKey().c_str();
         assert(sslBumpCertKey.size() &gt; 0 &amp;&amp; sslBumpCertKey[0] != '\0');
 
         // Disable caching for bumpPeekAndSplice mode
         if (!(sslServerBump &amp;&amp; (sslServerBump-&gt;act.step1 == Ssl::bumpPeek || sslServerBump-&gt;act.step1 == Ssl::bumpStare))) {
             debugs(33, 5, &quot;Finding SSL certificate for &quot; &lt;&lt; sslBumpCertKey &lt;&lt; &quot; in cache&quot;);
             Ssl::LocalContextStorage * ssl_ctx_cache = Ssl::TheGlobalContextStorage.getLocalStorage(port-&gt;s);
             Security::ContextPointer dynCtx = nullptr;
             Ssl::SSL_CTX_Pointer *cachedCtx = ssl_ctx_cache ? ssl_ctx_cache-&gt;get(sslBumpCertKey.termedBuf()) : NULL;
             if (cachedCtx &amp;&amp; (dynCtx = cachedCtx-&gt;get())) {
                 debugs(33, 5, &quot;SSL certificate for &quot; &lt;&lt; sslBumpCertKey &lt;&lt; &quot; found in cache&quot;);
                 if (Ssl::verifySslCertificate(dynCtx, certProperties)) {
                     debugs(33, 5, &quot;Cached SSL certificate for &quot; &lt;&lt; sslBumpCertKey &lt;&lt; &quot; is valid&quot;);
                     getSslContextDone(dynCtx);
                     return;
                 } else {
@@ -4114,41 +4022,41 @@
     debugs(83,5, &quot;Bio for  &quot; &lt;&lt; clientConnection &lt;&lt; &quot; read &quot; &lt;&lt; rbuf.contentSize() &lt;&lt; &quot; helo bytes&quot;);
     // Do splice:
     fd_table[clientConnection-&gt;fd].read_method = &amp;default_read_method;
     fd_table[clientConnection-&gt;fd].write_method = &amp;default_write_method;
 
     if (transparent()) {
         // set the current protocol to something sensible (was &quot;HTTPS&quot; for the bumping process)
         // we are sending a faked-up HTTP/1.1 message wrapper, so go with that.
         transferProtocol = Http::ProtocolVersion();
         // XXX: copy from MemBuf reallocates, not a regression since old code did too
         SBuf temp;
         temp.append(rbuf.content(), rbuf.contentSize());
         fakeAConnectRequest(&quot;intercepted TLS spliced&quot;, temp);
     } else {
         // XXX: assuming that there was an HTTP/1.1 CONNECT to begin with...
 
         // reset the current protocol to HTTP/1.1 (was &quot;HTTPS&quot; for the bumping process)
         transferProtocol = Http::ProtocolVersion();
         // inBuf still has the &quot;CONNECT ...&quot; request data, reset it to SSL hello message
         inBuf.append(rbuf.content(), rbuf.contentSize());
-        ClientSocketContext::Pointer context = getCurrentContext();
+        ClientSocketContext::Pointer context = pipeline.front();
         ClientHttpRequest *http = context-&gt;http;
         tunnelStart(http);
     }
 }
 
 void
 ConnStateData::startPeekAndSpliceDone()
 {
     // This is the Step2 of the SSL bumping
     assert(sslServerBump);
     if (sslServerBump-&gt;step == Ssl::bumpStep1) {
         sslServerBump-&gt;step = Ssl::bumpStep2;
         // Run a accessList check to check if want to splice or continue bumping
 
         ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(Config.accessList.ssl_bump, sslServerBump-&gt;request.getRaw(), NULL);
         //acl_checklist-&gt;src_addr = params.conn-&gt;remote;
         //acl_checklist-&gt;my_addr = s-&gt;s;
         acl_checklist-&gt;banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpNone));
         acl_checklist-&gt;banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpClientFirst));
         acl_checklist-&gt;banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpServerFirst));
@@ -4170,42 +4078,42 @@
     debugs(33, 5, &quot;PeekAndSplice mode, proceed with client negotiation. Currrent state:&quot; &lt;&lt; SSL_state_string_long(ssl));
     bio-&gt;hold(false);
 
     Comm::SetSelect(clientConnection-&gt;fd, COMM_SELECT_WRITE, clientNegotiateSSL, this, 0);
     switchedToHttps_ = true;
 }
 
 void
 ConnStateData::httpsPeeked(Comm::ConnectionPointer serverConnection)
 {
     Must(sslServerBump != NULL);
 
     if (Comm::IsConnOpen(serverConnection)) {
         pinConnection(serverConnection, NULL, NULL, false);
 
         debugs(33, 5, HERE &lt;&lt; &quot;bumped HTTPS server: &quot; &lt;&lt; sslConnectHostOrIp);
     } else {
         debugs(33, 5, HERE &lt;&lt; &quot;Error while bumping: &quot; &lt;&lt; sslConnectHostOrIp);
 
         //  copy error detail from bump-server-first request to CONNECT request
-        if (currentobject != NULL &amp;&amp; currentobject-&gt;http != NULL &amp;&amp; currentobject-&gt;http-&gt;request)
-            currentobject-&gt;http-&gt;request-&gt;detailError(sslServerBump-&gt;request-&gt;errType, sslServerBump-&gt;request-&gt;errDetail);
+        if (!pipeline.empty() &amp;&amp; pipeline.front()-&gt;http != nullptr &amp;&amp; pipeline.front()-&gt;http-&gt;request)
+            pipeline.front()-&gt;http-&gt;request-&gt;detailError(sslServerBump-&gt;request-&gt;errType, sslServerBump-&gt;request-&gt;errDetail);
     }
 
     getSslContextStart();
 }
 
 #endif /* USE_OPENSSL */
 
 void
 ConnStateData::fakeAConnectRequest(const char *reason, const SBuf &amp;payload)
 {
     // fake a CONNECT request to force connState to tunnel
     SBuf connectHost;
 #if USE_OPENSSL
     if (serverBump() &amp;&amp; !serverBump()-&gt;clientSni.isEmpty()) {
         connectHost.assign(serverBump()-&gt;clientSni);
         if (clientConnection-&gt;local.port() &gt; 0)
             connectHost.appendf(&quot;:%d&quot;,clientConnection-&gt;local.port());
     } else
 #endif
     {
@@ -4604,61 +4512,61 @@
 {
     Must(bodyPipe != NULL);
     debugs(33, 5, HERE &lt;&lt; &quot;start dechunking&quot; &lt;&lt; bodyPipe-&gt;status());
     assert(!bodyParser);
     bodyParser = new Http1::TeChunkedParser;
 }
 
 /// put parsed content into input buffer and clean up
 void
 ConnStateData::finishDechunkingRequest(bool withSuccess)
 {
     debugs(33, 5, HERE &lt;&lt; &quot;finish dechunking: &quot; &lt;&lt; withSuccess);
 
     if (bodyPipe != NULL) {
         debugs(33, 7, HERE &lt;&lt; &quot;dechunked tail: &quot; &lt;&lt; bodyPipe-&gt;status());
         BodyPipe::Pointer myPipe = bodyPipe;
         stopProducingFor(bodyPipe, withSuccess); // sets bodyPipe-&gt;bodySize()
         Must(!bodyPipe); // we rely on it being nil after we are done with body
         if (withSuccess) {
             Must(myPipe-&gt;bodySizeKnown());
-            ClientSocketContext::Pointer context = getCurrentContext();
+            ClientSocketContext::Pointer context = pipeline.front();
             if (context != NULL &amp;&amp; context-&gt;http &amp;&amp; context-&gt;http-&gt;request)
                 context-&gt;http-&gt;request-&gt;setContentLength(myPipe-&gt;bodySize());
         }
     }
 
     delete bodyParser;
     bodyParser = NULL;
 }
 
+// XXX: this is an HTTP/1-only operation
 void
 ConnStateData::sendControlMsg(HttpControlMsg msg)
 {
     if (!isOpen()) {
         debugs(33, 3, HERE &lt;&lt; &quot;ignoring 1xx due to earlier closure&quot;);
         return;
     }
 
-    ClientSocketContext::Pointer context = getCurrentContext();
-    if (context != NULL) {
-        context-&gt;writeControlMsg(msg); // will call msg.cbSuccess
+    if (!pipeline.empty()) {
+        pipeline.front()-&gt;writeControlMsg(msg); // will call msg.cbSuccess
         return;
     }
 
     debugs(33, 3, HERE &lt;&lt; &quot; closing due to missing context for 1xx&quot;);
     clientConnection-&gt;close();
 }
 
 /// Our close handler called by Comm when the pinned connection is closed
 void
 ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &amp;io)
 {
     // FwdState might repin a failed connection sooner than this close
     // callback is called for the failed connection.
     assert(pinning.serverConnection == io.conn);
     pinning.closeHandler = NULL; // Comm unregisters handlers before calling
     const bool sawZeroReply = pinning.zeroReply; // reset when unpinning
     pinning.serverConnection-&gt;noteClosure();
     unpinConnection(false);
 
     if (sawZeroReply &amp;&amp; clientConnection != NULL) {
@@ -4784,50 +4692,49 @@
 }
 #endif
 
 /// Our read handler called by Comm when the server either closes an idle pinned connection or
 /// perhaps unexpectedly sends something on that idle (from Squid p.o.v.) connection.
 void
 ConnStateData::clientPinnedConnectionRead(const CommIoCbParams &amp;io)
 {
     pinning.readHandler = NULL; // Comm unregisters handlers before calling
 
     if (io.flag == Comm::ERR_CLOSING)
         return; // close handler will clean up
 
     Must(pinning.serverConnection == io.conn);
 
 #if USE_OPENSSL
     if (handleIdleClientPinnedTlsRead())
         return;
 #endif
 
-    // We could use getConcurrentRequestCount(), but this may be faster.
-    const bool clientIsIdle = !getCurrentContext();
+    const bool clientIsIdle = pipeline.empty();
 
     debugs(33, 3, &quot;idle pinned &quot; &lt;&lt; pinning.serverConnection &lt;&lt; &quot; read &quot; &lt;&lt;
            io.size &lt;&lt; (clientIsIdle ? &quot; with idle client&quot; : &quot;&quot;));
 
     pinning.serverConnection-&gt;close();
 
     // If we are still sending data to the client, do not close now. When we are done sending,
-    // ClientSocketContext::keepaliveNextRequest() checks pinning.serverConnection and will close.
+    // ConnStateData::kick() checks pinning.serverConnection and will close.
     // However, if we are idle, then we must close to inform the idle client and minimize races.
     if (clientIsIdle &amp;&amp; clientConnection != NULL)
         clientConnection-&gt;close();
 }
 
 const Comm::ConnectionPointer
 ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *aPeer)
 {
     debugs(33, 7, HERE &lt;&lt; pinning.serverConnection);
 
     bool valid = true;
     if (!Comm::IsConnOpen(pinning.serverConnection))
         valid = false;
     else if (pinning.auth &amp;&amp; pinning.host &amp;&amp; request &amp;&amp; strcasecmp(pinning.host, request-&gt;url.host()) != 0)
         valid = false;
     else if (request &amp;&amp; pinning.port != request-&gt;url.port())
         valid = false;
     else if (pinning.peer &amp;&amp; !cbdataReferenceValid(pinning.peer))
         valid = false;
     else if (aPeer != pinning.peer)

=== modified file 'src/client_side.h'
--- src/client_side.h	2015-11-09 16:24:34 +0000
+++ src/client_side.h	2015-11-17 08:18:04 +0000
@@ -20,234 +20,247 @@
 #include &quot;ipc/FdNotes.h&quot;
 #include &quot;SBuf.h&quot;
 #include &quot;servers/Server.h&quot;
 #if USE_AUTH
 #include &quot;auth/UserRequest.h&quot;
 #endif
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
 namespace AnyP
 {
 class PortCfg;
 } // namespace Anyp
 
 /**
  * Badly named.
- * This is in fact the processing context for a single HTTP request.
+ * This is in fact the processing context for a single HTTP transaction.
  *
- * Managing what has been done, and what happens next to the data buffer
- * holding what we hope is an HTTP request.
+ * A context lifetime extends from directly after a request has been parsed
+ * off the client connection buffer, until the last byte of both request
+ * and reply payload (if any) have been written.
+ *
+ * (NOTE: it is not certain yet if an early reply to a POST/PUT is sent by
+ * the server whether the context will remain in the pipeline until its
+ * request payload has finished being read. It is supposed to, but may not)
+ *
+ * Contexts self-register with the Pipeline being managed by the Server
+ * for the connection on which the request was received.
+ *
+ * When HTTP/1 pipeline is operating there may be multiple transactions using
+ * the clientConnection. Only the back() context may read from the connection,
+ * and only the front() context may write to it. A context which needs to read
+ * or write to the connection but does not meet those criteria must be shifted
+ * to the deferred state.
+ *
+ * When a context is completed the finished() method needs to be called which
+ * will perform all cleanup and deregistration operations. If the reason for
+ * finishing is an error, then notifyIoError() needs to be called prior to
+ * the finished() method.
+ * The caller should follow finished() with a call to ConnStateData::kick()
+ * to resume processing of other transactions or I/O on the connection.
  *
- * Parsing is still a mess of global functions done in conjunction with the
- * real socket controller which generated ClientHttpRequest.
- * It also generates one of us and passes us control from there based on
- * the results of the parse.
+ * Alternatively the initiateClose() method can be called to terminate the
+ * whole client connection and all other pending contexts.
  *
- * After that all the request interpretation and adaptation is in our scope.
- * Then finally the reply fetcher is created by this and we get the result
- * back. Which we then have to manage writing of it to the ConnStateData.
- *
- * The socket level management is done by a ConnStateData which owns us.
+ * The socket level management is done by a Server which owns us.
  * The scope of this objects control over a socket consists of the data
- * buffer received from ConnStateData with an initially unknown length.
- * When that length is known it sets the end bounary of our acces to the
+ * buffer received from the Server with an initially unknown length.
+ * When that length is known it sets the end boundary of our access to the
  * buffer.
  *
  * The individual processing actions are done by other Jobs which we
  * kick off as needed.
  *
  * XXX: If an async call ends the ClientHttpRequest job, ClientSocketContext
  * (and ConnStateData) may not know about it, leading to segfaults and
- * assertions like areAllContextsForThisConnection(). This is difficult to fix
+ * assertions. This is difficult to fix
  * because ClientHttpRequest lacks a good way to communicate its ongoing
  * destruction back to the ClientSocketContext which pretends to &quot;own&quot; *http.
  */
 class ClientSocketContext : public RefCountable
 {
     CBDATA_CLASS(ClientSocketContext);
 
 public:
     typedef RefCount&lt;ClientSocketContext&gt; Pointer;
     ClientSocketContext(const Comm::ConnectionPointer &amp;aConn, ClientHttpRequest *aReq);
     ~ClientSocketContext();
     bool startOfOutput() const;
     void writeComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag);
-    void keepaliveNextRequest();
 
     Comm::ConnectionPointer clientConnection; /// details about the client connection socket.
     ClientHttpRequest *http;    /* we pretend to own that job */
     HttpReply *reply;
     char reqbuf[HTTP_REQBUF_SZ];
-    Pointer next;
 
     struct {
 
         unsigned deferred:1; /* This is a pipelined request waiting for the current object to complete */
 
         unsigned parsed_ok:1; /* Was this parsed correctly? */
     } flags;
     bool mayUseConnection() const {return mayUseConnection_;}
 
     void mayUseConnection(bool aBool) {
         mayUseConnection_ = aBool;
         debugs(33,3, HERE &lt;&lt; &quot;This &quot; &lt;&lt; this &lt;&lt; &quot; marked &quot; &lt;&lt; aBool);
     }
 
     class DeferredParams
     {
 
     public:
         clientStreamNode *node;
         HttpReply *rep;
         StoreIOBuffer queuedBuffer;
     };
 
     DeferredParams deferredparams;
     int64_t writtenToSocket;
     void pullData();
     int64_t getNextRangeOffset() const;
     bool canPackMoreRanges() const;
     clientStream_status_t socketState();
     void sendBody(HttpReply * rep, StoreIOBuffer bodyData);
     void sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData);
     size_t lengthToSend(Range&lt;int64_t&gt; const &amp;available);
     void noteSentBodyBytes(size_t);
     void buildRangeHeader(HttpReply * rep);
     clientStreamNode * getTail() const;
     clientStreamNode * getClientReplyContext() const;
     ConnStateData *getConn() const;
-    void connIsFinished();
-    void removeFromConnectionList(ConnStateData * conn);
+    void finished(); ///&lt; cleanup when the transaction has finished. may destroy 'this'
     void deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData);
     bool multipartRangeRequest() const;
     void registerWithConn();
     void noteIoError(const int xerrno); ///&lt; update state to reflect I/O error
 
     /// starts writing 1xx control message to the client
     void writeControlMsg(HttpControlMsg &amp;msg);
 
 protected:
     static IOCB WroteControlMsg;
     void wroteControlMsg(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag, int xerrno);
 
 private:
     void prepareReply(HttpReply * rep);
     void packChunk(const StoreIOBuffer &amp;bodyData, MemBuf &amp;mb);
     void packRange(StoreIOBuffer const &amp;, MemBuf * mb);
-    void deRegisterWithConn();
     void doClose();
     void initiateClose(const char *reason);
 
     AsyncCall::Pointer cbControlMsgSent; ///&lt; notifies HttpControlMsg Source
 
     bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
     bool connRegistered_;
 };
 
 class ConnectionDetail;
 #if USE_OPENSSL
 namespace Ssl
 {
 class ServerBump;
 }
 #endif
+
 /**
- * Manages a connection to a client.
+ * Legacy Server code managing a connection to a client.
+ *
+ * NP: presents AsyncJob API but does not operate autonomously as a Job.
+ *     So Must() is not safe to use.
+ *
+ * Multiple requests (up to pipeline_prefetch) can be pipelined.
+ * This object is responsible for managing which one is currently being
+ * fulfilled and what happens to the queue if the current one causes the client
+ * connection to be closed early.
+ *
+ * Act as a manager for the client connection and passes data in buffer to a
+ * Parser relevant to the state (message headers vs body) that is being
+ * processed.
+ *
+ * Performs HTTP message processing to kick off the actual HTTP request
+ * handling objects (ClientSocketContext, ClientHttpRequest, HttpRequest).
  *
- * Multiple requests (up to pipeline_prefetch) can be pipelined. This object is responsible for managing
- * which one is currently being fulfilled and what happens to the queue if the current one
- * causes the client connection to be closed early.
- *
- * Act as a manager for the connection and passes data in buffer to the current parser.
- * the parser has ambiguous scope at present due to being made from global functions
- * I believe this object uses the parser to identify boundaries and kick off the
- * actual HTTP request handling objects (ClientSocketContext, ClientHttpRequest, HttpRequest)
+ * Performs SSL-Bump processing for switching between HTTP and HTTPS protocols.
  *
- * If the above can be confirmed accurate we can call this object PipelineManager or similar
+ * To terminate a ConnStateData close() the client Comm::Connection it is
+ * managing, or for graceful half-close use the stopReceiving() or
+ * stopSending() methods.
  */
 class ConnStateData : public Server, public HttpControlMsgSink, public RegisteredRunner
 {
 
 public:
     explicit ConnStateData(const MasterXaction::Pointer &amp;xact);
     virtual ~ConnStateData();
 
     /* ::Server API */
-    virtual void notifyAllContexts(const int xerrno);
     virtual void receivedFirstByte();
     virtual bool handleReadData();
     virtual void afterClientRead();
 
-    bool areAllContextsForThisConnection() const;
-    void freeAllContexts();
     /// Traffic parsing
     bool clientParseRequests();
     void readNextRequest();
-    ClientSocketContext::Pointer getCurrentContext() const;
-    void addContextToQueue(ClientSocketContext * context);
-    int getConcurrentRequestCount() const;
+
+    /// try to make progress on a transaction or read more I/O
+    void kick();
+
     bool isOpen() const;
 
     // HttpControlMsgSink API
     virtual void sendControlMsg(HttpControlMsg msg);
 
     Http1::TeChunkedParser *bodyParser; ///&lt; parses HTTP/1.1 chunked request body
 
     /** number of body bytes we need to comm_read for the &quot;current&quot; request
      *
      * \retval 0         We do not need to read any [more] body bytes
      * \retval negative  May need more but do not know how many; could be zero!
      * \retval positive  Need to read exactly that many more body bytes
      */
     int64_t mayNeedToReadMoreBody() const;
 
 #if USE_AUTH
     /**
      * Fetch the user details for connection based authentication
      * NOTE: this is ONLY connection based because NTLM and Negotiate is against HTTP spec.
      */
     const Auth::UserRequest::Pointer &amp;getAuth() const { return auth_; }
 
     /**
      * Set the user details for connection-based authentication to use from now until connection closure.
      *
      * Any change to existing credentials shows that something invalid has happened. Such as:
      * - NTLM/Negotiate auth was violated by the per-request headers missing a revalidation token
      * - NTLM/Negotiate auth was violated by the per-request headers being for another user
      * - SSL-Bump CONNECT tunnel with persistent credentials has ended
      */
     void setAuth(const Auth::UserRequest::Pointer &amp;aur, const char *cause);
 #endif
 
-    /**
-     * used by the owner of the connection, opaque otherwise
-     * TODO: generalise the connection owner concept.
-     */
-    ClientSocketContext::Pointer currentobject;
-
     Ip::Address log_addr;
-    int nrequests;
 
     struct {
         bool readMore; ///&lt; needs comm_read (for this request or new requests)
         bool swanSang; // XXX: temporary flag to check proper cleanup
     } flags;
     struct {
         Comm::ConnectionPointer serverConnection; /* pinned server side connection */
         char *host;             /* host name of pinned connection */
         int port;               /* port of pinned connection */
         bool pinned;             /* this connection was pinned */
         bool auth;               /* pinned for www authentication */
         bool reading;   ///&lt; we are monitoring for peer connection closure
         bool zeroReply; ///&lt; server closed w/o response (ERR_ZERO_SIZE_OBJECT)
         CachePeer *peer;             /* CachePeer the connection goes via */
         AsyncCall::Pointer readHandler; ///&lt; detects serverConnection closure
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
     bool transparent() const;
 

=== modified file 'src/servers/FtpServer.cc'
--- src/servers/FtpServer.cc	2015-11-07 12:08:33 +0000
+++ src/servers/FtpServer.cc	2015-11-17 07:10:06 +0000
@@ -107,68 +107,68 @@
     if (reader != NULL)
         return;
 
     const size_t availSpace = sizeof(uploadBuf) - uploadAvailSize;
     if (availSpace &lt;= 0)
         return;
 
     debugs(33, 4, dataConn &lt;&lt; &quot;: reading FTP data...&quot;);
 
     typedef CommCbMemFunT&lt;Server, CommIoCbParams&gt; Dialer;
     reader = JobCallback(33, 5, Dialer, this, Ftp::Server::readUploadData);
     comm_read(dataConn, uploadBuf + uploadAvailSize, availSpace,
               reader);
 }
 
 /// react to the freshly parsed request
 void
 Ftp::Server::doProcessRequest()
 {
     // zero pipelinePrefetchMax() ensures that there is only parsed request
-    ClientSocketContext::Pointer context = getCurrentContext();
-    Must(context != NULL);
-    Must(getConcurrentRequestCount() == 1);
+    Must(pipeline.count() == 1);
+    ClientSocketContext::Pointer context = pipeline.front();
+    Must(context != nullptr);
 
     ClientHttpRequest *const http = context-&gt;http;
     assert(http != NULL);
 
     HttpRequest *const request = http-&gt;request;
     Must(http-&gt;storeEntry() || request);
     const bool mayForward = !http-&gt;storeEntry() &amp;&amp; handleRequest(request);
 
     if (http-&gt;storeEntry() != NULL) {
         debugs(33, 4, &quot;got an immediate response&quot;);
         clientSetKeepaliveFlag(http);
         context-&gt;pullData();
     } else if (mayForward) {
         debugs(33, 4, &quot;forwarding request to server side&quot;);
         assert(http-&gt;storeEntry() == NULL);
         clientProcessRequest(this, Http1::RequestParserPointer(), context.getRaw());
     } else {
         debugs(33, 4, &quot;will resume processing later&quot;);
     }
 }
 
 void
 Ftp::Server::processParsedRequest(ClientSocketContext *)
 {
-    Must(getConcurrentRequestCount() == 1);
+    Must(pipeline.count() == 1);
 
     // Process FTP request asynchronously to make sure FTP
     // data connection accept callback is fired first.
     CallJobHere(33, 4, CbcPointer&lt;Server&gt;(this),
                 Ftp::Server, doProcessRequest);
 }
 
 /// imports more upload data from the data connection
 void
 Ftp::Server::readUploadData(const CommIoCbParams &amp;io)
 {
     debugs(33, 5, io.conn &lt;&lt; &quot; size &quot; &lt;&lt; io.size);
     Must(reader != NULL);
     reader = NULL;
 
     assert(Comm::IsConnOpen(dataConn));
     assert(io.conn-&gt;fd == dataConn-&gt;fd);
 
     if (io.flag == Comm::OK &amp;&amp; bodyPipe != NULL) {
         if (io.size &gt; 0) {
@@ -271,42 +271,42 @@
         clientStartListeningOn(s, subCall, Ipc::fdnFtpSocket);
     }
 }
 
 void
 Ftp::StopListening()
 {
     for (AnyP::PortCfgPointer s = FtpPortList; s != NULL; s = s-&gt;next) {
         if (s-&gt;listenConn != NULL) {
             debugs(1, DBG_IMPORTANT, &quot;Closing FTP port &quot; &lt;&lt; s-&gt;listenConn-&gt;local);
             s-&gt;listenConn-&gt;close();
             s-&gt;listenConn = NULL;
         }
     }
 }
 
 void
 Ftp::Server::notePeerConnection(Comm::ConnectionPointer conn)
 {
     // find request
-    ClientSocketContext::Pointer context = getCurrentContext();
-    Must(context != NULL);
+    ClientSocketContext::Pointer context = pipeline.front();
+    Must(context != nullptr);
     ClientHttpRequest *const http = context-&gt;http;
     Must(http != NULL);
     HttpRequest *const request = http-&gt;request;
     Must(request != NULL);
 
     // this is not an idle connection, so we do not want I/O monitoring
     const bool monitor = false;
 
     // make FTP peer connection exclusive to our request
     pinConnection(conn, request, conn-&gt;getPeer(), false, monitor);
 }
 
 void
 Ftp::Server::clientPinnedConnectionClosed(const CommCloseCbParams &amp;io)
 {
     ConnStateData::clientPinnedConnectionClosed(io);
 
     // if the server control connection is gone, reset state to login again
     resetLogin(&quot;control connection closure&quot;);
 
@@ -744,80 +744,80 @@
         new ClientSocketContext(clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result-&gt;reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
 
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
                      clientSocketDetach, newClient, tempBuffer);
 
     result-&gt;flags.parsed_ok = 1;
     return result;
 }
 
 void
 Ftp::Server::handleReply(HttpReply *reply, StoreIOBuffer data)
 {
     // the caller guarantees that we are dealing with the current context only
-    ClientSocketContext::Pointer context = getCurrentContext();
-    assert(context != NULL);
+    ClientSocketContext::Pointer context = pipeline.front();
+    assert(context != nullptr);
 
     if (context-&gt;http &amp;&amp; context-&gt;http-&gt;al != NULL &amp;&amp;
             !context-&gt;http-&gt;al-&gt;reply &amp;&amp; reply) {
         context-&gt;http-&gt;al-&gt;reply = reply;
         HTTPMSGLOCK(context-&gt;http-&gt;al-&gt;reply);
     }
 
     static ReplyHandler handlers[] = {
         NULL, // fssBegin
         NULL, // fssConnected
         &amp;Ftp::Server::handleFeatReply, // fssHandleFeat
         &amp;Ftp::Server::handlePasvReply, // fssHandlePasv
         &amp;Ftp::Server::handlePortReply, // fssHandlePort
         &amp;Ftp::Server::handleDataReply, // fssHandleDataRequest
         &amp;Ftp::Server::handleUploadReply, // fssHandleUploadRequest
         &amp;Ftp::Server::handleEprtReply,// fssHandleEprt
         &amp;Ftp::Server::handleEpsvReply,// fssHandleEpsv
         NULL, // fssHandleCwd
         NULL, // fssHandlePass
         NULL, // fssHandleCdup
         &amp;Ftp::Server::handleErrorReply // fssError
     };
     try {
         const Server &amp;server = dynamic_cast&lt;const Ftp::Server&amp;&gt;(*context-&gt;getConn());
         if (const ReplyHandler handler = handlers[server.master-&gt;serverState])
             (this-&gt;*handler)(reply, data);
         else
             writeForwardedReply(reply);
     } catch (const std::exception &amp;e) {
         callException(e);
         throw TexcHere(e.what());
     }
 }
 
 void
 Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
 {
-    if (getCurrentContext()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
+    if (pipeline.front()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
         writeCustomReply(502, &quot;Server does not support FEAT&quot;, reply);
         return;
     }
 
     Must(reply);
     HttpReply::Pointer featReply = Ftp::HttpReplyWrapper(211, &quot;End&quot;, Http::scNoContent, 0);
     HttpHeader const &amp;serverReplyHeader = reply-&gt;header;
 
     HttpHeaderPos pos = HttpHeaderInitPos;
     bool hasEPRT = false;
     bool hasEPSV = false;
     int prependSpaces = 1;
 
     featReply-&gt;header.putStr(Http::HdrType::FTP_PRE, &quot;\&quot;211-Features:\&quot;&quot;);
     const int scode = serverReplyHeader.getInt(Http::HdrType::FTP_STATUS);
     if (scode == 211) {
         while (const HttpHeaderEntry *e = serverReplyHeader.getEntry(&amp;pos)) {
             if (e-&gt;id == Http::HdrType::FTP_PRE) {
                 // assume RFC 2389 FEAT response format, quoted by Squid:
                 // &lt;&quot;&gt; SP NAME [SP PARAMS] &lt;&quot;&gt;
@@ -852,81 +852,81 @@
     } // else we got a FEAT error and will only report Squid-supported features
 
     char buf[256];
     if (!hasEPRT) {
         snprintf(buf, sizeof(buf), &quot;\&quot;%*s\&quot;&quot;, prependSpaces + 4, &quot;EPRT&quot;);
         featReply-&gt;header.putStr(Http::HdrType::FTP_PRE, buf);
     }
     if (!hasEPSV) {
         snprintf(buf, sizeof(buf), &quot;\&quot;%*s\&quot;&quot;, prependSpaces + 4, &quot;EPSV&quot;);
         featReply-&gt;header.putStr(Http::HdrType::FTP_PRE, buf);
     }
 
     featReply-&gt;header.refreshMask();
 
     writeForwardedReply(featReply.getRaw());
 }
 
 void
 Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
 {
-    ClientSocketContext::Pointer context = getCurrentContext();
-    assert(context != NULL);
+    const ClientSocketContext::Pointer context(pipeline.front());
+    assert(context != nullptr);
 
     if (context-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
         writeCustomReply(502, &quot;Server does not support PASV&quot;, reply);
         return;
     }
 
     const unsigned short localPort = listenForDataConnection();
     if (!localPort)
         return;
 
     char addr[MAX_IPSTRLEN];
     // remote server in interception setups and local address otherwise
     const Ip::Address &amp;server = transparent() ?
                                 clientConnection-&gt;local : dataListenConn-&gt;local;
     server.toStr(addr, MAX_IPSTRLEN, AF_INET);
     addr[MAX_IPSTRLEN - 1] = '\0';
     for (char *c = addr; *c != '\0'; ++c) {
         if (*c == '.')
             *c = ',';
     }
 
     // In interception setups, we combine remote server address with a
     // local port number and hope that traffic will be redirected to us.
     // Do not use &quot;227 =a,b,c,d,p1,p2&quot; format or omit parens: some nf_ct_ftp
     // versions block responses that use those alternative syntax rules!
     MemBuf mb;
     mb.init();
     mb.appendf(&quot;227 Entering Passive Mode (%s,%i,%i).\r\n&quot;,
                addr,
                static_cast&lt;int&gt;(localPort / 256),
                static_cast&lt;int&gt;(localPort % 256));
     debugs(9, 3, Raw(&quot;writing&quot;, mb.buf, mb.size));
     writeReply(mb);
 }
 
 void
 Ftp::Server::handlePortReply(const HttpReply *reply, StoreIOBuffer)
 {
-    if (getCurrentContext()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
+    if (pipeline.front()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
         writeCustomReply(502, &quot;Server does not support PASV (converted from PORT)&quot;, reply);
         return;
     }
 
     writeCustomReply(200, &quot;PORT successfully converted to PASV.&quot;);
 
     // and wait for RETR
 }
 
 void
 Ftp::Server::handleErrorReply(const HttpReply *reply, StoreIOBuffer)
 {
     if (!pinning.pinned) // we failed to connect to server
         uri.clear();
     // 421: we will close due to fssError
     writeErrorReply(reply, 421);
 }
 
 void
 Ftp::Server::handleDataReply(const HttpReply *reply, StoreIOBuffer data)
@@ -950,70 +950,70 @@
         writeCustomReply(425, &quot;Data connection is not established.&quot;);
         closeDataConnection();
         return;
     }
 
     debugs(33, 7, data.length);
 
     if (data.length &lt;= 0) {
         replyDataWritingCheckpoint(); // skip the actual write call
         return;
     }
 
     MemBuf mb;
     mb.init(data.length + 1, data.length + 1);
     mb.append(data.data, data.length);
 
     typedef CommCbMemFunT&lt;Server, CommIoCbParams&gt; Dialer;
     AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteReplyData);
     Comm::Write(dataConn, &amp;mb, call);
 
-    getCurrentContext()-&gt;noteSentBodyBytes(data.length);
+    pipeline.front()-&gt;noteSentBodyBytes(data.length);
 }
 
 /// called when we are done writing a chunk of the response data
 void
 Ftp::Server::wroteReplyData(const CommIoCbParams &amp;io)
 {
     if (io.flag == Comm::ERR_CLOSING)
         return;
 
     if (io.flag != Comm::OK) {
         debugs(33, 3, &quot;FTP reply data writing failed: &quot; &lt;&lt; xstrerr(io.xerrno));
         closeDataConnection();
         writeCustomReply(426, &quot;Data connection error; transfer aborted&quot;);
         return;
     }
 
-    assert(getCurrentContext()-&gt;http);
-    getCurrentContext()-&gt;http-&gt;out.size += io.size;
+    assert(pipeline.front()-&gt;http);
+    pipeline.front()-&gt;http-&gt;out.size += io.size;
     replyDataWritingCheckpoint();
 }
 
 /// ClientStream checks after (actual or skipped) reply data writing
 void
 Ftp::Server::replyDataWritingCheckpoint()
 {
-    switch (getCurrentContext()-&gt;socketState()) {
+    switch (pipeline.front()-&gt;socketState()) {
     case STREAM_NONE:
         debugs(33, 3, &quot;Keep going&quot;);
-        getCurrentContext()-&gt;pullData();
+        pipeline.front()-&gt;pullData();
         return;
     case STREAM_COMPLETE:
         debugs(33, 3, &quot;FTP reply data transfer successfully complete&quot;);
         writeCustomReply(226, &quot;Transfer complete&quot;);
         break;
     case STREAM_UNPLANNED_COMPLETE:
         debugs(33, 3, &quot;FTP reply data transfer failed: STREAM_UNPLANNED_COMPLETE&quot;);
         writeCustomReply(451, &quot;Server error; transfer aborted&quot;);
         break;
     case STREAM_FAILED:
         debugs(33, 3, &quot;FTP reply data transfer failed: STREAM_FAILED&quot;);
         writeCustomReply(451, &quot;Server error; transfer aborted&quot;);
         break;
     default:
         fatal(&quot;unreachable code&quot;);
     }
 
     closeDataConnection();
 }
 
@@ -1027,77 +1027,77 @@
 void
 Ftp::Server::writeForwardedReply(const HttpReply *reply)
 {
     Must(reply);
 
     const HttpHeader &amp;header = reply-&gt;header;
     // adaptation and forwarding errors lack Http::HdrType::FTP_STATUS
     if (!header.has(Http::HdrType::FTP_STATUS)) {
         writeForwardedForeign(reply); // will get to Ftp::Server::wroteReply
         return;
     }
 
     typedef CommCbMemFunT&lt;Server, CommIoCbParams&gt; Dialer;
     AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteReply);
     writeForwardedReplyAndCall(reply, call);
 }
 
 void
 Ftp::Server::handleEprtReply(const HttpReply *reply, StoreIOBuffer)
 {
-    if (getCurrentContext()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
+    if (pipeline.front()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
         writeCustomReply(502, &quot;Server does not support PASV (converted from EPRT)&quot;, reply);
         return;
     }
 
     writeCustomReply(200, &quot;EPRT successfully converted to PASV.&quot;);
 
     // and wait for RETR
 }
 
 void
 Ftp::Server::handleEpsvReply(const HttpReply *reply, StoreIOBuffer)
 {
-    if (getCurrentContext()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
+    if (pipeline.front()-&gt;http-&gt;request-&gt;errType != ERR_NONE) {
         writeCustomReply(502, &quot;Cannot connect to server&quot;, reply);
         return;
     }
 
     const unsigned short localPort = listenForDataConnection();
     if (!localPort)
         return;
 
     // In interception setups, we use a local port number and hope that data
     // traffic will be redirected to us.
     MemBuf mb;
     mb.init();
     mb.appendf(&quot;229 Entering Extended Passive Mode (|||%u|)\r\n&quot;, localPort);
 
     debugs(9, 3, Raw(&quot;writing&quot;, mb.buf, mb.size));
     writeReply(mb);
 }
 
 /// writes FTP error response with given status and reply-derived error details
 void
 Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
 {
-    const HttpRequest *request = getCurrentContext()-&gt;http-&gt;request;
+    const HttpRequest *request = pipeline.front()-&gt;http-&gt;request;
     assert(request);
 
     MemBuf mb;
     mb.init();
 
     if (request-&gt;errType != ERR_NONE)
         mb.appendf(&quot;%i-%s\r\n&quot;, scode, errorPageName(request-&gt;errType));
 
     if (request-&gt;errDetail &gt; 0) {
         // XXX: &gt; 0 may not always mean that this is an errno
         mb.appendf(&quot;%i-Error: (%d) %s\r\n&quot;, scode,
                    request-&gt;errDetail,
                    strerror(request-&gt;errDetail));
     }
 
 #if USE_ADAPTATION
     // XXX: Remove hard coded names. Use an error page template instead.
     const Adaptation::History::Pointer ah = request-&gt;adaptHistory();
     if (ah != NULL) { // XXX: add adapt::&lt;all_h but use lastMeta here
         const String info = ah-&gt;allMeta.getByName(&quot;X-Response-Info&quot;);
@@ -1210,88 +1210,89 @@
 
     if (header.has(Http::HdrType::FTP_STATUS)) {
         const char *reason = header.getStr(Http::HdrType::FTP_REASON);
         mb.appendf(&quot;%i %s\r\n&quot;, header.getInt(Http::HdrType::FTP_STATUS),
                    (reason ? reason : 0));
     }
 }
 
 void
 Ftp::Server::wroteEarlyReply(const CommIoCbParams &amp;io)
 {
     if (io.flag == Comm::ERR_CLOSING)
         return;
 
     if (io.flag != Comm::OK) {
         debugs(33, 3, &quot;FTP reply writing failed: &quot; &lt;&lt; xstrerr(io.xerrno));
         io.conn-&gt;close();
         return;
     }
 
-    ClientSocketContext::Pointer context = getCurrentContext();
-    if (context != NULL &amp;&amp; context-&gt;http) {
+    ClientSocketContext::Pointer context = pipeline.front();
+    if (context != nullptr &amp;&amp; context-&gt;http) {
         context-&gt;http-&gt;out.size += io.size;
         context-&gt;http-&gt;out.headers_sz += io.size;
     }
 
     flags.readMore = true;
     readSomeData();
 }
 
 void
 Ftp::Server::wroteReply(const CommIoCbParams &amp;io)
 {
     if (io.flag == Comm::ERR_CLOSING)
         return;
 
     if (io.flag != Comm::OK) {
         debugs(33, 3, &quot;FTP reply writing failed: &quot; &lt;&lt; xstrerr(io.xerrno));
         io.conn-&gt;close();
         return;
     }
 
-    ClientSocketContext::Pointer context = getCurrentContext();
+    ClientSocketContext::Pointer context = pipeline.front();
     assert(context-&gt;http);
     context-&gt;http-&gt;out.size += io.size;
     context-&gt;http-&gt;out.headers_sz += io.size;
 
     if (master-&gt;serverState == fssError) {
         debugs(33, 5, &quot;closing on FTP server error&quot;);
         io.conn-&gt;close();
         return;
     }
 
     const clientStream_status_t socketState = context-&gt;socketState();
     debugs(33, 5, &quot;FTP client stream state &quot; &lt;&lt; socketState);
     switch (socketState) {
     case STREAM_UNPLANNED_COMPLETE:
     case STREAM_FAILED:
         io.conn-&gt;close();
         return;
 
     case STREAM_NONE:
     case STREAM_COMPLETE:
         flags.readMore = true;
         changeState(fssConnected, &quot;Ftp::Server::wroteReply&quot;);
         if (bodyParser)
             finishDechunkingRequest(false);
-        context-&gt;keepaliveNextRequest();
+        context-&gt;finished();
+        kick();
         return;
     }
 }
 
 bool
 Ftp::Server::handleRequest(HttpRequest *request)
 {
     debugs(33, 9, request);
     Must(request);
 
     HttpHeader &amp;header = request-&gt;header;
     Must(header.has(Http::HdrType::FTP_COMMAND));
     String &amp;cmd = header.findEntry(Http::HdrType::FTP_COMMAND)-&gt;value;
     Must(header.has(Http::HdrType::FTP_ARGUMENTS));
     String &amp;params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)-&gt;value;
 
     if (do_debug(9, 2)) {
         MemBuf mb;
         mb.init();
         request-&gt;pack(&amp;mb);
@@ -1477,41 +1478,41 @@
 }
 
 bool
 Ftp::Server::handleDataRequest(String &amp;, String &amp;)
 {
     if (!checkDataConnPre())
         return false;
 
     changeState(fssHandleDataRequest, &quot;handleDataRequest&quot;);
 
     return true;
 }
 
 bool
 Ftp::Server::handleUploadRequest(String &amp;, String &amp;)
 {
     if (!checkDataConnPre())
         return false;
 
     if (Config.accessList.forceRequestBodyContinuation) {
-        ClientHttpRequest *http = getCurrentContext()-&gt;http;
+        ClientHttpRequest *http = pipeline.front()-&gt;http;
         HttpRequest *request = http-&gt;request;
         ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request, NULL);
         if (bodyContinuationCheck.fastCheck() == ACCESS_ALLOWED) {
             request-&gt;forcedBodyContinuation = true;
             if (checkDataConnPost()) {
                 // Write control Msg
                 writeEarlyReply(150, &quot;Data connection opened&quot;);
                 maybeReadUploadData();
             } else {
                 // wait for acceptDataConnection but tell it to call wroteEarlyReply
                 // after writing &quot;150 Data connection opened&quot;
                 typedef CommCbMemFunT&lt;Server, CommIoCbParams&gt; Dialer;
                 AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteEarlyReply);
                 onDataAcceptCall = call;
             }
         }
     }
 
     changeState(fssHandleUploadRequest, &quot;handleDataRequest&quot;);
 
@@ -1581,41 +1582,41 @@
 
 bool
 Ftp::Server::handlePassRequest(String &amp;, String &amp;)
 {
     changeState(fssHandlePass, &quot;handlePassRequest&quot;);
     return true;
 }
 
 bool
 Ftp::Server::handleCdupRequest(String &amp;, String &amp;)
 {
     changeState(fssHandleCdup, &quot;handleCdupRequest&quot;);
     return true;
 }
 
 // Convert user PORT, EPRT, PASV, or EPSV data command to Squid PASV command.
 // Squid FTP client decides what data command to use with peers.
 void
 Ftp::Server::setDataCommand()
 {
-    ClientHttpRequest *const http = getCurrentContext()-&gt;http;
+    ClientHttpRequest *const http = pipeline.front()-&gt;http;
     assert(http != NULL);
     HttpRequest *const request = http-&gt;request;
     assert(request != NULL);
     HttpHeader &amp;header = request-&gt;header;
     header.delById(Http::HdrType::FTP_COMMAND);
     header.putStr(Http::HdrType::FTP_COMMAND, &quot;PASV&quot;);
     header.delById(Http::HdrType::FTP_ARGUMENTS);
     header.putStr(Http::HdrType::FTP_ARGUMENTS, &quot;&quot;);
     debugs(9, 5, &quot;client data command converted to fake PASV&quot;);
 }
 
 /// check that client data connection is ready for future I/O or at least
 /// has a chance of becoming ready soon.
 bool
 Ftp::Server::checkDataConnPre()
 {
     if (Comm::IsConnOpen(dataConn))
         return true;
 
     if (Comm::IsConnOpen(dataListenConn)) {
@@ -1647,56 +1648,56 @@
 Ftp::Server::checkDataConnPost() const
 {
     if (!Comm::IsConnOpen(dataConn)) {
         debugs(33, 3, &quot;missing client data conn: &quot; &lt;&lt; dataConn);
         return false;
     }
     return true;
 }
 
 /// Done establishing a data connection to the user.
 void
 Ftp::Server::connectedForData(const CommConnectCbParams &amp;params)
 {
     connector = NULL;
 
     if (params.flag != Comm::OK) {
         /* it might have been a timeout with a partially open link */
         if (params.conn != NULL)
             params.conn-&gt;close();
         setReply(425, &quot;Cannot open data connection.&quot;);
-        ClientSocketContext::Pointer context = getCurrentContext();
+        ClientSocketContext::Pointer context = pipeline.front();
         Must(context-&gt;http);
         Must(context-&gt;http-&gt;storeEntry() != NULL);
     } else {
         Must(dataConn == params.conn);
         Must(Comm::IsConnOpen(params.conn));
         fd_note(params.conn-&gt;fd, &quot;active client ftp data&quot;);
     }
 
     doProcessRequest();
 }
 
 void
 Ftp::Server::setReply(const int code, const char *msg)
 {
-    ClientSocketContext::Pointer context = getCurrentContext();
+    ClientSocketContext::Pointer context = pipeline.front();
     ClientHttpRequest *const http = context-&gt;http;
     assert(http != NULL);
     assert(http-&gt;storeEntry() == NULL);
 
     HttpReply *const reply = Ftp::HttpReplyWrapper(code, msg, Http::scNoContent, 0);
 
     setLogUri(http, urlCanonicalClean(http-&gt;request));
 
     clientStreamNode *const node = context-&gt;getClientReplyContext();
     clientReplyContext *const repContext =
         dynamic_cast&lt;clientReplyContext *&gt;(node-&gt;data.getRaw());
     assert(repContext != NULL);
 
     RequestFlags reqFlags;
     reqFlags.cachable = false; // force releaseRequest() in storeCreateEntry()
     reqFlags.noCache = true;
     repContext-&gt;createStoreEntry(http-&gt;request-&gt;method, reqFlags);
     http-&gt;storeEntry()-&gt;replaceHttpReply(reply);
 }
 

=== modified file 'src/servers/Http1Server.cc'
--- src/servers/Http1Server.cc	2015-11-07 12:08:33 +0000
+++ src/servers/Http1Server.cc	2015-11-15 13:03:14 +0000
@@ -225,78 +225,78 @@
                 const AsyncCall::Pointer cb = asyncCall(11, 3,  &quot;Http1::Server::proceedAfterBodyContinuation&quot;, CbDialer(this, &amp;Http1::Server::proceedAfterBodyContinuation, ClientSocketContext::Pointer(context)));
                 sendControlMsg(HttpControlMsg(rep, cb));
                 return;
             }
         }
     }
     clientProcessRequest(this, parser_, context);
 }
 
 void
 Http::One::Server::noteBodyConsumerAborted(BodyPipe::Pointer ptr)
 {
     ConnStateData::noteBodyConsumerAborted(ptr);
     stopReceiving(&quot;virgin request body consumer aborted&quot;); // closes ASAP
 }
 
 void
 Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
 {
     // the caller guarantees that we are dealing with the current context only
-    ClientSocketContext::Pointer context = getCurrentContext();
-    Must(context != NULL);
+    ClientSocketContext::Pointer context = pipeline.front();
+    Must(context != nullptr);
     const ClientHttpRequest *http = context-&gt;http;
     Must(http != NULL);
 
     // After sending Transfer-Encoding: chunked (at least), always send
     // the last-chunk if there was no error, ignoring responseFinishedOrFailed.
     const bool mustSendLastChunk = http-&gt;request-&gt;flags.chunkedReply &amp;&amp;
                                    !http-&gt;request-&gt;flags.streamError &amp;&amp;
                                    !EBIT_TEST(http-&gt;storeEntry()-&gt;flags, ENTRY_BAD_LENGTH) &amp;&amp;
                                    !context-&gt;startOfOutput();
     const bool responseFinishedOrFailed = !rep &amp;&amp;
                                           !receivedData.data &amp;&amp;
                                           !receivedData.length;
     if (responseFinishedOrFailed &amp;&amp; !mustSendLastChunk) {
         context-&gt;writeComplete(context-&gt;clientConnection, NULL, 0, Comm::OK);
         return;
     }
 
     if (!context-&gt;startOfOutput()) {
         context-&gt;sendBody(rep, receivedData);
         return;
     }
 
     assert(rep);
     http-&gt;al-&gt;reply = rep;
     HTTPMSGLOCK(http-&gt;al-&gt;reply);
     context-&gt;sendStartOfMessage(rep, receivedData);
 }
 
 void
 Http::One::Server::writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &amp;call)
 {
     // apply selected clientReplyContext::buildReplyHeader() mods
     // it is not clear what headers are required for control messages
     rep-&gt;header.removeHopByHopEntries();
     rep-&gt;header.putStr(Http::HdrType::CONNECTION, &quot;keep-alive&quot;);
-    httpHdrMangleList(&amp;rep-&gt;header, getCurrentContext()-&gt;http-&gt;request, ROR_REPLY);
+    httpHdrMangleList(&amp;rep-&gt;header, pipeline.front()-&gt;http-&gt;request, ROR_REPLY);
 
     MemBuf *mb = rep-&gt;pack();
 
     debugs(11, 2, &quot;HTTP Client &quot; &lt;&lt; clientConnection);
     debugs(11, 2, &quot;HTTP Client CONTROL MSG:\n---------\n&quot; &lt;&lt; mb-&gt;buf &lt;&lt; &quot;\n----------&quot;);
 
     Comm::Write(context-&gt;clientConnection, mb, call);
 
     delete mb;
 }
 
 ConnStateData *
 Http::NewServer(MasterXactionPointer &amp;xact)
 {
     return new Http1::Server(xact, false);
 }
 
 ConnStateData *
 Https::NewServer(MasterXactionPointer &amp;xact)
 {

=== modified file 'src/servers/Server.cc'
--- src/servers/Server.cc	2015-11-07 12:12:13 +0000
+++ src/servers/Server.cc	2015-11-15 11:10:03 +0000
@@ -1,30 +1,31 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
+#include &quot;client_side.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;comm/Read.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;MasterXaction.h&quot;
 #include &quot;servers/Server.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;StatCounters.h&quot;
 #include &quot;tools.h&quot;
 
 Server::Server(const MasterXaction::Pointer &amp;xact) :
     AsyncJob(&quot;::Server&quot;), // kids overwrite
     clientConnection(xact-&gt;tcpClient),
     transferProtocol(xact-&gt;squidPort-&gt;transport),
     port(xact-&gt;squidPort),
     receivedFirstByte_(false)
 {}
 
 bool
@@ -150,41 +151,41 @@
             clientConnection-&gt;close();
             return;
         }
 
         /* It might be half-closed, we can't tell */
         fd_table[io.conn-&gt;fd].flags.socket_eof = true;
         commMarkHalfClosed(io.conn-&gt;fd);
         fd_note(io.conn-&gt;fd, &quot;half-closed&quot;);
 
         /* There is one more close check at the end, to detect aborted
          * (partial) requests. At this point we can't tell if the request
          * is partial.
          */
 
         /* Continue to process previously read data */
         break;
 
     // case Comm::COMM_ERROR:
     default: // no other flags should ever occur
         debugs(33, 2, io.conn &lt;&lt; &quot;: got flag &quot; &lt;&lt; rd.flag &lt;&lt; &quot;; &quot; &lt;&lt; xstrerr(rd.xerrno));
-        notifyAllContexts(rd.xerrno);
+        pipeline.terminateAll(rd.xerrno);
         io.conn-&gt;close();
         return;
     }
 
     afterClientRead();
 }
 
 void
 Server::clientWriteDone(const CommIoCbParams &amp;io)
 {
     debugs(33,5, io.conn);
     Must(writer != NULL);
     writer = NULL;
 
     /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */
     if (io.flag == Comm::ERR_CLOSING) {
         debugs(33,5, io.conn &lt;&lt; &quot; closing Bailout.&quot;);
         return;
     }
 

=== modified file 'src/servers/Server.h'
--- src/servers/Server.h	2015-11-07 12:12:13 +0000
+++ src/servers/Server.h	2015-11-15 11:10:19 +0000
@@ -1,59 +1,57 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 33    Client-side Routines */
 
 #ifndef SQUID_SERVERS_SERVER_H
 #define SQUID_SERVERS_SERVER_H
 
 #include &quot;anyp/forward.h&quot;
 #include &quot;anyp/ProtocolVersion.h&quot;
 #include &quot;base/AsyncJob.h&quot;
 #include &quot;BodyPipe.h&quot;
 #include &quot;comm/forward.h&quot;
 #include &quot;CommCalls.h&quot;
+#include &quot;Pipeline.h&quot;
 #include &quot;SBuf.h&quot;
 
 /**
  * Common base for all Server classes used
  * to manage connections from clients.
  */
 class Server : virtual public AsyncJob, public BodyProducer
 {
 public:
     Server(const MasterXaction::Pointer &amp;xact);
     virtual ~Server() {}
 
     /* AsyncJob API */
     virtual void start();
     virtual bool doneAll() const;
     virtual void swanSong();
 
-    /// tell all active contexts on a connection about an error
-    virtual void notifyAllContexts(const int xerrno) = 0;
-
     /// ??
     virtual bool connFinishedWithConn(int size) = 0;
 
     /// processing to be done after a Comm::Read()
     virtual void afterClientRead() = 0;
 
     /// maybe grow the inBuf and schedule Comm::Read()
     void readSomeData();
 
     /**
      * called when new request data has been read from the socket
      *
      * \retval false called comm_close or setReplyToError (the caller should bail)
      * \retval true  we did not call comm_close or setReplyToError
      */
     virtual bool handleReadData() = 0;
 
     /// whether Comm::Read() is scheduled
     bool reading() const {return reader != NULL;}
 
@@ -79,30 +77,33 @@
     bool maybeMakeSpaceAvailable();
 
     // Client TCP connection details from comm layer.
     Comm::ConnectionPointer clientConnection;
 
     /**
      * The transfer protocol currently being spoken on this connection.
      * HTTP/1.x CONNECT, HTTP/1.1 Upgrade and HTTP/2 SETTINGS offer the
      * ability to change protocols on the fly.
      */
     AnyP::ProtocolVersion transferProtocol;
 
     /// Squid listening port details where this connection arrived.
     AnyP::PortCfgPointer port;
 
     /// read I/O buffer for the client connection
     SBuf inBuf;
 
     bool receivedFirstByte_; ///&lt; true if at least one byte received on this connection
 
+    /// set of requests waiting to be serviced
+    Pipeline pipeline;
+
 protected:
     void doClientRead(const CommIoCbParams &amp;io);
     void clientWriteDone(const CommIoCbParams &amp;io);
 
     AsyncCall::Pointer reader; ///&lt; set when we are reading
     AsyncCall::Pointer writer; ///&lt; set when we are writing
 };
 
 #endif /* SQUID_SERVERS_SERVER_H */
 

=== modified file 'src/stat.cc'
--- src/stat.cc	2015-11-07 12:08:33 +0000
+++ src/stat.cc	2015-11-15 09:01:18 +0000
@@ -1845,42 +1845,41 @@
     char buf[MAX_IPSTRLEN];
 
     for (i = ClientActiveRequests.head; i; i = i-&gt;next) {
         const char *p = NULL;
         http = static_cast&lt;ClientHttpRequest *&gt;(i-&gt;data);
         assert(http);
         ConnStateData * conn = http-&gt;getConn();
         storeAppendPrintf(s, &quot;Connection: %p\n&quot;, conn);
 
         if (conn != NULL) {
             const int fd = conn-&gt;clientConnection-&gt;fd;
             storeAppendPrintf(s, &quot;\tFD %d, read %&quot; PRId64 &quot;, wrote %&quot; PRId64 &quot;\n&quot;, fd,
                               fd_table[fd].bytes_read, fd_table[fd].bytes_written);
             storeAppendPrintf(s, &quot;\tFD desc: %s\n&quot;, fd_table[fd].desc);
             storeAppendPrintf(s, &quot;\tin: buf %p, used %ld, free %ld\n&quot;,
                               conn-&gt;inBuf.rawContent(), (long int) conn-&gt;inBuf.length(), (long int) conn-&gt;inBuf.spaceSize());
             storeAppendPrintf(s, &quot;\tremote: %s\n&quot;,
                               conn-&gt;clientConnection-&gt;remote.toUrl(buf,MAX_IPSTRLEN));
             storeAppendPrintf(s, &quot;\tlocal: %s\n&quot;,
                               conn-&gt;clientConnection-&gt;local.toUrl(buf,MAX_IPSTRLEN));
-            storeAppendPrintf(s, &quot;\tnrequests: %d\n&quot;,
-                              conn-&gt;nrequests);
+            storeAppendPrintf(s, &quot;\tnrequests: %u\n&quot;, conn-&gt;pipeline.nrequests);
         }
 
         storeAppendPrintf(s, &quot;uri %s\n&quot;, http-&gt;uri);
         storeAppendPrintf(s, &quot;logType %s\n&quot;, http-&gt;logType.c_str());
         storeAppendPrintf(s, &quot;out.offset %ld, out.size %lu\n&quot;,
                           (long int) http-&gt;out.offset, (unsigned long int) http-&gt;out.size);
         storeAppendPrintf(s, &quot;req_sz %ld\n&quot;, (long int) http-&gt;req_sz);
         e = http-&gt;storeEntry();
         storeAppendPrintf(s, &quot;entry %p/%s\n&quot;, e, e ? e-&gt;getMD5Text() : &quot;N/A&quot;);
         storeAppendPrintf(s, &quot;start %ld.%06d (%f seconds ago)\n&quot;,
                           (long int) http-&gt;al-&gt;cache.start_time.tv_sec,
                           (int) http-&gt;al-&gt;cache.start_time.tv_usec,
                           tvSubDsec(http-&gt;al-&gt;cache.start_time, current_time));
 #if USE_AUTH
         if (http-&gt;request-&gt;auth_user_request != NULL)
             p = http-&gt;request-&gt;auth_user_request-&gt;username();
         else
 #endif
             if (http-&gt;request-&gt;extacl_user.size() &gt; 0) {
                 p = http-&gt;request-&gt;extacl_user.termedBuf();

=== modified file 'src/tests/stub_client_side.cc'
--- src/tests/stub_client_side.cc	2015-11-07 12:08:33 +0000
+++ src/tests/stub_client_side.cc	2015-11-17 03:30:09 +0000
@@ -1,66 +1,60 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;client_side.h&quot;
 
 #define STUB_API &quot;client_side.cc&quot;
 #include &quot;tests/STUB.h&quot;
 
 //ClientSocketContext::ClientSocketContext(const ConnectionPointer&amp;, ClientHttpRequest*) STUB
 //ClientSocketContext::~ClientSocketContext() STUB
 bool ClientSocketContext::startOfOutput() const STUB_RETVAL(false)
 void ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag) STUB
-void ClientSocketContext::keepaliveNextRequest() STUB
 void ClientSocketContext::pullData() STUB
 int64_t ClientSocketContext::getNextRangeOffset() const STUB_RETVAL(0)
 bool ClientSocketContext::canPackMoreRanges() const STUB_RETVAL(false)
 clientStream_status_t ClientSocketContext::socketState() STUB_RETVAL(STREAM_NONE)
 void ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData) STUB
 void ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData) STUB
 size_t ClientSocketContext::lengthToSend(Range&lt;int64_t&gt; const &amp;available) STUB_RETVAL(0)
 void ClientSocketContext::noteSentBodyBytes(size_t) STUB
 void ClientSocketContext::buildRangeHeader(HttpReply * rep) STUB
 clientStreamNode * ClientSocketContext::getTail() const STUB_RETVAL(NULL)
 clientStreamNode * ClientSocketContext::getClientReplyContext() const STUB_RETVAL(NULL)
-void ClientSocketContext::connIsFinished() STUB
-void ClientSocketContext::removeFromConnectionList(ConnStateData * conn) STUB
+void ClientSocketContext::finished() STUB
 void ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData) STUB
 bool ClientSocketContext::multipartRangeRequest() const STUB_RETVAL(false)
 void ClientSocketContext::registerWithConn() STUB
 void ClientSocketContext::noteIoError(const int xerrno) STUB
 void ClientSocketContext::writeControlMsg(HttpControlMsg &amp;msg) STUB
 
-bool ConnStateData::areAllContextsForThisConnection() const STUB_RETVAL(false)
-void ConnStateData::freeAllContexts() STUB
-void ConnStateData::notifyAllContexts(const int xerrno) STUB
 bool ConnStateData::clientParseRequests() STUB_RETVAL(false)
 void ConnStateData::readNextRequest() STUB
-void ConnStateData::addContextToQueue(ClientSocketContext * context) STUB
-int ConnStateData::getConcurrentRequestCount() const STUB_RETVAL(0)
 bool ConnStateData::isOpen() const STUB_RETVAL(false)
+void ConnStateData::kick() STUB
 void ConnStateData::sendControlMsg(HttpControlMsg msg) STUB
 int64_t ConnStateData::mayNeedToReadMoreBody() const STUB_RETVAL(0)
 #if USE_AUTH
 void ConnStateData::setAuth(const Auth::UserRequest::Pointer &amp;aur, const char *cause) STUB
 #endif
 bool ConnStateData::transparent() const STUB_RETVAL(false)
 void ConnStateData::stopReceiving(const char *error) STUB
 void ConnStateData::stopSending(const char *error) STUB
 void ConnStateData::expectNoForwarding() STUB
 void ConnStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer) STUB
 void ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer) STUB
 bool ConnStateData::handleReadData() STUB_RETVAL(false)
 bool ConnStateData::handleRequestBodyData() STUB_RETVAL(false)
 void ConnStateData::pinConnection(const Comm::ConnectionPointer &amp;pinServerConn, HttpRequest *request, CachePeer *peer, bool auth, bool monitor) STUB
 void ConnStateData::unpinConnection(const bool andClose) STUB
 const Comm::ConnectionPointer ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *peer) STUB_RETVAL(NULL)
 void ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &amp;io) STUB
 void ConnStateData::connStateClosed(const CommCloseCbParams &amp;io) STUB
 void ConnStateData::requestTimeout(const CommTimeoutCbParams &amp;params) STUB
 void ConnStateData::swanSong() STUB

=== modified file 'src/tunnel.cc'
--- src/tunnel.cc	2015-11-09 21:38:44 +0000
+++ src/tunnel.cc	2015-11-17 10:06:53 +0000
@@ -225,59 +225,67 @@
 static CLCB tunnelClientClosed;
 static CTCB tunnelTimeout;
 static PSC tunnelPeerSelectComplete;
 static EVH tunnelDelayedClientRead;
 static EVH tunnelDelayedServerRead;
 static void tunnelConnected(const Comm::ConnectionPointer &amp;server, void *);
 static void tunnelRelayConnectRequest(const Comm::ConnectionPointer &amp;server, void *);
 
 static void
 tunnelServerClosed(const CommCloseCbParams &amp;params)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)params.data;
     debugs(26, 3, HERE &lt;&lt; tunnelState-&gt;server.conn);
     tunnelState-&gt;server.conn = NULL;
     tunnelState-&gt;server.writer = NULL;
 
     if (tunnelState-&gt;request != NULL)
         tunnelState-&gt;request-&gt;hier.stopPeerClock(false);
 
     if (tunnelState-&gt;noConnections()) {
+        // ConnStateData pipeline should contain the CONNECT we are performing
+        auto ctx = tunnelState-&gt;http-&gt;getConn()-&gt;pipeline.front();
+        if (ctx != nullptr)
+            ctx-&gt;finished();
         delete tunnelState;
         return;
     }
 
     if (!tunnelState-&gt;client.writer) {
         tunnelState-&gt;client.conn-&gt;close();
         return;
     }
 }
 
 static void
 tunnelClientClosed(const CommCloseCbParams &amp;params)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)params.data;
     debugs(26, 3, HERE &lt;&lt; tunnelState-&gt;client.conn);
     tunnelState-&gt;client.conn = NULL;
     tunnelState-&gt;client.writer = NULL;
 
     if (tunnelState-&gt;noConnections()) {
+        // ConnStateData pipeline should contain the CONNECT we are performing
+        auto ctx = tunnelState-&gt;http-&gt;getConn()-&gt;pipeline.front();
+        if (ctx != nullptr)
+            ctx-&gt;finished();
         delete tunnelState;
         return;
     }
 
     if (!tunnelState-&gt;server.writer) {
         tunnelState-&gt;server.conn-&gt;close();
         return;
     }
 }
 
 TunnelStateData::TunnelStateData() :
     url(NULL),
     http(),
     request(NULL),
     status_ptr(NULL),
     logTag_ptr(NULL),
     connectRespBuf(NULL),
     connectReqWriting(false),
     started(squid_curtime)
 {
@@ -1216,42 +1224,42 @@
     /* Create state structure. */
     TunnelStateData *tunnelState = NULL;
     const SBuf url(request-&gt;effectiveRequestUri());
 
     debugs(26, 3, request-&gt;method &lt;&lt; &quot; &quot; &lt;&lt; url &lt;&lt; &quot; &quot; &lt;&lt; request-&gt;http_ver);
     ++statCounter.server.all.requests;
     ++statCounter.server.other.requests;
 
     tunnelState = new TunnelStateData;
     tunnelState-&gt;url = SBufToCstring(url);
     tunnelState-&gt;request = request;
     tunnelState-&gt;server.size_ptr = NULL; //Set later if ClientSocketContext is available
 
     // Temporary static variable to store the unneeded for our case status code
     static int status_code = 0;
     tunnelState-&gt;status_ptr = &amp;status_code;
     tunnelState-&gt;client.conn = clientConn;
 
     ConnStateData *conn;
     if ((conn = request-&gt;clientConnectionManager.get())) {
-        ClientSocketContext::Pointer context = conn-&gt;getCurrentContext();
-        if (context != NULL &amp;&amp; context-&gt;http != NULL) {
+        ClientSocketContext::Pointer context = conn-&gt;pipeline.front());
+        if (context != nullptr &amp;&amp; context-&gt;http != nullptr) {
             tunnelState-&gt;logTag_ptr = &amp;context-&gt;http-&gt;logType;
             tunnelState-&gt;server.size_ptr = &amp;context-&gt;http-&gt;out.size;
 
 #if USE_DELAY_POOLS
             /* no point using the delayIsNoDelay stuff since tunnel is nice and simple */
             if (srvConn-&gt;getPeer() &amp;&amp; srvConn-&gt;getPeer()-&gt;options.no_delay)
                 tunnelState-&gt;server.setDelayId(DelayId::DelayClient(context-&gt;http));
 #endif
         }
     }
 
     comm_add_close_handler(tunnelState-&gt;client.conn-&gt;fd,
                            tunnelClientClosed,
                            tunnelState);
 
     AsyncCall::Pointer timeoutCall = commCbCall(5, 4, &quot;tunnelTimeout&quot;,
                                      CommTimeoutCbPtrFun(tunnelTimeout, tunnelState));
     commSetConnTimeout(tunnelState-&gt;client.conn, Config.Timeout.lifetime, timeoutCall);
     fd_table[clientConn-&gt;fd].read_method = &amp;default_read_method;
     fd_table[clientConn-&gt;fd].write_method = &amp;default_write_method;

</PRE>

















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003759.html">[squid-dev] Jenkins build is back to normal : trunk-full-matrix Â» gcc,d-debian-unstable #46
</A></li>
	<LI>Next message: <A HREF="003916.html">[squid-dev] [PATCH] refactor ConnStateData pipeline handling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3764">[ date ]</a>
              <a href="thread.html#3764">[ thread ]</a>
              <a href="subject.html#3764">[ subject ]</a>
              <a href="author.html#3764">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
