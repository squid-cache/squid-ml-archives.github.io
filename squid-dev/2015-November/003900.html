<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] on_unsupported_protocol doesn't work for bumped https connecttions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20on_unsupported_protocol%20doesn%27t%20work%20for%20bumped%0A%20https%20connecttions&In-Reply-To=%3C564F4203.2060001%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003899.html">
   <LINK REL="Next"  HREF="003902.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] on_unsupported_protocol doesn't work for bumped https connecttions</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20on_unsupported_protocol%20doesn%27t%20work%20for%20bumped%0A%20https%20connecttions&In-Reply-To=%3C564F4203.2060001%40measurement-factory.com%3E"
       TITLE="[squid-dev] on_unsupported_protocol doesn't work for bumped https connecttions">rousskov at measurement-factory.com
       </A><BR>
    <I>Fri Nov 20 15:53:39 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003899.html">[squid-dev] on_unsupported_protocol doesn't work for bumped https	connecttions
</A></li>
        <LI>Next message: <A HREF="003902.html">[squid-dev] Hello and ssl_bump and External ACLs - 4.0.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3900">[ date ]</a>
              <a href="thread.html#3900">[ thread ]</a>
              <a href="subject.html#3900">[ subject ]</a>
              <a href="author.html#3900">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/20/2015 06:55 AM, Tarik Demirci wrote:
&gt;<i> On Wed, Nov 18, 2015 at 5:55 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 11/18/2015 12:53 AM, Tarik Demirci wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I did more detailed tests for this case. Constructing a tcp-in-https
</I>&gt;&gt;&gt;<i> connection results with error ERR_PROTOCOL_UNKNOWN in spite of
</I>&gt;&gt;&gt;<i> &quot;on_unsupported_protocol tunnel all&quot; conf directive. Is this a Squid
</I>&gt;&gt;&gt;<i> bug? Doc for on_unsupported_protocol says it works for bumped tunnels
</I>&gt;&gt;&gt;<i> but I can't confirm this in any way.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I debugged the code and it fails in a check in clientTunnelOnError
</I>&gt;&gt;&gt;<i> function. By the time Squid understands it's not http inside https,
</I>&gt;&gt;&gt;<i> conn-&gt;nrequests value is 2. So conn-&gt;nrequests &lt;= 1 check fails.
</I>

&gt;&gt;<i> AFAICT, the intended goal of the nrequests check is to prevent switching
</I>&gt;&gt;<i> to tunnel mode after the tunnel has already been proven to carry a
</I>&gt;&gt;<i> &quot;supported&quot; protocol (i.e., HTTPS or HTTP).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I do not think that nrequests check is correct: The nrequests member is
</I>&gt;&gt;<i> incremented on every request, so it may be very large if a browser
</I>&gt;&gt;<i> switches to a tunnel after sending many regular requests:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   GET
</I>&gt;&gt;<i>   GET
</I>&gt;&gt;<i>   GET
</I>&gt;&gt;<i>   CONNECT
</I>

&gt;<i> In my situation it's something like this because of ssl bump:
</I>&gt;<i> 
</I>&gt;<i> CONNECT
</I>&gt;<i> GET (or unknown protocol)
</I>

&gt;&gt;<i> I also suspect the check is difficult to get right because fake CONNECTs
</I>&gt;&gt;<i> on intercepted connections and real CONNECTs on forwarded connections
</I>&gt;&gt;<i> might be counted differently. I did not verify that, but it may explain
</I>&gt;&gt;<i> why you are hitting this bug -- the code may have been tested with
</I>&gt;&gt;<i> intercepted connections only and just &quot;assumed&quot; to work for CONNECT
</I>&gt;&gt;<i> tunnels as well.
</I>&gt;<i> 
</I>&gt;<i> Does connect TUNNEL mean explicit proxy by client (client is proxy
</I>&gt;<i> aware)? 
</I>
In this context, yes.


&gt;<i> If yes, this is not my case. I test this situation for
</I>&gt;<i> intercepted connections on 443 (using iptables REDIRECT).
</I>
Noted.


&gt;&gt;<i> I recommend replacing nrequests check with a check based on a new
</I>&gt;&gt;<i> tooLateToTunnel boolean data member. That member can be initialized to
</I>&gt;&gt;<i> false and set to true after receiving valid HTTP request headers inside
</I>&gt;&gt;<i> an inspected connection (at least).
</I>

&gt;<i> I implemented your suggestion but failed. During ssl bump,
</I>&gt;<i> httpsSslBumpAccessCheckDone fires a fakeAConnectRequest. This CONNECT
</I>&gt;<i> request has an 'Host:' header. Therefore it makes tooLateToTunnel
</I>&gt;<i> value true which causes bypass to fail again.
</I>
The last part does not compute for me: Why would the Host header
presence be relevant to tooLateToTunnel? The code should not make
tooLateToTunnel true until it is really too late to tunnel. Dealing with
a [fake] CONNECT request does not mean it is too late to tunnel,
regardless of the Host header presence.

One of the difficulties you may face is that, on one hand,
tooLateToTunnel should remain false before the first CONNECT (fake or
real). The member should be set to true after receiving valid HTTP
request headers _inside_ an inspected connection. On the other hand, we
should _not_ start tunneling in this http_port situation either:

  GET
  GET
  GET
  non-HTTP-traffic

That means we may need to reset tooLateTooTunnel back to false when
dealing with a CONNECT request. The new member may need to be called
prohibitTunneling:


For http_port connection:

  prohibitTunneling = false
  accept
  successfully parsed first HTTP request
  prohibitTunneling = the request was not a CONNECT request
  ...
  real CONNECT
  bumping
  successfully parsed first inspected HTTP request
  prohibitTunneling = true


For intercepted https_port connections:

    prohibitTunneling = false
    accept
    fake CONNECT
    bumping
    successfully parsed first inspected HTTP request
    prohibitTunneling = true

The above sketch may not cover all situations, of course, but your code
should.


HTH,

Alex.

</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003899.html">[squid-dev] on_unsupported_protocol doesn't work for bumped https	connecttions
</A></li>
	<LI>Next message: <A HREF="003902.html">[squid-dev] Hello and ssl_bump and External ACLs - 4.0.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3900">[ date ]</a>
              <a href="thread.html#3900">[ thread ]</a>
              <a href="subject.html#3900">[ subject ]</a>
              <a href="author.html#3900">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
