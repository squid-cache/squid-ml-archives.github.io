From squid3 at treenet.co.nz  Thu Oct  1 01:20:36 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Thu, 1 Oct 2015 14:20:36 +1300
Subject: [squid-dev] [PATCH] Fix for bug 4190
In-Reply-To: <560B3D7E.2010500@treenet.co.nz>
References: <CA+Y8hcM8ne+WWmpc0SEzAydfWBtCT9vrfwhv2bH2Ys8p1matqA@mail.gmail.com>
 <55EBC3AE.5070905@measurement-factory.com> <55EC191E.9030501@treenet.co.nz>
 <55ED165D.9090102@measurement-factory.com> <56088231.1050903@treenet.co.nz>
 <560B3D7E.2010500@treenet.co.nz>
Message-ID: <560C8A64.4080507@treenet.co.nz>

Applied as rev.14335

Amos


From ealireza at gmail.com  Thu Oct  1 04:49:20 2015
From: ealireza at gmail.com (Alireza Asgari)
Date: Thu, 1 Oct 2015 08:19:20 +0330
Subject: [squid-dev] Compile Squid 4.x ubuntu 15 / ubuntu 14
Message-ID: <CAJ7N0V3qGBb5HX8vcyjQahmyo1tCq99tin=ugLgQ7gq4wjr95Q@mail.gmail.com>

i have problem with compiling squid

generaly i use
./boos....
./configure
make

but it fail
what wrong

-pipe -D_REENTRANT -g -O2 -march=native -std=c++11 -MT StoreSwapLogData.o
-MD -MP -MF $depbase.Tpo -c -o StoreSwapLogData.o StoreSwapLogData.cc &&\
mv -f $depbase.Tpo $depbase.Po
StoreSwapLogData.cc: In member function ‘std::ostream&
SwapChecksum24::print(std::ostream&) const’:
StoreSwapLogData.cc:47:15: error: no match for ‘operator<<’ (operand types
are ‘std::ostream {aka std::basic_ostream<char>}’ and ‘const uint8_t {aka
const unsigned char}’)
     return os << raw[0] << '-' << raw[1] << '-' << raw[2];
               ^
StoreSwapLogData.cc:47:15: note: candidate is:
In file included from StoreSwapLogData.cc:12:0:
StoreSwapLogData.h:70:1: note: std::ostream& operator<<(std::ostream&,
const SwapChecksum24&)
 operator <<(std::ostream &os, const SwapChecksum24 &sum)
 ^
StoreSwapLogData.h:70:1: note:   no known conversion for argument 2 from
‘const uint8_t {aka const unsigned char}’ to ‘const SwapChecksum24&’
StoreSwapLogData.cc:48:1: error: control reaches end of non-void function
[-Werror=return-type]
 }
 ^
At global scope:
cc1plus: error: unrecognized command line option "-Wno-deprecated-register"
[-Werror]
cc1plus: all warnings being treated as errors
Makefile:6823: recipe for target 'StoreSwapLogData.o' failed
make[3]: *** [StoreSwapLogData.o] Error 1
make[3]: Leaving directory '/root/squid-4.0.0-20150929-r14330/src'
Makefile:6945: recipe for target 'all-recursive' failed
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory '/root/squid-4.0.0-20150929-r14330/src'
Makefile:5974: recipe for target 'all' failed
make[1]: *** [all] Error 2
make[1]: Leaving directory '/root/squid-4.0.0-20150929-r14330/src'
Makefile:569: recipe for target 'all-recursive' failed
make: *** [all-recursive] Error 1
root at UK-CDN:~/squid-4.0.0-20150929-r14330#
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151001/bef612ec/attachment-0001.html>

From squid3 at treenet.co.nz  Thu Oct  1 09:57:08 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Thu, 1 Oct 2015 22:57:08 +1300
Subject: [squid-dev] Compile Squid 4.x ubuntu 15 / ubuntu 14
In-Reply-To: <CAJ7N0V3qGBb5HX8vcyjQahmyo1tCq99tin=ugLgQ7gq4wjr95Q@mail.gmail.com>
References: <CAJ7N0V3qGBb5HX8vcyjQahmyo1tCq99tin=ugLgQ7gq4wjr95Q@mail.gmail.com>
Message-ID: <560D0374.90004@treenet.co.nz>

On 1/10/2015 5:49 p.m., Alireza Asgari wrote:
> i have problem with compiling squid
> 
> generaly i use
> ./boos....
> ./configure
> make
> 
> but it fail
> what wrong
> 

Bug 4329. GCC 5.2 problems. I've just applied the fix to Squid-4 in
rev.14336

Amos


From noc at squid-cache.org  Thu Oct  1 10:45:14 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Thu, 1 Oct 2015 10:45:14 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #882
In-Reply-To: <968823735.427.1443655576376.JavaMail.jenkins@buildmaster>
References: <968823735.427.1443655576376.JavaMail.jenkins@buildmaster>
Message-ID: <1725577277.443.1443696314902.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/882/>


From gkinkie at gmail.com  Thu Oct  1 14:29:33 2015
From: gkinkie at gmail.com (Kinkie)
Date: Thu, 1 Oct 2015 16:29:33 +0200
Subject: [squid-dev] [PATCH] convert squidaio_ctrl_t to MEMPROXY_CLASS
Message-ID: <CA+Y8hcPtf2AiSbuffV2gjbP7TQQOfYh-Ox3yAcrP=TsvuJLuuA@mail.gmail.com>

Hi,
   the attached large-context patch converts squidaio_ctrl_t to MEMPROXY_CLASS.
It also:
- adds a tiny bit of documentation to some fields of squidaio_ctrl_t
- extends the MEMPROXY_CLASS API to expose the pool's use-count as a
static function
- fixes a tiny bit of documentation in aiops.cc
- fixes a bug in aioWrite [1]

[1] old code wouldn't set ctrlp->len; when free_func would eventually
be called, it'd happen with a length argument of 0 (default length
value). I'm quite surprised this hasn't caused havoc so far. New code
sets len. So either this fixes an issue, or it introduces one ;)


-- 
    Francesco
-------------- next part --------------
A non-text attachment was scrubbed...
Name: mempools-nozero-squidaio_ctrl_t-v1.patch
Type: text/x-diff
Size: 10294 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151001/bcda9901/attachment.patch>

From squid3 at treenet.co.nz  Thu Oct  1 15:39:12 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 2 Oct 2015 04:39:12 +1300
Subject: [squid-dev] [PATCH] convert squidaio_ctrl_t to MEMPROXY_CLASS
In-Reply-To: <CA+Y8hcPtf2AiSbuffV2gjbP7TQQOfYh-Ox3yAcrP=TsvuJLuuA@mail.gmail.com>
References: <CA+Y8hcPtf2AiSbuffV2gjbP7TQQOfYh-Ox3yAcrP=TsvuJLuuA@mail.gmail.com>
Message-ID: <560D53A0.3090903@treenet.co.nz>

On 2/10/2015 3:29 a.m., Kinkie wrote:
> Hi,
>    the attached large-context patch converts squidaio_ctrl_t to MEMPROXY_CLASS.
> It also:
> - adds a tiny bit of documentation to some fields of squidaio_ctrl_t
> - extends the MEMPROXY_CLASS API to expose the pool's use-count as a
> static function
> - fixes a tiny bit of documentation in aiops.cc
> - fixes a bug in aioWrite [1]
> 
> [1] old code wouldn't set ctrlp->len; when free_func would eventually
> be called, it'd happen with a length argument of 0 (default length
> value). I'm quite surprised this hasn't caused havoc so far. New code
> sets len. So either this fixes an issue, or it introduces one ;)
> 

That sounds like the freeFunc do not use len. Maybe its another bit of
dead code left over from Squid-2 logics?


in src/DiskIO/DiskThreads/DiskThreads.h:
* please reduce the 2 spaces before some "= delete;"
 - also are these default & copy ctor and copy-assign removals actually
needed since there is a ctor with parameters defined?

* "struct squidaio_ctrl_t *next;" is now wrong for a non-struct
 - maybe other uses of "struct squidaio_ctrl_t"


in src/DiskIO/DiskThreads/aiops.cc:

* since the name length of the parameters is causing line wrap, the
answer is to shorten the parameter names.
 - consider abbreviations
 - please use one member per line on the initializer list


in src/DiskIO/DiskThreads/async_io.cc:

* please merge+sort mem/Pool.h into the include list

* please move the "squidaio_ctrl_t *ctrlp;" down to their relevant
position of first use. I can see at least one defined a couple of lines
above the 'ctrlp = new ...' .


Amos


From squid3 at treenet.co.nz  Thu Oct  1 16:37:45 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 2 Oct 2015 05:37:45 +1300
Subject: [squid-dev] FYI: RFC 2617 ("HTTP Authentication: Basic and Digest
 Access Authentication") is obsolete
In-Reply-To: <560D329A.3080906@gmx.de>
References: <560D329A.3080906@gmx.de>
Message-ID: <560D6159.70501@treenet.co.nz>

For those interested. HTTP authentication Basic and Digest schemes have
been updated.


On 2/10/2015 2:18 a.m., Julian Reschke wrote:
> Hi there.
> 
> RFC 2617 ("HTTP Authentication: Basic and Digest Access Authentication")
> has finally been obsoleted.
> 
> It has been superseded by a document set consisting of:
> 
> RFC 7235: Hypertext Transfer Protocol (HTTP/1.1): Authentication
> (defining the authentication framework, published last year),
> 
> RFC 7615: HTTP Authentication-Info and Proxy-Authentication-Info
> Response Header Fields (defining just two optional header fields),
> 
> RFC 7616: HTTP Digest Access Authentication, and
> 
> RFC 7617: The 'Basic' HTTP Authentication Scheme.
> 
> The two latter documents have been developed in the HTTPAUTH working group.
> 
> Best regards, Julian
> 
> PS1: We failed to make the document titles for Basic and Digest
> consistent. Sorry.
> 
> PS2: RFC 7615 is of course a candidate for inclusion into RFC 7235bis.
> 



From noc at squid-cache.org  Fri Oct  2 00:16:17 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 2 Oct 2015 00:16:17 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #883
Message-ID: <668205167.455.1443744977542.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/883/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 378
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14340 squid3 at treenet.co.nz-20151001123509-fi7ue52u2vpmyeeh
" stderr: ""
RevisionState revno:14340 revid:squid3 at treenet.co.nz-20151001123509-fi7ue52u2vpmyeeh
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson3066097219175394140.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 883 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From noc at squid-cache.org  Fri Oct  2 10:29:29 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 2 Oct 2015 10:29:29 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #884
In-Reply-To: <668205167.455.1443744977542.JavaMail.jenkins@buildmaster>
References: <668205167.455.1443744977542.JavaMail.jenkins@buildmaster>
Message-ID: <1598861939.466.1443781769651.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/884/>


From squid3 at treenet.co.nz  Sat Oct  3 08:35:07 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Sat, 3 Oct 2015 21:35:07 +1300
Subject: [squid-dev] [PATCH] external_acl_type logformat tokens
Message-ID: <560F933B.8040804@treenet.co.nz>

Update the external_acl_type helper interface to use libformat and thus
make any logformat token valid in its format parameter field.

As a result much of the logic surrounding format code parsing, display
and helper query generation has been completely dropped. What remains is
a basic parse loop handling backward compatibility for the unusual
%CERT_* token syntax, space delimiter and field default encodings.


Extensions to logformat resulting from the merger:

* adds \-escape encoding of output fields

* allows {arg} field to be placed before or after the format code.

* extended to accept the old external_acl_type %macros. But not
documented, these are deprecated and only for backward compatibility.

* extended to support outputting formats without a format-name prefix.


The major side effect of this change is that these ACLs now require
AccessLogEntry to be filled out with state data, rather than just the
ACLChecklist object members.

The requires*() mechanism of ACLChecklist has been extended to catch
some cases resulting from missing the ALE entirely. But it cannot catch
the more subtle problem of data members inside the ALE being unset.


I have given it some basic testing and the commonly used %macros work
fine for the common use cases. So I believe it is suitable for inclusion
into trunk. But this definitely needs wider testing to catch uncommon
and rare edge cases where the ALE object is not filled out early enough,
or not presented by the checklist.

Amos
-------------- next part --------------
=== modified file 'src/AccessLogEntry.h'
--- src/AccessLogEntry.h	2015-09-14 16:25:05 +0000
+++ src/AccessLogEntry.h	2015-10-02 10:25:46 +0000
@@ -186,43 +186,50 @@
     /** \brief This subclass holds general adaptation log info.
      * \todo Inner class declarations should be moved outside.
      */
     class AdaptationDetails
     {
 
     public:
         AdaptationDetails(): last_meta(NULL) {}
 
         /// image of the last ICAP response header or eCAP meta received
         char *last_meta;
     } adapt;
 #endif
 
     // Why is this a sub-class and not a set of real "private:" fields?
     // TODO: shuffle this to the relevant ICP/HTCP protocol section
     class Private
     {
 
     public:
-        Private() : method_str(NULL) {}
+        Private() : method_str(NULL), lastAclName(NULL), lastAclData(NULL) {}
+        ~Private() {
+            safe_free(lastAclName);
+            safe_free(lastAclData);
+        }
 
         const char *method_str;
+        const char *lastAclName; ///< string for external_acl_type %ACL format code
+        const char *lastAclData; ///< string for external_acl_type %DATA format code
+
     } _private;
     HierarchyLogEntry hier;
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
     /// key:value pairs set by squid.conf note directive and
     /// key=value pairs returned from URL rewrite/redirect helper
     NotePairs::Pointer notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
      *  \todo Inner class declarations should be moved outside
      */
     class IcapLogEntry
     {
     public:
         IcapLogEntry() : reqMethod(Adaptation::methodNone), bytesSent(0), bytesRead(0),
             bodyBytesRead(-1), request(NULL), reply(NULL),
             outcome(Adaptation::Icap::xoUnknown), resStatus(Http::scNone)

=== modified file 'src/ExternalACL.h'
--- src/ExternalACL.h	2015-02-04 16:45:30 +0000
+++ src/ExternalACL.h	2015-05-29 10:33:44 +0000
@@ -34,40 +34,41 @@
 
 #include "acl/Acl.h"
 
 class ACLExternal : public ACL
 {
     MEMPROXY_CLASS(ACLExternal);
 
 public:
     static void ExternalAclLookup(ACLChecklist * ch, ACLExternal *);
 
     ACLExternal(char const *);
     ACLExternal(ACLExternal const &);
     ~ACLExternal();
     ACLExternal&operator=(ACLExternal const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     /* This really should be dynamic based on the external class defn */
+    virtual bool requiresAleXXX() const {return true;}
     virtual bool requiresRequest() const {return true;}
 
     /* when requiresRequest is made dynamic, review this too */
     //    virtual bool requiresReply() const {return true;}
     virtual bool isProxyAuth() const;
     virtual SBufList dump() const;
     virtual bool valid () const;
     virtual bool empty () const;
 
 protected:
     static Prototype RegistryProtoype;
     static ACLExternal RegistryEntry_;
     external_acl_data *data;
     char const *class_;
 };
 
 void parse_externalAclHelper(external_acl **);
 void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 void free_externalAclHelper(external_acl **);
 typedef void EAH(void *data, const ExternalACLEntryPointer &result);

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-09-25 10:12:56 +0000
+++ src/Makefile.am	2015-09-28 00:41:05 +0000
@@ -3445,40 +3445,41 @@
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
+	tests/stub_libeui.cc \
 	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	pconn.cc \

=== modified file 'src/acl/Acl.cc'
--- src/acl/Acl.cc	2015-08-24 14:20:07 +0000
+++ src/acl/Acl.cc	2015-09-30 09:36:05 +0000
@@ -136,41 +136,44 @@
     *name = 0;
 }
 
 bool ACL::valid () const
 {
     return true;
 }
 
 bool
 ACL::matches(ACLChecklist *checklist) const
 {
     PROF_start(ACL_matches);
     debugs(28, 5, "checking " << name);
 
     // XXX: AclMatchedName does not contain a matched ACL name when the acl
     // does not match. It contains the last (usually leaf) ACL name checked
     // (or is NULL if no ACLs were checked).
     AclMatchedName = name;
 
     int result = 0;
-    if (!checklist->hasRequest() && requiresRequest()) {
+    if (!checklist->hasAleXXX() && requiresAleXXX()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an ALE state. Assuming mismatch.");
+    } else if (!checklist->hasRequest() && requiresRequest()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP request. Assuming mismatch.");
     } else if (!checklist->hasReply() && requiresReply()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP response. Assuming mismatch.");
     } else {
         // have to cast because old match() API is missing const
         result = const_cast<ACL*>(this)->match(checklist);
     }
 
     const char *extra = checklist->asyncInProgress() ? " async" : "";
     debugs(28, 3, "checked: " << name << " = " << result << extra);
     PROF_stop(ACL_matches);
     return result == 1; // true for match; false for everything else
 }
 
 void
 ACL::context(const char *aName, const char *aCfgLine)
 {
     name[0] = '\0';
@@ -351,40 +354,46 @@
 
 void
 aclCacheMatchFlush(dlink_list * cache)
 {
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link, *tmplink;
     link = cache->head;
 
     debugs(28, 8, "aclCacheMatchFlush called for cache " << cache);
 
     while (link) {
         auth_match = (acl_proxy_auth_match_cache *)link->data;
         tmplink = link;
         link = link->next;
         dlinkDelete(tmplink, cache);
         delete auth_match;
     }
 }
 
 bool
+ACL::requiresAleXXX() const
+{
+    return false;
+}
+
+bool
 ACL::requiresReply() const
 {
     return false;
 }
 
 bool
 ACL::requiresRequest() const
 {
     return false;
 }
 
 /*********************/
 /* Destroy functions */
 /*********************/
 
 ACL::~ACL()
 {
     debugs(28, 3, "freeing ACL " << name);
     safe_free(cfgline);
     AclMatchedName = NULL; // in case it was pointing to our name

=== modified file 'src/acl/Acl.h'
--- src/acl/Acl.h	2015-08-24 14:20:07 +0000
+++ src/acl/Acl.h	2015-09-28 00:41:05 +0000
@@ -124,40 +124,42 @@
         ~Prototype();
         static bool Registered(char const *);
         static ACL *Factory(char const *);
 
     private:
         ACL const *prototype;
         char const *typeString;
 
     private:
         static std::vector<Prototype const *> * Registry;
         static void *Initialized;
         typedef std::vector<Prototype const*>::iterator iterator;
         typedef std::vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
 
 private:
     /// Matches the actual data in checklist against this ACL.
     virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
 
+    /// whether our (i.e. shallow) match() requires checklist to have a AccessLogEntry
+    virtual bool requiresAleXXX() const;
     /// whether our (i.e. shallow) match() requires checklist to have a request
     virtual bool requiresRequest() const;
     /// whether our (i.e. shallow) match() requires checklist to have a reply
     virtual bool requiresReply() const;
 };
 
 /// \ingroup ACLAPI
 typedef enum {
     // Authorization ACL result states
     ACCESS_DENIED,
     ACCESS_ALLOWED,
     ACCESS_DUNNO,
 
     // Authentication ACL result states
     ACCESS_AUTH_REQUIRED,    // Missing Credentials
 } aclMatchCode;
 
 /// \ingroup ACLAPI
 /// ACL check answer; TODO: Rename to Acl::Answer
 class allow_t

=== modified file 'src/acl/Checklist.h'
--- src/acl/Checklist.h	2015-08-30 20:36:48 +0000
+++ src/acl/Checklist.h	2015-09-28 00:41:05 +0000
@@ -146,40 +146,41 @@
     /// whether markFinished() was called
     bool finished() const { return finished_; }
     /// async call has been started and has not finished (or failed) yet
     bool asyncInProgress() const { return asyncStage_ != asyncNone; }
     /// called when no more ACLs should be checked; sets the final answer and
     /// prints a debugging message explaining the reason for that answer
     void markFinished(const allow_t &newAnswer, const char *reason);
 
     const allow_t &currentAnswer() const { return allow_; }
 
     /// whether the action is banned or not
     bool bannedAction(const allow_t &action) const;
     /// add action to the list of banned actions
     void banAction(const allow_t &action);
 
     // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
     // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
     virtual bool hasRequest() const = 0;
     virtual bool hasReply() const = 0;
+    virtual bool hasAleXXX() const = 0;
 
     /// change the current ACL list
     /// \return a pointer to the old list value (may be nullptr)
     const Acl::Tree *changeAcl(const Acl::Tree *t) {
         const Acl::Tree *old = accessList;
         if (t != accessList) {
             cbdataReferenceDone(accessList);
             accessList = cbdataReference(t);
         }
         return old;
     }
 
 private:
     /// Calls non-blocking check callback with the answer and destroys self.
     void checkCallback(allow_t answer);
 
     void matchAndFinish();
 
     void changeState(AsyncState *);
     AsyncState *asyncState() const;

=== modified file 'src/acl/FilledChecklist.h'
--- src/acl/FilledChecklist.h	2015-09-14 16:25:05 +0000
+++ src/acl/FilledChecklist.h	2015-09-28 00:41:05 +0000
@@ -45,67 +45,68 @@
     ConnStateData * conn() const;
 
     /// The client side fd. It uses conn() if available
     int fd() const;
 
     /// set either conn
     void conn(ConnStateData *);
     /// set the client side FD
     void fd(int aDescriptor);
 
     //int authenticated();
 
     bool destinationDomainChecked() const;
     void markDestinationDomainChecked();
     bool sourceDomainChecked() const;
     void markSourceDomainChecked();
 
     // ACLChecklist API
     virtual bool hasRequest() const { return request != NULL; }
     virtual bool hasReply() const { return reply != NULL; }
+    virtual bool hasAleXXX() const { return al != NULL; }
 
 public:
     Ip::Address src_addr;
     Ip::Address dst_addr;
     Ip::Address my_addr;
     SBuf dst_peer_name;
     char *dst_rdns;
 
     HttpRequest *request;
     HttpReply *reply;
 
     char rfc931[USER_IDENT_SZ];
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
 #if SQUID_SNMP
     char *snmp_community;
 #endif
 
 #if USE_OPENSSL
     /// SSL [certificate validation] errors, in undefined order
     Ssl::CertErrors *sslErrors;
     /// The peer certificate
     Security::CertPointer serverCert;
 #endif
 
-    AccessLogEntry::Pointer al; ///< info for the future access.log entry
+    AccessLogEntry::Pointer al; ///< info for the future access.log, and external ACL
 
     ExternalACLEntryPointer extacl_entry;
 
     err_type requestErrorType;
 
 private:
     ConnStateData * conn_;          /**< hack for ident and NTLM */
     int fd_;                        /**< may be available when conn_ is not */
     bool destinationDomainChecked_;
     bool sourceDomainChecked_;
     /// not implemented; will cause link failures if used
     ACLFilledChecklist(const ACLFilledChecklist &);
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
 inline
 ACLFilledChecklist *Filled(ACLChecklist *checklist)
 {

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-08-30 01:07:47 +0000
+++ src/cf.data.pre	2015-10-02 10:15:34 +0000
@@ -700,141 +700,111 @@
 DOC_END
 
 COMMENT_START
  ACCESS CONTROLS
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: external_acl_type
 TYPE: externalAclHelper
 LOC: Config.externalAclHelperList
 DEFAULT: none
 DOC_START
 	This option defines external acl classes using a helper program
 	to look up the status
 
 	  external_acl_type name [options] FORMAT.. /path/to/helper [helper arguments..]
 
 	Options:
 
 	  ttl=n		TTL in seconds for cached results (defaults to 3600
-	  		for 1 hour)
+			for 1 hour)
 
 	  negative_ttl=n
-	  		TTL for cached negative lookups (default same
-	  		as ttl)
+			TTL for cached negative lookups (default same
+			as ttl)
 
 	  grace=n	Percentage remaining of TTL where a refresh of a
 			cached entry should be initiated without needing to
 			wait for a new reply. (default is for no grace period)
 
 	  cache=n	Limit the result cache size, default is 262144.
 			The expanded FORMAT value is used as the cache key, so
 			if the details in FORMAT are highly variable a larger
 			cache may be needed to produce reduction in helper load.
 
 	  children-max=n
 			Maximum number of acl helper processes spawned to service
 			external acl lookups of this type. (default 20)
 
 	  children-startup=n
 			Minimum number of acl helper processes to spawn during
 			startup and reconfigure to service external acl lookups
 			of this type. (default 0)
 
 	  children-idle=n
 			Number of acl helper processes to keep ahead of traffic
 			loads. Squid will spawn this many at once whenever load
 			rises above the capabilities of existing processes.
 			Up to the value of children-max. (default 1)
 
 	  concurrency=n	concurrency level per process. Only used with helpers
 			capable of processing more than one query at a time.
 
 	  queue-size=N  The queue-size= option sets the maximum number of queued
 			requests. If the queued requests exceed queue size 
 			the acl is ignored.
 			The default value is set to 2*children-max.
 
 	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers.
 
 	  ipv4 / ipv6	IP protocol used to communicate with this helper.
 			The default is to auto-detect IPv6 and use it when available.
 
 
-	FORMAT specifications
+	FORMAT is a series of %macro codes. See logformat directive for a full list
+	of the accepted codes. Although note that at the time of any external ACL
+	being tested data may not be available and thus some %macro expand to '-'.
 
-	  %LOGIN	Authenticated user login name
-	  %un		A user name. Expands to the first available name
-	  		from the following list of information sources:
-			- authenticated user name, like %ul or %LOGIN
-			- user name sent by an external ACL, like %EXT_USER
-			- SSL client name, like %us in logformat
-			- ident user name, like %ui in logformat
-	  %EXT_USER	Username from previous external acl
-	  %EXT_LOG	Log details from previous external acl
-	  %EXT_TAG	Tag from previous external acl
-	  %IDENT	Ident user name
-	  %SRC		Client IP
-	  %SRCPORT	Client source port
-	  %URI		Requested URI
-	  %DST		Requested host
-	  %PROTO	Requested URL scheme
-	  %PORT		Requested port
-	  %PATH		Requested URL path
-	  %METHOD	Request method
-	  %MYADDR	Squid interface address
-	  %MYPORT	Squid http_port number
-	  %PATH		Requested URL-path (including query-string if any)
-	  %USER_CERT	SSL User certificate in PEM format
-	  %USER_CERTCHAIN SSL User certificate chain in PEM format
-	  %USER_CERT_xx	SSL User certificate subject attribute xx
-	  %USER_CA_CERT_xx SSL User certificate issuer attribute xx
-	  %ssl::>sni	SSL client SNI sent to Squid
-	  %ssl::<cert_subject SSL server certificate DN
-	  %ssl::<cert_issuer SSL server certificate issuer DN
-
-	  %>{Header}	HTTP request header "Header"
-	  %>{Hdr:member}
-	  		HTTP request header "Hdr" list member "member"
-	  %>{Hdr:;member}
-	  		HTTP request header list member using ; as
-	  		list separator. ; can be any non-alphanumeric
-			character.
-
-	  %<{Header}	HTTP reply header "Header"
-	  %<{Hdr:member}
-	  		HTTP reply header "Hdr" list member "member"
-	  %<{Hdr:;member}
-	  		HTTP reply header list member using ; as
-	  		list separator. ; can be any non-alphanumeric
-			character.
+	In addition to the logformat codes; when processing external ACLs these
+	additional macros are made available:
 
 	  %ACL		The name of the ACL being tested.
-	  %DATA		The ACL arguments. If not used then any arguments
-			is automatically added at the end of the line
-			sent to the helper.
-			NOTE: this will encode the arguments as one token,
-			whereas the default will pass each separately.
 
-	  %%		The percent sign. Useful for helpers which need
-			an unchanging input format.
+	  %DATA		The ACL arguments. If a logformat encoding modifier
+			is used it will encode the whole set of arguments
+			as a single token.
+
+			If not used; then any arguments are automatically
+			added at the end of the line sent to the helper
+			as separately URL-encoded fields.
+
+	If SSL is enabled, the following formating codes become available:
+
+	  %USER_CERT		SSL User certificate in PEM format
+	  %USER_CERTCHAIN	SSL User certificate chain in PEM format
+	  %USER_CERT_xx		SSL User certificate subject attribute xx
+	  %USER_CA_CERT_xx	SSL User certificate issuer attribute xx
+
+
+	NOTE: all other format codes accepted by older Squid versions
+		are deprecated.
 
 
 	General request syntax:
 
 	  [channel-ID] FORMAT-values [acl-values ...]
 
 
 	FORMAT-values consists of transaction details expanded with
 	whitespace separation per the config file FORMAT specification
 	using the FORMAT macros listed above.
 
 	acl-values consists of any string specified in the referencing
 	config 'acl ... external' line. see the "acl external" directive.
 
 	Request values sent to the helper are URL escaped to protect
 	each value in requests against whitespaces.
 
 	If using protocol=2.5 then the request sent to the helper is not
 	URL escaped to protect against whitespace.
 
@@ -868,43 +838,43 @@
 		An internal error occurred in the helper, preventing
 		a result being identified.
 
 	The meaning of 'a match' is determined by your squid.conf
 	access control configuration. See the Squid wiki for details.
 
 	Defined keywords:
 
 	  user=		The users name (login)
 
 	  password=	The users password (for login= cache_peer option)
 
 	  message=	Message describing the reason for this response.
 			Available as %o in error pages.
 			Useful on (ERR and BH results).
 
 	  tag=		Apply a tag to a request. Only sets a tag once,
 			does not alter existing tags.
 
 	  log=		String to be logged in access.log. Available as
-	  		%ea in logformat specifications.
+			%ea in logformat specifications.
 
-  	  clt_conn_tag= Associates a TAG with the client TCP connection.
+	  clt_conn_tag= Associates a TAG with the client TCP connection.
 			Please see url_rewrite_program related documentation
 			for this kv-pair.
 
 	Any keywords may be sent on any response whether OK, ERR or BH.
 
 	All response keyword values need to be a single token with URL
 	escaping, or enclosed in double quotes (") and escaped using \ on
 	any double quotes or \ characters within the value. The wrapping
 	double quotes are removed before the value is interpreted by Squid.
 	\r and \n are also replace by CR and LF.
 
 	Some example key values:
 
 		user=John%20Smith
 		user="John Smith"
 		user="J. \"Bob\" Smith"
 DOC_END
 
 NAME: acl
 TYPE: acl
@@ -4064,55 +4034,57 @@
 NAME: logformat
 TYPE: logformat
 LOC: Log::TheConfig
 DEFAULT: none
 DEFAULT_DOC: The format definitions squid, common, combined, referrer, useragent are built in.
 DOC_START
 	Usage:
 
 	logformat <name> <format specification>
 
 	Defines an access log format.
 
 	The <format specification> is a string with embedded % format codes
 
 	% format codes all follow the same basic structure where all but
 	the formatcode is optional. Output strings are automatically escaped
 	as required according to their context and the output format
 	modifiers are usually not needed, but can be specified if an explicit
 	output format is desired.
 
-		% ["|[|'|#] [-] [[0]width] [{argument}] formatcode
+		% ["|[|'|#|/] [-] [[0]width] [{arg}] formatcode [{arg}]
 
 		"	output in quoted string format
 		[	output in squid text log format as used by log_mime_hdrs
 		#	output in URL quoted format
+		/	output in shell \-escaped format
 		'	output as-is
 
 		-	left aligned
 
 		width	minimum and/or maximum field width:
 			    [width_min][.width_max]
 			When minimum starts with 0, the field is zero-padded.
 			String values exceeding maximum width are truncated.
 
-		{arg}	argument such as header name etc
+		{arg}	argument such as header name etc. This field may be
+			placed before or after the token, but not both at once.
 
 	Format codes:
 
 		%	a literal % character
 		sn	Unique sequence number per log line entry
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
 		note	The annotation specified by the argument. Also
 			logs the adaptation meta headers set by the
 			adaptation_meta configuration parameter.
 			If no argument given all annotations logged.
 			The argument may include a separator to use with
 			annotation values:
                             name[:separator]
 			By default, multiple note values are separated with ","
 			and multiple notes are separated with "\r\n".
 			When logging named notes with %{name}note, the
 			explicitly configured separator is used between note
 			values. When logging all notes with %note, the

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-09-25 05:07:55 +0000
+++ src/external_acl.cc	2015-10-02 10:13:22 +0000
@@ -1,41 +1,42 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 82    External ACL */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/FilledChecklist.h"
 #include "cache_cf.h"
 #include "client_side.h"
+#include "client_side_request.h"
 #include "comm/Connection.h"
 #include "ConfigParser.h"
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
 #include "fde.h"
-#include "format/ByteCode.h"
+#include "format/Token.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc1738.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "tools.h"
 #include "URL.h"
 #include "wordlist.h"
 #if USE_OPENSSL
 #include "ssl/ServerBump.h"
 #include "ssl/support.h"
 #endif
@@ -49,427 +50,301 @@
 #endif
 
 #ifndef DEFAULT_EXTERNAL_ACL_TTL
 #define DEFAULT_EXTERNAL_ACL_TTL 1 * 60 * 60
 #endif
 #ifndef DEFAULT_EXTERNAL_ACL_CHILDREN
 #define DEFAULT_EXTERNAL_ACL_CHILDREN 5
 #endif
 
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static void external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry);
 static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
 
 /******************************************************************
  * external_acl directive
  */
 
-class external_acl_format : public RefCountable
-{
-    MEMPROXY_CLASS(external_acl_format);
-
-public:
-    typedef RefCount<external_acl_format> Pointer;
-
-    external_acl_format() :
-        type(Format::LFT_NONE),
-        header(nullptr),
-        member(nullptr),
-        separator(' '),
-        header_id(Http::HdrType::BAD_HDR)
-    {}
-    ~external_acl_format() {
-        xfree(header);
-        xfree(member);
-    }
-
-    Format::ByteCode_t type;
-    external_acl_format::Pointer next;
-    char *header;
-    char *member;
-    char separator;
-    Http::HdrType header_id;
-};
-
 class external_acl
 {
     /* FIXME: These are not really cbdata, but it is an easy way
      * to get them pooled, refcounted, accounted and freed properly...
      */
     CBDATA_CLASS(external_acl);
 
 public:
     external_acl();
     ~external_acl();
 
     external_acl *next;
 
     void add(const ExternalACLEntryPointer &);
 
     void trimCache();
 
     int ttl;
 
     int negative_ttl;
 
     int grace;
 
     char *name;
 
-    external_acl_format::Pointer format;
+    Format::Format format;
 
     wordlist *cmdline;
 
     Helper::ChildConfig children;
 
     helper *theHelper;
 
     hash_table *cache;
 
     dlink_list lru_list;
 
     int cache_size;
 
     int cache_entries;
 
     dlink_list queue;
 
 #if USE_AUTH
     /**
      * Configuration flag. May only be altered by the configuration parser.
      *
      * Indicates that all uses of this external_acl_type helper require authentication
      * details to be processed. If none are available its a fail match.
      */
     bool require_auth;
 #endif
 
-    enum {
-        QUOTE_METHOD_SHELL = 1,
-        QUOTE_METHOD_URL
-    } quote;
+    Format::Quoting quote; // default quoting to use, set by protocol= parameter
 
     Ip::Address local_addr;
 };
 
 CBDATA_CLASS_INIT(external_acl);
 
 external_acl::external_acl() :
     next(NULL),
     ttl(DEFAULT_EXTERNAL_ACL_TTL),
     negative_ttl(-1),
     grace(1),
     name(NULL),
+    format("external_acl_type"),
     cmdline(NULL),
     children(DEFAULT_EXTERNAL_ACL_CHILDREN),
     theHelper(NULL),
     cache(NULL),
     cache_size(256*1024),
     cache_entries(0),
 #if USE_AUTH
     require_auth(0),
 #endif
-    quote(external_acl::QUOTE_METHOD_URL)
+    quote(Format::LOG_QUOTE_URL)
 {
     local_addr.setLocalhost();
 }
 
 external_acl::~external_acl()
 {
     xfree(name);
-    format = NULL;
     wordlistDestroy(&cmdline);
 
     if (theHelper) {
         helperShutdown(theHelper);
         delete theHelper;
         theHelper = NULL;
     }
 
     while (lru_list.tail) {
         ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(lru_list.tail->data));
         external_acl_cache_delete(this, e);
     }
     if (cache)
         hashFreeMemory(cache);
 
     while (next) {
         external_acl *node = next;
         next = node->next;
         node->next = NULL; // prevent recursion
         delete node;
     }
 }
 
-/**
- * Parse the External ACL format %<{.*} and %>{.*} token(s) to pass a specific
- * request or reply header to external helper.
- *
- \param header   - the token being parsed (without the identifying prefix)
- \param type     - format enum identifier for this element, pulled from identifying prefix
- \param format   - structure to contain all the info about this format element.
- */
-void
-parse_header_token(external_acl_format::Pointer format, char *header, const Format::ByteCode_t type)
-{
-    /* header format */
-    char *member, *end;
-
-    /** Cut away the closing brace */
-    end = strchr(header, '}');
-    if (end && strlen(end) == 1)
-        *end = '\0';
-    else
-        self_destruct();
-
-    member = strchr(header, ':');
-
-    if (member) {
-        /* Split in header and member */
-        *member = '\0';
-        ++member;
-
-        if (!xisalnum(*member)) {
-            format->separator = *member;
-            ++member;
-        } else {
-            format->separator = ',';
-        }
-
-        format->member = xstrdup(member);
-
-        if (type == Format::LFT_ADAPTED_REQUEST_HEADER)
-            format->type = Format::LFT_ADAPTED_REQUEST_HEADER_ELEM;
-        else
-            format->type = Format::LFT_REPLY_HEADER_ELEM;
-
-    } else {
-        format->type = type;
-    }
-
-    format->header = xstrdup(header);
-    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header)).id;
-}
-
 void
 parse_externalAclHelper(external_acl ** list)
 {
     external_acl *a = new external_acl;
     char *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
 
     a->name = xstrdup(token);
 
     // Allow supported %macros inside quoted tokens
     ConfigParser::EnableMacros();
     token = ConfigParser::NextToken();
 
     /* Parse options */
     while (token) {
         if (strncmp(token, "ttl=", 4) == 0) {
             a->ttl = atoi(token + 4);
         } else if (strncmp(token, "negative_ttl=", 13) == 0) {
             a->negative_ttl = atoi(token + 13);
         } else if (strncmp(token, "children=", 9) == 0) {
             a->children.n_max = atoi(token + 9);
             debugs(0, DBG_CRITICAL, "WARNING: external_acl_type option children=N has been deprecated in favor of children-max=N and children-startup=N");
         } else if (strncmp(token, "children-max=", 13) == 0) {
             a->children.n_max = atoi(token + 13);
         } else if (strncmp(token, "children-startup=", 17) == 0) {
             a->children.n_startup = atoi(token + 17);
         } else if (strncmp(token, "children-idle=", 14) == 0) {
             a->children.n_idle = atoi(token + 14);
         } else if (strncmp(token, "concurrency=", 12) == 0) {
             a->children.concurrency = atoi(token + 12);
         } else if (strncmp(token, "queue-size=", 11) == 0) {
             a->children.queue_size = atoi(token + 11);
             a->children.defaultQueueSize = false;
         } else if (strncmp(token, "cache=", 6) == 0) {
             a->cache_size = atoi(token + 6);
         } else if (strncmp(token, "grace=", 6) == 0) {
             a->grace = atoi(token + 6);
         } else if (strcmp(token, "protocol=2.5") == 0) {
-            a->quote = external_acl::QUOTE_METHOD_SHELL;
+            a->quote = Format::LOG_QUOTE_SHELL;
         } else if (strcmp(token, "protocol=3.0") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option protocol=3.0 is deprecated. Remove this from your config.");
-            a->quote = external_acl::QUOTE_METHOD_URL;
+            a->quote = Format::LOG_QUOTE_URL;
         } else if (strcmp(token, "quote=url") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=url is deprecated. Remove this from your config.");
-            a->quote = external_acl::QUOTE_METHOD_URL;
+            a->quote = Format::LOG_QUOTE_URL;
         } else if (strcmp(token, "quote=shell") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=shell is deprecated. Use protocol=2.5 if still needed.");
-            a->quote = external_acl::QUOTE_METHOD_SHELL;
+            a->quote = Format::LOG_QUOTE_SHELL;
 
             /* INET6: allow admin to configure some helpers explicitly to
                       bind to IPv4/v6 localhost port. */
         } else if (strcmp(token, "ipv4") == 0) {
             if ( !a->local_addr.setIPv4() ) {
                 debugs(3, DBG_CRITICAL, "WARNING: Error converting " << a->local_addr << " to IPv4 in " << a->name );
             }
         } else if (strcmp(token, "ipv6") == 0) {
             if (!Ip::EnableIpv6)
                 debugs(3, DBG_CRITICAL, "WARNING: --enable-ipv6 required for external ACL helpers to use IPv6: " << a->name );
             // else nothing to do.
         } else {
             break;
         }
 
         token = ConfigParser::NextToken();
     }
     ConfigParser::DisableMacros();
 
     /* check that child startup value is sane. */
     if (a->children.n_startup > a->children.n_max)
         a->children.n_startup = a->children.n_max;
 
     /* check that child idle value is sane. */
     if (a->children.n_idle > a->children.n_max)
         a->children.n_idle = a->children.n_max;
     if (a->children.n_idle < 1)
         a->children.n_idle = 1;
 
     if (a->negative_ttl == -1)
         a->negative_ttl = a->ttl;
 
     if (a->children.defaultQueueSize)
         a->children.queue_size = 2 * a->children.n_max;
 
-    /* Parse format */
-    external_acl_format::Pointer *p = &a->format;
-
+    /* Legacy external_acl_type format parser.
+     * Handles a series of %... tokens where any non-% means
+     * the start of another parameter field (ie the path to binary).
+     */
+    enum Format::Quoting quote = Format::LOG_QUOTE_NONE;
+    Format::Token **fmt = &a->format.format;
+    bool data_used = false;
     while (token) {
-        /* stop on first non-format token found */
-
+        /* stop on first non-% token found */
         if (*token != '%')
             break;
 
-        external_acl_format::Pointer format = new external_acl_format;
-
-        if (strncmp(token, "%{", 2) == 0) {
-            // deprecated. but assume the old configs all referred to request headers.
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+2), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%>{", 3) == 0) {
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%>ha{", 5) == 0) {
-            parse_header_token(format, (token+5), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%<{", 3) == 0) {
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
-            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
-        } else if (strncmp(token, "%<h{", 4) == 0) {
-            parse_header_token(format, (token+4), Format::LFT_REPLY_HEADER);
-#if USE_AUTH
-        } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
-            format->type = Format::LFT_USER_LOGIN;
-            a->require_auth = true;
-#endif
-        }
-#if USE_IDENT
-        else if (strcmp(token, "%IDENT") == 0 || strcmp(token, "%ui") == 0)
-            format->type = Format::LFT_USER_IDENT;
-#endif
-        else if (strcmp(token, "%SRC") == 0 || strcmp(token, "%>a") == 0)
-            format->type = Format::LFT_CLIENT_IP_ADDRESS;
-        else if (strcmp(token, "%SRCPORT") == 0 || strcmp(token, "%>p") == 0)
-            format->type = Format::LFT_CLIENT_PORT;
-#if USE_SQUID_EUI
-        else if (strcmp(token, "%SRCEUI48") == 0)
-            format->type = Format::LFT_EXT_ACL_CLIENT_EUI48;
-        else if (strcmp(token, "%SRCEUI64") == 0)
-            format->type = Format::LFT_EXT_ACL_CLIENT_EUI64;
-#endif
-        else if (strcmp(token, "%MYADDR") == 0 || strcmp(token, "%la") == 0)
-            format->type = Format::LFT_LOCAL_LISTENING_IP;
-        else if (strcmp(token, "%MYPORT") == 0 || strcmp(token, "%lp") == 0)
-            format->type = Format::LFT_LOCAL_LISTENING_PORT;
-        else if (strcmp(token, "%URI") == 0 || strcmp(token, "%>ru") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URI;
-        else if (strcmp(token, "%DST") == 0 || strcmp(token, "%>rd") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLDOMAIN;
-        else if (strcmp(token, "%PROTO") == 0 || strcmp(token, "%>rs") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLSCHEME;
-        else if (strcmp(token, "%PORT") == 0) // XXX: add a logformat token
-            format->type = Format::LFT_CLIENT_REQ_URLPORT;
-        else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLPATH;
-        else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
-            format->type = Format::LFT_CLIENT_REQ_METHOD;
-#if USE_OPENSSL
-        else if (strcmp(token, "%USER_CERT") == 0)
-            format->type = Format::LFT_EXT_ACL_USER_CERT_RAW;
-        else if (strcmp(token, "%USER_CERTCHAIN") == 0)
-            format->type = Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW;
-        else if (strncmp(token, "%USER_CERT_", 11) == 0) {
-            format->type = Format::LFT_EXT_ACL_USER_CERT;
-            format->header = xstrdup(token + 11);
+        *fmt = new Format::Token;
+        // these tokens are whitespace delimited
+        (*fmt)->space = true;
+
+	// set the default encoding to match the protocol= config
+        // this will be overridden by explicit %macro attributes
+        (*fmt)->quote = a->quote;
+
+        // compatibility for old tokens incompatible with Format::Token syntax
+#if USE_OPENSSL // dont bother if we dont have to.
+        if (strncmp(token, "%USER_CERT_", 11) == 0) {
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CERT;
+            (*fmt)->data.string = xstrdup(token + 11);
+            (*fmt)->data.header.header = (*fmt)->data.string;
         } else if (strncmp(token, "%USER_CA_CERT_", 14) == 0) {
-            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 14);
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CA_CERT;
+            (*fmt)->data.string = xstrdup(token + 14);
+            (*fmt)->data.header.header = (*fmt)->data.string;
         } else if (strncmp(token, "%CA_CERT_", 9) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
-            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 9);
-        } else if (strcmp(token, "%ssl::>sni") == 0)
-            format->type = Format::LFT_SSL_CLIENT_SNI;
-        else if (strcmp(token, "%ssl::<cert_subject") == 0)
-            format->type = Format::LFT_SSL_SERVER_CERT_SUBJECT;
-        else if (strcmp(token, "%ssl::<cert_issuer") == 0)
-            format->type = Format::LFT_SSL_SERVER_CERT_ISSUER;
-#endif
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CA_CERT;
+            (*fmt)->data.string = xstrdup(token + 9);
+            (*fmt)->data.header.header = (*fmt)->data.string;
+        } else
+#endif
+        {
+            // we can use the Format::Token::parse() method since it
+            // only pulls off one token. Since we already checked
+            // for '%' prefix above this is guaranteed to be a token.
+            const size_t len = (*fmt)->parse(token, &quote);
+            assert(len == strlen(token));
+        }
+
+        // process special token-specific actions (only if necessary)
 #if USE_AUTH
-        else if (strcmp(token, "%EXT_USER") == 0 || strcmp(token, "%ue") == 0)
-            format->type = Format::LFT_USER_EXTERNAL;
-#endif
-#if USE_AUTH || defined(USE_OPENSSL) || defined(USE_IDENT)
-        else if (strcmp(token, "%un") == 0)
-            format->type = Format::LFT_USER_NAME;
+        if ((*fmt)->type == Format::LFT_USER_LOGIN)
+            a->require_auth = true;
 #endif
-        else if (strcmp(token, "%EXT_LOG") == 0 || strcmp(token, "%ea") == 0)
-            format->type = Format::LFT_EXT_LOG;
-        else if (strcmp(token, "%TAG") == 0  || strcmp(token, "%et") == 0)
-            format->type = Format::LFT_TAG;
-        else if (strcmp(token, "%ACL") == 0)
-            format->type = Format::LFT_EXT_ACL_NAME;
-        else if (strcmp(token, "%DATA") == 0)
-            format->type = Format::LFT_EXT_ACL_DATA;
-        else if (strcmp(token, "%%") == 0)
-            format->type = Format::LFT_PERCENT;
-        else {
-            debugs(0, DBG_CRITICAL, "ERROR: Unknown Format token " << token);
-            self_destruct();
-        }
 
-        *p = format;
-        p = &format->next;
+        if ((*fmt)->type == Format::LFT_EXT_ACL_DATA)
+            data_used = true;
+
+        fmt = &((*fmt)->next);
         token = ConfigParser::NextToken();
     }
 
     /* There must be at least one format token */
-    if (!a->format)
+    if (!a->format.format)
         self_destruct();
 
+    // format has implicit %DATA on the end if not used explicitly
+    if (!data_used) {
+        *fmt = new Format::Token;
+        (*fmt)->type = Format::LFT_EXT_ACL_DATA;
+        (*fmt)->quote = Format::LOG_QUOTE_URL;
+    }
+
     /* helper */
     if (!token)
         self_destruct();
 
     wordlistAdd(&a->cmdline, token);
 
     /* arguments */
     parse_wordlist(&a->cmdline);
 
     while (*list)
         list = &(*list)->next;
 
     *list = a;
 }
 
 void
 dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl * list)
 {
     const external_acl *node;
     const wordlist *word;
@@ -489,110 +364,44 @@
             storeAppendPrintf(sentry, " negative_ttl=%d", node->negative_ttl);
 
         if (node->grace)
             storeAppendPrintf(sentry, " grace=%d", node->grace);
 
         if (node->children.n_max != DEFAULT_EXTERNAL_ACL_CHILDREN)
             storeAppendPrintf(sentry, " children-max=%d", node->children.n_max);
 
         if (node->children.n_startup != 1)
             storeAppendPrintf(sentry, " children-startup=%d", node->children.n_startup);
 
         if (node->children.n_idle != (node->children.n_max + node->children.n_startup) )
             storeAppendPrintf(sentry, " children-idle=%d", node->children.n_idle);
 
         if (node->children.concurrency)
             storeAppendPrintf(sentry, " concurrency=%d", node->children.concurrency);
 
         if (node->cache)
             storeAppendPrintf(sentry, " cache=%d", node->cache_size);
 
-        if (node->quote == external_acl::QUOTE_METHOD_SHELL)
+        if (node->quote == Format::LOG_QUOTE_SHELL)
             storeAppendPrintf(sentry, " protocol=2.5");
 
-        for (external_acl_format::Pointer format = node->format; format!= NULL; format = format->next) {
-            switch (format->type) {
-
-            case Format::LFT_ADAPTED_REQUEST_HEADER:
-                storeAppendPrintf(sentry, " %%>ha{%s}", format->header);
-                break;
-
-            case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-                storeAppendPrintf(sentry, " %%>ha{%s:%s}", format->header, format->member);
-                break;
-
-            case Format::LFT_REPLY_HEADER:
-                storeAppendPrintf(sentry, " %%<h{%s}", format->header);
-                break;
-
-            case Format::LFT_REPLY_HEADER_ELEM:
-                storeAppendPrintf(sentry, " %%<h{%s:%s}", format->header, format->member);
-                break;
-
-#define DUMP_EXT_ACL_TYPE_FMT(a, fmt, ...) \
-            case Format::LFT_##a: \
-                storeAppendPrintf(sentry, fmt, ##__VA_ARGS__); \
-                break
-#if USE_AUTH
-                DUMP_EXT_ACL_TYPE_FMT(USER_LOGIN," %%ul");
-                DUMP_EXT_ACL_TYPE_FMT(USER_NAME," %%un");
-#endif
-#if USE_IDENT
-
-                DUMP_EXT_ACL_TYPE_FMT(USER_IDENT," %%ui");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_IP_ADDRESS," %%>a");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_PORT," %%>p");
-#if USE_SQUID_EUI
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI48," %%SRCEUI48");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI64," %%SRCEUI64");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_IP," %%>la");
-                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_PORT," %%>lp");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URI," %%>ru");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLDOMAIN," %%>rd");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLSCHEME," %%>rs");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPORT," %%>rP");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPATH," %%>rp");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_METHOD," %%>rm");
-#if USE_OPENSSL
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT_RAW, " %%USER_CERT_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT, " %%USER_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(SSL_CLIENT_SNI, "%%ssl::>sni");
-                DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_SUBJECT, "%%ssl::<cert_subject");
-                DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_ISSUER, "%%ssl::<cert_issuer");
-#endif
-#if USE_AUTH
-                DUMP_EXT_ACL_TYPE_FMT(USER_EXTERNAL," %%ue");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(EXT_LOG," %%ea");
-                DUMP_EXT_ACL_TYPE_FMT(TAG," %%et");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_NAME," %%ACL");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_DATA," %%DATA");
-                DUMP_EXT_ACL_TYPE_FMT(PERCENT, " %%%%");
-            default:
-                fatal("unknown external_acl format error");
-                break;
-            }
-        }
+        node->format.dump(sentry, NULL, false);
 
         for (word = node->cmdline; word; word = word->next)
             storeAppendPrintf(sentry, " %s", word->key);
 
         storeAppendPrintf(sentry, "\n");
     }
 }
 
 void
 free_externalAclHelper(external_acl ** list)
 {
     delete *list;
     *list = NULL;
 }
 
 static external_acl *
 find_externalAclHelper(const char *name)
 {
     external_acl *node;
 
@@ -881,361 +690,92 @@
 
     return rv;
 }
 
 /******************************************************************
  * external_acl cache
  */
 
 static void
 external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     // this must not be done when nothing is being cached.
     if (def->cache_size <= 0 || (def->ttl <= 0 && entry->result == 1) || (def->negative_ttl <= 0 && entry->result != 1))
         return;
 
     dlinkDelete(&entry->lru, &def->lru_list);
     ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
     dlinkAdd(e, &entry->lru, &def->lru_list);
 }
 
-#if USE_OPENSSL
-static const char *
-external_acl_ssl_get_user_attribute(const ACLFilledChecklist &ch, const char *attr)
-{
-    if (ch.conn() != NULL && Comm::IsConnOpen(ch.conn()->clientConnection)) {
-        if (SSL *ssl = fd_table[ch.conn()->clientConnection->fd].ssl)
-            return sslGetUserAttribute(ssl, attr);
-    }
-    return NULL;
-}
-#endif
-
 static char *
 makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 {
     static MemBuf mb;
-    char buf[256];
-    int first = 1;
-    wordlist *arg;
-    HttpRequest *request = ch->request;
-    HttpReply *reply = ch->reply;
     mb.reset();
-    bool data_used = false;
-
-    for (external_acl_format::Pointer format = acl_data->def->format; format != NULL; format = format->next) {
-        const char *str = NULL;
-        String sb;
-
-        switch (format->type) {
-#if USE_AUTH
-        case Format::LFT_USER_LOGIN:
-            // if this ACL line was the cause of credentials fetch
-            // they may not already be in the checklist
-            if (ch->auth_user_request == NULL && ch->request)
-                ch->auth_user_request = ch->request->auth_user_request;
 
-            if (ch->auth_user_request != NULL)
-                str = ch->auth_user_request->username();
-            break;
-#endif
-#if USE_IDENT
-        case Format::LFT_USER_IDENT:
-            str = ch->rfc931;
+    // check for special case tokens in the format
+    for (Format::Token *t = acl_data->def->format.format; t ; t = t->next) {
 
-            if (!str || !*str) {
-                // if we fail to go async, we still return NULL and the caller
-                // will detect the failure in ACLExternal::match().
-                (void)ch->goAsync(IdentLookup::Instance());
-                return NULL;
-            }
-
-            break;
-#endif
-
-        case Format::LFT_CLIENT_IP_ADDRESS:
-            str = ch->src_addr.toStr(buf,sizeof(buf));
-            break;
-
-        case Format::LFT_CLIENT_PORT:
-            snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
-            str = buf;
-            break;
-
-#if USE_SQUID_EUI
-        case Format::LFT_EXT_ACL_CLIENT_EUI48:
-            if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
-                    request->clientConnectionManager->clientConnection->remoteEui48.encode(buf, sizeof(buf)))
-                str = buf;
-            break;
-
-        case Format::LFT_EXT_ACL_CLIENT_EUI64:
-            if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
-                    request->clientConnectionManager->clientConnection->remoteEui64.encode(buf, sizeof(buf)))
-                str = buf;
-            break;
-#endif
-
-        case Format::LFT_LOCAL_LISTENING_IP:
-            str = request->my_addr.toStr(buf, sizeof(buf));
-            break;
-
-        case Format::LFT_LOCAL_LISTENING_PORT:
-            snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URI:
-            snprintf(buf, sizeof(buf), SQUIDSBUFPH, SQUIDSBUFPRINT(request->effectiveRequestUri()));
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLDOMAIN:
-            str = request->url.host();
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLSCHEME:
-            str = request->url.getScheme().c_str();
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLPORT:
-            snprintf(buf, sizeof(buf), "%u", request->url.port());
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLPATH: {
-            SBuf tmp = request->url.path();
-            str = tmp.c_str();
-        }
-        break;
-
-        case Format::LFT_CLIENT_REQ_METHOD: {
-            const SBuf &s = request->method.image();
-            sb.append(s.rawContent(), s.length());
+        if (t->type == Format::LFT_EXT_ACL_NAME) {
+            // setup for %ACL
+            safe_free(ch->al->_private.lastAclName);
+            ch->al->_private.lastAclName = xstrdup(acl_data->name);
         }
-        str = sb.termedBuf();
-        break;
-
-        case Format::LFT_ADAPTED_REQUEST_HEADER:
-            if (format->header_id == Http::HdrType::BAD_HDR)
-                sb = request->header.getByName(format->header);
-            else
-                sb = request->header.getStrOrList(format->header_id);
-            str = sb.termedBuf();
-            break;
-
-        case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-            if (format->header_id == Http::HdrType::BAD_HDR)
-                sb = request->header.getByNameListMember(format->header, format->member, format->separator);
-            else
-                sb = request->header.getListMember(format->header_id, format->member, format->separator);
-            str = sb.termedBuf();
-            break;
-
-        case Format::LFT_REPLY_HEADER:
-            if (reply) {
-                if (format->header_id == Http::HdrType::BAD_HDR)
-                    sb = reply->header.getByName(format->header);
-                else
-                    sb = reply->header.getStrOrList(format->header_id);
-                str = sb.termedBuf();
-            }
-            break;
-
-        case Format::LFT_REPLY_HEADER_ELEM:
-            if (reply) {
-                if (format->header_id == Http::HdrType::BAD_HDR)
-                    sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
-                else
-                    sb = reply->header.getListMember(format->header_id, format->member, format->separator);
-                str = sb.termedBuf();
-            }
-            break;
-
-#if USE_OPENSSL
-
-        case Format::LFT_EXT_ACL_USER_CERT_RAW:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserCertificatePEM(ssl);
-            }
-
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserCertificateChainPEM(ssl);
-            }
-
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CERT:
-
-            str = external_acl_ssl_get_user_attribute(*ch, format->header);
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CA_CERT:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetCAAttribute(ssl, format->header);
-            }
 
-            break;
-
-        case Format::LFT_SSL_CLIENT_SNI:
-            if (ch->conn() != NULL) {
-                if (Ssl::ServerBump * srvBump = ch->conn()->serverBump()) {
-                    if (!srvBump->clientSni.isEmpty())
-                        str = srvBump->clientSni.c_str();
-                }
-            }
-            break;
-
-        case Format::LFT_SSL_SERVER_CERT_SUBJECT:
-        case Format::LFT_SSL_SERVER_CERT_ISSUER: {
-            X509 *serverCert = NULL;
-            if (ch->serverCert.get())
-                serverCert = ch->serverCert.get();
-            else if (ch->conn() && ch->conn()->serverBump())
-                serverCert = ch->conn()->serverBump()->serverCert.get();
-
-            if (serverCert) {
-                if (format->type == Format::LFT_SSL_SERVER_CERT_SUBJECT)
-                    str = Ssl::GetX509UserAttribute(serverCert, "DN");
-                else
-                    str = Ssl::GetX509CAAttribute(serverCert, "DN");
-            }
-            break;
-        }
-
-#endif
-#if USE_AUTH
-        case Format::LFT_USER_EXTERNAL:
-            str = request->extacl_user.termedBuf();
-            break;
-#endif
-        case Format::LFT_USER_NAME:
-            /* find the first available name from various sources */
-#if USE_AUTH
-            // if this ACL line was the cause of credentials fetch
-            // they may not already be in the checklist
-            if (!ch->auth_user_request && ch->request)
-                ch->auth_user_request = ch->request->auth_user_request;
-
-            if (ch->auth_user_request != NULL)
-                str = ch->auth_user_request->username();
-
-            if ((!str || !*str) &&
-                    (request->extacl_user.size() > 0 && request->extacl_user[0] != '-'))
-                str = request->extacl_user.termedBuf();
-#endif
-#if USE_OPENSSL
-            if (!str || !*str)
-                str = external_acl_ssl_get_user_attribute(*ch, "CN");
-#endif
-#if USE_IDENT
-            if (!str || !*str)
-                str = ch->rfc931;
-#endif
-            break;
-        case Format::LFT_EXT_LOG:
-            str = request->extacl_log.termedBuf();
-            break;
-        case Format::LFT_TAG:
-            str = request->tag.termedBuf();
-            break;
-        case Format::LFT_EXT_ACL_NAME:
-            str = acl_data->name;
-            break;
-        case Format::LFT_EXT_ACL_DATA:
-            data_used = true;
-            for (arg = acl_data->arguments; arg; arg = arg->next) {
-                if (!first)
+        if (t->type == Format::LFT_EXT_ACL_DATA) {
+            // setup string for %DATA
+            SBuf sb;
+            for (auto arg = acl_data->arguments; arg; arg = arg->next) {
+                if (sb.length())
                     sb.append(" ", 1);
 
-                if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                if (acl_data->def->quote == Format::LOG_QUOTE_URL) {
                     const char *quoted = rfc1738_escape(arg->key);
                     sb.append(quoted, strlen(quoted));
                 } else {
                     static MemBuf mb2;
                     mb2.init();
                     strwordquote(&mb2, arg->key);
                     sb.append(mb2.buf, mb2.size);
                     mb2.clean();
                 }
-
-                first = 0;
             }
-            break;
-        case Format::LFT_PERCENT:
-            str = "%";
-            break;
 
-        default:
-            // TODO: replace this function with Format::assemble()
-            // For now die on unsupported logformat codes.
-            fatalf("ERROR: unknown external_acl_type format %u", (uint8_t)format->type);
-            break;
+            ch->al->_private.lastAclData = sb.c_str();
         }
 
-        if (str)
-            if (!*str)
-                str = NULL;
-
-        if (!str)
-            str = "-";
-
-        if (!first)
-            mb.append(" ", 1);
-
-        if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-            const char *quoted = rfc1738_escape(str);
-            mb.append(quoted, strlen(quoted));
-        } else {
-            strwordquote(&mb, str);
-        }
-
-        sb.clean();
-
-        first = 0;
-    }
-
-    if (!data_used) {
-        for (arg = acl_data->arguments; arg; arg = arg->next) {
-            if (!first)
-                mb.append(" ", 1);
-
-            if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-                const char *quoted = rfc1738_escape(arg->key);
-                mb.append(quoted, strlen(quoted));
-            } else {
-                strwordquote(&mb, arg->key);
+#if USE_IDENT
+        if (t->type == Format::LFT_USER_IDENT) {
+            if (!*ch->rfc931) {
+                // if we fail to go async, we still return NULL and the caller
+                // will detect the failure in ACLExternal::match().
+                (void)ch->goAsync(IdentLookup::Instance());
+                return NULL;
             }
-
-            first = 0;
         }
+#endif
     }
 
+    // assemble the full helper lookup string
+    acl_data->def->format.assemble(mb, ch->al, 0);
+
     return mb.buf;
 }
 
 static int
 external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;
 
     if (entry->date + (entry->result == 1 ? def->ttl : def->negative_ttl) < squid_curtime)
         return 1;
     else
         return 0;
 }
 
 static int
 external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;

=== modified file 'src/format/ByteCode.h'
--- src/format/ByteCode.h	2015-01-13 07:25:36 +0000
+++ src/format/ByteCode.h	2015-10-02 10:00:59 +0000
@@ -206,44 +206,47 @@
     LFT_ICAP_TR_RESPONSE_TIME,
     LFT_ICAP_IO_TIME,
     LFT_ICAP_OUTCOME,
     LFT_ICAP_STATUS_CODE,
 #endif
     LFT_CREDENTIALS,
 
 #if USE_OPENSSL
     LFT_SSL_BUMP_MODE,
     LFT_SSL_USER_CERT_SUBJECT,
     LFT_SSL_USER_CERT_ISSUER,
     LFT_SSL_CLIENT_SNI,
     LFT_SSL_SERVER_CERT_SUBJECT,
     LFT_SSL_SERVER_CERT_ISSUER,
 #endif
 
     LFT_NOTE,
     LFT_PERCENT,            /* special string cases for escaped chars */
 
     // TODO assign better bytecode names and Token strings for these
+#if USE_OPENSSL
     LFT_EXT_ACL_USER_CERT_RAW,
     LFT_EXT_ACL_USER_CERTCHAIN_RAW,
     LFT_EXT_ACL_USER_CERT,
     LFT_EXT_ACL_USER_CA_CERT,
+#endif
     LFT_EXT_ACL_CLIENT_EUI48,
     LFT_EXT_ACL_CLIENT_EUI64,
     LFT_EXT_ACL_NAME,
     LFT_EXT_ACL_DATA
 
 } ByteCode_t;
 
 /// Quoting style for a format output.
 enum Quoting {
     LOG_QUOTE_NONE = 0,
     LOG_QUOTE_QUOTES,
     LOG_QUOTE_MIMEBLOB,
     LOG_QUOTE_URL,
+    LOG_QUOTE_SHELL,
     LOG_QUOTE_RAW
 };
 
 } // namespace Format
 
 #endif /* _SQUID_FMT_BYTECODE_H */
 

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2015-07-19 13:23:01 +0000
+++ src/format/Format.cc	2015-10-02 10:47:21 +0000
@@ -5,40 +5,41 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "err_detail_type.h"
 #include "errorpage.h"
 #include "fde.h"
 #include "format/Format.h"
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "fqdncache.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
 #include "SquidTime.h"
 #include "Store.h"
+#include "tools.h"
 #include "URL.h"
 #if USE_OPENSSL
 #include "ssl/ErrorDetail.h"
 #include "ssl/ServerBump.h"
 #endif
 
 /// Convert a string to NULL pointer if it is ""
 #define strOrNull(s) ((s)==NULL||(s)[0]=='\0'?NULL:(s))
 
 Format::Format::Format(const char *n) :
     format(NULL),
     next(NULL)
 {
     name = xstrdup(n);
 }
 
 Format::Format::~Format()
 {
     // erase the list without consuming stack space
     while (next) {
@@ -71,48 +72,49 @@
     /* very inefficent parser, but who cares, this needs to be simple */
     /* First off, let's tokenize, we'll optimize in a second pass.
      * A token can either be a %-prefixed sequence (usually a dynamic
      * token but it can be an escaped sequence), or a string. */
     cur = def;
     eos = def + strlen(def);
     format = new_lt = last_lt = new Token;
     cur += new_lt->parse(cur, &quote);
 
     while (cur < eos) {
         new_lt = new Token;
         last_lt->next = new_lt;
         last_lt = new_lt;
         cur += new_lt->parse(cur, &quote);
     }
 
     return true;
 }
 
 void
-Format::Format::dump(StoreEntry * entry, const char *directiveName)
+Format::Format::dump(StoreEntry * entry, const char *directiveName, bool eol) const
 {
     debugs(46, 4, HERE);
 
     // loop rather than recursing to conserve stack space.
-    for (Format *fmt = this; fmt; fmt = fmt->next) {
+    for (const Format *fmt = this; fmt; fmt = fmt->next) {
         debugs(46, 3, HERE << "Dumping format definition for " << fmt->name);
-        storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
+        if (directiveName)
+            storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
 
         for (Token *t = fmt->format; t; t = t->next) {
             if (t->type == LFT_STRING)
                 storeAppendPrintf(entry, "%s", t->data.string);
             else {
                 char argbuf[256];
                 char *arg = NULL;
                 ByteCode_t type = t->type;
 
                 switch (type) {
                 /* special cases */
 
                 case LFT_STRING:
                     break;
 #if USE_ADAPTATION
                 case LFT_ADAPTATION_LAST_HEADER_ELEM:
 #endif
 #if ICAP_CLIENT
                 case LFT_ICAP_REQ_HEADER_ELEM:
                 case LFT_ICAP_REP_HEADER_ELEM:
@@ -208,67 +210,72 @@
                 entry->append("%", 1);
 
                 switch (t->quote) {
 
                 case LOG_QUOTE_QUOTES:
                     entry->append("\"", 1);
                     break;
 
                 case LOG_QUOTE_MIMEBLOB:
                     entry->append("[", 1);
                     break;
 
                 case LOG_QUOTE_URL:
                     entry->append("#", 1);
                     break;
 
                 case LOG_QUOTE_RAW:
                     entry->append("'", 1);
                     break;
 
+                case LOG_QUOTE_SHELL:
+                    entry->append("/", 1);
+                    break;
+
                 case LOG_QUOTE_NONE:
                     break;
                 }
 
                 if (t->left)
                     entry->append("-", 1);
 
                 if (t->zero)
                     entry->append("0", 1);
 
                 if (t->widthMin >= 0)
                     storeAppendPrintf(entry, "%d", t->widthMin);
 
                 if (t->widthMax >= 0)
                     storeAppendPrintf(entry, ".%d", t->widthMax);
 
                 if (arg)
                     storeAppendPrintf(entry, "{%s}", arg);
 
                 storeAppendPrintf(entry, "%s", t->label);
 
                 if (t->space)
                     entry->append(" ", 1);
             }
         }
 
-        entry->append("\n", 1);
+        if (eol)
+            entry->append("\n", 1);
     }
 
 }
 
 static void
 log_quoted_string(const char *str, char *out)
 {
     char *p = out;
 
     while (*str) {
         int l = strcspn(str, "\"\\\r\n\t");
         memcpy(p, str, l);
         str += l;
         p += l;
 
         switch (*str) {
 
         case '\0':
             break;
 
@@ -353,42 +360,62 @@
 
             break;
 
         case LFT_CLIENT_PORT:
             if (al->request) {
                 outint = al->request->client_addr.port();
                 doint = 1;
             }
             break;
 
         case LFT_CLIENT_EUI:
 #if USE_SQUID_EUI
             // TODO make the ACL checklist have a direct link to any TCP details.
             if (al->request && al->request->clientConnectionManager.valid() && al->request->clientConnectionManager->clientConnection != NULL) {
                 if (al->request->clientConnectionManager->clientConnection->remote.isIPv4())
                     al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
                 else
                     al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
                 out = tmp;
             }
-#else
-            out = "-";
+#endif
+            break;
+
+        case LFT_EXT_ACL_CLIENT_EUI48:
+#if USE_SQUID_EUI
+            if (al->request && al->request->clientConnectionManager.valid() &&
+                    al->request->clientConnectionManager->clientConnection != NULL &&
+                    al->request->clientConnectionManager->clientConnection->remote.isIPv4()) {
+                al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
+                out = tmp;
+            }
+#endif
+            break;
+
+        case LFT_EXT_ACL_CLIENT_EUI64:
+#if USE_SQUID_EUI
+            if (al->request && al->request->clientConnectionManager.valid() &&
+                    al->request->clientConnectionManager->clientConnection != NULL &&
+                    !al->request->clientConnectionManager->clientConnection->remote.isIPv4()) {
+                al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
+                out = tmp;
+            }
 #endif
             break;
 
         case LFT_SERVER_IP_ADDRESS:
             if (al->hier.tcpServer != NULL) {
                 out = al->hier.tcpServer->remote.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_SERVER_FQDN_OR_PEER_NAME:
             out = al->hier.host;
             break;
 
         case LFT_SERVER_PORT:
             if (al->hier.tcpServer != NULL) {
                 outint = al->hier.tcpServer->remote.port();
                 doint = 1;
             }
             break;
 
@@ -820,41 +847,45 @@
 #if USE_OPENSSL
             if (!out)
                 out = strOrNull(al->cache.ssluser);
 #endif
             if (!out)
                 out = strOrNull(al->cache.rfc931);
             break;
 
         case LFT_USER_LOGIN:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->username());
 #endif
             break;
 
         case LFT_USER_IDENT:
             out = strOrNull(al->cache.rfc931);
             break;
 
         case LFT_USER_EXTERNAL:
-            out = strOrNull(al->cache.extuser);
+            if (al->request && al->request->extacl_user.size())
+                out = al->request->extacl_user.termedBuf();
+
+            if (!out)
+                out = strOrNull(al->cache.extuser);
             break;
 
         /* case LFT_USER_REALM: */
         /* case LFT_USER_SCHEME: */
 
         // the fmt->type can not be LFT_HTTP_SENT_STATUS_CODE_OLD_30
         // but compiler complains if ommited
         case LFT_HTTP_SENT_STATUS_CODE_OLD_30:
         case LFT_HTTP_SENT_STATUS_CODE:
             outint = al->http.code;
 
             doint = 1;
 
             break;
 
         case LFT_HTTP_RECEIVED_STATUS_CODE:
             if (al->hier.peer_reply_status == Http::scNone) {
                 out = "-";
             } else {
                 outint = al->hier.peer_reply_status;
@@ -878,42 +909,41 @@
 
         case LFT_SQUID_STATUS:
             out = al->cache.code.c_str();
             break;
 
         case LFT_SQUID_ERROR:
             if (al->request && al->request->errType != ERR_NONE)
                 out = errorPageName(al->request->errType);
             break;
 
         case LFT_SQUID_ERROR_DETAIL:
 #if USE_OPENSSL
             if (al->request && al->request->errType == ERR_SECURE_CONNECT_FAIL) {
                 if (! (out = Ssl::GetErrorName(al->request->errDetail))) {
                     snprintf(tmp, sizeof(tmp), "SSL_ERR=%d", al->request->errDetail);
                     out = tmp;
                 }
             } else
 #endif
                 if (al->request && al->request->errDetail != ERR_DETAIL_NONE) {
-                    if (al->request->errDetail > ERR_DETAIL_START  &&
-                            al->request->errDetail < ERR_DETAIL_MAX)
+                    if (al->request->errDetail > ERR_DETAIL_START && al->request->errDetail < ERR_DETAIL_MAX)
                         out = errorDetailName(al->request->errDetail);
                     else {
                         if (al->request->errDetail >= ERR_DETAIL_EXCEPTION_START)
                             snprintf(tmp, sizeof(tmp), "%s=0x%X",
                                      errorDetailName(al->request->errDetail), (uint32_t) al->request->errDetail);
                         else
                             snprintf(tmp, sizeof(tmp), "%s=%d",
                                      errorDetailName(al->request->errDetail), al->request->errDetail);
                         out = tmp;
                     }
                 }
             break;
 
         case LFT_SQUID_HIERARCHY:
             if (al->hier.ping.timedout)
                 mb.append("TIMEOUT_", 8);
 
             out = hier_code_str[al->hier.code];
 
             break;
@@ -1112,60 +1142,101 @@
             break;
 
         case LFT_EXT_LOG:
             if (al->request)
                 out = al->request->extacl_log.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_SEQUENCE_NUMBER:
             outoff = logSequenceNumber;
             dooff = 1;
             break;
 
 #if USE_OPENSSL
         case LFT_SSL_BUMP_MODE: {
             const Ssl::BumpMode mode = static_cast<Ssl::BumpMode>(al->ssl.bumpMode);
             // for Ssl::bumpEnd, Ssl::bumpMode() returns NULL and we log '-'
             out = Ssl::bumpMode(mode);
-            break;
         }
+            break;
+
+        case LFT_EXT_ACL_USER_CERT_RAW:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserCertificatePEM(ssl);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserCertificatePEM(ssl);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CERT:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserAttribute(ssl, format->data.header.header);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CA_CERT:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                       out = sslGetCAAttribute(ssl, format->data.header.header);
+                }
+            }
+            break;
 
         case LFT_SSL_USER_CERT_SUBJECT:
             if (X509 *cert = al->cache.sslClientCert.get()) {
                 if (X509_NAME *subject = X509_get_subject_name(cert)) {
                     X509_NAME_oneline(subject, tmp, sizeof(tmp));
                     out = tmp;
                 }
             }
             break;
 
         case LFT_SSL_USER_CERT_ISSUER:
             if (X509 *cert = al->cache.sslClientCert.get()) {
                 if (X509_NAME *issuer = X509_get_issuer_name(cert)) {
                     X509_NAME_oneline(issuer, tmp, sizeof(tmp));
                     out = tmp;
                 }
             }
             break;
+
         case LFT_SSL_CLIENT_SNI:
             if (al->request && al->request->clientConnectionManager.valid()) {
                 if (Ssl::ServerBump * srvBump = al->request->clientConnectionManager->serverBump()) {
                     if (!srvBump->clientSni.isEmpty())
                         out = srvBump->clientSni.c_str();
                 }
             }
             break;
 
         case LFT_SSL_SERVER_CERT_ISSUER:
         case LFT_SSL_SERVER_CERT_SUBJECT:
             // Not implemented
             break;
 #endif
 
         case LFT_REQUEST_URLGROUP_OLD_2X:
             assert(LFT_REQUEST_URLGROUP_OLD_2X == 0); // should never happen.
 
         case LFT_NOTE:
             tmp[0] = fmt->data.header.separator;
@@ -1199,52 +1270,46 @@
                 if (al->notes != NULL && !al->notes->empty())
                     sb.append(al->notes->toString(separator));
 
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_CREDENTIALS:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->credentialsStr());
 #endif
 
             break;
 
         case LFT_PERCENT:
             out = "%";
             break;
 
-        // XXX: external_acl_type format tokens which are not output by logformat.
-        // They are listed here because the switch requires
-        // every ByteCode_t to be explicitly enumerated.
-        // But do not output due to lack of access to the values.
-        case LFT_EXT_ACL_USER_CERT_RAW:
-        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
-        case LFT_EXT_ACL_USER_CERT:
-        case LFT_EXT_ACL_USER_CA_CERT:
-        case LFT_EXT_ACL_CLIENT_EUI48:
-        case LFT_EXT_ACL_CLIENT_EUI64:
         case LFT_EXT_ACL_NAME:
+            out = al->_private.lastAclName;
+            break;
+
         case LFT_EXT_ACL_DATA:
+            out = al->_private.lastAclData;
             break;
         }
 
         if (dooff) {
             snprintf(tmp, sizeof(tmp), "%0*" PRId64, fmt->zero && fmt->widthMin >= 0 ? fmt->widthMin : 0, outoff);
             out = tmp;
 
         } else if (doint) {
             snprintf(tmp, sizeof(tmp), "%0*ld", fmt->zero && fmt->widthMin >= 0 ? fmt->widthMin : 0, outint);
             out = tmp;
         } else if (doMsec) {
             if (fmt->widthMax < 0) {
                 snprintf(tmp, sizeof(tmp), "%0*ld", fmt->widthMin , tvToMsec(outtv));
             } else {
                 int precision = fmt->widthMax;
                 snprintf(tmp, sizeof(tmp), "%0*" PRId64 ".%0*" PRId64 "", fmt->zero && (fmt->widthMin - precision - 1 >= 0) ? fmt->widthMin - precision - 1 : 0, static_cast<int64_t>(outtv.tv_sec * 1000 + outtv.tv_usec / 1000), precision, static_cast<int64_t>((outtv.tv_usec % 1000 )* (1000 / fmt->divisor)));
             }
             out = tmp;
         } else if (doSec) {
             int precision = fmt->widthMax >=0 ? fmt->widthMax :3;
@@ -1266,40 +1331,49 @@
                 case LOG_QUOTE_QUOTES: {
                     size_t out_len = static_cast<size_t>(strlen(out)) * 2 + 1;
                     if (out_len >= sizeof(tmp)) {
                         newout = (char *)xmalloc(out_len);
                         newfree = 1;
                     } else
                         newout = tmp;
                     log_quoted_string(out, newout);
                 }
                 break;
 
                 case LOG_QUOTE_MIMEBLOB:
                     newout = QuoteMimeBlob(out);
                     newfree = 1;
                     break;
 
                 case LOG_QUOTE_URL:
                     newout = rfc1738_escape(out);
                     break;
 
+                case LOG_QUOTE_SHELL: {
+                    MemBuf mbq;
+                    mbq.init();
+                    strwordquote(&mbq, out);
+                    newout = mbq.content();
+                    mbq.stolen = 1;
+                    newfree = 1;
+                    } break;
+
                 case LOG_QUOTE_RAW:
                     break;
                 }
 
                 if (newout) {
                     if (dofree)
                         safe_free(out);
 
                     out = newout;
 
                     dofree = newfree;
                 }
             }
 
             // enforce width limits if configured
             const bool haveMaxWidth = fmt->widthMax >=0 && !doint && !dooff && !doMsec && !doSec;
             if (haveMaxWidth || fmt->widthMin) {
                 const int minWidth = fmt->widthMin >= 0 ?
                                      fmt->widthMin :0;
                 const int maxWidth = haveMaxWidth ?

=== modified file 'src/format/Format.h'
--- src/format/Format.h	2015-01-13 07:25:36 +0000
+++ src/format/Format.h	2015-05-22 05:54:39 +0000
@@ -34,31 +34,31 @@
 
 class Token;
 
 // XXX: inherit from linked list
 class Format
 {
 public:
     Format(const char *name);
     virtual ~Format();
 
     /* very inefficent parser, but who cares, this needs to be simple */
     /* First off, let's tokenize, we'll optimize in a second pass.
      * A token can either be a %-prefixed sequence (usually a dynamic
      * token but it can be an escaped sequence), or a string. */
     bool parse(const char *def);
 
     /// assemble the state information into a formatted line.
     void assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const;
 
     /// dump this whole list of formats into the provided StoreEntry
-    void dump(StoreEntry * entry, const char *directiveName);
+    void dump(StoreEntry * entry, const char *directiveName, bool eol = true) const;
 
     char *name;
     Token *format;
     Format *next;
 };
 
 } // namespace Format
 
 #endif /* _SQUID_FORMAT_FORMAT_H */
 

=== modified file 'src/format/Token.cc'
--- src/format/Token.cc	2015-01-13 07:25:36 +0000
+++ src/format/Token.cc	2015-08-09 11:23:34 +0000
@@ -128,40 +128,66 @@
     /*TokenTableEntry("stP", LFT_SERVER_IO_SIZE_TOTAL),*/
 
     TokenTableEntry("et", LFT_TAG),
     TokenTableEntry("ea", LFT_EXT_LOG),
     TokenTableEntry("sn", LFT_SEQUENCE_NUMBER),
 
     TokenTableEntry(NULL, LFT_NONE)        /* this must be last */
 };
 
 /// Miscellaneous >2 byte tokens
 static TokenTableEntry TokenTableMisc[] = {
     TokenTableEntry(">eui", LFT_CLIENT_EUI),
     TokenTableEntry(">qos", LFT_CLIENT_LOCAL_TOS),
     TokenTableEntry("<qos", LFT_SERVER_LOCAL_TOS),
     TokenTableEntry(">nfmark", LFT_CLIENT_LOCAL_NFMARK),
     TokenTableEntry("<nfmark", LFT_SERVER_LOCAL_NFMARK),
     TokenTableEntry("err_code", LFT_SQUID_ERROR ),
     TokenTableEntry("err_detail", LFT_SQUID_ERROR_DETAIL ),
     TokenTableEntry("note", LFT_NOTE ),
     TokenTableEntry("credentials", LFT_CREDENTIALS),
+    /*
+     * Legacy external_acl_type format tokens
+     */
+    TokenTableEntry("ACL", LFT_EXT_ACL_NAME),
+    TokenTableEntry("DATA", LFT_EXT_ACL_DATA),
+    TokenTableEntry("DST", LFT_CLIENT_REQ_URLDOMAIN),
+    TokenTableEntry("EXT_LOG", LFT_EXT_LOG),
+    TokenTableEntry("EXT_USER", LFT_USER_EXTERNAL),
+    TokenTableEntry("IDENT", LFT_USER_IDENT),
+    TokenTableEntry("LOGIN", LFT_USER_LOGIN),
+    TokenTableEntry("METHOD", LFT_CLIENT_REQ_METHOD),
+    TokenTableEntry("MYADDR", LFT_LOCAL_LISTENING_IP),
+    TokenTableEntry("MYPORT", LFT_LOCAL_LISTENING_PORT),
+    TokenTableEntry("PATH", LFT_CLIENT_REQ_URLPATH),
+    TokenTableEntry("PORT", LFT_CLIENT_REQ_URLPORT),
+    TokenTableEntry("PROTO", LFT_CLIENT_REQ_URLSCHEME),
+    TokenTableEntry("SRCEUI48", LFT_EXT_ACL_CLIENT_EUI48),
+    TokenTableEntry("SRCEUI64", LFT_EXT_ACL_CLIENT_EUI64),
+    TokenTableEntry("SRCPORT", LFT_CLIENT_PORT),
+    TokenTableEntry("SRC", LFT_CLIENT_IP_ADDRESS), // keep after longer SRC* tokens
+    TokenTableEntry("TAG", LFT_TAG),
+    TokenTableEntry("URI", LFT_CLIENT_REQ_URI),
+#if USE_OPENSSL
+    TokenTableEntry("USER_CERTCHAIN", LFT_EXT_ACL_USER_CERTCHAIN_RAW),
+    TokenTableEntry("USER_CERT", LFT_EXT_ACL_USER_CERT_RAW),
+#endif
     TokenTableEntry(NULL, LFT_NONE)        /* this must be last */
 };
 
 #if USE_ADAPTATION
 static TokenTableEntry TokenTableAdapt[] = {
     TokenTableEntry("all_trs", LFT_ADAPTATION_ALL_XACT_TIMES),
     TokenTableEntry("sum_trs", LFT_ADAPTATION_SUM_XACT_TIMES),
     TokenTableEntry("<last_h", LFT_ADAPTATION_LAST_HEADER),
     TokenTableEntry(NULL, LFT_NONE)           /* this must be last */
 };
 #endif
 
 #if ICAP_CLIENT
 /// ICAP (icap::) tokens
 static TokenTableEntry TokenTableIcap[] = {
     TokenTableEntry("tt", LFT_ICAP_TOTAL_TIME),
     TokenTableEntry("<last_h", LFT_ADAPTATION_LAST_HEADER), // deprecated
 
     TokenTableEntry("<A",  LFT_ICAP_ADDR),
     TokenTableEntry("<service_name",  LFT_ICAP_SERV_NAME),
@@ -185,41 +211,40 @@
 
 #if USE_OPENSSL
 // SSL (ssl::) tokens
 static TokenTableEntry TokenTableSsl[] = {
     TokenTableEntry("bump_mode", LFT_SSL_BUMP_MODE),
     TokenTableEntry(">cert_subject", LFT_SSL_USER_CERT_SUBJECT),
     TokenTableEntry(">cert_issuer", LFT_SSL_USER_CERT_ISSUER),
     TokenTableEntry(">sni", LFT_SSL_CLIENT_SNI),
     /*TokenTableEntry("<cert_subject", LFT_SSL_SERVER_CERT_SUBJECT), */
     /*TokenTableEntry("<cert_issuer", LFT_SSL_SERVER_CERT_ISSUER), */
     TokenTableEntry(NULL, LFT_NONE)
 };
 #endif
 } // namespace Format
 
 /// Register all components custom format tokens
 void
 Format::Token::Init()
 {
     // TODO standard log tokens
-    // TODO external ACL fmt tokens
 
 #if USE_ADAPTATION
     TheConfig.registerTokens(String("adapt"),::Format::TokenTableAdapt);
 #endif
 #if ICAP_CLIENT
     TheConfig.registerTokens(String("icap"),::Format::TokenTableIcap);
 #endif
 #if USE_OPENSSL
     TheConfig.registerTokens(String("ssl"),::Format::TokenTableSsl);
 #endif
 }
 
 /// Scans a token table to see if the next token exists there
 /// returns a pointer to next unparsed byte and updates type member if found
 const char *
 Format::Token::scanForToken(TokenTableEntry const table[], const char *cur)
 {
     for (TokenTableEntry const *lte = table; lte->configTag != NULL; ++lte) {
         debugs(46, 8, HERE << "compare tokens '" << lte->configTag << "' with '" << cur << "'");
         if (strncmp(lte->configTag, cur, strlen(lte->configTag)) == 0) {
@@ -318,40 +343,41 @@
             left = true;
             ++cur;
         }
 
         if (*cur == '0') {
             zero = true;
             ++cur;
         }
 
         char *endp;
         if (xisdigit(*cur)) {
             widthMin = strtol(cur, &endp, 10);
             cur = endp;
         }
 
         if (*cur == '.' && xisdigit(*(++cur))) {
             widthMax = strtol(cur, &endp, 10);
             cur = endp;
         }
 
+        // when {arg} field is before the token (old logformat syntax)
         if (*cur == '{') {
             char *cp;
             ++cur;
             l = strcspn(cur, "}");
             cp = (char *)xmalloc(l + 1);
             xstrncpy(cp, cur, l + 1);
             data.string = cp;
             cur += l;
 
             if (*cur == '}')
                 ++cur;
         }
 
         type = LFT_NONE;
 
         // Scan each registered token namespace
         debugs(46, 9, HERE << "check for token in " << TheConfig.tokens.size() << " namespaces.");
         for (std::list<TokenNamespace>::const_iterator itr = TheConfig.tokens.begin(); itr != TheConfig.tokens.end(); ++itr) {
             debugs(46, 7, HERE << "check for possible " << itr->prefix << ":: token");
             const size_t len = itr->prefix.size();
@@ -378,40 +404,55 @@
 
             // Scan for various long tokens
             debugs(46, 5, HERE << "scan for possible Misc token");
             cur = scanForToken(TokenTableMisc, cur);
             // scan for 2-char tokens
             if (type == LFT_NONE) {
                 debugs(46, 5, HERE << "scan for possible 2C token");
                 cur = scanForToken(TokenTable2C, cur);
             }
             // finally scan for 1-char tokens.
             if (type == LFT_NONE) {
                 debugs(46, 5, HERE << "scan for possible 1C token");
                 cur = scanForToken(TokenTable1C, cur);
             }
         }
 
         if (type == LFT_NONE) {
             fatalf("Can't parse configuration token: '%s'\n", def);
         }
 
+        // when {arg} field is after the token (old external_acl_type token syntax)
+        // but accept only if there was none before the token
+        if (*cur == '{' && !data.string) {
+            char *cp;
+            ++cur;
+            l = strcspn(cur, "}");
+            cp = (char *)xmalloc(l + 1);
+            xstrncpy(cp, cur, l + 1);
+            data.string = cp;
+            cur += l;
+
+            if (*cur == '}')
+                ++cur;
+        }
+
         if (*cur == ' ') {
             space = true;
             ++cur;
         }
     }
 
     switch (type) {
 
 #if USE_ADAPTATION
     case LFT_ADAPTATION_LAST_HEADER:
 #endif
 
 #if ICAP_CLIENT
     case LFT_ICAP_REQ_HEADER:
 
     case LFT_ICAP_REP_HEADER:
 #endif
 
     case LFT_ADAPTED_REQUEST_HEADER:
 


From squid3 at treenet.co.nz  Sat Oct  3 08:44:07 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Sat, 3 Oct 2015 21:44:07 +1300
Subject: [squid-dev] [PATCH] crypto-ng: CA support for GnuTLS
Message-ID: <560F9557.9040308@treenet.co.nz>

Shuffle the cafile= context logics to libsecurity class PeerOptions.

* Rename the parameter tls-cafile= and allow multiple cafile= entries to
be used in squid.conf.

* Document the capath= option as only supported by OpenSSL and LibreSSL.

* Add GnuTLS support for CA loading.
 Although at this point GnuTLS contexts are not yet created.

Amos

-------------- next part --------------
=== modified file 'doc/release-notes/release-4.sgml'
--- doc/release-notes/release-4.sgml	2015-08-26 13:53:33 +0000
+++ doc/release-notes/release-4.sgml	2015-10-03 05:29:50 +0000
@@ -157,70 +157,73 @@
 	<tag>url_rewrite_timeout</tag>
 	<p>Squid times active requests to redirector. This option sets
 	   the timeout value and the Squid reaction to a timed out
 	   request.
 
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
 	<tag>auth_param</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
 
 	<tag>cache_peer</tag>
 	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
 	<p>All <em>ssloptions=</em> values for SSLv2 configuration or disabling
 	   have been removed.
 	<p>Removed <em>sslversion=</em> option. Use <em>tls-options=</em> instead.
 	<p>Manual squid.conf update may be required on upgrade.
+	<p>Replaced <em>sslcafile=</em> with <em>tls-cafile=</em> which takes multiple entries.
 
 	<tag>external_acl_type</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
 
 	<tag>http_port</tag>
 	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
 	<p>All <em>option=</em> values for SSLv2 configuration or disabling
 	   have been removed.
 	<p>Removed <em>version=</em> option. Use <em>tls-options=</em> instead.
 	<p>New <em>options=SINGLE_ECDH_USE</em> parameter to enable ephemeral
 	   ECDH key exchange.
 	<p>Deprecated <em>dhparams=</em> option. Use <em>tls-dh=</em> instead.
 	   The new option allows to optionally specify an elliptic curve for
 	   ephemeral ECDH by adding <em>curve-name:</em> in front of the
 	   parameter file name.
 	<p>Manual squid.conf update may be required on upgrade.
+	<p>Replaced <em>cafile=</em> with <em>tls-cafile=</em> which takes multiple entries.
 
 	<tag>https_port</tag>
 	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
 	<p>All <em>options=</em> values for SSLv2
 	   configuration or disabling have been removed.
 	<p>Removed <em>version=</em> option. Use <em>tls-options=</em> instead.
 	<p>New <em>options=SINGLE_ECDH_USE</em> parameter to enable ephemeral
 	   ECDH key exchange.
 	<p>Deprecated <em>dhparams=</em> option. Use <em>tls-dh=</em> instead.
 	   The new option allows to optionally specify an elliptic curve for
 	   ephemeral ECDH by adding <em>curve-name:</em> in front of the
 	   parameter file name.
 	<p>Manual squid.conf update may be required on upgrade.
+	<p>Replaced <em>cafile=</em> with <em>tls-cafile=</em> which takes multiple entries.
 
 	<tag>icap_service</tag>
 	<p>New scheme <em>icaps://</em> to enable TLS/SSL connections to Secure ICAP
 	   servers on port 11344.
 	<p>New <em>tls-cert=</em> option to set TLS client certificate to use.
 	<p>New <em>tls-key=</em> option to set TLS private key matching the client
 	   certificate used.
 	<p>New <em>tls-min-version=1.N</em> option to set minimum TLS version allowed
 	   on server connections.
 	<p>New <em>tls-options=</em> option to set OpenSSL library parameters.
 	<p>New <em>tls-flags=</em> option to set flags modifying Squid TLS operations.
 	<p>New <em>tls-cipher=</em> option to set a list of ciphers permitted.
 	<p>New <em>tls-cafile=</em> option to set a file with additional CA
 	   certificate(s) to verify the server certificate.
 	<p>New <em>tls-crlfile=</em> option to set a file with a CRL to verify the
 	   server certificate.
 	<p>New <em>tls-domain=</em> option to verify the server certificate domain.
 
 	<tag>refresh_pattern</tag>
 	<p>Removed <em>ignore-auth</em>. Its commonly desired behaviour is
@@ -239,40 +242,41 @@
 	<tag>url_rewrite_children</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
 	   of queued requests.
 
 </descrip>
 
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
 	<tag>cache_peer_domain</tag>
 	<p>Superceded by <em>cache_peer_access</em>. Use dstdomain ACL
 	   in the access control list to restrict domains requested.
 
 	<tag>refresh_pattern</tag>
 	<p>Option <em>ignore-auth</em> removed. Its original intent was
 	   to improve caching. HTTP/1.1 permits caching of authenticated
 	   messages under conditions which Squid does check for and obey.
 
 	<tag>sslproxy_cafile</tag>
 	<p>Replaced by <em>tls_outgoing_options cafile=</em>.
+	   Which now takes multiple entries.
 
 	<tag>sslproxy_capath</tag>
 	<p>Replaced by <em>tls_outgoing_options capath=</em>.
 
 	<tag>sslproxy_cipher</tag>
 	<p>Replaced by <em>tls_outgoing_options cipher=</em>.
 
 	<tag>sslproxy_client_certificate</tag>
 	<p>Replaced by <em>tls_outgoing_options cert=</em>.
 
 	<tag>sslproxy_client_key</tag>
 	<p>Replaced by <em>tls_outgoing_options key=</em>.
 
 	<tag>sslproxy_flags</tag>
 	<p>Replaced by <em>tls_outgoing_options flags=</em>.
 
 	<tag>sslproxy_options</tag>
 	<p>Replaced by <em>tls_outgoing_options options=</em>.
 	<p>All values for SSLv2 configuration or disabling have been removed.
 	<p>Manual squid.conf update may be required on upgrade.

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-09-05 18:52:17 +0000
+++ src/cache_cf.cc	2015-09-30 13:01:19 +0000
@@ -3561,40 +3561,42 @@
                "in " << cfg_directive << ". Use 'ssl-bump' instead.");
         s->flags.tunnelSslBumping = true;
     } else if (strcmp(token, "ssl-bump") == 0) {
         s->flags.tunnelSslBumping = true;
     } else if (strncmp(token, "cert=", 5) == 0) {
         s->secure.parse(token);
     } else if (strncmp(token, "key=", 4) == 0) {
         s->secure.parse(token);
     } else if (strncmp(token, "version=", 8) == 0) {
         debugs(3, DBG_PARSE_NOTE(1), "UPGRADE WARNING: '" << token << "' is deprecated " <<
                "in " << cfg_directive << ". Use 'options=' instead.");
         s->secure.parse(token);
     } else if (strncmp(token, "options=", 8) == 0) {
         s->secure.parse(token);
     } else if (strncmp(token, "cipher=", 7) == 0) {
         s->secure.parse(token);
     } else if (strncmp(token, "clientca=", 9) == 0) {
         safe_free(s->clientca);
         s->clientca = xstrdup(token + 9);
     } else if (strncmp(token, "cafile=", 7) == 0) {
+        debugs(3, DBG_PARSE_NOTE(1), "UPGRADE WARNING: '" << token << "' is deprecated " <<
+               "in " << cfg_directive << ". Use 'tls-cafile=' instead.");
         s->secure.parse(token);
     } else if (strncmp(token, "capath=", 7) == 0) {
         s->secure.parse(token);
     } else if (strncmp(token, "crlfile=", 8) == 0) {
         s->secure.parse(token);
     } else if (strncmp(token, "dhparams=", 9) == 0) {
         debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: '" << token << "' is deprecated " <<
                "in " << cfg_directive << ". Use 'tls-dh=' instead.");
         safe_free(s->dhfile);
         s->dhfile = xstrdup(token + 9);
     } else if (strncmp(token, "tls-dh=", 7) == 0) {
         safe_free(s->tls_dh);
         s->tls_dh = xstrdup(token + 7);
     } else if (strncmp(token, "sslflags=", 9) == 0) {
         s->secure.parse(token+3);
     } else if (strncmp(token, "sslcontext=", 11) == 0) {
         safe_free(s->sslContextSessionId);
         s->sslContextSessionId = xstrdup(token + 11);
     } else if (strcmp(token, "generate-host-certificates") == 0) {
         s->generateHostCertificates = true;
@@ -3642,40 +3644,47 @@
         self_destruct();
         return;
     }
 
     char *token = ConfigParser::NextToken();
 
     if (!token) {
         self_destruct();
         return;
     }
 
     AnyP::PortCfgPointer s = new AnyP::PortCfg();
     s->transport = parsePortProtocol(protoName); // default; protocol=... overwrites
     parsePortSpecification(s, token);
 
     /* parse options ... */
     while ((token = ConfigParser::NextToken())) {
         parse_port_option(s, token);
     }
 
+#if USE_OPENSSL
+    // if clientca has been defined but not cafile, then use it to verify
+    // but if cafile has been defined, only use that to verify
+    if (s->clientca && !s->secure.caFiles.size())
+        s->secure.caFiles.emplace_back(SBuf(s->clientca));
+#endif
+
     if (s->transport.protocol == AnyP::PROTO_HTTPS) {
         s->secure.encryptTransport = true;
 #if USE_OPENSSL
         /* ssl-bump on https_port configuration requires either tproxy or intercept, and vice versa */
         const bool hijacked = s->flags.isIntercepted();
         if (s->flags.tunnelSslBumping && !hijacked) {
             debugs(3, DBG_CRITICAL, "FATAL: ssl-bump on https_port requires tproxy/intercept which is missing.");
             self_destruct();
         }
         if (hijacked && !s->flags.tunnelSslBumping) {
             debugs(3, DBG_CRITICAL, "FATAL: tproxy/intercept on https_port requires ssl-bump which is missing.");
             self_destruct();
         }
 #endif
         if (s->flags.proxySurrogate) {
             debugs(3,DBG_CRITICAL, "FATAL: https_port: require-proxy-header option is not supported on HTTPS ports.");
             self_destruct();
         }
     } else if (protoName.cmp("FTP") == 0) {
         /* ftp_port does not support ssl-bump */

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-08-30 01:07:47 +0000
+++ src/cf.data.pre	2015-09-30 13:39:34 +0000
@@ -1948,46 +1948,47 @@
 				      The adopted curve should be specified
 				      using the tls-dh option.
 
 			    NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as "harmless" by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 
 	   clientca=	File containing the list of CAs to use when
 			requesting a client certificate.
 
-	   cafile=	File containing additional CA certificates to
-			use when verifying client certificates. If unset
-			clientca will be used.
+	   tls-cafile=	PEM file containing CA certificates to use when verifying
+			client certificates. If not configured clientca will be
+			used. May be repeated to load multiple files.
 
 	   capath=	Directory containing additional CA certificates
 			and CRL lists to use when verifying client certificates.
+			Requires OpenSSL or LibreSSL.
 
 	   crlfile=	File of additional CRL lists to use when verifying
 			the client certificate, in addition to CRLs stored in
 			the capath. Implies VERIFY_CRL flag below.
 
 	   tls-dh=[curve:]file
 			File containing DH parameters for temporary/ephemeral DH key
 			exchanges, optionally prefixed by a curve for ephemeral ECDH
 			key exchanges.
 			See OpenSSL documentation for details on how to create the
 			DH parameter file. Supported curves for ECDH can be listed
 			using the "openssl ecparam -list_curves" command.
 			WARNING: EDH and EECDH ciphers will be silently disabled if
 				 this option is not set.
 
 	   sslflags=	Various flags modifying the use of SSL:
 			    DELAYED_AUTH
 				Don't request client certificates
 				immediately, but wait until acl processing
 				requires a certificate (not yet implemented).
@@ -2132,46 +2133,47 @@
 				      The adopted curve should be specified
 				      using the tls-dh option.
 
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as "harmless" by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 
 	   clientca=	File containing the list of CAs to use when
 			requesting a client certificate.
 
-	   cafile=	File containing additional CA certificates to
-			use when verifying client certificates. If unset
-			clientca will be used.
+	   tls-cafile=	PEM file containing CA certificates to use when verifying
+			client certificates. If not configured clientca will be
+			used. May be repeated to load multiple files.
 
 	   capath=	Directory containing additional CA certificates
 			and CRL lists to use when verifying client certificates.
+			Requires OpenSSL or LibreSSL.
 
 	   crlfile=	File of additional CRL lists to use when verifying
 			the client certificate, in addition to CRLs stored in
 			the capath. Implies VERIFY_CRL flag below.
 
 	   tls-dh=[curve:]file
 			File containing DH parameters for temporary/ephemeral DH key
 			exchanges, optionally prefixed by a curve for ephemeral ECDH
 			key exchanges.
 
 	   sslflags=	Various flags modifying the use of SSL:
 			    DELAYED_AUTH
 				Don't request client certificates
 				immediately, but wait until acl processing
 				requires a certificate (not yet implemented).
 			    NO_DEFAULT_CA
 				Don't use the default CA lists built in
 				to OpenSSL.
 			    NO_SESSION_REUSE
 				Don't allow for session reuse. Each connection
@@ -2630,45 +2632,46 @@
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as "harmless" by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 	
-	cafile=... 	A file containing additional CA certificates to use
-			when verifying the peer certificate.
-	
-	capath=...	A directory containing additional CA certificates to
+	cafile=		PEM file containing CA certificates to use when verifying
+			the peer certificate. May be repeated to load multiple files.
+
+	capath=		A directory containing additional CA certificates to
 			use when verifying the peer certificate.
+			Requires OpenSSL or LibreSSL.
 	
 	crlfile=... 	A certificate revocation list file to use when
 			verifying the peer certificate.
 	
 	flags=...	Specify various flags modifying the TLS implementation:
 	
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 			NO_DEFAULT_CA
 				Don't use the default CA list built in
 				to OpenSSL.
 			DONT_VERIFY_DOMAIN
 				Don't verify the peer certificate
 				matches the server name
 	
 	domain= 	The peer name as advertised in its certificate.
 			Used for verifying the correctness of the received peer
 			certificate. If not specified the peer hostname will be
 			used.
@@ -3367,45 +3370,46 @@
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as "harmless" by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 	
-	sslcafile=... 	A file containing additional CA certificates to use
-			when verifying the peer certificate.
+	tls-cafile=	PEM file containing CA certificates to use when verifying
+			the peer certificate. May be repeated to load multiple files.
 	
 	sslcapath=...	A directory containing additional CA certificates to
 			use when verifying the peer certificate.
+			Requires OpenSSL or LibreSSL.
 	
 	sslcrlfile=... 	A certificate revocation list file to use when
 			verifying the peer certificate.
 	
 	sslflags=...	Specify various flags modifying the SSL implementation:
 	
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 
 			NO_DEFAULT_CA
 				Don't use the default CA list built in
 				to OpenSSL.
 
 			DONT_VERIFY_DOMAIN
 				Don't verify the peer certificate
 				matches the server name
 	
 	ssldomain= 	The peer name as advertised in it's certificate.
 			Used for verifying the correctness of the received peer
@@ -8524,48 +8528,50 @@
 
 			    NO_SSLv3    Disallow the use of SSLv3
 
 			    NO_TLSv1    Disallow the use of TLSv1.0
 			    NO_TLSv1_1  Disallow the use of TLSv1.1
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
 			    ALL       Enable various bug workarounds
 				      suggested as "harmless" by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list. Options relevant only to SSLv2 are
 			not supported.
 
-	tls-cafile=...	A PEM file containing additional CA certificates to use
-			when verifying the icap server certificate. Used
-			to specify intermediate CA certificate(s) if not sent
-			by the server. Or the full CA chain for the server
-			when using the NO_DEFAULT_CA flag.
+	tls-cafile=	PEM file containing CA certificates to use when verifying
+			the icap server certificate.
+			Use to specify intermediate CA certificate(s) if not sent
+			by the server. Or the full CA chain for the server when
+			using the NO_DEFAULT_CA flag.
+			May be repeated to load multiple files.
 
 	tls-capath=...	A directory containing additional CA certificates to
 			use when verifying the icap server certificate.
+			Requires OpenSSL or LibreSSL.
 
 	tls-crlfile=...	A certificate revocation list file to use when
 			verifying the icap server certificate.
 
 	tls-flags=...	Specify various flags modifying the Squid TLS implementation:
 
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 			NO_DEFAULT_CA
 				Don't use the default CA list built into
 				OpenSSL.
 			DONT_VERIFY_DOMAIN
 				Don't verify the icap server certificate
 				matches the server name
 
 	tls-domain=	The icap server name as advertised in it's certificate.
 			Used for verifying the correctness of the received icap
 			server certificate. If not specified the icap server
 			hostname extracted from ICAP URI will be used.

=== modified file 'src/security/Context.h'
--- src/security/Context.h	2015-03-21 11:58:32 +0000
+++ src/security/Context.h	2015-10-02 18:51:31 +0000
@@ -10,31 +10,31 @@
 #define SQUID_SRC_SECURITY_CONTEXT_H
 
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include <openssl/ssl.h>
 #endif
 #endif
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_GNUTLS_H
 #include <gnutls/gnutls.h>
 #endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
 typedef SSL_CTX* ContextPointer;
 
 #elif USE_GNUTLS
-typedef gnutls_certificate_credentials_t* ContextPointer;
+typedef gnutls_certificate_credentials_t ContextPointer;
 
 #else
 // use void* so we can check against NULL
 typedef void* ContextPointer;
 #endif
 
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_CONTEXT_H */
 

=== modified file 'src/security/PeerOptions.cc'
--- src/security/PeerOptions.cc	2015-09-24 21:08:23 +0000
+++ src/security/PeerOptions.cc	2015-10-03 04:56:55 +0000
@@ -9,48 +9,48 @@
 #include "squid.h"
 #include "base/Packable.h"
 #include "Debug.h"
 #include "fatal.h"
 #include "globals.h"
 #include "parser/Tokenizer.h"
 #include "parser/Tokenizer.h"
 #include "Parsing.h"
 #include "security/PeerOptions.h"
 
 #if USE_OPENSSL
 #include "ssl/support.h"
 #endif
 
 Security::PeerOptions Security::ProxyOutgoingConfig;
 
 Security::PeerOptions::PeerOptions(const Security::PeerOptions &p) :
     certFile(p.certFile),
     privateKeyFile(p.privateKeyFile),
     sslOptions(p.sslOptions),
-    caFile(p.caFile),
     caDir(p.caDir),
     crlFile(p.crlFile),
     sslCipher(p.sslCipher),
     sslFlags(p.sslFlags),
     sslDomain(p.sslDomain),
     parsedOptions(p.parsedOptions),
     parsedFlags(p.parsedFlags),
+    caFiles(p.caFiles),
     parsedCrl(p.parsedCrl),
     sslVersion(p.sslVersion),
     encryptTransport(p.encryptTransport)
 {
 }
 
 void
 Security::PeerOptions::parse(const char *token)
 {
     if (!*token) {
         // config says just "ssl" or "tls" (or "tls-")
         encryptTransport = true;
         return;
     }
 
     if (strncmp(token, "disable", 7) == 0) {
         clear();
         return;
     }
 
@@ -58,84 +58,88 @@
         certFile = SBuf(token + 5);
         if (privateKeyFile.isEmpty())
             privateKeyFile = certFile;
     } else if (strncmp(token, "key=", 4) == 0) {
         privateKeyFile = SBuf(token + 4);
         if (certFile.isEmpty()) {
             debugs(3, DBG_PARSE_NOTE(1), "WARNING: cert= option needs to be set before key= is used.");
             certFile = privateKeyFile;
         }
     } else if (strncmp(token, "version=", 8) == 0) {
         debugs(0, DBG_PARSE_NOTE(1), "UPGRADE WARNING: SSL version= is deprecated. Use options= to limit protocols instead.");
         sslVersion = xatoi(token + 8);
     } else if (strncmp(token, "min-version=", 12) == 0) {
         tlsMinVersion = SBuf(token + 12);
     } else if (strncmp(token, "options=", 8) == 0) {
         sslOptions = SBuf(token + 8);
         parsedOptions = parseOptions();
     } else if (strncmp(token, "cipher=", 7) == 0) {
         sslCipher = SBuf(token + 7);
     } else if (strncmp(token, "cafile=", 7) == 0) {
-        caFile = SBuf(token + 7);
+        caFiles.emplace_back(SBuf(token + 7));
     } else if (strncmp(token, "capath=", 7) == 0) {
         caDir = SBuf(token + 7);
+#if !USE_OPENSSL
+        debugs(3, DBG_PARSE_NOTE(1), "WARNING: capath= option requires --with-openssl.");
+#endif
     } else if (strncmp(token, "crlfile=", 8) == 0) {
         crlFile = SBuf(token + 8);
         loadCrlFile();
     } else if (strncmp(token, "flags=", 6) == 0) {
         if (parsedFlags != 0) {
             debugs(3, DBG_PARSE_NOTE(1), "WARNING: Overwriting flags=" << sslFlags << " with " << SBuf(token + 6));
         }
         sslFlags = SBuf(token + 6);
         parsedFlags = parseFlags();
     } else if (strncmp(token, "domain=", 7) == 0) {
         sslDomain = SBuf(token + 7);
     } else {
         debugs(3, DBG_CRITICAL, "ERROR: Unknown TLS option '" << token << "'");
         return;
     }
 
     encryptTransport = true;
 }
 
 void
 Security::PeerOptions::dumpCfg(Packable *p, const char *pfx) const
 {
     if (!encryptTransport) {
         p->appendf(" %sdisable", pfx);
         return; // no other settings are relevant
     }
 
     if (!certFile.isEmpty())
         p->appendf(" %scert=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(certFile));
 
     if (!privateKeyFile.isEmpty() && privateKeyFile != certFile)
         p->appendf(" %skey=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(privateKeyFile));
 
     if (!sslOptions.isEmpty())
         p->appendf(" %soptions=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslOptions));
 
     if (!sslCipher.isEmpty())
         p->appendf(" %scipher=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslCipher));
 
-    if (!caFile.isEmpty())
-        p->appendf(" %scafile=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(caFile));
+    for (auto i : caFiles) {
+        p->appendf(" %scafile=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(i));
+    }
 
     if (!caDir.isEmpty())
         p->appendf(" %scapath=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(caDir));
 
     if (!crlFile.isEmpty())
         p->appendf(" %scrlfile=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(crlFile));
 
     if (!sslFlags.isEmpty())
         p->appendf(" %sflags=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslFlags));
 }
 
 void
 Security::PeerOptions::updateTlsVersionLimits()
 {
     if (!tlsMinVersion.isEmpty()) {
         ::Parser::Tokenizer tok(tlsMinVersion);
         int64_t v = 0;
         if (tok.skip('1') && tok.skip('.') && tok.int64(v, 10, false, 1) && v <= 3) {
             // only account for TLS here - SSL versions are handled by options= parameter
             // avoid affecting options= parameter in cachemgr config report
@@ -174,51 +178,54 @@
             break;
         case 6:
             add = "NO_SSLv3,NO_TLSv1,NO_TLSv1_1";
             break;
         default: // nothing
             break;
         }
         if (add) {
             if (!sslOptions.isEmpty())
                 sslOptions.append(",",1);
             sslOptions.append(add, strlen(add));
         }
         sslVersion = 0; // prevent sslOptions being repeatedly appended
     }
 }
 
 // XXX: make a GnuTLS variant
 Security::ContextPointer
 Security::PeerOptions::createClientContext(bool setOptions)
 {
-    Security::ContextPointer t = NULL;
+    Security::ContextPointer t = nullptr;
 
     updateTlsVersionLimits();
+
 #if USE_OPENSSL
     // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
     t = sslCreateClientContext(certFile.c_str(), privateKeyFile.c_str(), sslCipher.c_str(),
-                               (setOptions ? parsedOptions : 0), parsedFlags,
-                               caFile.c_str(), caDir.c_str());
+                               (setOptions ? parsedOptions : 0), parsedFlags);
 #endif
 
-    updateContextCrl(t);
+    if (t) {
+        updateContextCa(t);
+        updateContextCrl(t);
+    }
 
     return t;
 }
 
 /// set of options we can parse and what they map to
 static struct ssl_option {
     const char *name;
     long value;
 
 } ssl_options[] = {
 
 #if SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
     {
         "NETSCAPE_REUSE_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
     },
 #endif
 #if SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
     {
         "SSLREF2_REUSE_CERT_TYPE_BUG", SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
     },
@@ -459,40 +466,74 @@
 {
     parsedCrl.clear();
     if (crlFile.isEmpty())
         return;
 
 #if USE_OPENSSL
     BIO *in = BIO_new_file(crlFile.c_str(), "r");
     if (!in) {
         debugs(83, 2, "WARNING: Failed to open CRL file " << crlFile);
         return;
     }
 
     while (X509_CRL *crl = PEM_read_bio_X509_CRL(in,NULL,NULL,NULL)) {
         parsedCrl.emplace_back(Security::CrlPointer(crl));
     }
     BIO_free(in);
 #endif
 }
 
 void
+Security::PeerOptions::updateContextCa(Security::ContextPointer &ctx)
+{
+    debugs(83, 8, "Setting CA certificate locations.");
+
+    for (auto i : caFiles) {
+#if USE_OPENSSL
+        if (!SSL_CTX_load_verify_locations(ctx, i.c_str(), caDir.c_str())) {
+            const int ssl_error = ERR_get_error();
+            debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
+        }
+#elif USE_GNUTLS
+        if (gnutls_certificate_set_x509_trust_file(ctx, i.c_str(), GNUTLS_X509_FMT_PEM) < 0) {
+            debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate location: " << i);
+        }
+#endif
+    }
+
+    if ((parsedFlags & SSL_FLAG_NO_DEFAULT_CA))
+        return;
+
+#if USE_OPENSSL
+    if (!SSL_CTX_set_default_verify_paths(ctx)) {
+        const int ssl_error = ERR_get_error();
+        debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default trusted CA : "
+               << ERR_error_string(ssl_error, NULL));
+    }
+#elif USE_GNUTLS
+    if (gnutls_certificate_set_x509_system_trust(ctx) != GNUTLS_E_SUCCESS) {
+        debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default trusted CA.");
+    }
+#endif
+}
+
+void
 Security::PeerOptions::updateContextCrl(Security::ContextPointer &ctx)
 {
 #if USE_OPENSSL
     bool verifyCrl = false;
     X509_STORE *st = SSL_CTX_get_cert_store(ctx);
     if (parsedCrl.size()) {
         for (auto &i : parsedCrl) {
             if (!X509_STORE_add_crl(st, i.get()))
                 debugs(83, 2, "WARNING: Failed to add CRL");
             else
                 verifyCrl = true;
         }
     }
 
 #if X509_V_FLAG_CRL_CHECK
     if ((parsedFlags & SSL_FLAG_VERIFY_CRL_ALL))
         X509_STORE_set_flags(st, X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
     else if (verifyCrl || (parsedFlags & SSL_FLAG_VERIFY_CRL))
         X509_STORE_set_flags(st, X509_V_FLAG_CRL_CHECK);
 #endif

=== modified file 'src/security/PeerOptions.h'
--- src/security/PeerOptions.h	2015-09-24 21:08:23 +0000
+++ src/security/PeerOptions.h	2015-09-30 13:53:12 +0000
@@ -20,68 +20,71 @@
 
 /// TLS squid.conf settings for a remote server peer
 class PeerOptions
 {
 public:
     PeerOptions() : parsedOptions(0), parsedFlags(0), sslVersion(0), encryptTransport(false) {}
     PeerOptions(const PeerOptions &);
 
     /// parse a TLS squid.conf option
     void parse(const char *);
 
     /// reset the configuration details to default
     void clear() {*this = PeerOptions();}
 
     /// generate a security client-context from these configured options
     Security::ContextPointer createClientContext(bool setOptions);
 
     /// sync the context options with tls-min-version=N configuration
     void updateTlsVersionLimits();
 
+    /// setup the CA details for the given context
+    void updateContextCa(Security::ContextPointer &);
+
     /// setup the CRL details for the given context
     void updateContextCrl(Security::ContextPointer &);
 
     /// output squid.conf syntax with 'pfx' prefix on parameters for the stored settings
     void dumpCfg(Packable *, const char *pfx) const;
 
 private:
     long parseOptions();
     long parseFlags();
     void loadCrlFile();
 
 public:
     SBuf certFile;       ///< path of file containing PEM format X509 certificate
     SBuf privateKeyFile; ///< path of file containing private key in PEM format
     SBuf sslOptions;     ///< library-specific options string
-    SBuf caFile;         ///< path of file containing trusted Certificate Authority
     SBuf caDir;          ///< path of directory containing a set of trusted Certificate Authorities
     SBuf crlFile;        ///< path of file containing Certificate Revoke List
 
     SBuf sslCipher;
     SBuf sslFlags;       ///< flags defining what TLS operations Squid performs
     SBuf sslDomain;
 
     SBuf tlsMinVersion;  ///< version label for minimum TLS version to permit
 
     long parsedOptions; ///< parsed value of sslOptions
     long parsedFlags;   ///< parsed value of sslFlags
 
+    std::list<SBuf> caFiles;  ///< paths of files containing trusted Certificate Authority
     Security::CertRevokeList parsedCrl; ///< CRL to use when verifying the remote end certificate
 
 private:
     int sslVersion;
 
 public:
     /// whether transport encryption (TLS/SSL) is to be used on connections to the peer
     bool encryptTransport;
 };
 
 /// configuration options for DIRECT server access
 extern PeerOptions ProxyOutgoingConfig;
 
 } // namespace Security
 
 // parse the tls_outgoing_options directive
 void parse_securePeerOptions(Security::PeerOptions *);
 #define free_securePeerOptions(x) Security::ProxyOutgoingConfig.clear()
 #define dump_securePeerOptions(e,n,x) do { (e)->appendf(n); (x).dumpCfg((e),""); (e)->append("\n",1); } while(false)
 

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2015-09-24 21:08:23 +0000
+++ src/ssl/support.cc	2015-09-30 12:26:01 +0000
@@ -559,53 +559,41 @@
         if (!SSL_CTX_set_cipher_list(sslContext, port.secure.sslCipher.c_str())) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" << port.secure.sslCipher << "': " << ERR_error_string(ssl_error, NULL));
             return false;
         }
     }
 
     debugs(83, 9, "Setting RSA key generation callback.");
     SSL_CTX_set_tmp_rsa_callback(sslContext, ssl_temp_rsa_cb);
 
     if (port.eecdhCurve) {
         debugs(83, 9, "Setting Ephemeral ECDH curve to " << port.eecdhCurve << ".");
 
         if (!configureSslEECDH(sslContext, port.eecdhCurve)) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Unable to configure Ephemeral ECDH: " << ERR_error_string(ssl_error, NULL));
             return false;
         }
     }
 
-    debugs(83, 9, "Setting CA certificate locations.");
-
-    const char *cafile = port.secure.caFile.isEmpty() ? port.clientca : port.secure.caFile.c_str();
-    if ((cafile || !port.secure.caDir.isEmpty()) && !SSL_CTX_load_verify_locations(sslContext, cafile, port.secure.caDir.c_str())) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
-    }
-
-    if (!(port.secure.parsedFlags & SSL_FLAG_NO_DEFAULT_CA) &&
-            !SSL_CTX_set_default_verify_paths(sslContext)) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default CA certificate location: " << ERR_error_string(ssl_error, NULL));
-    }
+    port.secure.updateContextCa(sslContext);
 
     if (port.clientCA.get()) {
         ERR_clear_error();
         if (STACK_OF(X509_NAME) *clientca = SSL_dup_CA_list(port.clientCA.get())) {
             SSL_CTX_set_client_CA_list(sslContext, clientca);
         } else {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, "ERROR: Failed to dupe the client CA list: " << ERR_error_string(ssl_error, NULL));
             return false;
         }
 
         if (port.secure.parsedFlags & SSL_FLAG_DELAYED_AUTH) {
             debugs(83, 9, "Not requesting client certificates until acl processing requires one");
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
         } else {
             debugs(83, 9, "Requiring client certificates.");
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
         }
 
         port.secure.updateContextCrl(sslContext);
@@ -695,41 +683,41 @@
         debugs(83, DBG_CRITICAL, "ERROR: Configuring static SSL context");
         SSL_CTX_free(sslContext);
         return NULL;
     }
 
     return sslContext;
 }
 
 #if defined(TLSEXT_TYPE_next_proto_neg)
 //Dummy next_proto_neg callback
 static int
 ssl_next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg)
 {
     static const unsigned char supported_protos[] = {8, 'h','t','t', 'p', '/', '1', '.', '1'};
     (void)SSL_select_next_proto(out, outlen, in, inlen, supported_protos, sizeof(supported_protos));
     return SSL_TLSEXT_ERR_OK;
 }
 #endif
 
 SSL_CTX *
-sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl, const char *CAfile, const char *CApath)
+sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl)
 {
     ssl_initialize();
 
 #if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
     SSL_CTX *sslContext = SSL_CTX_new(TLS_client_method());
 #else
     SSL_CTX *sslContext = SSL_CTX_new(SSLv23_client_method());
 #endif
 
     if (sslContext == NULL) {
         const int ssl_error = ERR_get_error();
         fatalf("Failed to allocate SSL context: %s\n",
                ERR_error_string(ssl_error, NULL));
     }
 
     SSL_CTX_set_options(sslContext, options);
 
 #if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
     SSL_CTX_set_info_callback(sslContext, ssl_info_cb);
 #endif
@@ -765,53 +753,40 @@
         debugs(83, 5, "Comparing private and public SSL keys.");
 
         if (!SSL_CTX_check_private_key(sslContext)) {
             const int ssl_error = ERR_get_error();
             fatalf("SSL private key '%s' does not match public key '%s': %s\n",
                    certfile, keyfile, ERR_error_string(ssl_error, NULL));
         }
     }
 
     debugs(83, 9, "Setting RSA key generation callback.");
     SSL_CTX_set_tmp_rsa_callback(sslContext, ssl_temp_rsa_cb);
 
     if (fl & SSL_FLAG_DONT_VERIFY_PEER) {
         debugs(83, 2, "NOTICE: Peer certificates are not verified for validity!");
         SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
     } else {
         debugs(83, 9, "Setting certificate verification callback.");
         SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
     }
 
-    debugs(83, 9, "Setting CA certificate locations.");
-
-    if ((*CAfile || *CApath) && !SSL_CTX_load_verify_locations(sslContext, CAfile, CApath)) {
-        const int ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
-    }
-
-    if (!(fl & SSL_FLAG_NO_DEFAULT_CA) &&
-            !SSL_CTX_set_default_verify_paths(sslContext)) {
-        const int ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default CA certificate location: " << ERR_error_string(ssl_error, NULL));
-    }
-
 #if defined(TLSEXT_TYPE_next_proto_neg)
     SSL_CTX_set_next_proto_select_cb(sslContext, &ssl_next_proto_cb, NULL);
 #endif
     return sslContext;
 }
 
 /// \ingroup ServerProtocolSSLInternal
 int
 ssl_read_method(int fd, char *buf, int len)
 {
     SSL *ssl = fd_table[fd].ssl;
     int i;
 
 #if DONT_DO_THIS
 
     if (!SSL_is_init_finished(ssl)) {
         errno = ENOTCONN;
         return -1;
     }
 

=== modified file 'src/ssl/support.h'
--- src/ssl/support.h	2015-09-24 21:08:23 +0000
+++ src/ssl/support.h	2015-09-30 12:20:20 +0000
@@ -73,41 +73,41 @@
 {
 public:
     ssl_error_t code; ///< certificate error code
     Security::CertPointer cert; ///< certificate with the above error code
     CertError(ssl_error_t anErr, X509 *aCert);
     CertError(CertError const &err);
     CertError & operator = (const CertError &old);
     bool operator == (const CertError &ce) const;
     bool operator != (const CertError &ce) const;
 };
 
 /// Holds a list of certificate SSL errors
 typedef CbDataList<Ssl::CertError> CertErrors;
 
 } //namespace Ssl
 
 /// \ingroup ServerProtocolSSLAPI
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port);
 
 /// \ingroup ServerProtocolSSLAPI
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags, const char *CAfile, const char *CApath);
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags);
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_read_method(int, char *, int);
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_write_method(int, const char *, int);
 
 /// \ingroup ServerProtocolSSLAPI
 void ssl_shutdown_method(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserEmail(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name);
 
 /// \ingroup ServerProtocolSSLAPI

=== modified file 'src/tests/stub_libsecurity.cc'
--- src/tests/stub_libsecurity.cc	2015-09-24 21:08:23 +0000
+++ src/tests/stub_libsecurity.cc	2015-09-30 12:21:00 +0000
@@ -4,26 +4,27 @@
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "comm/Connection.h"
 
 #define STUB_API "security/libsecurity.la"
 #include "tests/STUB.h"
 
 #include "security/EncryptorAnswer.h"
 Security::EncryptorAnswer::~EncryptorAnswer() {}
 std::ostream &Security::operator <<(std::ostream &os, const Security::EncryptorAnswer &) STUB_RETVAL(os)
 
 #include "security/PeerOptions.h"
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
 Security::ContextPointer Security::PeerOptions::createClientContext(bool) STUB_RETVAL(NULL)
 void Security::PeerOptions::updateTlsVersionLimits() STUB
+void Security::PeerOptions::updateContextCa(Security::ContextPointer &) STUB
 void Security::PeerOptions::updateContextCrl(Security::ContextPointer &) STUB
 void Security::PeerOptions::dumpCfg(Packable*, char const*) const STUB
 long Security::PeerOptions::parseOptions() STUB_RETVAL(0)
 long Security::PeerOptions::parseFlags() STUB_RETVAL(0)
 void parse_securePeerOptions(Security::PeerOptions *) STUB
 

=== modified file 'src/tests/stub_libsslsquid.cc'
--- src/tests/stub_libsslsquid.cc	2015-09-24 21:08:23 +0000
+++ src/tests/stub_libsslsquid.cc	2015-09-30 12:20:45 +0000
@@ -40,41 +40,41 @@
 void Ssl::GlobalContextStorage::reconfigureStart() STUB
 //Ssl::GlobalContextStorage Ssl::TheGlobalContextStorage;
 
 #include "ssl/ErrorDetail.h"
 Ssl::ssl_error_t parseErrorString(const char *name) STUB_RETVAL(0)
 //const char *Ssl::getErrorName(ssl_error_t value) STUB_RETVAL(NULL)
 Ssl::ErrorDetail::ErrorDetail(ssl_error_t err_no, X509 *, X509 *, const char *) STUB
 Ssl::ErrorDetail::ErrorDetail(ErrorDetail const &) STUB
 const String & Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 
 #include "ssl/support.h"
 namespace Ssl
 {
 //CertError::CertError(ssl_error_t anErr, X509 *aCert) STUB
 //CertError::CertError(CertError const &err) STUB
 CertError & CertError::operator = (const CertError &old) STUB_RETVAL(*this)
 bool CertError::operator == (const CertError &ce) const STUB_RETVAL(false)
 bool CertError::operator != (const CertError &ce) const STUB_RETVAL(false)
 } // namespace Ssl
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port) STUB_RETVAL(NULL)
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags, const char *CAfile, const char *CApath) STUB_RETVAL(NULL)
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
 void ssl_shutdown_method(SSL *ssl) STUB
 const char *sslGetUserEmail(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
 const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
 const char *sslGetUserCertificatePEM(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserCertificateChainPEM(SSL *ssl) STUB_RETVAL(NULL)
 namespace Ssl
 {
 //GETX509ATTRIBUTE GetX509UserAttribute;
 //GETX509ATTRIBUTE GetX509CAAttribute;
 //GETX509ATTRIBUTE GetX509Fingerprint;
 const char *BumpModeStr[] = {""};
 DH *readDHParams(const char *dhfile) STUB_RETVAL(NULL)
 bool generateUntrustedCert(Security::CertPointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, Security::CertPointer const & cert, EVP_PKEY_Pointer const & pkey) STUB_RETVAL(false)
 SSL_CTX * generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port) STUB_RETVAL(NULL)
 bool verifySslCertificate(SSL_CTX * sslContext,  CertificateProperties const &properties) STUB_RETVAL(false)
 SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &port) STUB_RETVAL(NULL)
 void addChainToSslContext(SSL_CTX *sslContext, STACK_OF(X509) *certList) STUB


From keith.white at emdmillipore.com  Mon Oct  5 12:25:45 2015
From: keith.white at emdmillipore.com (Keith White)
Date: Mon, 5 Oct 2015 12:25:45 +0000
Subject: [squid-dev] Squid for Windows/AD authentication
Message-ID: <344af5be191345c3a49c5c7a9d7f9f70@de35s02aexc02.ucc.merckgroup.com>

I have searched Google, tries the squid-users mail list and the Diladele forum but there doesn't seem to be much information on how to get Squid on Windows configured for AD authentication.  Are there any guides that describe how to do this?

Thanks,

Keith



This message and any attachment are confidential and may be privileged or otherwise protected from disclosure. If you are not the intended recipient, you must not copy this message or attachment or disclose the contents to any other person. If you have received this transmission in error, please notify the sender immediately and delete the message and any attachment from your system. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not accept liability for any omissions or errors in this message which may arise as a result of E-Mail-transmission or for damages resulting from any unauthorized changes of the content of this message and any attachment thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.



Click http://www.merckgroup.com/disclaimer to access the German, French, Spanish and Portuguese versions of this disclaimer.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151005/5127914d/attachment.html>

From gkinkie at gmail.com  Mon Oct  5 12:52:07 2015
From: gkinkie at gmail.com (Kinkie)
Date: Mon, 5 Oct 2015 14:52:07 +0200
Subject: [squid-dev] Squid for Windows/AD authentication
In-Reply-To: <344af5be191345c3a49c5c7a9d7f9f70@de35s02aexc02.ucc.merckgroup.com>
References: <344af5be191345c3a49c5c7a9d7f9f70@de35s02aexc02.ucc.merckgroup.com>
Message-ID: <CA+Y8hcMT8rS8u7QAD0pCrtsvWVzYZM2rGfe0brPsM3jV9Uvg=A@mail.gmail.com>

Hi,
  what you are looking for are the "SSPI" family of authentication
helpers: basic_sspi_auth, ntlm_sspi_auth, negotiate_sspi_auth.

On Mon, Oct 5, 2015 at 2:25 PM, Keith White
<keith.white at emdmillipore.com> wrote:
> I have searched Google, tries the squid-users mail list and the Diladele
> forum but there doesn’t seem to be much information on how to get Squid on
> Windows configured for AD authentication.  Are there any guides that
> describe how to do this?
>
>
>
> Thanks,
>
>
>
> Keith
>
>
>
> This message and any attachment are confidential and may be privileged or
> otherwise protected from disclosure. If you are not the intended recipient,
> you must not copy this message or attachment or disclose the contents to any
> other person. If you have received this transmission in error, please notify
> the sender immediately and delete the message and any attachment from your
> system. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not
> accept liability for any omissions or errors in this message which may arise
> as a result of E-Mail-transmission or for damages resulting from any
> unauthorized changes of the content of this message and any attachment
> thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not
> guarantee that this message is free of viruses and does not accept liability
> for any damages caused by any virus transmitted therewith.
>
>
>
> Click http://www.merckgroup.com/disclaimer to access the German, French,
> Spanish and Portuguese versions of this disclaimer.
>
>
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev
>



-- 
    Francesco

From keith.white at emdmillipore.com  Mon Oct  5 18:26:33 2015
From: keith.white at emdmillipore.com (Keith White)
Date: Mon, 5 Oct 2015 18:26:33 +0000
Subject: [squid-dev] Squid for Windows/AD authentication
In-Reply-To: <CA+Y8hcMT8rS8u7QAD0pCrtsvWVzYZM2rGfe0brPsM3jV9Uvg=A@mail.gmail.com>
References: <344af5be191345c3a49c5c7a9d7f9f70@de35s02aexc02.ucc.merckgroup.com>
 <CA+Y8hcMT8rS8u7QAD0pCrtsvWVzYZM2rGfe0brPsM3jV9Uvg=A@mail.gmail.com>
Message-ID: <946086cb74204890b74fb1c67c1dbe08@de35s02aexc02.ucc.merckgroup.com>

It doesn't appear the SSPI modules are installed.  In lib I have basic_fake_auth.exe and ntlm_fake_auth.exe

Thanks,

Keith


-----Original Message-----
From: squid-dev [mailto:squid-dev-bounces at lists.squid-cache.org] On Behalf Of Kinkie
Sent: Monday, October 05, 2015 8:52 AM
To: squid-dev at lists.squid-cache.org
Subject: Re: [squid-dev] Squid for Windows/AD authentication

Hi,
  what you are looking for are the "SSPI" family of authentication
helpers: basic_sspi_auth, ntlm_sspi_auth, negotiate_sspi_auth.

On Mon, Oct 5, 2015 at 2:25 PM, Keith White <keith.white at emdmillipore.com> wrote:
> I have searched Google, tries the squid-users mail list and the
> Diladele forum but there doesn’t seem to be much information on how to
> get Squid on Windows configured for AD authentication.  Are there any
> guides that describe how to do this?
>
>
>
> Thanks,
>
>
>
> Keith
>
>
>
> This message and any attachment are confidential and may be privileged
> or otherwise protected from disclosure. If you are not the intended
> recipient, you must not copy this message or attachment or disclose
> the contents to any other person. If you have received this
> transmission in error, please notify the sender immediately and delete
> the message and any attachment from your system. Merck KGaA,
> Darmstadt, Germany and any of its subsidiaries do not accept liability
> for any omissions or errors in this message which may arise as a
> result of E-Mail-transmission or for damages resulting from any
> unauthorized changes of the content of this message and any attachment
> thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do
> not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.
>
>
>
> Click http://www.merckgroup.com/disclaimer to access the German,
> French, Spanish and Portuguese versions of this disclaimer.
>
>
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev
>



--
    Francesco
_______________________________________________
squid-dev mailing list
squid-dev at lists.squid-cache.org
http://lists.squid-cache.org/listinfo/squid-dev


This message and any attachment are confidential and may be privileged or otherwise protected from disclosure. If you are not the intended recipient, you must not copy this message or attachment or disclose the contents to any other person. If you have received this transmission in error, please notify the sender immediately and delete the message and any attachment from your system. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not accept liability for any omissions or errors in this message which may arise as a result of E-Mail-transmission or for damages resulting from any unauthorized changes of the content of this message and any attachment thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.



Click http://www.merckgroup.com/disclaimer to access the German, French, Spanish and Portuguese versions of this disclaimer.

From Massimo.Sala at asl.bergamo.it  Tue Oct  6 11:57:27 2015
From: Massimo.Sala at asl.bergamo.it (Massimo.Sala at asl.bergamo.it)
Date: Tue, 6 Oct 2015 13:57:27 +0200
Subject: [squid-dev] squid 3.4.14, compile without ESI
Message-ID: <OFC8A6AEEA.567C6202-ONC1257ED6.00419730-C1257ED6.00416DC7@asl.bergamo.it>

Hi

I wish a basic Squid daemon listening on port 3128 ( not transparent ), 
without external helpers and fancy features.

I tried the attached configure options, but make bails out :
squid-3.4.14/src/client_side_reply.cc:2013: undefined reference to 
`esiEnableProcessing(HttpReply*)

Please, how can I disable ESI ?

[ environment : debian 8.2, linux 3.16 64 bit ]

best regards, Massimo
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: squid.txt
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151006/286e05ef/attachment.txt>

From jkeil at suse.de  Tue Oct  6 12:36:29 2015
From: jkeil at suse.de (Jochen Keil)
Date: Tue, 06 Oct 2015 14:36:29 +0200
Subject: [squid-dev] SQUID-2015:2 - Improper Protection of Alternate Path -
 patch for 3.3
Message-ID: <5613C04D.2020607@suse.de>

Hi,

attached you'll find a patch for squid 3.3 for the bug mentioned in the
subject. It would be very kind if someone could review it.

Thank you,

  Jochen

-- 
Jochen Keil
SUSE Linux GmbH,
GF: Felix Imendörffer, Jane Smithard, Graham Norton,
HRB 21284 (AG Nürnberg)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: squid-3.3_CVE-2015-5400.patch
Type: text/x-patch
Size: 21636 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151006/b4ddd52e/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 181 bytes
Desc: OpenPGP digital signature
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151006/b4ddd52e/attachment.sig>

From keith.white at emdmillipore.com  Tue Oct  6 12:51:15 2015
From: keith.white at emdmillipore.com (Keith White)
Date: Tue, 6 Oct 2015 12:51:15 +0000
Subject: [squid-dev] Squid for Windows/AD authentication
In-Reply-To: <CA+Y8hcMT8rS8u7QAD0pCrtsvWVzYZM2rGfe0brPsM3jV9Uvg=A@mail.gmail.com>
References: <344af5be191345c3a49c5c7a9d7f9f70@de35s02aexc02.ucc.merckgroup.com>
 <CA+Y8hcMT8rS8u7QAD0pCrtsvWVzYZM2rGfe0brPsM3jV9Uvg=A@mail.gmail.com>
Message-ID: <0d6ba4576ce64632964ce5c52f805fba@de35s02aexc02.ucc.merckgroup.com>

Based on what I can find it looks like the only way to get the modules is to compile squid on Windows and not use the available binary packages.  Can you please confirm this.

Thanks,

Keith


-----Original Message-----
From: squid-dev [mailto:squid-dev-bounces at lists.squid-cache.org] On Behalf Of Kinkie
Sent: Monday, October 05, 2015 8:52 AM
To: squid-dev at lists.squid-cache.org
Subject: Re: [squid-dev] Squid for Windows/AD authentication

Hi,
  what you are looking for are the "SSPI" family of authentication
helpers: basic_sspi_auth, ntlm_sspi_auth, negotiate_sspi_auth.

On Mon, Oct 5, 2015 at 2:25 PM, Keith White <keith.white at emdmillipore.com> wrote:
> I have searched Google, tries the squid-users mail list and the
> Diladele forum but there doesn’t seem to be much information on how to
> get Squid on Windows configured for AD authentication.  Are there any
> guides that describe how to do this?
>
>
>
> Thanks,
>
>
>
> Keith
>
>
>
> This message and any attachment are confidential and may be privileged
> or otherwise protected from disclosure. If you are not the intended
> recipient, you must not copy this message or attachment or disclose
> the contents to any other person. If you have received this
> transmission in error, please notify the sender immediately and delete
> the message and any attachment from your system. Merck KGaA,
> Darmstadt, Germany and any of its subsidiaries do not accept liability
> for any omissions or errors in this message which may arise as a
> result of E-Mail-transmission or for damages resulting from any
> unauthorized changes of the content of this message and any attachment
> thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do
> not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.
>
>
>
> Click http://www.merckgroup.com/disclaimer to access the German,
> French, Spanish and Portuguese versions of this disclaimer.
>
>
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev
>



--
    Francesco
_______________________________________________
squid-dev mailing list
squid-dev at lists.squid-cache.org
http://lists.squid-cache.org/listinfo/squid-dev


This message and any attachment are confidential and may be privileged or otherwise protected from disclosure. If you are not the intended recipient, you must not copy this message or attachment or disclose the contents to any other person. If you have received this transmission in error, please notify the sender immediately and delete the message and any attachment from your system. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not accept liability for any omissions or errors in this message which may arise as a result of E-Mail-transmission or for damages resulting from any unauthorized changes of the content of this message and any attachment thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.



Click http://www.merckgroup.com/disclaimer to access the German, French, Spanish and Portuguese versions of this disclaimer.

From gkinkie at gmail.com  Tue Oct  6 13:12:34 2015
From: gkinkie at gmail.com (Kinkie)
Date: Tue, 6 Oct 2015 15:12:34 +0200
Subject: [squid-dev] squid 3.4.14, compile without ESI
In-Reply-To: <OFC8A6AEEA.567C6202-ONC1257ED6.00419730-C1257ED6.00416DC7@asl.bergamo.it>
References: <OFC8A6AEEA.567C6202-ONC1257ED6.00419730-C1257ED6.00416DC7@asl.bergamo.it>
Message-ID: <CA+Y8hcNfU_FC4+biW0jN_snfU_gygKnkAhOHHAd0=+E9eoVMpw@mail.gmail.com>

Hi Massimo,
   what arguments are you using for ./configure?

$ ./configure --help|fgrep -i esi
 --enable-esi            Enable ESI for accelerators. Benefits from expat or
                         libxml2. Enabling ESI will cause squid reverse
                         proxies to be capable of the Edge Acceleration
                         Specification (www.esi.org).

ESI should be off by default. If it isn't, --disable-esi will force that.

On Tue, Oct 6, 2015 at 1:57 PM,  <Massimo.Sala at asl.bergamo.it> wrote:
> Hi
>
> I wish a basic Squid daemon listening on port 3128 ( not transparent ),
> without external helpers and fancy features.
>
> I tried the attached configure options, but make bails out :
> squid-3.4.14/src/client_side_reply.cc:2013: undefined reference to
> `esiEnableProcessing(HttpReply*)
>
> Please, how can I disable ESI ?
>
> [ environment : debian 8.2, linux 3.16 64 bit ]
>
> best regards, Massimo
>
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev
>



-- 
    Francesco

From gkinkie at gmail.com  Tue Oct  6 13:33:39 2015
From: gkinkie at gmail.com (Kinkie)
Date: Tue, 6 Oct 2015 15:33:39 +0200
Subject: [squid-dev] Squid for Windows/AD authentication
In-Reply-To: <0d6ba4576ce64632964ce5c52f805fba@de35s02aexc02.ucc.merckgroup.com>
References: <344af5be191345c3a49c5c7a9d7f9f70@de35s02aexc02.ucc.merckgroup.com>
 <CA+Y8hcMT8rS8u7QAD0pCrtsvWVzYZM2rGfe0brPsM3jV9Uvg=A@mail.gmail.com>
 <0d6ba4576ce64632964ce5c52f805fba@de35s02aexc02.ucc.merckgroup.com>
Message-ID: <CA+Y8hcNLQMhQ59oD0N7_PKYiQprJNoTyRRC-wQTYvRhvS=Qv2A@mail.gmail.com>

Hi,
  you'd have to ask to who supplied you the binary packages. The squid
project only distributes in source form, and there is no plan that I
am aware of to change that.
Unfortunately, setting a build environment up on Windows is not easy.

On Tue, Oct 6, 2015 at 2:51 PM, Keith White
<keith.white at emdmillipore.com> wrote:
> Based on what I can find it looks like the only way to get the modules is to compile squid on Windows and not use the available binary packages.  Can you please confirm this.
>
> Thanks,
>
> Keith
>
>
> -----Original Message-----
> From: squid-dev [mailto:squid-dev-bounces at lists.squid-cache.org] On Behalf Of Kinkie
> Sent: Monday, October 05, 2015 8:52 AM
> To: squid-dev at lists.squid-cache.org
> Subject: Re: [squid-dev] Squid for Windows/AD authentication
>
> Hi,
>   what you are looking for are the "SSPI" family of authentication
> helpers: basic_sspi_auth, ntlm_sspi_auth, negotiate_sspi_auth.
>
> On Mon, Oct 5, 2015 at 2:25 PM, Keith White <keith.white at emdmillipore.com> wrote:
>> I have searched Google, tries the squid-users mail list and the
>> Diladele forum but there doesn’t seem to be much information on how to
>> get Squid on Windows configured for AD authentication.  Are there any
>> guides that describe how to do this?
>>
>>
>>
>> Thanks,
>>
>>
>>
>> Keith
>>
>>
>>
>> This message and any attachment are confidential and may be privileged
>> or otherwise protected from disclosure. If you are not the intended
>> recipient, you must not copy this message or attachment or disclose
>> the contents to any other person. If you have received this
>> transmission in error, please notify the sender immediately and delete
>> the message and any attachment from your system. Merck KGaA,
>> Darmstadt, Germany and any of its subsidiaries do not accept liability
>> for any omissions or errors in this message which may arise as a
>> result of E-Mail-transmission or for damages resulting from any
>> unauthorized changes of the content of this message and any attachment
>> thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do
>> not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.
>>
>>
>>
>> Click http://www.merckgroup.com/disclaimer to access the German,
>> French, Spanish and Portuguese versions of this disclaimer.
>>
>>
>> _______________________________________________
>> squid-dev mailing list
>> squid-dev at lists.squid-cache.org
>> http://lists.squid-cache.org/listinfo/squid-dev
>>
>
>
>
> --
>     Francesco
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev
>
>
> This message and any attachment are confidential and may be privileged or otherwise protected from disclosure. If you are not the intended recipient, you must not copy this message or attachment or disclose the contents to any other person. If you have received this transmission in error, please notify the sender immediately and delete the message and any attachment from your system. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not accept liability for any omissions or errors in this message which may arise as a result of E-Mail-transmission or for damages resulting from any unauthorized changes of the content of this message and any attachment thereto. Merck KGaA, Darmstadt, Germany and any of its subsidiaries do not guarantee that this message is free of viruses and does not accept liability for any damages caused by any virus transmitted therewith.
>
>
>
> Click http://www.merckgroup.com/disclaimer to access the German, French, Spanish and Portuguese versions of this disclaimer.



-- 
    Francesco

From rousskov at measurement-factory.com  Wed Oct  7 15:05:07 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Wed, 7 Oct 2015 09:05:07 -0600
Subject: [squid-dev] [PATCH] external_acl_type logformat tokens
In-Reply-To: <560F933B.8040804@treenet.co.nz>
References: <560F933B.8040804@treenet.co.nz>
Message-ID: <561534A3.1090406@measurement-factory.com>

On 10/03/2015 02:35 AM, Amos Jeffries wrote:
> Update the external_acl_type helper interface to use libformat and thus
> make any logformat token valid in its format parameter field.
> 
> As a result much of the logic surrounding format code parsing, display
> and helper query generation has been completely dropped. What remains is
> a basic parse loop handling backward compatibility for the unusual
> %CERT_* token syntax, space delimiter and field default encodings.
> 
> 
> Extensions to logformat resulting from the merger:
> 
> * adds \-escape encoding of output fields
> 
> * allows {arg} field to be placed before or after the format code.
> 
> * extended to accept the old external_acl_type %macros. But not
> documented, these are deprecated and only for backward compatibility.
> 
> * extended to support outputting formats without a format-name prefix.

Please rephrase/clarify the last bullet in the commit message. I do not
know what that last bullet means.



> The major side effect of this change is that these ACLs now require
> AccessLogEntry to be filled out with state data, rather than just the
> ACLChecklist object members.
> 
> The requires*() mechanism of ACLChecklist has been extended to catch
> some cases resulting from missing the ALE entirely. But it cannot catch
> the more subtle problem of data members inside the ALE being unset.


Agreed. I expect lots of small but time-wasting and
deployment-preventing bugs because of that change.

Would it be possible to avoid most of those problems by using the
following approach?

1. If both hasAleXXX() and requiresAleXXX() are true in
   ACL::matches(), call a new virtual checklist->syncAle() method.

2. Add FilledChecklist::syncAle() method that fills unset ALE data
   members with data from the checklist object, where possible. This
   can be limited to external_acl_type-relevant fields if needed.

3. If any ALE data member is filled in #2, print a level-1 warning.
   Do not print more than a few such warnings per worker lifetime.

The above plan is meant to alert us of the bugs introduced by this
change without actually exposing admins to those bugs (except for the
warning and a small performance penalty).

Please let me know if the above sketch is not detailed enough to follow.


> +    virtual bool requiresAleXXX() const {return true;}

I do not think this really warrants an XXX because I see nothing
seriously wrong with this method. Same for hasAleXXX().


>      // Why is this a sub-class and not a set of real "private:" fields?
>      // TODO: shuffle this to the relevant ICP/HTCP protocol section
>      class Private
>      {
>  
>      public:
> -        Private() : method_str(NULL) {}
> +        Private() : method_str(NULL), lastAclName(NULL), lastAclData(NULL) {}
> +        ~Private() {
> +            safe_free(lastAclName);
> +            safe_free(lastAclData);
> +        }
>  
>          const char *method_str;
> +        const char *lastAclName; ///< string for external_acl_type %ACL format code
> +        const char *lastAclData; ///< string for external_acl_type %DATA format code
> +
>      } _private;


Why exacerbate the existing problem by adding more fields to _private
instead of just adding those fields to the "public:" section? Just give
them names specific to external_acl_type to emphasize that these fields
are not generally available (which is true for many ALE fields). You can
even create a dedicated sub-class for them, like we already do for
protocols!

Eventually, we may decide to support lastAclName for access_log (and
other contexts?) as well.



> +            safe_free(lastAclData);
...
> +            ch->al->_private.lastAclData = sb.c_str();

The combination looks wrong to me. c_str() does not allocate a new
c-string AFAICT.


Please also check the patch for out-of-scope or needless whitespace changes.

This is not a full/detailed audit, but I do not expect to be able to do
more in the foreseeable future. Consider pinging Christos if you need a
second opinion -- he knows this code well.


Thank you,

Alex.


From chtsanti at users.sourceforge.net  Wed Oct  7 15:11:04 2015
From: chtsanti at users.sourceforge.net (Tsantilas Christos)
Date: Wed, 7 Oct 2015 18:11:04 +0300
Subject: [squid-dev] [PATCH] %ssl::<cert_errors logformat code
In-Reply-To: <560AAA21.90707@users.sourceforge.net>
References: <55FA7508.4000200@users.sourceforge.net>
 <5603F683.6040404@treenet.co.nz> <560AAA21.90707@users.sourceforge.net>
Message-ID: <56153608.1080709@users.sourceforge.net>

If there is not any objection  I will apply this patch to trunk.



On 09/29/2015 06:11 PM, Tsantilas Christos wrote:
> A new version of this patch.
>
> On 09/24/2015 04:11 PM, Amos Jeffries wrote:
>> On 17/09/2015 8:08 p.m., Tsantilas Christos wrote:
>>>
>>> Currently Squid with SSL bumping only logs SSL errors that have caused
>>> Squid to block traffic. It does not log SSL errors that are mimicked.
>>> Logging a list with all encountered (and ignored) errors is interesting
>>> for debugging and statistics reasons.
>>>
>>> The new %ssl::<cert_errors logformat code lists server certificate
>>> validation errors detected by Squid (including OpenSSL and the
>>> certificate validation helper components)
>>>
>>> This is a Measurement Factory project
>>>
>>
>> in cf.data.pre:
>>
>> * Please leave a 1-line whitespace gap between these very long
>> descriptions. Same as you can see above the cert_issuer option
>> description.
>>
>>
>> in src/format/Format.cc:
>>
>> * please shuffle the switch case up above the two "not implemented"
>> existing ones.
>>
>>   * Also leave whitespace around the new case code. The existing ones are
>> only squashed together since they both fall through to the same break.
>>
>> * sslErrorName can be a static function local to this .cc
>>   - that avoids the need to touch Format.h
>
> all of the above fixed in this new patch.
>
>
>>
>>
>> Amos
>>
>> _______________________________________________
>> squid-dev mailing list
>> squid-dev at lists.squid-cache.org
>> http://lists.squid-cache.org/listinfo/squid-dev
>>
>
>
>
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev
>


From Massimo.Sala at asl.bergamo.it  Wed Oct  7 17:11:59 2015
From: Massimo.Sala at asl.bergamo.it (Massimo.Sala at asl.bergamo.it)
Date: Wed, 7 Oct 2015 19:11:59 +0200
Subject: [squid-dev]  squid 3.4.14, compile without ESI
In-Reply-To: <OFC8A6AEEA.567C6202-ONC1257ED6.00419730-C1257ED6.00416DC7@asl.bergamo.it>
Message-ID: <OFEA5F4BA0.0D48A61B-ONC1257ED7.005E0628-C1257ED7.005E4231@asl.bergamo.it>

with these "minimal build" the compilation is successfull :

--build=x86_64-linux-gnu --prefix=/usr --includedir=${prefix}/include 
--mandir=${prefix}/share/man --infodir=${prefix}/share/info 
--sysconfdir=/etc
--localstatedir=/var --libexecdir=${prefix}/lib/squid3 --srcdir=.
--datadir=/usr/share/squid3 --sysconfdir=/etc/squid3 
--mandir=/usr/share/man
--with-swapdir=/var/spool/squid3 --with-logdir=/var/log/squid3 
--with-pidfile=/var/run/squid3.pid
--with-filedescriptors=65536 --with-large-files --with-default-user=proxy
--disable-maintainer-mode --disable-dependency-tracking 
--enable-silent-rules --disable-translation --disable-auto-locale

# esx guest VM
--disable-arch-native

--enable-async-io=8 --enable-storeio=ufs 
--enable-removal-policies=lru,heap
--enable-delay-pools --enable-kill-parent-hack

--disable-ipv6 --disable-pf-transparent --disable-linux-netfilter
--disable-icmp --disable-internal-dns --disable-snmp --disable-unlinkd
--disable-auth --disable-ident-lookups --disable-cache-digests
--disable-eui --disable-htcp --disable-loadable-modules --disable-wccp 
--disable-wccpv2

# debugging
--enable-xmalloc-statistics --enable-stacktraces --disable-inline 
--disable-optimizations



many thanks, Massimo


From vel21ripn at gmail.com  Wed Oct  7 18:16:25 2015
From: vel21ripn at gmail.com (Vitaly Lavrov)
Date: Wed, 07 Oct 2015 21:16:25 +0300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
Message-ID: <56156179.1040708@gmail.com>

Bug 4279: No response from proxy for FTP-download of non-existing file

There is no code to handle errors ftp-protocol functions ftpFail().
The patch forms a response to the client an error similar to loginFailed().
To handle specific errors, you must add code in failedHttpStatus().

If you add to the template ERR_FTP_NOT_FOUND macro "%g", then the client
will be seen the original message server (550: Permission denied/File not found)

Patch tested on squid-3.5.9
-------------- next part --------------
A non-text attachment was scrubbed...
Name: squid-3.5-ftp_error_handle.diff
Type: text/x-diff
Size: 2174 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151007/c011b79d/attachment.diff>

From vel21ripn at gmail.com  Wed Oct  7 18:38:18 2015
From: vel21ripn at gmail.com (Vitaly Lavrov)
Date: Wed, 07 Oct 2015 21:38:18 +0300
Subject: [squid-dev] [PATCH] squid-3.5: use ACL rep_mime_type in delay_access
Message-ID: <5615669A.5060000@gmail.com>

This worked in squid-2X, but does not work in versions 3.X.
I offer a patch that allows you to use ACL-type "rep_mime_type" in delay_access.
Patch for squid-3.5.9.
This patch working from 3.4.2+ more than one years.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: squid-3.5-acl_repmime_type_delay_access.diff
Type: text/x-diff
Size: 1673 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151007/fe98f744/attachment.diff>

From rousskov at measurement-factory.com  Wed Oct  7 19:47:21 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Wed, 7 Oct 2015 13:47:21 -0600
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <56156179.1040708@gmail.com>
References: <56156179.1040708@gmail.com>
Message-ID: <561576C9.2080504@measurement-factory.com>

On 10/07/2015 12:16 PM, Vitaly Lavrov wrote:
> Bug 4279: No response from proxy for FTP-download of non-existing file
> 
> There is no code to handle errors ftp-protocol functions ftpFail().
> The patch forms a response to the client an error similar to loginFailed().
> To handle specific errors, you must add code in failedHttpStatus().
> 
> If you add to the template ERR_FTP_NOT_FOUND macro "%g", then the client
> will be seen the original message server (550: Permission denied/File
> not found)
> 
> Patch tested on squid-3.5.9


Hello Vitaly,

    I am glad you were able to fix the problem, and I thank you for
sharing your fix.

Unfortunately, the patch itself needs significant refactoring because
you are [incorrectly] duplicating an already duplicated code. As you
probably know, most of the code you added already exists in
Ftp::Gateway::loginFailed() and, more importantly, in
Ftp::Client::failed(). We do not need a third imperfect copy of that logic!

Somebody should examine your additions as well as the existing two
methods and carefully merge them, keeping Ftp::Relay needs in mind. If
you can help with that, I would recommend the following first steps:

0. Undo your changes (the code may be reused at step #3).

1. Add an optional ErrorState *err parameter to ftpFail() with a default
NULL value. When the parameter is not nil, ftpFail() should use it
instead of creating its own ErrorState.

2. Change Ftp::Gateway::loginFailed() to always call ftpFail() after
trying to create an ErrorState. Move the bottom of
Ftp::Gateway::loginFailed() (i.e., the code that handles non-nil err) to
ftpFail(). Test the refactored code for regressions. This change will
not fix the bug you are after.

3. Compare the resulting ftpFail() with the code from your patch. Add
any missing actions. Test that the resulting code works fine, including
handling the bug you are after.

More work will be needed after the above steps to remove duplication
with Ftp::Client::failed(), but these steps would move us a lot closer
to that final goal.


HTH,

Alex.


From vel21ripn at gmail.com  Thu Oct  8 14:15:58 2015
From: vel21ripn at gmail.com (Vitaly Lavrov)
Date: Thu, 8 Oct 2015 17:15:58 +0300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <561576C9.2080504@measurement-factory.com>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com>
Message-ID: <56167A9E.3020907@gmail.com>

On 07.10.2015 22:47, Alex Rousskov wrote:

Hello Alex.

Thanks for the quick response.
> Hello Vitaly,
>
>      I am glad you were able to fix the problem, and I thank you for
> sharing your fix.
>
> Unfortunately, the patch itself needs significant refactoring because
> you are [incorrectly] duplicating an already duplicated code. As you
> probably know, most of the code you added already exists in
> Ftp::Gateway::loginFailed() and, more importantly, in
> Ftp::Client::failed(). We do not need a third imperfect copy of that logic!
Yes, agree!
> 0. Undo your changes (the code may be reused at step #3).
>
> 1. Add an optional ErrorState *err parameter to ftpFail() with a default
> NULL value. When the parameter is not nil, ftpFail() should use it
> instead of creating its own ErrorState.
>
> 2. Change Ftp::Gateway::loginFailed() to always call ftpFail() after
> trying to create an ErrorState. Move the bottom of
> Ftp::Gateway::loginFailed() (i.e., the code that handles non-nil err) to
> ftpFail(). Test the refactored code for regressions. This change will
> not fix the bug you are after.
>
> 3. Compare the resulting ftpFail() with the code from your patch. Add
> any missing actions. Test that the resulting code works fine, including
> handling the bug you are after.
I added a field "ErrorState *ftperr" in class Ftp::Client. If it is not NULL,
the Ftp::Client::failed() uses it. Through "ftperr" also passed httpStatus correct and error-code.
Duplicate code in loginFailed() and ftpFail() removed.

See the new version of the patch.

I can not test all variants of handling errors when using the protocol ftp.
I checked for proper operation without anonymous access, and anonymous access
to the available file, missing file, missing directory in the file path and
the file inaccessible due to permissions.

>
> More work will be needed after the above steps to remove duplication
> with Ftp::Client::failed(), but these steps would move us a lot closer
> to that final goal.
>
> HTH,
>
> Alex.
>


-------------- next part --------------
A non-text attachment was scrubbed...
Name: squid-3.5-ftp_error_handle2.diff
Type: text/x-patch
Size: 5174 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151008/cf0147fe/attachment.bin>

From chtsanti at users.sourceforge.net  Thu Oct  8 17:21:09 2015
From: chtsanti at users.sourceforge.net (Tsantilas Christos)
Date: Thu, 8 Oct 2015 20:21:09 +0300
Subject: [squid-dev] [PATCH] %ssl::<cert_errors logformat code
In-Reply-To: <56153608.1080709@users.sourceforge.net>
References: <55FA7508.4000200@users.sourceforge.net>
 <5603F683.6040404@treenet.co.nz> <560AAA21.90707@users.sourceforge.net>
 <56153608.1080709@users.sourceforge.net>
Message-ID: <5616A605.90605@users.sourceforge.net>

Patch applied to trunk as r14343.

On 10/07/2015 06:11 PM, Tsantilas Christos wrote:
> If there is not any objection  I will apply this patch to trunk.
>
>
>
> On 09/29/2015 06:11 PM, Tsantilas Christos wrote:
>> A new version of this patch.
>>
>> On 09/24/2015 04:11 PM, Amos Jeffries wrote:
>>> On 17/09/2015 8:08 p.m., Tsantilas Christos wrote:
>>>>
>>>> Currently Squid with SSL bumping only logs SSL errors that have caused
>>>> Squid to block traffic. It does not log SSL errors that are mimicked.
>>>> Logging a list with all encountered (and ignored) errors is interesting
>>>> for debugging and statistics reasons.
>>>>
>>>> The new %ssl::<cert_errors logformat code lists server certificate
>>>> validation errors detected by Squid (including OpenSSL and the
>>>> certificate validation helper components)
>>>>
>>>> This is a Measurement Factory project
>>>>
>>>
>>> in cf.data.pre:
>>>
>>> * Please leave a 1-line whitespace gap between these very long
>>> descriptions. Same as you can see above the cert_issuer option
>>> description.
>>>
>>>
>>> in src/format/Format.cc:
>>>
>>> * please shuffle the switch case up above the two "not implemented"
>>> existing ones.
>>>
>>>   * Also leave whitespace around the new case code. The existing ones
>>> are
>>> only squashed together since they both fall through to the same break.
>>>
>>> * sslErrorName can be a static function local to this .cc
>>>   - that avoids the need to touch Format.h
>>
>> all of the above fixed in this new patch.
>>
>>
>>>
>>>
>>> Amos
>>>
>>> _______________________________________________
>>> squid-dev mailing list
>>> squid-dev at lists.squid-cache.org
>>> http://lists.squid-cache.org/listinfo/squid-dev
>>>
>>
>>
>>
>> _______________________________________________
>> squid-dev mailing list
>> squid-dev at lists.squid-cache.org
>> http://lists.squid-cache.org/listinfo/squid-dev
>>
>
> _______________________________________________
> squid-dev mailing list
> squid-dev at lists.squid-cache.org
> http://lists.squid-cache.org/listinfo/squid-dev


From noc at squid-cache.org  Thu Oct  8 20:06:42 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Thu, 8 Oct 2015 20:06:42 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #886
Message-ID: <1056169414.471.1444334802787.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/886/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 381
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14343 chtsanti at users.sourceforge.net-20151008172027-5twir6w6hqxywaht
" stderr: ""
RevisionState revno:14343 revid:chtsanti at users.sourceforge.net-20151008172027-5twir6w6hqxywaht
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson7158833938331688377.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 886 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From squid3 at treenet.co.nz  Fri Oct  9 01:45:37 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 9 Oct 2015 14:45:37 +1300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <56167A9E.3020907@gmail.com>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
Message-ID: <56171C41.1090105@treenet.co.nz>

On 9/10/2015 3:15 a.m., Vitaly Lavrov wrote:
> On 07.10.2015 22:47, Alex Rousskov wrote:
> 
> Hello Alex.
> 
> Thanks for the quick response.
>> Hello Vitaly,
>>
>>      I am glad you were able to fix the problem, and I thank you for
>> sharing your fix.
>>
>> Unfortunately, the patch itself needs significant refactoring because
>> you are [incorrectly] duplicating an already duplicated code. As you
>> probably know, most of the code you added already exists in
>> Ftp::Gateway::loginFailed() and, more importantly, in
>> Ftp::Client::failed(). We do not need a third imperfect copy of that
>> logic!
> Yes, agree!
>> 0. Undo your changes (the code may be reused at step #3).
>>
>> 1. Add an optional ErrorState *err parameter to ftpFail() with a default
>> NULL value. When the parameter is not nil, ftpFail() should use it
>> instead of creating its own ErrorState.
>>
>> 2. Change Ftp::Gateway::loginFailed() to always call ftpFail() after
>> trying to create an ErrorState. Move the bottom of
>> Ftp::Gateway::loginFailed() (i.e., the code that handles non-nil err) to
>> ftpFail(). Test the refactored code for regressions. This change will
>> not fix the bug you are after.
>>
>> 3. Compare the resulting ftpFail() with the code from your patch. Add
>> any missing actions. Test that the resulting code works fine, including
>> handling the bug you are after.
> I added a field "ErrorState *ftperr" in class Ftp::Client. If it is not
> NULL,
> the Ftp::Client::failed() uses it.

This is not what Alex meant by parameter.

Function parameter is passed by the caller directly and only exists
within the specific function call chain where it was passed. It cannot
remain in memory interferring with other state or operations, does not
need any extra constructor/destructor infrastructure code to manage its
existence, and the value of the pointer being NULL/non-NULL can be used
as the boolean of whether to use it or not.

A member like ftperr may be setup by some earlier FTP transaction an
unknown number of steps and time prior to the current error happening.
Then prevents any following errors from using their own ErrorState
object with details about the second error.

For example; if you have some minor error early in the protocol that the
code causes to be ignored (because its minor), then something major like
login could get an irrelevant error page displayed and break the login
process.


> Through "ftperr" also passed
> httpStatus correct and error-code.
> Duplicate code in loginFailed() and ftpFail() removed.
> 
> See the new version of the patch.
> 
> I can not test all variants of handling errors when using the protocol ftp.
> I checked for proper operation without anonymous access, and anonymous
> access
> to the available file, missing file, missing directory in the file path and
> the file inaccessible due to permissions.
> 
>>
>> More work will be needed after the above steps to remove duplication
>> with Ftp::Client::failed(), but these steps would move us a lot closer
>> to that final goal.
>>

This new patch is making things even more complicated than they started
off just by using that new member. Alexs' suggestion was a specific set
of steps that when followed reduces complexity.

Amos


From squid3 at treenet.co.nz  Fri Oct  9 02:10:42 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 9 Oct 2015 15:10:42 +1300
Subject: [squid-dev] SQUID-2015:2 - Improper Protection of Alternate
 Path - patch for 3.3
In-Reply-To: <5613C04D.2020607@suse.de>
References: <5613C04D.2020607@suse.de>
Message-ID: <56172222.9070606@treenet.co.nz>

On 7/10/2015 1:36 a.m., Jochen Keil wrote:
> Hi,
> 
> attached you'll find a patch for squid 3.3 for the bug mentioned in the
> subject. It would be very kind if someone could review it.
> 
> Thank you,
> 
>   Jochen
> 

Sorry for the slow response.

I think can reduce this patch size a bit by omitting the parts doing
CBDATA class conversion of TunnelStateData. That is all the toCbdata(),
constructor/destructor and new/delete operator chunks.

Please compare it against Raphaels patch for 3.1 which is a lot closer
in code requirements to 3.3 than the 3.4+ series patches. You may be
able to find further reductions from that comparison.
<http://www.squid-cache.org/Versions/v3/3.1/changesets/squid-3.1-10494.patch>

Amos


From squid3 at treenet.co.nz  Fri Oct  9 03:42:23 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 9 Oct 2015 16:42:23 +1300
Subject: [squid-dev] [PATCH] crypto-ng: CA support for GnuTLS
In-Reply-To: <560F9557.9040308@treenet.co.nz>
References: <560F9557.9040308@treenet.co.nz>
Message-ID: <5617379F.6020901@treenet.co.nz>

On 3/10/2015 9:44 p.m., Amos Jeffries wrote:
> Shuffle the cafile= context logics to libsecurity class PeerOptions.
> 
> * Rename the parameter tls-cafile= and allow multiple cafile= entries to
> be used in squid.conf.
> 
> * Document the capath= option as only supported by OpenSSL and LibreSSL.
> 
> * Add GnuTLS support for CA loading.
>  Although at this point GnuTLS contexts are not yet created.
> 

Applied as trunk rev.14345

Amos


From squid3 at treenet.co.nz  Fri Oct  9 04:56:47 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 9 Oct 2015 17:56:47 +1300
Subject: [squid-dev] [PATCH] external_acl_type logformat tokens
In-Reply-To: <561534A3.1090406@measurement-factory.com>
References: <560F933B.8040804@treenet.co.nz>
 <561534A3.1090406@measurement-factory.com>
Message-ID: <5617490E.8070401@treenet.co.nz>

On 8/10/2015 4:05 a.m., Alex Rousskov wrote:
> On 10/03/2015 02:35 AM, Amos Jeffries wrote:
>> Update the external_acl_type helper interface to use libformat and thus
>> make any logformat token valid in its format parameter field.
>>
>> As a result much of the logic surrounding format code parsing, display
>> and helper query generation has been completely dropped. What remains is
>> a basic parse loop handling backward compatibility for the unusual
>> %CERT_* token syntax, space delimiter and field default encodings.
>>
>>
>> Extensions to logformat resulting from the merger:
>>
>> * adds \-escape encoding of output fields
>>
>> * allows {arg} field to be placed before or after the format code.
>>
>> * extended to accept the old external_acl_type %macros. But not
>> documented, these are deprecated and only for backward compatibility.
>>
>> * extended to support outputting formats without a format-name prefix.
> 
> Please rephrase/clarify the last bullet in the commit message. I do not
> know what that last bullet means.
> 

The Format dumper routines are currently hard-coded for logformat
directive which begins with a format name field.
This patch makes that field optional, so formats can be output inline
with other directives like external_acl_type which has no format name.


> 
>> The major side effect of this change is that these ACLs now require
>> AccessLogEntry to be filled out with state data, rather than just the
>> ACLChecklist object members.
>>
>> The requires*() mechanism of ACLChecklist has been extended to catch
>> some cases resulting from missing the ALE entirely. But it cannot catch
>> the more subtle problem of data members inside the ALE being unset.
> 
> 
> Agreed. I expect lots of small but time-wasting and
> deployment-preventing bugs because of that change.
> 
> Would it be possible to avoid most of those problems by using the
> following approach?
> 
> 1. If both hasAleXXX() and requiresAleXXX() are true in
>    ACL::matches(), call a new virtual checklist->syncAle() method.
> 
> 2. Add FilledChecklist::syncAle() method that fills unset ALE data
>    members with data from the checklist object, where possible. This
>    can be limited to external_acl_type-relevant fields if needed.
> 
> 3. If any ALE data member is filled in #2, print a level-1 warning.
>    Do not print more than a few such warnings per worker lifetime.
> 
> The above plan is meant to alert us of the bugs introduced by this
> change without actually exposing admins to those bugs (except for the
> warning and a small performance penalty).
> 
> Please let me know if the above sketch is not detailed enough to follow.
> 

Sounds reasonable. Adding it.

> 
>> +    virtual bool requiresAleXXX() const {return true;}
> 
> I do not think this really warrants an XXX because I see nothing
> seriously wrong with this method. Same for hasAleXXX().
> 
> 

Ok, done.

>>      // Why is this a sub-class and not a set of real "private:" fields?
>>      // TODO: shuffle this to the relevant ICP/HTCP protocol section
>>      class Private
>>      {
>>  
>>      public:
>> -        Private() : method_str(NULL) {}
>> +        Private() : method_str(NULL), lastAclName(NULL), lastAclData(NULL) {}
>> +        ~Private() {
>> +            safe_free(lastAclName);
>> +            safe_free(lastAclData);
>> +        }
>>  
>>          const char *method_str;
>> +        const char *lastAclName; ///< string for external_acl_type %ACL format code
>> +        const char *lastAclData; ///< string for external_acl_type %DATA format code
>> +
>>      } _private;
> 
> 
> Why exacerbate the existing problem by adding more fields to _private
> instead of just adding those fields to the "public:" section? Just give
> them names specific to external_acl_type to emphasize that these fields
> are not generally available (which is true for many ALE fields). You can
> even create a dedicated sub-class for them, like we already do for
> protocols!
> 
> Eventually, we may decide to support lastAclName for access_log (and
> other contexts?) as well.

Okay. Dropped to the upper level.


> 
>> +            safe_free(lastAclData);
> ...
>> +            ch->al->_private.lastAclData = sb.c_str();
> 
> The combination looks wrong to me. c_str() does not allocate a new
> c-string AFAICT.

Good catch. Fixed.

> 
> Please also check the patch for out-of-scope or needless whitespace changes.
> 
> This is not a full/detailed audit, but I do not expect to be able to do
> more in the foreseeable future. Consider pinging Christos if you need a
> second opinion -- he knows this code well.
> 

Thank you.

Amos
-------------- next part --------------
=== modified file 'src/AccessLogEntry.cc'
--- src/AccessLogEntry.cc	2015-01-13 07:25:36 +0000
+++ src/AccessLogEntry.cc	2015-10-08 09:14:03 +0000
@@ -45,28 +45,31 @@
 
     if (!log_ip.isLocalhost() && log_ip.isIPv4())
         log_ip.applyMask(Config.Addrs.client_netmask);
 
     log_ip.toStr(buf, bufsz);
 }
 
 AccessLogEntry::~AccessLogEntry()
 {
     safe_free(headers.request);
 
 #if USE_ADAPTATION
     safe_free(adapt.last_meta);
 #endif
 
     safe_free(headers.reply);
 
     safe_free(headers.adapted_request);
     HTTPMSGUNLOCK(adapted_request);
 
+    safe_free(lastAclName);
+    safe_free(lastAclData);
+
     HTTPMSGUNLOCK(reply);
     HTTPMSGUNLOCK(request);
 #if ICAP_CLIENT
     HTTPMSGUNLOCK(icap.reply);
     HTTPMSGUNLOCK(icap.request);
 #endif
 }
 

=== modified file 'src/AccessLogEntry.h'
--- src/AccessLogEntry.h	2015-09-14 16:25:05 +0000
+++ src/AccessLogEntry.h	2015-10-08 09:13:35 +0000
@@ -22,42 +22,48 @@
 #include "MessageSizes.h"
 #include "Notes.h"
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
 #if USE_OPENSSL
 #include "ssl/gadgets.h"
 #endif
 
 /* forward decls */
 class HttpReply;
 class HttpRequest;
 class CustomLog;
 
 class AccessLogEntry: public RefCountable
 {
 
 public:
     typedef RefCount<AccessLogEntry> Pointer;
 
-    AccessLogEntry() : url(NULL), tcpClient(), reply(NULL), request(NULL),
-        adapted_request(NULL) {}
+    AccessLogEntry() :
+        url(nullptr),
+        lastAclName(nullptr),
+        lastAclData(nullptr),
+        reply(nullptr),
+        request(nullptr),
+        adapted_request(nullptr)
+    {}
     ~AccessLogEntry();
 
     /// Fetch the client IP log string into the given buffer.
     /// Knows about several alternate locations of the IP
     /// including indirect forwarded-for IP if configured to log that
     void getLogClientIp(char *buf, size_t bufsz) const;
 
     const char *url;
 
     /// TCP/IP level details about the client connection
     Comm::ConnectionPointer tcpClient;
     // TCP/IP level details about the server or peer connection
     // are stored in hier.tcpServer
 
     /** \brief This subclass holds log info for HTTP protocol
      * \todo Inner class declarations should be moved outside
      * \todo details of HTTP held in the parent class need moving into here.
      */
     class HttpDetails
     {
@@ -190,40 +196,44 @@
     {
 
     public:
         AdaptationDetails(): last_meta(NULL) {}
 
         /// image of the last ICAP response header or eCAP meta received
         char *last_meta;
     } adapt;
 #endif
 
     // Why is this a sub-class and not a set of real "private:" fields?
     // TODO: shuffle this to the relevant ICP/HTCP protocol section
     class Private
     {
 
     public:
         Private() : method_str(NULL) {}
 
         const char *method_str;
     } _private;
+
+    const char *lastAclName; ///< string for external_acl_type %ACL format code
+    const char *lastAclData; ///< string for external_acl_type %DATA format code
+
     HierarchyLogEntry hier;
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
     /// key:value pairs set by squid.conf note directive and
     /// key=value pairs returned from URL rewrite/redirect helper
     NotePairs::Pointer notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
      *  \todo Inner class declarations should be moved outside
      */
     class IcapLogEntry
     {
     public:
         IcapLogEntry() : reqMethod(Adaptation::methodNone), bytesSent(0), bytesRead(0),
             bodyBytesRead(-1), request(NULL), reply(NULL),
             outcome(Adaptation::Icap::xoUnknown), resStatus(Http::scNone)
         {

=== modified file 'src/ExternalACL.h'
--- src/ExternalACL.h	2015-02-04 16:45:30 +0000
+++ src/ExternalACL.h	2015-10-08 09:10:14 +0000
@@ -34,40 +34,41 @@
 
 #include "acl/Acl.h"
 
 class ACLExternal : public ACL
 {
     MEMPROXY_CLASS(ACLExternal);
 
 public:
     static void ExternalAclLookup(ACLChecklist * ch, ACLExternal *);
 
     ACLExternal(char const *);
     ACLExternal(ACLExternal const &);
     ~ACLExternal();
     ACLExternal&operator=(ACLExternal const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     /* This really should be dynamic based on the external class defn */
+    virtual bool requiresAle() const {return true;}
     virtual bool requiresRequest() const {return true;}
 
     /* when requiresRequest is made dynamic, review this too */
     //    virtual bool requiresReply() const {return true;}
     virtual bool isProxyAuth() const;
     virtual SBufList dump() const;
     virtual bool valid () const;
     virtual bool empty () const;
 
 protected:
     static Prototype RegistryProtoype;
     static ACLExternal RegistryEntry_;
     external_acl_data *data;
     char const *class_;
 };
 
 void parse_externalAclHelper(external_acl **);
 void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 void free_externalAclHelper(external_acl **);
 typedef void EAH(void *data, const ExternalACLEntryPointer &result);

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-09-25 10:12:56 +0000
+++ src/Makefile.am	2015-09-28 00:41:05 +0000
@@ -3445,40 +3445,41 @@
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
+	tests/stub_libeui.cc \
 	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	pconn.cc \

=== modified file 'src/acl/Acl.cc'
--- src/acl/Acl.cc	2015-08-24 14:20:07 +0000
+++ src/acl/Acl.cc	2015-10-08 12:28:05 +0000
@@ -136,47 +136,54 @@
     *name = 0;
 }
 
 bool ACL::valid () const
 {
     return true;
 }
 
 bool
 ACL::matches(ACLChecklist *checklist) const
 {
     PROF_start(ACL_matches);
     debugs(28, 5, "checking " << name);
 
     // XXX: AclMatchedName does not contain a matched ACL name when the acl
     // does not match. It contains the last (usually leaf) ACL name checked
     // (or is NULL if no ACLs were checked).
     AclMatchedName = name;
 
     int result = 0;
-    if (!checklist->hasRequest() && requiresRequest()) {
+    if (!checklist->hasAle() && requiresAle()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an ALE state. Assuming mismatch.");
+    } else if (!checklist->hasRequest() && requiresRequest()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP request. Assuming mismatch.");
     } else if (!checklist->hasReply() && requiresReply()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP response. Assuming mismatch.");
     } else {
+        // make sure the ALE has as much data as possible
+        if (requiresAle())
+            checklist->syncAle();
+
         // have to cast because old match() API is missing const
         result = const_cast<ACL*>(this)->match(checklist);
     }
 
     const char *extra = checklist->asyncInProgress() ? " async" : "";
     debugs(28, 3, "checked: " << name << " = " << result << extra);
     PROF_stop(ACL_matches);
     return result == 1; // true for match; false for everything else
 }
 
 void
 ACL::context(const char *aName, const char *aCfgLine)
 {
     name[0] = '\0';
     if (aName)
         xstrncpy(name, aName, ACL_NAME_SZ-1);
     safe_free(cfgline);
     if (aCfgLine)
         cfgline = xstrdup(aCfgLine);
 }
@@ -351,40 +358,46 @@
 
 void
 aclCacheMatchFlush(dlink_list * cache)
 {
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link, *tmplink;
     link = cache->head;
 
     debugs(28, 8, "aclCacheMatchFlush called for cache " << cache);
 
     while (link) {
         auth_match = (acl_proxy_auth_match_cache *)link->data;
         tmplink = link;
         link = link->next;
         dlinkDelete(tmplink, cache);
         delete auth_match;
     }
 }
 
 bool
+ACL::requiresAle() const
+{
+    return false;
+}
+
+bool
 ACL::requiresReply() const
 {
     return false;
 }
 
 bool
 ACL::requiresRequest() const
 {
     return false;
 }
 
 /*********************/
 /* Destroy functions */
 /*********************/
 
 ACL::~ACL()
 {
     debugs(28, 3, "freeing ACL " << name);
     safe_free(cfgline);
     AclMatchedName = NULL; // in case it was pointing to our name

=== modified file 'src/acl/Acl.h'
--- src/acl/Acl.h	2015-08-24 14:20:07 +0000
+++ src/acl/Acl.h	2015-10-08 09:10:25 +0000
@@ -124,40 +124,42 @@
         ~Prototype();
         static bool Registered(char const *);
         static ACL *Factory(char const *);
 
     private:
         ACL const *prototype;
         char const *typeString;
 
     private:
         static std::vector<Prototype const *> * Registry;
         static void *Initialized;
         typedef std::vector<Prototype const*>::iterator iterator;
         typedef std::vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
 
 private:
     /// Matches the actual data in checklist against this ACL.
     virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
 
+    /// whether our (i.e. shallow) match() requires checklist to have a AccessLogEntry
+    virtual bool requiresAle() const;
     /// whether our (i.e. shallow) match() requires checklist to have a request
     virtual bool requiresRequest() const;
     /// whether our (i.e. shallow) match() requires checklist to have a reply
     virtual bool requiresReply() const;
 };
 
 /// \ingroup ACLAPI
 typedef enum {
     // Authorization ACL result states
     ACCESS_DENIED,
     ACCESS_ALLOWED,
     ACCESS_DUNNO,
 
     // Authentication ACL result states
     ACCESS_AUTH_REQUIRED,    // Missing Credentials
 } aclMatchCode;
 
 /// \ingroup ACLAPI
 /// ACL check answer; TODO: Rename to Acl::Answer
 class allow_t

=== modified file 'src/acl/Checklist.h'
--- src/acl/Checklist.h	2015-08-30 20:36:48 +0000
+++ src/acl/Checklist.h	2015-10-08 14:31:29 +0000
@@ -146,40 +146,42 @@
     /// whether markFinished() was called
     bool finished() const { return finished_; }
     /// async call has been started and has not finished (or failed) yet
     bool asyncInProgress() const { return asyncStage_ != asyncNone; }
     /// called when no more ACLs should be checked; sets the final answer and
     /// prints a debugging message explaining the reason for that answer
     void markFinished(const allow_t &newAnswer, const char *reason);
 
     const allow_t &currentAnswer() const { return allow_; }
 
     /// whether the action is banned or not
     bool bannedAction(const allow_t &action) const;
     /// add action to the list of banned actions
     void banAction(const allow_t &action);
 
     // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
     // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
     virtual bool hasRequest() const = 0;
     virtual bool hasReply() const = 0;
+    virtual bool hasAle() const = 0;
+    virtual void syncAle() const = 0;
 
     /// change the current ACL list
     /// \return a pointer to the old list value (may be nullptr)
     const Acl::Tree *changeAcl(const Acl::Tree *t) {
         const Acl::Tree *old = accessList;
         if (t != accessList) {
             cbdataReferenceDone(accessList);
             accessList = cbdataReference(t);
         }
         return old;
     }
 
 private:
     /// Calls non-blocking check callback with the answer and destroys self.
     void checkCallback(allow_t answer);
 
     void matchAndFinish();
 
     void changeState(AsyncState *);
     AsyncState *asyncState() const;

=== modified file 'src/acl/FilledChecklist.cc'
--- src/acl/FilledChecklist.cc	2015-08-29 17:59:28 +0000
+++ src/acl/FilledChecklist.cc	2015-10-08 15:03:03 +0000
@@ -49,40 +49,96 @@
 
 ACLFilledChecklist::~ACLFilledChecklist()
 {
     assert (!asyncInProgress());
 
     safe_free(dst_rdns); // created by xstrdup().
 
     HTTPMSGUNLOCK(request);
 
     HTTPMSGUNLOCK(reply);
 
     cbdataReferenceDone(conn_);
 
 #if USE_OPENSSL
     cbdataReferenceDone(sslErrors);
 #endif
 
     debugs(28, 4, HERE << "ACLFilledChecklist destroyed " << this);
 }
 
+static void
+showDebugWarning(const char *msg)
+{
+    static uint16_t count = 0;
+    if (count > 100)
+        return;
+
+    ++count;
+    debugs(28, DBG_IMPORTANT, "ALE missing " << msg);
+}
+
+void
+ACLFilledChecklist::syncAle() const
+{
+    // make sure the ALE fields used by Format::assemble to
+    // fill the old external_acl_type codes are set if any
+    // data on them exists in the Checklist
+
+    if (!al->cache.port && conn()) {
+        showDebugWarning("listening port");
+        al->cache.port = conn()->port;
+    }
+
+    if (request) {
+        if (!al->request) {
+            showDebugWarning("HttpRequest object");
+            al->request = request;
+            HTTPMSGLOCK(al->request);
+        }
+
+        if (!al->adapted_request) {
+            showDebugWarning("adapted HttpRequest object");
+            al->adapted_request = request;
+            HTTPMSGLOCK(al->adapted_request);
+        }
+
+        if (!al->url) {
+            showDebugWarning("URL");
+            al->url = xstrdup(request->url.absolute().c_str());
+        }
+    }
+
+    if (reply && !al->reply) {
+        showDebugWarning("HttpReply object");
+        al->reply = reply;
+        HTTPMSGLOCK(al->reply);
+    }
+
+#if USE_IDENT
+    if (rfc931 && !al->cache.rfc931) {
+        showDebugWarning("IDENT");
+        al->cache.rfc931 = xstrdup(rfc931);
+    }
+#endif
+}
+
 ConnStateData *
 ACLFilledChecklist::conn() const
 {
     return  conn_;
 }
 
 void
 ACLFilledChecklist::conn(ConnStateData *aConn)
 {
     if (conn() == aConn)
         return;
     assert (conn() == NULL);
     conn_ = cbdataReference(aConn);
 }
 
 int
 ACLFilledChecklist::fd() const
 {
     return (conn_ != NULL && conn_->clientConnection != NULL) ? conn_->clientConnection->fd : fd_;
 }

=== modified file 'src/acl/FilledChecklist.h'
--- src/acl/FilledChecklist.h	2015-09-14 16:25:05 +0000
+++ src/acl/FilledChecklist.h	2015-10-08 14:31:57 +0000
@@ -45,67 +45,69 @@
     ConnStateData * conn() const;
 
     /// The client side fd. It uses conn() if available
     int fd() const;
 
     /// set either conn
     void conn(ConnStateData *);
     /// set the client side FD
     void fd(int aDescriptor);
 
     //int authenticated();
 
     bool destinationDomainChecked() const;
     void markDestinationDomainChecked();
     bool sourceDomainChecked() const;
     void markSourceDomainChecked();
 
     // ACLChecklist API
     virtual bool hasRequest() const { return request != NULL; }
     virtual bool hasReply() const { return reply != NULL; }
+    virtual bool hasAle() const { return al != NULL; }
+    virtual void syncAle() const;
 
 public:
     Ip::Address src_addr;
     Ip::Address dst_addr;
     Ip::Address my_addr;
     SBuf dst_peer_name;
     char *dst_rdns;
 
     HttpRequest *request;
     HttpReply *reply;
 
     char rfc931[USER_IDENT_SZ];
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
 #if SQUID_SNMP
     char *snmp_community;
 #endif
 
 #if USE_OPENSSL
     /// SSL [certificate validation] errors, in undefined order
     Ssl::CertErrors *sslErrors;
     /// The peer certificate
     Security::CertPointer serverCert;
 #endif
 
-    AccessLogEntry::Pointer al; ///< info for the future access.log entry
+    AccessLogEntry::Pointer al; ///< info for the future access.log, and external ACL
 
     ExternalACLEntryPointer extacl_entry;
 
     err_type requestErrorType;
 
 private:
     ConnStateData * conn_;          /**< hack for ident and NTLM */
     int fd_;                        /**< may be available when conn_ is not */
     bool destinationDomainChecked_;
     bool sourceDomainChecked_;
     /// not implemented; will cause link failures if used
     ACLFilledChecklist(const ACLFilledChecklist &);
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
 inline
 ACLFilledChecklist *Filled(ACLChecklist *checklist)
 {

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-08-30 01:07:47 +0000
+++ src/cf.data.pre	2015-10-02 10:15:34 +0000
@@ -700,141 +700,111 @@
 DOC_END
 
 COMMENT_START
  ACCESS CONTROLS
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: external_acl_type
 TYPE: externalAclHelper
 LOC: Config.externalAclHelperList
 DEFAULT: none
 DOC_START
 	This option defines external acl classes using a helper program
 	to look up the status
 
 	  external_acl_type name [options] FORMAT.. /path/to/helper [helper arguments..]
 
 	Options:
 
 	  ttl=n		TTL in seconds for cached results (defaults to 3600
-	  		for 1 hour)
+			for 1 hour)
 
 	  negative_ttl=n
-	  		TTL for cached negative lookups (default same
-	  		as ttl)
+			TTL for cached negative lookups (default same
+			as ttl)
 
 	  grace=n	Percentage remaining of TTL where a refresh of a
 			cached entry should be initiated without needing to
 			wait for a new reply. (default is for no grace period)
 
 	  cache=n	Limit the result cache size, default is 262144.
 			The expanded FORMAT value is used as the cache key, so
 			if the details in FORMAT are highly variable a larger
 			cache may be needed to produce reduction in helper load.
 
 	  children-max=n
 			Maximum number of acl helper processes spawned to service
 			external acl lookups of this type. (default 20)
 
 	  children-startup=n
 			Minimum number of acl helper processes to spawn during
 			startup and reconfigure to service external acl lookups
 			of this type. (default 0)
 
 	  children-idle=n
 			Number of acl helper processes to keep ahead of traffic
 			loads. Squid will spawn this many at once whenever load
 			rises above the capabilities of existing processes.
 			Up to the value of children-max. (default 1)
 
 	  concurrency=n	concurrency level per process. Only used with helpers
 			capable of processing more than one query at a time.
 
 	  queue-size=N  The queue-size= option sets the maximum number of queued
 			requests. If the queued requests exceed queue size 
 			the acl is ignored.
 			The default value is set to 2*children-max.
 
 	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers.
 
 	  ipv4 / ipv6	IP protocol used to communicate with this helper.
 			The default is to auto-detect IPv6 and use it when available.
 
 
-	FORMAT specifications
+	FORMAT is a series of %macro codes. See logformat directive for a full list
+	of the accepted codes. Although note that at the time of any external ACL
+	being tested data may not be available and thus some %macro expand to '-'.
 
-	  %LOGIN	Authenticated user login name
-	  %un		A user name. Expands to the first available name
-	  		from the following list of information sources:
-			- authenticated user name, like %ul or %LOGIN
-			- user name sent by an external ACL, like %EXT_USER
-			- SSL client name, like %us in logformat
-			- ident user name, like %ui in logformat
-	  %EXT_USER	Username from previous external acl
-	  %EXT_LOG	Log details from previous external acl
-	  %EXT_TAG	Tag from previous external acl
-	  %IDENT	Ident user name
-	  %SRC		Client IP
-	  %SRCPORT	Client source port
-	  %URI		Requested URI
-	  %DST		Requested host
-	  %PROTO	Requested URL scheme
-	  %PORT		Requested port
-	  %PATH		Requested URL path
-	  %METHOD	Request method
-	  %MYADDR	Squid interface address
-	  %MYPORT	Squid http_port number
-	  %PATH		Requested URL-path (including query-string if any)
-	  %USER_CERT	SSL User certificate in PEM format
-	  %USER_CERTCHAIN SSL User certificate chain in PEM format
-	  %USER_CERT_xx	SSL User certificate subject attribute xx
-	  %USER_CA_CERT_xx SSL User certificate issuer attribute xx
-	  %ssl::>sni	SSL client SNI sent to Squid
-	  %ssl::<cert_subject SSL server certificate DN
-	  %ssl::<cert_issuer SSL server certificate issuer DN
-
-	  %>{Header}	HTTP request header "Header"
-	  %>{Hdr:member}
-	  		HTTP request header "Hdr" list member "member"
-	  %>{Hdr:;member}
-	  		HTTP request header list member using ; as
-	  		list separator. ; can be any non-alphanumeric
-			character.
-
-	  %<{Header}	HTTP reply header "Header"
-	  %<{Hdr:member}
-	  		HTTP reply header "Hdr" list member "member"
-	  %<{Hdr:;member}
-	  		HTTP reply header list member using ; as
-	  		list separator. ; can be any non-alphanumeric
-			character.
+	In addition to the logformat codes; when processing external ACLs these
+	additional macros are made available:
 
 	  %ACL		The name of the ACL being tested.
-	  %DATA		The ACL arguments. If not used then any arguments
-			is automatically added at the end of the line
-			sent to the helper.
-			NOTE: this will encode the arguments as one token,
-			whereas the default will pass each separately.
 
-	  %%		The percent sign. Useful for helpers which need
-			an unchanging input format.
+	  %DATA		The ACL arguments. If a logformat encoding modifier
+			is used it will encode the whole set of arguments
+			as a single token.
+
+			If not used; then any arguments are automatically
+			added at the end of the line sent to the helper
+			as separately URL-encoded fields.
+
+	If SSL is enabled, the following formating codes become available:
+
+	  %USER_CERT		SSL User certificate in PEM format
+	  %USER_CERTCHAIN	SSL User certificate chain in PEM format
+	  %USER_CERT_xx		SSL User certificate subject attribute xx
+	  %USER_CA_CERT_xx	SSL User certificate issuer attribute xx
+
+
+	NOTE: all other format codes accepted by older Squid versions
+		are deprecated.
 
 
 	General request syntax:
 
 	  [channel-ID] FORMAT-values [acl-values ...]
 
 
 	FORMAT-values consists of transaction details expanded with
 	whitespace separation per the config file FORMAT specification
 	using the FORMAT macros listed above.
 
 	acl-values consists of any string specified in the referencing
 	config 'acl ... external' line. see the "acl external" directive.
 
 	Request values sent to the helper are URL escaped to protect
 	each value in requests against whitespaces.
 
 	If using protocol=2.5 then the request sent to the helper is not
 	URL escaped to protect against whitespace.
 
@@ -868,43 +838,43 @@
 		An internal error occurred in the helper, preventing
 		a result being identified.
 
 	The meaning of 'a match' is determined by your squid.conf
 	access control configuration. See the Squid wiki for details.
 
 	Defined keywords:
 
 	  user=		The users name (login)
 
 	  password=	The users password (for login= cache_peer option)
 
 	  message=	Message describing the reason for this response.
 			Available as %o in error pages.
 			Useful on (ERR and BH results).
 
 	  tag=		Apply a tag to a request. Only sets a tag once,
 			does not alter existing tags.
 
 	  log=		String to be logged in access.log. Available as
-	  		%ea in logformat specifications.
+			%ea in logformat specifications.
 
-  	  clt_conn_tag= Associates a TAG with the client TCP connection.
+	  clt_conn_tag= Associates a TAG with the client TCP connection.
 			Please see url_rewrite_program related documentation
 			for this kv-pair.
 
 	Any keywords may be sent on any response whether OK, ERR or BH.
 
 	All response keyword values need to be a single token with URL
 	escaping, or enclosed in double quotes (") and escaped using \ on
 	any double quotes or \ characters within the value. The wrapping
 	double quotes are removed before the value is interpreted by Squid.
 	\r and \n are also replace by CR and LF.
 
 	Some example key values:
 
 		user=John%20Smith
 		user="John Smith"
 		user="J. \"Bob\" Smith"
 DOC_END
 
 NAME: acl
 TYPE: acl
@@ -4064,55 +4034,57 @@
 NAME: logformat
 TYPE: logformat
 LOC: Log::TheConfig
 DEFAULT: none
 DEFAULT_DOC: The format definitions squid, common, combined, referrer, useragent are built in.
 DOC_START
 	Usage:
 
 	logformat <name> <format specification>
 
 	Defines an access log format.
 
 	The <format specification> is a string with embedded % format codes
 
 	% format codes all follow the same basic structure where all but
 	the formatcode is optional. Output strings are automatically escaped
 	as required according to their context and the output format
 	modifiers are usually not needed, but can be specified if an explicit
 	output format is desired.
 
-		% ["|[|'|#] [-] [[0]width] [{argument}] formatcode
+		% ["|[|'|#|/] [-] [[0]width] [{arg}] formatcode [{arg}]
 
 		"	output in quoted string format
 		[	output in squid text log format as used by log_mime_hdrs
 		#	output in URL quoted format
+		/	output in shell \-escaped format
 		'	output as-is
 
 		-	left aligned
 
 		width	minimum and/or maximum field width:
 			    [width_min][.width_max]
 			When minimum starts with 0, the field is zero-padded.
 			String values exceeding maximum width are truncated.
 
-		{arg}	argument such as header name etc
+		{arg}	argument such as header name etc. This field may be
+			placed before or after the token, but not both at once.
 
 	Format codes:
 
 		%	a literal % character
 		sn	Unique sequence number per log line entry
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
 		note	The annotation specified by the argument. Also
 			logs the adaptation meta headers set by the
 			adaptation_meta configuration parameter.
 			If no argument given all annotations logged.
 			The argument may include a separator to use with
 			annotation values:
                             name[:separator]
 			By default, multiple note values are separated with ","
 			and multiple notes are separated with "\r\n".
 			When logging named notes with %{name}note, the
 			explicitly configured separator is used between note
 			values. When logging all notes with %note, the

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-09-25 05:07:55 +0000
+++ src/external_acl.cc	2015-10-09 02:20:53 +0000
@@ -1,41 +1,42 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 82    External ACL */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/FilledChecklist.h"
 #include "cache_cf.h"
 #include "client_side.h"
+#include "client_side_request.h"
 #include "comm/Connection.h"
 #include "ConfigParser.h"
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
 #include "fde.h"
-#include "format/ByteCode.h"
+#include "format/Token.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc1738.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "tools.h"
 #include "URL.h"
 #include "wordlist.h"
 #if USE_OPENSSL
 #include "ssl/ServerBump.h"
 #include "ssl/support.h"
 #endif
@@ -49,427 +50,301 @@
 #endif
 
 #ifndef DEFAULT_EXTERNAL_ACL_TTL
 #define DEFAULT_EXTERNAL_ACL_TTL 1 * 60 * 60
 #endif
 #ifndef DEFAULT_EXTERNAL_ACL_CHILDREN
 #define DEFAULT_EXTERNAL_ACL_CHILDREN 5
 #endif
 
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static void external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry);
 static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
 
 /******************************************************************
  * external_acl directive
  */
 
-class external_acl_format : public RefCountable
-{
-    MEMPROXY_CLASS(external_acl_format);
-
-public:
-    typedef RefCount<external_acl_format> Pointer;
-
-    external_acl_format() :
-        type(Format::LFT_NONE),
-        header(nullptr),
-        member(nullptr),
-        separator(' '),
-        header_id(Http::HdrType::BAD_HDR)
-    {}
-    ~external_acl_format() {
-        xfree(header);
-        xfree(member);
-    }
-
-    Format::ByteCode_t type;
-    external_acl_format::Pointer next;
-    char *header;
-    char *member;
-    char separator;
-    Http::HdrType header_id;
-};
-
 class external_acl
 {
     /* FIXME: These are not really cbdata, but it is an easy way
      * to get them pooled, refcounted, accounted and freed properly...
      */
     CBDATA_CLASS(external_acl);
 
 public:
     external_acl();
     ~external_acl();
 
     external_acl *next;
 
     void add(const ExternalACLEntryPointer &);
 
     void trimCache();
 
     int ttl;
 
     int negative_ttl;
 
     int grace;
 
     char *name;
 
-    external_acl_format::Pointer format;
+    Format::Format format;
 
     wordlist *cmdline;
 
     Helper::ChildConfig children;
 
     helper *theHelper;
 
     hash_table *cache;
 
     dlink_list lru_list;
 
     int cache_size;
 
     int cache_entries;
 
     dlink_list queue;
 
 #if USE_AUTH
     /**
      * Configuration flag. May only be altered by the configuration parser.
      *
      * Indicates that all uses of this external_acl_type helper require authentication
      * details to be processed. If none are available its a fail match.
      */
     bool require_auth;
 #endif
 
-    enum {
-        QUOTE_METHOD_SHELL = 1,
-        QUOTE_METHOD_URL
-    } quote;
+    Format::Quoting quote; // default quoting to use, set by protocol= parameter
 
     Ip::Address local_addr;
 };
 
 CBDATA_CLASS_INIT(external_acl);
 
 external_acl::external_acl() :
     next(NULL),
     ttl(DEFAULT_EXTERNAL_ACL_TTL),
     negative_ttl(-1),
     grace(1),
     name(NULL),
+    format("external_acl_type"),
     cmdline(NULL),
     children(DEFAULT_EXTERNAL_ACL_CHILDREN),
     theHelper(NULL),
     cache(NULL),
     cache_size(256*1024),
     cache_entries(0),
 #if USE_AUTH
     require_auth(0),
 #endif
-    quote(external_acl::QUOTE_METHOD_URL)
+    quote(Format::LOG_QUOTE_URL)
 {
     local_addr.setLocalhost();
 }
 
 external_acl::~external_acl()
 {
     xfree(name);
-    format = NULL;
     wordlistDestroy(&cmdline);
 
     if (theHelper) {
         helperShutdown(theHelper);
         delete theHelper;
         theHelper = NULL;
     }
 
     while (lru_list.tail) {
         ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(lru_list.tail->data));
         external_acl_cache_delete(this, e);
     }
     if (cache)
         hashFreeMemory(cache);
 
     while (next) {
         external_acl *node = next;
         next = node->next;
         node->next = NULL; // prevent recursion
         delete node;
     }
 }
 
-/**
- * Parse the External ACL format %<{.*} and %>{.*} token(s) to pass a specific
- * request or reply header to external helper.
- *
- \param header   - the token being parsed (without the identifying prefix)
- \param type     - format enum identifier for this element, pulled from identifying prefix
- \param format   - structure to contain all the info about this format element.
- */
-void
-parse_header_token(external_acl_format::Pointer format, char *header, const Format::ByteCode_t type)
-{
-    /* header format */
-    char *member, *end;
-
-    /** Cut away the closing brace */
-    end = strchr(header, '}');
-    if (end && strlen(end) == 1)
-        *end = '\0';
-    else
-        self_destruct();
-
-    member = strchr(header, ':');
-
-    if (member) {
-        /* Split in header and member */
-        *member = '\0';
-        ++member;
-
-        if (!xisalnum(*member)) {
-            format->separator = *member;
-            ++member;
-        } else {
-            format->separator = ',';
-        }
-
-        format->member = xstrdup(member);
-
-        if (type == Format::LFT_ADAPTED_REQUEST_HEADER)
-            format->type = Format::LFT_ADAPTED_REQUEST_HEADER_ELEM;
-        else
-            format->type = Format::LFT_REPLY_HEADER_ELEM;
-
-    } else {
-        format->type = type;
-    }
-
-    format->header = xstrdup(header);
-    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header)).id;
-}
-
 void
 parse_externalAclHelper(external_acl ** list)
 {
     external_acl *a = new external_acl;
     char *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
 
     a->name = xstrdup(token);
 
     // Allow supported %macros inside quoted tokens
     ConfigParser::EnableMacros();
     token = ConfigParser::NextToken();
 
     /* Parse options */
     while (token) {
         if (strncmp(token, "ttl=", 4) == 0) {
             a->ttl = atoi(token + 4);
         } else if (strncmp(token, "negative_ttl=", 13) == 0) {
             a->negative_ttl = atoi(token + 13);
         } else if (strncmp(token, "children=", 9) == 0) {
             a->children.n_max = atoi(token + 9);
             debugs(0, DBG_CRITICAL, "WARNING: external_acl_type option children=N has been deprecated in favor of children-max=N and children-startup=N");
         } else if (strncmp(token, "children-max=", 13) == 0) {
             a->children.n_max = atoi(token + 13);
         } else if (strncmp(token, "children-startup=", 17) == 0) {
             a->children.n_startup = atoi(token + 17);
         } else if (strncmp(token, "children-idle=", 14) == 0) {
             a->children.n_idle = atoi(token + 14);
         } else if (strncmp(token, "concurrency=", 12) == 0) {
             a->children.concurrency = atoi(token + 12);
         } else if (strncmp(token, "queue-size=", 11) == 0) {
             a->children.queue_size = atoi(token + 11);
             a->children.defaultQueueSize = false;
         } else if (strncmp(token, "cache=", 6) == 0) {
             a->cache_size = atoi(token + 6);
         } else if (strncmp(token, "grace=", 6) == 0) {
             a->grace = atoi(token + 6);
         } else if (strcmp(token, "protocol=2.5") == 0) {
-            a->quote = external_acl::QUOTE_METHOD_SHELL;
+            a->quote = Format::LOG_QUOTE_SHELL;
         } else if (strcmp(token, "protocol=3.0") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option protocol=3.0 is deprecated. Remove this from your config.");
-            a->quote = external_acl::QUOTE_METHOD_URL;
+            a->quote = Format::LOG_QUOTE_URL;
         } else if (strcmp(token, "quote=url") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=url is deprecated. Remove this from your config.");
-            a->quote = external_acl::QUOTE_METHOD_URL;
+            a->quote = Format::LOG_QUOTE_URL;
         } else if (strcmp(token, "quote=shell") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=shell is deprecated. Use protocol=2.5 if still needed.");
-            a->quote = external_acl::QUOTE_METHOD_SHELL;
+            a->quote = Format::LOG_QUOTE_SHELL;
 
             /* INET6: allow admin to configure some helpers explicitly to
                       bind to IPv4/v6 localhost port. */
         } else if (strcmp(token, "ipv4") == 0) {
             if ( !a->local_addr.setIPv4() ) {
                 debugs(3, DBG_CRITICAL, "WARNING: Error converting " << a->local_addr << " to IPv4 in " << a->name );
             }
         } else if (strcmp(token, "ipv6") == 0) {
             if (!Ip::EnableIpv6)
                 debugs(3, DBG_CRITICAL, "WARNING: --enable-ipv6 required for external ACL helpers to use IPv6: " << a->name );
             // else nothing to do.
         } else {
             break;
         }
 
         token = ConfigParser::NextToken();
     }
     ConfigParser::DisableMacros();
 
     /* check that child startup value is sane. */
     if (a->children.n_startup > a->children.n_max)
         a->children.n_startup = a->children.n_max;
 
     /* check that child idle value is sane. */
     if (a->children.n_idle > a->children.n_max)
         a->children.n_idle = a->children.n_max;
     if (a->children.n_idle < 1)
         a->children.n_idle = 1;
 
     if (a->negative_ttl == -1)
         a->negative_ttl = a->ttl;
 
     if (a->children.defaultQueueSize)
         a->children.queue_size = 2 * a->children.n_max;
 
-    /* Parse format */
-    external_acl_format::Pointer *p = &a->format;
-
+    /* Legacy external_acl_type format parser.
+     * Handles a series of %... tokens where any non-% means
+     * the start of another parameter field (ie the path to binary).
+     */
+    enum Format::Quoting quote = Format::LOG_QUOTE_NONE;
+    Format::Token **fmt = &a->format.format;
+    bool data_used = false;
     while (token) {
-        /* stop on first non-format token found */
-
+        /* stop on first non-% token found */
         if (*token != '%')
             break;
 
-        external_acl_format::Pointer format = new external_acl_format;
-
-        if (strncmp(token, "%{", 2) == 0) {
-            // deprecated. but assume the old configs all referred to request headers.
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+2), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%>{", 3) == 0) {
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%>ha{", 5) == 0) {
-            parse_header_token(format, (token+5), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%<{", 3) == 0) {
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
-            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
-        } else if (strncmp(token, "%<h{", 4) == 0) {
-            parse_header_token(format, (token+4), Format::LFT_REPLY_HEADER);
-#if USE_AUTH
-        } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
-            format->type = Format::LFT_USER_LOGIN;
-            a->require_auth = true;
-#endif
-        }
-#if USE_IDENT
-        else if (strcmp(token, "%IDENT") == 0 || strcmp(token, "%ui") == 0)
-            format->type = Format::LFT_USER_IDENT;
-#endif
-        else if (strcmp(token, "%SRC") == 0 || strcmp(token, "%>a") == 0)
-            format->type = Format::LFT_CLIENT_IP_ADDRESS;
-        else if (strcmp(token, "%SRCPORT") == 0 || strcmp(token, "%>p") == 0)
-            format->type = Format::LFT_CLIENT_PORT;
-#if USE_SQUID_EUI
-        else if (strcmp(token, "%SRCEUI48") == 0)
-            format->type = Format::LFT_EXT_ACL_CLIENT_EUI48;
-        else if (strcmp(token, "%SRCEUI64") == 0)
-            format->type = Format::LFT_EXT_ACL_CLIENT_EUI64;
-#endif
-        else if (strcmp(token, "%MYADDR") == 0 || strcmp(token, "%la") == 0)
-            format->type = Format::LFT_LOCAL_LISTENING_IP;
-        else if (strcmp(token, "%MYPORT") == 0 || strcmp(token, "%lp") == 0)
-            format->type = Format::LFT_LOCAL_LISTENING_PORT;
-        else if (strcmp(token, "%URI") == 0 || strcmp(token, "%>ru") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URI;
-        else if (strcmp(token, "%DST") == 0 || strcmp(token, "%>rd") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLDOMAIN;
-        else if (strcmp(token, "%PROTO") == 0 || strcmp(token, "%>rs") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLSCHEME;
-        else if (strcmp(token, "%PORT") == 0) // XXX: add a logformat token
-            format->type = Format::LFT_CLIENT_REQ_URLPORT;
-        else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLPATH;
-        else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
-            format->type = Format::LFT_CLIENT_REQ_METHOD;
-#if USE_OPENSSL
-        else if (strcmp(token, "%USER_CERT") == 0)
-            format->type = Format::LFT_EXT_ACL_USER_CERT_RAW;
-        else if (strcmp(token, "%USER_CERTCHAIN") == 0)
-            format->type = Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW;
-        else if (strncmp(token, "%USER_CERT_", 11) == 0) {
-            format->type = Format::LFT_EXT_ACL_USER_CERT;
-            format->header = xstrdup(token + 11);
+        *fmt = new Format::Token;
+        // these tokens are whitespace delimited
+        (*fmt)->space = true;
+
+        // set the default encoding to match the protocol= config
+        // this will be overridden by explicit %macro attributes
+        (*fmt)->quote = a->quote;
+
+        // compatibility for old tokens incompatible with Format::Token syntax
+#if USE_OPENSSL // dont bother if we dont have to.
+        if (strncmp(token, "%USER_CERT_", 11) == 0) {
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CERT;
+            (*fmt)->data.string = xstrdup(token + 11);
+            (*fmt)->data.header.header = (*fmt)->data.string;
         } else if (strncmp(token, "%USER_CA_CERT_", 14) == 0) {
-            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 14);
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CA_CERT;
+            (*fmt)->data.string = xstrdup(token + 14);
+            (*fmt)->data.header.header = (*fmt)->data.string;
         } else if (strncmp(token, "%CA_CERT_", 9) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
-            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 9);
-        } else if (strcmp(token, "%ssl::>sni") == 0)
-            format->type = Format::LFT_SSL_CLIENT_SNI;
-        else if (strcmp(token, "%ssl::<cert_subject") == 0)
-            format->type = Format::LFT_SSL_SERVER_CERT_SUBJECT;
-        else if (strcmp(token, "%ssl::<cert_issuer") == 0)
-            format->type = Format::LFT_SSL_SERVER_CERT_ISSUER;
-#endif
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CA_CERT;
+            (*fmt)->data.string = xstrdup(token + 9);
+            (*fmt)->data.header.header = (*fmt)->data.string;
+        } else
+#endif
+        {
+            // we can use the Format::Token::parse() method since it
+            // only pulls off one token. Since we already checked
+            // for '%' prefix above this is guaranteed to be a token.
+            const size_t len = (*fmt)->parse(token, &quote);
+            assert(len == strlen(token));
+        }
+
+        // process special token-specific actions (only if necessary)
 #if USE_AUTH
-        else if (strcmp(token, "%EXT_USER") == 0 || strcmp(token, "%ue") == 0)
-            format->type = Format::LFT_USER_EXTERNAL;
-#endif
-#if USE_AUTH || defined(USE_OPENSSL) || defined(USE_IDENT)
-        else if (strcmp(token, "%un") == 0)
-            format->type = Format::LFT_USER_NAME;
+        if ((*fmt)->type == Format::LFT_USER_LOGIN)
+            a->require_auth = true;
 #endif
-        else if (strcmp(token, "%EXT_LOG") == 0 || strcmp(token, "%ea") == 0)
-            format->type = Format::LFT_EXT_LOG;
-        else if (strcmp(token, "%TAG") == 0  || strcmp(token, "%et") == 0)
-            format->type = Format::LFT_TAG;
-        else if (strcmp(token, "%ACL") == 0)
-            format->type = Format::LFT_EXT_ACL_NAME;
-        else if (strcmp(token, "%DATA") == 0)
-            format->type = Format::LFT_EXT_ACL_DATA;
-        else if (strcmp(token, "%%") == 0)
-            format->type = Format::LFT_PERCENT;
-        else {
-            debugs(0, DBG_CRITICAL, "ERROR: Unknown Format token " << token);
-            self_destruct();
-        }
 
-        *p = format;
-        p = &format->next;
+        if ((*fmt)->type == Format::LFT_EXT_ACL_DATA)
+            data_used = true;
+
+        fmt = &((*fmt)->next);
         token = ConfigParser::NextToken();
     }
 
     /* There must be at least one format token */
-    if (!a->format)
+    if (!a->format.format)
         self_destruct();
 
+    // format has implicit %DATA on the end if not used explicitly
+    if (!data_used) {
+        *fmt = new Format::Token;
+        (*fmt)->type = Format::LFT_EXT_ACL_DATA;
+        (*fmt)->quote = Format::LOG_QUOTE_URL;
+    }
+
     /* helper */
     if (!token)
         self_destruct();
 
     wordlistAdd(&a->cmdline, token);
 
     /* arguments */
     parse_wordlist(&a->cmdline);
 
     while (*list)
         list = &(*list)->next;
 
     *list = a;
 }
 
 void
 dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl * list)
 {
     const external_acl *node;
     const wordlist *word;
@@ -489,110 +364,44 @@
             storeAppendPrintf(sentry, " negative_ttl=%d", node->negative_ttl);
 
         if (node->grace)
             storeAppendPrintf(sentry, " grace=%d", node->grace);
 
         if (node->children.n_max != DEFAULT_EXTERNAL_ACL_CHILDREN)
             storeAppendPrintf(sentry, " children-max=%d", node->children.n_max);
 
         if (node->children.n_startup != 1)
             storeAppendPrintf(sentry, " children-startup=%d", node->children.n_startup);
 
         if (node->children.n_idle != (node->children.n_max + node->children.n_startup) )
             storeAppendPrintf(sentry, " children-idle=%d", node->children.n_idle);
 
         if (node->children.concurrency)
             storeAppendPrintf(sentry, " concurrency=%d", node->children.concurrency);
 
         if (node->cache)
             storeAppendPrintf(sentry, " cache=%d", node->cache_size);
 
-        if (node->quote == external_acl::QUOTE_METHOD_SHELL)
+        if (node->quote == Format::LOG_QUOTE_SHELL)
             storeAppendPrintf(sentry, " protocol=2.5");
 
-        for (external_acl_format::Pointer format = node->format; format!= NULL; format = format->next) {
-            switch (format->type) {
-
-            case Format::LFT_ADAPTED_REQUEST_HEADER:
-                storeAppendPrintf(sentry, " %%>ha{%s}", format->header);
-                break;
-
-            case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-                storeAppendPrintf(sentry, " %%>ha{%s:%s}", format->header, format->member);
-                break;
-
-            case Format::LFT_REPLY_HEADER:
-                storeAppendPrintf(sentry, " %%<h{%s}", format->header);
-                break;
-
-            case Format::LFT_REPLY_HEADER_ELEM:
-                storeAppendPrintf(sentry, " %%<h{%s:%s}", format->header, format->member);
-                break;
-
-#define DUMP_EXT_ACL_TYPE_FMT(a, fmt, ...) \
-            case Format::LFT_##a: \
-                storeAppendPrintf(sentry, fmt, ##__VA_ARGS__); \
-                break
-#if USE_AUTH
-                DUMP_EXT_ACL_TYPE_FMT(USER_LOGIN," %%ul");
-                DUMP_EXT_ACL_TYPE_FMT(USER_NAME," %%un");
-#endif
-#if USE_IDENT
-
-                DUMP_EXT_ACL_TYPE_FMT(USER_IDENT," %%ui");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_IP_ADDRESS," %%>a");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_PORT," %%>p");
-#if USE_SQUID_EUI
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI48," %%SRCEUI48");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI64," %%SRCEUI64");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_IP," %%>la");
-                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_PORT," %%>lp");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URI," %%>ru");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLDOMAIN," %%>rd");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLSCHEME," %%>rs");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPORT," %%>rP");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPATH," %%>rp");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_METHOD," %%>rm");
-#if USE_OPENSSL
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT_RAW, " %%USER_CERT_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT, " %%USER_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(SSL_CLIENT_SNI, "%%ssl::>sni");
-                DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_SUBJECT, "%%ssl::<cert_subject");
-                DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_ISSUER, "%%ssl::<cert_issuer");
-#endif
-#if USE_AUTH
-                DUMP_EXT_ACL_TYPE_FMT(USER_EXTERNAL," %%ue");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(EXT_LOG," %%ea");
-                DUMP_EXT_ACL_TYPE_FMT(TAG," %%et");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_NAME," %%ACL");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_DATA," %%DATA");
-                DUMP_EXT_ACL_TYPE_FMT(PERCENT, " %%%%");
-            default:
-                fatal("unknown external_acl format error");
-                break;
-            }
-        }
+        node->format.dump(sentry, NULL, false);
 
         for (word = node->cmdline; word; word = word->next)
             storeAppendPrintf(sentry, " %s", word->key);
 
         storeAppendPrintf(sentry, "\n");
     }
 }
 
 void
 free_externalAclHelper(external_acl ** list)
 {
     delete *list;
     *list = NULL;
 }
 
 static external_acl *
 find_externalAclHelper(const char *name)
 {
     external_acl *node;
 
@@ -881,361 +690,92 @@
 
     return rv;
 }
 
 /******************************************************************
  * external_acl cache
  */
 
 static void
 external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     // this must not be done when nothing is being cached.
     if (def->cache_size <= 0 || (def->ttl <= 0 && entry->result == 1) || (def->negative_ttl <= 0 && entry->result != 1))
         return;
 
     dlinkDelete(&entry->lru, &def->lru_list);
     ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
     dlinkAdd(e, &entry->lru, &def->lru_list);
 }
 
-#if USE_OPENSSL
-static const char *
-external_acl_ssl_get_user_attribute(const ACLFilledChecklist &ch, const char *attr)
-{
-    if (ch.conn() != NULL && Comm::IsConnOpen(ch.conn()->clientConnection)) {
-        if (SSL *ssl = fd_table[ch.conn()->clientConnection->fd].ssl)
-            return sslGetUserAttribute(ssl, attr);
-    }
-    return NULL;
-}
-#endif
-
 static char *
 makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 {
     static MemBuf mb;
-    char buf[256];
-    int first = 1;
-    wordlist *arg;
-    HttpRequest *request = ch->request;
-    HttpReply *reply = ch->reply;
     mb.reset();
-    bool data_used = false;
-
-    for (external_acl_format::Pointer format = acl_data->def->format; format != NULL; format = format->next) {
-        const char *str = NULL;
-        String sb;
-
-        switch (format->type) {
-#if USE_AUTH
-        case Format::LFT_USER_LOGIN:
-            // if this ACL line was the cause of credentials fetch
-            // they may not already be in the checklist
-            if (ch->auth_user_request == NULL && ch->request)
-                ch->auth_user_request = ch->request->auth_user_request;
 
-            if (ch->auth_user_request != NULL)
-                str = ch->auth_user_request->username();
-            break;
-#endif
-#if USE_IDENT
-        case Format::LFT_USER_IDENT:
-            str = ch->rfc931;
+    // check for special case tokens in the format
+    for (Format::Token *t = acl_data->def->format.format; t ; t = t->next) {
 
-            if (!str || !*str) {
-                // if we fail to go async, we still return NULL and the caller
-                // will detect the failure in ACLExternal::match().
-                (void)ch->goAsync(IdentLookup::Instance());
-                return NULL;
-            }
-
-            break;
-#endif
-
-        case Format::LFT_CLIENT_IP_ADDRESS:
-            str = ch->src_addr.toStr(buf,sizeof(buf));
-            break;
-
-        case Format::LFT_CLIENT_PORT:
-            snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
-            str = buf;
-            break;
-
-#if USE_SQUID_EUI
-        case Format::LFT_EXT_ACL_CLIENT_EUI48:
-            if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
-                    request->clientConnectionManager->clientConnection->remoteEui48.encode(buf, sizeof(buf)))
-                str = buf;
-            break;
-
-        case Format::LFT_EXT_ACL_CLIENT_EUI64:
-            if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
-                    request->clientConnectionManager->clientConnection->remoteEui64.encode(buf, sizeof(buf)))
-                str = buf;
-            break;
-#endif
-
-        case Format::LFT_LOCAL_LISTENING_IP:
-            str = request->my_addr.toStr(buf, sizeof(buf));
-            break;
-
-        case Format::LFT_LOCAL_LISTENING_PORT:
-            snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URI:
-            snprintf(buf, sizeof(buf), SQUIDSBUFPH, SQUIDSBUFPRINT(request->effectiveRequestUri()));
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLDOMAIN:
-            str = request->url.host();
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLSCHEME:
-            str = request->url.getScheme().c_str();
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLPORT:
-            snprintf(buf, sizeof(buf), "%u", request->url.port());
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLPATH: {
-            SBuf tmp = request->url.path();
-            str = tmp.c_str();
-        }
-        break;
-
-        case Format::LFT_CLIENT_REQ_METHOD: {
-            const SBuf &s = request->method.image();
-            sb.append(s.rawContent(), s.length());
+        if (t->type == Format::LFT_EXT_ACL_NAME) {
+            // setup for %ACL
+            safe_free(ch->al->lastAclName);
+            ch->al->lastAclName = xstrdup(acl_data->name);
         }
-        str = sb.termedBuf();
-        break;
-
-        case Format::LFT_ADAPTED_REQUEST_HEADER:
-            if (format->header_id == Http::HdrType::BAD_HDR)
-                sb = request->header.getByName(format->header);
-            else
-                sb = request->header.getStrOrList(format->header_id);
-            str = sb.termedBuf();
-            break;
-
-        case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-            if (format->header_id == Http::HdrType::BAD_HDR)
-                sb = request->header.getByNameListMember(format->header, format->member, format->separator);
-            else
-                sb = request->header.getListMember(format->header_id, format->member, format->separator);
-            str = sb.termedBuf();
-            break;
-
-        case Format::LFT_REPLY_HEADER:
-            if (reply) {
-                if (format->header_id == Http::HdrType::BAD_HDR)
-                    sb = reply->header.getByName(format->header);
-                else
-                    sb = reply->header.getStrOrList(format->header_id);
-                str = sb.termedBuf();
-            }
-            break;
-
-        case Format::LFT_REPLY_HEADER_ELEM:
-            if (reply) {
-                if (format->header_id == Http::HdrType::BAD_HDR)
-                    sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
-                else
-                    sb = reply->header.getListMember(format->header_id, format->member, format->separator);
-                str = sb.termedBuf();
-            }
-            break;
-
-#if USE_OPENSSL
-
-        case Format::LFT_EXT_ACL_USER_CERT_RAW:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserCertificatePEM(ssl);
-            }
-
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserCertificateChainPEM(ssl);
-            }
-
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CERT:
-
-            str = external_acl_ssl_get_user_attribute(*ch, format->header);
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CA_CERT:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetCAAttribute(ssl, format->header);
-            }
 
-            break;
-
-        case Format::LFT_SSL_CLIENT_SNI:
-            if (ch->conn() != NULL) {
-                if (Ssl::ServerBump * srvBump = ch->conn()->serverBump()) {
-                    if (!srvBump->clientSni.isEmpty())
-                        str = srvBump->clientSni.c_str();
-                }
-            }
-            break;
-
-        case Format::LFT_SSL_SERVER_CERT_SUBJECT:
-        case Format::LFT_SSL_SERVER_CERT_ISSUER: {
-            X509 *serverCert = NULL;
-            if (ch->serverCert.get())
-                serverCert = ch->serverCert.get();
-            else if (ch->conn() && ch->conn()->serverBump())
-                serverCert = ch->conn()->serverBump()->serverCert.get();
-
-            if (serverCert) {
-                if (format->type == Format::LFT_SSL_SERVER_CERT_SUBJECT)
-                    str = Ssl::GetX509UserAttribute(serverCert, "DN");
-                else
-                    str = Ssl::GetX509CAAttribute(serverCert, "DN");
-            }
-            break;
-        }
-
-#endif
-#if USE_AUTH
-        case Format::LFT_USER_EXTERNAL:
-            str = request->extacl_user.termedBuf();
-            break;
-#endif
-        case Format::LFT_USER_NAME:
-            /* find the first available name from various sources */
-#if USE_AUTH
-            // if this ACL line was the cause of credentials fetch
-            // they may not already be in the checklist
-            if (!ch->auth_user_request && ch->request)
-                ch->auth_user_request = ch->request->auth_user_request;
-
-            if (ch->auth_user_request != NULL)
-                str = ch->auth_user_request->username();
-
-            if ((!str || !*str) &&
-                    (request->extacl_user.size() > 0 && request->extacl_user[0] != '-'))
-                str = request->extacl_user.termedBuf();
-#endif
-#if USE_OPENSSL
-            if (!str || !*str)
-                str = external_acl_ssl_get_user_attribute(*ch, "CN");
-#endif
-#if USE_IDENT
-            if (!str || !*str)
-                str = ch->rfc931;
-#endif
-            break;
-        case Format::LFT_EXT_LOG:
-            str = request->extacl_log.termedBuf();
-            break;
-        case Format::LFT_TAG:
-            str = request->tag.termedBuf();
-            break;
-        case Format::LFT_EXT_ACL_NAME:
-            str = acl_data->name;
-            break;
-        case Format::LFT_EXT_ACL_DATA:
-            data_used = true;
-            for (arg = acl_data->arguments; arg; arg = arg->next) {
-                if (!first)
+        if (t->type == Format::LFT_EXT_ACL_DATA) {
+            // setup string for %DATA
+            SBuf sb;
+            for (auto arg = acl_data->arguments; arg; arg = arg->next) {
+                if (sb.length())
                     sb.append(" ", 1);
 
-                if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                if (acl_data->def->quote == Format::LOG_QUOTE_URL) {
                     const char *quoted = rfc1738_escape(arg->key);
                     sb.append(quoted, strlen(quoted));
                 } else {
                     static MemBuf mb2;
                     mb2.init();
                     strwordquote(&mb2, arg->key);
                     sb.append(mb2.buf, mb2.size);
                     mb2.clean();
                 }
-
-                first = 0;
             }
-            break;
-        case Format::LFT_PERCENT:
-            str = "%";
-            break;
 
-        default:
-            // TODO: replace this function with Format::assemble()
-            // For now die on unsupported logformat codes.
-            fatalf("ERROR: unknown external_acl_type format %u", (uint8_t)format->type);
-            break;
+            ch->al->lastAclData = xstrdup(sb.c_str());
         }
 
-        if (str)
-            if (!*str)
-                str = NULL;
-
-        if (!str)
-            str = "-";
-
-        if (!first)
-            mb.append(" ", 1);
-
-        if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-            const char *quoted = rfc1738_escape(str);
-            mb.append(quoted, strlen(quoted));
-        } else {
-            strwordquote(&mb, str);
-        }
-
-        sb.clean();
-
-        first = 0;
-    }
-
-    if (!data_used) {
-        for (arg = acl_data->arguments; arg; arg = arg->next) {
-            if (!first)
-                mb.append(" ", 1);
-
-            if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-                const char *quoted = rfc1738_escape(arg->key);
-                mb.append(quoted, strlen(quoted));
-            } else {
-                strwordquote(&mb, arg->key);
+#if USE_IDENT
+        if (t->type == Format::LFT_USER_IDENT) {
+            if (!*ch->rfc931) {
+                // if we fail to go async, we still return NULL and the caller
+                // will detect the failure in ACLExternal::match().
+                (void)ch->goAsync(IdentLookup::Instance());
+                return NULL;
             }
-
-            first = 0;
         }
+#endif
     }
 
+    // assemble the full helper lookup string
+    acl_data->def->format.assemble(mb, ch->al, 0);
+
     return mb.buf;
 }
 
 static int
 external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;
 
     if (entry->date + (entry->result == 1 ? def->ttl : def->negative_ttl) < squid_curtime)
         return 1;
     else
         return 0;
 }
 
 static int
 external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;

=== modified file 'src/format/ByteCode.h'
--- src/format/ByteCode.h	2015-01-13 07:25:36 +0000
+++ src/format/ByteCode.h	2015-10-02 10:00:59 +0000
@@ -206,44 +206,47 @@
     LFT_ICAP_TR_RESPONSE_TIME,
     LFT_ICAP_IO_TIME,
     LFT_ICAP_OUTCOME,
     LFT_ICAP_STATUS_CODE,
 #endif
     LFT_CREDENTIALS,
 
 #if USE_OPENSSL
     LFT_SSL_BUMP_MODE,
     LFT_SSL_USER_CERT_SUBJECT,
     LFT_SSL_USER_CERT_ISSUER,
     LFT_SSL_CLIENT_SNI,
     LFT_SSL_SERVER_CERT_SUBJECT,
     LFT_SSL_SERVER_CERT_ISSUER,
 #endif
 
     LFT_NOTE,
     LFT_PERCENT,            /* special string cases for escaped chars */
 
     // TODO assign better bytecode names and Token strings for these
+#if USE_OPENSSL
     LFT_EXT_ACL_USER_CERT_RAW,
     LFT_EXT_ACL_USER_CERTCHAIN_RAW,
     LFT_EXT_ACL_USER_CERT,
     LFT_EXT_ACL_USER_CA_CERT,
+#endif
     LFT_EXT_ACL_CLIENT_EUI48,
     LFT_EXT_ACL_CLIENT_EUI64,
     LFT_EXT_ACL_NAME,
     LFT_EXT_ACL_DATA
 
 } ByteCode_t;
 
 /// Quoting style for a format output.
 enum Quoting {
     LOG_QUOTE_NONE = 0,
     LOG_QUOTE_QUOTES,
     LOG_QUOTE_MIMEBLOB,
     LOG_QUOTE_URL,
+    LOG_QUOTE_SHELL,
     LOG_QUOTE_RAW
 };
 
 } // namespace Format
 
 #endif /* _SQUID_FMT_BYTECODE_H */
 

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2015-07-19 13:23:01 +0000
+++ src/format/Format.cc	2015-10-09 02:21:13 +0000
@@ -5,40 +5,41 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "err_detail_type.h"
 #include "errorpage.h"
 #include "fde.h"
 #include "format/Format.h"
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "fqdncache.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
 #include "SquidTime.h"
 #include "Store.h"
+#include "tools.h"
 #include "URL.h"
 #if USE_OPENSSL
 #include "ssl/ErrorDetail.h"
 #include "ssl/ServerBump.h"
 #endif
 
 /// Convert a string to NULL pointer if it is ""
 #define strOrNull(s) ((s)==NULL||(s)[0]=='\0'?NULL:(s))
 
 Format::Format::Format(const char *n) :
     format(NULL),
     next(NULL)
 {
     name = xstrdup(n);
 }
 
 Format::Format::~Format()
 {
     // erase the list without consuming stack space
     while (next) {
@@ -71,48 +72,49 @@
     /* very inefficent parser, but who cares, this needs to be simple */
     /* First off, let's tokenize, we'll optimize in a second pass.
      * A token can either be a %-prefixed sequence (usually a dynamic
      * token but it can be an escaped sequence), or a string. */
     cur = def;
     eos = def + strlen(def);
     format = new_lt = last_lt = new Token;
     cur += new_lt->parse(cur, &quote);
 
     while (cur < eos) {
         new_lt = new Token;
         last_lt->next = new_lt;
         last_lt = new_lt;
         cur += new_lt->parse(cur, &quote);
     }
 
     return true;
 }
 
 void
-Format::Format::dump(StoreEntry * entry, const char *directiveName)
+Format::Format::dump(StoreEntry * entry, const char *directiveName, bool eol) const
 {
     debugs(46, 4, HERE);
 
     // loop rather than recursing to conserve stack space.
-    for (Format *fmt = this; fmt; fmt = fmt->next) {
+    for (const Format *fmt = this; fmt; fmt = fmt->next) {
         debugs(46, 3, HERE << "Dumping format definition for " << fmt->name);
-        storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
+        if (directiveName)
+            storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
 
         for (Token *t = fmt->format; t; t = t->next) {
             if (t->type == LFT_STRING)
                 storeAppendPrintf(entry, "%s", t->data.string);
             else {
                 char argbuf[256];
                 char *arg = NULL;
                 ByteCode_t type = t->type;
 
                 switch (type) {
                 /* special cases */
 
                 case LFT_STRING:
                     break;
 #if USE_ADAPTATION
                 case LFT_ADAPTATION_LAST_HEADER_ELEM:
 #endif
 #if ICAP_CLIENT
                 case LFT_ICAP_REQ_HEADER_ELEM:
                 case LFT_ICAP_REP_HEADER_ELEM:
@@ -208,67 +210,72 @@
                 entry->append("%", 1);
 
                 switch (t->quote) {
 
                 case LOG_QUOTE_QUOTES:
                     entry->append("\"", 1);
                     break;
 
                 case LOG_QUOTE_MIMEBLOB:
                     entry->append("[", 1);
                     break;
 
                 case LOG_QUOTE_URL:
                     entry->append("#", 1);
                     break;
 
                 case LOG_QUOTE_RAW:
                     entry->append("'", 1);
                     break;
 
+                case LOG_QUOTE_SHELL:
+                    entry->append("/", 1);
+                    break;
+
                 case LOG_QUOTE_NONE:
                     break;
                 }
 
                 if (t->left)
                     entry->append("-", 1);
 
                 if (t->zero)
                     entry->append("0", 1);
 
                 if (t->widthMin >= 0)
                     storeAppendPrintf(entry, "%d", t->widthMin);
 
                 if (t->widthMax >= 0)
                     storeAppendPrintf(entry, ".%d", t->widthMax);
 
                 if (arg)
                     storeAppendPrintf(entry, "{%s}", arg);
 
                 storeAppendPrintf(entry, "%s", t->label);
 
                 if (t->space)
                     entry->append(" ", 1);
             }
         }
 
-        entry->append("\n", 1);
+        if (eol)
+            entry->append("\n", 1);
     }
 
 }
 
 static void
 log_quoted_string(const char *str, char *out)
 {
     char *p = out;
 
     while (*str) {
         int l = strcspn(str, "\"\\\r\n\t");
         memcpy(p, str, l);
         str += l;
         p += l;
 
         switch (*str) {
 
         case '\0':
             break;
 
@@ -353,42 +360,62 @@
 
             break;
 
         case LFT_CLIENT_PORT:
             if (al->request) {
                 outint = al->request->client_addr.port();
                 doint = 1;
             }
             break;
 
         case LFT_CLIENT_EUI:
 #if USE_SQUID_EUI
             // TODO make the ACL checklist have a direct link to any TCP details.
             if (al->request && al->request->clientConnectionManager.valid() && al->request->clientConnectionManager->clientConnection != NULL) {
                 if (al->request->clientConnectionManager->clientConnection->remote.isIPv4())
                     al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
                 else
                     al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
                 out = tmp;
             }
-#else
-            out = "-";
+#endif
+            break;
+
+        case LFT_EXT_ACL_CLIENT_EUI48:
+#if USE_SQUID_EUI
+            if (al->request && al->request->clientConnectionManager.valid() &&
+                    al->request->clientConnectionManager->clientConnection != NULL &&
+                    al->request->clientConnectionManager->clientConnection->remote.isIPv4()) {
+                al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
+                out = tmp;
+            }
+#endif
+            break;
+
+        case LFT_EXT_ACL_CLIENT_EUI64:
+#if USE_SQUID_EUI
+            if (al->request && al->request->clientConnectionManager.valid() &&
+                    al->request->clientConnectionManager->clientConnection != NULL &&
+                    !al->request->clientConnectionManager->clientConnection->remote.isIPv4()) {
+                al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
+                out = tmp;
+            }
 #endif
             break;
 
         case LFT_SERVER_IP_ADDRESS:
             if (al->hier.tcpServer != NULL) {
                 out = al->hier.tcpServer->remote.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_SERVER_FQDN_OR_PEER_NAME:
             out = al->hier.host;
             break;
 
         case LFT_SERVER_PORT:
             if (al->hier.tcpServer != NULL) {
                 outint = al->hier.tcpServer->remote.port();
                 doint = 1;
             }
             break;
 
@@ -414,40 +441,43 @@
             break;
 
         case LFT_CLIENT_LOCAL_TOS:
             if (al->tcpClient != NULL) {
                 snprintf(tmp, sizeof(tmp), "0x%x", (uint32_t)al->tcpClient->tos);
                 out = tmp;
             }
             break;
 
         case LFT_CLIENT_LOCAL_NFMARK:
             if (al->tcpClient != NULL) {
                 snprintf(tmp, sizeof(tmp), "0x%x", al->tcpClient->nfmark);
                 out = tmp;
             }
             break;
 
         case LFT_LOCAL_LISTENING_PORT:
             if (al->cache.port != NULL) {
                 outint = al->cache.port->s.port();
                 doint = 1;
+            } else if (al->request) {
+                outint = al->request->my_addr.port();
+                doint = 1;
             }
             break;
 
         case LFT_CLIENT_LOCAL_PORT:
             if (al->tcpClient != NULL) {
                 outint = al->tcpClient->local.port();
                 doint = 1;
             }
             break;
 
         case LFT_SERVER_LOCAL_IP_OLD_27:
         case LFT_SERVER_LOCAL_IP:
             if (al->hier.tcpServer != NULL) {
                 out = al->hier.tcpServer->local.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_SERVER_LOCAL_PORT:
             if (al->hier.tcpServer != NULL) {
                 outint = al->hier.tcpServer->local.port();
@@ -820,41 +850,45 @@
 #if USE_OPENSSL
             if (!out)
                 out = strOrNull(al->cache.ssluser);
 #endif
             if (!out)
                 out = strOrNull(al->cache.rfc931);
             break;
 
         case LFT_USER_LOGIN:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->username());
 #endif
             break;
 
         case LFT_USER_IDENT:
             out = strOrNull(al->cache.rfc931);
             break;
 
         case LFT_USER_EXTERNAL:
-            out = strOrNull(al->cache.extuser);
+            if (al->request && al->request->extacl_user.size())
+                out = al->request->extacl_user.termedBuf();
+
+            if (!out)
+                out = strOrNull(al->cache.extuser);
             break;
 
         /* case LFT_USER_REALM: */
         /* case LFT_USER_SCHEME: */
 
         // the fmt->type can not be LFT_HTTP_SENT_STATUS_CODE_OLD_30
         // but compiler complains if ommited
         case LFT_HTTP_SENT_STATUS_CODE_OLD_30:
         case LFT_HTTP_SENT_STATUS_CODE:
             outint = al->http.code;
 
             doint = 1;
 
             break;
 
         case LFT_HTTP_RECEIVED_STATUS_CODE:
             if (al->hier.peer_reply_status == Http::scNone) {
                 out = "-";
             } else {
                 outint = al->hier.peer_reply_status;
@@ -878,42 +912,41 @@
 
         case LFT_SQUID_STATUS:
             out = al->cache.code.c_str();
             break;
 
         case LFT_SQUID_ERROR:
             if (al->request && al->request->errType != ERR_NONE)
                 out = errorPageName(al->request->errType);
             break;
 
         case LFT_SQUID_ERROR_DETAIL:
 #if USE_OPENSSL
             if (al->request && al->request->errType == ERR_SECURE_CONNECT_FAIL) {
                 if (! (out = Ssl::GetErrorName(al->request->errDetail))) {
                     snprintf(tmp, sizeof(tmp), "SSL_ERR=%d", al->request->errDetail);
                     out = tmp;
                 }
             } else
 #endif
                 if (al->request && al->request->errDetail != ERR_DETAIL_NONE) {
-                    if (al->request->errDetail > ERR_DETAIL_START  &&
-                            al->request->errDetail < ERR_DETAIL_MAX)
+                    if (al->request->errDetail > ERR_DETAIL_START && al->request->errDetail < ERR_DETAIL_MAX)
                         out = errorDetailName(al->request->errDetail);
                     else {
                         if (al->request->errDetail >= ERR_DETAIL_EXCEPTION_START)
                             snprintf(tmp, sizeof(tmp), "%s=0x%X",
                                      errorDetailName(al->request->errDetail), (uint32_t) al->request->errDetail);
                         else
                             snprintf(tmp, sizeof(tmp), "%s=%d",
                                      errorDetailName(al->request->errDetail), al->request->errDetail);
                         out = tmp;
                     }
                 }
             break;
 
         case LFT_SQUID_HIERARCHY:
             if (al->hier.ping.timedout)
                 mb.append("TIMEOUT_", 8);
 
             out = hier_code_str[al->hier.code];
 
             break;
@@ -1112,60 +1145,101 @@
             break;
 
         case LFT_EXT_LOG:
             if (al->request)
                 out = al->request->extacl_log.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_SEQUENCE_NUMBER:
             outoff = logSequenceNumber;
             dooff = 1;
             break;
 
 #if USE_OPENSSL
         case LFT_SSL_BUMP_MODE: {
             const Ssl::BumpMode mode = static_cast<Ssl::BumpMode>(al->ssl.bumpMode);
             // for Ssl::bumpEnd, Ssl::bumpMode() returns NULL and we log '-'
             out = Ssl::bumpMode(mode);
-            break;
         }
+            break;
+
+        case LFT_EXT_ACL_USER_CERT_RAW:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserCertificatePEM(ssl);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserCertificatePEM(ssl);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CERT:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserAttribute(ssl, format->data.header.header);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CA_CERT:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                       out = sslGetCAAttribute(ssl, format->data.header.header);
+                }
+            }
+            break;
 
         case LFT_SSL_USER_CERT_SUBJECT:
             if (X509 *cert = al->cache.sslClientCert.get()) {
                 if (X509_NAME *subject = X509_get_subject_name(cert)) {
                     X509_NAME_oneline(subject, tmp, sizeof(tmp));
                     out = tmp;
                 }
             }
             break;
 
         case LFT_SSL_USER_CERT_ISSUER:
             if (X509 *cert = al->cache.sslClientCert.get()) {
                 if (X509_NAME *issuer = X509_get_issuer_name(cert)) {
                     X509_NAME_oneline(issuer, tmp, sizeof(tmp));
                     out = tmp;
                 }
             }
             break;
+
         case LFT_SSL_CLIENT_SNI:
             if (al->request && al->request->clientConnectionManager.valid()) {
                 if (Ssl::ServerBump * srvBump = al->request->clientConnectionManager->serverBump()) {
                     if (!srvBump->clientSni.isEmpty())
                         out = srvBump->clientSni.c_str();
                 }
             }
             break;
 
         case LFT_SSL_SERVER_CERT_ISSUER:
         case LFT_SSL_SERVER_CERT_SUBJECT:
             // Not implemented
             break;
 #endif
 
         case LFT_REQUEST_URLGROUP_OLD_2X:
             assert(LFT_REQUEST_URLGROUP_OLD_2X == 0); // should never happen.
 
         case LFT_NOTE:
             tmp[0] = fmt->data.header.separator;
@@ -1199,52 +1273,46 @@
                 if (al->notes != NULL && !al->notes->empty())
                     sb.append(al->notes->toString(separator));
 
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_CREDENTIALS:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->credentialsStr());
 #endif
 
             break;
 
         case LFT_PERCENT:
             out = "%";
             break;
 
-        // XXX: external_acl_type format tokens which are not output by logformat.
-        // They are listed here because the switch requires
-        // every ByteCode_t to be explicitly enumerated.
-        // But do not output due to lack of access to the values.
-        case LFT_EXT_ACL_USER_CERT_RAW:
-        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
-        case LFT_EXT_ACL_USER_CERT:
-        case LFT_EXT_ACL_USER_CA_CERT:
-        case LFT_EXT_ACL_CLIENT_EUI48:
-        case LFT_EXT_ACL_CLIENT_EUI64:
         case LFT_EXT_ACL_NAME:
+            out = al->lastAclName;
+            break;
+
         case LFT_EXT_ACL_DATA:
+            out = al->lastAclData;
             break;
         }
 
         if (dooff) {
             snprintf(tmp, sizeof(tmp), "%0*" PRId64, fmt->zero && fmt->widthMin >= 0 ? fmt->widthMin : 0, outoff);
             out = tmp;
 
         } else if (doint) {
             snprintf(tmp, sizeof(tmp), "%0*ld", fmt->zero && fmt->widthMin >= 0 ? fmt->widthMin : 0, outint);
             out = tmp;
         } else if (doMsec) {
             if (fmt->widthMax < 0) {
                 snprintf(tmp, sizeof(tmp), "%0*ld", fmt->widthMin , tvToMsec(outtv));
             } else {
                 int precision = fmt->widthMax;
                 snprintf(tmp, sizeof(tmp), "%0*" PRId64 ".%0*" PRId64 "", fmt->zero && (fmt->widthMin - precision - 1 >= 0) ? fmt->widthMin - precision - 1 : 0, static_cast<int64_t>(outtv.tv_sec * 1000 + outtv.tv_usec / 1000), precision, static_cast<int64_t>((outtv.tv_usec % 1000 )* (1000 / fmt->divisor)));
             }
             out = tmp;
         } else if (doSec) {
             int precision = fmt->widthMax >=0 ? fmt->widthMax :3;
@@ -1266,40 +1334,49 @@
                 case LOG_QUOTE_QUOTES: {
                     size_t out_len = static_cast<size_t>(strlen(out)) * 2 + 1;
                     if (out_len >= sizeof(tmp)) {
                         newout = (char *)xmalloc(out_len);
                         newfree = 1;
                     } else
                         newout = tmp;
                     log_quoted_string(out, newout);
                 }
                 break;
 
                 case LOG_QUOTE_MIMEBLOB:
                     newout = QuoteMimeBlob(out);
                     newfree = 1;
                     break;
 
                 case LOG_QUOTE_URL:
                     newout = rfc1738_escape(out);
                     break;
 
+                case LOG_QUOTE_SHELL: {
+                    MemBuf mbq;
+                    mbq.init();
+                    strwordquote(&mbq, out);
+                    newout = mbq.content();
+                    mbq.stolen = 1;
+                    newfree = 1;
+                    } break;
+
                 case LOG_QUOTE_RAW:
                     break;
                 }
 
                 if (newout) {
                     if (dofree)
                         safe_free(out);
 
                     out = newout;
 
                     dofree = newfree;
                 }
             }
 
             // enforce width limits if configured
             const bool haveMaxWidth = fmt->widthMax >=0 && !doint && !dooff && !doMsec && !doSec;
             if (haveMaxWidth || fmt->widthMin) {
                 const int minWidth = fmt->widthMin >= 0 ?
                                      fmt->widthMin :0;
                 const int maxWidth = haveMaxWidth ?

=== modified file 'src/format/Format.h'
--- src/format/Format.h	2015-01-13 07:25:36 +0000
+++ src/format/Format.h	2015-05-22 05:54:39 +0000
@@ -34,31 +34,31 @@
 
 class Token;
 
 // XXX: inherit from linked list
 class Format
 {
 public:
     Format(const char *name);
     virtual ~Format();
 
     /* very inefficent parser, but who cares, this needs to be simple */
     /* First off, let's tokenize, we'll optimize in a second pass.
      * A token can either be a %-prefixed sequence (usually a dynamic
      * token but it can be an escaped sequence), or a string. */
     bool parse(const char *def);
 
     /// assemble the state information into a formatted line.
     void assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const;
 
     /// dump this whole list of formats into the provided StoreEntry
-    void dump(StoreEntry * entry, const char *directiveName);
+    void dump(StoreEntry * entry, const char *directiveName, bool eol = true) const;
 
     char *name;
     Token *format;
     Format *next;
 };
 
 } // namespace Format
 
 #endif /* _SQUID_FORMAT_FORMAT_H */
 

=== modified file 'src/format/Token.cc'
--- src/format/Token.cc	2015-01-13 07:25:36 +0000
+++ src/format/Token.cc	2015-08-09 11:23:34 +0000
@@ -128,40 +128,66 @@
     /*TokenTableEntry("stP", LFT_SERVER_IO_SIZE_TOTAL),*/
 
     TokenTableEntry("et", LFT_TAG),
     TokenTableEntry("ea", LFT_EXT_LOG),
     TokenTableEntry("sn", LFT_SEQUENCE_NUMBER),
 
     TokenTableEntry(NULL, LFT_NONE)        /* this must be last */
 };
 
 /// Miscellaneous >2 byte tokens
 static TokenTableEntry TokenTableMisc[] = {
     TokenTableEntry(">eui", LFT_CLIENT_EUI),
     TokenTableEntry(">qos", LFT_CLIENT_LOCAL_TOS),
     TokenTableEntry("<qos", LFT_SERVER_LOCAL_TOS),
     TokenTableEntry(">nfmark", LFT_CLIENT_LOCAL_NFMARK),
     TokenTableEntry("<nfmark", LFT_SERVER_LOCAL_NFMARK),
     TokenTableEntry("err_code", LFT_SQUID_ERROR ),
     TokenTableEntry("err_detail", LFT_SQUID_ERROR_DETAIL ),
     TokenTableEntry("note", LFT_NOTE ),
     TokenTableEntry("credentials", LFT_CREDENTIALS),
+    /*
+     * Legacy external_acl_type format tokens
+     */
+    TokenTableEntry("ACL", LFT_EXT_ACL_NAME),
+    TokenTableEntry("DATA", LFT_EXT_ACL_DATA),
+    TokenTableEntry("DST", LFT_CLIENT_REQ_URLDOMAIN),
+    TokenTableEntry("EXT_LOG", LFT_EXT_LOG),
+    TokenTableEntry("EXT_USER", LFT_USER_EXTERNAL),
+    TokenTableEntry("IDENT", LFT_USER_IDENT),
+    TokenTableEntry("LOGIN", LFT_USER_LOGIN),
+    TokenTableEntry("METHOD", LFT_CLIENT_REQ_METHOD),
+    TokenTableEntry("MYADDR", LFT_LOCAL_LISTENING_IP),
+    TokenTableEntry("MYPORT", LFT_LOCAL_LISTENING_PORT),
+    TokenTableEntry("PATH", LFT_CLIENT_REQ_URLPATH),
+    TokenTableEntry("PORT", LFT_CLIENT_REQ_URLPORT),
+    TokenTableEntry("PROTO", LFT_CLIENT_REQ_URLSCHEME),
+    TokenTableEntry("SRCEUI48", LFT_EXT_ACL_CLIENT_EUI48),
+    TokenTableEntry("SRCEUI64", LFT_EXT_ACL_CLIENT_EUI64),
+    TokenTableEntry("SRCPORT", LFT_CLIENT_PORT),
+    TokenTableEntry("SRC", LFT_CLIENT_IP_ADDRESS), // keep after longer SRC* tokens
+    TokenTableEntry("TAG", LFT_TAG),
+    TokenTableEntry("URI", LFT_CLIENT_REQ_URI),
+#if USE_OPENSSL
+    TokenTableEntry("USER_CERTCHAIN", LFT_EXT_ACL_USER_CERTCHAIN_RAW),
+    TokenTableEntry("USER_CERT", LFT_EXT_ACL_USER_CERT_RAW),
+#endif
     TokenTableEntry(NULL, LFT_NONE)        /* this must be last */
 };
 
 #if USE_ADAPTATION
 static TokenTableEntry TokenTableAdapt[] = {
     TokenTableEntry("all_trs", LFT_ADAPTATION_ALL_XACT_TIMES),
     TokenTableEntry("sum_trs", LFT_ADAPTATION_SUM_XACT_TIMES),
     TokenTableEntry("<last_h", LFT_ADAPTATION_LAST_HEADER),
     TokenTableEntry(NULL, LFT_NONE)           /* this must be last */
 };
 #endif
 
 #if ICAP_CLIENT
 /// ICAP (icap::) tokens
 static TokenTableEntry TokenTableIcap[] = {
     TokenTableEntry("tt", LFT_ICAP_TOTAL_TIME),
     TokenTableEntry("<last_h", LFT_ADAPTATION_LAST_HEADER), // deprecated
 
     TokenTableEntry("<A",  LFT_ICAP_ADDR),
     TokenTableEntry("<service_name",  LFT_ICAP_SERV_NAME),
@@ -185,41 +211,40 @@
 
 #if USE_OPENSSL
 // SSL (ssl::) tokens
 static TokenTableEntry TokenTableSsl[] = {
     TokenTableEntry("bump_mode", LFT_SSL_BUMP_MODE),
     TokenTableEntry(">cert_subject", LFT_SSL_USER_CERT_SUBJECT),
     TokenTableEntry(">cert_issuer", LFT_SSL_USER_CERT_ISSUER),
     TokenTableEntry(">sni", LFT_SSL_CLIENT_SNI),
     /*TokenTableEntry("<cert_subject", LFT_SSL_SERVER_CERT_SUBJECT), */
     /*TokenTableEntry("<cert_issuer", LFT_SSL_SERVER_CERT_ISSUER), */
     TokenTableEntry(NULL, LFT_NONE)
 };
 #endif
 } // namespace Format
 
 /// Register all components custom format tokens
 void
 Format::Token::Init()
 {
     // TODO standard log tokens
-    // TODO external ACL fmt tokens
 
 #if USE_ADAPTATION
     TheConfig.registerTokens(String("adapt"),::Format::TokenTableAdapt);
 #endif
 #if ICAP_CLIENT
     TheConfig.registerTokens(String("icap"),::Format::TokenTableIcap);
 #endif
 #if USE_OPENSSL
     TheConfig.registerTokens(String("ssl"),::Format::TokenTableSsl);
 #endif
 }
 
 /// Scans a token table to see if the next token exists there
 /// returns a pointer to next unparsed byte and updates type member if found
 const char *
 Format::Token::scanForToken(TokenTableEntry const table[], const char *cur)
 {
     for (TokenTableEntry const *lte = table; lte->configTag != NULL; ++lte) {
         debugs(46, 8, HERE << "compare tokens '" << lte->configTag << "' with '" << cur << "'");
         if (strncmp(lte->configTag, cur, strlen(lte->configTag)) == 0) {
@@ -318,40 +343,41 @@
             left = true;
             ++cur;
         }
 
         if (*cur == '0') {
             zero = true;
             ++cur;
         }
 
         char *endp;
         if (xisdigit(*cur)) {
             widthMin = strtol(cur, &endp, 10);
             cur = endp;
         }
 
         if (*cur == '.' && xisdigit(*(++cur))) {
             widthMax = strtol(cur, &endp, 10);
             cur = endp;
         }
 
+        // when {arg} field is before the token (old logformat syntax)
         if (*cur == '{') {
             char *cp;
             ++cur;
             l = strcspn(cur, "}");
             cp = (char *)xmalloc(l + 1);
             xstrncpy(cp, cur, l + 1);
             data.string = cp;
             cur += l;
 
             if (*cur == '}')
                 ++cur;
         }
 
         type = LFT_NONE;
 
         // Scan each registered token namespace
         debugs(46, 9, HERE << "check for token in " << TheConfig.tokens.size() << " namespaces.");
         for (std::list<TokenNamespace>::const_iterator itr = TheConfig.tokens.begin(); itr != TheConfig.tokens.end(); ++itr) {
             debugs(46, 7, HERE << "check for possible " << itr->prefix << ":: token");
             const size_t len = itr->prefix.size();
@@ -378,40 +404,55 @@
 
             // Scan for various long tokens
             debugs(46, 5, HERE << "scan for possible Misc token");
             cur = scanForToken(TokenTableMisc, cur);
             // scan for 2-char tokens
             if (type == LFT_NONE) {
                 debugs(46, 5, HERE << "scan for possible 2C token");
                 cur = scanForToken(TokenTable2C, cur);
             }
             // finally scan for 1-char tokens.
             if (type == LFT_NONE) {
                 debugs(46, 5, HERE << "scan for possible 1C token");
                 cur = scanForToken(TokenTable1C, cur);
             }
         }
 
         if (type == LFT_NONE) {
             fatalf("Can't parse configuration token: '%s'\n", def);
         }
 
+        // when {arg} field is after the token (old external_acl_type token syntax)
+        // but accept only if there was none before the token
+        if (*cur == '{' && !data.string) {
+            char *cp;
+            ++cur;
+            l = strcspn(cur, "}");
+            cp = (char *)xmalloc(l + 1);
+            xstrncpy(cp, cur, l + 1);
+            data.string = cp;
+            cur += l;
+
+            if (*cur == '}')
+                ++cur;
+        }
+
         if (*cur == ' ') {
             space = true;
             ++cur;
         }
     }
 
     switch (type) {
 
 #if USE_ADAPTATION
     case LFT_ADAPTATION_LAST_HEADER:
 #endif
 
 #if ICAP_CLIENT
     case LFT_ICAP_REQ_HEADER:
 
     case LFT_ICAP_REP_HEADER:
 #endif
 
     case LFT_ADAPTED_REQUEST_HEADER:
 


From vel21ripn at gmail.com  Fri Oct  9 08:53:22 2015
From: vel21ripn at gmail.com (Vitaly Lavrov)
Date: Fri, 9 Oct 2015 11:53:22 +0300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <56171C41.1090105@treenet.co.nz>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
 <56171C41.1090105@treenet.co.nz>
Message-ID: <56178082.7040708@gmail.com>

On 09.10.2015 04:45, Amos Jeffries wrote:
> On 9/10/2015 3:15 a.m., Vitaly Lavrov wrote:
>> On 07.10.2015 22:47, Alex Rousskov wrote:
>>
>> Hello Alex.
>>
>> Thanks for the quick response.
>>> Hello Vitaly,
>>>
>>>       I am glad you were able to fix the problem, and I thank you for
>>> sharing your fix.
>>>
>>> Unfortunately, the patch itself needs significant refactoring because
>>> you are [incorrectly] duplicating an already duplicated code. As you
>>> probably know, most of the code you added already exists in
>>> Ftp::Gateway::loginFailed() and, more importantly, in
>>> Ftp::Client::failed(). We do not need a third imperfect copy of that
>>> logic!
>> Yes, agree!
>>> 0. Undo your changes (the code may be reused at step #3).
>>>
>>> 1. Add an optional ErrorState *err parameter to ftpFail() with a default
>>> NULL value. When the parameter is not nil, ftpFail() should use it
>>> instead of creating its own ErrorState.
>>>
>>> 2. Change Ftp::Gateway::loginFailed() to always call ftpFail() after
>>> trying to create an ErrorState. Move the bottom of
>>> Ftp::Gateway::loginFailed() (i.e., the code that handles non-nil err) to
>>> ftpFail(). Test the refactored code for regressions. This change will
>>> not fix the bug you are after.
>>>
>>> 3. Compare the resulting ftpFail() with the code from your patch. Add
>>> any missing actions. Test that the resulting code works fine, including
>>> handling the bug you are after.
>> I added a field "ErrorState *ftperr" in class Ftp::Client. If it is not
>> NULL,
>> the Ftp::Client::failed() uses it.
>
> This is not what Alex meant by parameter.
>
> Function parameter is passed by the caller directly and only exists
> within the specific function call chain where it was passed. It cannot
> remain in memory interferring with other state or operations, does not
> need any extra constructor/destructor infrastructure code to manage its
> existence, and the value of the pointer being NULL/non-NULL can be used
> as the boolean of whether to use it or not.
>
> A member like ftperr may be setup by some earlier FTP transaction an
> unknown number of steps and time prior to the current error happening.
> Then prevents any following errors from using their own ErrorState
> object with details about the second error.
Here's a version without field "ftperr" and with an additional parameter
in the Ftp::CLient::failed().


-------------- next part --------------
A non-text attachment was scrubbed...
Name: squid-3.5-ftp_error_handle3.diff
Type: text/x-patch
Size: 4466 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151009/6b910134/attachment.bin>

From noc at squid-cache.org  Fri Oct  9 10:10:32 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 9 Oct 2015 10:10:32 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #887
In-Reply-To: <1056169414.471.1444334802787.JavaMail.jenkins@buildmaster>
References: <1056169414.471.1444334802787.JavaMail.jenkins@buildmaster>
Message-ID: <2098638761.480.1444385432436.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/887/>


From squid3 at treenet.co.nz  Sun Oct 11 05:17:25 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Sun, 11 Oct 2015 18:17:25 +1300
Subject: [squid-dev] [PATCH] remove HttpsPortList
Message-ID: <5619F0E5.3010101@treenet.co.nz>

Combine the https_port list internal state with http_port state.
These two lists have been near identical for some time now and we can
easily reduce code by simply merging the two and using either the
secure.encryptTransport flag or the transport.protocol type to select
the remaining non-identical code paths.

There are only minor documentation changes resulting from this change.

Amos

-------------- next part --------------
=== modified file 'src/anyp/PortCfg.cc'
--- src/anyp/PortCfg.cc	2015-09-24 21:08:23 +0000
+++ src/anyp/PortCfg.cc	2015-10-10 06:35:15 +0000
@@ -2,43 +2,40 @@
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "anyp/PortCfg.h"
 #include "comm.h"
 #include "fatal.h"
 #include "security/PeerOptions.h"
 #if USE_OPENSSL
 #include "ssl/support.h"
 #endif
 
 #include <cstring>
 #include <limits>
 
 AnyP::PortCfgPointer HttpPortList;
-#if USE_OPENSSL
-AnyP::PortCfgPointer HttpsPortList;
-#endif
 AnyP::PortCfgPointer FtpPortList;
 
 int NHttpSockets = 0;
 int HttpSockets[MAXTCPLISTENPORTS];
 
 AnyP::PortCfg::PortCfg() :
     next(),
     s(),
     transport(AnyP::PROTO_HTTP,1,1), // "Squid is an HTTP proxy", etc.
     name(NULL),
     defaultsite(NULL),
     flags(),
     allow_direct(false),
     vhost(false),
     actAsOrigin(false),
     ignore_cc(false),
     connection_auth_disabled(false),
     ftp_track_dirs(false),
     vport(0),
     disable_pmtu_discovery(0),

=== modified file 'src/anyp/PortCfg.h'
--- src/anyp/PortCfg.h	2015-09-24 21:08:23 +0000
+++ src/anyp/PortCfg.h	2015-10-10 06:37:36 +0000
@@ -78,42 +78,37 @@
     char *tls_dh;
     char *sslContextSessionId; ///< "session id context" for staticSslContext
     bool generateHostCertificates; ///< dynamically make host cert for sslBump
     size_t dynamicCertMemCacheSize; ///< max size of generated certificates memory cache
 
     Ssl::SSL_CTX_Pointer staticSslContext; ///< for HTTPS accelerator or static sslBump
     Security::CertPointer signingCert; ///< x509 certificate for signing generated certificates
     Ssl::EVP_PKEY_Pointer signPkey; ///< private key for sighing generated certificates
     Ssl::X509_STACK_Pointer certsToChain; ///<  x509 certificates to send with the generated cert
     Security::CertPointer untrustedSigningCert; ///< x509 certificate for signing untrusted generated certificates
     Ssl::EVP_PKEY_Pointer untrustedSignPkey; ///< private key for signing untrusted generated certificates
 
     Ssl::X509_NAME_STACK_Pointer clientCA; ///< CA certificates to use when verifying client certificates
     Ssl::DH_Pointer dhParams; ///< DH parameters for temporary/ephemeral DH key exchanges
     char *eecdhCurve; ///< Elliptic curve for ephemeral EC-based DH key exchanges
 #endif
 };
 
 } // namespace AnyP
 
-/// list of Squid http_port configured
+/// list of Squid http(s)_port configured
 extern AnyP::PortCfgPointer HttpPortList;
 
-#if USE_OPENSSL
-/// list of Squid https_port configured
-extern AnyP::PortCfgPointer HttpsPortList;
-#endif
-
 /// list of Squid ftp_port configured
 extern AnyP::PortCfgPointer FtpPortList;
 
 #if !defined(MAXTCPLISTENPORTS)
 // Max number of TCP listening ports
 #define MAXTCPLISTENPORTS 128
 #endif
 
 // TODO: kill this global array. Need to check performance of array vs list though.
 extern int NHttpSockets;
 extern int HttpSockets[MAXTCPLISTENPORTS];
 
 #endif /* SQUID_ANYP_PORTCFG_H */
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-10-09 06:02:01 +0000
+++ src/cache_cf.cc	2015-10-10 06:16:17 +0000
@@ -878,52 +878,45 @@
     }
 
     for (CachePeer *p = Config.peers; p != NULL; p = p->next) {
 
         // default value for ssldomain= is the peer host/IP
         if (p->secure.sslDomain.isEmpty())
             p->secure.sslDomain = p->host;
 
         if (p->secure.encryptTransport) {
             debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " TLS context");
             p->sslContext = p->secure.createClientContext(true);
             if (!p->sslContext) {
                 debugs(3, DBG_CRITICAL, "ERROR: Could not initialize cache_peer " << p->name << " TLS context");
                 self_destruct();
             }
         }
     }
 
 #if USE_OPENSSL
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
-        if (!s->flags.tunnelSslBumping)
+        if (!s->secure.encryptTransport)
             continue;
-
-        debugs(3, DBG_IMPORTANT, "Initializing http_port " << s->s << " SSL context");
+        debugs(3, DBG_IMPORTANT, "Initializing " << AnyP::UriScheme(s->transport.protocol) << "_port " << s->s << " TLS context");
         s->configureSslServerContext();
     }
-
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
-        debugs(3, DBG_IMPORTANT, "Initializing https_port " << s->s << " SSL context");
-        s->configureSslServerContext();
-    }
-
 #endif
 
     // prevent infinite fetch loops in the request parser
     // due to buffer full but not enough data recived to finish parse
     if (Config.maxRequestBufferSize <= Config.maxRequestHeaderSize) {
         fatalf("Client request buffer of %u bytes cannot hold a request with %u bytes of headers." \
                " Change client_request_buffer_max or request_header_max_size limits.",
                (uint32_t)Config.maxRequestBufferSize, (uint32_t)Config.maxRequestHeaderSize);
     }
 
     /*
      * Disable client side request pipelining if client_persistent_connections OFF.
      * Waste of resources queueing any pipelined requests when the first will close the connection.
      */
     if (Config.pipeline_max_prefetch > 0 && !Config.onoff.client_pconns) {
         debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: pipeline_prefetch " << Config.pipeline_max_prefetch <<
                " requires client_persistent_connections ON. Forced pipeline_prefetch 0.");
         Config.pipeline_max_prefetch = 0;
     }
 

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-10-10 07:11:39 +0000
+++ src/cf.data.pre	2015-10-10 07:11:59 +0000
@@ -2040,44 +2040,44 @@
 			timeout the time before giving up.
 
 	   require-proxy-header
 			Require PROXY protocol version 1 or 2 connections.
 			The proxy_protocol_access is required to whitelist
 			downstream proxies which can be trusted.
 
 	If you run Squid on a dual-homed machine with an internal
 	and an external interface we recommend you to specify the
 	internal address:port in http_port. This way Squid will only be
 	visible on the internal address.
 
 NOCOMMENT_START
 
 # Squid normally listens to port 3128
 http_port @DEFAULT_HTTP_PORT@
 NOCOMMENT_END
 DOC_END
 
 NAME: https_port
-IFDEF: USE_OPENSSL
+IFDEF: USE_GNUTLS||USE_OPENSSL
 TYPE: PortCfg
 DEFAULT: none
-LOC: HttpsPortList
+LOC: HttpPortList
 DOC_START
 	Usage:  [ip:]port [mode] cert=certificate.pem [options]
 
 	The socket address where Squid will listen for client requests made
 	over TLS or SSL connections. Commonly referred to as HTTPS.
 
 	This is most useful for situations where you are running squid in
 	accelerator mode and you want to do the TLS work at the accelerator level.
 
 	You may specify multiple socket addresses on multiple lines,
 	each with their own certificate and/or options.
 
 	The TLS cert= option is mandatory on HTTPS ports.
 
 	See http_port for a list of modes and options.
 DOC_END
 
 NAME: ftp_port
 TYPE: PortCfg
 DEFAULT: none

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-09-27 10:30:23 +0000
+++ src/client_side.cc	2015-10-11 04:24:59 +0000
@@ -4359,137 +4359,108 @@
     }
     return true;
 }
 
 /// find any unused HttpSockets[] slot and store fd there or return false
 static bool
 AddOpenedHttpSocket(const Comm::ConnectionPointer &conn)
 {
     bool found = false;
     for (int i = 0; i < NHttpSockets && !found; ++i) {
         if ((found = HttpSockets[i] < 0))
             HttpSockets[i] = conn->fd;
     }
     return found;
 }
 
 static void
 clientHttpConnectionsOpen(void)
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
+        const char *scheme = AnyP::UriScheme(s->transport.protocol).c_str();
+
         if (MAXTCPLISTENPORTS == NHttpSockets) {
-            debugs(1, DBG_IMPORTANT, "WARNING: You have too many 'http_port' lines.");
+            debugs(1, DBG_IMPORTANT, "WARNING: You have too many '" << scheme << "_port' lines.");
             debugs(1, DBG_IMPORTANT, "         The limit is " << MAXTCPLISTENPORTS << " HTTP ports.");
             continue;
         }
 
 #if USE_OPENSSL
-        if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
-            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << AnyP::UriScheme(s->transport.protocol) << "_port " << s->s);
-            s->flags.tunnelSslBumping = false;
-        }
-
-        if (s->flags.tunnelSslBumping &&
-                !s->staticSslContext &&
-                !s->generateHostCertificates) {
-            debugs(1, DBG_IMPORTANT, "Will not bump SSL at http_port " << s->s << " due to SSL initialization failure.");
-            s->flags.tunnelSslBumping = false;
-        }
         if (s->flags.tunnelSslBumping) {
-            // Create ssl_ctx cache for this port.
-            Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
+            if (!Config.accessList.ssl_bump) {
+                debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << scheme << "_port " << s->s);
+                s->flags.tunnelSslBumping = false;
+            }
+            if (!s->staticSslContext && !s->generateHostCertificates) {
+                debugs(1, DBG_IMPORTANT, "Will not bump SSL at " << scheme << "_port " << s->s << " due to TLS initialization failure.");
+                s->flags.tunnelSslBumping = false;
+                if (s->transport.protocol == AnyP::PROTO_HTTP)
+                    s->secure.encryptTransport = false;
+            }
+            if (s->flags.tunnelSslBumping) {
+                // Create ssl_ctx cache for this port.
+                auto sz = s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize;
+                Ssl::TheGlobalContextStorage.addLocalStorage(s->s, sz);
+            }
         }
 #endif
 
-        // Fill out a Comm::Connection which IPC will open as a listener for us
-        //  then pass back when active so we can start a TcpAcceptor subscription.
-        s->listenConn = new Comm::Connection;
-        s->listenConn->local = s->s;
-        s->listenConn->flags = COMM_NONBLOCKING | (s->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) | (s->flags.natIntercept ? COMM_INTERCEPTION : 0);
-
-        // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
-        typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
-        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpAccept", CommAcceptCbPtrFun(httpAccept, CommAcceptCbParams(NULL)));
-        Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
-
-        AsyncCall::Pointer listenCall = asyncCall(33,2, "clientListenerConnectionOpened",
-                                        ListeningStartedDialer(&clientListenerConnectionOpened, s, Ipc::fdnHttpSocket, sub));
-        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->listenConn, Ipc::fdnHttpSocket, listenCall);
-
-        HttpSockets[NHttpSockets] = -1; // set in clientListenerConnectionOpened
-        ++NHttpSockets;
-    }
-}
-
-#if USE_OPENSSL
-static void
-clientHttpsConnectionsOpen(void)
-{
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
-        if (MAXTCPLISTENPORTS == NHttpSockets) {
-            debugs(1, DBG_IMPORTANT, "Ignoring 'https_port' lines exceeding the limit.");
-            debugs(1, DBG_IMPORTANT, "The limit is " << MAXTCPLISTENPORTS << " HTTPS ports.");
-            continue;
-        }
-
-        if (!s->staticSslContext) {
-            debugs(1, DBG_IMPORTANT, "Ignoring https_port " << s->s <<
-                   " due to SSL initialization failure.");
+        if (s->secure.encryptTransport && !s->staticSslContext) {
+            debugs(1, DBG_CRITICAL, "ERROR: Ignoring " << scheme << "_port " << s->s << " due to TLS context initialization failure.");
             continue;
         }
 
-        // TODO: merge with similar code in clientHttpConnectionsOpen()
-        if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
-            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << AnyP::UriScheme(s->transport.protocol) << "_port " << s->s);
-            s->flags.tunnelSslBumping = false;
-        }
-
-        if (s->flags.tunnelSslBumping && !s->staticSslContext && !s->generateHostCertificates) {
-            debugs(1, DBG_IMPORTANT, "Will not bump SSL at https_port " << s->s << " due to SSL initialization failure.");
-            s->flags.tunnelSslBumping = false;
-        }
-
-        if (s->flags.tunnelSslBumping) {
-            // Create ssl_ctx cache for this port.
-            Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
-        }
-
         // Fill out a Comm::Connection which IPC will open as a listener for us
+        //  then pass back when active so we can start a TcpAcceptor subscription.
         s->listenConn = new Comm::Connection;
         s->listenConn->local = s->s;
+
         s->listenConn->flags = COMM_NONBLOCKING | (s->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
                                (s->flags.natIntercept ? COMM_INTERCEPTION : 0);
 
-        // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
-        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpsAccept", CommAcceptCbPtrFun(httpsAccept, CommAcceptCbParams(NULL)));
-        Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
+        if (s->transport.protocol == AnyP::PROTO_HTTP) {
+            // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
+            RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpAccept", CommAcceptCbPtrFun(httpAccept, CommAcceptCbParams(NULL)));
+            Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
+
+            AsyncCall::Pointer listenCall = asyncCall(33,2, "clientListenerConnectionOpened",
+                                            ListeningStartedDialer(&clientListenerConnectionOpened, s, Ipc::fdnHttpSocket, sub));
+            Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->listenConn, Ipc::fdnHttpSocket, listenCall);
+
+#if USE_OPENSSL
+        } else if (s->transport.protocol == AnyP::PROTO_HTTPS) {
+            // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
+            RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpsAccept", CommAcceptCbPtrFun(httpsAccept, CommAcceptCbParams(NULL)));
+            Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
+
+            AsyncCall::Pointer listenCall = asyncCall(33, 2, "clientListenerConnectionOpened",
+                                            ListeningStartedDialer(&clientListenerConnectionOpened,
+                                                    s, Ipc::fdnHttpsSocket, sub));
+            Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->listenConn, Ipc::fdnHttpsSocket, listenCall);
+#endif
+        }
 
-        AsyncCall::Pointer listenCall = asyncCall(33, 2, "clientListenerConnectionOpened",
-                                        ListeningStartedDialer(&clientListenerConnectionOpened,
-                                                s, Ipc::fdnHttpsSocket, sub));
-        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->listenConn, Ipc::fdnHttpsSocket, listenCall);
-        HttpSockets[NHttpSockets] = -1;
+        HttpSockets[NHttpSockets] = -1; // set in clientListenerConnectionOpened
         ++NHttpSockets;
     }
 }
-#endif
 
 void
 clientStartListeningOn(AnyP::PortCfgPointer &port, const RefCount< CommCbFunPtrCallT<CommAcceptCbPtrFun> > &subCall, const Ipc::FdNoteId fdNote)
 {
     // Fill out a Comm::Connection which IPC will open as a listener for us
     port->listenConn = new Comm::Connection;
     port->listenConn->local = port->s;
     port->listenConn->flags =
         COMM_NONBLOCKING |
         (port->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
         (port->flags.natIntercept ? COMM_INTERCEPTION : 0);
 
     // route new connections to subCall
     typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
     Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
     AsyncCall::Pointer listenCall =
         asyncCall(33, 2, "clientListenerConnectionOpened",
                   ListeningStartedDialer(&clientListenerConnectionOpened,
                                          port, fdNote, sub));
     Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, port->listenConn, fdNote, listenCall);
@@ -4511,69 +4482,56 @@
     Must(Comm::IsConnOpen(s->listenConn));
 
     // TCP: setup a job to handle accept() with subscribed handler
     AsyncJob::Start(new Comm::TcpAcceptor(s, FdNote(portTypeNote), sub));
 
     debugs(1, DBG_IMPORTANT, "Accepting " <<
            (s->flags.natIntercept ? "NAT intercepted " : "") <<
            (s->flags.tproxyIntercept ? "TPROXY intercepted " : "") <<
            (s->flags.tunnelSslBumping ? "SSL bumped " : "") <<
            (s->flags.accelSurrogate ? "reverse-proxy " : "")
            << FdNote(portTypeNote) << " connections at "
            << s->listenConn);
 
     Must(AddOpenedHttpSocket(s->listenConn)); // otherwise, we have received a fd we did not ask for
 }
 
 void
 clientOpenListenSockets(void)
 {
     clientHttpConnectionsOpen();
-#if USE_OPENSSL
-    clientHttpsConnectionsOpen();
-#endif
     Ftp::StartListening();
 
     if (NHttpSockets < 1)
         fatal("No HTTP, HTTPS, or FTP ports configured");
 }
 
 void
 clientConnectionsClose()
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL) {
-            debugs(1, DBG_IMPORTANT, "Closing HTTP port " << s->listenConn->local);
-            s->listenConn->close();
-            s->listenConn = NULL;
-        }
-    }
-
-#if USE_OPENSSL
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
-        if (s->listenConn != NULL) {
-            debugs(1, DBG_IMPORTANT, "Closing HTTPS port " << s->listenConn->local);
+            debugs(1, DBG_IMPORTANT, "Closing HTTP(S) port " << s->listenConn->local);
             s->listenConn->close();
             s->listenConn = NULL;
         }
     }
-#endif
 
     Ftp::StopListening();
 
     // TODO see if we can drop HttpSockets array entirely */
     for (int i = 0; i < NHttpSockets; ++i) {
         HttpSockets[i] = -1;
     }
 
     NHttpSockets = 0;
 }
 
 int
 varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
 {
     const char *vary = request->vary_headers;
     int has_vary = entry->getReply()->header.has(Http::HdrType::VARY);
 #if X_ACCELERATOR_VARY
 
     has_vary |=
         entry->getReply()->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY);

=== modified file 'src/ssl/helper.cc'
--- src/ssl/helper.cc	2015-05-18 12:50:03 +0000
+++ src/ssl/helper.cc	2015-10-10 06:35:44 +0000
@@ -29,42 +29,40 @@
 }
 
 Ssl::Helper::Helper() : ssl_crtd(NULL)
 {
 }
 
 Ssl::Helper::~Helper()
 {
     Shutdown();
 }
 
 void Ssl::Helper::Init()
 {
     assert(ssl_crtd == NULL);
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL *and* generate certificates
     // TODO: generate host certificates for SNI enabled accel ports
     bool found = false;
     for (AnyP::PortCfgPointer s = HttpPortList; !found && s != NULL; s = s->next)
         found = s->flags.tunnelSslBumping && s->generateHostCertificates;
-    for (AnyP::PortCfgPointer s = HttpsPortList; !found && s != NULL; s = s->next)
-        found = s->flags.tunnelSslBumping && s->generateHostCertificates;
     if (!found)
         return;
 
     ssl_crtd = new helper("ssl_crtd");
     ssl_crtd->childs.updateLimits(Ssl::TheConfig.ssl_crtdChildren);
     ssl_crtd->ipc_type = IPC_STREAM;
     // The crtd messages may contain the eol ('\n') character. We are
     // going to use the '\1' char as the end-of-message mark.
     ssl_crtd->eom = '\1';
     assert(ssl_crtd->cmdline == NULL);
     {
         char *tmp = xstrdup(Ssl::TheConfig.ssl_crtd);
         char *tmp_begin = tmp;
         char * token = NULL;
         bool db_path_was_found = false;
         bool block_size_was_found = false;
         char buffer[20] = "2048";
         while ((token = strwordtok(NULL, &tmp))) {
             wordlistAdd(&ssl_crtd->cmdline, token);
             if (!strcmp(token, "-b"))
@@ -121,42 +119,40 @@
     return &sslHelper;
 }
 
 Ssl::CertValidationHelper::CertValidationHelper() : ssl_crt_validator(NULL)
 {
 }
 
 Ssl::CertValidationHelper::~CertValidationHelper()
 {
     Shutdown();
 }
 
 void Ssl::CertValidationHelper::Init()
 {
     assert(ssl_crt_validator == NULL);
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL
     bool found = false;
     for (AnyP::PortCfgPointer s = HttpPortList; !found && s != NULL; s = s->next)
         found = s->flags.tunnelSslBumping;
-    for (AnyP::PortCfgPointer s = HttpsPortList; !found && s != NULL; s = s->next)
-        found = s->flags.tunnelSslBumping;
     if (!found)
         return;
 
     ssl_crt_validator = new helper("ssl_crt_validator");
     ssl_crt_validator->childs.updateLimits(Ssl::TheConfig.ssl_crt_validator_Children);
     ssl_crt_validator->ipc_type = IPC_STREAM;
     // The crtd messages may contain the eol ('\n') character. We are
     // going to use the '\1' char as the end-of-message mark.
     ssl_crt_validator->eom = '\1';
     assert(ssl_crt_validator->cmdline == NULL);
 
     int ttl = 60;
     size_t cache = 2048;
     {
         char *tmp = xstrdup(Ssl::TheConfig.ssl_crt_validator);
         char *tmp_begin = tmp;
         char * token = NULL;
         bool parseParams = true;
         while ((token = strwordtok(NULL, &tmp))) {
             if (parseParams) {

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2015-10-03 05:26:00 +0000
+++ src/ssl/support.cc	2015-10-10 06:37:11 +0000
@@ -1420,79 +1420,73 @@
     // the reference count is not incremented and therefore the session must
     // not be explicitly freed with SSL_SESSION_free(3).
     *copy = 0;
     return session;
 }
 
 static void
 setSessionCallbacks(SSL_CTX *ctx)
 {
     if (SslSessionCache) {
         SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER|SSL_SESS_CACHE_NO_INTERNAL);
         SSL_CTX_sess_set_new_cb(ctx, store_session_cb);
         SSL_CTX_sess_set_remove_cb(ctx, remove_session_cb);
         SSL_CTX_sess_set_get_cb(ctx, get_session_cb);
     }
 }
 
 static bool
 isSslServer()
 {
-    if (HttpsPortList != NULL)
-        return true;
-
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
+        if (s->secure.encryptTransport)
+            return true;
         if (s->flags.tunnelSslBumping)
             return true;
     }
 
     return false;
 }
 
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
 void
 Ssl::initialize_session_cache()
 {
 
     if (!isSslServer()) //no need to configure ssl session cache.
         return;
 
     // Check if the MemMap keys and data are enough big to hold
     // session ids and session data
     assert(SSL_SESSION_ID_SIZE >= MEMMAP_SLOT_KEY_SIZE);
     assert(SSL_SESSION_MAX_SIZE >= MEMMAP_SLOT_DATA_SIZE);
 
     int configuredItems = ::Config.SSL.sessionCacheSize / sizeof(Ipc::MemMap::Slot);
     if (IamWorkerProcess() && configuredItems)
         SslSessionCache = new Ipc::MemMap(SslSessionCacheName);
     else {
         SslSessionCache = NULL;
         return;
     }
 
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
-        if (s->staticSslContext.get() != NULL)
-            setSessionCallbacks(s->staticSslContext.get());
-    }
-
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->staticSslContext.get() != NULL)
             setSessionCallbacks(s->staticSslContext.get());
     }
 }
 
 void
 destruct_session_cache()
 {
     delete SslSessionCache;
 }
 
 /// initializes shared memory segments used by MemStore
 class SharedSessionCacheRr: public Ipc::Mem::RegisteredRunner
 {
 public:
     /* RegisteredRunner API */
     SharedSessionCacheRr(): owner(NULL) {}
     virtual void useConfig();
     virtual ~SharedSessionCacheRr();

=== modified file 'src/tools.cc'
--- src/tools.cc	2015-08-30 00:26:47 +0000
+++ src/tools.cc	2015-10-10 06:21:06 +0000
@@ -404,47 +404,40 @@
 
 const char *
 getMyHostname(void)
 {
     LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
     static int present = 0;
     struct addrinfo *AI = NULL;
     Ip::Address sa;
 
     if (Config.visibleHostname != NULL)
         return Config.visibleHostname;
 
     if (present)
         return host;
 
     host[0] = '\0';
 
     if (HttpPortList != NULL && sa.isAnyAddr())
         sa = HttpPortList->s;
 
-#if USE_OPENSSL
-
-    if (HttpsPortList != NULL && sa.isAnyAddr())
-        sa = HttpsPortList->s;
-
-#endif
-
     /*
      * If the first http_port address has a specific address, try a
      * reverse DNS lookup on it.
      */
     if ( !sa.isAnyAddr() ) {
 
         sa.getAddrInfo(AI);
         /* we are looking for a name. */
         if (getnameinfo(AI->ai_addr, AI->ai_addrlen, host, SQUIDHOSTNAMELEN, NULL, 0, NI_NAMEREQD ) == 0) {
             /* DNS lookup successful */
             /* use the official name from DNS lookup */
             debugs(50, 4, "getMyHostname: resolved " << sa << " to '" << host << "'");
 
             present = 1;
 
             Ip::Address::FreeAddr(AI);
 
             if (strchr(host, '.'))
                 return host;
         }
@@ -1061,50 +1054,40 @@
             fqdncacheAddEntryFromHosts(addr, hosts);
             wordlistDestroy(&hosts);
         }
     }
 
     fclose (fp);
 }
 
 int
 getMyPort(void)
 {
     AnyP::PortCfgPointer p;
     if ((p = HttpPortList) != NULL) {
         // skip any special interception ports
         while (p != NULL && p->flags.isIntercepted())
             p = p->next;
         if (p != NULL)
             return p->s.port();
     }
 
-#if USE_OPENSSL
-    if ((p = HttpsPortList) != NULL) {
-        // skip any special interception ports
-        while (p != NULL && p->flags.isIntercepted())
-            p = p->next;
-        if (p != NULL)
-            return p->s.port();
-    }
-#endif
-
     if ((p = FtpPortList) != NULL) {
         // skip any special interception ports
         while (p != NULL && p->flags.isIntercepted())
             p = p->next;
         if (p != NULL)
             return p->s.port();
     }
 
     debugs(21, DBG_CRITICAL, "ERROR: No forward-proxy ports configured.");
     return 0; // Invalid port. This will result in invalid URLs on bad configurations.
 }
 
 /*
  * Set the umask to at least the given mask. This is in addition
  * to the umask set at startup
  */
 void
 setUmask(mode_t mask)
 {
     // No way to get the current umask value without setting it.


From squid3 at treenet.co.nz  Sun Oct 11 14:10:40 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Mon, 12 Oct 2015 03:10:40 +1300
Subject: [squid-dev] [PATCH] external_acl_type logformat tokens
In-Reply-To: <5617490E.8070401@treenet.co.nz>
References: <560F933B.8040804@treenet.co.nz>
 <561534A3.1090406@measurement-factory.com> <5617490E.8070401@treenet.co.nz>
Message-ID: <561A6DDF.6010404@treenet.co.nz>

Applied to trunk as rev.14351.

Amos


From squid3 at treenet.co.nz  Sun Oct 11 15:56:13 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Mon, 12 Oct 2015 04:56:13 +1300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <56178082.7040708@gmail.com>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
 <56171C41.1090105@treenet.co.nz> <56178082.7040708@gmail.com>
Message-ID: <561A869D.8090305@treenet.co.nz>

Attached is a cleaned version of the patch. It now meets the source
coding guidelines, and applies cleanly to trunk / Squid-4.

I took the opportunity to remove two useless if() conditions - one was
duplicate checking a value, the other for values in a pointer that was
just new()'d.


Logic looks mostly okay, but this part in the middle of
Ftp::Gateway::loginFailed() is rather odd:

-    // any other problems are general falures.
-    if (!err) {
-        ftpFail(this);
+    if (!err)
         return;
-    }

The original behaviour was to output an error and perform the ftpQuit()
sequence. Now it appears to just halt without doing anything.

Is that behaviour change intentional? I suspect the correct behaviour is
to remove that if()-condition entirely, but I'm unsure.

Amos

-------------- next part --------------
=== modified file 'src/clients/FtpClient.cc'
--- src/clients/FtpClient.cc	2015-08-30 00:26:47 +0000
+++ src/clients/FtpClient.cc	2015-10-11 15:21:07 +0000
@@ -225,75 +225,86 @@
         debugs(9, 3, "closing FTP data FD " << data.conn->fd << ", this " << this);
         data.close();
     }
 
     debugs(9, 3, "FTP ctrl and data connections closed. this " << this);
 }
 
 /**
  * Did we close all FTP server connection(s)?
  *
  \retval true  Both server control and data channels are closed. And not waiting for a new data connection to open.
  \retval false Either control channel or data is still active.
  */
 bool
 Ftp::Client::doneWithServer() const
 {
     return !Comm::IsConnOpen(ctrl.conn) && !Comm::IsConnOpen(data.conn);
 }
 
 void
-Ftp::Client::failed(err_type error, int xerrno)
+Ftp::Client::failed(err_type error, int xerrno, ErrorState *err)
 {
     debugs(9, 3, "entry-null=" << (entry?entry->isEmpty():0) << ", entry=" << entry);
 
     const char *command, *reply;
-    const Http::StatusCode httpStatus = failedHttpStatus(error);
-    ErrorState *const ftperr = new ErrorState(error, httpStatus, fwd->request);
+    ErrorState *ftperr;
+
+    if (err) {
+        debugs(9, 6, "error=" << err->type << ", code=" << xerrno <<
+               ", status=" << err->httpStatus);
+        error = err->type;
+        ftperr = err;
+    } else {
+        Http::StatusCode httpStatus = failedHttpStatus(error);
+        ftperr = new ErrorState(error, httpStatus, fwd->request);
+    }
+
     ftperr->xerrno = xerrno;
 
     ftperr->ftp.server_msg = ctrl.message;
     ctrl.message = NULL;
 
     if (old_request)
         command = old_request;
     else
         command = ctrl.last_command;
 
     if (command && strncmp(command, "PASS", 4) == 0)
         command = "PASS <yourpassword>";
 
     if (old_reply)
         reply = old_reply;
     else
         reply = ctrl.last_reply;
 
     if (command)
         ftperr->ftp.request = xstrdup(command);
 
     if (reply)
         ftperr->ftp.reply = xstrdup(reply);
 
-    fwd->request->detailError(error, xerrno);
-    fwd->fail(ftperr);
-
-    closeServer(); // we failed, so no serverComplete()
+    if (!err) {
+        fwd->request->detailError(error, xerrno);
+        fwd->fail(ftperr);
+        closeServer(); // we failed, so no serverComplete()
+    }
 }
 
 Http::StatusCode
 Ftp::Client::failedHttpStatus(err_type &error)
 {
     if (error == ERR_NONE)
         error = ERR_FTP_FAILURE;
     return error == ERR_READ_TIMEOUT ? Http::scGatewayTimeout :
            Http::scBadGateway;
 }
 
 /**
  * DPW 2007-04-23
  * Looks like there are no longer anymore callers that set
  * buffered_ok=1.  Perhaps it can be removed at some point.
  */
 void
 Ftp::Client::scheduleReadControlReply(int buffered_ok)
 {
     debugs(9, 3, ctrl.conn);

=== modified file 'src/clients/FtpClient.h'
--- src/clients/FtpClient.h	2015-01-13 07:25:36 +0000
+++ src/clients/FtpClient.h	2015-10-11 14:52:02 +0000
@@ -81,41 +81,42 @@
 
     void addr(const Ip::Address &addr); ///< import host and port
 
 public:
     MemBuf *readBuf;
     char *host;
     unsigned short port;
     bool read_pending;
 };
 
 /// FTP client functionality shared among FTP Gateway and Relay clients.
 class Client: public ::Client
 {
     CBDATA_CLASS(Client);
 
 public:
     explicit Client(FwdState *fwdState);
     virtual ~Client();
 
     /// handle a fatal transaction error, closing the control connection
-    virtual void failed(err_type error = ERR_NONE, int xerrno = 0);
+    virtual void failed(err_type error = ERR_NONE, int xerrno = 0,
+                        ErrorState *ftperr = NULL);
 
     /// read timeout handler
     virtual void timeout(const CommTimeoutCbParams &io);
 
     /* Client API */
     virtual void maybeReadVirginBody();
 
     void writeCommand(const char *buf);
 
     /// extracts remoteAddr from PASV response, validates it,
     /// sets data address details, and returns true on success
     bool handlePasvReply(Ip::Address &remoteAddr);
     bool handleEpsvReply(Ip::Address &remoteAddr);
 
     bool sendEprt();
     bool sendPort();
     bool sendPassive();
     void connectDataChannel();
     bool openListenSocket();
     void switchTimeoutToDataChannel();

=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-08-24 16:51:17 +0000
+++ src/clients/FtpGateway.cc	2015-10-11 15:32:07 +0000
@@ -1210,86 +1210,62 @@
         ftpSendUser(ftpState);
     } else if (code == 120) {
         if (NULL != ftpState->ctrl.message)
             debugs(9, DBG_IMPORTANT, "FTP server is busy: " << ftpState->ctrl.message->key);
 
         return;
     } else {
         ftpFail(ftpState);
     }
 }
 
 /**
  * Translate FTP login failure into HTTP error
  * this is an attmpt to get the 407 message to show up outside Squid.
  * its NOT a general failure. But a correct FTP response type.
  */
 void
 Ftp::Gateway::loginFailed()
 {
     ErrorState *err = NULL;
-    const char *command, *reply;
 
     if ((state == SENT_USER || state == SENT_PASS) && ctrl.replycode >= 400) {
         if (ctrl.replycode == 421 || ctrl.replycode == 426) {
             // 421/426 - Service Overload - retry permitted.
             err = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd->request);
         } else if (ctrl.replycode >= 430 && ctrl.replycode <= 439) {
             // 43x - Invalid or Credential Error - retry challenge required.
             err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
         } else if (ctrl.replycode >= 530 && ctrl.replycode <= 539) {
             // 53x - Credentials Missing - retry challenge required
             if (password_url) // but they were in the URI! major fail.
                 err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd->request);
             else
                 err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
         }
     }
 
-    // any other problems are general falures.
-    if (!err) {
-        ftpFail(this);
+    if (!err)
         return;
-    }
-
-    err->ftp.server_msg = ctrl.message;
-
-    ctrl.message = NULL;
-
-    if (old_request)
-        command = old_request;
-    else
-        command = ctrl.last_command;
 
-    if (command && strncmp(command, "PASS", 4) == 0)
-        command = "PASS <yourpassword>";
-
-    if (old_reply)
-        reply = old_reply;
-    else
-        reply = ctrl.last_reply;
-
-    if (command)
-        err->ftp.request = xstrdup(command);
-
-    if (reply)
-        err->ftp.reply = xstrdup(reply);
+    failed(ERR_NONE, ctrl.replycode, err);
+    // any other problems are general falures.
 
     HttpReply *newrep = err->BuildHttpReply();
     delete err;
 
 #if HAVE_AUTH_MODULE_BASIC
     /* add Authenticate header */
     newrep->header.putAuth("Basic", ftpRealm());
 #endif
 
     // add it to the store entry for response....
     entry->replaceHttpReply(newrep);
     serverComplete();
 }
 
 const char *
 Ftp::Gateway::ftpRealm()
 {
     static char realm[8192];
 
     /* This request is not fully authenticated */
@@ -2396,67 +2372,78 @@
     debugs(9, 3, HERE);
 
     if (old_request == NULL) {
         old_request = ctrl.last_command;
         ctrl.last_command = NULL;
         old_reply = ctrl.last_reply;
         ctrl.last_reply = NULL;
 
         if (pathcomps == NULL && filepath != NULL)
             old_filepath = xstrdup(filepath);
     }
 
     /* Jump to the "hack" state */
     nextState(this);
 }
 
 static void
 ftpFail(Ftp::Gateway *ftpState)
 {
     const bool slashHack = ftpState->request->url.path().caseCmp("/%2f", 4)==0;
-    debugs(9, 6, "flags(" <<
+    int code = ftpState->ctrl.replycode;
+    err_type error_code = ERR_NONE;
+
+    debugs(9, 6, "state " << ftpState->state <<
+           " reply code " << code << "flags(" <<
            (ftpState->flags.isdir?"IS_DIR,":"") <<
            (ftpState->flags.try_slash_hack?"TRY_SLASH_HACK":"") << "), " <<
            "mdtm=" << ftpState->mdtm << ", size=" << ftpState->theSize <<
            "slashhack=" << (slashHack? "T":"F"));
 
     /* Try the / hack to support "Netscape" FTP URL's for retreiving files */
     if (!ftpState->flags.isdir &&   /* Not a directory */
             !ftpState->flags.try_slash_hack && !slashHack && /* Not doing slash hack */
             ftpState->mdtm <= 0 && ftpState->theSize < 0) { /* Not known as a file */
 
         switch (ftpState->state) {
 
         case Ftp::Client::SENT_CWD:
 
         case Ftp::Client::SENT_RETR:
             /* Try the / hack */
             ftpState->hackShortcut(ftpTrySlashHack);
             return;
 
         default:
             break;
         }
     }
 
-    ftpState->failed(ERR_NONE, 0);
-    /* failed() closes ctrl.conn and frees this */
+    Http::StatusCode sc = ftpState->failedHttpStatus(error_code);
+    ErrorState *ftperr = new ErrorState(error_code, sc, ftpState->fwd->request);
+    ftpState->failed(error_code, code, ftperr);
+    ftperr->detailError(code);
+    HttpReply *newrep = ftperr->BuildHttpReply();
+    delete ftperr;
+
+    ftpState->entry->replaceHttpReply(newrep);
+    ftpSendQuit(ftpState);
 }
 
 Http::StatusCode
 Ftp::Gateway::failedHttpStatus(err_type &error)
 {
     if (error == ERR_NONE) {
         switch (state) {
 
         case SENT_USER:
 
         case SENT_PASS:
 
             if (ctrl.replycode > 500) {
                 error = ERR_FTP_FORBIDDEN;
                 return password_url ? Http::scForbidden : Http::scUnauthorized;
             } else if (ctrl.replycode == 421) {
                 error = ERR_FTP_UNAVAILABLE;
                 return Http::scServiceUnavailable;
             }
             break;


From noc at squid-cache.org  Sun Oct 11 18:24:15 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Sun, 11 Oct 2015 18:24:15 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #889
Message-ID: <599570518.489.1444587856058.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/889/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 386
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14352 squid3 at treenet.co.nz-20151011160926-v86yv0wp50toe27h
" stderr: ""
RevisionState revno:14352 revid:squid3 at treenet.co.nz-20151011160926-v86yv0wp50toe27h
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson9076529386263244166.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 889 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From squid-user at tlinx.org  Sun Oct 11 22:31:54 2015
From: squid-user at tlinx.org (Linda A. Walsh)
Date: Sun, 11 Oct 2015 15:31:54 -0700
Subject: [squid-dev] got http2?
Message-ID: <561AE35A.1090507@tlinx.org>





I was looking at some traffic differences between one of
my browsers going through squid and going direct (via masquerade).

The protocol usage in the 2nd case used 'http2' -- which started me
wondering what the heck that was...so googled around and
found it is an optimized http/1.1 mostly meant for packing
a website and streaming the whole thing as a byte-stream
to the client.


Interestingly, a few things are starting to support it:
nginx, chrome, MS(w/partial support), later firefox
versions... and several others.

In the http2-working (ietf) group, webpage loading
was about 50% faster (obviously depending on number
of items).  Supposedly it has to be 'encrypted' w/
TLS2, BUT I see nothing in spec that requires that.

Notably google was talking about http2 support on
their website, and the availability of businesses
with web-proxys to request that their clients not
use the bump to TLS2, but still allow the main
things that speed things up -- appending multiple
web items in 1 binary stream and using both
header and body compression.

I could see several ways/levels of squid supporting
this, but looking through my local mail archives,
I didn't see 'http2' mentioned once --either
on the users or the dev list and this complete
lack of its mention is leading me to think of the
that there is no ongoing work for it or future
plans at this point?

I think it is partly being supported through the current
squid by encapsulating a http2 session in a
http1.1 "tunnel" -- which raises some problems.

All the kinks aren't worked out yet, but
Proxy-Users scenarios are shown at:

https://github.com/http2/http2-spec/wiki/Proxy-User-Stories

Are the impacts or implementation details
being thought about in squid?, since if it comes
down to it only being supported by encrypted
TUNNELS, its not only going to be hard to cache,
but also makes it a pain to implement http/browsing
controls on content -- since it would all
be encrypted and and compressed and impossible
to directly use in companies that need to filter
web-content as it comes in.

A bit concerned...
linda

(p.s. -- also sent to "-dev" group, but directed replies
to the user group -- feel free to reply as wanted, if
you feel it is needed, but didn't want to overload
dev list with something they may not be working on
yet and would just waste reading and 'discussion'
bandwidth)






From noc at squid-cache.org  Mon Oct 12 00:04:56 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Mon, 12 Oct 2015 00:04:56 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #890
In-Reply-To: <599570518.489.1444587856058.JavaMail.jenkins@buildmaster>
References: <599570518.489.1444587856058.JavaMail.jenkins@buildmaster>
Message-ID: <1856820083.490.1444608296504.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/890/>


From noc at squid-cache.org  Mon Oct 12 05:05:10 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Mon, 12 Oct 2015 05:05:10 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #891
Message-ID: <800825981.491.1444626311020.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/891/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 388
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14354 squid3 at treenet.co.nz-20151012013802-6s2xyslu9ub3sj5a
" stderr: ""
RevisionState revno:14354 revid:squid3 at treenet.co.nz-20151012013802-6s2xyslu9ub3sj5a
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson2255372732640380038.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 891 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From vel21ripn at gmail.com  Mon Oct 12 08:21:34 2015
From: vel21ripn at gmail.com (Vitaly Lavrov)
Date: Mon, 12 Oct 2015 11:21:34 +0300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <561A869D.8090305@treenet.co.nz>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
 <56171C41.1090105@treenet.co.nz> <56178082.7040708@gmail.com>
 <561A869D.8090305@treenet.co.nz>
Message-ID: <561B6D8E.6020809@gmail.com>

On 11.10.2015 18:56, Amos Jeffries wrote:
> Attached is a cleaned version of the patch. It now meets the source
> coding guidelines, and applies cleanly to trunk / Squid-4.
>
> I took the opportunity to remove two useless if() conditions - one was
> duplicate checking a value, the other for values in a pointer that was
> just new()'d.
>
>
> Logic looks mostly okay, but this part in the middle of
> Ftp::Gateway::loginFailed() is rather odd:
>
> -    // any other problems are general falures.
> -    if (!err) {
> -        ftpFail(this);
> +    if (!err)
>           return;
> -    }
>
> The original behaviour was to output an error and perform the ftpQuit()
> sequence. Now it appears to just halt without doing anything.
>
> Is that behaviour change intentional? I suspect the correct behaviour is
> to remove that if()-condition entirely, but I'm unsure.
It is possible that  ftpFail(this) was deleted accidentally during multiple rework code.
The original version "if(!err) { ftpFail(this); return; }" looks more logical.


From noc at squid-cache.org  Mon Oct 12 08:30:23 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Mon, 12 Oct 2015 08:30:23 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #892
In-Reply-To: <800825981.491.1444626311020.JavaMail.jenkins@buildmaster>
References: <800825981.491.1444626311020.JavaMail.jenkins@buildmaster>
Message-ID: <989507106.492.1444638623762.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/892/>


From squid3 at treenet.co.nz  Mon Oct 12 15:40:23 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Tue, 13 Oct 2015 04:40:23 +1300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <561B6D8E.6020809@gmail.com>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
 <56171C41.1090105@treenet.co.nz> <56178082.7040708@gmail.com>
 <561A869D.8090305@treenet.co.nz> <561B6D8E.6020809@gmail.com>
Message-ID: <561BD467.7060703@treenet.co.nz>

On 12/10/2015 9:21 p.m., Vitaly Lavrov wrote:
> On 11.10.2015 18:56, Amos Jeffries wrote:
>> Attached is a cleaned version of the patch. It now meets the source
>> coding guidelines, and applies cleanly to trunk / Squid-4.
>>
>> I took the opportunity to remove two useless if() conditions - one was
>> duplicate checking a value, the other for values in a pointer that was
>> just new()'d.
>>
>>
>> Logic looks mostly okay, but this part in the middle of
>> Ftp::Gateway::loginFailed() is rather odd:
>>
>> -    // any other problems are general falures.
>> -    if (!err) {
>> -        ftpFail(this);
>> +    if (!err)
>>           return;
>> -    }
>>
>> The original behaviour was to output an error and perform the ftpQuit()
>> sequence. Now it appears to just halt without doing anything.
>>
>> Is that behaviour change intentional? I suspect the correct behaviour is
>> to remove that if()-condition entirely, but I'm unsure.
> It is possible that  ftpFail(this) was deleted accidentally during
> multiple rework code.
> The original version "if(!err) { ftpFail(this); return; }" looks more
> logical.
> 

Could we get that tested please before I apply the patch to Squid-4.

Thanks
Amos


From vel21ripn at gmail.com  Mon Oct 12 16:44:17 2015
From: vel21ripn at gmail.com (Vitaly Lavrov)
Date: Mon, 12 Oct 2015 19:44:17 +0300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <561BD467.7060703@treenet.co.nz>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
 <56171C41.1090105@treenet.co.nz> <56178082.7040708@gmail.com>
 <561A869D.8090305@treenet.co.nz> <561B6D8E.6020809@gmail.com>
 <561BD467.7060703@treenet.co.nz>
Message-ID: <561BE361.4090407@gmail.com>

On 12.10.2015 18:40, Amos Jeffries wrote:
> On 12/10/2015 9:21 p.m., Vitaly Lavrov wrote:
>> On 11.10.2015 18:56, Amos Jeffries wrote:
>>> Attached is a cleaned version of the patch. It now meets the source
>>> coding guidelines, and applies cleanly to trunk / Squid-4.
>>>
>>> I took the opportunity to remove two useless if() conditions - one was
>>> duplicate checking a value, the other for values in a pointer that was
>>> just new()'d.
>>>
>>>
>>> Logic looks mostly okay, but this part in the middle of
>>> Ftp::Gateway::loginFailed() is rather odd:
>>>
>>> -    // any other problems are general falures.
>>> -    if (!err) {
>>> -        ftpFail(this);
>>> +    if (!err)
>>>            return;
>>> -    }
>>>
>>> The original behaviour was to output an error and perform the ftpQuit()
>>> sequence. Now it appears to just halt without doing anything.
>>>
>>> Is that behaviour change intentional? I suspect the correct behaviour is
>>> to remove that if()-condition entirely, but I'm unsure.
>> It is possible that  ftpFail(this) was deleted accidentally during
>> multiple rework code.
>> The original version "if(!err) { ftpFail(this); return; }" looks more
>> logical.
>>
>
> Could we get that tested please before I apply the patch to Squid-4.
All right. In the case of non-standard error code ftpFail() returns an error to the client ERR_FTP_FAILED/502.
>
> Thanks
> Amos
>


From squid3 at treenet.co.nz  Tue Oct 13 12:54:29 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Wed, 14 Oct 2015 01:54:29 +1300
Subject: [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a
 non-existent file via ftp
In-Reply-To: <561BE361.4090407@gmail.com>
References: <56156179.1040708@gmail.com>
 <561576C9.2080504@measurement-factory.com> <56167A9E.3020907@gmail.com>
 <56171C41.1090105@treenet.co.nz> <56178082.7040708@gmail.com>
 <561A869D.8090305@treenet.co.nz> <561B6D8E.6020809@gmail.com>
 <561BD467.7060703@treenet.co.nz> <561BE361.4090407@gmail.com>
Message-ID: <561CFF05.2000301@treenet.co.nz>

Applied to Squid-4 as rev.14355

Amos

From noc at squid-cache.org  Wed Oct 14 10:03:02 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Wed, 14 Oct 2015 10:03:02 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #894
Message-ID: <162695.493.1444816982907.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/894/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 391
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14356 squid3 at treenet.co.nz-20151014060723-c55e98yugjttramg
" stderr: ""
RevisionState revno:14356 revid:squid3 at treenet.co.nz-20151014060723-c55e98yugjttramg
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson4468986651800896943.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 894 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From rousskov at measurement-factory.com  Wed Oct 14 21:06:12 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Wed, 14 Oct 2015 15:06:12 -0600
Subject: [squid-dev] 1xx terminates Squid-to-server connection
Message-ID: <561EC3C4.7020007@measurement-factory.com>

Hello,

    HTTP 1xx responses terminate Squid-to-server connection in trunk,
breaking many PUTs. This regression probably existed since
trunk revision 13688 dated 2014-11-07 (Parser-NG: HTTP Parser structural
redesign).

The attached patch fixes the bug in my limited trunk tests. Amos, please
review if you can because I may have missed some reasons why the flag
setting code was changed -- the change was not mentioned in the commit
message for the merged revision 13688.1.6.


HTH,

Alex.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 1xx-terminates-conn.patch
Type: text/x-diff
Size: 2667 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151014/aa6771a4/attachment.patch>

From squid3 at treenet.co.nz  Thu Oct 15 02:54:15 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Thu, 15 Oct 2015 15:54:15 +1300
Subject: [squid-dev] 1xx terminates Squid-to-server connection
In-Reply-To: <561EC3C4.7020007@measurement-factory.com>
References: <561EC3C4.7020007@measurement-factory.com>
Message-ID: <561F1557.7000800@treenet.co.nz>

On 15/10/2015 10:06 a.m., Alex Rousskov wrote:
> Hello,
> 
>     HTTP 1xx responses terminate Squid-to-server connection in trunk,
> breaking many PUTs. This regression probably existed since
> trunk revision 13688 dated 2014-11-07 (Parser-NG: HTTP Parser structural
> redesign).
> 
> The attached patch fixes the bug in my limited trunk tests. Amos, please
> review if you can because I may have missed some reasons why the flag
> setting code was changed -- the change was not mentioned in the commit
> message for the merged revision 13688.1.6.
> 

Confirmed, and applied to trunk as rev.14357

Thank you.
Amos


From noc at squid-cache.org  Thu Oct 15 05:59:39 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Thu, 15 Oct 2015 05:59:39 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Build_failed_in_Jenkins=3A_trunk-matrix_?=
 =?utf-8?q?=C2=BB_gcc=2Cd-fedora-21_=23392?=
Message-ID: <1501952366.494.1444888779150.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/392/>

------------------------------------------
[...truncated 39712 lines...]
make[5]: Nothing to be done for 'all'.
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
make  check-TESTS
make[5]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
make[6]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
/bin/sh ../../../test-suite/testheaders.sh "ccache g++ -DHAVE_CONFIG_H   -I../../.. -I../../../include -I../../../lib -I../../../src -I../../include    -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11" ../../../src/snmp/Pdu.h ../../../src/snmp/Inquirer.h ../../../src/snmp/Forwarder.h ../../../src/snmp/forward.h ../../../src/snmp/Var.h ../../../src/snmp/Response.h ../../../src/snmp/Request.h ../../../src/snmp/Session.h || exit 1
Testing ../../../src/snmp/Pdu.h ...Ok.
Testing ../../../src/snmp/Inquirer.h ...Ok.
Testing ../../../src/snmp/Forwarder.h ...Ok.
Testing ../../../src/snmp/forward.h ...Ok.
Testing ../../../src/snmp/Var.h ...Ok.
Testing ../../../src/snmp/Response.h ...Ok.
Testing ../../../src/snmp/Request.h ...Ok.
Testing ../../../src/snmp/Session.h ...Ok.
PASS: testHeaders
make[7]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
make[7]: Nothing to be done for 'all'.
make[7]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
============================================================================
Testsuite summary for Squid Web Proxy 4.0.1-BZR
============================================================================
# TOTAL: 1
# PASS:  1
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
make[6]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/snmp'>
Making check in adaptation
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
Making check in icap
make[5]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make  
make[6]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[6]: Nothing to be done for 'all'.
make[6]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make  check-TESTS
make[6]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[7]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
/bin/sh ../../../../test-suite/testheaders.sh "ccache g++ -DHAVE_CONFIG_H   -I../../../.. -I../../../../include -I../../../../lib -I../../../../src -I../../../include    -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11" ../../../../src/adaptation/icap/Client.h ../../../../src/adaptation/icap/Options.h ../../../../src/adaptation/icap/OptXact.h ../../../../src/adaptation/icap/icap_log.h ../../../../src/adaptation/icap/Xaction.h ../../../../src/adaptation/icap/Config.h ../../../../src/adaptation/icap/ServiceRep.h ../../../../src/adaptation/icap/Launcher.h ../../../../src/adaptation/icap/History.h ../../../../src/adaptation/icap/InOut.h ../../../../src/adaptation/icap/ModXact.h ../../../../src/adaptation/icap/Elements.h || exit 1
Testing ../../../../src/adaptation/icap/Client.h ...Ok.
Testing ../../../../src/adaptation/icap/Options.h ...Ok.
Testing ../../../../src/adaptation/icap/OptXact.h ...Ok.
Testing ../../../../src/adaptation/icap/icap_log.h ...Ok.
Testing ../../../../src/adaptation/icap/Xaction.h ...Ok.
Testing ../../../../src/adaptation/icap/Config.h ...Ok.
Testing ../../../../src/adaptation/icap/ServiceRep.h ...Ok.
Testing ../../../../src/adaptation/icap/Launcher.h ...Ok.
Testing ../../../../src/adaptation/icap/History.h ...Ok.
Testing ../../../../src/adaptation/icap/InOut.h ...Ok.
Testing ../../../../src/adaptation/icap/ModXact.h ...Ok.
Testing ../../../../src/adaptation/icap/Elements.h ...Ok.
PASS: testHeaders
make[8]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[8]: Nothing to be done for 'all'.
make[8]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
============================================================================
Testsuite summary for Squid Web Proxy 4.0.1-BZR
============================================================================
# TOTAL: 1
# PASS:  1
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
make[7]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[6]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[5]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make  
make[6]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
Making all in icap
make[7]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[7]: Nothing to be done for 'all'.
make[7]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[7]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[7]: Nothing to be done for 'all-am'.
make[7]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[6]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make  check-TESTS
make[6]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[7]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
/bin/sh ../../../test-suite/testheaders.sh "ccache g++ -DHAVE_CONFIG_H   -I../../.. -I../../../include -I../../../lib -I../../../src -I../../include    -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11" ../../../src/adaptation/ServiceGroups.h ../../../src/adaptation/AccessCheck.h ../../../src/adaptation/Initiate.h ../../../src/adaptation/Answer.h ../../../src/adaptation/Config.h ../../../src/adaptation/DynamicGroupCfg.h ../../../src/adaptation/Iterator.h ../../../src/adaptation/forward.h ../../../src/adaptation/AccessRule.h ../../../src/adaptation/ServiceConfig.h ../../../src/adaptation/History.h ../../../src/adaptation/ServiceFilter.h ../../../src/adaptation/Initiator.h ../../../src/adaptation/Message.h ../../../src/adaptation/Elements.h ../../../src/adaptation/Service.h || exit 1
Testing ../../../src/adaptation/ServiceGroups.h ...Ok.
Testing ../../../src/adaptation/AccessCheck.h ...Ok.
Testing ../../../src/adaptation/Initiate.h ...Ok.
Testing ../../../src/adaptation/Answer.h ...Ok.
Testing ../../../src/adaptation/Config.h ...Ok.
Testing ../../../src/adaptation/DynamicGroupCfg.h ...Ok.
Testing ../../../src/adaptation/Iterator.h ...Ok.
Testing ../../../src/adaptation/forward.h ...Ok.
Testing ../../../src/adaptation/AccessRule.h ...Ok.
Testing ../../../src/adaptation/ServiceConfig.h ...Ok.
Testing ../../../src/adaptation/History.h ...Ok.
Testing ../../../src/adaptation/ServiceFilter.h ...Ok.
Testing ../../../src/adaptation/Initiator.h ...Ok.
Testing ../../../src/adaptation/Message.h ...Ok.
Testing ../../../src/adaptation/Elements.h ...Ok.
Testing ../../../src/adaptation/Service.h ...Ok.
PASS: testHeaders
make[8]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
Making all in icap
make[9]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[9]: Nothing to be done for 'all'.
make[9]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation/icap'>
make[9]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[9]: Nothing to be done for 'all-am'.
make[9]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[8]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
============================================================================
Testsuite summary for Squid Web Proxy 4.0.1-BZR
============================================================================
# TOTAL: 1
# PASS:  1
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
make[7]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[6]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
Making check in esi
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make  
make[5]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[5]: Nothing to be done for 'all'.
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make  check-TESTS
make[5]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[6]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
/bin/sh ../../../test-suite/testheaders.sh "ccache g++ -DHAVE_CONFIG_H   -I../../.. -I../../../include -I../../../lib -I../../../src -I../../include    -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11" ../../../src/esi/Attempt.h ../../../src/esi/Esi.h ../../../src/esi/Literal.h ../../../src/esi/Except.h ../../../src/esi/ExpatParser.h ../../../src/esi/Element.h ../../../src/esi/Context.h ../../../src/esi/ElementList.h ../../../src/esi/Module.h ../../../src/esi/VarState.h ../../../src/esi/Segment.h ../../../src/esi/CustomParser.h ../../../src/esi/Include.h ../../../src/esi/Sequence.h ../../../src/esi/Expression.h ../../../src/esi/Var.h ../../../src/esi/Libxml2Parser.h ../../../src/esi/Parser.h ../../../src/esi/Assign.h || exit 1
Testing ../../../src/esi/Attempt.h ...Ok.
Testing ../../../src/esi/Esi.h ...Ok.
Testing ../../../src/esi/Literal.h ...Ok.
Testing ../../../src/esi/Except.h ...Ok.
Testing ../../../src/esi/ExpatParser.h ...Ok.
Testing ../../../src/esi/Element.h ...Ok.
Testing ../../../src/esi/Context.h ...Ok.
Testing ../../../src/esi/ElementList.h ...Ok.
Testing ../../../src/esi/Module.h ...Ok.
Testing ../../../src/esi/VarState.h ...Ok.
Testing ../../../src/esi/Segment.h ...Ok.
Testing ../../../src/esi/CustomParser.h ...Ok.
Testing ../../../src/esi/Include.h ...Ok.
Testing ../../../src/esi/Sequence.h ...Ok.
Testing ../../../src/esi/Expression.h ...Ok.
Testing ../../../src/esi/Var.h ...Ok.
Testing ../../../src/esi/Libxml2Parser.h ...Ok.
Testing ../../../src/esi/Parser.h ...Ok.
Testing ../../../src/esi/Assign.h ...Ok.
PASS: testHeaders
make[7]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[7]: Nothing to be done for 'all'.
make[7]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
============================================================================
Testsuite summary for Squid Web Proxy 4.0.1-BZR
============================================================================
# TOTAL: 1
# PASS:  1
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
make[6]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
make  tests/testACLMaxUserIP tests/testBoilerplate tests/testCacheManager tests/testCharacterSet tests/testDiskIO tests/testDns tests/testEnumIterator tests/testEvent tests/testEventLoop tests/test_http_range tests/testTokenizer tests/testHttp1Parser tests/testHttpReply tests/testHttpRequest tests/testIcmp tests/testIpAddress tests/testStore tests/testString tests/testURL tests/testSBuf tests/testSBufList tests/testConfigParser tests/testStatHist tests/testLookupTable tests/testRock tests/testUfs testRefCount
make[5]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
cp ../../test-suite/test_tools.cc .
depbase=`echo SBufList.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT SBufList.o -MD -MP -MF $depbase.Tpo -c -o SBufList.o ../../src/SBufList.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testConfigParser.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testConfigParser.o -MD -MP -MF $depbase.Tpo -c -o tests/testConfigParser.o ../../src/tests/testConfigParser.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testStatHist.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testStatHist.o -MD -MP -MF $depbase.Tpo -c -o tests/testStatHist.o ../../src/tests/testStatHist.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testLookupTable.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testLookupTable.o -MD -MP -MF $depbase.Tpo -c -o tests/testLookupTable.o ../../src/tests/testLookupTable.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testRock.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testRock.o -MD -MP -MF $depbase.Tpo -c -o tests/testRock.o ../../src/tests/testRock.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testUfs.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testUfs.o -MD -MP -MF $depbase.Tpo -c -o tests/testUfs.o ../../src/tests/testUfs.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testRefCount.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src   -I/usr/include/libxml2  -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testRefCount.o -MD -MP -MF $depbase.Tpo -c -o tests/testRefCount.o ../../src/tests/testRefCount.cc &&\
mv -f $depbase.Tpo $depbase.Po
../../src/tests/testRefCount.cc:11:19: fatal error: squid.h: No such file or directory
 #include "squid.h"
                   ^
compilation terminated.
Makefile:6824: recipe for target 'tests/testRefCount.o' failed
make[5]: *** [tests/testRefCount.o] Error 1
make[5]: *** Waiting for unfinished jobs....
Assembler messages:
Fatal error: can't create tests/testStatHist.o: No such file or directory
../../src/tests/testStatHist.cc:9:19: fatal error: squid.h: No such file or directory
 #include "squid.h"
                   ^
compilation terminated.
Makefile:6824: recipe for target 'tests/testStatHist.o' failed
make[5]: *** [tests/testStatHist.o] Error 2
g++: error: ../../src/tests/testUfs.cc: No such file or directory
g++: fatal error: no input files
compilation terminated.
Makefile:6824: recipe for target 'tests/testUfs.o' failed
make[5]: *** [tests/testUfs.o] Error 4
g++: error: ../../src/tests/testRock.cc: No such file or directory
g++: fatal error: no input files
compilation terminated.
Makefile:6824: recipe for target 'tests/testRock.o' failed
make[5]: *** [tests/testRock.o] Error 4
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
Makefile:7446: recipe for target 'check-am' failed
make[4]: *** [check-am] Error 2
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
Makefile:6946: recipe for target 'check-recursive' failed
make[3]: *** [check-recursive] Error 1
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
Makefile:7449: recipe for target 'check' failed
make[2]: *** [check] Error 2
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
Makefile:568: recipe for target 'check-recursive' failed
make[1]: *** [check-recursive] Error 1
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build'>
Makefile:776: recipe for target 'distcheck' failed
make: *** [distcheck] Error 1
buildtest.sh result is 2
grep: btlayer-02-maximus.log: No such file or directory
grep: btlayer-02-maximus.log: No such file or directory
grep: btlayer-02-maximus.log: No such file or directory
Build FAILED.
Build step 'Execute shell' marked build as failure
[description-setter] Description set: 

From eliezer at ngtech.co.il  Thu Oct 15 07:53:21 2015
From: eliezer at ngtech.co.il (Eliezer Croitoru)
Date: Thu, 15 Oct 2015 10:53:21 +0300
Subject: [squid-dev] 1xx terminates Squid-to-server connection
In-Reply-To: <561F1557.7000800@treenet.co.nz>
References: <561EC3C4.7020007@measurement-factory.com>
 <561F1557.7000800@treenet.co.nz>
Message-ID: <561F5B71.9050704@ngtech.co.il>

Is this something that should be applied to 3.5.X?

Eliezer

On 15/10/2015 05:54, Amos Jeffries wrote:
> Confirmed, and applied to trunk as rev.14357
>
> Thank you.
> Amos


From squid3 at treenet.co.nz  Thu Oct 15 08:41:57 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Thu, 15 Oct 2015 21:41:57 +1300
Subject: [squid-dev] 1xx terminates Squid-to-server connection
In-Reply-To: <561F5B71.9050704@ngtech.co.il>
References: <561EC3C4.7020007@measurement-factory.com>
 <561F1557.7000800@treenet.co.nz> <561F5B71.9050704@ngtech.co.il>
Message-ID: <561F66D5.7080303@treenet.co.nz>

On 15/10/2015 8:53 p.m., Eliezer Croitoru wrote:
> Is this something that should be applied to 3.5.X?

No, the affected parser changes are only in 4.x.

Amos


From noc at squid-cache.org  Fri Oct 16 13:36:14 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 16 Oct 2015 13:36:14 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Jenkins_build_is_back_to_normal_=3A_trunk-m?=
 =?utf-8?q?atrix_=C2=BB_gcc=2Cd-fedora-21_=23393?=
In-Reply-To: <1501952366.494.1444888779150.JavaMail.jenkins@buildmaster>
References: <1501952366.494.1444888779150.JavaMail.jenkins@buildmaster>
Message-ID: <740761981.495.1445002574630.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-fedora-21/393/>


From noc at squid-cache.org  Fri Oct 16 15:18:03 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 16 Oct 2015 15:18:03 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #895
In-Reply-To: <162695.493.1444816982907.JavaMail.jenkins@buildmaster>
References: <162695.493.1444816982907.JavaMail.jenkins@buildmaster>
Message-ID: <2045115560.496.1445008683680.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/895/>


From noc at squid-cache.org  Fri Oct 16 18:06:44 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 16 Oct 2015 18:06:44 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #896
Message-ID: <1595372319.497.1445018804542.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/896/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 394
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14359 squid3 at treenet.co.nz-20151016142852-b6tm82rmd2xcyszp
" stderr: ""
RevisionState revno:14359 revid:squid3 at treenet.co.nz-20151016142852-b6tm82rmd2xcyszp
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson1357796960398396727.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 896 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From eliezer at ngtech.co.il  Tue Oct 20 16:00:25 2015
From: eliezer at ngtech.co.il (Eliezer Croitoru)
Date: Tue, 20 Oct 2015 19:00:25 +0300
Subject: [squid-dev] [squid-users] POST upload splits tcp stream in many
 small 39byte sized pakets
In-Reply-To: <20151020154947.Horde.MkuPY1Mxju5p8MXnZRANOvZ@aws-it.at>
References: <20151020154947.Horde.MkuPY1Mxju5p8MXnZRANOvZ@aws-it.at>
Message-ID: <56266519.7010604@ngtech.co.il>

Hey Toni,

I have not reviewed your tcpdump captures but I have briefly reviewed 
your squid.conf.
The number of packets per second would not be accounted as a DOS unless 
the admin of the service don't really know what it means.
The TCP stack allows a connection to send small packets if there is a 
need and it is a part of the TCP open and available options for the 
public use.

I recommend you to open a bug in the bugzilla using this link:
http://bugs.squid-cache.org/enter_bug.cgi?product=Squid

And choose the "other" component and 3.5 as the version and as confirmed.

I have also tested this issue now after reading your issue and it seems 
to be quite real.
The test I was running was on latest 3.5.10:
[root at proxy]$ http_proxy="http://192.168.10.150:3128/" curl -X POST -H 
"Content-Type: multipart/form-data" -F "data=@/tmp/storeid_db" 
http://ngtech.co.il/favicon.ico >/dev/null

And the tcp dump result was fascinating:
[root at www1]$ tcpdump -n port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
18:57:46.748661 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [S], 
seq 1931160420, win 14600, options [mss 1460,sackOK,TS val 2567736261 
ecr 0,nop,wscale 7], length 0
18:57:46.748801 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [S.], 
seq 2253848035, ack 1931160421, win 28960, options [mss 1460,sackOK,TS 
val 578191590 ecr 2567736261,nop,wscale 7], length 0
18:57:46.754405 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 1, win 115, options [nop,nop,TS val 2567736266 ecr 578191590], length 0
18:57:46.755667 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 1:270, ack 1, win 115, options [nop,nop,TS val 2567736268 ecr 
578191590], length 269
18:57:46.755790 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
ack 270, win 235, options [nop,nop,TS val 578191592 ecr 2567736268], 
length 0
18:57:46.765041 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [P.], 
seq 1:26, ack 270, win 235, options [nop,nop,TS val 578191594 ecr 
2567736268], length 25
18:57:46.766184 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 26, win 115, options [nop,nop,TS val 2567736278 ecr 578191594], length 0
18:57:46.767043 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 270:309, ack 26, win 115, options [nop,nop,TS val 2567736279 ecr 
578191594], length 39
18:57:46.767706 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 309:348, ack 26, win 115, options [nop,nop,TS val 2567736279 ecr 
578191594], length 39
18:57:46.767744 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 348:387, ack 26, win 115, options [nop,nop,TS val 2567736279 ecr 
578191594], length 39
18:57:46.767760 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 387:424, ack 26, win 115, options [nop,nop,TS val 2567736279 ecr 
578191594], length 37
18:57:46.767827 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
ack 424, win 235, options [nop,nop,TS val 578191595 ecr 2567736279], 
length 0
18:57:46.807708 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 424:463, ack 26, win 115, options [nop,nop,TS val 2567736319 ecr 
578191595], length 39
18:57:46.807762 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 463:502, ack 26, win 115, options [nop,nop,TS val 2567736319 ecr 
578191595], length 39
18:57:46.807779 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 502:541, ack 26, win 115, options [nop,nop,TS val 2567736319 ecr 
578191595], length 39
18:57:46.807791 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 541:580, ack 26, win 115, options [nop,nop,TS val 2567736319 ecr 
578191595], length 39
18:57:46.807809 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 580:619, ack 26, win 115, options [nop,nop,TS val 2567736319 ecr 
578191595], length 39
18:57:46.807823 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 619:658, ack 26, win 115, options [nop,nop,TS val 2567736320 ecr 
578191595], length 39
18:57:46.807870 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [P.], 
seq 658:672, ack 26, win 115, options [nop,nop,TS val 2567736320 ecr 
578191595], length 14
18:57:46.807976 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
ack 672, win 235, options [nop,nop,TS val 578191605 ecr 2567736319], 
length 0
18:57:46.808180 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
seq 26:2922, ack 672, win 235, options [nop,nop,TS val 578191605 ecr 
2567736319], length 2896
18:57:46.808221 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
seq 2922:5818, ack 672, win 235, options [nop,nop,TS val 578191605 ecr 
2567736319], length 2896
18:57:46.808241 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [P.], 
seq 5818:8714, ack 672, win 235, options [nop,nop,TS val 578191605 ecr 
2567736319], length 2896
18:57:46.808260 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
seq 8714:11610, ack 672, win 235, options [nop,nop,TS val 578191605 ecr 
2567736319], length 2896
18:57:46.808280 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [.], 
seq 11610:14506, ack 672, win 235, options [nop,nop,TS val 578191605 ecr 
2567736319], length 2896
18:57:46.809154 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 2922, win 160, options [nop,nop,TS val 2567736321 ecr 578191605], 
length 0
18:57:46.809226 IP 192.168.10.1.80 > 192.168.10.254.40918: Flags [P.], 
seq 14506:17258, ack 672, win 235, options [nop,nop,TS val 578191605 ecr 
2567736321], length 2752
18:57:46.809257 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 5818, win 205, options [nop,nop,TS val 2567736321 ecr 578191605], 
length 0
18:57:46.809278 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 8714, win 250, options [nop,nop,TS val 2567736321 ecr 578191605], 
length 0
18:57:46.809294 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 11610, win 269, options [nop,nop,TS val 2567736321 ecr 578191605], 
length 0
18:57:46.809311 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 14506, win 296, options [nop,nop,TS val 2567736321 ecr 578191605], 
length 0
18:57:46.809913 IP 192.168.10.254.40918 > 192.168.10.1.80: Flags [.], 
ack 17258, win 323, options [nop,nop,TS val 2567736322 ecr 578191605], 
length 0
^C
32 packets captured
32 packets received by filter
0 packets dropped by kernel

Eliezer

On 20/10/2015 16:49, Squid admin wrote:
> Dear squid team,
>
> first of all thanks for developing such a great product!
>
> Unfortunately on uploading a big test file (unencrypted POST) to apache
> webserver using a squid proxy (V 3.5.10 or 4.0.1) the upstream pakets
> get slized into thousands of small 39 byte sized pakets.
>
> Excerpt from cache.log:
>
> 2015/10/20 13:51:08.201 kid1| 5,5| Write.cc(35) Write:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: sz 583:
> asynCall 0x244b670*1
> 2015/10/20 13:51:08.201 kid1| 5,5| Write.cc(66) HandleWrite:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: off 0, sz 583.
> 2015/10/20 13:51:08.203 kid1| 5,5| Write.cc(35) Write:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: sz 16422:
> asynCall 0x2447d40*1
> 2015/10/20 13:51:08.203 kid1| 5,5| Write.cc(66) HandleWrite:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: off 0, sz 16422.
> 2015/10/20 13:51:08.204 kid1| 5,5| Write.cc(35) Write:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: sz 39:
> asynCall 0x2448ec0*1
> 2015/10/20 13:51:08.205 kid1| 5,5| Write.cc(66) HandleWrite:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: off 0, sz 39.
> 2015/10/20 13:51:08.206 kid1| 5,5| Write.cc(35) Write:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: sz 39:
> asynCall 0x2464bb0*1
> 2015/10/20 13:51:08.207 kid1| 5,5| Write.cc(66) HandleWrite:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: off 0, sz 39.
> 2015/10/20 13:51:08.208 kid1| 5,5| Write.cc(35) Write:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: sz 39:
> asynCall 0x2448ec0*1
> 2015/10/20 13:51:08.209 kid1| 5,5| Write.cc(66) HandleWrite:
> local=10.1.1.210:46731 remote=10.1.1.19:81 FD 17 flags=1: off 0, sz 39.
> ...
>
> Attached you can find a tar file containing squid configuration,
> test network topology, network trace from traffic from client to squid,
> network trace from squid to webserver and a full debug log from squid
>
> One incoming paket of size ~ 1500 bytes gets sliced into more as 40 pakets.
> On the target webserver the squid upstream traffic therefore looks like
> a DOS attack.
>
> The problem can be reproduced using squid 3.5.x and squid 4.0.x (32bit
> and 64bit variants)
> The where no such problems using squid 3.2.x
>
> Hopefully you can help me to fix this problem as this is a showstopper
> for me to upgrade to squid 3.5.x and higher.
>
> Best regards,
>
> Toni


From rousskov at measurement-factory.com  Wed Oct 21 03:42:42 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Tue, 20 Oct 2015 21:42:42 -0600
Subject: [squid-dev] [PATCH] %<lp missing for persistent connections
Message-ID: <562709B2.70304@measurement-factory.com>

Hello,

    Connection stats, including %<lp, were missing for persistent
connections.

The code reusing a pconn was missing a hier.note() call, resulting in 0
values logged for %<lp (local port number of the last server or peer
connection) and probably other missing stats.

Also refactored poorly copied statistics collection code to remove
duplication and always update to-server connection stats when the actual
connection becomes available.

Positive side effect: Upon setsockopt(2) failures, the tos and nfmark
fields of a pinned connection were set to the desired (but not actually
applied) values, while persistent connection fields were left intact
(and, hence, stale). Both fields are now reset to zero on failures, for
both types of connections.


HTH,

Alex.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: SQUID-106-intermittent-0-outgoing-port-t3.patch
Type: text/x-diff
Size: 14732 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151020/9d8d4016/attachment.patch>

From squid3 at treenet.co.nz  Wed Oct 21 09:14:10 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Wed, 21 Oct 2015 22:14:10 +1300
Subject: [squid-dev] [PATCH] %<lp missing for persistent connections
In-Reply-To: <562709B2.70304@measurement-factory.com>
References: <562709B2.70304@measurement-factory.com>
Message-ID: <56275762.2000606@treenet.co.nz>

On 21/10/2015 4:42 p.m., Alex Rousskov wrote:
> Hello,
> 
>     Connection stats, including %<lp, were missing for persistent
> connections.
> 
> The code reusing a pconn was missing a hier.note() call, resulting in 0
> values logged for %<lp (local port number of the last server or peer
> connection) and probably other missing stats.
> 
> Also refactored poorly copied statistics collection code to remove
> duplication and always update to-server connection stats when the actual
> connection becomes available.
> 
> Positive side effect: Upon setsockopt(2) failures, the tos and nfmark
> fields of a pinned connection were set to the desired (but not actually
> applied) values, while persistent connection fields were left intact
> (and, hence, stale). Both fields are now reset to zero on failures, for
> both types of connections.
> 

+1.

Amos


From squid3 at treenet.co.nz  Wed Oct 21 11:47:57 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Thu, 22 Oct 2015 00:47:57 +1300
Subject: [squid-dev] [PATCH] squid-3.5: use ACL rep_mime_type in
 delay_access
In-Reply-To: <5615669A.5060000@gmail.com>
References: <5615669A.5060000@gmail.com>
Message-ID: <56277B6D.6020703@treenet.co.nz>

On 8/10/2015 7:38 a.m., Vitaly Lavrov wrote:
> This worked in squid-2X, but does not work in versions 3.X.
> I offer a patch that allows you to use ACL-type "rep_mime_type" in
> delay_access.
> Patch for squid-3.5.9.
> This patch working from 3.4.2+ more than one years.
> 

Looks okay with quick check and has passed the 10 day wait period for merge.
Applied to trunk as rev.14360

Amos


From noc at squid-cache.org  Wed Oct 21 16:02:14 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Wed, 21 Oct 2015 16:02:14 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #897
In-Reply-To: <1595372319.497.1445018804542.JavaMail.jenkins@buildmaster>
References: <1595372319.497.1445018804542.JavaMail.jenkins@buildmaster>
Message-ID: <1632837188.498.1445443334325.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/897/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 395
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14361 squid3 at treenet.co.nz-20151021115913-n4irnnhsz1l4mrdo
" stderr: ""
[trunk-polygraph] $ bzr update
 M  src/DelayId.cc
 M  src/DelayId.h
 M  src/client_side_reply.cc
 M  src/http/one/TeChunkedParser.cc
All changes applied successfully.
Updated to revision 14361 of branch http://bzr.squid-cache.org/bzr/squid3/trunk
[trunk-polygraph] $ bzr switch http://bzr.squid-cache.org/bzr/squid3/trunk/
Tree is up to date at revision 14361.
Switched to branch: http://bzr.squid-cache.org/bzr/squid3/trunk/
[trunk-polygraph] $ bzr revert
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14361 squid3 at treenet.co.nz-20151021115913-n4irnnhsz1l4mrdo
" stderr: ""
[trunk-polygraph] $ bzr log -v -r revid:squid3 at treenet.co.nz-20151021115913-n4irnnhsz1l4mrdo..revid:squid3 at treenet.co.nz-20151021115913-n4irnnhsz1l4mrdo --long --show-ids
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14361 squid3 at treenet.co.nz-20151021115913-n4irnnhsz1l4mrdo
" stderr: ""
RevisionState revno:14361 revid:squid3 at treenet.co.nz-20151021115913-n4irnnhsz1l4mrdo
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson4648545591412003955.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 897 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From rousskov at measurement-factory.com  Wed Oct 21 22:25:24 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Wed, 21 Oct 2015 16:25:24 -0600
Subject: [squid-dev] [PATCH] Parser-NG conversion of ICAP pt2
In-Reply-To: <55DA2FC2.7020808@treenet.co.nz>
References: <55DA2FC2.7020808@treenet.co.nz>
Message-ID: <562810D4.4060703@measurement-factory.com>

On 08/23/2015 02:40 PM, Amos Jeffries wrote:
> It turns out that ICAP implements has three distinct protocol parsers.
> 
> I begin the ICAP parser conversion to the Parser-NG model with
> ModXact::parseHeaders() - which was conflating both ICAP and HTTP, and
> the HTTP directional parsers.
> 
> 
> * splits the exiting parse method into 3 distinct stages; ICAP-reply,
> HTTP-request, HTTP-reply. Each stage is sequential and controlled by the
> Encapsulated header contents.
> 
> I'm not sure yet if we need to be tolerant of out-of-order segments in
> the payload. The spec is pretty clear that order is explicit and
> specific. 

AFAIK, we do not need to be tolerant to out-of-order segments -- there
are no known cases of those. We might want to be tolerant to unexpected
segments (bug 2480).


> But the old parser actually ignored the Encapsulated header
> byte offsets (!!).


The new parsers should continue to ignore them IMO. Those offsets are an
ICAP mis-feature -- a duplication of information that, as most
duplicates, leads to bugs. Ignoring them makes Squid ICAP code more
robust and probably decreases compatibility problems without [known] bad
side effects. We should parse the headers declared by Encapsulated.
Ignore numerical offset values.


> +     * ICAP header parse does not share the HTTP segment code, and
> +     * Encapsulated: tells us how many bytes and where each payload segment is.
> +     * We can pull N bytes into a child SBuf for parsing.
> +     *
> +     * 1) if there are not enough bytes we need more before even attempting the parse
> +     *
> +     * 2) after parse we can verify that it consumed all of the child buf.
> +     *    if there are leftovers ... smuggling attack from the ICAP server?
> +     */

This part of the TODO comment should be removed IMO. See my comments
above for the rationale.


> +    /* TODO: we do not need to rely on readBuf anymore for the parser logic.

The comment seems to be misplaced which makes it unclear. The
surrounding code does not rely on readBuf parser logic, whatever that
is. Please reword it in a context-specific way or move it to a more
appropriate place.


> +    /* Attempt to parse the ICAP message */

s/parse the ICAP message/isolate the ICAP response header/

(if that is what you are doing here; note that there is a "parse
headers" comment further below so you are not parsing headers here)


> +        bool parsedOk = hp->parse(readBuf);

If you can make it constant, make it const.


> +        // sync the buffers after parsing.
> +        readBuf = hp->remaining();

Too early? The "unrecoverable parsing error" code below should show what
we failed to parse, not what remained after we failed to parse.


> +    /* We know the whole response is in parser now */

s/response/response header/


> +    // XXX: performance regression. SBuf::c_str() reallocates
> +    SBuf tmpPhrase(hp->reasonPhrase());
> +    icapReply->sline.set(hp->messageProtocol(), hp->messageStatus(), tmpPhrase.c_str());

Do we need to introduce a regression here? How about using a few
hard-coded reasons for supported codes and a catch-all for all others?


Many of the above comments apply to the other parsing methods you have
created: parseHttpRequestHead and parseHttpRequestHead. Please check
those as well.


> +        // const_cast is okay, the buffer area behind the c_str will not be used again by this xaction
> +        // and that will only change when urlParse() starts taking the requestUri() SBuf directly

This violates, and I quote, "DO NOT EVER USE THE RETURNED POINTER FOR
WRITING" c_str() API. Explaining why that API violation may be safe
today is better than nothing, but still deserves a big fat XXX.

Even if the above assumption is accurate today, a code change in a
seemingly unrelated place may make it false, leading to hard-to-find
bugs. All it takes is for some code to copy the underlying SBuf
somewhere... If you want to improve this, please contact Christos: IIRC,
we have seen a similar problem elsewhere in the code and ended up adding
a new SBuf method to combat it. Christos should have the details.



> +    state.parsing = State::psHttpRequestHeader; // 'reqhdr' segment maybe first

To clarify, I would replace that comment with something like

// some buggy ICAP servers send HTTP request headers even when
// we expect only HTTP response headers (e.g., during RESPMOD)
state.parsing = State::psHttpRequestHeader


Alternatively, you can set state.parsing based on the Encapsulated
header. This will be more complex but a bit faster because you will
avoid calling parseHttpRequestHead() for 99.99999999% of RESPMOD
responses. That method has a non-trivial initial overhead.


> +        // parse headers
> +        adapted.header->pstate = psReadyToParseHeaders;
> +        Must(adapted.header->httpMsgParseStep(httpReqParser->mimeHeader().rawContent(), httpReqParser->mimeHeader().length(), true) >= 0);
> +
> +        setOutcome(xoModified);

If I am reading the patched code correctly, this is wrong for HTTP
request headers in a RESPMOD response. Those headers must be ignored,
not used as adapted message headers.


> +        // XXX: replyHttpHeaderSize used to account how many ICAP body bytes are processed
> +        // but ICAP can present two header segments and only the second gets counted.
> +        // Worse; the second in that case is HTTP reply message and smaller of the two.

Similarly, there appears to be some confusion regarding the number of
HTTP headers in the ICAP response. A valid response has either zero or
one HTTP header. If we decide to accept buggy ICAP responses that
include both HTTP request and HTTP response headers, then we must
*discard* the HTTP request header.

Two HTTP headers in an ICAP response is not an XXX (our bug), but an
ICAP server bug. If we decide to be tolerant, we need to process it
correctly, but if it is too complex to do that correctly, we should not
be tolerant in this case -- AFAICT, there are no popular (or even
non-obscure) ICAP servers that send two HTTP message headers in ICAP
responses.

Referring to bug 2480 in some of the source code comments might be
helpful: http://bugs.squid-cache.org/show_bug.cgi?id=2480



> +    Icap::ResponseParserPointer hp;  ///< parser for current ICAP protocol message (if any)

AFAICT, this is an attempt at incremental parsing for ICAP response
headers. I recommend avoiding that optimization because ICAP response
headers are small and we have spent enough time fixing incremental
parsing bugs already. Make that hp parser local to parseIcapHead().



> * adds "ICAP" / "icap" to the registered protocol types and scheme
> names, and associated Icap::ProtocolVersion() infrastructure.
> 
> * adds Adaptation::Icap::ResponseParser class extending
> Http1::ResponseParser with ICAP related details and first-line parser.

I do not think we should do that. The HTTP and ICAP syntax are
essentially the same. There is no good reason to duplicate this code. If
you need to parametrize "HTTP" vs. "ICAP" tokens, either add a data
member or, better, allow for both in the *parser* and let the caller
check the parsed protocol. IIRC, we already allow ICY for HTTP and this
approach may help remove that exception from the parser.


> +    // NOTE: RFC 3507 does not define extended whitespace characters to be tolerated
> +    //       like RFC 7230. Being strict leads to fewer problems in the long term.


RFC 3507 lets HTTP/1 define general status line and header syntax. Thus,
it essentially allows everything that HTTP/1 allows.

The lack of an explicit reference to some HTTP syntax concept in RFC
3507 should not be misinterpreted as an implication that HTTP-allowed
things are prohibited in ICAP. We have wasted weeks on this during HTTP
parser "upgrade" which is still unfinished. Let's not repeat that here,
please. Reuse the HTTP parsing code for ICAP as much as you can.


> There is some weird race behaviour I still want to verify if trunk has
> too. But have gone with PATCH instead of PREVIEW since this seems like a
> good place to pause. Leaving most polish and some major bug fixes to
> followups. That includes the other two parsers in adaptation/icap/.


Similarly, my initial review focuses on just a few big issues. More
review rounds will be necessary.

Please note that you are not simply replacing old hand-written parsing
code with code that uses currently available parsers. You are also
changing the overall ICAP logic surrounding that code. I doubt that was
a good idea, but it is probably too late to go back to a simpler
replacement plan.


Thank you,

Alex.


From aymericvincent at free.fr  Thu Oct 22 13:30:47 2015
From: aymericvincent at free.fr (aymericvincent at free.fr)
Date: Thu, 22 Oct 2015 15:30:47 +0200 (CEST)
Subject: [squid-dev] [PATCH] add support for using an existing kerberos
 cache instead of a keytab
In-Reply-To: <796532091.238275386.1445520040753.JavaMail.root@zimbra35-e6.priv.proxad.net>
Message-ID: <86042149.238300963.1445520647278.JavaMail.root@zimbra35-e6.priv.proxad.net>


    Hi,

the attached patch adds a NOKEYTAB option to the login=NEGOTIATE case (a local proxy needs to authenticate via kerberos to a proxy peer).

When specified, this option prevents squid from crafting a kerberos credentials cache from a keytab, but instead lets GSSAPI use an existing credentials cache.

This is very useful to allow a normal user to use his user credentials to run a local unprivileged squid on his desktop/laptop without having to deploy a keytab on the (say) parent proxy.

The way the option is specified is IMHO sub-optimal (sorry) but minimises diff footprint, and I'm open to any suggestion if you're interested in incorporating this simple yet useful change.

Best regards,
 Aymeric
-------------- next part --------------
A non-text attachment was scrubbed...
Name: diff-squid-negotiate-nokeytab
Type: text/x-patch
Size: 4642 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151022/e10f2a9d/attachment.bin>

From aymericvincent at free.fr  Thu Oct 22 13:55:02 2015
From: aymericvincent at free.fr (aymericvincent at free.fr)
Date: Thu, 22 Oct 2015 15:55:02 +0200 (CEST)
Subject: [squid-dev] Possible mistake in src/peer_digest.cc
In-Reply-To: <466021175.238308062.1445520847962.JavaMail.root@zimbra35-e6.priv.proxad.net>
Message-ID: <2036229703.238358630.1445522102960.JavaMail.root@zimbra35-e6.priv.proxad.net>


Hi again,

while grepping around to understand the potential implications of my previous patch, I stumbled upon a piece of code in src/peer_digest.cc which seems incorrect to me.

login=NEGOTIATE can have an additional parameter specified, like login=NEGOTIATE:xxx

One test does not take this case into account and it will probably send a garbage "login:password" (== "NEGOTIATE:xxx") to its peer when requesting a digest. The following patch fixes this but it is untested and requires a review from someone who understands the precise consequences of that piece of code.

Best regards,
 Aymeric
-------------- next part --------------
A non-text attachment was scrubbed...
Name: diff-squid-peer_digest-NEGOTIATE-fix
Type: text/x-patch
Size: 576 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151022/5a5e1ff1/attachment.bin>

From squid3 at treenet.co.nz  Thu Oct 22 14:15:54 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 23 Oct 2015 03:15:54 +1300
Subject: [squid-dev] [PATCH] add support for using an existing kerberos
 cache instead of a keytab
In-Reply-To: <86042149.238300963.1445520647278.JavaMail.root@zimbra35-e6.priv.proxad.net>
References: <86042149.238300963.1445520647278.JavaMail.root@zimbra35-e6.priv.proxad.net>
Message-ID: <5628EF9A.6020404@treenet.co.nz>

On 23/10/2015 2:30 a.m., aymericvincent wrote:
> 

> Hi,
> 
> the attached patch adds a NOKEYTAB option to the login=NEGOTIATE case
> (a local proxy needs to authenticate via kerberos to a proxy peer).
> 
> When specified, this option prevents squid from crafting a kerberos
> credentials cache from a keytab, but instead lets GSSAPI use an
> existing credentials cache.
> 
> This is very useful to allow a normal user to use his user
> credentials to run a local unprivileged squid on his desktop/laptop
> without having to deploy a keytab on the (say) parent proxy.
> 
> The way the option is specified is IMHO sub-optimal (sorry) but
> minimises diff footprint, and I'm open to any suggestion if you're
> interested in incorporating this simple yet useful change.
> 

There are two existing Negotiate auth cases.

* One where a "login=NEGOTIATE:principle_name" is given and causes Squid
to load the named entry from the users keytab.

* One where only "login=NEGOTIATE" is given, and causes Squid to load
the default (first) entry from the users default keytab.

In both cases the keytab entry can specify a memory cache contains the
credentials, or a specific named account. But that is stored in the
keytab itself. Not in squid.conf settings.

This patch appears to make Squid ignore loading keytabs entirely and
just allow random credentials from unspecified location(s) to be used.

In the absence of a location from which to load the credentials where
does GSSAPI load the credentials from?

Is the users generic cache backed by a keytab somewhere in the local
account? and why can't we just load that?

Is that GSSAPI behaviour consistent across the four krb5 libraries Squid
can be built to use?


Overall this seems to me to be making Squid pick a random user account
from the machine and sending a lot of traffic through some peer
pretending to be that user instead of a proxy. That is bad security, and
Kerberos is supposed to be the most secure authentication possible. So I
am not happy with this (yet).

Whatever we end up with Squid should never be impersonating a user
account. Ever. It is an automated service, not a person.



NP: don't worry about small diff. We are in feature freeze for Squid-4
beta cycle. Since this is a small UI change it will be held anyway until
Squid-5 branching, which is likely to be a month or two away.

IMO if accepted this should be a separate flag option available on
cache_peer. It would then be a boolean value in the CachePeer object
instead of a global macro #define.

Amos

From aymericvincent at free.fr  Thu Oct 22 14:59:20 2015
From: aymericvincent at free.fr (aymericvincent at free.fr)
Date: Thu, 22 Oct 2015 16:59:20 +0200 (CEST)
Subject: [squid-dev] [PATCH] add support for using an existing kerberos
 cache instead of a keytab
In-Reply-To: <5628EF9A.6020404@treenet.co.nz>
Message-ID: <627254322.238505303.1445525960185.JavaMail.root@zimbra35-e6.priv.proxad.net>


Hi,

"Amos Jeffries" <squid3 at treenet.co.nz> writes:

> This patch appears to make Squid ignore loading keytabs entirely and
> just allow random credentials from unspecified location(s) to be used.

That's correct and that's the whole point of the diff. ("unspecified location"... to squid)

> In the absence of a location from which to load the credentials where
> does GSSAPI load the credentials from?

When a user is logged in and authenticated to a kdc, a credentials cache is kept around (in practice in a file belonging to the user in /tmp on Unix) and used whenever kerberos authentication is required by a client. That's what you see when you type "klist" for example. Given that one of the interesting features of kerberos is single sign on, I would be surprised that the behaviour is not very similar on other OSes/implementations.

> Is the users generic cache backed by a keytab somewhere in the local
> account? and why can't we just load that?

I'm not familiar enough with kerberos to be authoritative, but I'm quite sure it's not the case : the ticket granting ticket is provided in exchange for the user's password, not thanks to a user-specific keytab AFAIK.

> Overall this seems to me to be making Squid pick a random user account
> from the machine and sending a lot of traffic through some peer
> pretending to be that user instead of a proxy. That is bad security, and
> Kerberos is supposed to be the most secure authentication possible. So I
> am not happy with this (yet).

I'm fine with your opinion, but you should replace "a random user account" by "the account which started squid".

> NP: don't worry about small diff. We are in feature freeze for Squid-4
> beta cycle. Since this is a small UI change it will be held anyway until
> Squid-5 branching, which is likely to be a month or two away.

OK, I'll keep that in mind. So we can devise a better way of specifying the option. Moreover, I also realised that keeping the ability to specify a principal name in the NOKEYTAB case is pointless (and will be ignored by the current code) so if others prefer to keep a similar syntax (I'm not fond of it either), it could be login=NEGOTIATE:NOKEYTAB directly and not login=NEGOTIATE::NOKEYTAB.

Best regards,
 Aymeric

From squid3 at treenet.co.nz  Thu Oct 22 15:08:46 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 23 Oct 2015 04:08:46 +1300
Subject: [squid-dev] Possible mistake in src/peer_digest.cc
In-Reply-To: <2036229703.238358630.1445522102960.JavaMail.root@zimbra35-e6.priv.proxad.net>
References: <2036229703.238358630.1445522102960.JavaMail.root@zimbra35-e6.priv.proxad.net>
Message-ID: <5628FBFE.5040704@treenet.co.nz>

On 23/10/2015 2:55 a.m., aymericvincent wrote:
> 
> Hi again,
> 
> while grepping around to understand the potential implications of my previous patch, I stumbled upon a piece of code in src/peer_digest.cc which seems incorrect to me.
> 
> login=NEGOTIATE can have an additional parameter specified, like login=NEGOTIATE:xxx
> 
> One test does not take this case into account and it will probably send a garbage "login:password" (== "NEGOTIATE:xxx") to its peer when requesting a digest. The following patch fixes this but it is untested and requires a review from someone who understands the precise consequences of that piece of code.
> 

The code is attempting to fill out the userinfo URL segment.
squid.conf like so:
  cache_peer example.com ... login=user:info

resulting in:
 GET http://user:info at example.com/squid-internal-digest/...


There are two problems here.

The main one is that the userinfo URL segment is now outright forbidden
in http:// scheme URL. So Squid should be sending actual Proxy-auth or
WWW-auth headers instead same as it does for any client requests.


The second one is what you mention. The "NEGOTIATE:principal" string
being broadcast over the network.

Please do check if that is actually happening when a principal is
configured. And then if your patch prevents it. I will accept if it
tests as actually needed and working.


Amos


From squid3 at treenet.co.nz  Thu Oct 22 15:22:21 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 23 Oct 2015 04:22:21 +1300
Subject: [squid-dev] [PATCH] add support for using an existing kerberos
 cache instead of a keytab
In-Reply-To: <627254322.238505303.1445525960185.JavaMail.root@zimbra35-e6.priv.proxad.net>
References: <627254322.238505303.1445525960185.JavaMail.root@zimbra35-e6.priv.proxad.net>
Message-ID: <5628FF2D.9020406@treenet.co.nz>

On 23/10/2015 3:59 a.m., aymericvincent wrote:
> 
> Hi,
> 
> "Amos Jeffries" writes:
> 
>> This patch appears to make Squid ignore loading keytabs entirely and
>> just allow random credentials from unspecified location(s) to be used.
> 
> That's correct and that's the whole point of the diff. ("unspecified location"... to squid)
> 
>> In the absence of a location from which to load the credentials where
>> does GSSAPI load the credentials from?
> 
> When a user is logged in and authenticated to a kdc, a credentials cache is kept around (in practice in a file belonging to the user in /tmp on Unix) and used whenever kerberos authentication is required by a client. That's what you see when you type "klist" for example. Given that one of the interesting features of kerberos is single sign on, I would be surprised that the behaviour is not very similar on other OSes/implementations.
> 
>> Is the users generic cache backed by a keytab somewhere in the local
>> account? and why can't we just load that?
> 
> I'm not familiar enough with kerberos to be authoritative, but I'm quite sure it's not the case : the ticket granting ticket is provided in exchange for the user's password, not thanks to a user-specific keytab AFAIK.
> 
>> Overall this seems to me to be making Squid pick a random user account
>> from the machine and sending a lot of traffic through some peer
>> pretending to be that user instead of a proxy. That is bad security, and
>> Kerberos is supposed to be the most secure authentication possible. So I
>> am not happy with this (yet).
> 
> I'm fine with your opinion, but you should replace "a random user account" by "the account which started squid".

I'm not sure even that is true. Because Squid dynamically alters its
user account for the workers. They may be running as some other
effective user with a different credentials cache.

Which reminds me that Squid usually cannot be started by a non-root user
anyway. There are root privileges required to do effective-user changes,
capabilities assignment, access kernel NAT tables and some other socket
operations we do.

> 
>> NP: don't worry about small diff. We are in feature freeze for Squid-4
>> beta cycle. Since this is a small UI change it will be held anyway until
>> Squid-5 branching, which is likely to be a month or two away.
> 
> OK, I'll keep that in mind. So we can devise a better way of specifying the option. Moreover, I also realised that keeping the ability to specify a principal name in the NOKEYTAB case is pointless (and will be ignored by the current code) so if others prefer to keep a similar syntax (I'm not fond of it either), it could be login=NEGOTIATE:NOKEYTAB directly and not login=NEGOTIATE::NOKEYTAB.
> 

 "login=NEGOTIATE auth-no-keytab" should do.

Like I mentioned that allows a simple boolean flag in the CachePeer.
Which avoids the macro define. And also adjusting the if conditions in
all the places auth type is detected by those nasty strcmp/strncmp tests.

Amos

From noc at squid-cache.org  Fri Oct 23 05:59:44 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 23 Oct 2015 05:59:44 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Build_failed_in_Jenkins=3A_trunk-matrix_?=
 =?utf-8?q?=C2=BB_gcc=2Cd-debian-unstable_=23396?=
Message-ID: <1467679723.499.1445579984696.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/396/>

------------------------------------------
[...truncated 45650 lines...]
rm -f ./so_locations
test -z "test-suite.log" || rm -f test-suite.log
test . = "../../../src/adaptation" || test -z "" || rm -f 
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
rm -rf ./.deps
rm -f Makefile
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/adaptation'>
Making distclean in esi
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
test -z "testHeaders" || rm -f testHeaders
rm -rf .libs _libs
test -z "libesi.la" || rm -f libesi.la
rm -f *.o
test -z "testHeaders.log" || rm -f testHeaders.log
rm -f *.lo
test -z "testHeaders.trs" || rm -f testHeaders.trs
rm -f ./so_locations
rm -f *.tab.c
test -z "" || rm -f 
rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
test -z "test-suite.log" || rm -f test-suite.log
test . = "../../../src/esi" || test -z "" || rm -f 
rm -rf ./.deps
rm -f Makefile
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src/esi'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
cd .. && make  am--refresh
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build'>
make[4]: *** No rule to make target 'am--refresh'.  Stop.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build'>
Makefile:6003: recipe for target '../config.status' failed
make[3]: *** [../config.status] Error 2
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
Makefile:6946: recipe for target 'distclean-recursive' failed
make[2]: *** [distclean-recursive] Error 1
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build/src'>
Makefile:568: recipe for target 'distclean-recursive' failed
make[1]: *** [distclean-recursive] Error 1
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_build'>
Makefile:776: recipe for target 'distcheck' failed
make: *** [distcheck] Error 1
buildtest.sh result is 2
BUILD: .././test-suite/buildtests/layer-02-maximus.opts
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -ldl -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: -Wall -g -O2
configure: BUILD EXTRA C FLAGS: -Wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow -Werror -pipe -D_REENTRANT
configure: BUILD C++ FLAGS:  -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS: -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT
configure: BUILD Tools C++ FLAGS:   -g -O2 -std=c++11
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -ldl -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS: -Wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow -Werror -pipe -D_REENTRANT
configure: BUILD C++ FLAGS:  -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS: -I/usr/include/libxml2 -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT
configure: BUILD Tools C++ FLAGS:   -g -O2 -std=c++11
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
# XFAIL: 0
# FAIL:  0
2015/10/23 05:58:57| FATAL ERROR: MIME Config Table <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/mime.conf>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: unlinkd_program <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/unlinkd>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: logfile_daemon <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/log_file_daemon>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: Icon Directory <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share/icons>: (2) No such file or directory
<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/var/logs/cache.log>: No such file or directory
2015/10/23 05:58:57| FATAL ERROR: MIME Config Table <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/mime.conf>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: unlinkd_program <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/unlinkd>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: logfile_daemon <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/log_file_daemon>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: Icon Directory <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share/icons>: (2) No such file or directory
<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/var/logs/cache.log>: No such file or directory
2015/10/23 05:58:57| FATAL ERROR: MIME Config Table <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/mime.conf>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: unlinkd_program <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/unlinkd>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: logfile_daemon <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/log_file_daemon>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: Icon Directory <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share/icons>: (2) No such file or directory
<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/var/logs/cache.log>: No such file or directory
2015/10/23 05:58:57| FATAL ERROR: MIME Config Table <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/mime.conf>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: unlinkd_program <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/unlinkd>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: logfile_daemon <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/log_file_daemon>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: Icon Directory <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share/icons>: (2) No such file or directory
<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/var/logs/cache.log>: No such file or directory
2015/10/23 05:58:57| FATAL ERROR: MIME Config Table <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/etc/mime.conf>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: unlinkd_program <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/unlinkd>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: logfile_daemon <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/libexec/log_file_daemon>: (2) No such file or directory
2015/10/23 05:58:57| FATAL ERROR: Icon Directory <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/share/icons>: (2) No such file or directory
<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/ws/btlayer-02-maximus/squid-4.0.1-BZR/_inst/var/logs/cache.log>: No such file or directory
# XFAIL: 0
# FAIL:  0
make[3]: *** [../config.status] Error 2
make[2]: *** [distclean-recursive] Error 1
make[1]: *** [distclean-recursive] Error 1
make: *** [distcheck] Error 1
Build FAILED.
Build step 'Execute shell' marked build as failure
[description-setter] Description set: 

From noc at squid-cache.org  Fri Oct 23 07:45:46 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 23 Oct 2015 07:45:46 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Jenkins_build_is_back_to_normal_=3A_trunk-m?=
 =?utf-8?q?atrix_=C2=BB_gcc=2Cd-debian-unstable_=23397?=
In-Reply-To: <1467679723.499.1445579984696.JavaMail.jenkins@buildmaster>
References: <1467679723.499.1445579984696.JavaMail.jenkins@buildmaster>
Message-ID: <608111440.500.1445586346218.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-debian-unstable/397/>


From noc at squid-cache.org  Fri Oct 23 09:28:50 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 23 Oct 2015 09:28:50 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #898
In-Reply-To: <1632837188.498.1445443334325.JavaMail.jenkins@buildmaster>
References: <1632837188.498.1445443334325.JavaMail.jenkins@buildmaster>
Message-ID: <319101441.501.1445592530016.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/898/>


From aymericvincent at free.fr  Sun Oct 25 16:59:10 2015
From: aymericvincent at free.fr (Aymeric Vincent)
Date: Sun, 25 Oct 2015 17:59:10 +0100
Subject: [squid-dev] Possible mistake in src/peer_digest.cc
In-Reply-To: <5628FBFE.5040704@treenet.co.nz> (Amos Jeffries's message of
 "Fri, 23 Oct 2015 04:08:46 +1300")
References: <2036229703.238358630.1445522102960.JavaMail.root@zimbra35-e6.priv.proxad.net>
 <5628FBFE.5040704@treenet.co.nz>
Message-ID: <87wpuanau9.fsf@free.fr>


Hi,

Amos Jeffries <squid3 at treenet.co.nz> writes:

> Please do check if that is actually happening when a principal is
> configured. And then if your patch prevents it. I will accept if it
> tests as actually needed and working.

So I added the following line to a squid.conf

cache_peer localhost parent 3129 0 default login=NEGOTIATE:abcd

and started squid without the patch. After faking a connection to the
squid and waiting for a timeout, the following shows up on port 3129.

$ nc -k6l 3129
...
GET /squid-internal-periodic/store_digest HTTP/1.1
Accept: application/cache-digest
Accept: text/html
Via: 1.1 x (squid/4.0.1-BZR)
X-Forwarded-For: ::
Host: localhost:3129
Authorization: Basic TkVHT1RJQVRFOmFiY2Q=
Cache-Control: max-age=259200
Connection: keep-alive


And, base64-decoding the basic auth token yields as expected:
$ base64 -d <<EOF
> TkVHT1RJQVRFOmFiY2Q=
> EOF
NEGOTIATE:abcd$ 

After applying the patch, recompiling and restarting squid, the same
sequence of actions gives:

$ nc -k6l 3129
...
GET /squid-internal-periodic/store_digest HTTP/1.1
Accept: application/cache-digest
Accept: text/html
Via: 1.1 x (squid/4.0.1-BZR)
X-Forwarded-For: ::
Host: localhost:3129
Cache-Control: max-age=259200
Connection: keep-alive


Notice the absence of Authorization: line.

Best regards,
 Aymeric

From noc at squid-cache.org  Mon Oct 26 00:08:26 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Mon, 26 Oct 2015 00:08:26 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #900
Message-ID: <398729193.534.1445818106266.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/900/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 399
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14365 squid3 at treenet.co.nz-20151025123516-uagfdwb1tgokp5os
" stderr: ""
RevisionState revno:14365 revid:squid3 at treenet.co.nz-20151025123516-uagfdwb1tgokp5os
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson9222916308224657217.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 900 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From squid3 at treenet.co.nz  Mon Oct 26 02:58:55 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Mon, 26 Oct 2015 15:58:55 +1300
Subject: [squid-dev] Possible mistake in src/peer_digest.cc
In-Reply-To: <87wpuanau9.fsf@free.fr>
References: <2036229703.238358630.1445522102960.JavaMail.root@zimbra35-e6.priv.proxad.net>
 <5628FBFE.5040704@treenet.co.nz> <87wpuanau9.fsf@free.fr>
Message-ID: <562D96EF.2040405@treenet.co.nz>

Thank you. Applied with one small weak to avoid strlen() to Squid-4 as
trunk rev.14366.

Amos

From noc at squid-cache.org  Mon Oct 26 11:13:58 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Mon, 26 Oct 2015 11:13:58 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #901
In-Reply-To: <398729193.534.1445818106266.JavaMail.jenkins@buildmaster>
References: <398729193.534.1445818106266.JavaMail.jenkins@buildmaster>
Message-ID: <720523486.538.1445858038119.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/901/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 400
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14366 squid3 at treenet.co.nz-20151026025330-zir5kn2r2sbvin1b
" stderr: ""
[trunk-polygraph] $ bzr update
 M  src/peer_digest.cc
All changes applied successfully.
Updated to revision 14366 of branch http://bzr.squid-cache.org/bzr/squid3/trunk
[trunk-polygraph] $ bzr switch http://bzr.squid-cache.org/bzr/squid3/trunk/
Tree is up to date at revision 14366.
Switched to branch: http://bzr.squid-cache.org/bzr/squid3/trunk/
[trunk-polygraph] $ bzr revert
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14366 squid3 at treenet.co.nz-20151026025330-zir5kn2r2sbvin1b
" stderr: ""
[trunk-polygraph] $ bzr log -v -r revid:squid3 at treenet.co.nz-20151026025330-zir5kn2r2sbvin1b..revid:squid3 at treenet.co.nz-20151026025330-zir5kn2r2sbvin1b --long --show-ids
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14366 squid3 at treenet.co.nz-20151026025330-zir5kn2r2sbvin1b
" stderr: ""
RevisionState revno:14366 revid:squid3 at treenet.co.nz-20151026025330-zir5kn2r2sbvin1b
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson7364323057433622698.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 901 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From rousskov at measurement-factory.com  Mon Oct 26 16:00:13 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Mon, 26 Oct 2015 10:00:13 -0600
Subject: [squid-dev] [PATCH] No reconfiguration during shutdown
Message-ID: <562E4E0D.3090704@measurement-factory.com>

Hello,

    To avoid crashes, prohibit pointless reconfiguration during shutdown.

Also consolidated and polished signal action handling code:

1. For any executed action X, clear do_X at the beginning of action X
   code because once we start X, we should accept/queue more X
   requests (or inform the admin if we reject them).

2. Delay any action X requested during startup or reconfiguration
   because the latter two actions modify global state that X depends
   on. Inform the admin that the requested action is being delayed.

3. Cancel any action X requested during shutdown. We cannot run X
   during shutdown because shutdown modifies global state that X
   depends on, and we never come back from shutdown so there is no
   point in delaying X. Inform the admin that the requested action is
   canceled.

Repeated failed attempts to fix crashes related to various overlapping
signal actions confirm that this code is a lot trickier than it looks.
This change introduces a more systematic/comprehensive approach to
resolving associated conflicts compared to previous ad hoc attempts.

For example, there were several changes related to bug 3574 (trunk
r14354), but trunk Squid still crashes if SIGHUP is received at the
"wrong" time. I hope this fix will kill the remaining similar bugs or at
least make future fixes easier.

    http://bugs.squid-cache.org/show_bug.cgi?id=3574


One possible future work is to split shutdown into two states:

* scheduled (waiting for timeout to expire; may not affect some of the
  signal actions) and
* in-progress (blocks out all other actions).

Currently, the two states are merged into one in trunk code (there is
only one shutting_down global). This fix does not attempt to address
that deficiency. Factory does not plan to work on this in the
foreseeable future. Please feel free to solve this problem!


Amos, I have also attached a "bag10s" patch that may work better for the
v3.5 branch should you decide to apply this fix to v3.5 as well.


Thank you,

Alex.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: SQUID-116-no-reconfig-during-shutdown-t8.patch
Type: text/x-diff
Size: 9175 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151026/0149c28d/attachment.patch>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: SQUID-116-no-reconfig-during-shutdown-bag10s-t8.patch
Type: text/x-diff
Size: 7438 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151026/0149c28d/attachment-0001.patch>

From squid3 at treenet.co.nz  Mon Oct 26 17:24:56 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Tue, 27 Oct 2015 06:24:56 +1300
Subject: [squid-dev] [PATCH] No reconfiguration during shutdown
In-Reply-To: <562E4E0D.3090704@measurement-factory.com>
References: <562E4E0D.3090704@measurement-factory.com>
Message-ID: <562E61E8.4050507@treenet.co.nz>

On 27/10/2015 5:00 a.m., Alex Rousskov wrote:
> Hello,
> 
>     To avoid crashes, prohibit pointless reconfiguration during shutdown.
> 
> Also consolidated and polished signal action handling code:
> 
> 1. For any executed action X, clear do_X at the beginning of action X
>    code because once we start X, we should accept/queue more X
>    requests (or inform the admin if we reject them).
> 
> 2. Delay any action X requested during startup or reconfiguration
>    because the latter two actions modify global state that X depends
>    on. Inform the admin that the requested action is being delayed.
> 
> 3. Cancel any action X requested during shutdown. We cannot run X
>    during shutdown because shutdown modifies global state that X
>    depends on, and we never come back from shutdown so there is no
>    point in delaying X. Inform the admin that the requested action is
>    canceled.
> 
> Repeated failed attempts to fix crashes related to various overlapping
> signal actions confirm that this code is a lot trickier than it looks.
> This change introduces a more systematic/comprehensive approach to
> resolving associated conflicts compared to previous ad hoc attempts.
> 
> For example, there were several changes related to bug 3574 (trunk
> r14354), but trunk Squid still crashes if SIGHUP is received at the
> "wrong" time. I hope this fix will kill the remaining similar bugs or at
> least make future fixes easier.
> 
>     http://bugs.squid-cache.org/show_bug.cgi?id=3574
> 

+1 on this patch.

Please apply with a "--fixes squid:3574" and bug reference in the commit
title.


> 
> One possible future work is to split shutdown into two states:
> 
> * scheduled (waiting for timeout to expire; may not affect some of the
>   signal actions) and
> * in-progress (blocks out all other actions).
> 
> Currently, the two states are merged into one in trunk code (there is
> only one shutting_down global). This fix does not attempt to address
> that deficiency. Factory does not plan to work on this in the
> foreseeable future. Please feel free to solve this problem!


I did (re-)discover that the final cycle through SignalsEngine whe
hutdown timeout ends does indeed drain the AsyncQueue. But not wait for
any other types of pending I/O or FD events that might appear during
that drain. That is paving the way for the current swap.state read/write
crashes on shutdown.

I plan to work towards Runners doing all the shutdown handling and in
particular hooking some components into that which are currently not
paying any attention to shutdown termination (ie the swap.state and DNS
sockets FD). Once that conversion is completed we shall see what remains
that needs any async handling after timout ends.

Amos

From rousskov at measurement-factory.com  Tue Oct 27 03:51:30 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Mon, 26 Oct 2015 21:51:30 -0600
Subject: [squid-dev] [PATCH] %<lp missing for persistent connections
In-Reply-To: <56275762.2000606@treenet.co.nz>
References: <562709B2.70304@measurement-factory.com>
 <56275762.2000606@treenet.co.nz>
Message-ID: <562EF4C2.50802@measurement-factory.com>

On 10/21/2015 03:14 AM, Amos Jeffries wrote:
> On 21/10/2015 4:42 p.m., Alex Rousskov wrote:
>> Hello,
>>
>>     Connection stats, including %<lp, were missing for persistent
>> connections.
>>
>> The code reusing a pconn was missing a hier.note() call, resulting in 0
>> values logged for %<lp (local port number of the last server or peer
>> connection) and probably other missing stats.
>>
>> Also refactored poorly copied statistics collection code to remove
>> duplication and always update to-server connection stats when the actual
>> connection becomes available.
>>
>> Positive side effect: Upon setsockopt(2) failures, the tos and nfmark
>> fields of a pinned connection were set to the desired (but not actually
>> applied) values, while persistent connection fields were left intact
>> (and, hence, stale). Both fields are now reset to zero on failures, for
>> both types of connections.
>>
> 
> +1.

Committed to trunk (r14367).


Thank you,

Alex.


From noc at squid-cache.org  Tue Oct 27 06:00:10 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Tue, 27 Oct 2015 06:00:10 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Build_failed_in_Jenkins=3A_trunk-matrix_?=
 =?utf-8?b?wrsgZ2NjLGQtb3BlbnN1c2UtMTMuMiAjNDAx?=
Message-ID: <370731809.539.1445925610138.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/401/>

------------------------------------------
[...truncated 9455 lines...]
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_ipc_TypedMsgHdr.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_ipc_TypedMsgHdr.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_ipc_TypedMsgHdr.o ../../src/tests/stub_ipc_TypedMsgHdr.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libauth.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libauth.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libauth.o ../../src/tests/stub_libauth.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libcomm.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libcomm.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libcomm.o ../../src/tests/stub_libcomm.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libdiskio.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libdiskio.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libdiskio.o ../../src/tests/stub_libdiskio.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libformat.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libformat.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libformat.o ../../src/tests/stub_libformat.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libmem.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libmem.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libmem.o ../../src/tests/stub_libmem.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libsslsquid.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libsslsquid.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libsslsquid.o ../../src/tests/stub_libsslsquid.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_MemObject.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_MemObject.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_MemObject.o ../../src/tests/stub_MemObject.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_MemStore.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_MemStore.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_MemStore.o ../../src/tests/stub_MemStore.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_mime.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_mime.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_mime.o ../../src/tests/stub_mime.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_pconn.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_pconn.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_pconn.o ../../src/tests/stub_pconn.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_Port.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_Port.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_Port.o ../../src/tests/stub_Port.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_store.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_store.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_store.o ../../src/tests/stub_store.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_store_client.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_store_client.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_store_client.o ../../src/tests/stub_store_client.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_store_rebuild.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_store_rebuild.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_store_rebuild.o ../../src/tests/stub_store_rebuild.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_store_stats.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_store_stats.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_store_stats.o ../../src/tests/stub_store_stats.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_store_swapout.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_store_swapout.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_store_swapout.o ../../src/tests/stub_store_swapout.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_tools.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_tools.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_tools.o ../../src/tests/stub_tools.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_cache_manager.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_cache_manager.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_cache_manager.o ../../src/tests/stub_cache_manager.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_UdsOp.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_UdsOp.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_UdsOp.o ../../src/tests/stub_UdsOp.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testACLMaxUserIP.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testACLMaxUserIP.o -MD -MP -MF $depbase.Tpo -c -o tests/testACLMaxUserIP.o ../../src/tests/testACLMaxUserIP.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_time.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_time.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_time.o ../../src/tests/stub_time.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo test_tools.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT test_tools.o -MD -MP -MF $depbase.Tpo -c -o test_tools.o test_tools.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testBoilerplate.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testBoilerplate.o -MD -MP -MF $depbase.Tpo -c -o tests/testBoilerplate.o ../../src/tests/testBoilerplate.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_cbdata.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_cbdata.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_cbdata.o ../../src/tests/stub_cbdata.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_MemBuf.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_MemBuf.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_MemBuf.o ../../src/tests/stub_MemBuf.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testCacheManager.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testCacheManager.o -MD -MP -MF $depbase.Tpo -c -o tests/testCacheManager.o ../../src/tests/testCacheManager.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_main_cc.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_main_cc.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_main_cc.o ../../src/tests/stub_main_cc.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_ipc_Forwarder.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_ipc_Forwarder.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_ipc_Forwarder.o ../../src/tests/stub_ipc_Forwarder.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_EventLoop.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_EventLoop.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_EventLoop.o ../../src/tests/stub_EventLoop.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_CacheDigest.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_CacheDigest.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_CacheDigest.o ../../src/tests/stub_CacheDigest.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_carp.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_carp.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_carp.o ../../src/tests/stub_carp.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_redirect.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_redirect.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_redirect.o ../../src/tests/stub_redirect.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libauth_acls.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libauth_acls.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libauth_acls.o ../../src/tests/stub_libauth_acls.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_store_digest.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_store_digest.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_store_digest.o ../../src/tests/stub_store_digest.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_tunnel.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_tunnel.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_tunnel.o ../../src/tests/stub_tunnel.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_wccp2.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_wccp2.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_wccp2.o ../../src/tests/stub_wccp2.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_whois.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_whois.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_whois.o ../../src/tests/stub_whois.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testCharacterSet.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testCharacterSet.o -MD -MP -MF $depbase.Tpo -c -o tests/testCharacterSet.o ../../src/tests/testCharacterSet.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_acl.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_acl.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_acl.o ../../src/tests/stub_acl.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_client_db.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_client_db.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_client_db.o ../../src/tests/stub_client_db.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_client_side_request.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_client_side_request.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_client_side_request.o ../../src/tests/stub_client_side_request.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_helper.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_helper.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_helper.o ../../src/tests/stub_helper.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_HelperChildConfig.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_HelperChildConfig.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_HelperChildConfig.o ../../src/tests/stub_HelperChildConfig.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_http.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_http.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_http.o ../../src/tests/stub_http.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_icp.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_icp.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_icp.o ../../src/tests/stub_icp.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_internal.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_internal.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_internal.o ../../src/tests/stub_internal.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_ipc.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_ipc.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_ipc.o ../../src/tests/stub_ipc.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_ipcache.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_ipcache.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_ipcache.o ../../src/tests/stub_ipcache.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libeui.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libeui.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libeui.o ../../src/tests/stub_libeui.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_libicmp.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_libicmp.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_libicmp.o ../../src/tests/stub_libicmp.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_neighbors.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_neighbors.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_neighbors.o ../../src/tests/stub_neighbors.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_stat.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_stat.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_stat.o ../../src/tests/stub_stat.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testDiskIO.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testDiskIO.o -MD -MP -MF $depbase.Tpo -c -o tests/testDiskIO.o ../../src/tests/testDiskIO.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testStoreSupport.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testStoreSupport.o -MD -MP -MF $depbase.Tpo -c -o tests/testStoreSupport.o ../../src/tests/testStoreSupport.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testRFC1035.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testRFC1035.o -MD -MP -MF $depbase.Tpo -c -o tests/testRFC1035.o ../../src/tests/testRFC1035.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_SBuf.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_SBuf.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_SBuf.o ../../src/tests/stub_SBuf.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testEnumIterator.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testEnumIterator.o -MD -MP -MF $depbase.Tpo -c -o tests/testEnumIterator.o ../../src/tests/testEnumIterator.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testEvent.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testEvent.o -MD -MP -MF $depbase.Tpo -c -o tests/testEvent.o ../../src/tests/testEvent.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testEventLoop.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testEventLoop.o -MD -MP -MF $depbase.Tpo -c -o tests/testEventLoop.o ../../src/tests/testEventLoop.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/test_http_range.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/test_http_range.o -MD -MP -MF $depbase.Tpo -c -o tests/test_http_range.o ../../src/tests/test_http_range.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_external_acl.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_external_acl.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_external_acl.o ../../src/tests/stub_external_acl.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/testTokenizer.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/testTokenizer.o -MD -MP -MF $depbase.Tpo -c -o tests/testTokenizer.o ../../src/tests/testTokenizer.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_comm.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_comm.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_comm.o ../../src/tests/stub_comm.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_event.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_event.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_event.o ../../src/tests/stub_event.cc &&\
mv -f $depbase.Tpo $depbase.Po
depbase=`echo tests/stub_stmem.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache g++ -DHAVE_CONFIG_H -DDEFAULT_CONFIG_FILE=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc/squid.conf\"> -DDEFAULT_SQUID_DATA_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/share\"> -DDEFAULT_SQUID_CONFIG_DIR=\"<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_inst/etc\">   -I../.. -I../../include -I../../lib -I../../src -I../include    -I../src    -Wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow -Werror -Wno-deprecated-register -pipe -D_REENTRANT -g -O2 -std=c++11 -MT tests/stub_stmem.o -MD -MP -MF $depbase.Tpo -c -o tests/stub_stmem.o ../../src/tests/stub_stmem.cc &&\
mv -f $depbase.Tpo $depbase.Po
../../src/tests/stub_stmem.cc:9:19: fatal error: squid.h: No such file or directory
 #include "squid.h"
                   ^
compilation terminated.
Makefile:6824: recipe for target 'tests/stub_stmem.o' failed
make[5]: *** [tests/stub_stmem.o] Error 1
make[5]: *** Waiting for unfinished jobs....
../../src/tests/stub_event.cc:9:19: fatal error: squid.h: No such file or directory
 #include "squid.h"
                   ^
compilation terminated.
Assembler messages:
Fatal error: can't create tests/stub_comm.o: No such file or directory
Assembler messages:
Fatal error: can't create tests/stub_event.o: No such file or directory
Makefile:6824: recipe for target 'tests/stub_event.o' failed
make[5]: *** [tests/stub_event.o] Error 1
../../src/tests/stub_comm.cc:9:19: fatal error: squid.h: No such file or directory
 #include "squid.h"
                   ^
compilation terminated.
Makefile:6824: recipe for target 'tests/stub_comm.o' failed
make[5]: *** [tests/stub_comm.o] Error 2
g++: error: ../../src/tests/testTokenizer.cc: No such file or directory
g++: fatal error: no input files
compilation terminated.
Makefile:6824: recipe for target 'tests/testTokenizer.o' failed
make[5]: *** [tests/testTokenizer.o] Error 1
make[5]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_build/src'>
Makefile:7446: recipe for target 'check-am' failed
make[4]: *** [check-am] Error 2
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_build/src'>
Makefile:6946: recipe for target 'check-recursive' failed
make[3]: *** [check-recursive] Error 1
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_build/src'>
Makefile:7449: recipe for target 'check' failed
make[2]: *** [check] Error 2
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_build/src'>
Makefile:568: recipe for target 'check-recursive' failed
make[1]: *** [check-recursive] Error 1
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/ws/btlayer-00-default/squid-4.0.1-BZR/_build'>
Makefile:770: recipe for target 'distcheck' failed
make: *** [distcheck] Error 1
buildtest.sh result is 2
grep: btlayer-00-default.log: No such file or directory
grep: btlayer-00-default.log: No such file or directory
grep: btlayer-00-default.log: No such file or directory
Build FAILED.
Build step 'Execute shell' marked build as failure
[description-setter] Description set: 

From noc at squid-cache.org  Tue Oct 27 08:40:28 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Tue, 27 Oct 2015 08:40:28 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Jenkins_build_is_back_to_normal_=3A_trunk-m?=
 =?utf-8?q?atrix_=C2=BB_gcc=2Cd-opensuse-13=2E2_=23402?=
In-Reply-To: <370731809.539.1445925610138.JavaMail.jenkins@buildmaster>
References: <370731809.539.1445925610138.JavaMail.jenkins@buildmaster>
Message-ID: <1186211012.540.1445935228118.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=gcc,label=d-opensuse-13.2/402/>


From noc at squid-cache.org  Tue Oct 27 10:07:57 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Tue, 27 Oct 2015 10:07:57 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #902
In-Reply-To: <720523486.538.1445858038119.JavaMail.jenkins@buildmaster>
References: <720523486.538.1445858038119.JavaMail.jenkins@buildmaster>
Message-ID: <784623798.541.1445940477199.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/902/>


From manojmaybe000 at gmail.com  Tue Oct 27 10:05:01 2015
From: manojmaybe000 at gmail.com (manojmaybe)
Date: Tue, 27 Oct 2015 03:05:01 -0700 (PDT)
Subject: [squid-dev] Peek and splice
Message-ID: <1445940301143-4673975.post@n4.nabble.com>

I use squid 3.5.10 as transparent proxy mode . I used peek and splice mode, i
try to peek at step1 (SslBump1) and server name is available in SNI go for
further, also peeked at step2 (SslBump2) for whether we doesn't get server
name , if server name not get in certificate cn i would like to splice all.
My squid configuration as follows

ssl_bump bump ssl_bumping_forcesafesearch bump_ips bump_ports
acl no_server_name_yet ssl::server_name_regex none
ssl_bump peek step1
ssl_bump peek no_server_name_yet step2
ssl_bump splice all

but the configuration not working properly.
How i solve the above scenario. 



--
View this message in context: http://squid-web-proxy-cache.1019090.n4.nabble.com/Peek-and-splice-tp4673975.html
Sent from the Squid - Development mailing list archive at Nabble.com.

From chris at computersalat.de  Tue Oct 27 13:36:05 2015
From: chris at computersalat.de (Christian)
Date: Tue, 27 Oct 2015 14:36:05 +0100
Subject: [squid-dev] dead link to squid 4 Changelog
Message-ID: <562F7DC5.6090406@computersalat.de>

link to Changelog is dead

http://www.squid-cache.org/Versions/v4/ChangeLog.txt
... file not found.

Please fix.
Thank you very much

-- 

Christian
----------------------------------------------------
   - Please do not 'CC' me on list mails.
          Just reply to the list :)
----------------------------------------------------
Der ultimative shop für Sportbekleidung und Zubehör

http://www.sc24.de
----------------------------------------------------

From rousskov at measurement-factory.com  Tue Oct 27 19:17:25 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Tue, 27 Oct 2015 13:17:25 -0600
Subject: [squid-dev] Peek and splice
In-Reply-To: <1445940301143-4673975.post@n4.nabble.com>
References: <1445940301143-4673975.post@n4.nabble.com>
Message-ID: <562FCDC5.1030607@measurement-factory.com>

On 10/27/2015 04:05 AM, manojmaybe wrote:
> I use squid 3.5.10 as transparent proxy mode . I used peek and splice mode, i
> try to peek at step1 (SslBump1) and server name is available in SNI go for
> further, also peeked at step2 (SslBump2) for whether we doesn't get server
> name , if server name not get in certificate cn i would like to splice all.
> My squid configuration as follows
> 
> ssl_bump bump ssl_bumping_forcesafesearch bump_ips bump_ports
> acl no_server_name_yet ssl::server_name_regex none
> ssl_bump peek step1
> ssl_bump peek no_server_name_yet step2
> ssl_bump splice all
> 
> but the configuration not working properly.
> How i solve the above scenario. 

I recommend posting this configuration question to squid-users instead
of squid-dev. If you do, consider adding an explanation of which
transactions you want to _bump_. Your email only documents what you want
to splice but your squid.conf rules contain a bump action as well.

It may also help if you reshape your description of the desired
functionality in the form of isolated if-then items rather than a single
sentence.

Alex.


From squid3 at treenet.co.nz  Tue Oct 27 19:28:57 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Wed, 28 Oct 2015 08:28:57 +1300
Subject: [squid-dev] dead link to squid 4 Changelog
In-Reply-To: <562F7DC5.6090406@computersalat.de>
References: <562F7DC5.6090406@computersalat.de>
Message-ID: <562FD079.1090308@treenet.co.nz>

On 28/10/2015 2:36 a.m., Christian wrote:
> link to Changelog is dead
> 
> http://www.squid-cache.org/Versions/v4/ChangeLog.txt
> ... file not found.
> 
> Please fix.
> Thank you very much
> 

The URL is now http://www.squid-cache.org/Versions/v4/ChangeLog.html and
should be fixed when the mirrors next update.

PS. the 4.x changelog is also available via
<ftp://ftp.squid-cache.org/pub/squid/squid-4-ChangeLog.txt>

Amos


From noc at squid-cache.org  Wed Oct 28 03:59:50 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Wed, 28 Oct 2015 03:59:50 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #904
Message-ID: <1511970278.542.1446004790695.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/904/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 404
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14370 squid3 at treenet.co.nz-20151027224300-qtfu7m2sfcde7vv1
" stderr: ""
RevisionState revno:14370 revid:squid3 at treenet.co.nz-20151027224300-qtfu7m2sfcde7vv1
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson6568486329498000550.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 904 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

From gkinkie at gmail.com  Wed Oct 28 13:05:42 2015
From: gkinkie at gmail.com (Kinkie)
Date: Wed, 28 Oct 2015 14:05:42 +0100
Subject: [squid-dev] [PATCH] mempools-nozero: squidaio_ctrl_t
Message-ID: <CA+Y8hcPysnDkS3mV7bM58c3NdewR3PkLOpw_sSSB7=deBJXtrw@mail.gmail.com>

Hi all,
   this is the final patch of my current drive on mempools-nozero (aka
convert explicit pool users to MEMPROXY_CLASS).
Build-and run-tested, big-context diff.

Thanks

-- 
    Francesco
-------------- next part --------------
A non-text attachment was scrubbed...
Name: mempools-nozero-1028-v1.patch
Type: text/x-diff
Size: 11873 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151028/d342c7be/attachment.patch>

From squid3 at treenet.co.nz  Wed Oct 28 14:16:12 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Thu, 29 Oct 2015 03:16:12 +1300
Subject: [squid-dev] [PATCH] mempools-nozero: squidaio_ctrl_t
In-Reply-To: <CA+Y8hcPysnDkS3mV7bM58c3NdewR3PkLOpw_sSSB7=deBJXtrw@mail.gmail.com>
References: <CA+Y8hcPysnDkS3mV7bM58c3NdewR3PkLOpw_sSSB7=deBJXtrw@mail.gmail.com>
Message-ID: <5630D8AC.5090308@treenet.co.nz>

On 29/10/2015 2:05 a.m., Kinkie wrote:
> Hi all,
>    this is the final patch of my current drive on mempools-nozero (aka
> convert explicit pool users to MEMPROXY_CLASS).
> Build-and run-tested, big-context diff.
> 
> Thanks
> 

Thank you.

in src/DiskIO/DiskThreads/DiskThreads.h:

* do you have enough knowledge about the new classes now to write a
doxygen description for them?

* please use doxygen syntax for the new label comments


in src/DiskIO/DiskThreads/DiskThreadsIOStrategy.cc:

* please use C++ casting on new and altered lines with casts.
 - DiskThreadsIOStrategy::callback at least has one.


in src/DiskIO/DiskThreads/aiops.cc:

* since you are changing the pool lines documentation, please make them
all use doxygen comments and nullptr.



Otherwise this looks fine.

+1.

Amos

From gkinkie at gmail.com  Wed Oct 28 15:42:41 2015
From: gkinkie at gmail.com (Kinkie)
Date: Wed, 28 Oct 2015 16:42:41 +0100
Subject: [squid-dev] [PATCH] mempools-nozero: squidaio_ctrl_t
In-Reply-To: <5630D8AC.5090308@treenet.co.nz>
References: <CA+Y8hcPysnDkS3mV7bM58c3NdewR3PkLOpw_sSSB7=deBJXtrw@mail.gmail.com>
 <5630D8AC.5090308@treenet.co.nz>
Message-ID: <CA+Y8hcOwd9uY3QwvK0_3eKjhuYnLj_t+d9g9GsuVkK8gjWC5LQ@mail.gmail.com>

On Wed, Oct 28, 2015 at 3:16 PM, Amos Jeffries <squid3 at treenet.co.nz> wrote:
> On 29/10/2015 2:05 a.m., Kinkie wrote:
>> Hi all,
>>    this is the final patch of my current drive on mempools-nozero (aka
>> convert explicit pool users to MEMPROXY_CLASS).
>> Build-and run-tested, big-context diff.
>>
>> Thanks
>>
>
> Thank you.
>
> in src/DiskIO/DiskThreads/DiskThreads.h:
>
> * do you have enough knowledge about the new classes now to write a
> doxygen description for them?

.. I wish..

>
> * please use doxygen syntax for the new label comments
>
>
> in src/DiskIO/DiskThreads/DiskThreadsIOStrategy.cc:
>
> * please use C++ casting on new and altered lines with casts.
>  - DiskThreadsIOStrategy::callback at least has one.

There was another in aioCancel.

>
>
> in src/DiskIO/DiskThreads/aiops.cc:
>
> * since you are changing the pool lines documentation, please make them
> all use doxygen comments and nullptr.

Ok. I'm not sure that the documentation will be much more informative
than now though.

> Otherwise this looks fine.
>
> +1.


Thanks, will merge in ~30 minutes.

   Kinkie

From noc at squid-cache.org  Thu Oct 29 11:19:05 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Thu, 29 Oct 2015 11:19:05 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Build_failed_in_Jenkins=3A_trunk-matrix_?=
 =?utf-8?q?=C2=BB_clang=2Cd-debian-unstable_=23405?=
Message-ID: <1494012284.0.1446117545781.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/405/>

------------------------------------------
[...truncated 6735 lines...]
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/base'>
Making dvi in anyp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/anyp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/anyp'>
Making dvi in helper
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/helper'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/helper'>
Making dvi in dns
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/dns'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/dns'>
Making dvi in ftp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ftp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ftp'>
Making dvi in parser
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/parser'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/parser'>
Making dvi in comm
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/comm'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/comm'>
Making dvi in eui
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/eui'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/eui'>
Making dvi in acl
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/acl'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/acl'>
Making dvi in format
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/format'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/format'>
Making dvi in clients
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/clients'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/clients'>
Making dvi in servers
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/servers'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/servers'>
Making dvi in fs
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/fs'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/fs'>
Making dvi in repl
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/repl'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/repl'>
Making dvi in DiskIO
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
Making dvi in AIO
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/AIO'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/AIO'>
Making dvi in Blocking
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Blocking'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Blocking'>
Making dvi in DiskDaemon
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskDaemon'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskDaemon'>
Making dvi in DiskThreads
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskThreads'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskThreads'>
Making dvi in IpcIo
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/IpcIo'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/IpcIo'>
Making dvi in Mmapped
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Mmapped'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Mmapped'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
Making dvi in auth
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
Making dvi in basic
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/basic'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/basic'>
Making dvi in digest
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/digest'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/digest'>
Making dvi in negotiate
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/negotiate'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/negotiate'>
Making dvi in ntlm
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/ntlm'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/ntlm'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
Making dvi in http
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
Making dvi in one
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http/one'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http/one'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
Making dvi in ip
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ip'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ip'>
Making dvi in icmp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/icmp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/icmp'>
Making dvi in ident
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ident'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ident'>
Making dvi in log
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/log'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/log'>
Making dvi in ipc
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ipc'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ipc'>
Making dvi in mgr
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/mgr'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/mgr'>
Making dvi in security
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/security'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/security'>
Making dvi in snmp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/snmp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/snmp'>
Making dvi in adaptation
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
Making dvi in icap
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation/icap'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation/icap'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
make[3]: Nothing to be done for 'dvi-am'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
Making dvi in tools
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
Making dvi in helper-mux
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/helper-mux'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/helper-mux'>
Making dvi in purge
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/purge'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/purge'>
Making dvi in squidclient
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
Making dvi in systemd
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/systemd'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/systemd'>
Making dvi in sysvinit
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/sysvinit'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/sysvinit'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
make[3]: Nothing to be done for 'dvi-am'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
Making dvi in test-suite
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/test-suite'>
make[2]: Nothing to be done for 'dvi'.
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/test-suite'>
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[2]: Nothing to be done for 'dvi-am'.
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[1]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
Making check in compat
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
make  testPreCompiler
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
depbase=`echo testPreCompiler.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache clang++ -DHAVE_CONFIG_H   -I../../.. -I../../../include -I../../../lib -I../../../src -I../include     -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT -g -O2 -std=c++11 -MT testPreCompiler.o -MD -MP -MF $depbase.Tpo -c -o testPreCompiler.o ../../../compat/testPreCompiler.cc &&\
mv -f $depbase.Tpo $depbase.Po
/bin/bash ../libtool  --tag=CXX   --mode=link ccache clang++ -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT -g -O2 -std=c++11  -g -o testPreCompiler testPreCompiler.o  -L/usr/lib/x86_64-linux-gnu -lcppunit -ldl 
libtool: link: ccache clang++ -Werror -Qunused-arguments -Wno-deprecated-register -D_REENTRANT -g -O2 -std=c++11 -g -o testPreCompiler testPreCompiler.o  -L/usr/lib/x86_64-linux-gnu -lcppunit -ldl
testPreCompiler.o:(.rodata._ZTVN7CppUnit10TestCallerI15testPreCompilerEE[_ZTVN7CppUnit10TestCallerI15testPreCompilerEE]+0x40): undefined reference to `CppUnit::TestCase::getName() const'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
Makefile:853: recipe for target 'testPreCompiler' failed
make[3]: *** [testPreCompiler] Error 1
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
Makefile:1195: recipe for target 'check-am' failed
make[2]: *** [check-am] Error 2
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
Makefile:579: recipe for target 'check-recursive' failed
make[1]: *** [check-recursive] Error 1
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
Makefile:787: recipe for target 'distcheck' failed
make: *** [distcheck] Error 1
buildtest.sh result is 2
BUILD: .././test-suite/buildtests/layer-00-default.opts
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS:  -Werror -Qunused-arguments  -D_REENTRANT
configure: BUILD C++ FLAGS: -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS:  -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT
configure: BUILD Tools C++ FLAGS:  -g -O2 -std=c++11
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS:  -Werror -Qunused-arguments  -D_REENTRANT
configure: BUILD C++ FLAGS: -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS:  -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT
configure: BUILD Tools C++ FLAGS:  -g -O2 -std=c++11
testPreCompiler.o:(.rodata._ZTVN7CppUnit10TestCallerI15testPreCompilerEE[_ZTVN7CppUnit10TestCallerI15testPreCompilerEE]+0x40): undefined reference to `CppUnit::TestCase::getName() const'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[3]: *** [testPreCompiler] Error 1
make[2]: *** [check-am] Error 2
make[1]: *** [check-recursive] Error 1
make: *** [distcheck] Error 1
Build FAILED.
Build step 'Execute shell' marked build as failure
[description-setter] Description set: 

From gkinkie at gmail.com  Thu Oct 29 13:49:10 2015
From: gkinkie at gmail.com (Kinkie)
Date: Thu, 29 Oct 2015 14:49:10 +0100
Subject: [squid-dev] [PATCH] Migrate basic_ncsa_auth from squid hash to
	std::unordered_map
Message-ID: <CA+Y8hcPi1DbzDE7_qz=uutrLReVQU=bkFhi-RKhx05yz6OABQg@mail.gmail.com>

Hi all,
  this patch, part of my renewed push to use std:: containers in place
of our hand-rolled ones, migrates basic_ncsa_auth to
std::unordered_map. It's been build- and run-tested successfully.


-- 
    Francesco
-------------- next part --------------
A non-text attachment was scrubbed...
Name: stl-151029-v1.patch
Type: text/x-diff
Size: 4916 bytes
Desc: not available
URL: <http://lists.squid-cache.org/pipermail/squid-dev/attachments/20151029/a065d3b4/attachment.patch>

From squid3 at treenet.co.nz  Thu Oct 29 17:49:27 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 30 Oct 2015 06:49:27 +1300
Subject: [squid-dev] [PATCH] Migrate basic_ncsa_auth from squid hash to
 std::unordered_map
In-Reply-To: <CA+Y8hcPi1DbzDE7_qz=uutrLReVQU=bkFhi-RKhx05yz6OABQg@mail.gmail.com>
References: <CA+Y8hcPi1DbzDE7_qz=uutrLReVQU=bkFhi-RKhx05yz6OABQg@mail.gmail.com>
Message-ID: <56325C27.3080308@treenet.co.nz>

On 30/10/2015 2:49 a.m., Kinkie wrote:
> Hi all,
>   this patch, part of my renewed push to use std:: containers in place
> of our hand-rolled ones, migrates basic_ncsa_auth to
> std::unordered_map. It's been build- and run-tested successfully.
> 

+1. Thank you.

Amos


From squid3 at treenet.co.nz  Thu Oct 29 19:23:47 2015
From: squid3 at treenet.co.nz (Amos Jeffries)
Date: Fri, 30 Oct 2015 08:23:47 +1300
Subject: [squid-dev] [PATCH] SBuf Locker friend class
Message-ID: <56327243.4080305@treenet.co.nz>

Adds the Locker friend class to SBuf to provide safety ref-count locks
when dealing with dangerous char* or SBuf& inputs.

I have gone through and added it to all the non-const methods that
appear to be taking char* directly, or using a char* taken from SBuf&.
That review added the appendf/printf methods to the set we identified on
IRC.

IMO the trim() method mentioned on IRC does not need it since the scope
lifetime of the pointer taken by toRemove.buf() does not cross any
alterations of the this objects members.


I've not added documentation for the Locker class. Alex could you
provide a blurb to describe the memory issue and requirements this solves ?

Amos
-------------- next part --------------
=== modified file 'src/SBuf.cc'
--- src/SBuf.cc	2015-08-12 22:18:22 +0000
+++ src/SBuf.cc	2015-10-29 18:41:39 +0000
@@ -144,40 +144,41 @@
     return InitialStore;
 }
 
 SBuf&
 SBuf::assign(const SBuf &S)
 {
     debugs(24, 7, "assigning " << id << " from " <<  S.id);
     if (&S == this) //assignment to self. Noop.
         return *this;
     ++stats.assignFast;
     store_ = S.store_;
     off_ = S.off_;
     len_ = S.len_;
     return *this;
 }
 
 SBuf&
 SBuf::assign(const char *S, size_type n)
 {
     debugs(24, 6, id << " from c-string, n=" << n << ")");
+    Locker prevent_raw_memory_madness(this, S, n);
     clear();
     return append(S, n); //bounds checked in append()
 }
 
 void
 SBuf::reserveCapacity(size_type minCapacity)
 {
     Must(minCapacity <= maxSize);
     cow(minCapacity);
 }
 
 char *
 SBuf::rawSpace(size_type minSpace)
 {
     Must(length() <= maxSize - minSpace);
     debugs(24, 7, "reserving " << minSpace << " for " << id);
     ++stats.rawAccess;
     // we're not concerned about RefCounts here,
     // the store knows the last-used portion. If
     // it's available, we're effectively claiming ownership
@@ -196,90 +197,99 @@
 void
 SBuf::clear()
 {
 #if 0
     //enabling this code path, the store will be freed and reinitialized
     store_ = GetStorePrototype(); //uncomment to actually free storage upon clear()
 #else
     //enabling this code path, we try to release the store without deallocating it.
     // will be lazily reallocated if needed.
     if (store_->LockCount() == 1)
         store_->clear();
 #endif
     len_ = 0;
     off_ = 0;
     ++stats.clear;
 }
 
 SBuf&
 SBuf::append(const SBuf &S)
 {
+    Locker prevent_raw_memory_madness(this, S.buf(), S.length());
     return lowAppend(S.buf(), S.length());
 }
 
 SBuf &
 SBuf::append(const char * S, size_type Ssize)
 {
     if (S == NULL)
         return *this;
     if (Ssize == SBuf::npos)
         Ssize = strlen(S);
     debugs(24, 7, "from c-string to id " << id);
+    Locker prevent_raw_memory_madness(this, S, Ssize);
     // coverity[access_dbuff_in_call]
     return lowAppend(S, Ssize);
 }
 
 SBuf &
 SBuf::append(const char c)
 {
     return lowAppend(&c, 1);
 }
 
 SBuf&
 SBuf::Printf(const char *fmt, ...)
 {
+    // with printf() an arg might be a dangerous char*
+    // NP: cant rely on vappendf() Locker because of clear()
+    Locker prevent_raw_memory_madness(this, buf(), length());
+
     va_list args;
     va_start(args, fmt);
     clear();
     vappendf(fmt, args);
     va_end(args);
     return *this;
 }
 
 SBuf&
 SBuf::appendf(const char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
     vappendf(fmt, args);
     va_end(args);
     return *this;
 }
 
 SBuf&
 SBuf::vappendf(const char *fmt, va_list vargs)
 {
     Must(fmt != NULL);
     int sz = 0;
     //reserve twice the format-string size, it's a likely heuristic
     size_type requiredSpaceEstimate = strlen(fmt)*2;
 
+    // with appendf() an arg might be a dangerous char*
+    Locker prevent_raw_memory_madness(this, buf(), length());
+
     char *space = rawSpace(requiredSpaceEstimate);
 #ifdef VA_COPY
     va_list ap;
     VA_COPY(ap, vargs);
     sz = vsnprintf(space, spaceSize(), fmt, ap);
     va_end(ap);
 #else
     sz = vsnprintf(space, spaceSize(), fmt, vargs);
 #endif
 
     /* check for possible overflow */
     /* snprintf on Linux returns -1 on output errors, or the size
      * that would have been written if enough space had been available */
     /* vsnprintf is standard in C99 */
 
     if (sz >= static_cast<int>(spaceSize())) {
         // not enough space on the first go, we now know how much we need
         requiredSpaceEstimate = sz*2; // TODO: tune heuristics
         space = rawSpace(requiredSpaceEstimate);
         sz = vsnprintf(space, spaceSize(), fmt, vargs);

=== modified file 'src/SBuf.h'
--- src/SBuf.h	2015-08-12 22:18:22 +0000
+++ src/SBuf.h	2015-10-29 18:53:31 +0000
@@ -650,40 +650,54 @@
     iterator begin() {
         return iterator(*this, 0);
     }
 
     iterator end() {
         return iterator(*this, length());
     }
 
     reverse_iterator rbegin() {
         return reverse_iterator(*this, length());
     }
 
     reverse_iterator rend() {
         return reverse_iterator(*this, 0);
     }
 
     // TODO: possibly implement erase() similar to std::string's erase
     // TODO: possibly implement a replace() call
 private:
 
+    class Locker
+    {
+    public:
+        Locker(SBuf *parent, const char *Q, size_t len) : locket(nullptr) {
+            // lock if Q intersects the parents buffer area
+            const MemBlob *P = parent->store_.getRaw();
+            if ( (Q+len) >= P->mem && Q <= (P->mem + P->capacity) )
+                locket = P;
+        }
+    private:
+        MemBlob::Pointer locket;
+    };
+    friend class Locker;
+
     MemBlob::Pointer store_; ///< memory block, possibly shared with other SBufs
     size_type off_; ///< our content start offset from the beginning of shared store_
     size_type len_; ///< number of our content bytes in shared store_
     static SBufStats stats; ///< class-wide statistics
 
     /// SBuf object identifier; does not change when contents do,
     ///   including during assignment
     const InstanceId<SBuf> id;
 
     /** obtain prototype store
      *
      * Just-created SBufs all share to the same MemBlob.
      * This call instantiates and returns it.
      */
     static MemBlob::Pointer GetStorePrototype();
 
     /**
      * obtains a char* to the beginning of this SBuf in memory.
      * \note the obtained string is NOT null-terminated.
      */


From rousskov at measurement-factory.com  Thu Oct 29 21:40:18 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Thu, 29 Oct 2015 15:40:18 -0600
Subject: [squid-dev] [PATCH] SBuf Locker friend class
In-Reply-To: <56327243.4080305@treenet.co.nz>
References: <56327243.4080305@treenet.co.nz>
Message-ID: <56329242.70708@measurement-factory.com>

On 10/29/2015 01:23 PM, Amos Jeffries wrote:

> Adds the Locker friend class to SBuf to provide safety ref-count locks
> when dealing with dangerous char* or SBuf& inputs.

Thank you for working on this.


> +    Locker prevent_raw_memory_madness(this, S, n);

If you can make it constant, make it const.


> +            // lock if Q intersects the parents buffer area
> +            const MemBlob *P = parent->store_.getRaw();
> +            if ( (Q+len) >= P->mem && Q <= (P->mem + P->capacity) )


I do not think "len" is important here. We are not trying to protect
ourselves against invalid pointers that start somewhere before the blob
but end inside the blob. If I am right, please remove the len argument
and simplify.

I recommend using "min <= x <= max" pattern.

Also, a Q pointing at (P->mem + P->capacity) does not belong to P!

Please avoid single-character names. They may the code more difficult to
understand, search, and refactor.

Please reserve capitalized names for Globals.

In summary, consider:

    if (blob->mem <= mem && mem < blob->mem + blob->capacity)


However, I would actually make it an inlined MemBlob method:

    if (blob->contains(mem))


I like your refcounting Pointer trick. Much better than manual
lock/unlock work!


> I have gone through and added it to all the non-const methods that
> appear to be taking char* directly, or using a char* taken from SBuf&.
> That review added the appendf/printf methods to the set we identified on
> IRC.

What about SBuf::scanf()? Unlikely, but, the format parameter might be
pointing to the same blob that gets deleted when we call c_str()...



>  SBuf &
>  SBuf::append(const char * S, size_type Ssize)
>  {
>      if (S == NULL)
>          return *this;
>      if (Ssize == SBuf::npos)
>          Ssize = strlen(S);
>      debugs(24, 7, "from c-string to id " << id);
> +    Locker prevent_raw_memory_madness(this, S, Ssize);

and

> SBuf::vappendf(const char *fmt, va_list vargs)
>  {
>      Must(fmt != NULL);
>      int sz = 0;
>      //reserve twice the format-string size, it's a likely heuristic
>      size_type requiredSpaceEstimate = strlen(fmt)*2;
>  
> +    // with appendf() an arg might be a dangerous char*
> +    Locker prevent_raw_memory_madness(this, buf(), length());
> +

If possible, let's always start dangerous methods with allocating a
Locker object. This clarifies the lock scope and minimizes the chance
that somebody adds dangerous code _above_ the lock.


> +    // with printf() an arg might be a dangerous char*

> +    // with appendf() an arg might be a dangerous char*


s/an arg/fmt or arg/ or s/an arg/any parameter/

That is, the "fmt" parameter itself is not excluded from danger.


> IMO the trim() method mentioned on IRC does not need it since the scope
> lifetime of the pointer taken by toRemove.buf() does not cross any
> alterations of the this objects members.

Agreed.


I also suggest renaming "prevent_raw_memory_madness" to "blobKeeper" to
clarify and for consistency with other camelCase names.



> I've not added documentation for the Locker class. Alex could you
> provide a blurb to describe the memory issue and requirements this solves ?


How about something like the following?

/// Keeps SBuf's MemBlob alive in a blob-destroying context where
/// a seemingly unrelated memory pointer may belong to the same blob.
/// For [an extreme] example, consider: a.append(a).
/// Compared to an SBuf temporary, this class is optimized to
/// preserve blobs only if needed and to reduce debugging noise.
class Locker ...


HTH,

Alex.


From noc at squid-cache.org  Fri Oct 30 06:39:18 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 30 Oct 2015 06:39:18 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Build_failed_in_Jenkins=3A_trunk-full-matri?=
 =?utf-8?q?x_=C2=BB_clang=2Cd-debian-unstable_=2333?=
Message-ID: <1876007718.13.1446187158984.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/33/>

------------------------------------------
[...truncated 6737 lines...]
Making dvi in anyp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/anyp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/anyp'>
Making dvi in helper
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/helper'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/helper'>
Making dvi in dns
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/dns'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/dns'>
Making dvi in ftp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ftp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ftp'>
Making dvi in parser
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/parser'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/parser'>
Making dvi in comm
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/comm'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/comm'>
Making dvi in eui
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/eui'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/eui'>
Making dvi in acl
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/acl'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/acl'>
Making dvi in format
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/format'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/format'>
Making dvi in clients
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/clients'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/clients'>
Making dvi in servers
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/servers'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/servers'>
Making dvi in fs
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/fs'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/fs'>
Making dvi in repl
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/repl'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/repl'>
Making dvi in DiskIO
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
Making dvi in AIO
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/AIO'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/AIO'>
Making dvi in Blocking
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Blocking'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Blocking'>
Making dvi in DiskDaemon
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskDaemon'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskDaemon'>
Making dvi in DiskThreads
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskThreads'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskThreads'>
Making dvi in IpcIo
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/IpcIo'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/IpcIo'>
Making dvi in Mmapped
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Mmapped'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Mmapped'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
Making dvi in auth
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
Making dvi in basic
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/basic'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/basic'>
Making dvi in digest
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/digest'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/digest'>
Making dvi in negotiate
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/negotiate'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/negotiate'>
Making dvi in ntlm
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/ntlm'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/ntlm'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
Making dvi in http
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
Making dvi in one
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http/one'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http/one'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
Making dvi in ip
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ip'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ip'>
Making dvi in icmp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/icmp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/icmp'>
Making dvi in ident
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ident'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ident'>
Making dvi in log
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/log'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/log'>
Making dvi in ipc
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ipc'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ipc'>
Making dvi in mgr
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/mgr'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/mgr'>
Making dvi in security
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/security'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/security'>
Making dvi in snmp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/snmp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/snmp'>
Making dvi in adaptation
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
Making dvi in icap
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation/icap'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation/icap'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
make[3]: Nothing to be done for 'dvi-am'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
Making dvi in tools
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
Making dvi in helper-mux
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/helper-mux'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/helper-mux'>
Making dvi in purge
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/purge'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/purge'>
Making dvi in squidclient
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
Making dvi in systemd
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/systemd'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/systemd'>
Making dvi in sysvinit
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/sysvinit'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/sysvinit'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
make[3]: Nothing to be done for 'dvi-am'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
Making dvi in test-suite
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/test-suite'>
make[2]: Nothing to be done for 'dvi'.
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/test-suite'>
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[2]: Nothing to be done for 'dvi-am'.
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[1]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
Making check in compat
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
make  testPreCompiler
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
depbase=`echo testPreCompiler.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache clang++ -DHAVE_CONFIG_H   -I../../.. -I../../../include -I../../../lib -I../../../src -I../include     -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT -g -O2 -std=c++11 -MT testPreCompiler.o -MD -MP -MF $depbase.Tpo -c -o testPreCompiler.o ../../../compat/testPreCompiler.cc &&\
mv -f $depbase.Tpo $depbase.Po
/bin/bash ../libtool  --tag=CXX   --mode=link ccache clang++ -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT -g -O2 -std=c++11  -g -o testPreCompiler testPreCompiler.o  -L/usr/lib/x86_64-linux-gnu -lcppunit -ldl 
libtool: link: ccache clang++ -Werror -Qunused-arguments -Wno-deprecated-register -D_REENTRANT -g -O2 -std=c++11 -g -o testPreCompiler testPreCompiler.o  -L/usr/lib/x86_64-linux-gnu -lcppunit -ldl
testPreCompiler.o:(.rodata._ZTVN7CppUnit10TestCallerI15testPreCompilerEE[_ZTVN7CppUnit10TestCallerI15testPreCompilerEE]+0x40): undefined reference to `CppUnit::TestCase::getName() const'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
Makefile:853: recipe for target 'testPreCompiler' failed
make[3]: *** [testPreCompiler] Error 1
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
Makefile:1195: recipe for target 'check-am' failed
make[2]: *** [check-am] Error 2
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
Makefile:579: recipe for target 'check-recursive' failed
make[1]: *** [check-recursive] Error 1
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
Makefile:787: recipe for target 'distcheck' failed
make: *** [distcheck] Error 1
buildtest.sh result is 2
BUILD: .././test-suite/buildtests/layer-00-default.opts
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS:  -Werror -Qunused-arguments  -D_REENTRANT
configure: BUILD C++ FLAGS: -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS:  -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT
configure: BUILD Tools C++ FLAGS:  -g -O2 -std=c++11
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS:  -Werror -Qunused-arguments  -D_REENTRANT
configure: BUILD C++ FLAGS: -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS:  -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT
configure: BUILD Tools C++ FLAGS:  -g -O2 -std=c++11
checking for egrep... ../../configure: line 7182: echo: write error: Broken pipe
testPreCompiler.o:(.rodata._ZTVN7CppUnit10TestCallerI15testPreCompilerEE[_ZTVN7CppUnit10TestCallerI15testPreCompilerEE]+0x40): undefined reference to `CppUnit::TestCase::getName() const'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[3]: *** [testPreCompiler] Error 1
make[2]: *** [check-am] Error 2
make[1]: *** [check-recursive] Error 1
make: *** [distcheck] Error 1
Build FAILED.
Build step 'Execute shell' marked build as failure
[description-setter] Description set: 

From noc at squid-cache.org  Fri Oct 30 17:29:15 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Fri, 30 Oct 2015 17:29:15 +0000 (UTC)
Subject: [squid-dev] Jenkins build is back to normal : trunk-polygraph #905
In-Reply-To: <1511970278.542.1446004790695.JavaMail.jenkins@buildmaster>
References: <1511970278.542.1446004790695.JavaMail.jenkins@buildmaster>
Message-ID: <1672466577.18.1446226155554.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/905/>


From rousskov at measurement-factory.com  Fri Oct 30 20:58:14 2015
From: rousskov at measurement-factory.com (Alex Rousskov)
Date: Fri, 30 Oct 2015 14:58:14 -0600
Subject: [squid-dev] [PATCH] No reconfiguration during shutdown
In-Reply-To: <562E61E8.4050507@treenet.co.nz>
References: <562E4E0D.3090704@measurement-factory.com>
 <562E61E8.4050507@treenet.co.nz>
Message-ID: <5633D9E6.7000402@measurement-factory.com>

On 10/26/2015 11:24 AM, Amos Jeffries wrote:
> On 27/10/2015 5:00 a.m., Alex Rousskov wrote:
>> Hello,
>>
>>     To avoid crashes, prohibit pointless reconfiguration during shutdown.
>>
>> Also consolidated and polished signal action handling code:
>>
>> 1. For any executed action X, clear do_X at the beginning of action X
>>    code because once we start X, we should accept/queue more X
>>    requests (or inform the admin if we reject them).
>>
>> 2. Delay any action X requested during startup or reconfiguration
>>    because the latter two actions modify global state that X depends
>>    on. Inform the admin that the requested action is being delayed.
>>
>> 3. Cancel any action X requested during shutdown. We cannot run X
>>    during shutdown because shutdown modifies global state that X
>>    depends on, and we never come back from shutdown so there is no
>>    point in delaying X. Inform the admin that the requested action is
>>    canceled.
>>
>> Repeated failed attempts to fix crashes related to various overlapping
>> signal actions confirm that this code is a lot trickier than it looks.
>> This change introduces a more systematic/comprehensive approach to
>> resolving associated conflicts compared to previous ad hoc attempts.
>>
>> For example, there were several changes related to bug 3574 (trunk
>> r14354), but trunk Squid still crashes if SIGHUP is received at the
>> "wrong" time. I hope this fix will kill the remaining similar bugs or at
>> least make future fixes easier.
>>
>>     http://bugs.squid-cache.org/show_bug.cgi?id=3574
>>
> 
> +1 on this patch.
> 
> Please apply with a "--fixes squid:3574" and bug reference in the commit
> title.

Done (r14374).



>> One possible future work is to split shutdown into two states:
>>
>> * scheduled (waiting for timeout to expire; may not affect some of the
>>   signal actions) and
>> * in-progress (blocks out all other actions).
>>
>> Currently, the two states are merged into one in trunk code (there is
>> only one shutting_down global). This fix does not attempt to address
>> that deficiency. Factory does not plan to work on this in the
>> foreseeable future. Please feel free to solve this problem!
> 
> 
> I did (re-)discover that the final cycle through SignalsEngine whe
> hutdown timeout ends does indeed drain the AsyncQueue. But not wait for
> any other types of pending I/O or FD events that might appear during
> that drain. That is paving the way for the current swap.state read/write
> crashes on shutdown.

Glad you found that bug. We should fix it, but the correct fix is not
trivial because we have to both loop when stop looping at some point. I
resist the temptation to discuss specifics on this thread.


> I plan to work towards Runners doing all the shutdown handling and in
> particular hooking some components into that which are currently not
> paying any attention to shutdown termination (ie the swap.state and DNS
> sockets FD). Once that conversion is completed we shall see what remains
> that needs any async handling after timout ends.


Thank you,

Alex.


From noc at squid-cache.org  Sat Oct 31 01:37:37 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Sat, 31 Oct 2015 01:37:37 +0000 (UTC)
Subject: [squid-dev] =?utf-8?q?Build_failed_in_Jenkins=3A_trunk-full-matri?=
 =?utf-8?q?x_=C2=BB_clang=2Cd-debian-unstable_=2334?=
In-Reply-To: <1876007718.13.1446187158984.JavaMail.jenkins@buildmaster>
References: <1876007718.13.1446187158984.JavaMail.jenkins@buildmaster>
Message-ID: <1332296964.19.1446255457397.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/34/>

------------------------------------------
[...truncated 6739 lines...]
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/anyp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/anyp'>
Making dvi in helper
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/helper'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/helper'>
Making dvi in dns
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/dns'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/dns'>
Making dvi in ftp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ftp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ftp'>
Making dvi in parser
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/parser'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/parser'>
Making dvi in comm
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/comm'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/comm'>
Making dvi in eui
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/eui'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/eui'>
Making dvi in acl
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/acl'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/acl'>
Making dvi in format
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/format'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/format'>
Making dvi in clients
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/clients'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/clients'>
Making dvi in servers
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/servers'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/servers'>
Making dvi in fs
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/fs'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/fs'>
Making dvi in repl
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/repl'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/repl'>
Making dvi in DiskIO
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
Making dvi in AIO
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/AIO'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/AIO'>
Making dvi in Blocking
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Blocking'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Blocking'>
Making dvi in DiskDaemon
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskDaemon'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskDaemon'>
Making dvi in DiskThreads
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskThreads'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/DiskThreads'>
Making dvi in IpcIo
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/IpcIo'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/IpcIo'>
Making dvi in Mmapped
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Mmapped'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO/Mmapped'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/DiskIO'>
Making dvi in auth
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
Making dvi in basic
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/basic'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/basic'>
Making dvi in digest
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/digest'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/digest'>
Making dvi in negotiate
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/negotiate'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/negotiate'>
Making dvi in ntlm
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/ntlm'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth/ntlm'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/auth'>
Making dvi in http
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
Making dvi in one
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http/one'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http/one'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/http'>
Making dvi in ip
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ip'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ip'>
Making dvi in icmp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/icmp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/icmp'>
Making dvi in ident
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ident'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ident'>
Making dvi in log
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/log'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/log'>
Making dvi in ipc
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ipc'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/ipc'>
Making dvi in mgr
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/mgr'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/mgr'>
Making dvi in security
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/security'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/security'>
Making dvi in snmp
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/snmp'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/snmp'>
Making dvi in adaptation
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
Making dvi in icap
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation/icap'>
make[4]: Nothing to be done for 'dvi'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation/icap'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src/adaptation'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
make[3]: Nothing to be done for 'dvi-am'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/src'>
Making dvi in tools
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
Making dvi in helper-mux
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/helper-mux'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/helper-mux'>
Making dvi in purge
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/purge'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/purge'>
Making dvi in squidclient
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[4]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[4]: Nothing to be done for 'dvi-am'.
make[4]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/squidclient'>
Making dvi in systemd
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/systemd'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/systemd'>
Making dvi in sysvinit
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/sysvinit'>
make[3]: Nothing to be done for 'dvi'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools/sysvinit'>
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
make[3]: Nothing to be done for 'dvi-am'.
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/tools'>
Making dvi in test-suite
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/test-suite'>
make[2]: Nothing to be done for 'dvi'.
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/test-suite'>
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[2]: Nothing to be done for 'dvi-am'.
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
make[1]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
Making check in compat
make[2]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
make  testPreCompiler
make[3]: Entering directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
depbase=`echo testPreCompiler.o | sed 's|[^/]*$|.deps/&|;s|\.o$||'`;\
ccache clang++ -DHAVE_CONFIG_H   -I../../.. -I../../../include -I../../../lib -I../../../src -I../include     -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT -g -O2 -std=c++11 -MT testPreCompiler.o -MD -MP -MF $depbase.Tpo -c -o testPreCompiler.o ../../../compat/testPreCompiler.cc &&\
mv -f $depbase.Tpo $depbase.Po
/bin/bash ../libtool  --tag=CXX   --mode=link ccache clang++ -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT -g -O2 -std=c++11  -g -o testPreCompiler testPreCompiler.o  -L/usr/lib/x86_64-linux-gnu -lcppunit -ldl 
libtool: link: ccache clang++ -Werror -Qunused-arguments -Wno-deprecated-register -D_REENTRANT -g -O2 -std=c++11 -g -o testPreCompiler testPreCompiler.o  -L/usr/lib/x86_64-linux-gnu -lcppunit -ldl
testPreCompiler.o:(.rodata._ZTVN7CppUnit10TestCallerI15testPreCompilerEE[_ZTVN7CppUnit10TestCallerI15testPreCompilerEE]+0x40): undefined reference to `CppUnit::TestCase::getName() const'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
Makefile:853: recipe for target 'testPreCompiler' failed
make[3]: *** [testPreCompiler] Error 1
make[3]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
Makefile:1195: recipe for target 'check-am' failed
make[2]: *** [check-am] Error 2
make[2]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub/compat'>
Makefile:579: recipe for target 'check-recursive' failed
make[1]: *** [check-recursive] Error 1
make[1]: Leaving directory '<http://build.squid-cache.org/job/trunk-full-matrix/compiler=clang,label=d-debian-unstable/ws/btlayer-00-default/squid-4.0.1-BZR/_build/sub'>
Makefile:787: recipe for target 'distcheck' failed
make: *** [distcheck] Error 1
buildtest.sh result is 2
BUILD: .././test-suite/buildtests/layer-00-default.opts
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS:  -Werror -Qunused-arguments  -D_REENTRANT
configure: BUILD C++ FLAGS: -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS:  -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT
configure: BUILD Tools C++ FLAGS:  -g -O2 -std=c++11
configure: BUILD LIBRARIES: 
configure: BUILD EXTRA LIBRARIES: -lm -lnsl -lresolv -lcap -lrt -ldl -ldl
configure: BUILD OBJECTS: 
configure: BUILD EXTRA OBJECTS: 
configure: BUILD C FLAGS: 
configure: BUILD EXTRA C FLAGS:  -Werror -Qunused-arguments  -D_REENTRANT
configure: BUILD C++ FLAGS: -g -O2 -std=c++11
configure: BUILD EXTRA C++ FLAGS:  -Werror -Qunused-arguments -Wno-deprecated-register  -D_REENTRANT
configure: BUILD Tools C++ FLAGS:  -g -O2 -std=c++11
checking for egrep... .././test-suite/../configure: line 7182: echo: write error: Broken pipe
checking for fgrep... .././test-suite/../configure: line 8150: echo: write error: Broken pipe
testPreCompiler.o:(.rodata._ZTVN7CppUnit10TestCallerI15testPreCompilerEE[_ZTVN7CppUnit10TestCallerI15testPreCompilerEE]+0x40): undefined reference to `CppUnit::TestCase::getName() const'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[3]: *** [testPreCompiler] Error 1
make[2]: *** [check-am] Error 2
make[1]: *** [check-recursive] Error 1
make: *** [distcheck] Error 1
Build FAILED.
Build step 'Execute shell' marked build as failure
[description-setter] Description set: 

From noc at squid-cache.org  Sat Oct 31 03:40:07 2015
From: noc at squid-cache.org (noc at squid-cache.org)
Date: Sat, 31 Oct 2015 03:40:07 +0000 (UTC)
Subject: [squid-dev] Build failed in Jenkins: trunk-polygraph #906
Message-ID: <1142699719.20.1446262808713.JavaMail.jenkins@buildmaster>

See <http://build.squid-cache.org/job/trunk-polygraph/906/>

------------------------------------------
Started by upstream project "trunk-matrix" build number 407
originally caused by:
 Started by an SCM change
Building remotely on polygraph (12.04 amd64-Ubuntu Ubuntu amd64-Ubuntu-12.04 Ubuntu-12.04 amd64) in workspace <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Cleaning workspace...
$ bzr checkout --lightweight http://bzr.squid-cache.org/bzr/squid3/trunk/ <http://build.squid-cache.org/job/trunk-polygraph/ws/>
Getting local revision...
$ bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/>
info result: bzr revision-info -d <http://build.squid-cache.org/job/trunk-polygraph/ws/> returned 0. Command output: "14374 rousskov at measurement-factory.com-20151030203857-5o64s2fvsekeju7p
" stderr: ""
RevisionState revno:14374 revid:rousskov at measurement-factory.com-20151030203857-5o64s2fvsekeju7p
[trunk-polygraph] $ /bin/sh -xe /tmp/hudson3823145089219662399.sh
+ cd /home/jenkins/squidperf
+ python SquidBasicPerf.py --audited http://build.squid-cache.org/job/trunk-polygraph/830/artifact/logs/test.lx --jjid 906 --svnurl http://bzr.squid-cache.org/bzr/squid3/trunk/ --jobname trunk-polygraph
Test is failed
Build step 'Execute shell' marked build as failure
Archiving artifacts
[description-setter] Could not determine description.

