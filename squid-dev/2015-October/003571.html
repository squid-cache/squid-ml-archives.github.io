<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] crypto-ng: CA support for GnuTLS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20crypto-ng%3A%20CA%20support%20for%20GnuTLS&In-Reply-To=%3C560F9557.9040308%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003596.html">
   <LINK REL="Next"  HREF="003591.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] crypto-ng: CA support for GnuTLS</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20crypto-ng%3A%20CA%20support%20for%20GnuTLS&In-Reply-To=%3C560F9557.9040308%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] crypto-ng: CA support for GnuTLS">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Oct  3 08:44:07 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003596.html">[squid-dev] [PATCH] external_acl_type logformat tokens
</A></li>
        <LI>Next message: <A HREF="003591.html">[squid-dev] [PATCH] crypto-ng: CA support for GnuTLS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3571">[ date ]</a>
              <a href="thread.html#3571">[ thread ]</a>
              <a href="subject.html#3571">[ subject ]</a>
              <a href="author.html#3571">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Shuffle the cafile= context logics to libsecurity class PeerOptions.

* Rename the parameter tls-cafile= and allow multiple cafile= entries to
be used in squid.conf.

* Document the capath= option as only supported by OpenSSL and LibreSSL.

* Add GnuTLS support for CA loading.
 Although at this point GnuTLS contexts are not yet created.

Amos

-------------- next part --------------
=== modified file 'doc/release-notes/release-4.sgml'
--- doc/release-notes/release-4.sgml	2015-08-26 13:53:33 +0000
+++ doc/release-notes/release-4.sgml	2015-10-03 05:29:50 +0000
@@ -157,70 +157,73 @@
 	&lt;tag&gt;url_rewrite_timeout&lt;/tag&gt;
 	&lt;p&gt;Squid times active requests to redirector. This option sets
 	   the timeout value and the Squid reaction to a timed out
 	   request.
 
 &lt;/descrip&gt;
 
 &lt;sect1&gt;Changes to existing tags&lt;label id=&quot;modifiedtags&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
 	&lt;tag&gt;auth_param&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 	&lt;tag&gt;cache_peer&lt;/tag&gt;
 	&lt;p&gt;New option &lt;em&gt;tls-min-version=1.N&lt;/em&gt; to set minimum TLS version allowed.
 	&lt;p&gt;All &lt;em&gt;ssloptions=&lt;/em&gt; values for SSLv2 configuration or disabling
 	   have been removed.
 	&lt;p&gt;Removed &lt;em&gt;sslversion=&lt;/em&gt; option. Use &lt;em&gt;tls-options=&lt;/em&gt; instead.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.
+	&lt;p&gt;Replaced &lt;em&gt;sslcafile=&lt;/em&gt; with &lt;em&gt;tls-cafile=&lt;/em&gt; which takes multiple entries.
 
 	&lt;tag&gt;external_acl_type&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 	&lt;tag&gt;http_port&lt;/tag&gt;
 	&lt;p&gt;New option &lt;em&gt;tls-min-version=1.N&lt;/em&gt; to set minimum TLS version allowed.
 	&lt;p&gt;All &lt;em&gt;option=&lt;/em&gt; values for SSLv2 configuration or disabling
 	   have been removed.
 	&lt;p&gt;Removed &lt;em&gt;version=&lt;/em&gt; option. Use &lt;em&gt;tls-options=&lt;/em&gt; instead.
 	&lt;p&gt;New &lt;em&gt;options=SINGLE_ECDH_USE&lt;/em&gt; parameter to enable ephemeral
 	   ECDH key exchange.
 	&lt;p&gt;Deprecated &lt;em&gt;dhparams=&lt;/em&gt; option. Use &lt;em&gt;tls-dh=&lt;/em&gt; instead.
 	   The new option allows to optionally specify an elliptic curve for
 	   ephemeral ECDH by adding &lt;em&gt;curve-name:&lt;/em&gt; in front of the
 	   parameter file name.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.
+	&lt;p&gt;Replaced &lt;em&gt;cafile=&lt;/em&gt; with &lt;em&gt;tls-cafile=&lt;/em&gt; which takes multiple entries.
 
 	&lt;tag&gt;https_port&lt;/tag&gt;
 	&lt;p&gt;New option &lt;em&gt;tls-min-version=1.N&lt;/em&gt; to set minimum TLS version allowed.
 	&lt;p&gt;All &lt;em&gt;options=&lt;/em&gt; values for SSLv2
 	   configuration or disabling have been removed.
 	&lt;p&gt;Removed &lt;em&gt;version=&lt;/em&gt; option. Use &lt;em&gt;tls-options=&lt;/em&gt; instead.
 	&lt;p&gt;New &lt;em&gt;options=SINGLE_ECDH_USE&lt;/em&gt; parameter to enable ephemeral
 	   ECDH key exchange.
 	&lt;p&gt;Deprecated &lt;em&gt;dhparams=&lt;/em&gt; option. Use &lt;em&gt;tls-dh=&lt;/em&gt; instead.
 	   The new option allows to optionally specify an elliptic curve for
 	   ephemeral ECDH by adding &lt;em&gt;curve-name:&lt;/em&gt; in front of the
 	   parameter file name.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.
+	&lt;p&gt;Replaced &lt;em&gt;cafile=&lt;/em&gt; with &lt;em&gt;tls-cafile=&lt;/em&gt; which takes multiple entries.
 
 	&lt;tag&gt;icap_service&lt;/tag&gt;
 	&lt;p&gt;New scheme &lt;em&gt;<A HREF="icaps://&lt;/em">icaps://&lt;/em</A>&gt; to enable TLS/SSL connections to Secure ICAP
 	   servers on port 11344.
 	&lt;p&gt;New &lt;em&gt;tls-cert=&lt;/em&gt; option to set TLS client certificate to use.
 	&lt;p&gt;New &lt;em&gt;tls-key=&lt;/em&gt; option to set TLS private key matching the client
 	   certificate used.
 	&lt;p&gt;New &lt;em&gt;tls-min-version=1.N&lt;/em&gt; option to set minimum TLS version allowed
 	   on server connections.
 	&lt;p&gt;New &lt;em&gt;tls-options=&lt;/em&gt; option to set OpenSSL library parameters.
 	&lt;p&gt;New &lt;em&gt;tls-flags=&lt;/em&gt; option to set flags modifying Squid TLS operations.
 	&lt;p&gt;New &lt;em&gt;tls-cipher=&lt;/em&gt; option to set a list of ciphers permitted.
 	&lt;p&gt;New &lt;em&gt;tls-cafile=&lt;/em&gt; option to set a file with additional CA
 	   certificate(s) to verify the server certificate.
 	&lt;p&gt;New &lt;em&gt;tls-crlfile=&lt;/em&gt; option to set a file with a CRL to verify the
 	   server certificate.
 	&lt;p&gt;New &lt;em&gt;tls-domain=&lt;/em&gt; option to verify the server certificate domain.
 
 	&lt;tag&gt;refresh_pattern&lt;/tag&gt;
 	&lt;p&gt;Removed &lt;em&gt;ignore-auth&lt;/em&gt;. Its commonly desired behaviour is
@@ -239,40 +242,41 @@
 	&lt;tag&gt;url_rewrite_children&lt;/tag&gt;
 	&lt;p&gt;New parameter &lt;em&gt;queue-size=&lt;/em&gt; to set the maximum number
 	   of queued requests.
 
 &lt;/descrip&gt;
 
 &lt;sect1&gt;Removed tags&lt;label id=&quot;removedtags&quot;&gt;
 &lt;p&gt;
 &lt;descrip&gt;
 	&lt;tag&gt;cache_peer_domain&lt;/tag&gt;
 	&lt;p&gt;Superceded by &lt;em&gt;cache_peer_access&lt;/em&gt;. Use dstdomain ACL
 	   in the access control list to restrict domains requested.
 
 	&lt;tag&gt;refresh_pattern&lt;/tag&gt;
 	&lt;p&gt;Option &lt;em&gt;ignore-auth&lt;/em&gt; removed. Its original intent was
 	   to improve caching. HTTP/1.1 permits caching of authenticated
 	   messages under conditions which Squid does check for and obey.
 
 	&lt;tag&gt;sslproxy_cafile&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options cafile=&lt;/em&gt;.
+	   Which now takes multiple entries.
 
 	&lt;tag&gt;sslproxy_capath&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options capath=&lt;/em&gt;.
 
 	&lt;tag&gt;sslproxy_cipher&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options cipher=&lt;/em&gt;.
 
 	&lt;tag&gt;sslproxy_client_certificate&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options cert=&lt;/em&gt;.
 
 	&lt;tag&gt;sslproxy_client_key&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options key=&lt;/em&gt;.
 
 	&lt;tag&gt;sslproxy_flags&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options flags=&lt;/em&gt;.
 
 	&lt;tag&gt;sslproxy_options&lt;/tag&gt;
 	&lt;p&gt;Replaced by &lt;em&gt;tls_outgoing_options options=&lt;/em&gt;.
 	&lt;p&gt;All values for SSLv2 configuration or disabling have been removed.
 	&lt;p&gt;Manual squid.conf update may be required on upgrade.

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-09-05 18:52:17 +0000
+++ src/cache_cf.cc	2015-09-30 13:01:19 +0000
@@ -3561,40 +3561,42 @@
                &quot;in &quot; &lt;&lt; cfg_directive &lt;&lt; &quot;. Use 'ssl-bump' instead.&quot;);
         s-&gt;flags.tunnelSslBumping = true;
     } else if (strcmp(token, &quot;ssl-bump&quot;) == 0) {
         s-&gt;flags.tunnelSslBumping = true;
     } else if (strncmp(token, &quot;cert=&quot;, 5) == 0) {
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;key=&quot;, 4) == 0) {
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;version=&quot;, 8) == 0) {
         debugs(3, DBG_PARSE_NOTE(1), &quot;UPGRADE WARNING: '&quot; &lt;&lt; token &lt;&lt; &quot;' is deprecated &quot; &lt;&lt;
                &quot;in &quot; &lt;&lt; cfg_directive &lt;&lt; &quot;. Use 'options=' instead.&quot;);
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;options=&quot;, 8) == 0) {
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;cipher=&quot;, 7) == 0) {
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;clientca=&quot;, 9) == 0) {
         safe_free(s-&gt;clientca);
         s-&gt;clientca = xstrdup(token + 9);
     } else if (strncmp(token, &quot;cafile=&quot;, 7) == 0) {
+        debugs(3, DBG_PARSE_NOTE(1), &quot;UPGRADE WARNING: '&quot; &lt;&lt; token &lt;&lt; &quot;' is deprecated &quot; &lt;&lt;
+               &quot;in &quot; &lt;&lt; cfg_directive &lt;&lt; &quot;. Use 'tls-cafile=' instead.&quot;);
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;capath=&quot;, 7) == 0) {
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;crlfile=&quot;, 8) == 0) {
         s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;dhparams=&quot;, 9) == 0) {
         debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: '&quot; &lt;&lt; token &lt;&lt; &quot;' is deprecated &quot; &lt;&lt;
                &quot;in &quot; &lt;&lt; cfg_directive &lt;&lt; &quot;. Use 'tls-dh=' instead.&quot;);
         safe_free(s-&gt;dhfile);
         s-&gt;dhfile = xstrdup(token + 9);
     } else if (strncmp(token, &quot;tls-dh=&quot;, 7) == 0) {
         safe_free(s-&gt;tls_dh);
         s-&gt;tls_dh = xstrdup(token + 7);
     } else if (strncmp(token, &quot;sslflags=&quot;, 9) == 0) {
         s-&gt;secure.parse(token+3);
     } else if (strncmp(token, &quot;sslcontext=&quot;, 11) == 0) {
         safe_free(s-&gt;sslContextSessionId);
         s-&gt;sslContextSessionId = xstrdup(token + 11);
     } else if (strcmp(token, &quot;generate-host-certificates&quot;) == 0) {
         s-&gt;generateHostCertificates = true;
@@ -3642,40 +3644,47 @@
         self_destruct();
         return;
     }
 
     char *token = ConfigParser::NextToken();
 
     if (!token) {
         self_destruct();
         return;
     }
 
     AnyP::PortCfgPointer s = new AnyP::PortCfg();
     s-&gt;transport = parsePortProtocol(protoName); // default; protocol=... overwrites
     parsePortSpecification(s, token);
 
     /* parse options ... */
     while ((token = ConfigParser::NextToken())) {
         parse_port_option(s, token);
     }
 
+#if USE_OPENSSL
+    // if clientca has been defined but not cafile, then use it to verify
+    // but if cafile has been defined, only use that to verify
+    if (s-&gt;clientca &amp;&amp; !s-&gt;secure.caFiles.size())
+        s-&gt;secure.caFiles.emplace_back(SBuf(s-&gt;clientca));
+#endif
+
     if (s-&gt;transport.protocol == AnyP::PROTO_HTTPS) {
         s-&gt;secure.encryptTransport = true;
 #if USE_OPENSSL
         /* ssl-bump on https_port configuration requires either tproxy or intercept, and vice versa */
         const bool hijacked = s-&gt;flags.isIntercepted();
         if (s-&gt;flags.tunnelSslBumping &amp;&amp; !hijacked) {
             debugs(3, DBG_CRITICAL, &quot;FATAL: ssl-bump on https_port requires tproxy/intercept which is missing.&quot;);
             self_destruct();
         }
         if (hijacked &amp;&amp; !s-&gt;flags.tunnelSslBumping) {
             debugs(3, DBG_CRITICAL, &quot;FATAL: tproxy/intercept on https_port requires ssl-bump which is missing.&quot;);
             self_destruct();
         }
 #endif
         if (s-&gt;flags.proxySurrogate) {
             debugs(3,DBG_CRITICAL, &quot;FATAL: https_port: require-proxy-header option is not supported on HTTPS ports.&quot;);
             self_destruct();
         }
     } else if (protoName.cmp(&quot;FTP&quot;) == 0) {
         /* ftp_port does not support ssl-bump */

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-08-30 01:07:47 +0000
+++ src/cf.data.pre	2015-09-30 13:39:34 +0000
@@ -1948,46 +1948,47 @@
 				      The adopted curve should be specified
 				      using the tls-dh option.
 
 			    NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as &quot;harmless&quot; by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 
 	   clientca=	File containing the list of CAs to use when
 			requesting a client certificate.
 
-	   cafile=	File containing additional CA certificates to
-			use when verifying client certificates. If unset
-			clientca will be used.
+	   tls-cafile=	PEM file containing CA certificates to use when verifying
+			client certificates. If not configured clientca will be
+			used. May be repeated to load multiple files.
 
 	   capath=	Directory containing additional CA certificates
 			and CRL lists to use when verifying client certificates.
+			Requires OpenSSL or LibreSSL.
 
 	   crlfile=	File of additional CRL lists to use when verifying
 			the client certificate, in addition to CRLs stored in
 			the capath. Implies VERIFY_CRL flag below.
 
 	   tls-dh=[curve:]file
 			File containing DH parameters for temporary/ephemeral DH key
 			exchanges, optionally prefixed by a curve for ephemeral ECDH
 			key exchanges.
 			See OpenSSL documentation for details on how to create the
 			DH parameter file. Supported curves for ECDH can be listed
 			using the &quot;openssl ecparam -list_curves&quot; command.
 			WARNING: EDH and EECDH ciphers will be silently disabled if
 				 this option is not set.
 
 	   sslflags=	Various flags modifying the use of SSL:
 			    DELAYED_AUTH
 				Don't request client certificates
 				immediately, but wait until acl processing
 				requires a certificate (not yet implemented).
@@ -2132,46 +2133,47 @@
 				      The adopted curve should be specified
 				      using the tls-dh option.
 
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as &quot;harmless&quot; by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 
 	   clientca=	File containing the list of CAs to use when
 			requesting a client certificate.
 
-	   cafile=	File containing additional CA certificates to
-			use when verifying client certificates. If unset
-			clientca will be used.
+	   tls-cafile=	PEM file containing CA certificates to use when verifying
+			client certificates. If not configured clientca will be
+			used. May be repeated to load multiple files.
 
 	   capath=	Directory containing additional CA certificates
 			and CRL lists to use when verifying client certificates.
+			Requires OpenSSL or LibreSSL.
 
 	   crlfile=	File of additional CRL lists to use when verifying
 			the client certificate, in addition to CRLs stored in
 			the capath. Implies VERIFY_CRL flag below.
 
 	   tls-dh=[curve:]file
 			File containing DH parameters for temporary/ephemeral DH key
 			exchanges, optionally prefixed by a curve for ephemeral ECDH
 			key exchanges.
 
 	   sslflags=	Various flags modifying the use of SSL:
 			    DELAYED_AUTH
 				Don't request client certificates
 				immediately, but wait until acl processing
 				requires a certificate (not yet implemented).
 			    NO_DEFAULT_CA
 				Don't use the default CA lists built in
 				to OpenSSL.
 			    NO_SESSION_REUSE
 				Don't allow for session reuse. Each connection
@@ -2630,45 +2632,46 @@
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as &quot;harmless&quot; by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 	
-	cafile=... 	A file containing additional CA certificates to use
-			when verifying the peer certificate.
-	
-	capath=...	A directory containing additional CA certificates to
+	cafile=		PEM file containing CA certificates to use when verifying
+			the peer certificate. May be repeated to load multiple files.
+
+	capath=		A directory containing additional CA certificates to
 			use when verifying the peer certificate.
+			Requires OpenSSL or LibreSSL.
 	
 	crlfile=... 	A certificate revocation list file to use when
 			verifying the peer certificate.
 	
 	flags=...	Specify various flags modifying the TLS implementation:
 	
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 			NO_DEFAULT_CA
 				Don't use the default CA list built in
 				to OpenSSL.
 			DONT_VERIFY_DOMAIN
 				Don't verify the peer certificate
 				matches the server name
 	
 	domain= 	The peer name as advertised in its certificate.
 			Used for verifying the correctness of the received peer
 			certificate. If not specified the peer hostname will be
 			used.
@@ -3367,45 +3370,46 @@
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
 			    SSL_OP_NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
 				      to ambiguous specification in RFC4507.
 
 			    ALL       Enable various bug workarounds
 				      suggested as &quot;harmless&quot; by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list.
 	
-	sslcafile=... 	A file containing additional CA certificates to use
-			when verifying the peer certificate.
+	tls-cafile=	PEM file containing CA certificates to use when verifying
+			the peer certificate. May be repeated to load multiple files.
 	
 	sslcapath=...	A directory containing additional CA certificates to
 			use when verifying the peer certificate.
+			Requires OpenSSL or LibreSSL.
 	
 	sslcrlfile=... 	A certificate revocation list file to use when
 			verifying the peer certificate.
 	
 	sslflags=...	Specify various flags modifying the SSL implementation:
 	
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 
 			NO_DEFAULT_CA
 				Don't use the default CA list built in
 				to OpenSSL.
 
 			DONT_VERIFY_DOMAIN
 				Don't verify the peer certificate
 				matches the server name
 	
 	ssldomain= 	The peer name as advertised in it's certificate.
 			Used for verifying the correctness of the received peer
@@ -8524,48 +8528,50 @@
 
 			    NO_SSLv3    Disallow the use of SSLv3
 
 			    NO_TLSv1    Disallow the use of TLSv1.0
 			    NO_TLSv1_1  Disallow the use of TLSv1.1
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
 			    ALL       Enable various bug workarounds
 				      suggested as &quot;harmless&quot; by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
 			more complete list. Options relevant only to SSLv2 are
 			not supported.
 
-	tls-cafile=...	A PEM file containing additional CA certificates to use
-			when verifying the icap server certificate. Used
-			to specify intermediate CA certificate(s) if not sent
-			by the server. Or the full CA chain for the server
-			when using the NO_DEFAULT_CA flag.
+	tls-cafile=	PEM file containing CA certificates to use when verifying
+			the icap server certificate.
+			Use to specify intermediate CA certificate(s) if not sent
+			by the server. Or the full CA chain for the server when
+			using the NO_DEFAULT_CA flag.
+			May be repeated to load multiple files.
 
 	tls-capath=...	A directory containing additional CA certificates to
 			use when verifying the icap server certificate.
+			Requires OpenSSL or LibreSSL.
 
 	tls-crlfile=...	A certificate revocation list file to use when
 			verifying the icap server certificate.
 
 	tls-flags=...	Specify various flags modifying the Squid TLS implementation:
 
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 			NO_DEFAULT_CA
 				Don't use the default CA list built into
 				OpenSSL.
 			DONT_VERIFY_DOMAIN
 				Don't verify the icap server certificate
 				matches the server name
 
 	tls-domain=	The icap server name as advertised in it's certificate.
 			Used for verifying the correctness of the received icap
 			server certificate. If not specified the icap server
 			hostname extracted from ICAP URI will be used.

=== modified file 'src/security/Context.h'
--- src/security/Context.h	2015-03-21 11:58:32 +0000
+++ src/security/Context.h	2015-10-02 18:51:31 +0000
@@ -10,31 +10,31 @@
 #define SQUID_SRC_SECURITY_CONTEXT_H
 
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 #endif
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_GNUTLS_H
 #include &lt;gnutls/gnutls.h&gt;
 #endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
 typedef SSL_CTX* ContextPointer;
 
 #elif USE_GNUTLS
-typedef gnutls_certificate_credentials_t* ContextPointer;
+typedef gnutls_certificate_credentials_t ContextPointer;
 
 #else
 // use void* so we can check against NULL
 typedef void* ContextPointer;
 #endif
 
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_CONTEXT_H */
 

=== modified file 'src/security/PeerOptions.cc'
--- src/security/PeerOptions.cc	2015-09-24 21:08:23 +0000
+++ src/security/PeerOptions.cc	2015-10-03 04:56:55 +0000
@@ -9,48 +9,48 @@
 #include &quot;squid.h&quot;
 #include &quot;base/Packable.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;fatal.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 #include &quot;Parsing.h&quot;
 #include &quot;security/PeerOptions.h&quot;
 
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 
 Security::PeerOptions Security::ProxyOutgoingConfig;
 
 Security::PeerOptions::PeerOptions(const Security::PeerOptions &amp;p) :
     certFile(p.certFile),
     privateKeyFile(p.privateKeyFile),
     sslOptions(p.sslOptions),
-    caFile(p.caFile),
     caDir(p.caDir),
     crlFile(p.crlFile),
     sslCipher(p.sslCipher),
     sslFlags(p.sslFlags),
     sslDomain(p.sslDomain),
     parsedOptions(p.parsedOptions),
     parsedFlags(p.parsedFlags),
+    caFiles(p.caFiles),
     parsedCrl(p.parsedCrl),
     sslVersion(p.sslVersion),
     encryptTransport(p.encryptTransport)
 {
 }
 
 void
 Security::PeerOptions::parse(const char *token)
 {
     if (!*token) {
         // config says just &quot;ssl&quot; or &quot;tls&quot; (or &quot;tls-&quot;)
         encryptTransport = true;
         return;
     }
 
     if (strncmp(token, &quot;disable&quot;, 7) == 0) {
         clear();
         return;
     }
 
@@ -58,84 +58,88 @@
         certFile = SBuf(token + 5);
         if (privateKeyFile.isEmpty())
             privateKeyFile = certFile;
     } else if (strncmp(token, &quot;key=&quot;, 4) == 0) {
         privateKeyFile = SBuf(token + 4);
         if (certFile.isEmpty()) {
             debugs(3, DBG_PARSE_NOTE(1), &quot;WARNING: cert= option needs to be set before key= is used.&quot;);
             certFile = privateKeyFile;
         }
     } else if (strncmp(token, &quot;version=&quot;, 8) == 0) {
         debugs(0, DBG_PARSE_NOTE(1), &quot;UPGRADE WARNING: SSL version= is deprecated. Use options= to limit protocols instead.&quot;);
         sslVersion = xatoi(token + 8);
     } else if (strncmp(token, &quot;min-version=&quot;, 12) == 0) {
         tlsMinVersion = SBuf(token + 12);
     } else if (strncmp(token, &quot;options=&quot;, 8) == 0) {
         sslOptions = SBuf(token + 8);
         parsedOptions = parseOptions();
     } else if (strncmp(token, &quot;cipher=&quot;, 7) == 0) {
         sslCipher = SBuf(token + 7);
     } else if (strncmp(token, &quot;cafile=&quot;, 7) == 0) {
-        caFile = SBuf(token + 7);
+        caFiles.emplace_back(SBuf(token + 7));
     } else if (strncmp(token, &quot;capath=&quot;, 7) == 0) {
         caDir = SBuf(token + 7);
+#if !USE_OPENSSL
+        debugs(3, DBG_PARSE_NOTE(1), &quot;WARNING: capath= option requires --with-openssl.&quot;);
+#endif
     } else if (strncmp(token, &quot;crlfile=&quot;, 8) == 0) {
         crlFile = SBuf(token + 8);
         loadCrlFile();
     } else if (strncmp(token, &quot;flags=&quot;, 6) == 0) {
         if (parsedFlags != 0) {
             debugs(3, DBG_PARSE_NOTE(1), &quot;WARNING: Overwriting flags=&quot; &lt;&lt; sslFlags &lt;&lt; &quot; with &quot; &lt;&lt; SBuf(token + 6));
         }
         sslFlags = SBuf(token + 6);
         parsedFlags = parseFlags();
     } else if (strncmp(token, &quot;domain=&quot;, 7) == 0) {
         sslDomain = SBuf(token + 7);
     } else {
         debugs(3, DBG_CRITICAL, &quot;ERROR: Unknown TLS option '&quot; &lt;&lt; token &lt;&lt; &quot;'&quot;);
         return;
     }
 
     encryptTransport = true;
 }
 
 void
 Security::PeerOptions::dumpCfg(Packable *p, const char *pfx) const
 {
     if (!encryptTransport) {
         p-&gt;appendf(&quot; %sdisable&quot;, pfx);
         return; // no other settings are relevant
     }
 
     if (!certFile.isEmpty())
         p-&gt;appendf(&quot; %scert=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(certFile));
 
     if (!privateKeyFile.isEmpty() &amp;&amp; privateKeyFile != certFile)
         p-&gt;appendf(&quot; %skey=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(privateKeyFile));
 
     if (!sslOptions.isEmpty())
         p-&gt;appendf(&quot; %soptions=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslOptions));
 
     if (!sslCipher.isEmpty())
         p-&gt;appendf(&quot; %scipher=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslCipher));
 
-    if (!caFile.isEmpty())
-        p-&gt;appendf(&quot; %scafile=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(caFile));
+    for (auto i : caFiles) {
+        p-&gt;appendf(&quot; %scafile=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(i));
+    }
 
     if (!caDir.isEmpty())
         p-&gt;appendf(&quot; %scapath=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(caDir));
 
     if (!crlFile.isEmpty())
         p-&gt;appendf(&quot; %scrlfile=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(crlFile));
 
     if (!sslFlags.isEmpty())
         p-&gt;appendf(&quot; %sflags=&quot; SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(sslFlags));
 }
 
 void
 Security::PeerOptions::updateTlsVersionLimits()
 {
     if (!tlsMinVersion.isEmpty()) {
         ::Parser::Tokenizer tok(tlsMinVersion);
         int64_t v = 0;
         if (tok.skip('1') &amp;&amp; tok.skip('.') &amp;&amp; tok.int64(v, 10, false, 1) &amp;&amp; v &lt;= 3) {
             // only account for TLS here - SSL versions are handled by options= parameter
             // avoid affecting options= parameter in cachemgr config report
@@ -174,51 +178,54 @@
             break;
         case 6:
             add = &quot;NO_SSLv3,NO_TLSv1,NO_TLSv1_1&quot;;
             break;
         default: // nothing
             break;
         }
         if (add) {
             if (!sslOptions.isEmpty())
                 sslOptions.append(&quot;,&quot;,1);
             sslOptions.append(add, strlen(add));
         }
         sslVersion = 0; // prevent sslOptions being repeatedly appended
     }
 }
 
 // XXX: make a GnuTLS variant
 Security::ContextPointer
 Security::PeerOptions::createClientContext(bool setOptions)
 {
-    Security::ContextPointer t = NULL;
+    Security::ContextPointer t = nullptr;
 
     updateTlsVersionLimits();
+
 #if USE_OPENSSL
     // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
     t = sslCreateClientContext(certFile.c_str(), privateKeyFile.c_str(), sslCipher.c_str(),
-                               (setOptions ? parsedOptions : 0), parsedFlags,
-                               caFile.c_str(), caDir.c_str());
+                               (setOptions ? parsedOptions : 0), parsedFlags);
 #endif
 
-    updateContextCrl(t);
+    if (t) {
+        updateContextCa(t);
+        updateContextCrl(t);
+    }
 
     return t;
 }
 
 /// set of options we can parse and what they map to
 static struct ssl_option {
     const char *name;
     long value;
 
 } ssl_options[] = {
 
 #if SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
     {
         &quot;NETSCAPE_REUSE_CIPHER_CHANGE_BUG&quot;, SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
     },
 #endif
 #if SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
     {
         &quot;SSLREF2_REUSE_CERT_TYPE_BUG&quot;, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
     },
@@ -459,40 +466,74 @@
 {
     parsedCrl.clear();
     if (crlFile.isEmpty())
         return;
 
 #if USE_OPENSSL
     BIO *in = BIO_new_file(crlFile.c_str(), &quot;r&quot;);
     if (!in) {
         debugs(83, 2, &quot;WARNING: Failed to open CRL file &quot; &lt;&lt; crlFile);
         return;
     }
 
     while (X509_CRL *crl = PEM_read_bio_X509_CRL(in,NULL,NULL,NULL)) {
         parsedCrl.emplace_back(Security::CrlPointer(crl));
     }
     BIO_free(in);
 #endif
 }
 
 void
+Security::PeerOptions::updateContextCa(Security::ContextPointer &amp;ctx)
+{
+    debugs(83, 8, &quot;Setting CA certificate locations.&quot;);
+
+    for (auto i : caFiles) {
+#if USE_OPENSSL
+        if (!SSL_CTX_load_verify_locations(ctx, i.c_str(), caDir.c_str())) {
+            const int ssl_error = ERR_get_error();
+            debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate locations: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
+        }
+#elif USE_GNUTLS
+        if (gnutls_certificate_set_x509_trust_file(ctx, i.c_str(), GNUTLS_X509_FMT_PEM) &lt; 0) {
+            debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate location: &quot; &lt;&lt; i);
+        }
+#endif
+    }
+
+    if ((parsedFlags &amp; SSL_FLAG_NO_DEFAULT_CA))
+        return;
+
+#if USE_OPENSSL
+    if (!SSL_CTX_set_default_verify_paths(ctx)) {
+        const int ssl_error = ERR_get_error();
+        debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting default trusted CA : &quot;
+               &lt;&lt; ERR_error_string(ssl_error, NULL));
+    }
+#elif USE_GNUTLS
+    if (gnutls_certificate_set_x509_system_trust(ctx) != GNUTLS_E_SUCCESS) {
+        debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting default trusted CA.&quot;);
+    }
+#endif
+}
+
+void
 Security::PeerOptions::updateContextCrl(Security::ContextPointer &amp;ctx)
 {
 #if USE_OPENSSL
     bool verifyCrl = false;
     X509_STORE *st = SSL_CTX_get_cert_store(ctx);
     if (parsedCrl.size()) {
         for (auto &amp;i : parsedCrl) {
             if (!X509_STORE_add_crl(st, i.get()))
                 debugs(83, 2, &quot;WARNING: Failed to add CRL&quot;);
             else
                 verifyCrl = true;
         }
     }
 
 #if X509_V_FLAG_CRL_CHECK
     if ((parsedFlags &amp; SSL_FLAG_VERIFY_CRL_ALL))
         X509_STORE_set_flags(st, X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
     else if (verifyCrl || (parsedFlags &amp; SSL_FLAG_VERIFY_CRL))
         X509_STORE_set_flags(st, X509_V_FLAG_CRL_CHECK);
 #endif

=== modified file 'src/security/PeerOptions.h'
--- src/security/PeerOptions.h	2015-09-24 21:08:23 +0000
+++ src/security/PeerOptions.h	2015-09-30 13:53:12 +0000
@@ -20,68 +20,71 @@
 
 /// TLS squid.conf settings for a remote server peer
 class PeerOptions
 {
 public:
     PeerOptions() : parsedOptions(0), parsedFlags(0), sslVersion(0), encryptTransport(false) {}
     PeerOptions(const PeerOptions &amp;);
 
     /// parse a TLS squid.conf option
     void parse(const char *);
 
     /// reset the configuration details to default
     void clear() {*this = PeerOptions();}
 
     /// generate a security client-context from these configured options
     Security::ContextPointer createClientContext(bool setOptions);
 
     /// sync the context options with tls-min-version=N configuration
     void updateTlsVersionLimits();
 
+    /// setup the CA details for the given context
+    void updateContextCa(Security::ContextPointer &amp;);
+
     /// setup the CRL details for the given context
     void updateContextCrl(Security::ContextPointer &amp;);
 
     /// output squid.conf syntax with 'pfx' prefix on parameters for the stored settings
     void dumpCfg(Packable *, const char *pfx) const;
 
 private:
     long parseOptions();
     long parseFlags();
     void loadCrlFile();
 
 public:
     SBuf certFile;       ///&lt; path of file containing PEM format X509 certificate
     SBuf privateKeyFile; ///&lt; path of file containing private key in PEM format
     SBuf sslOptions;     ///&lt; library-specific options string
-    SBuf caFile;         ///&lt; path of file containing trusted Certificate Authority
     SBuf caDir;          ///&lt; path of directory containing a set of trusted Certificate Authorities
     SBuf crlFile;        ///&lt; path of file containing Certificate Revoke List
 
     SBuf sslCipher;
     SBuf sslFlags;       ///&lt; flags defining what TLS operations Squid performs
     SBuf sslDomain;
 
     SBuf tlsMinVersion;  ///&lt; version label for minimum TLS version to permit
 
     long parsedOptions; ///&lt; parsed value of sslOptions
     long parsedFlags;   ///&lt; parsed value of sslFlags
 
+    std::list&lt;SBuf&gt; caFiles;  ///&lt; paths of files containing trusted Certificate Authority
     Security::CertRevokeList parsedCrl; ///&lt; CRL to use when verifying the remote end certificate
 
 private:
     int sslVersion;
 
 public:
     /// whether transport encryption (TLS/SSL) is to be used on connections to the peer
     bool encryptTransport;
 };
 
 /// configuration options for DIRECT server access
 extern PeerOptions ProxyOutgoingConfig;
 
 } // namespace Security
 
 // parse the tls_outgoing_options directive
 void parse_securePeerOptions(Security::PeerOptions *);
 #define free_securePeerOptions(x) Security::ProxyOutgoingConfig.clear()
 #define dump_securePeerOptions(e,n,x) do { (e)-&gt;appendf(n); (x).dumpCfg((e),&quot;&quot;); (e)-&gt;append(&quot;\n&quot;,1); } while(false)
 

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2015-09-24 21:08:23 +0000
+++ src/ssl/support.cc	2015-09-30 12:26:01 +0000
@@ -559,53 +559,41 @@
         if (!SSL_CTX_set_cipher_list(sslContext, port.secure.sslCipher.c_str())) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, &quot;ERROR: Failed to set SSL cipher suite '&quot; &lt;&lt; port.secure.sslCipher &lt;&lt; &quot;': &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
             return false;
         }
     }
 
     debugs(83, 9, &quot;Setting RSA key generation callback.&quot;);
     SSL_CTX_set_tmp_rsa_callback(sslContext, ssl_temp_rsa_cb);
 
     if (port.eecdhCurve) {
         debugs(83, 9, &quot;Setting Ephemeral ECDH curve to &quot; &lt;&lt; port.eecdhCurve &lt;&lt; &quot;.&quot;);
 
         if (!configureSslEECDH(sslContext, port.eecdhCurve)) {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, &quot;ERROR: Unable to configure Ephemeral ECDH: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
             return false;
         }
     }
 
-    debugs(83, 9, &quot;Setting CA certificate locations.&quot;);
-
-    const char *cafile = port.secure.caFile.isEmpty() ? port.clientca : port.secure.caFile.c_str();
-    if ((cafile || !port.secure.caDir.isEmpty()) &amp;&amp; !SSL_CTX_load_verify_locations(sslContext, cafile, port.secure.caDir.c_str())) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate locations: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
-    }
-
-    if (!(port.secure.parsedFlags &amp; SSL_FLAG_NO_DEFAULT_CA) &amp;&amp;
-            !SSL_CTX_set_default_verify_paths(sslContext)) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting default CA certificate location: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
-    }
+    port.secure.updateContextCa(sslContext);
 
     if (port.clientCA.get()) {
         ERR_clear_error();
         if (STACK_OF(X509_NAME) *clientca = SSL_dup_CA_list(port.clientCA.get())) {
             SSL_CTX_set_client_CA_list(sslContext, clientca);
         } else {
             ssl_error = ERR_get_error();
             debugs(83, DBG_CRITICAL, &quot;ERROR: Failed to dupe the client CA list: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
             return false;
         }
 
         if (port.secure.parsedFlags &amp; SSL_FLAG_DELAYED_AUTH) {
             debugs(83, 9, &quot;Not requesting client certificates until acl processing requires one&quot;);
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
         } else {
             debugs(83, 9, &quot;Requiring client certificates.&quot;);
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
         }
 
         port.secure.updateContextCrl(sslContext);
@@ -695,41 +683,41 @@
         debugs(83, DBG_CRITICAL, &quot;ERROR: Configuring static SSL context&quot;);
         SSL_CTX_free(sslContext);
         return NULL;
     }
 
     return sslContext;
 }
 
 #if defined(TLSEXT_TYPE_next_proto_neg)
 //Dummy next_proto_neg callback
 static int
 ssl_next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg)
 {
     static const unsigned char supported_protos[] = {8, 'h','t','t', 'p', '/', '1', '.', '1'};
     (void)SSL_select_next_proto(out, outlen, in, inlen, supported_protos, sizeof(supported_protos));
     return SSL_TLSEXT_ERR_OK;
 }
 #endif
 
 SSL_CTX *
-sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl, const char *CAfile, const char *CApath)
+sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl)
 {
     ssl_initialize();
 
 #if (OPENSSL_VERSION_NUMBER &gt;= 0x10100000L)
     SSL_CTX *sslContext = SSL_CTX_new(TLS_client_method());
 #else
     SSL_CTX *sslContext = SSL_CTX_new(SSLv23_client_method());
 #endif
 
     if (sslContext == NULL) {
         const int ssl_error = ERR_get_error();
         fatalf(&quot;Failed to allocate SSL context: %s\n&quot;,
                ERR_error_string(ssl_error, NULL));
     }
 
     SSL_CTX_set_options(sslContext, options);
 
 #if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
     SSL_CTX_set_info_callback(sslContext, ssl_info_cb);
 #endif
@@ -765,53 +753,40 @@
         debugs(83, 5, &quot;Comparing private and public SSL keys.&quot;);
 
         if (!SSL_CTX_check_private_key(sslContext)) {
             const int ssl_error = ERR_get_error();
             fatalf(&quot;SSL private key '%s' does not match public key '%s': %s\n&quot;,
                    certfile, keyfile, ERR_error_string(ssl_error, NULL));
         }
     }
 
     debugs(83, 9, &quot;Setting RSA key generation callback.&quot;);
     SSL_CTX_set_tmp_rsa_callback(sslContext, ssl_temp_rsa_cb);
 
     if (fl &amp; SSL_FLAG_DONT_VERIFY_PEER) {
         debugs(83, 2, &quot;NOTICE: Peer certificates are not verified for validity!&quot;);
         SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
     } else {
         debugs(83, 9, &quot;Setting certificate verification callback.&quot;);
         SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
     }
 
-    debugs(83, 9, &quot;Setting CA certificate locations.&quot;);
-
-    if ((*CAfile || *CApath) &amp;&amp; !SSL_CTX_load_verify_locations(sslContext, CAfile, CApath)) {
-        const int ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting CA certificate locations: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
-    }
-
-    if (!(fl &amp; SSL_FLAG_NO_DEFAULT_CA) &amp;&amp;
-            !SSL_CTX_set_default_verify_paths(sslContext)) {
-        const int ssl_error = ERR_get_error();
-        debugs(83, DBG_IMPORTANT, &quot;WARNING: Ignoring error setting default CA certificate location: &quot; &lt;&lt; ERR_error_string(ssl_error, NULL));
-    }
-
 #if defined(TLSEXT_TYPE_next_proto_neg)
     SSL_CTX_set_next_proto_select_cb(sslContext, &amp;ssl_next_proto_cb, NULL);
 #endif
     return sslContext;
 }
 
 /// \ingroup ServerProtocolSSLInternal
 int
 ssl_read_method(int fd, char *buf, int len)
 {
     SSL *ssl = fd_table[fd].ssl;
     int i;
 
 #if DONT_DO_THIS
 
     if (!SSL_is_init_finished(ssl)) {
         errno = ENOTCONN;
         return -1;
     }
 

=== modified file 'src/ssl/support.h'
--- src/ssl/support.h	2015-09-24 21:08:23 +0000
+++ src/ssl/support.h	2015-09-30 12:20:20 +0000
@@ -73,41 +73,41 @@
 {
 public:
     ssl_error_t code; ///&lt; certificate error code
     Security::CertPointer cert; ///&lt; certificate with the above error code
     CertError(ssl_error_t anErr, X509 *aCert);
     CertError(CertError const &amp;err);
     CertError &amp; operator = (const CertError &amp;old);
     bool operator == (const CertError &amp;ce) const;
     bool operator != (const CertError &amp;ce) const;
 };
 
 /// Holds a list of certificate SSL errors
 typedef CbDataList&lt;Ssl::CertError&gt; CertErrors;
 
 } //namespace Ssl
 
 /// \ingroup ServerProtocolSSLAPI
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &amp;port);
 
 /// \ingroup ServerProtocolSSLAPI
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags, const char *CAfile, const char *CApath);
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags);
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_read_method(int, char *, int);
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_write_method(int, const char *, int);
 
 /// \ingroup ServerProtocolSSLAPI
 void ssl_shutdown_method(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserEmail(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name);
 
 /// \ingroup ServerProtocolSSLAPI

=== modified file 'src/tests/stub_libsecurity.cc'
--- src/tests/stub_libsecurity.cc	2015-09-24 21:08:23 +0000
+++ src/tests/stub_libsecurity.cc	2015-09-30 12:21:00 +0000
@@ -4,26 +4,27 @@
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;comm/Connection.h&quot;
 
 #define STUB_API &quot;security/libsecurity.la&quot;
 #include &quot;tests/STUB.h&quot;
 
 #include &quot;security/EncryptorAnswer.h&quot;
 Security::EncryptorAnswer::~EncryptorAnswer() {}
 std::ostream &amp;Security::operator &lt;&lt;(std::ostream &amp;os, const Security::EncryptorAnswer &amp;) STUB_RETVAL(os)
 
 #include &quot;security/PeerOptions.h&quot;
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
 Security::ContextPointer Security::PeerOptions::createClientContext(bool) STUB_RETVAL(NULL)
 void Security::PeerOptions::updateTlsVersionLimits() STUB
+void Security::PeerOptions::updateContextCa(Security::ContextPointer &amp;) STUB
 void Security::PeerOptions::updateContextCrl(Security::ContextPointer &amp;) STUB
 void Security::PeerOptions::dumpCfg(Packable*, char const*) const STUB
 long Security::PeerOptions::parseOptions() STUB_RETVAL(0)
 long Security::PeerOptions::parseFlags() STUB_RETVAL(0)
 void parse_securePeerOptions(Security::PeerOptions *) STUB
 

=== modified file 'src/tests/stub_libsslsquid.cc'
--- src/tests/stub_libsslsquid.cc	2015-09-24 21:08:23 +0000
+++ src/tests/stub_libsslsquid.cc	2015-09-30 12:20:45 +0000
@@ -40,41 +40,41 @@
 void Ssl::GlobalContextStorage::reconfigureStart() STUB
 //Ssl::GlobalContextStorage Ssl::TheGlobalContextStorage;
 
 #include &quot;ssl/ErrorDetail.h&quot;
 Ssl::ssl_error_t parseErrorString(const char *name) STUB_RETVAL(0)
 //const char *Ssl::getErrorName(ssl_error_t value) STUB_RETVAL(NULL)
 Ssl::ErrorDetail::ErrorDetail(ssl_error_t err_no, X509 *, X509 *, const char *) STUB
 Ssl::ErrorDetail::ErrorDetail(ErrorDetail const &amp;) STUB
 const String &amp; Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 
 #include &quot;ssl/support.h&quot;
 namespace Ssl
 {
 //CertError::CertError(ssl_error_t anErr, X509 *aCert) STUB
 //CertError::CertError(CertError const &amp;err) STUB
 CertError &amp; CertError::operator = (const CertError &amp;old) STUB_RETVAL(*this)
 bool CertError::operator == (const CertError &amp;ce) const STUB_RETVAL(false)
 bool CertError::operator != (const CertError &amp;ce) const STUB_RETVAL(false)
 } // namespace Ssl
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &amp;port) STUB_RETVAL(NULL)
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags, const char *CAfile, const char *CApath) STUB_RETVAL(NULL)
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
 void ssl_shutdown_method(SSL *ssl) STUB
 const char *sslGetUserEmail(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
 const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
 const char *sslGetUserCertificatePEM(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserCertificateChainPEM(SSL *ssl) STUB_RETVAL(NULL)
 namespace Ssl
 {
 //GETX509ATTRIBUTE GetX509UserAttribute;
 //GETX509ATTRIBUTE GetX509CAAttribute;
 //GETX509ATTRIBUTE GetX509Fingerprint;
 const char *BumpModeStr[] = {&quot;&quot;};
 DH *readDHParams(const char *dhfile) STUB_RETVAL(NULL)
 bool generateUntrustedCert(Security::CertPointer &amp; untrustedCert, EVP_PKEY_Pointer &amp; untrustedPkey, Security::CertPointer const &amp; cert, EVP_PKEY_Pointer const &amp; pkey) STUB_RETVAL(false)
 SSL_CTX * generateSslContext(CertificateProperties const &amp;properties, AnyP::PortCfg &amp;port) STUB_RETVAL(NULL)
 bool verifySslCertificate(SSL_CTX * sslContext,  CertificateProperties const &amp;properties) STUB_RETVAL(false)
 SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &amp;port) STUB_RETVAL(NULL)
 void addChainToSslContext(SSL_CTX *sslContext, STACK_OF(X509) *certList) STUB

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003596.html">[squid-dev] [PATCH] external_acl_type logformat tokens
</A></li>
	<LI>Next message: <A HREF="003591.html">[squid-dev] [PATCH] crypto-ng: CA support for GnuTLS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3571">[ date ]</a>
              <a href="thread.html#3571">[ thread ]</a>
              <a href="subject.html#3571">[ subject ]</a>
              <a href="author.html#3571">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
