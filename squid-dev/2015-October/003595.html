<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] remove HttpsPortList
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20remove%20HttpsPortList&In-Reply-To=%3C5619F0E5.3010101%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003594.html">
   <LINK REL="Next"  HREF="003598.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] remove HttpsPortList</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20remove%20HttpsPortList&In-Reply-To=%3C5619F0E5.3010101%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] remove HttpsPortList">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Oct 11 05:17:25 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003594.html">[squid-dev] Jenkins build is back to normal : trunk-polygraph #887
</A></li>
        <LI>Next message: <A HREF="003598.html">[squid-dev] Build failed in Jenkins: trunk-polygraph #889
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3595">[ date ]</a>
              <a href="thread.html#3595">[ thread ]</a>
              <a href="subject.html#3595">[ subject ]</a>
              <a href="author.html#3595">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Combine the https_port list internal state with http_port state.
These two lists have been near identical for some time now and we can
easily reduce code by simply merging the two and using either the
secure.encryptTransport flag or the transport.protocol type to select
the remaining non-identical code paths.

There are only minor documentation changes resulting from this change.

Amos

-------------- next part --------------
=== modified file 'src/anyp/PortCfg.cc'
--- src/anyp/PortCfg.cc	2015-09-24 21:08:23 +0000
+++ src/anyp/PortCfg.cc	2015-10-10 06:35:15 +0000
@@ -2,43 +2,40 @@
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;fatal.h&quot;
 #include &quot;security/PeerOptions.h&quot;
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 
 #include &lt;cstring&gt;
 #include &lt;limits&gt;
 
 AnyP::PortCfgPointer HttpPortList;
-#if USE_OPENSSL
-AnyP::PortCfgPointer HttpsPortList;
-#endif
 AnyP::PortCfgPointer FtpPortList;
 
 int NHttpSockets = 0;
 int HttpSockets[MAXTCPLISTENPORTS];
 
 AnyP::PortCfg::PortCfg() :
     next(),
     s(),
     transport(AnyP::PROTO_HTTP,1,1), // &quot;Squid is an HTTP proxy&quot;, etc.
     name(NULL),
     defaultsite(NULL),
     flags(),
     allow_direct(false),
     vhost(false),
     actAsOrigin(false),
     ignore_cc(false),
     connection_auth_disabled(false),
     ftp_track_dirs(false),
     vport(0),
     disable_pmtu_discovery(0),

=== modified file 'src/anyp/PortCfg.h'
--- src/anyp/PortCfg.h	2015-09-24 21:08:23 +0000
+++ src/anyp/PortCfg.h	2015-10-10 06:37:36 +0000
@@ -78,42 +78,37 @@
     char *tls_dh;
     char *sslContextSessionId; ///&lt; &quot;session id context&quot; for staticSslContext
     bool generateHostCertificates; ///&lt; dynamically make host cert for sslBump
     size_t dynamicCertMemCacheSize; ///&lt; max size of generated certificates memory cache
 
     Ssl::SSL_CTX_Pointer staticSslContext; ///&lt; for HTTPS accelerator or static sslBump
     Security::CertPointer signingCert; ///&lt; x509 certificate for signing generated certificates
     Ssl::EVP_PKEY_Pointer signPkey; ///&lt; private key for sighing generated certificates
     Ssl::X509_STACK_Pointer certsToChain; ///&lt;  x509 certificates to send with the generated cert
     Security::CertPointer untrustedSigningCert; ///&lt; x509 certificate for signing untrusted generated certificates
     Ssl::EVP_PKEY_Pointer untrustedSignPkey; ///&lt; private key for signing untrusted generated certificates
 
     Ssl::X509_NAME_STACK_Pointer clientCA; ///&lt; CA certificates to use when verifying client certificates
     Ssl::DH_Pointer dhParams; ///&lt; DH parameters for temporary/ephemeral DH key exchanges
     char *eecdhCurve; ///&lt; Elliptic curve for ephemeral EC-based DH key exchanges
 #endif
 };
 
 } // namespace AnyP
 
-/// list of Squid http_port configured
+/// list of Squid http(s)_port configured
 extern AnyP::PortCfgPointer HttpPortList;
 
-#if USE_OPENSSL
-/// list of Squid https_port configured
-extern AnyP::PortCfgPointer HttpsPortList;
-#endif
-
 /// list of Squid ftp_port configured
 extern AnyP::PortCfgPointer FtpPortList;
 
 #if !defined(MAXTCPLISTENPORTS)
 // Max number of TCP listening ports
 #define MAXTCPLISTENPORTS 128
 #endif
 
 // TODO: kill this global array. Need to check performance of array vs list though.
 extern int NHttpSockets;
 extern int HttpSockets[MAXTCPLISTENPORTS];
 
 #endif /* SQUID_ANYP_PORTCFG_H */
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-10-09 06:02:01 +0000
+++ src/cache_cf.cc	2015-10-10 06:16:17 +0000
@@ -878,52 +878,45 @@
     }
 
     for (CachePeer *p = Config.peers; p != NULL; p = p-&gt;next) {
 
         // default value for ssldomain= is the peer host/IP
         if (p-&gt;secure.sslDomain.isEmpty())
             p-&gt;secure.sslDomain = p-&gt;host;
 
         if (p-&gt;secure.encryptTransport) {
             debugs(3, DBG_IMPORTANT, &quot;Initializing cache_peer &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; TLS context&quot;);
             p-&gt;sslContext = p-&gt;secure.createClientContext(true);
             if (!p-&gt;sslContext) {
                 debugs(3, DBG_CRITICAL, &quot;ERROR: Could not initialize cache_peer &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; TLS context&quot;);
                 self_destruct();
             }
         }
     }
 
 #if USE_OPENSSL
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
-        if (!s-&gt;flags.tunnelSslBumping)
+        if (!s-&gt;secure.encryptTransport)
             continue;
-
-        debugs(3, DBG_IMPORTANT, &quot;Initializing http_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; SSL context&quot;);
+        debugs(3, DBG_IMPORTANT, &quot;Initializing &quot; &lt;&lt; AnyP::UriScheme(s-&gt;transport.protocol) &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; TLS context&quot;);
         s-&gt;configureSslServerContext();
     }
-
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s-&gt;next) {
-        debugs(3, DBG_IMPORTANT, &quot;Initializing https_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; SSL context&quot;);
-        s-&gt;configureSslServerContext();
-    }
-
 #endif
 
     // prevent infinite fetch loops in the request parser
     // due to buffer full but not enough data recived to finish parse
     if (Config.maxRequestBufferSize &lt;= Config.maxRequestHeaderSize) {
         fatalf(&quot;Client request buffer of %u bytes cannot hold a request with %u bytes of headers.&quot; \
                &quot; Change client_request_buffer_max or request_header_max_size limits.&quot;,
                (uint32_t)Config.maxRequestBufferSize, (uint32_t)Config.maxRequestHeaderSize);
     }
 
     /*
      * Disable client side request pipelining if client_persistent_connections OFF.
      * Waste of resources queueing any pipelined requests when the first will close the connection.
      */
     if (Config.pipeline_max_prefetch &gt; 0 &amp;&amp; !Config.onoff.client_pconns) {
         debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: pipeline_prefetch &quot; &lt;&lt; Config.pipeline_max_prefetch &lt;&lt;
                &quot; requires client_persistent_connections ON. Forced pipeline_prefetch 0.&quot;);
         Config.pipeline_max_prefetch = 0;
     }
 

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-10-10 07:11:39 +0000
+++ src/cf.data.pre	2015-10-10 07:11:59 +0000
@@ -2040,44 +2040,44 @@
 			timeout the time before giving up.
 
 	   require-proxy-header
 			Require PROXY protocol version 1 or 2 connections.
 			The proxy_protocol_access is required to whitelist
 			downstream proxies which can be trusted.
 
 	If you run Squid on a dual-homed machine with an internal
 	and an external interface we recommend you to specify the
 	internal address:port in http_port. This way Squid will only be
 	visible on the internal address.
 
 NOCOMMENT_START
 
 # Squid normally listens to port 3128
 http_port @DEFAULT_HTTP_PORT@
 NOCOMMENT_END
 DOC_END
 
 NAME: https_port
-IFDEF: USE_OPENSSL
+IFDEF: USE_GNUTLS||USE_OPENSSL
 TYPE: PortCfg
 DEFAULT: none
-LOC: HttpsPortList
+LOC: HttpPortList
 DOC_START
 	Usage:  [ip:]port [mode] cert=certificate.pem [options]
 
 	The socket address where Squid will listen for client requests made
 	over TLS or SSL connections. Commonly referred to as HTTPS.
 
 	This is most useful for situations where you are running squid in
 	accelerator mode and you want to do the TLS work at the accelerator level.
 
 	You may specify multiple socket addresses on multiple lines,
 	each with their own certificate and/or options.
 
 	The TLS cert= option is mandatory on HTTPS ports.
 
 	See http_port for a list of modes and options.
 DOC_END
 
 NAME: ftp_port
 TYPE: PortCfg
 DEFAULT: none

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-09-27 10:30:23 +0000
+++ src/client_side.cc	2015-10-11 04:24:59 +0000
@@ -4359,137 +4359,108 @@
     }
     return true;
 }
 
 /// find any unused HttpSockets[] slot and store fd there or return false
 static bool
 AddOpenedHttpSocket(const Comm::ConnectionPointer &amp;conn)
 {
     bool found = false;
     for (int i = 0; i &lt; NHttpSockets &amp;&amp; !found; ++i) {
         if ((found = HttpSockets[i] &lt; 0))
             HttpSockets[i] = conn-&gt;fd;
     }
     return found;
 }
 
 static void
 clientHttpConnectionsOpen(void)
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
+        const char *scheme = AnyP::UriScheme(s-&gt;transport.protocol).c_str();
+
         if (MAXTCPLISTENPORTS == NHttpSockets) {
-            debugs(1, DBG_IMPORTANT, &quot;WARNING: You have too many 'http_port' lines.&quot;);
+            debugs(1, DBG_IMPORTANT, &quot;WARNING: You have too many '&quot; &lt;&lt; scheme &lt;&lt; &quot;_port' lines.&quot;);
             debugs(1, DBG_IMPORTANT, &quot;         The limit is &quot; &lt;&lt; MAXTCPLISTENPORTS &lt;&lt; &quot; HTTP ports.&quot;);
             continue;
         }
 
 #if USE_OPENSSL
-        if (s-&gt;flags.tunnelSslBumping &amp;&amp; !Config.accessList.ssl_bump) {
-            debugs(33, DBG_IMPORTANT, &quot;WARNING: No ssl_bump configured. Disabling ssl-bump on &quot; &lt;&lt; AnyP::UriScheme(s-&gt;transport.protocol) &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s);
-            s-&gt;flags.tunnelSslBumping = false;
-        }
-
-        if (s-&gt;flags.tunnelSslBumping &amp;&amp;
-                !s-&gt;staticSslContext &amp;&amp;
-                !s-&gt;generateHostCertificates) {
-            debugs(1, DBG_IMPORTANT, &quot;Will not bump SSL at http_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to SSL initialization failure.&quot;);
-            s-&gt;flags.tunnelSslBumping = false;
-        }
         if (s-&gt;flags.tunnelSslBumping) {
-            // Create ssl_ctx cache for this port.
-            Ssl::TheGlobalContextStorage.addLocalStorage(s-&gt;s, s-&gt;dynamicCertMemCacheSize == std::numeric_limits&lt;size_t&gt;::max() ? 4194304 : s-&gt;dynamicCertMemCacheSize);
+            if (!Config.accessList.ssl_bump) {
+                debugs(33, DBG_IMPORTANT, &quot;WARNING: No ssl_bump configured. Disabling ssl-bump on &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s);
+                s-&gt;flags.tunnelSslBumping = false;
+            }
+            if (!s-&gt;staticSslContext &amp;&amp; !s-&gt;generateHostCertificates) {
+                debugs(1, DBG_IMPORTANT, &quot;Will not bump SSL at &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to TLS initialization failure.&quot;);
+                s-&gt;flags.tunnelSslBumping = false;
+                if (s-&gt;transport.protocol == AnyP::PROTO_HTTP)
+                    s-&gt;secure.encryptTransport = false;
+            }
+            if (s-&gt;flags.tunnelSslBumping) {
+                // Create ssl_ctx cache for this port.
+                auto sz = s-&gt;dynamicCertMemCacheSize == std::numeric_limits&lt;size_t&gt;::max() ? 4194304 : s-&gt;dynamicCertMemCacheSize;
+                Ssl::TheGlobalContextStorage.addLocalStorage(s-&gt;s, sz);
+            }
         }
 #endif
 
-        // Fill out a Comm::Connection which IPC will open as a listener for us
-        //  then pass back when active so we can start a TcpAcceptor subscription.
-        s-&gt;listenConn = new Comm::Connection;
-        s-&gt;listenConn-&gt;local = s-&gt;s;
-        s-&gt;listenConn-&gt;flags = COMM_NONBLOCKING | (s-&gt;flags.tproxyIntercept ? COMM_TRANSPARENT : 0) | (s-&gt;flags.natIntercept ? COMM_INTERCEPTION : 0);
-
-        // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
-        typedef CommCbFunPtrCallT&lt;CommAcceptCbPtrFun&gt; AcceptCall;
-        RefCount&lt;AcceptCall&gt; subCall = commCbCall(5, 5, &quot;httpAccept&quot;, CommAcceptCbPtrFun(httpAccept, CommAcceptCbParams(NULL)));
-        Subscription::Pointer sub = new CallSubscription&lt;AcceptCall&gt;(subCall);
-
-        AsyncCall::Pointer listenCall = asyncCall(33,2, &quot;clientListenerConnectionOpened&quot;,
-                                        ListeningStartedDialer(&amp;clientListenerConnectionOpened, s, Ipc::fdnHttpSocket, sub));
-        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s-&gt;listenConn, Ipc::fdnHttpSocket, listenCall);
-
-        HttpSockets[NHttpSockets] = -1; // set in clientListenerConnectionOpened
-        ++NHttpSockets;
-    }
-}
-
-#if USE_OPENSSL
-static void
-clientHttpsConnectionsOpen(void)
-{
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s-&gt;next) {
-        if (MAXTCPLISTENPORTS == NHttpSockets) {
-            debugs(1, DBG_IMPORTANT, &quot;Ignoring 'https_port' lines exceeding the limit.&quot;);
-            debugs(1, DBG_IMPORTANT, &quot;The limit is &quot; &lt;&lt; MAXTCPLISTENPORTS &lt;&lt; &quot; HTTPS ports.&quot;);
-            continue;
-        }
-
-        if (!s-&gt;staticSslContext) {
-            debugs(1, DBG_IMPORTANT, &quot;Ignoring https_port &quot; &lt;&lt; s-&gt;s &lt;&lt;
-                   &quot; due to SSL initialization failure.&quot;);
+        if (s-&gt;secure.encryptTransport &amp;&amp; !s-&gt;staticSslContext) {
+            debugs(1, DBG_CRITICAL, &quot;ERROR: Ignoring &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to TLS context initialization failure.&quot;);
             continue;
         }
 
-        // TODO: merge with similar code in clientHttpConnectionsOpen()
-        if (s-&gt;flags.tunnelSslBumping &amp;&amp; !Config.accessList.ssl_bump) {
-            debugs(33, DBG_IMPORTANT, &quot;WARNING: No ssl_bump configured. Disabling ssl-bump on &quot; &lt;&lt; AnyP::UriScheme(s-&gt;transport.protocol) &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s);
-            s-&gt;flags.tunnelSslBumping = false;
-        }
-
-        if (s-&gt;flags.tunnelSslBumping &amp;&amp; !s-&gt;staticSslContext &amp;&amp; !s-&gt;generateHostCertificates) {
-            debugs(1, DBG_IMPORTANT, &quot;Will not bump SSL at https_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to SSL initialization failure.&quot;);
-            s-&gt;flags.tunnelSslBumping = false;
-        }
-
-        if (s-&gt;flags.tunnelSslBumping) {
-            // Create ssl_ctx cache for this port.
-            Ssl::TheGlobalContextStorage.addLocalStorage(s-&gt;s, s-&gt;dynamicCertMemCacheSize == std::numeric_limits&lt;size_t&gt;::max() ? 4194304 : s-&gt;dynamicCertMemCacheSize);
-        }
-
         // Fill out a Comm::Connection which IPC will open as a listener for us
+        //  then pass back when active so we can start a TcpAcceptor subscription.
         s-&gt;listenConn = new Comm::Connection;
         s-&gt;listenConn-&gt;local = s-&gt;s;
+
         s-&gt;listenConn-&gt;flags = COMM_NONBLOCKING | (s-&gt;flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
                                (s-&gt;flags.natIntercept ? COMM_INTERCEPTION : 0);
 
-        // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
         typedef CommCbFunPtrCallT&lt;CommAcceptCbPtrFun&gt; AcceptCall;
-        RefCount&lt;AcceptCall&gt; subCall = commCbCall(5, 5, &quot;httpsAccept&quot;, CommAcceptCbPtrFun(httpsAccept, CommAcceptCbParams(NULL)));
-        Subscription::Pointer sub = new CallSubscription&lt;AcceptCall&gt;(subCall);
+        if (s-&gt;transport.protocol == AnyP::PROTO_HTTP) {
+            // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
+            RefCount&lt;AcceptCall&gt; subCall = commCbCall(5, 5, &quot;httpAccept&quot;, CommAcceptCbPtrFun(httpAccept, CommAcceptCbParams(NULL)));
+            Subscription::Pointer sub = new CallSubscription&lt;AcceptCall&gt;(subCall);
+
+            AsyncCall::Pointer listenCall = asyncCall(33,2, &quot;clientListenerConnectionOpened&quot;,
+                                            ListeningStartedDialer(&amp;clientListenerConnectionOpened, s, Ipc::fdnHttpSocket, sub));
+            Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s-&gt;listenConn, Ipc::fdnHttpSocket, listenCall);
+
+#if USE_OPENSSL
+        } else if (s-&gt;transport.protocol == AnyP::PROTO_HTTPS) {
+            // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
+            RefCount&lt;AcceptCall&gt; subCall = commCbCall(5, 5, &quot;httpsAccept&quot;, CommAcceptCbPtrFun(httpsAccept, CommAcceptCbParams(NULL)));
+            Subscription::Pointer sub = new CallSubscription&lt;AcceptCall&gt;(subCall);
+
+            AsyncCall::Pointer listenCall = asyncCall(33, 2, &quot;clientListenerConnectionOpened&quot;,
+                                            ListeningStartedDialer(&amp;clientListenerConnectionOpened,
+                                                    s, Ipc::fdnHttpsSocket, sub));
+            Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s-&gt;listenConn, Ipc::fdnHttpsSocket, listenCall);
+#endif
+        }
 
-        AsyncCall::Pointer listenCall = asyncCall(33, 2, &quot;clientListenerConnectionOpened&quot;,
-                                        ListeningStartedDialer(&amp;clientListenerConnectionOpened,
-                                                s, Ipc::fdnHttpsSocket, sub));
-        Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s-&gt;listenConn, Ipc::fdnHttpsSocket, listenCall);
-        HttpSockets[NHttpSockets] = -1;
+        HttpSockets[NHttpSockets] = -1; // set in clientListenerConnectionOpened
         ++NHttpSockets;
     }
 }
-#endif
 
 void
 clientStartListeningOn(AnyP::PortCfgPointer &amp;port, const RefCount&lt; CommCbFunPtrCallT&lt;CommAcceptCbPtrFun&gt; &gt; &amp;subCall, const Ipc::FdNoteId fdNote)
 {
     // Fill out a Comm::Connection which IPC will open as a listener for us
     port-&gt;listenConn = new Comm::Connection;
     port-&gt;listenConn-&gt;local = port-&gt;s;
     port-&gt;listenConn-&gt;flags =
         COMM_NONBLOCKING |
         (port-&gt;flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
         (port-&gt;flags.natIntercept ? COMM_INTERCEPTION : 0);
 
     // route new connections to subCall
     typedef CommCbFunPtrCallT&lt;CommAcceptCbPtrFun&gt; AcceptCall;
     Subscription::Pointer sub = new CallSubscription&lt;AcceptCall&gt;(subCall);
     AsyncCall::Pointer listenCall =
         asyncCall(33, 2, &quot;clientListenerConnectionOpened&quot;,
                   ListeningStartedDialer(&amp;clientListenerConnectionOpened,
                                          port, fdNote, sub));
     Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, port-&gt;listenConn, fdNote, listenCall);
@@ -4511,69 +4482,56 @@
     Must(Comm::IsConnOpen(s-&gt;listenConn));
 
     // TCP: setup a job to handle accept() with subscribed handler
     AsyncJob::Start(new Comm::TcpAcceptor(s, FdNote(portTypeNote), sub));
 
     debugs(1, DBG_IMPORTANT, &quot;Accepting &quot; &lt;&lt;
            (s-&gt;flags.natIntercept ? &quot;NAT intercepted &quot; : &quot;&quot;) &lt;&lt;
            (s-&gt;flags.tproxyIntercept ? &quot;TPROXY intercepted &quot; : &quot;&quot;) &lt;&lt;
            (s-&gt;flags.tunnelSslBumping ? &quot;SSL bumped &quot; : &quot;&quot;) &lt;&lt;
            (s-&gt;flags.accelSurrogate ? &quot;reverse-proxy &quot; : &quot;&quot;)
            &lt;&lt; FdNote(portTypeNote) &lt;&lt; &quot; connections at &quot;
            &lt;&lt; s-&gt;listenConn);
 
     Must(AddOpenedHttpSocket(s-&gt;listenConn)); // otherwise, we have received a fd we did not ask for
 }
 
 void
 clientOpenListenSockets(void)
 {
     clientHttpConnectionsOpen();
-#if USE_OPENSSL
-    clientHttpsConnectionsOpen();
-#endif
     Ftp::StartListening();
 
     if (NHttpSockets &lt; 1)
         fatal(&quot;No HTTP, HTTPS, or FTP ports configured&quot;);
 }
 
 void
 clientConnectionsClose()
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
         if (s-&gt;listenConn != NULL) {
-            debugs(1, DBG_IMPORTANT, &quot;Closing HTTP port &quot; &lt;&lt; s-&gt;listenConn-&gt;local);
-            s-&gt;listenConn-&gt;close();
-            s-&gt;listenConn = NULL;
-        }
-    }
-
-#if USE_OPENSSL
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s-&gt;next) {
-        if (s-&gt;listenConn != NULL) {
-            debugs(1, DBG_IMPORTANT, &quot;Closing HTTPS port &quot; &lt;&lt; s-&gt;listenConn-&gt;local);
+            debugs(1, DBG_IMPORTANT, &quot;Closing HTTP(S) port &quot; &lt;&lt; s-&gt;listenConn-&gt;local);
             s-&gt;listenConn-&gt;close();
             s-&gt;listenConn = NULL;
         }
     }
-#endif
 
     Ftp::StopListening();
 
     // TODO see if we can drop HttpSockets array entirely */
     for (int i = 0; i &lt; NHttpSockets; ++i) {
         HttpSockets[i] = -1;
     }
 
     NHttpSockets = 0;
 }
 
 int
 varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
 {
     const char *vary = request-&gt;vary_headers;
     int has_vary = entry-&gt;getReply()-&gt;header.has(Http::HdrType::VARY);
 #if X_ACCELERATOR_VARY
 
     has_vary |=
         entry-&gt;getReply()-&gt;header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY);

=== modified file 'src/ssl/helper.cc'
--- src/ssl/helper.cc	2015-05-18 12:50:03 +0000
+++ src/ssl/helper.cc	2015-10-10 06:35:44 +0000
@@ -29,42 +29,40 @@
 }
 
 Ssl::Helper::Helper() : ssl_crtd(NULL)
 {
 }
 
 Ssl::Helper::~Helper()
 {
     Shutdown();
 }
 
 void Ssl::Helper::Init()
 {
     assert(ssl_crtd == NULL);
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL *and* generate certificates
     // TODO: generate host certificates for SNI enabled accel ports
     bool found = false;
     for (AnyP::PortCfgPointer s = HttpPortList; !found &amp;&amp; s != NULL; s = s-&gt;next)
         found = s-&gt;flags.tunnelSslBumping &amp;&amp; s-&gt;generateHostCertificates;
-    for (AnyP::PortCfgPointer s = HttpsPortList; !found &amp;&amp; s != NULL; s = s-&gt;next)
-        found = s-&gt;flags.tunnelSslBumping &amp;&amp; s-&gt;generateHostCertificates;
     if (!found)
         return;
 
     ssl_crtd = new helper(&quot;ssl_crtd&quot;);
     ssl_crtd-&gt;childs.updateLimits(Ssl::TheConfig.ssl_crtdChildren);
     ssl_crtd-&gt;ipc_type = IPC_STREAM;
     // The crtd messages may contain the eol ('\n') character. We are
     // going to use the '\1' char as the end-of-message mark.
     ssl_crtd-&gt;eom = '\1';
     assert(ssl_crtd-&gt;cmdline == NULL);
     {
         char *tmp = xstrdup(Ssl::TheConfig.ssl_crtd);
         char *tmp_begin = tmp;
         char * token = NULL;
         bool db_path_was_found = false;
         bool block_size_was_found = false;
         char buffer[20] = &quot;2048&quot;;
         while ((token = strwordtok(NULL, &amp;tmp))) {
             wordlistAdd(&amp;ssl_crtd-&gt;cmdline, token);
             if (!strcmp(token, &quot;-b&quot;))
@@ -121,42 +119,40 @@
     return &sslHelper;
 }
 
 Ssl::CertValidationHelper::CertValidationHelper() : ssl_crt_validator(NULL)
 {
 }
 
 Ssl::CertValidationHelper::~CertValidationHelper()
 {
     Shutdown();
 }
 
 void Ssl::CertValidationHelper::Init()
 {
     assert(ssl_crt_validator == NULL);
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL
     bool found = false;
     for (AnyP::PortCfgPointer s = HttpPortList; !found &amp;&amp; s != NULL; s = s-&gt;next)
         found = s-&gt;flags.tunnelSslBumping;
-    for (AnyP::PortCfgPointer s = HttpsPortList; !found &amp;&amp; s != NULL; s = s-&gt;next)
-        found = s-&gt;flags.tunnelSslBumping;
     if (!found)
         return;
 
     ssl_crt_validator = new helper(&quot;ssl_crt_validator&quot;);
     ssl_crt_validator-&gt;childs.updateLimits(Ssl::TheConfig.ssl_crt_validator_Children);
     ssl_crt_validator-&gt;ipc_type = IPC_STREAM;
     // The crtd messages may contain the eol ('\n') character. We are
     // going to use the '\1' char as the end-of-message mark.
     ssl_crt_validator-&gt;eom = '\1';
     assert(ssl_crt_validator-&gt;cmdline == NULL);
 
     int ttl = 60;
     size_t cache = 2048;
     {
         char *tmp = xstrdup(Ssl::TheConfig.ssl_crt_validator);
         char *tmp_begin = tmp;
         char * token = NULL;
         bool parseParams = true;
         while ((token = strwordtok(NULL, &amp;tmp))) {
             if (parseParams) {

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2015-10-03 05:26:00 +0000
+++ src/ssl/support.cc	2015-10-10 06:37:11 +0000
@@ -1420,79 +1420,73 @@
     // the reference count is not incremented and therefore the session must
     // not be explicitly freed with SSL_SESSION_free(3).
     *copy = 0;
     return session;
 }
 
 static void
 setSessionCallbacks(SSL_CTX *ctx)
 {
     if (SslSessionCache) {
         SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER|SSL_SESS_CACHE_NO_INTERNAL);
         SSL_CTX_sess_set_new_cb(ctx, store_session_cb);
         SSL_CTX_sess_set_remove_cb(ctx, remove_session_cb);
         SSL_CTX_sess_set_get_cb(ctx, get_session_cb);
     }
 }
 
 static bool
 isSslServer()
 {
-    if (HttpsPortList != NULL)
-        return true;
-
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
+        if (s-&gt;secure.encryptTransport)
+            return true;
         if (s-&gt;flags.tunnelSslBumping)
             return true;
     }
 
     return false;
 }
 
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
 void
 Ssl::initialize_session_cache()
 {
 
     if (!isSslServer()) //no need to configure ssl session cache.
         return;
 
     // Check if the MemMap keys and data are enough big to hold
     // session ids and session data
     assert(SSL_SESSION_ID_SIZE &gt;= MEMMAP_SLOT_KEY_SIZE);
     assert(SSL_SESSION_MAX_SIZE &gt;= MEMMAP_SLOT_DATA_SIZE);
 
     int configuredItems = ::Config.SSL.sessionCacheSize / sizeof(Ipc::MemMap::Slot);
     if (IamWorkerProcess() &amp;&amp; configuredItems)
         SslSessionCache = new Ipc::MemMap(SslSessionCacheName);
     else {
         SslSessionCache = NULL;
         return;
     }
 
-    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s-&gt;next) {
-        if (s-&gt;staticSslContext.get() != NULL)
-            setSessionCallbacks(s-&gt;staticSslContext.get());
-    }
-
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
         if (s-&gt;staticSslContext.get() != NULL)
             setSessionCallbacks(s-&gt;staticSslContext.get());
     }
 }
 
 void
 destruct_session_cache()
 {
     delete SslSessionCache;
 }
 
 /// initializes shared memory segments used by MemStore
 class SharedSessionCacheRr: public Ipc::Mem::RegisteredRunner
 {
 public:
     /* RegisteredRunner API */
     SharedSessionCacheRr(): owner(NULL) {}
     virtual void useConfig();
     virtual ~SharedSessionCacheRr();

=== modified file 'src/tools.cc'
--- src/tools.cc	2015-08-30 00:26:47 +0000
+++ src/tools.cc	2015-10-10 06:21:06 +0000
@@ -404,47 +404,40 @@
 
 const char *
 getMyHostname(void)
 {
     LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
     static int present = 0;
     struct addrinfo *AI = NULL;
     Ip::Address sa;
 
     if (Config.visibleHostname != NULL)
         return Config.visibleHostname;
 
     if (present)
         return host;
 
     host[0] = '\0';
 
     if (HttpPortList != NULL &amp;&amp; sa.isAnyAddr())
         sa = HttpPortList-&gt;s;
 
-#if USE_OPENSSL
-
-    if (HttpsPortList != NULL &amp;&amp; sa.isAnyAddr())
-        sa = HttpsPortList-&gt;s;
-
-#endif
-
     /*
      * If the first http_port address has a specific address, try a
      * reverse DNS lookup on it.
      */
     if ( !sa.isAnyAddr() ) {
 
         sa.getAddrInfo(AI);
         /* we are looking for a name. */
         if (getnameinfo(AI-&gt;ai_addr, AI-&gt;ai_addrlen, host, SQUIDHOSTNAMELEN, NULL, 0, NI_NAMEREQD ) == 0) {
             /* DNS lookup successful */
             /* use the official name from DNS lookup */
             debugs(50, 4, &quot;getMyHostname: resolved &quot; &lt;&lt; sa &lt;&lt; &quot; to '&quot; &lt;&lt; host &lt;&lt; &quot;'&quot;);
 
             present = 1;
 
             Ip::Address::FreeAddr(AI);
 
             if (strchr(host, '.'))
                 return host;
         }
@@ -1061,50 +1054,40 @@
             fqdncacheAddEntryFromHosts(addr, hosts);
             wordlistDestroy(&amp;hosts);
         }
     }
 
     fclose (fp);
 }
 
 int
 getMyPort(void)
 {
     AnyP::PortCfgPointer p;
     if ((p = HttpPortList) != NULL) {
         // skip any special interception ports
         while (p != NULL &amp;&amp; p-&gt;flags.isIntercepted())
             p = p-&gt;next;
         if (p != NULL)
             return p-&gt;s.port();
     }
 
-#if USE_OPENSSL
-    if ((p = HttpsPortList) != NULL) {
-        // skip any special interception ports
-        while (p != NULL &amp;&amp; p-&gt;flags.isIntercepted())
-            p = p-&gt;next;
-        if (p != NULL)
-            return p-&gt;s.port();
-    }
-#endif
-
     if ((p = FtpPortList) != NULL) {
         // skip any special interception ports
         while (p != NULL &amp;&amp; p-&gt;flags.isIntercepted())
             p = p-&gt;next;
         if (p != NULL)
             return p-&gt;s.port();
     }
 
     debugs(21, DBG_CRITICAL, &quot;ERROR: No forward-proxy ports configured.&quot;);
     return 0; // Invalid port. This will result in invalid URLs on bad configurations.
 }
 
 /*
  * Set the umask to at least the given mask. This is in addition
  * to the umask set at startup
  */
 void
 setUmask(mode_t mask)
 {
     // No way to get the current umask value without setting it.

</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003594.html">[squid-dev] Jenkins build is back to normal : trunk-polygraph #887
</A></li>
	<LI>Next message: <A HREF="003598.html">[squid-dev] Build failed in Jenkins: trunk-polygraph #889
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3595">[ date ]</a>
              <a href="thread.html#3595">[ thread ]</a>
              <a href="subject.html#3595">[ subject ]</a>
              <a href="author.html#3595">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
