<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20squid-3.5%3A%20fix%20for%20errors%20when%20receiving%20a%0A%20non-existent%20file%20via%20ftp&In-Reply-To=%3C561A869D.8090305%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003593.html">
   <LINK REL="Next"  HREF="003602.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20squid-3.5%3A%20fix%20for%20errors%20when%20receiving%20a%0A%20non-existent%20file%20via%20ftp&In-Reply-To=%3C561A869D.8090305%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Oct 11 15:56:13 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003593.html">[squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp
</A></li>
        <LI>Next message: <A HREF="003602.html">[squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3597">[ date ]</a>
              <a href="thread.html#3597">[ thread ]</a>
              <a href="subject.html#3597">[ subject ]</a>
              <a href="author.html#3597">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Attached is a cleaned version of the patch. It now meets the source
coding guidelines, and applies cleanly to trunk / Squid-4.

I took the opportunity to remove two useless if() conditions - one was
duplicate checking a value, the other for values in a pointer that was
just new()'d.


Logic looks mostly okay, but this part in the middle of
Ftp::Gateway::loginFailed() is rather odd:

-    // any other problems are general falures.
-    if (!err) {
-        ftpFail(this);
+    if (!err)
         return;
-    }

The original behaviour was to output an error and perform the ftpQuit()
sequence. Now it appears to just halt without doing anything.

Is that behaviour change intentional? I suspect the correct behaviour is
to remove that if()-condition entirely, but I'm unsure.

Amos

-------------- next part --------------
=== modified file 'src/clients/FtpClient.cc'
--- src/clients/FtpClient.cc	2015-08-30 00:26:47 +0000
+++ src/clients/FtpClient.cc	2015-10-11 15:21:07 +0000
@@ -225,75 +225,86 @@
         debugs(9, 3, &quot;closing FTP data FD &quot; &lt;&lt; data.conn-&gt;fd &lt;&lt; &quot;, this &quot; &lt;&lt; this);
         data.close();
     }
 
     debugs(9, 3, &quot;FTP ctrl and data connections closed. this &quot; &lt;&lt; this);
 }
 
 /**
  * Did we close all FTP server connection(s)?
  *
  \retval true  Both server control and data channels are closed. And not waiting for a new data connection to open.
  \retval false Either control channel or data is still active.
  */
 bool
 Ftp::Client::doneWithServer() const
 {
     return !Comm::IsConnOpen(ctrl.conn) &amp;&amp; !Comm::IsConnOpen(data.conn);
 }
 
 void
-Ftp::Client::failed(err_type error, int xerrno)
+Ftp::Client::failed(err_type error, int xerrno, ErrorState *err)
 {
     debugs(9, 3, &quot;entry-null=&quot; &lt;&lt; (entry?entry-&gt;isEmpty():0) &lt;&lt; &quot;, entry=&quot; &lt;&lt; entry);
 
     const char *command, *reply;
-    const Http::StatusCode httpStatus = failedHttpStatus(error);
-    ErrorState *const ftperr = new ErrorState(error, httpStatus, fwd-&gt;request);
+    ErrorState *ftperr;
+
+    if (err) {
+        debugs(9, 6, &quot;error=&quot; &lt;&lt; err-&gt;type &lt;&lt; &quot;, code=&quot; &lt;&lt; xerrno &lt;&lt;
+               &quot;, status=&quot; &lt;&lt; err-&gt;httpStatus);
+        error = err-&gt;type;
+        ftperr = err;
+    } else {
+        Http::StatusCode httpStatus = failedHttpStatus(error);
+        ftperr = new ErrorState(error, httpStatus, fwd-&gt;request);
+    }
+
     ftperr-&gt;xerrno = xerrno;
 
     ftperr-&gt;ftp.server_msg = ctrl.message;
     ctrl.message = NULL;
 
     if (old_request)
         command = old_request;
     else
         command = ctrl.last_command;
 
     if (command &amp;&amp; strncmp(command, &quot;PASS&quot;, 4) == 0)
         command = &quot;PASS &lt;yourpassword&gt;&quot;;
 
     if (old_reply)
         reply = old_reply;
     else
         reply = ctrl.last_reply;
 
     if (command)
         ftperr-&gt;ftp.request = xstrdup(command);
 
     if (reply)
         ftperr-&gt;ftp.reply = xstrdup(reply);
 
-    fwd-&gt;request-&gt;detailError(error, xerrno);
-    fwd-&gt;fail(ftperr);
-
-    closeServer(); // we failed, so no serverComplete()
+    if (!err) {
+        fwd-&gt;request-&gt;detailError(error, xerrno);
+        fwd-&gt;fail(ftperr);
+        closeServer(); // we failed, so no serverComplete()
+    }
 }
 
 Http::StatusCode
 Ftp::Client::failedHttpStatus(err_type &amp;error)
 {
     if (error == ERR_NONE)
         error = ERR_FTP_FAILURE;
     return error == ERR_READ_TIMEOUT ? Http::scGatewayTimeout :
            Http::scBadGateway;
 }
 
 /**
  * DPW 2007-04-23
  * Looks like there are no longer anymore callers that set
  * buffered_ok=1.  Perhaps it can be removed at some point.
  */
 void
 Ftp::Client::scheduleReadControlReply(int buffered_ok)
 {
     debugs(9, 3, ctrl.conn);

=== modified file 'src/clients/FtpClient.h'
--- src/clients/FtpClient.h	2015-01-13 07:25:36 +0000
+++ src/clients/FtpClient.h	2015-10-11 14:52:02 +0000
@@ -81,41 +81,42 @@
 
     void addr(const Ip::Address &amp;addr); ///&lt; import host and port
 
 public:
     MemBuf *readBuf;
     char *host;
     unsigned short port;
     bool read_pending;
 };
 
 /// FTP client functionality shared among FTP Gateway and Relay clients.
 class Client: public ::Client
 {
     CBDATA_CLASS(Client);
 
 public:
     explicit Client(FwdState *fwdState);
     virtual ~Client();
 
     /// handle a fatal transaction error, closing the control connection
-    virtual void failed(err_type error = ERR_NONE, int xerrno = 0);
+    virtual void failed(err_type error = ERR_NONE, int xerrno = 0,
+                        ErrorState *ftperr = NULL);
 
     /// read timeout handler
     virtual void timeout(const CommTimeoutCbParams &amp;io);
 
     /* Client API */
     virtual void maybeReadVirginBody();
 
     void writeCommand(const char *buf);
 
     /// extracts remoteAddr from PASV response, validates it,
     /// sets data address details, and returns true on success
     bool handlePasvReply(Ip::Address &amp;remoteAddr);
     bool handleEpsvReply(Ip::Address &amp;remoteAddr);
 
     bool sendEprt();
     bool sendPort();
     bool sendPassive();
     void connectDataChannel();
     bool openListenSocket();
     void switchTimeoutToDataChannel();

=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-08-24 16:51:17 +0000
+++ src/clients/FtpGateway.cc	2015-10-11 15:32:07 +0000
@@ -1210,86 +1210,62 @@
         ftpSendUser(ftpState);
     } else if (code == 120) {
         if (NULL != ftpState-&gt;ctrl.message)
             debugs(9, DBG_IMPORTANT, &quot;FTP server is busy: &quot; &lt;&lt; ftpState-&gt;ctrl.message-&gt;key);
 
         return;
     } else {
         ftpFail(ftpState);
     }
 }
 
 /**
  * Translate FTP login failure into HTTP error
  * this is an attmpt to get the 407 message to show up outside Squid.
  * its NOT a general failure. But a correct FTP response type.
  */
 void
 Ftp::Gateway::loginFailed()
 {
     ErrorState *err = NULL;
-    const char *command, *reply;
 
     if ((state == SENT_USER || state == SENT_PASS) &amp;&amp; ctrl.replycode &gt;= 400) {
         if (ctrl.replycode == 421 || ctrl.replycode == 426) {
             // 421/426 - Service Overload - retry permitted.
             err = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd-&gt;request);
         } else if (ctrl.replycode &gt;= 430 &amp;&amp; ctrl.replycode &lt;= 439) {
             // 43x - Invalid or Credential Error - retry challenge required.
             err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd-&gt;request);
         } else if (ctrl.replycode &gt;= 530 &amp;&amp; ctrl.replycode &lt;= 539) {
             // 53x - Credentials Missing - retry challenge required
             if (password_url) // but they were in the URI! major fail.
                 err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd-&gt;request);
             else
                 err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd-&gt;request);
         }
     }
 
-    // any other problems are general falures.
-    if (!err) {
-        ftpFail(this);
+    if (!err)
         return;
-    }
-
-    err-&gt;ftp.server_msg = ctrl.message;
-
-    ctrl.message = NULL;
-
-    if (old_request)
-        command = old_request;
-    else
-        command = ctrl.last_command;
 
-    if (command &amp;&amp; strncmp(command, &quot;PASS&quot;, 4) == 0)
-        command = &quot;PASS &lt;yourpassword&gt;&quot;;
-
-    if (old_reply)
-        reply = old_reply;
-    else
-        reply = ctrl.last_reply;
-
-    if (command)
-        err-&gt;ftp.request = xstrdup(command);
-
-    if (reply)
-        err-&gt;ftp.reply = xstrdup(reply);
+    failed(ERR_NONE, ctrl.replycode, err);
+    // any other problems are general falures.
 
     HttpReply *newrep = err-&gt;BuildHttpReply();
     delete err;
 
 #if HAVE_AUTH_MODULE_BASIC
     /* add Authenticate header */
     newrep-&gt;header.putAuth(&quot;Basic&quot;, ftpRealm());
 #endif
 
     // add it to the store entry for response....
     entry-&gt;replaceHttpReply(newrep);
     serverComplete();
 }
 
 const char *
 Ftp::Gateway::ftpRealm()
 {
     static char realm[8192];
 
     /* This request is not fully authenticated */
@@ -2396,67 +2372,78 @@
     debugs(9, 3, HERE);
 
     if (old_request == NULL) {
         old_request = ctrl.last_command;
         ctrl.last_command = NULL;
         old_reply = ctrl.last_reply;
         ctrl.last_reply = NULL;
 
         if (pathcomps == NULL &amp;&amp; filepath != NULL)
             old_filepath = xstrdup(filepath);
     }
 
     /* Jump to the &quot;hack&quot; state */
     nextState(this);
 }
 
 static void
 ftpFail(Ftp::Gateway *ftpState)
 {
     const bool slashHack = ftpState-&gt;request-&gt;url.path().caseCmp(&quot;/%2f&quot;, 4)==0;
-    debugs(9, 6, &quot;flags(&quot; &lt;&lt;
+    int code = ftpState-&gt;ctrl.replycode;
+    err_type error_code = ERR_NONE;
+
+    debugs(9, 6, &quot;state &quot; &lt;&lt; ftpState-&gt;state &lt;&lt;
+           &quot; reply code &quot; &lt;&lt; code &lt;&lt; &quot;flags(&quot; &lt;&lt;
            (ftpState-&gt;flags.isdir?&quot;IS_DIR,&quot;:&quot;&quot;) &lt;&lt;
            (ftpState-&gt;flags.try_slash_hack?&quot;TRY_SLASH_HACK&quot;:&quot;&quot;) &lt;&lt; &quot;), &quot; &lt;&lt;
            &quot;mdtm=&quot; &lt;&lt; ftpState-&gt;mdtm &lt;&lt; &quot;, size=&quot; &lt;&lt; ftpState-&gt;theSize &lt;&lt;
            &quot;slashhack=&quot; &lt;&lt; (slashHack? &quot;T&quot;:&quot;F&quot;));
 
     /* Try the / hack to support &quot;Netscape&quot; FTP URL's for retreiving files */
     if (!ftpState-&gt;flags.isdir &amp;&amp;   /* Not a directory */
             !ftpState-&gt;flags.try_slash_hack &amp;&amp; !slashHack &amp;&amp; /* Not doing slash hack */
             ftpState-&gt;mdtm &lt;= 0 &amp;&amp; ftpState-&gt;theSize &lt; 0) { /* Not known as a file */
 
         switch (ftpState-&gt;state) {
 
         case Ftp::Client::SENT_CWD:
 
         case Ftp::Client::SENT_RETR:
             /* Try the / hack */
             ftpState-&gt;hackShortcut(ftpTrySlashHack);
             return;
 
         default:
             break;
         }
     }
 
-    ftpState-&gt;failed(ERR_NONE, 0);
-    /* failed() closes ctrl.conn and frees this */
+    Http::StatusCode sc = ftpState-&gt;failedHttpStatus(error_code);
+    ErrorState *ftperr = new ErrorState(error_code, sc, ftpState-&gt;fwd-&gt;request);
+    ftpState-&gt;failed(error_code, code, ftperr);
+    ftperr-&gt;detailError(code);
+    HttpReply *newrep = ftperr-&gt;BuildHttpReply();
+    delete ftperr;
+
+    ftpState-&gt;entry-&gt;replaceHttpReply(newrep);
+    ftpSendQuit(ftpState);
 }
 
 Http::StatusCode
 Ftp::Gateway::failedHttpStatus(err_type &amp;error)
 {
     if (error == ERR_NONE) {
         switch (state) {
 
         case SENT_USER:
 
         case SENT_PASS:
 
             if (ctrl.replycode &gt; 500) {
                 error = ERR_FTP_FORBIDDEN;
                 return password_url ? Http::scForbidden : Http::scUnauthorized;
             } else if (ctrl.replycode == 421) {
                 error = ERR_FTP_UNAVAILABLE;
                 return Http::scServiceUnavailable;
             }
             break;

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003593.html">[squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp
</A></li>
	<LI>Next message: <A HREF="003602.html">[squid-dev] [PATCH] squid-3.5: fix for errors when receiving a non-existent file via ftp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3597">[ date ]</a>
              <a href="thread.html#3597">[ thread ]</a>
              <a href="subject.html#3597">[ subject ]</a>
              <a href="author.html#3597">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
