<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Parser-NG conversion of ICAP pt2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Parser-NG%20conversion%20of%20ICAP%20pt2&In-Reply-To=%3C562810D4.4060703%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003637.html">
   <LINK REL="Next"  HREF="003622.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Parser-NG conversion of ICAP pt2</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Parser-NG%20conversion%20of%20ICAP%20pt2&In-Reply-To=%3C562810D4.4060703%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Parser-NG conversion of ICAP pt2">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Oct 21 22:25:24 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003637.html">[squid-dev] [PATCH] %&lt;lp missing for persistent connections
</A></li>
        <LI>Next message: <A HREF="003622.html">[squid-dev] [PATCH] add support for using an existing kerberos cache instead of a keytab
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3621">[ date ]</a>
              <a href="thread.html#3621">[ thread ]</a>
              <a href="subject.html#3621">[ subject ]</a>
              <a href="author.html#3621">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/23/2015 02:40 PM, Amos Jeffries wrote:
&gt;<i> It turns out that ICAP implements has three distinct protocol parsers.
</I>&gt;<i> 
</I>&gt;<i> I begin the ICAP parser conversion to the Parser-NG model with
</I>&gt;<i> ModXact::parseHeaders() - which was conflating both ICAP and HTTP, and
</I>&gt;<i> the HTTP directional parsers.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> * splits the exiting parse method into 3 distinct stages; ICAP-reply,
</I>&gt;<i> HTTP-request, HTTP-reply. Each stage is sequential and controlled by the
</I>&gt;<i> Encapsulated header contents.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure yet if we need to be tolerant of out-of-order segments in
</I>&gt;<i> the payload. The spec is pretty clear that order is explicit and
</I>&gt;<i> specific. 
</I>
AFAIK, we do not need to be tolerant to out-of-order segments -- there
are no known cases of those. We might want to be tolerant to unexpected
segments (bug 2480).


&gt;<i> But the old parser actually ignored the Encapsulated header
</I>&gt;<i> byte offsets (!!).
</I>

The new parsers should continue to ignore them IMO. Those offsets are an
ICAP mis-feature -- a duplication of information that, as most
duplicates, leads to bugs. Ignoring them makes Squid ICAP code more
robust and probably decreases compatibility problems without [known] bad
side effects. We should parse the headers declared by Encapsulated.
Ignore numerical offset values.


&gt;<i> +     * ICAP header parse does not share the HTTP segment code, and
</I>&gt;<i> +     * Encapsulated: tells us how many bytes and where each payload segment is.
</I>&gt;<i> +     * We can pull N bytes into a child SBuf for parsing.
</I>&gt;<i> +     *
</I>&gt;<i> +     * 1) if there are not enough bytes we need more before even attempting the parse
</I>&gt;<i> +     *
</I>&gt;<i> +     * 2) after parse we can verify that it consumed all of the child buf.
</I>&gt;<i> +     *    if there are leftovers ... smuggling attack from the ICAP server?
</I>&gt;<i> +     */
</I>
This part of the TODO comment should be removed IMO. See my comments
above for the rationale.


&gt;<i> +    /* TODO: we do not need to rely on readBuf anymore for the parser logic.
</I>
The comment seems to be misplaced which makes it unclear. The
surrounding code does not rely on readBuf parser logic, whatever that
is. Please reword it in a context-specific way or move it to a more
appropriate place.


&gt;<i> +    /* Attempt to parse the ICAP message */
</I>
s/parse the ICAP message/isolate the ICAP response header/

(if that is what you are doing here; note that there is a &quot;parse
headers&quot; comment further below so you are not parsing headers here)


&gt;<i> +        bool parsedOk = hp-&gt;parse(readBuf);
</I>
If you can make it constant, make it const.


&gt;<i> +        // sync the buffers after parsing.
</I>&gt;<i> +        readBuf = hp-&gt;remaining();
</I>
Too early? The &quot;unrecoverable parsing error&quot; code below should show what
we failed to parse, not what remained after we failed to parse.


&gt;<i> +    /* We know the whole response is in parser now */
</I>
s/response/response header/


&gt;<i> +    // XXX: performance regression. SBuf::c_str() reallocates
</I>&gt;<i> +    SBuf tmpPhrase(hp-&gt;reasonPhrase());
</I>&gt;<i> +    icapReply-&gt;sline.set(hp-&gt;messageProtocol(), hp-&gt;messageStatus(), tmpPhrase.c_str());
</I>
Do we need to introduce a regression here? How about using a few
hard-coded reasons for supported codes and a catch-all for all others?


Many of the above comments apply to the other parsing methods you have
created: parseHttpRequestHead and parseHttpRequestHead. Please check
those as well.


&gt;<i> +        // const_cast is okay, the buffer area behind the c_str will not be used again by this xaction
</I>&gt;<i> +        // and that will only change when urlParse() starts taking the requestUri() SBuf directly
</I>
This violates, and I quote, &quot;DO NOT EVER USE THE RETURNED POINTER FOR
WRITING&quot; c_str() API. Explaining why that API violation may be safe
today is better than nothing, but still deserves a big fat XXX.

Even if the above assumption is accurate today, a code change in a
seemingly unrelated place may make it false, leading to hard-to-find
bugs. All it takes is for some code to copy the underlying SBuf
somewhere... If you want to improve this, please contact Christos: IIRC,
we have seen a similar problem elsewhere in the code and ended up adding
a new SBuf method to combat it. Christos should have the details.



&gt;<i> +    state.parsing = State::psHttpRequestHeader; // 'reqhdr' segment maybe first
</I>
To clarify, I would replace that comment with something like

// some buggy ICAP servers send HTTP request headers even when
// we expect only HTTP response headers (e.g., during RESPMOD)
state.parsing = State::psHttpRequestHeader


Alternatively, you can set state.parsing based on the Encapsulated
header. This will be more complex but a bit faster because you will
avoid calling parseHttpRequestHead() for 99.99999999% of RESPMOD
responses. That method has a non-trivial initial overhead.


&gt;<i> +        // parse headers
</I>&gt;<i> +        adapted.header-&gt;pstate = psReadyToParseHeaders;
</I>&gt;<i> +        Must(adapted.header-&gt;httpMsgParseStep(httpReqParser-&gt;mimeHeader().rawContent(), httpReqParser-&gt;mimeHeader().length(), true) &gt;= 0);
</I>&gt;<i> +
</I>&gt;<i> +        setOutcome(xoModified);
</I>
If I am reading the patched code correctly, this is wrong for HTTP
request headers in a RESPMOD response. Those headers must be ignored,
not used as adapted message headers.


&gt;<i> +        // XXX: replyHttpHeaderSize used to account how many ICAP body bytes are processed
</I>&gt;<i> +        // but ICAP can present two header segments and only the second gets counted.
</I>&gt;<i> +        // Worse; the second in that case is HTTP reply message and smaller of the two.
</I>
Similarly, there appears to be some confusion regarding the number of
HTTP headers in the ICAP response. A valid response has either zero or
one HTTP header. If we decide to accept buggy ICAP responses that
include both HTTP request and HTTP response headers, then we must
*discard* the HTTP request header.

Two HTTP headers in an ICAP response is not an XXX (our bug), but an
ICAP server bug. If we decide to be tolerant, we need to process it
correctly, but if it is too complex to do that correctly, we should not
be tolerant in this case -- AFAICT, there are no popular (or even
non-obscure) ICAP servers that send two HTTP message headers in ICAP
responses.

Referring to bug 2480 in some of the source code comments might be
helpful: <A HREF="http://bugs.squid-cache.org/show_bug.cgi?id=2480">http://bugs.squid-cache.org/show_bug.cgi?id=2480</A>



&gt;<i> +    Icap::ResponseParserPointer hp;  ///&lt; parser for current ICAP protocol message (if any)
</I>
AFAICT, this is an attempt at incremental parsing for ICAP response
headers. I recommend avoiding that optimization because ICAP response
headers are small and we have spent enough time fixing incremental
parsing bugs already. Make that hp parser local to parseIcapHead().



&gt;<i> * adds &quot;ICAP&quot; / &quot;icap&quot; to the registered protocol types and scheme
</I>&gt;<i> names, and associated Icap::ProtocolVersion() infrastructure.
</I>&gt;<i> 
</I>&gt;<i> * adds Adaptation::Icap::ResponseParser class extending
</I>&gt;<i> Http1::ResponseParser with ICAP related details and first-line parser.
</I>
I do not think we should do that. The HTTP and ICAP syntax are
essentially the same. There is no good reason to duplicate this code. If
you need to parametrize &quot;HTTP&quot; vs. &quot;ICAP&quot; tokens, either add a data
member or, better, allow for both in the *parser* and let the caller
check the parsed protocol. IIRC, we already allow ICY for HTTP and this
approach may help remove that exception from the parser.


&gt;<i> +    // NOTE: RFC 3507 does not define extended whitespace characters to be tolerated
</I>&gt;<i> +    //       like RFC 7230. Being strict leads to fewer problems in the long term.
</I>

RFC 3507 lets HTTP/1 define general status line and header syntax. Thus,
it essentially allows everything that HTTP/1 allows.

The lack of an explicit reference to some HTTP syntax concept in RFC
3507 should not be misinterpreted as an implication that HTTP-allowed
things are prohibited in ICAP. We have wasted weeks on this during HTTP
parser &quot;upgrade&quot; which is still unfinished. Let's not repeat that here,
please. Reuse the HTTP parsing code for ICAP as much as you can.


&gt;<i> There is some weird race behaviour I still want to verify if trunk has
</I>&gt;<i> too. But have gone with PATCH instead of PREVIEW since this seems like a
</I>&gt;<i> good place to pause. Leaving most polish and some major bug fixes to
</I>&gt;<i> followups. That includes the other two parsers in adaptation/icap/.
</I>

Similarly, my initial review focuses on just a few big issues. More
review rounds will be necessary.

Please note that you are not simply replacing old hand-written parsing
code with code that uses currently available parsers. You are also
changing the overall ICAP logic surrounding that code. I doubt that was
a good idea, but it is probably too late to go back to a simpler
replacement plan.


Thank you,

Alex.

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003637.html">[squid-dev] [PATCH] %&lt;lp missing for persistent connections
</A></li>
	<LI>Next message: <A HREF="003622.html">[squid-dev] [PATCH] add support for using an existing kerberos cache instead of a keytab
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3621">[ date ]</a>
              <a href="thread.html#3621">[ thread ]</a>
              <a href="subject.html#3621">[ subject ]</a>
              <a href="author.html#3621">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
