<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SBuf Locker friend class
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20Locker%20friend%20class&In-Reply-To=%3C56327243.4080305%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003651.html">
   <LINK REL="Next"  HREF="003653.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SBuf Locker friend class</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20Locker%20friend%20class&In-Reply-To=%3C56327243.4080305%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] SBuf Locker friend class">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Oct 29 19:23:47 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003651.html">[squid-dev] [PATCH] Migrate basic_ncsa_auth from squid hash to std::unordered_map
</A></li>
        <LI>Next message: <A HREF="003653.html">[squid-dev] [PATCH] SBuf Locker friend class
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3652">[ date ]</a>
              <a href="thread.html#3652">[ thread ]</a>
              <a href="subject.html#3652">[ subject ]</a>
              <a href="author.html#3652">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Adds the Locker friend class to SBuf to provide safety ref-count locks
when dealing with dangerous char* or SBuf&amp; inputs.

I have gone through and added it to all the non-const methods that
appear to be taking char* directly, or using a char* taken from SBuf&amp;.
That review added the appendf/printf methods to the set we identified on
IRC.

IMO the trim() method mentioned on IRC does not need it since the scope
lifetime of the pointer taken by toRemove.buf() does not cross any
alterations of the this objects members.


I've not added documentation for the Locker class. Alex could you
provide a blurb to describe the memory issue and requirements this solves ?

Amos
-------------- next part --------------
=== modified file 'src/SBuf.cc'
--- src/SBuf.cc	2015-08-12 22:18:22 +0000
+++ src/SBuf.cc	2015-10-29 18:41:39 +0000
@@ -144,40 +144,41 @@
     return InitialStore;
 }
 
 SBuf&amp;
 SBuf::assign(const SBuf &amp;S)
 {
     debugs(24, 7, &quot;assigning &quot; &lt;&lt; id &lt;&lt; &quot; from &quot; &lt;&lt;  S.id);
     if (&amp;S == this) //assignment to self. Noop.
         return *this;
     ++stats.assignFast;
     store_ = S.store_;
     off_ = S.off_;
     len_ = S.len_;
     return *this;
 }
 
 SBuf&amp;
 SBuf::assign(const char *S, size_type n)
 {
     debugs(24, 6, id &lt;&lt; &quot; from c-string, n=&quot; &lt;&lt; n &lt;&lt; &quot;)&quot;);
+    Locker prevent_raw_memory_madness(this, S, n);
     clear();
     return append(S, n); //bounds checked in append()
 }
 
 void
 SBuf::reserveCapacity(size_type minCapacity)
 {
     Must(minCapacity &lt;= maxSize);
     cow(minCapacity);
 }
 
 char *
 SBuf::rawSpace(size_type minSpace)
 {
     Must(length() &lt;= maxSize - minSpace);
     debugs(24, 7, &quot;reserving &quot; &lt;&lt; minSpace &lt;&lt; &quot; for &quot; &lt;&lt; id);
     ++stats.rawAccess;
     // we're not concerned about RefCounts here,
     // the store knows the last-used portion. If
     // it's available, we're effectively claiming ownership
@@ -196,90 +197,99 @@
 void
 SBuf::clear()
 {
 #if 0
     //enabling this code path, the store will be freed and reinitialized
     store_ = GetStorePrototype(); //uncomment to actually free storage upon clear()
 #else
     //enabling this code path, we try to release the store without deallocating it.
     // will be lazily reallocated if needed.
     if (store_-&gt;LockCount() == 1)
         store_-&gt;clear();
 #endif
     len_ = 0;
     off_ = 0;
     ++stats.clear;
 }
 
 SBuf&amp;
 SBuf::append(const SBuf &amp;S)
 {
+    Locker prevent_raw_memory_madness(this, S.buf(), S.length());
     return lowAppend(S.buf(), S.length());
 }
 
 SBuf &amp;
 SBuf::append(const char * S, size_type Ssize)
 {
     if (S == NULL)
         return *this;
     if (Ssize == SBuf::npos)
         Ssize = strlen(S);
     debugs(24, 7, &quot;from c-string to id &quot; &lt;&lt; id);
+    Locker prevent_raw_memory_madness(this, S, Ssize);
     // coverity[access_dbuff_in_call]
     return lowAppend(S, Ssize);
 }
 
 SBuf &amp;
 SBuf::append(const char c)
 {
     return lowAppend(&amp;c, 1);
 }
 
 SBuf&amp;
 SBuf::Printf(const char *fmt, ...)
 {
+    // with printf() an arg might be a dangerous char*
+    // NP: cant rely on vappendf() Locker because of clear()
+    Locker prevent_raw_memory_madness(this, buf(), length());
+
     va_list args;
     va_start(args, fmt);
     clear();
     vappendf(fmt, args);
     va_end(args);
     return *this;
 }
 
 SBuf&amp;
 SBuf::appendf(const char *fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
     vappendf(fmt, args);
     va_end(args);
     return *this;
 }
 
 SBuf&amp;
 SBuf::vappendf(const char *fmt, va_list vargs)
 {
     Must(fmt != NULL);
     int sz = 0;
     //reserve twice the format-string size, it's a likely heuristic
     size_type requiredSpaceEstimate = strlen(fmt)*2;
 
+    // with appendf() an arg might be a dangerous char*
+    Locker prevent_raw_memory_madness(this, buf(), length());
+
     char *space = rawSpace(requiredSpaceEstimate);
 #ifdef VA_COPY
     va_list ap;
     VA_COPY(ap, vargs);
     sz = vsnprintf(space, spaceSize(), fmt, ap);
     va_end(ap);
 #else
     sz = vsnprintf(space, spaceSize(), fmt, vargs);
 #endif
 
     /* check for possible overflow */
     /* snprintf on Linux returns -1 on output errors, or the size
      * that would have been written if enough space had been available */
     /* vsnprintf is standard in C99 */
 
     if (sz &gt;= static_cast&lt;int&gt;(spaceSize())) {
         // not enough space on the first go, we now know how much we need
         requiredSpaceEstimate = sz*2; // TODO: tune heuristics
         space = rawSpace(requiredSpaceEstimate);
         sz = vsnprintf(space, spaceSize(), fmt, vargs);

=== modified file 'src/SBuf.h'
--- src/SBuf.h	2015-08-12 22:18:22 +0000
+++ src/SBuf.h	2015-10-29 18:53:31 +0000
@@ -650,40 +650,54 @@
     iterator begin() {
         return iterator(*this, 0);
     }
 
     iterator end() {
         return iterator(*this, length());
     }
 
     reverse_iterator rbegin() {
         return reverse_iterator(*this, length());
     }
 
     reverse_iterator rend() {
         return reverse_iterator(*this, 0);
     }
 
     // TODO: possibly implement erase() similar to std::string's erase
     // TODO: possibly implement a replace() call
 private:
 
+    class Locker
+    {
+    public:
+        Locker(SBuf *parent, const char *Q, size_t len) : locket(nullptr) {
+            // lock if Q intersects the parents buffer area
+            const MemBlob *P = parent-&gt;store_.getRaw();
+            if ( (Q+len) &gt;= P-&gt;mem &amp;&amp; Q &lt;= (P-&gt;mem + P-&gt;capacity) )
+                locket = P;
+        }
+    private:
+        MemBlob::Pointer locket;
+    };
+    friend class Locker;
+
     MemBlob::Pointer store_; ///&lt; memory block, possibly shared with other SBufs
     size_type off_; ///&lt; our content start offset from the beginning of shared store_
     size_type len_; ///&lt; number of our content bytes in shared store_
     static SBufStats stats; ///&lt; class-wide statistics
 
     /// SBuf object identifier; does not change when contents do,
     ///   including during assignment
     const InstanceId&lt;SBuf&gt; id;
 
     /** obtain prototype store
      *
      * Just-created SBufs all share to the same MemBlob.
      * This call instantiates and returns it.
      */
     static MemBlob::Pointer GetStorePrototype();
 
     /**
      * obtains a char* to the beginning of this SBuf in memory.
      * \note the obtained string is NOT null-terminated.
      */

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003651.html">[squid-dev] [PATCH] Migrate basic_ncsa_auth from squid hash to std::unordered_map
</A></li>
	<LI>Next message: <A HREF="003653.html">[squid-dev] [PATCH] SBuf Locker friend class
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3652">[ date ]</a>
              <a href="thread.html#3652">[ thread ]</a>
              <a href="subject.html#3652">[ subject ]</a>
              <a href="author.html#3652">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
