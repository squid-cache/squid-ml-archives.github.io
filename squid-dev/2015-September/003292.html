<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] mempools-nozero: turn StoreEntry into MEMPROXY_CLASS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mempools-nozero%3A%20turn%20StoreEntry%20into%0A%20MEMPROXY_CLASS&In-Reply-To=%3C55E54E5A.1030605%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003293.html">
   <LINK REL="Next"  HREF="003294.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] mempools-nozero: turn StoreEntry into MEMPROXY_CLASS</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mempools-nozero%3A%20turn%20StoreEntry%20into%0A%20MEMPROXY_CLASS&In-Reply-To=%3C55E54E5A.1030605%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] mempools-nozero: turn StoreEntry into MEMPROXY_CLASS">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Sep  1 07:06:02 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003293.html">[squid-dev] [PATCH] Handle SSL v2 Hello
</A></li>
        <LI>Next message: <A HREF="003294.html">[squid-dev] Build failed in Jenkins: trunk-polygraph #861
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3292">[ date ]</a>
              <a href="thread.html#3292">[ thread ]</a>
              <a href="subject.html#3292">[ subject ]</a>
              <a href="author.html#3292">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 1/09/2015 8:29 a.m., Alex Rousskov wrote:
&gt;<i> On 08/29/2015 08:03 PM, Kinkie wrote:
</I>&gt;&gt;<i> On Aug 28, 2015 7:24 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> Perhaps there a way to avoid this particular part of the change
</I>&gt;&gt;<i> and keep the StoreEntry chunk sizes the same as they are today?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Unfortunately not if we want to proceed with MEMPROXY_CLASS conversion,
</I>&gt;&gt;<i> which doesn't expose that method, and MEMPROXY_CLASS is with this branch
</I>&gt;&gt;<i> the easiest (I would dare to say standard) way to go to non-zeroing pools.
</I>&gt;<i> 
</I>&gt;<i> If you can avoid the problem by exposing and using that method, I think
</I>&gt;<i> that would be a good solution.
</I>
The problem then becomes *how* to do that.

Since it is a macro API the cleanest solution seems to be rename the
existing macro to one that takes a pool size parameter. Then add a
wrapper MEMPROXY_CLASS(x) macro that calls it with the usual pool size.


&gt;<i> 
</I>&gt;&gt;<i> I've tried to figure out the code some more; comments highlight that
</I>&gt;&gt;<i> it's an optimization feature, which is only effective with the chunked
</I>&gt;&gt;<i> allocator - it is otherwise a nop.
</I>&gt;&gt;<i> I believe this hint its is meant to try and alter the behavior of the
</I>&gt;&gt;<i> chunked allocator - in a roundabout way - hinting that the objects in
</I>&gt;&gt;<i> the pool are important and thus to try and make that particular object
</I>&gt;&gt;<i> pool less sensitive to memory pressure, by ensuring that if even a
</I>&gt;&gt;<i> single StoreEntry can be allocated, there will be at least
</I>&gt;&gt;<i> (chunk_size/obj_size -1) available memory areas until all of them have
</I>&gt;&gt;<i> been released.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> ... I suspect that whatever is the optimization value of
</I>&gt;&gt;<i> chunk size setting, it is dwarfed by other effects and is speculative;
</I>&gt;&gt;<i> at the same time we have a sure gain by not initializing objects twice
</I>&gt;&gt;<i> (one when zeroing the pool, and then in the constructor).
</I>&gt;&gt;<i> For this reason, I would like to go ahead with the merge, I agree it's a
</I>&gt;&gt;<i> good idea to isolate this patch into a separate commit, and to mark it
</I>&gt;&gt;<i> as potentially performance-impacting in the commit message.
</I>&gt;<i> 
</I>&gt;&gt;<i> Please let me know if you agree.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I may not agree with some of the above statements, but I do not object
</I>&gt;<i> to this change going in (in a dedicated commit) if you think that is the
</I>&gt;<i> best way forward (and others do not object).
</I>
Ditto.


PS. I think the chunked pools are not even used that much. But we simply
dont have enough solid info about the limit. Thus my earlier statement
about needing tests. From the suspected purpose it should only take
someone with lot of traffic and large cache_mem to trial the different
values and see what happens to their performance. It can be done on any
Squid version by just removing the 2MB limit setter.

PPS. We do have several active community members with that sort of setup
who might be willing to run a trial. Particularly if the hoped outcome
is better performance. If it gets *worse* then we may want to move on to
trialling larger chunk sizes instead.

Amos
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003293.html">[squid-dev] [PATCH] Handle SSL v2 Hello
</A></li>
	<LI>Next message: <A HREF="003294.html">[squid-dev] Build failed in Jenkins: trunk-polygraph #861
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3292">[ date ]</a>
              <a href="thread.html#3292">[ thread ]</a>
              <a href="subject.html#3292">[ subject ]</a>
              <a href="author.html#3292">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
