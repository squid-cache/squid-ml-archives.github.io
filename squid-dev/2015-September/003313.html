<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fix for bug 4190
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20for%20bug%204190&In-Reply-To=%3C55EBC3AE.5070905%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003301.html">
   <LINK REL="Next"  HREF="003314.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fix for bug 4190</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20for%20bug%204190&In-Reply-To=%3C55EBC3AE.5070905%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Fix for bug 4190">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Sep  6 04:40:14 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003301.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
        <LI>Next message: <A HREF="003314.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3313">[ date ]</a>
              <a href="thread.html#3313">[ thread ]</a>
              <a href="subject.html#3313">[ subject ]</a>
              <a href="author.html#3313">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/04/2015 10:50 PM, Kinkie wrote:
&gt;<i> Hi all,
</I>&gt;<i>    the attached patch is a proposed fix for bug 4190 (and then some).
</I>&gt;<i> It transforms the global hash_table proxy_auth_username_cache into
</I>&gt;<i> four per-authentication-scheme std::unordered_map-backed caches,
</I>&gt;<i> leveraging the RegisteredRunner API and SBuf.
</I>

&gt;<i> + * \returns a pointer to cached credentials, or nullptr if none found
</I>&gt;<i> + */
</I>&gt;<i> +class UserNameCache : public RegisteredRunner
</I>
Stale comment? A C++ class cannot return something.


&gt;<i> +/** Cache of Auth::User::Pointer, keyed by Auth::User::userKey
</I>...
&gt;<i> +class UserNameCache : public RegisteredRunner
</I>
Why is this called UserNameCache? It looks like this is a _user_ cache
(with all the authentication information we want to keep about the
user), not user _name_ cache (with just the user name).


&gt;<i> +class UserNameCache : public RegisteredRunner
</I>
Please separate cache operation (the UserNameCache class) and
external-to-caches cache object creation/cleanup/destruction/etc.
initiation code (creating a dedicated child of RegisteredRunner for
that). This is a good idea in general because it simplifies code, but it
is especially desirable here because you have multiple caches but need
only one Runner object to initiate their creation/cleanup/destruction/etc.


&gt;<i> +    UserNameCache() = delete;
</I>
Do not delete something that does not exist.


&gt;<i> +    /** obtain sorted list of usernames
</I>&gt;<i> +     *
</I>&gt;<i> +     */
</I>&gt;<i> +    std::vector&lt;Auth::User::Pointer&gt; sortedUsersList() const;
</I>
Sorted how? Please check other occurrences of new std::vectors in the
patch. Always define how they are indexed or sorted. It is much easier
to supply that info now than correctly restore it later.

Please typedef std::vector&lt;Auth::User::Pointer&gt; as Auth::Users or
similar and avoid repeating that expression many times.


&gt;<i> +    ~UserNameCache() = default;
</I>
This should have &quot;virtual&quot; keyword in the current patch. May not be
necessary after RegisteredRunner parent is removed.


&gt;<i> +    // c_str() raw pointer is used in event. std::string must not reallocate
</I>&gt;<i> +    // after ctor and until shutdown
</I>&gt;<i> +    // must be unique
</I>&gt;<i> +    std::string cacheCleanupEventName;
</I>
The troubles with this &quot;pray that it works&quot; design are not worth the
gains IMHO. If you think the event name must be &quot;User cache cleanup:
digest&quot; instead of just &quot;digest&quot;, &quot;Digest user cache&quot;, or similar, then
pass a beautiful event name as the second UserNameCache constructor
parameter, supplied by UserNameCache kids.


&gt;<i> +void
</I>&gt;<i> +UserNameCache::Cleanup(void *data)
</I>&gt;<i> +{
</I>&gt;<i> +    debugs(29, 5, &quot;checkpoint&quot;);
</I>&gt;<i> +    if (!cbdataReferenceValid(data))
</I>&gt;<i> +        return;
</I>
I believe you are using eventAdd() with cbdata protection so the
reference has to be valid. If I have not missed some case where data may
be invalid, please remove this if statement.


&gt;<i> +    eventDelete(&amp;UserNameCache::Cleanup, this);
</I>
This call will lead to debug_trap() if the event callback happens to be
scheduled already (and, hence, out of the event queue but not fired
yet). There is currently no safe way to delete events with arguments,
especially long-lived ones like cleanup. Do not delete them if possible.

If the cache is no longer needed, delete the cache object itself. This
will prevent the cbdata-protected event from reaching the cache object.
If you cannot delete the cache object because of the bugs elsewhere,
perhaps you can use cleared store_ as a sign that the event should not
be processed any more?

Or, alternatively, perhaps you can let the event fire (and just not
schedule the next one if there is nothing to cleanup)? Which brings me to:


&gt;<i> +UserNameCache::UserNameCache(const char *name) :
</I>&gt;<i> +    cachename(name), cacheCleanupEventName(&quot;User cache cleanup: &quot;)
</I>&gt;<i> +{
</I>&gt;<i> +    debugs(29, 5, &quot;initializing &quot; &lt;&lt; name &lt;&lt; &quot; username cache&quot;);
</I>&gt;<i> +    cacheCleanupEventName.append(name);
</I>&gt;<i> +    eventAdd(cacheCleanupEventName.c_str(), &amp;UserNameCache::Cleanup,
</I>&gt;<i> +             this, ::Config.authenticateGCInterval, 1);
</I>
It may be better to avoid scheduling cache cleanups until there is
something to cleanup. This will require storing &quot;we have scheduled a
cleanup&quot; boolean, but it may make help folks that deal with Squids which
are idle for extended periods of time but still wake up every second [to
do nothing].


&gt;<i> +    eventAdd(self-&gt;cacheCleanupEventName.c_str(), &amp;UserNameCache::Cleanup,
</I>&gt;<i> +             self, ::Config.authenticateGCInterval, 1);
</I>
&gt;<i> +    eventAdd(cacheCleanupEventName.c_str(), &amp;UserNameCache::Cleanup,
</I>&gt;<i> +             this, ::Config.authenticateGCInterval, 1);
</I>
Please avoid code duplication.


&gt;<i> +void
</I>&gt;<i> +UserNameCache::Cleanup(void *data)
</I>&gt;<i> +{
</I>&gt;<i> +    debugs(29, 5, &quot;checkpoint&quot;);
</I>...
&gt;<i> +    // data is this in disguise
</I>&gt;<i> +    UserNameCache *self = static_cast&lt;UserNameCache *&gt;(data);
</I>
And now it is time to call self-&gt;cleanup(), to avoid doing a lot of
stuff inside the static method when you have a perfectly good object
available.


HTH,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003301.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
	<LI>Next message: <A HREF="003314.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3313">[ date ]</a>
              <a href="thread.html#3313">[ thread ]</a>
              <a href="subject.html#3313">[ subject ]</a>
              <a href="author.html#3313">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
