<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fix for bug 4190
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20for%20bug%204190&In-Reply-To=%3C55EC191E.9030501%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003313.html">
   <LINK REL="Next"  HREF="003315.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fix for bug 4190</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20for%20bug%204190&In-Reply-To=%3C55EC191E.9030501%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Fix for bug 4190">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Sep  6 10:44:46 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003313.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
        <LI>Next message: <A HREF="003315.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3314">[ date ]</a>
              <a href="thread.html#3314">[ thread ]</a>
              <a href="subject.html#3314">[ subject ]</a>
              <a href="author.html#3314">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>[kinkie: looks like these may take a while to resolve. If you want to
push the branch to lp:~squid I can pick up the editing now]

On 6/09/2015 4:40 p.m., Alex Rousskov wrote:
&gt;<i> On 09/04/2015 10:50 PM, Kinkie wrote:
</I>&gt;&gt;<i> Hi all,
</I>&gt;&gt;<i>    the attached patch is a proposed fix for bug 4190 (and then some).
</I>&gt;&gt;<i> It transforms the global hash_table proxy_auth_username_cache into
</I>&gt;&gt;<i> four per-authentication-scheme std::unordered_map-backed caches,
</I>&gt;&gt;<i> leveraging the RegisteredRunner API and SBuf.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> + * \returns a pointer to cached credentials, or nullptr if none found
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +class UserNameCache : public RegisteredRunner
</I>&gt;<i> 
</I>&gt;<i> Stale comment? A C++ class cannot return something.
</I>&gt;<i> 
</I>
Should be on the lookup() method, and with s/nullptr/nil/

&gt;<i> 
</I>&gt;&gt;<i> +/** Cache of Auth::User::Pointer, keyed by Auth::User::userKey
</I>&gt;<i> ...
</I>&gt;&gt;<i> +class UserNameCache : public RegisteredRunner
</I>&gt;<i> 
</I>&gt;<i> Why is this called UserNameCache? It looks like this is a _user_ cache
</I>&gt;<i> (with all the authentication information we want to keep about the
</I>&gt;<i> user), not user _name_ cache (with just the user name).
</I>&gt;<i> 
</I>
Legacy: it caches Auth::User keyed by-name.

If we are going to change this it should probably be to
&quot;CredentialsCache&quot; I think.

&gt;<i> 
</I>&gt;&gt;<i> +class UserNameCache : public RegisteredRunner
</I>&gt;<i> 
</I>&gt;<i> Please separate cache operation (the UserNameCache class) and
</I>&gt;<i> external-to-caches cache object creation/cleanup/destruction/etc.
</I>&gt;<i> initiation code (creating a dedicated child of RegisteredRunner for
</I>&gt;<i> that). This is a good idea in general because it simplifies code, but it
</I>&gt;<i> is especially desirable here because you have multiple caches but need
</I>&gt;<i> only one Runner object to initiate their creation/cleanup/destruction/etc.
</I>&gt;<i> 
</I>
No. We cant have one runner.

The only safe way to check if a Cache() call is usable without creating
a whole new cache as side effect is to check the current scheme config.

With one runner we hit a race condition between the scheme config being
re-configured and the runner needing to decide if the cache is worth
re-configuring or deleting.

It would also mean even more hard-coding of what schemes exist and need
to be managed by the runner, when schemes are supposed to be plug-n-play
components. AIUI the whole point of the runner API was to avoid that
kind of hard-coding.

We can have N split runners controlling a cache each. Just doing nothing
if a CbcPointer they hold is invalid or null. That should work. But not
one runner juggling multiple optional schemes.

Doing the split though leads to direct code duplication. Since the
runner is just calling 1:1 methods on the cache, both have to have
identically matching lifetimes and ctor/dtor sequences need to line up
their actions with inverse dependency :: creating cache creates runner,
deleting runner deletes cache, creating runner early or deleting cache
early causes problems).


&gt;<i> 
</I>&gt;&gt;<i> +    UserNameCache() = delete;
</I>&gt;<i> 
</I>&gt;<i> Do not delete something that does not exist.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    /** obtain sorted list of usernames
</I>&gt;&gt;<i> +     *
</I>&gt;&gt;<i> +     */
</I>&gt;&gt;<i> +    std::vector&lt;Auth::User::Pointer&gt; sortedUsersList() const;
</I>&gt;<i> 
</I>&gt;<i> Sorted how? Please check other occurrences of new std::vectors in the
</I>&gt;<i> patch. Always define how they are indexed or sorted. It is much easier
</I>&gt;<i> to supply that info now than correctly restore it later.
</I>&gt;<i> 
</I>&gt;<i> Please typedef std::vector&lt;Auth::User::Pointer&gt; as Auth::Users or
</I>&gt;<i> similar and avoid repeating that expression many times.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    ~UserNameCache() = default;
</I>&gt;<i> 
</I>&gt;<i> This should have &quot;virtual&quot; keyword in the current patch. May not be
</I>&gt;<i> necessary after RegisteredRunner parent is removed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    // c_str() raw pointer is used in event. std::string must not reallocate
</I>&gt;&gt;<i> +    // after ctor and until shutdown
</I>&gt;&gt;<i> +    // must be unique
</I>&gt;&gt;<i> +    std::string cacheCleanupEventName;
</I>&gt;<i> 
</I>&gt;<i> The troubles with this &quot;pray that it works&quot; design are not worth the
</I>&gt;<i> gains IMHO. If you think the event name must be &quot;User cache cleanup:
</I>&gt;<i> digest&quot; instead of just &quot;digest&quot;, &quot;Digest user cache&quot;, or similar, then
</I>&gt;<i> pass a beautiful event name as the second UserNameCache constructor
</I>&gt;<i> parameter, supplied by UserNameCache kids.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +void
</I>&gt;&gt;<i> +UserNameCache::Cleanup(void *data)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    debugs(29, 5, &quot;checkpoint&quot;);
</I>&gt;&gt;<i> +    if (!cbdataReferenceValid(data))
</I>&gt;&gt;<i> +        return;
</I>&gt;<i> 
</I>&gt;<i> I believe you are using eventAdd() with cbdata protection so the
</I>&gt;<i> reference has to be valid. If I have not missed some case where data may
</I>&gt;<i> be invalid, please remove this if statement.
</I>&gt;<i> 
</I>
Squid crashes on shutdown without this. It seems due to the event firing
race you mention below. Though this was fixed before a bug in validating
the cache objects was found, so it may have been a miss-fix.

The above line is what implements the &quot;dont do anything&quot; logic when the
event *does* reach the static callback.

&gt;<i> 
</I>&gt;&gt;<i> +    eventDelete(&amp;UserNameCache::Cleanup, this);
</I>&gt;<i> 
</I>&gt;<i> This call will lead to debug_trap() if the event callback happens to be
</I>&gt;<i> scheduled already (and, hence, out of the event queue but not fired
</I>&gt;<i> yet). There is currently no safe way to delete events with arguments,
</I>&gt;<i> especially long-lived ones like cleanup. Do not delete them if possible.
</I>&gt;<i> 
</I>&gt;<i> If the cache is no longer needed, delete the cache object itself. This
</I>&gt;<i> will prevent the cbdata-protected event from reaching the cache object.
</I>&gt;<i> If you cannot delete the cache object because of the bugs elsewhere,
</I>&gt;<i> perhaps you can use cleared store_ as a sign that the event should not
</I>&gt;<i> be processed any more?
</I>
We can only delete reliably on final shutdown due to cachemgr things
needing access to Cache(), which will re-allocate it all again uselessly.

Which is part of the reason Cache was inheriting from RunnerRegistry. We
have to have one runner per cache anyway, and the registry default
finshShutdown() takes care of all the deletion and cbdata invalidations
at the correct times without any new code.

&gt;<i> 
</I>&gt;<i> Or, alternatively, perhaps you can let the event fire (and just not
</I>&gt;<i> schedule the next one if there is nothing to cleanup)? Which brings me to:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +UserNameCache::UserNameCache(const char *name) :
</I>&gt;&gt;<i> +    cachename(name), cacheCleanupEventName(&quot;User cache cleanup: &quot;)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    debugs(29, 5, &quot;initializing &quot; &lt;&lt; name &lt;&lt; &quot; username cache&quot;);
</I>&gt;&gt;<i> +    cacheCleanupEventName.append(name);
</I>&gt;&gt;<i> +    eventAdd(cacheCleanupEventName.c_str(), &amp;UserNameCache::Cleanup,
</I>&gt;&gt;<i> +             this, ::Config.authenticateGCInterval, 1);
</I>&gt;<i> 
</I>&gt;<i> It may be better to avoid scheduling cache cleanups until there is
</I>&gt;<i> something to cleanup. This will require storing &quot;we have scheduled a
</I>&gt;<i> cleanup&quot; boolean, but it may make help folks that deal with Squids which
</I>&gt;<i> are idle for extended periods of time but still wake up every second [to
</I>&gt;<i> do nothing].
</I>
We were trying to avoid behavour changes as much as possible in this
round. I like though.

&gt;<i> 
</I>&gt;&gt;<i> +    eventAdd(self-&gt;cacheCleanupEventName.c_str(), &amp;UserNameCache::Cleanup,
</I>&gt;&gt;<i> +             self, ::Config.authenticateGCInterval, 1);
</I>&gt;<i> 
</I>&gt;&gt;<i> +    eventAdd(cacheCleanupEventName.c_str(), &amp;UserNameCache::Cleanup,
</I>&gt;&gt;<i> +             this, ::Config.authenticateGCInterval, 1);
</I>&gt;<i> 
</I>&gt;<i> Please avoid code duplication.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +void
</I>&gt;&gt;<i> +UserNameCache::Cleanup(void *data)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    debugs(29, 5, &quot;checkpoint&quot;);
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    // data is this in disguise
</I>&gt;&gt;<i> +    UserNameCache *self = static_cast&lt;UserNameCache *&gt;(data);
</I>&gt;<i> 
</I>&gt;<i> And now it is time to call self-&gt;cleanup(), to avoid doing a lot of
</I>&gt;<i> stuff inside the static method when you have a perfectly good object
</I>&gt;<i> available.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> HTH,
</I>&gt;<i> 
</I>&gt;<i> Alex.
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i> 
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003313.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
	<LI>Next message: <A HREF="003315.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3314">[ date ]</a>
              <a href="thread.html#3314">[ thread ]</a>
              <a href="subject.html#3314">[ subject ]</a>
              <a href="author.html#3314">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
