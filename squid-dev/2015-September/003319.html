<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fix for bug 4190
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20for%20bug%204190&In-Reply-To=%3C55ED165D.9090102%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003315.html">
   <LINK REL="Next"  HREF="003491.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fix for bug 4190</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20for%20bug%204190&In-Reply-To=%3C55ED165D.9090102%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Fix for bug 4190">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Sep  7 04:45:17 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003315.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
        <LI>Next message: <A HREF="003491.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3319">[ date ]</a>
              <a href="thread.html#3319">[ thread ]</a>
              <a href="subject.html#3319">[ subject ]</a>
              <a href="author.html#3319">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/06/2015 04:44 AM, Amos Jeffries wrote:
&gt;<i> On 6/09/2015 4:40 p.m., Alex Rousskov wrote:
</I>
&gt;&gt;&gt;<i> +class UserNameCache : public RegisteredRunner
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why is this called UserNameCache? It looks like this is a _user_ cache
</I>&gt;&gt;<i> [...] not user _name_ cache
</I>
&gt;<i> Legacy: it caches Auth::User keyed by-name.
</I>
Since this is a new name (unused in the old code), we can pick the right
name -- no legacy issues here. If this is the only thing that caches
Auth::User, then &quot;keyed by-name&quot; is not important.


&gt;<i> If we are going to change this it should probably be to
</I>&gt;<i> &quot;CredentialsCache&quot; I think.
</I>
Sounds good to me.


&gt;&gt;&gt;<i> +class UserNameCache : public RegisteredRunner
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please separate cache operation (the UserNameCache class) and
</I>&gt;&gt;<i> external-to-caches cache object creation/cleanup/destruction/etc.
</I>&gt;&gt;<i> initiation code (creating a dedicated child of RegisteredRunner for
</I>&gt;&gt;<i> that). This is a good idea in general because it simplifies code, but it
</I>&gt;&gt;<i> is especially desirable here because you have multiple caches but need
</I>&gt;&gt;<i> only one Runner object to initiate their creation/cleanup/destruction/etc.
</I>

&gt;<i> No. We cant have one runner.
</I>
Please note that the above comment was not about having one runner. The
discussion below does not change what the above comment is about:
Separating the UserNameCache class from the RegisteredRunner API.


&gt;<i> The only safe way to check if a Cache() call is usable without creating
</I>&gt;<i> a whole new cache as side effect is to check the current scheme config.
</I>
There is no reason to let a small problem create a bigger one. If the
static User::Cache() methods prevent you from doing something good
(i.e., using Runners interface properly), just fix those static methods.
AFAICT, it is trivial to avoid the side effect you are describing if needed.


&gt;<i> With one runner we hit a race condition between the scheme config being
</I>&gt;<i> re-configured and the runner needing to decide if the cache is worth
</I>&gt;<i> re-configuring or deleting.
</I>

That does not compute for me: If there is a race condition, it would
exist for one runner or three runners AFAICT, but I suspect this is not
important.

Also, please note that the runner does not &quot;need to decide&quot;. If making
that decision elsewhere is better, then the runner can simply forward
main.cc events to all existing caches. That &quot;elsewhere&quot; code will decide
which cache needs to be created or deleted. I am not saying the Runner
cannot decide, I am just saying there are many options here, but none of
them require the [stable/simple] runner to be the same object as the
[volatile and complex] cache object.


&gt;<i> It would also mean even more hard-coding of what schemes exist and need
</I>&gt;<i> to be managed by the runner, when schemes are supposed to be plug-n-play
</I>&gt;<i> components. AIUI the whole point of the runner API was to avoid that
</I>&gt;<i> kind of hard-coding.
</I>
The runner API is essentially about hiding modules from main.cc.
Hard-coding inside a runner class is OK (but is not required, of course).


&gt;<i> We can have N split runners controlling a cache each. Just doing nothing
</I>&gt;<i> if a CbcPointer they hold is invalid or null. That should work. But not
</I>&gt;<i> one runner juggling multiple optional schemes.
</I>
I am sure it is possible to make both &quot;one runner&quot; and &quot;N runners&quot;
design work. Pick the one you think is best overall.


&gt;<i> Doing the split though leads to direct code duplication. Since the
</I>&gt;<i> runner is just calling 1:1 methods on the cache, both have to have
</I>&gt;<i> identically matching lifetimes and ctor/dtor sequences need to line up
</I>&gt;<i> their actions with inverse dependency :: creating cache creates runner,
</I>&gt;<i> deleting runner deletes cache, creating runner early or deleting cache
</I>&gt;<i> early causes problems).
</I>
I do not know authentication code as well as you do, but I recommend
registering one runner regardless of individual cache existence and
letting that single runner call configuration/cleanup methods of the
caches that happen to exist at the time of the configuration/cleanup event.

If that simple approach requires some code adjustments (e.g., a
User::Cache() implementation without side effects), then make those
adjustments.


&gt;&gt;&gt;<i> +void
</I>&gt;&gt;&gt;<i> +UserNameCache::Cleanup(void *data)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +    debugs(29, 5, &quot;checkpoint&quot;);
</I>&gt;&gt;&gt;<i> +    if (!cbdataReferenceValid(data))
</I>&gt;&gt;&gt;<i> +        return;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I believe you are using eventAdd() with cbdata protection so the
</I>&gt;&gt;<i> reference has to be valid. If I have not missed some case where data may
</I>&gt;&gt;<i> be invalid, please remove this if statement.
</I>

&gt;<i> Squid crashes on shutdown without this. 
</I>
One more reason to remove that should-not-be-there code and fix the bug
causing the crash instead of trying to hide that bug like this. The code
path that I see checks the validity of that pointer before calling the
callback, so the extra check should not be necessary [unless there is a
bug elsewhere or a different code path that should not exist]:

&gt;<i> bool
</I>&gt;<i> EventDialer::canDial(AsyncCall &amp;call)
</I>&gt;<i> {
</I>...
&gt;<i>     if (isLockedArg &amp;&amp; !cbdataReferenceValid(theArg))
</I>&gt;<i>         return call.cancel(&quot;stale handler data&quot;);
</I>&gt;<i> }
</I>

&gt;<i> The above line is what implements the &quot;dont do anything&quot; logic when the
</I>&gt;<i> event *does* reach the static callback.
</I>
That line is already inside event.cc (as quoted above). If you do need
to repeat it, something went wrong.


&gt;&gt;&gt;<i> +    eventDelete(&amp;UserNameCache::Cleanup, this);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This call will lead to debug_trap() if the event callback happens to be
</I>&gt;&gt;<i> scheduled already (and, hence, out of the event queue but not fired
</I>&gt;&gt;<i> yet). There is currently no safe way to delete events with arguments,
</I>&gt;&gt;<i> especially long-lived ones like cleanup. Do not delete them if possible.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If the cache is no longer needed, delete the cache object itself. This
</I>&gt;&gt;<i> will prevent the cbdata-protected event from reaching the cache object.
</I>&gt;&gt;<i> If you cannot delete the cache object because of the bugs elsewhere,
</I>&gt;&gt;<i> perhaps you can use cleared store_ as a sign that the event should not
</I>&gt;&gt;<i> be processed any more?
</I>
&gt;<i> We can only delete reliably on final shutdown due to cachemgr things
</I>&gt;<i> needing access to Cache(), which will re-allocate it all again uselessly.
</I>
If you are talking about UserNameCache::endingShutdown(), then Squid
will run at least one main loop iteration after that call (as guaranteed
by the Runners API). Thus, it is not safe to call eventDelete() there.

And again, if the proposed Cache() implementation is in the way of doing
the right thing, change Cache() and/or its callers. It is a new method
so you can make it do whatever you need.


&gt;<i> Which is part of the reason Cache was inheriting from RunnerRegistry. We
</I>&gt;<i> have to have one runner per cache anyway, and the registry default
</I>&gt;<i> finshShutdown() takes care of all the deletion and cbdata invalidations
</I>&gt;<i> at the correct times without any new code.
</I>
I doubt endingShutdown() takes care of all the deletion and cbdata
invalidations at the correct times. If I saw no signs of problems in the
proposed code, I would be content with the &quot;it seems to work&quot; argument.
When I see problems, that argument alone is not enough, especially when
we are talking about such significant changes that affect multiple code
areas.


HTH,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003315.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
	<LI>Next message: <A HREF="003491.html">[squid-dev] [PATCH] Fix for bug 4190
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3319">[ date ]</a>
              <a href="thread.html#3319">[ thread ]</a>
              <a href="subject.html#3319">[ subject ]</a>
              <a href="author.html#3319">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
