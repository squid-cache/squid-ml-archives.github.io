<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] The next step towards: StoreID and metalink.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20The%20next%20step%20towards%3A%20StoreID%20and%20metalink.&In-Reply-To=%3C56006435.3030203%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003424.html">
   <LINK REL="Next"  HREF="003426.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] The next step towards: StoreID and metalink.</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20The%20next%20step%20towards%3A%20StoreID%20and%20metalink.&In-Reply-To=%3C56006435.3030203%40measurement-factory.com%3E"
       TITLE="[squid-dev] The next step towards: StoreID and metalink.">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Sep 21 20:10:29 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003424.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
        <LI>Next message: <A HREF="003426.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3425">[ date ]</a>
              <a href="thread.html#3425">[ thread ]</a>
              <a href="subject.html#3425">[ subject ]</a>
              <a href="author.html#3425">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/21/2015 01:28 PM, Amos Jeffries wrote:
&gt;<i> On 22/09/2015 6:19 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 09/19/2015 05:28 PM, Eliezer Croitoru wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> There are things which can help an ECAP module to decide how to do
</I>&gt;&gt;&gt;<i> things when handling metalinks related affairs.
</I>&gt;&gt;&gt;<i> For example, a cache object lookup from within an ECAP module.
</I>&gt;&gt;&gt;<i> So basically the logic of the ECAP module is 100% blind to the cache
</I>&gt;&gt;&gt;<i> internals.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> FWIW, there have been requests to expose host cache state to eCAP
</I>&gt;&gt;<i> adapters. It can be easily done (via Cache-Lookup metadata) for the
</I>&gt;&gt;<i> current request [in pre-cache REQMOD]. Doing so will even be compatible
</I>&gt;&gt;<i> with ICAP services.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Unfortunately, but most real use cases I know about actually need a true
</I>&gt;&gt;<i> &quot;cache lookup using an arbitrary request and/or StoreID&quot; functionality
</I>&gt;&gt;<i> and not just a &quot;is the current request likely to be served from cache?&quot;
</I>&gt;&gt;<i> answer. Supporting arbitrary lookups would require expanding eCAP API. I
</I>&gt;&gt;<i> would support such expansion, especially if we have several different
</I>&gt;&gt;<i> specific use cases the back the new API design up.
</I>
&gt;<i> What I have been thinking of for Metalinks was a StoreID helper that
</I>&gt;<i> took the requested URI and matched it against an index/DB of it own to
</I>&gt;<i> see if there was a previous ID for it.
</I>
Mapping a given request [URL] to Store ID(s) can be supported using
eCAP-supplied annotations without any eCAP API changes. An adapter can
simply return a &quot;use these IDs&quot; annotation with Store ID(s) that Squid
would recognize. That part requires straightforward Squid changes,
especially if only REQMOD support is needed.

My response to Eliezer question above was primarily about allowing an
eCAP adapter to ask the host application (such as Squid) whether an
arbitrary request [URI] is likely to be satisfied from its cache. That
part requires non-trivial eCAP API changes [and it would be good to have
more specific use cases to guide those changes].


&gt;<i> That could be paired with an eCAP RESPMOD adapter that scanned for
</I>&gt;<i> metalink URIs and added records to the StoreID index/DB for them. So
</I>&gt;<i> that future requests for those URIs got the now-cached content.
</I>
Sure.


&gt;<i> There are issues around invalidation to work out. Specifically when the
</I>&gt;<i> cached object gets replaced and has different metalinks attached, how to
</I>&gt;<i> find the obsolete ones. Doing a delete operation at speed may be
</I>&gt;<i> problematic.
</I>

&gt;<i> If the index/DB could be Squids internal cache index, or a special case
</I>&gt;<i> per-cache indexes like Transients but for the eCAP adapter. Then the
</I>&gt;<i> StoreID helper may not be even necessary. But that might be a lot more work.
</I>

If we want tight integration between Squid cache and an adapter,
including things like notifications about purged cached entries, then we
probably want the Store to &quot;adapt&quot; its cache _operations_ (add, update,
delete cache entry) rather than HTTP messages. In other words, in
addition to icap_service and ecap_service, we would have a cache_service
(that can still use eCAP API but send cache operations instead of real
HTTP messages for &quot;adaptation&quot;).


HTH,

Alex.

</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003424.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
	<LI>Next message: <A HREF="003426.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3425">[ date ]</a>
              <a href="thread.html#3425">[ thread ]</a>
              <a href="subject.html#3425">[ subject ]</a>
              <a href="author.html#3425">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
