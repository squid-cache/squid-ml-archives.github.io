<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] The next step towards: StoreID and metalink.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20The%20next%20step%20towards%3A%20StoreID%20and%20metalink.&In-Reply-To=%3C5600794B.6000701%40ngtech.co.il%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003425.html">
   <LINK REL="Next"  HREF="003429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] The next step towards: StoreID and metalink.</H1>
    <B>Eliezer Croitoru</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20The%20next%20step%20towards%3A%20StoreID%20and%20metalink.&In-Reply-To=%3C5600794B.6000701%40ngtech.co.il%3E"
       TITLE="[squid-dev] The next step towards: StoreID and metalink.">eliezer at ngtech.co.il
       </A><BR>
    <I>Mon Sep 21 21:40:27 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003425.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
        <LI>Next message: <A HREF="003429.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3426">[ date ]</a>
              <a href="thread.html#3426">[ thread ]</a>
              <a href="subject.html#3426">[ subject ]</a>
              <a href="author.html#3426">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Alex, Amos,

The first step now I am trying to grasp first what could be done in the 
current state of squid and ECAP without any changes.
Currently squid provides the methods to modify a request and\or response.

Basic StoreID support in a REQMOD should be possible in any case to 
allow an ECAP module to do those things and also sine it has more 
information about the request details it can decide better then the 
current StoreID helpers.
Leaving the StoreID aside and back to hashes.
Currently the ECAP module can calculate hashes on the fly and then in 
the end of the transaction write the result to either a log file or a DB.
For now the benefits i see from this is the option to find duplicate 
content based on the hash.
For example: running a db lookup for similar hashes or something like 
sort by hash.
pesudo:
iterate on the hashes and urls
if hash exists add the url to the array
else create a new hash to url array mapping.
then list urls with more then one url and get statistics for that.
* the statistics can be based on an access.log object/download size lookup

It would require some relational DB or some other way to store it in a 
K\V DB.

I think that in the current state of ECAP I can only build a statistics 
tool based on the ECAP module.

The actual cases which might benefit from a cache lookup would be metalinks.
And a &quot;If Modified Digest&quot; might also benefit from it.

There is another way to de-duplicate content for metalinks using cache 
objects planting\redirection.
The procedure would involve a setup which will allow for example a 302 
redirection planting.
I will describe it more in depth:
A response from a trusted source was found with metalink sources.
Once the hash was validated a series of objects &quot;insertion&quot; or 
&quot;implanting&quot; stage will start.
In this stage each and everyone of the link urls will be planted in the 
DB with a 302 redirect url.
(it can be inserted into squid cached objects or using an external DB)
The result will be:
If someone tries to contact a specific URL which is the DB, a 302 
redirection will be issued towards the already cached and hashed url.
it's not 100% full proof unless there is knowledge about the cache 
internals but as Amos suggested in the past, the store.log might be 
enough to make it possible to track cache removals and insertions.

Which of the ideas is a more realistic one compared to changing squid 
and\or ECAP?

Eliezer

On 21/09/2015 23:10, Alex Rousskov wrote:
&gt;<i> On 09/21/2015 01:28 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 22/09/2015 6:19 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 09/19/2015 05:28 PM, Eliezer Croitoru wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> There are things which can help an ECAP module to decide how to do
</I>&gt;&gt;&gt;&gt;<i> things when handling metalinks related affairs.
</I>&gt;&gt;&gt;&gt;<i> For example, a cache object lookup from within an ECAP module.
</I>&gt;&gt;&gt;&gt;<i> So basically the logic of the ECAP module is 100% blind to the cache
</I>&gt;&gt;&gt;&gt;<i> internals.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> FWIW, there have been requests to expose host cache state to eCAP
</I>&gt;&gt;&gt;<i> adapters. It can be easily done (via Cache-Lookup metadata) for the
</I>&gt;&gt;&gt;<i> current request [in pre-cache REQMOD]. Doing so will even be compatible
</I>&gt;&gt;&gt;<i> with ICAP services.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Unfortunately, but most real use cases I know about actually need a true
</I>&gt;&gt;&gt;<i> &quot;cache lookup using an arbitrary request and/or StoreID&quot; functionality
</I>&gt;&gt;&gt;<i> and not just a &quot;is the current request likely to be served from cache?&quot;
</I>&gt;&gt;&gt;<i> answer. Supporting arbitrary lookups would require expanding eCAP API. I
</I>&gt;&gt;&gt;<i> would support such expansion, especially if we have several different
</I>&gt;&gt;&gt;<i> specific use cases the back the new API design up.
</I>&gt;<i>
</I>&gt;&gt;<i> What I have been thinking of for Metalinks was a StoreID helper that
</I>&gt;&gt;<i> took the requested URI and matched it against an index/DB of it own to
</I>&gt;&gt;<i> see if there was a previous ID for it.
</I>&gt;<i>
</I>&gt;<i> Mapping a given request [URL] to Store ID(s) can be supported using
</I>&gt;<i> eCAP-supplied annotations without any eCAP API changes. An adapter can
</I>&gt;<i> simply return a &quot;use these IDs&quot; annotation with Store ID(s) that Squid
</I>&gt;<i> would recognize. That part requires straightforward Squid changes,
</I>&gt;<i> especially if only REQMOD support is needed.
</I>&gt;<i>
</I>&gt;<i> My response to Eliezer question above was primarily about allowing an
</I>&gt;<i> eCAP adapter to ask the host application (such as Squid) whether an
</I>&gt;<i> arbitrary request [URI] is likely to be satisfied from its cache. That
</I>&gt;<i> part requires non-trivial eCAP API changes [and it would be good to have
</I>&gt;<i> more specific use cases to guide those changes].
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> That could be paired with an eCAP RESPMOD adapter that scanned for
</I>&gt;&gt;<i> metalink URIs and added records to the StoreID index/DB for them. So
</I>&gt;&gt;<i> that future requests for those URIs got the now-cached content.
</I>&gt;<i>
</I>&gt;<i> Sure.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> There are issues around invalidation to work out. Specifically when the
</I>&gt;&gt;<i> cached object gets replaced and has different metalinks attached, how to
</I>&gt;&gt;<i> find the obsolete ones. Doing a delete operation at speed may be
</I>&gt;&gt;<i> problematic.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> If the index/DB could be Squids internal cache index, or a special case
</I>&gt;&gt;<i> per-cache indexes like Transients but for the eCAP adapter. Then the
</I>&gt;&gt;<i> StoreID helper may not be even necessary. But that might be a lot more work.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If we want tight integration between Squid cache and an adapter,
</I>&gt;<i> including things like notifications about purged cached entries, then we
</I>&gt;<i> probably want the Store to &quot;adapt&quot; its cache _operations_ (add, update,
</I>&gt;<i> delete cache entry) rather than HTTP messages. In other words, in
</I>&gt;<i> addition to icap_service and ecap_service, we would have a cache_service
</I>&gt;<i> (that can still use eCAP API but send cache operations instead of real
</I>&gt;<i> HTTP messages for &quot;adaptation&quot;).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i>
</I>
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003425.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
	<LI>Next message: <A HREF="003429.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3426">[ date ]</a>
              <a href="thread.html#3426">[ thread ]</a>
              <a href="subject.html#3426">[ subject ]</a>
              <a href="author.html#3426">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
