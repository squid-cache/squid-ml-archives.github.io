<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] The next step towards: StoreID and metalink.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20The%20next%20step%20towards%3A%20StoreID%20and%20metalink.&In-Reply-To=%3C5600960E.5080706%40ngtech.co.il%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003429.html">
   <LINK REL="Next"  HREF="003432.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] The next step towards: StoreID and metalink.</H1>
    <B>Eliezer Croitoru</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20The%20next%20step%20towards%3A%20StoreID%20and%20metalink.&In-Reply-To=%3C5600960E.5080706%40ngtech.co.il%3E"
       TITLE="[squid-dev] The next step towards: StoreID and metalink.">eliezer at ngtech.co.il
       </A><BR>
    <I>Mon Sep 21 23:43:10 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003429.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
        <LI>Next message: <A HREF="003432.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3433">[ date ]</a>
              <a href="thread.html#3433">[ thread ]</a>
              <a href="subject.html#3433">[ subject ]</a>
              <a href="author.html#3433">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 22/09/2015 00:57, Amos Jeffries wrote:
&gt;<i> Using 302 kind of defeats the purpose of metalinks: that the content can
</I>&gt;<i> be fetched from alternative URLs if one breaks in any way (by the
</I>&gt;<i> client, or by Squid on revalidation retries).
</I>
 &gt; Using StoreID helper to re-write the IDs to the same cached content is
 &gt; more inline with the metalinks model, in that Squid and/or client can
 &gt; revalidate the cached object from whatever URI the client is fetching
 &gt; and it updates all the other ones the StoreID maps to that sfileno ID.

You are right.
Indeed it defeats StoreID but there is another side to the whole picture.
The squid re-validation code assumes that the ETAG should be similar 
between servers so one issue is that using ETAG with metalinks kind of 
beats any squid cache basic validating logic.
As a base rule ETAG should not be present in a case that metalink 
headers of hashes are present or it should be consistent in each of the 
mirror servers.
So in some environments the usage of 302 with an override option in the 
url query terms might be the right choice.(I think it's the less proper 
solution and this is one of the reasons I was designing StoreID as it is).

&gt;<i> Note that all this use of eCAP and StoreID is for PoC testing how
</I>&gt;<i> metalinks works. Long-term these actions should all be an internal
</I>&gt;<i> feature of Squid. If we find that Squid needs to be altered to make the
</I>&gt;<i> PoC work then we are probably better just patching the related part of
</I>&gt;<i> metalinks operation in directly, or re-designing the PoC.
</I>
OK.
And for the PoC part of the issue.
I would like to first verify and test the influence of such hashing 
calculations(in this case SHA256) on the server operation under load.
I am using the module on my LAN proxy with SSL-bump ON to make sure how 
I feel the effect from the module.
I have observed that the actual download rates for a 20Mbps line works 
just fine but this is very far from real traffic on a loaded server.
Even if I like the metalinks concepts there is also the possibility of a 
wrong design.
So before proofing the concept itself I am looking for test candidates 
that will run the module and if possible on a controlled production 
environment.

Else then that I had the idea of using an internal StoreID for hashed 
content such as &quot;<A HREF="http://hash.squid.internal/sha256/calculated_hash">http://hash.squid.internal/sha256/calculated_hash</A>&quot;.
If we trust the source server we don't have any issue to use the StoreID 
and apply it without any relationship to the actual hashing of the content.
If we partially trust the source we can &quot;test&quot; and black\white\grey list 
the source metalink hash accuracy.

So there are couple models to how we can treat metalinks.
- Fully trust source
- Partially trust source
- Training\checking to verify if we trust the source

With the above model we can put the whole internal cache lookup logic 
aside and think about something global.

What do you think about the trust idea I had in mind? if you do have 
another trust approach please share your ideas.

Eliezer
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003429.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
	<LI>Next message: <A HREF="003432.html">[squid-dev] The next step towards: StoreID and metalink.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3433">[ date ]</a>
              <a href="thread.html#3433">[ thread ]</a>
              <a href="subject.html#3433">[ subject ]</a>
              <a href="author.html#3433">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
