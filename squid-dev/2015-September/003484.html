<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Fake CONNECT requests during SSL Bump
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Fake%20CONNECT%20requests%20during%20SSL%20Bump&In-Reply-To=%3C56073FD9.4060102%40ngtech.co.il%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="003483.html">
   <LINK REL="Next"  HREF="003461.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Fake CONNECT requests during SSL Bump</H1>
    <B>Eliezer Croitoru</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Fake%20CONNECT%20requests%20during%20SSL%20Bump&In-Reply-To=%3C56073FD9.4060102%40ngtech.co.il%3E"
       TITLE="[squid-dev] Fake CONNECT requests during SSL Bump">eliezer at ngtech.co.il
       </A><BR>
    <I>Sun Sep 27 01:01:13 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="003483.html">[squid-dev] Fake CONNECT requests during SSL Bump
</A></li>
        <LI>Next message: <A HREF="003461.html">[squid-dev] Fake CONNECT requests during SSL Bump
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3484">[ date ]</a>
              <a href="thread.html#3484">[ thread ]</a>
              <a href="subject.html#3484">[ subject ]</a>
              <a href="author.html#3484">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>* Now I see that the question was sent to your private email instead of 
squid-dev.

So after you have confirmed my assumption I can understand why actually 
the external_acl helpers interface do not slow down squid.
So for example I wrote a helper in golang 
[<A HREF="https://github.com/elico/squidblocker-client">https://github.com/elico/squidblocker-client</A>] which can actually handle 
a huge amount of requests per second utilizing the native concurrency of 
golang.
I have tried in the past to compare perl\python\ruby and other 
interpreted languages and they seem to lack the simplicity to handle 
concurrent request.
And I must say that when I am considering now in what language to use 
for a helper then just because of the concurrency simplicity compared to 
other languages I will first try golang.

I have replaced squidguard with my client and DB services and using the 
external_acl helper interface I managed to handle what more then 40 
squidguard helpers was required for with barely 5 helpers in golang.
I am still struggling with a way to handle ICAP requests properly in 
golang but now that you have mentioned threading in a C++ program it 
just gave me a rejection feeling.
I do not want to say bad things about C++ because I see how it is such a 
great language but for now C++ threading kind of frighten me and I 
assume that it's a blocker for me to try and do something in it.

And back to the acl eCAP module\service.
I have seen something in the adapter_async about threading but haven't 
had the chance to actually read it not talking about understanding it.
I also cannot think about an advanced acl adaptation service that will 
not use some DB or other socket based code(which by nature blocks).
For example basic authorization such as mysql, LDAP, session, RADIUS.
(As a side note I want to list eCAP modules that are open source at 
github that I know about:
- <A HREF="https://github.com/maxpmaxp/ecap-exif">https://github.com/maxpmaxp/ecap-exif</A>
- <A HREF="https://github.com/creamy/ecap-mongo">https://github.com/creamy/ecap-mongo</A>
- <A HREF="https://github.com/c-rack/squid-ecap-gzip">https://github.com/c-rack/squid-ecap-gzip</A>
- <A HREF="https://github.com/billowkiller/ecap">https://github.com/billowkiller/ecap</A>
- <A HREF="https://github.com/Securepoint/squid-ecap-av">https://github.com/Securepoint/squid-ecap-av</A>
- <A HREF="https://github.com/hynnet/ecap_clamav_adapter">https://github.com/hynnet/ecap_clamav_adapter</A>
)

So even converting any existing squid helpers will be turned into a non 
simple task since most of the current helpers by default do not 
implement concurrency at all.

So to sum all the above:
If I would have been asked to choose what to use in order to implement 
some acl helper I would prefer(based on my current knowledge in 
programming and CS in general)
1 - external_acl helper (done already)
2 - ICAP service (done for GET request and struggling with other methods 
and bodies handling)
3 - eCAP service (It is actually writing a boxed C++ application aka 
module inside another service and just mentioning threading rejects me)

Eliezer

On 27/09/2015 02:36, Alex Rousskov wrote:
&gt;<i> On 09/26/2015 04:52 PM, Eliezer Croitoru wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> if I will run some DB action inside an eCAP module it
</I>&gt;&gt;<i> should be done in a very specific way to not block the whole squid
</I>&gt;&gt;<i> process or to use an ICAP service instead.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I wanted to verify that I am right on the assumption.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You are correct:
</I>&gt;<i>
</I>&gt;<i> * The ICAP client implementation in Squid does not block the whole Squid
</I>&gt;<i> process because communication is done using non-blocking socket I/O.
</I>&gt;<i> What happens on the other side of that ICAP connection depends on the
</I>&gt;<i> ICAP server implementation. Some ICAP servers never create threads, some
</I>&gt;<i> create a thread per transaction, some support a pool of threads, and
</I>&gt;<i> some let ICAP adapters decide how to handle each transaction.
</I>&gt;<i>
</I>&gt;<i> * The eCAP client (a.k.a. &quot;host&quot;) implementation has to block the whole
</I>&gt;<i> host process because it has to use regular C++ function calls. What
</I>&gt;<i> happens on the other side of that function call is the eCAP adapter
</I>&gt;<i> responsibility. If your adapter can return from all eCAP function calls
</I>&gt;<i> &quot;fast&quot;, there is no need to worry (and you are saving a lot by not
</I>&gt;<i> having to go over a TCP connection). If you cannot answer some of the
</I>&gt;<i> host questions &quot;immediately&quot;, then you have to implement an async eCAP
</I>&gt;<i> adapter that uses threads or other non-blocking mechanisms to shield the
</I>&gt;<i> host application from &quot;slow&quot; or &quot;blocking&quot; adapter code.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I></PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003483.html">[squid-dev] Fake CONNECT requests during SSL Bump
</A></li>
	<LI>Next message: <A HREF="003461.html">[squid-dev] Fake CONNECT requests during SSL Bump
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3484">[ date ]</a>
              <a href="thread.html#3484">[ thread ]</a>
              <a href="subject.html#3484">[ subject ]</a>
              <a href="author.html#3484">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
