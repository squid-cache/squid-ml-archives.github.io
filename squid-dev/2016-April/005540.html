<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Increase request buffer size to 64kb
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Increase%20request%20buffer%20size%20to%2064kb&In-Reply-To=%3CCAGUJm7bJkYH%3DM2FA1rnyf92Gt%2B2iBCD3KOtRJSxwbMfGbpN0cA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005538.html">
   <LINK REL="Next"  HREF="005590.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Increase request buffer size to 64kb</H1>
    <B>Nathan Hoad</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Increase%20request%20buffer%20size%20to%2064kb&In-Reply-To=%3CCAGUJm7bJkYH%3DM2FA1rnyf92Gt%2B2iBCD3KOtRJSxwbMfGbpN0cA%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] Increase request buffer size to 64kb">nathan at getoffmalawn.com
       </A><BR>
    <I>Mon Apr  4 06:29:05 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005538.html">[squid-dev] [PATCH] Increase request buffer size to 64kb
</A></li>
        <LI>Next message: <A HREF="005590.html">[squid-dev] [PATCH] Increase request buffer size to 64kb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5540">[ date ]</a>
              <a href="thread.html#5540">[ thread ]</a>
              <a href="subject.html#5540">[ subject ]</a>
              <a href="author.html#5540">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

One large reply again. Attached is a patch with all the earlier
changes recommended by Alex. Most notably this removes the change for
read_ahead_gap, leaving the default at 16kb, and opting to use
read_ahead_gap for this rather than introduce a new option.

Alex,

&gt;&gt;<i> Make the size of the buffer on Http::Stream configurable.
</I>&gt;<i>
</I>&gt;<i> s/buffer on Http::Stream/ClientStream buffer/
</I>
That would make it inaccurate - there's still one use of
clientStreamInit that does not use this option, in
client_side_request.cc:clientBeginRequest, that works back to
ESISegment::buf, which is a char[HTTP_REQBUF_SZ]. I could convert
ESISegment::buf to a MemBlob and fix the call location in
ESIInclude::Start, but I would not be able to test the code at all, as
I've not used ESI before.

On 4 April 2016 at 10:32, Alex Rousskov
&lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
&gt;<i> On 03/30/2016 11:50 PM, Nathan Hoad wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Alex, I've tried 8, 16, 32, 128 and 512 KB values - all sizes leading
</I>&gt;&gt;<i> up to 64 KB scaled appropriately. 128 and 512 were the same or
</I>&gt;&gt;<i> slightly worse than 64, so I think 64 KB is the &quot;best value&quot;.
</I>&gt;<i>
</I>&gt;<i> Sounds good, but it is even more important that you have explained *why*
</I>&gt;<i> below.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> On 30 March 2016 at 21:29, Amos Jeffries &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid3 at treenet.co.nz</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> One thing you need to keep in mind with all this is that the above
</I>&gt;&gt;&gt;<i> macros *does not* configure the network I/O buffers.
</I>&gt;<i>
</I>&gt;&gt;<i> I don't think this is quite true - I don't think it's intentional, but
</I>&gt;&gt;<i> I am lead to believe that HTTP_REQBUF_SZ does influence network IO
</I>&gt;&gt;<i> buffers in some way. See below.
</I>&gt;<i>
</I>&gt;<i> You are probably both right: HTTP_REQBUF_SZ influences network I/O but
</I>&gt;<i> not necessarily all network I/O buffer capacities. In other words,
</I>&gt;<i> increasing HTTP_REQBUF_SZ improves uncachable miss performance until
</I>&gt;<i> HTTP_REQBUF_SZ matches the size of the second smallest buffer (or I/O
</I>&gt;<i> size) in the buffer chain. In your test, that limit was read_ahead_gap.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> In the long-term plan those internal uses will be replaced by SBuf
</I>&gt;<i>
</I>&gt;<i> ... or MemBlob or something that does not exist yet but uses MemBlob.
</I>&gt;<i>
</I>&gt;<i> SBuf it trying to provide &quot;everything to everybody&quot; and, naturally,
</I>&gt;<i> becomes a bad choice in some situations with strict requirements (e.g.,
</I>&gt;<i> when one has to preserve raw buffer pointer but does not want single
</I>&gt;<i> buffer content ownership).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Looking purely at system calls, it shows the reads from the upstream
</I>&gt;&gt;<i> server are being read in 16 KB chunks, where as writes to the client
</I>&gt;&gt;<i> are done in 4 KB chunks. With the patch, the writes to the client
</I>&gt;&gt;<i> increase to 16 KB, so it appears that HTTP_REQBUF_SZ does influence
</I>&gt;&gt;<i> network IO in this way.
</I>&gt;<i>
</I>&gt;<i> Naturally: One cannot write using 16 KB chunks when the data goes
</I>&gt;<i> through a 4KB buffer. Please note that the position of that 4KB buffer
</I>&gt;<i> in the buffer chain is almost irrelevant -- the weakest link in the
</I>&gt;<i> chain determines &quot;bytes pipelining&quot; or &quot;bytes streaming&quot; speed.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> However post-patch the improvement is quite
</I>&gt;&gt;<i> substantial, as the write(2) calls are now using the full 64 KB
</I>&gt;&gt;<i> buffer.
</I>&gt;<i>
</I>&gt;<i> This is an important finding! It shows that read_ahead_gap documentation
</I>&gt;<i> lies or at least misleads: Evidently, that directive controls not just
</I>&gt;<i> accumulation of data but [maximum] network read sizes, at least for
</I>&gt;<i> HTTP. Please fix that documentation in your next patch revision.
</I>
Done.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> At this stage, I'm not entirely sure what the best course of action
</I>&gt;&gt;<i> is. I'm happy to investigate things further, if people have
</I>&gt;&gt;<i> suggestions. read_ahead_gap appears to influence downstream write
</I>&gt;&gt;<i> buffer sizes, at least up to the maximum of HTTP_REQBUF_SZ.
</I>&gt;<i>
</I>&gt;<i> In other words, Squid Client (http.cc and clients/*) is able to give
</I>&gt;<i> Squid Server (client_side*cc and servers/*) the results of a single
</I>&gt;<i> Client network read (i.e., a single read from the origin server of
</I>&gt;<i> peer). The result is copied to the ClientStream StoreIOBuffer. Thus, if
</I>&gt;<i> we do not want to slow Squid down artificially, the StoreIOBuffer
</I>&gt;<i> capacity should match the maximum Client read I/O size.
</I>&gt;<i>
</I>&gt;<i> Do we use that StoreIOBuffer to write(2) to the HTTP client? If not,
</I>&gt;<i> what controls the I/O buffer size for writing to the HTTP client?
</I>
We do yes - that buffer makes it through
client_side.cc:clientSocketRecipient, Http::One::Server::handleReply,
and finally Http::Stream::sendBody, where the actual write is
performed.


&gt;<i>
</I>&gt;<i>Http::One::Server::handleReply
</I>&gt;&gt;<i> It would
</I>&gt;&gt;<i> be nice if that buffer size was independently run-time configurable
</I>&gt;<i>
</I>&gt;<i> Actually, it would be nice if the buffer sizes just matched, avoiding
</I>&gt;<i> both artificial slowdown and the need for careful configuration in most
</I>&gt;<i> cases.
</I>&gt;<i>
</I>&gt;<i> Whether configuration is also desirable in some special situations is a
</I>&gt;<i> separate question. If nobody comes forward with such a special
</I>&gt;<i> situation/need, then we may be better off avoiding adding a yet another
</I>&gt;<i> tunable and simply tying ClientStream buffer capacity to the
</I>&gt;<i> read_ahead_gap value. The only reason to add a configuration option
</I>&gt;<i> [that nobody we know needs] would be backward compatibility.
</I>
I've opted to remove the configuration option completely, making the
buffer size in Http::Stream obey read_ahead_gap. If such a use case
does come forward, it's trivial to add a configuration option for it.

&gt;<i>
</I>&gt;<i> If backward compatibility is deemed important here, we can add a
</I>&gt;<i> configuration option, but change the _default_ buffer size to track
</I>&gt;<i> read_ahead_gap and, hence, avoid artificial slowdown (at least in v4).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> How much impact does increasing read_ahead_gap and HTTP_REQBUF_SZ by B
</I>&gt;<i> and G bytes, respectively have on overall Squid memory usage? Is that
</I>&gt;<i> B+G per concurrent transaction, roughly? Are any other buffer capacities
</I>&gt;<i> that depend on those two parameters?
</I>&gt;<i>
</I>&gt;<i> If the increase is B+G then your changes increase Squid RAM footprint by
</I>&gt;<i> C*(60+48) KB where C is the number of concurrent master transactions. A
</I>&gt;<i> Squid dealing with 1000 concurrent transactions would see its RAM usage
</I>&gt;<i> increase by about 100 MB, which is not terrible (and decreased response
</I>&gt;<i> times may reduce the number of concurrent transactions, partially
</I>&gt;<i> mitigating that increase). The commit message (and release notes) should
</I>&gt;<i> disclose the estimated increase though.
</I>
Looking at it, yes that is correct - the increase is indeed C*(60+48)
KB. We could (and I have) instead opt to leave the default for
read_ahead_gap at 16kb, at which point the increase is C*12 KB, which
feels nicer to me, with a note in the documentation that increasing
this number may improve throughput at the cost of memory (and should
be tested).

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>
&gt;<i> AFAICT, reply_header_max_size affects the HTTP response reading only
</I>&gt;<i> until the headers are parsed:
</I>&gt;<i>
</I>&gt;&gt;<i>     const int limitBuffer = (flags.headers_parsed ? Config.readAheadGap : Config.maxReplyHeaderSize);
</I>&gt;<i>
</I>&gt;<i> This is actually kind of wrong because the first read should be
</I>&gt;<i> something like the maximum of those two values: Restricting response
</I>&gt;<i> header size should not restrict response body data prefetch during the
</I>&gt;<i> first I/O. Nathan, if you agree, fixing this would be in your patch
</I>&gt;<i> scope IMO!
</I>
That line is... not very nice. It's assigning to an int,
Config.readAheadGap is an int64_t, and Config.maxReplyHeaderSize is
size_t. Making the change you recommended reveals this via a
compilation error:

http.cc: In member function ‘bool HttpStateData::maybeMakeSpaceAvailable(bool)’:
http.cc:1547:125: error: no matching function for call to
‘max(size_t&amp;, int64_t&amp;)’
     const int limitBuffer = (flags.headers_parsed ?
Config.readAheadGap : max(Config.maxReplyHeaderSize,
Config.readAheadGap));

                                                      ^
In file included from ../compat/compat.h:100:0,
                 from ../include/squid.h:43,
                 from http.cc:16:
../compat/compat_shared.h:142:1: note: candidate: template&lt;class A&gt;
const A&amp; max(const A&amp;, const A&amp;)
 max(A const &amp; lhs, A const &amp; rhs)
 ^
../compat/compat_shared.h:142:1: note:   template argument
deduction/substitution failed:
http.cc:1547:125: note:   deduced conflicting types for parameter
‘const A’ (‘long unsigned int’ and ‘int64_t {aka long int}’)
     const int limitBuffer = (flags.headers_parsed ?
Config.readAheadGap : max(Config.maxReplyHeaderSize,
Config.readAheadGap));

I'm happy to include the change - just let me know which way I should
go with this and I'll resubmit.

Thank you,

Nathan.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: recv-buffer-v4.patch
Type: text/x-patch
Size: 7336 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160404/a3fa843d/attachment-0001.bin">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160404/a3fa843d/attachment-0001.bin</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005538.html">[squid-dev] [PATCH] Increase request buffer size to 64kb
</A></li>
	<LI>Next message: <A HREF="005590.html">[squid-dev] [PATCH] Increase request buffer size to 64kb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5540">[ date ]</a>
              <a href="thread.html#5540">[ thread ]</a>
              <a href="subject.html#5540">[ subject ]</a>
              <a href="author.html#5540">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
