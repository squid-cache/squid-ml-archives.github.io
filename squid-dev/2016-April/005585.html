<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] libmem API cleanup pt2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20libmem%20API%20cleanup%20pt2&In-Reply-To=%3C570CDC9C.6040608%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005580.html">
   <LINK REL="Next"  HREF="005607.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] libmem API cleanup pt2</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20libmem%20API%20cleanup%20pt2&In-Reply-To=%3C570CDC9C.6040608%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] libmem API cleanup pt2">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Apr 12 11:31:40 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005580.html">[squid-dev] [PATCH] Do not hide important/critical messages
</A></li>
        <LI>Next message: <A HREF="005607.html">[squid-dev] [PATCH] libmem API cleanup pt2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5585">[ date ]</a>
              <a href="thread.html#5585">[ thread ]</a>
              <a href="subject.html#5585">[ subject ]</a>
              <a href="author.html#5585">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is the first of the followup patches I promised when applying the
un-polished bug 4438 patch to 4.0.8.


Convert all the objects using the libmem &quot;old API&quot; for as-needed pools
to using the MEMPROXY_CLASS() API which is better designed for late
initialization.

The GetPool(type) function is now guaranteed to produce a
pre-initialized pool for all valid pool types. Except in the case where
it is recursively being used by Mem::Init() to perform that initialization.

Amos
-------------- next part --------------
=== modified file 'src/ClientInfo.h'
--- src/ClientInfo.h	2016-01-01 00:12:18 +0000
+++ src/ClientInfo.h	2016-04-08 12:48:24 +0000
@@ -15,6 +15,7 @@
 #include &quot;hash.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;LogTags.h&quot;
+#include &quot;mem/forward.h&quot;
 #include &quot;typedefs.h&quot;
 
 #include &lt;deque&gt;
@@ -25,12 +26,21 @@
 
 class ClientInfo
 {
+    MEMPROXY_CLASS(ClientInfo);
+
 public:
+    explicit ClientInfo(const Ip::Address &amp;);
+    ~ClientInfo();
+
     hash_link hash;             /* must be first */
 
     Ip::Address addr;
 
-    struct {
+    struct _protocol {
+        _protocol() : n_requests(0) {
+            memset(result_hist, 0, sizeof(result_hist));
+        }
+
         int result_hist[LOG_TYPE_MAX];
         int n_requests;
         ByteCounter kbytes_in;
@@ -38,7 +48,9 @@
         ByteCounter hit_kbytes_out;
     } Http, Icp;
 
-    struct {
+    struct _cutoff {
+        _cutoff() : time(0), n_req(0), n_denied(0) {}
+
         time_t time;
         int n_req;
         int n_denied;

=== modified file 'src/HttpHdrContRange.cc'
--- src/HttpHdrContRange.cc	2016-01-01 00:12:18 +0000
+++ src/HttpHdrContRange.cc	2016-04-11 16:15:31 +0000
@@ -117,7 +117,7 @@
 HttpHdrContRange *
 httpHdrContRangeCreate(void)
 {
-    HttpHdrContRange *r = (HttpHdrContRange *)memAllocate(MEM_HTTP_HDR_CONTENT_RANGE);
+    HttpHdrContRange *r = new HttpHdrContRange;
     r-&gt;spec.offset = r-&gt;spec.length = range_spec_unknown;
     r-&gt;elength = range_spec_unknown;
     return r;
@@ -129,8 +129,8 @@
     HttpHdrContRange *r = httpHdrContRangeCreate();
 
     if (!httpHdrContRangeParseInit(r, str)) {
-        httpHdrContRangeDestroy(r);
-        r = NULL;
+        delete r;
+        return nullptr;
     }
 
     return r;
@@ -182,13 +182,6 @@
     return 1;
 }
 
-void
-httpHdrContRangeDestroy(HttpHdrContRange * range)
-{
-    assert(range);
-    memFree(range, MEM_HTTP_HDR_CONTENT_RANGE);
-}
-
 HttpHdrContRange *
 httpHdrContRangeDup(const HttpHdrContRange * range)
 {

=== modified file 'src/HttpHdrContRange.h'
--- src/HttpHdrContRange.h	2016-01-01 00:12:18 +0000
+++ src/HttpHdrContRange.h	2016-04-12 05:33:03 +0000
@@ -9,16 +9,18 @@
 #ifndef SQUID_HTTPHDRCONTRANGE_H
 #define SQUID_HTTPHDRCONTRANGE_H
 
+#include &quot;HttpHeaderRange.h&quot;
+
 class HttpHeader;
 
-/* for HttpHdrRangeSpec */
-#include &quot;HttpHeaderRange.h&quot;
-
 /** HTTP Content-Range: header field */
 class HttpHdrContRange
 {
+    MEMPROXY_CLASS(HttpHdrContRange);
 
 public:
+    HttpHdrContRange() : elength(0) {}
+
     HttpHdrRangeSpec spec;
     int64_t elength;        /**&lt; entity length, not content length */
 };
@@ -29,7 +31,6 @@
 HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
 /** returns true if range is valid; inits HttpHdrContRange */
 int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
-void httpHdrContRangeDestroy(HttpHdrContRange * crange);
 HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
 void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packable * p);
 /** inits with given spec */

=== modified file 'src/HttpHeaderTools.cc'
--- src/HttpHeaderTools.cc	2016-04-01 18:12:14 +0000
+++ src/HttpHeaderTools.cc	2016-04-11 16:13:21 +0000
@@ -78,7 +78,7 @@
     assert(hdr &amp;&amp; ent_len &gt;= 0);
     httpHdrContRangeSet(cr, spec, ent_len);
     hdr-&gt;putContRange(cr);
-    httpHdrContRangeDestroy(cr);
+    delete cr;
 }
 
 /**

=== modified file 'src/HttpReply.cc'
--- src/HttpReply.cc	2016-03-20 16:20:28 +0000
+++ src/HttpReply.cc	2016-04-11 16:12:58 +0000
@@ -375,7 +375,7 @@
     }
 
     if (content_range) {
-        httpHdrContRangeDestroy(content_range);
+        delete content_range;
         content_range = NULL;
     }
 }

=== modified file 'src/PeerSelectState.h'
--- src/PeerSelectState.h	2016-01-01 00:12:18 +0000
+++ src/PeerSelectState.h	2016-04-09 07:51:31 +0000
@@ -11,10 +11,11 @@
 
 #include &quot;AccessLogEntry.h&quot;
 #include &quot;acl/Checklist.h&quot;
-#include &quot;cbdata.h&quot;
+#include &quot;base/CbcPointer.h&quot;
 #include &quot;comm/forward.h&quot;
 #include &quot;hier_code.h&quot;
 #include &quot;ip/Address.h&quot;
+#include &quot;mem/forward.h&quot;
 #include &quot;PingData.h&quot;
 
 class HttpRequest;
@@ -37,8 +38,16 @@
  */
 class FwdServer
 {
+    MEMPROXY_CLASS(FwdServer);
+
 public:
-    CachePeer *_peer;                /* NULL --&gt; origin server */
+    FwdServer(CachePeer *p, hier_code c) :
+        _peer(p),
+        code(c),
+        next(nullptr)
+    {}
+
+    CbcPointer&lt;CachePeer&gt; _peer;                /* NULL --&gt; origin server */
     hier_code code;
     FwdServer *next;
 };

=== modified file 'src/client_db.cc'
--- src/client_db.cc	2016-01-01 00:12:18 +0000
+++ src/client_db.cc	2016-04-09 03:26:14 +0000
@@ -52,32 +52,40 @@
 #define CLIENT_DB_HASH_SIZE 467
 #endif
 
+ClientInfo::ClientInfo(const Ip::Address &amp;ip) :
+    addr(ip),
+    n_established(0),
+    last_seen(0)
+#if USE_DELAY_POOLS
+    , writeSpeedLimit(0),
+    prevTime(0),
+    bucketSize(0),
+    bucketSizeLimit(0),
+    writeLimitingActive(false),
+    firstTimeConnection(true),
+    quotaQueue(nullptr),
+    rationedQuota(0),
+    rationedCount(0),
+    selectWaiting(false),
+    eventWaiting(false)
+#endif
+{
+    debugs(77, 9, &quot;ClientInfo constructed, this=&quot; &lt;&lt; static_cast&lt;void*&gt;(this));
+
+#if USE_DELAY_POOLS
+    getCurrentTime();
+    /* put current time to have something sensible here */
+    prevTime = current_dtime;
+#endif
+
+    char *buf = static_cast&lt;char*&gt;(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
+    hash.key = addr.toStr(buf,MAX_IPSTRLEN);
+}
+
 static ClientInfo *
-
 clientdbAdd(const Ip::Address &amp;addr)
 {
-    ClientInfo *c;
-    char *buf = static_cast&lt;char*&gt;(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
-    c = (ClientInfo *)memAllocate(MEM_CLIENT_INFO);
-    debugs(77, 9, &quot;ClientInfo constructed, this=&quot; &lt;&lt; c);
-    c-&gt;hash.key = addr.toStr(buf,MAX_IPSTRLEN);
-    c-&gt;addr = addr;
-#if USE_DELAY_POOLS
-    /* setup default values for client write limiter */
-    c-&gt;writeLimitingActive=false;
-    c-&gt;writeSpeedLimit=0;
-    c-&gt;bucketSize = 0;
-    c-&gt;firstTimeConnection=true;
-    c-&gt;quotaQueue = NULL;
-    c-&gt;rationedQuota = 0;
-    c-&gt;rationedCount = 0;
-    c-&gt;selectWaiting = false;
-    c-&gt;eventWaiting = false;
-
-    /* get current time */
-    getCurrentTime();
-    c-&gt;prevTime=current_dtime;/* put current time to have something sensible here */
-#endif
+    ClientInfo *c = new ClientInfo(addr);
     hash_join(client_table, &amp;c-&gt;hash);
     ++statCounter.client_http.clients;
 
@@ -331,17 +339,21 @@
 clientdbFreeItem(void *data)
 {
     ClientInfo *c = (ClientInfo *)data;
-    safe_free(c-&gt;hash.key);
+    delete c;
+}
+
+ClientInfo::~ClientInfo()
+{
+    safe_free(hash.key);
 
 #if USE_DELAY_POOLS
-    if (CommQuotaQueue *q = c-&gt;quotaQueue) {
+    if (CommQuotaQueue *q = quotaQueue) {
         q-&gt;clientInfo = NULL;
         delete q; // invalidates cbdata, cancelling any pending kicks
     }
 #endif
 
-    debugs(77, 9, &quot;ClientInfo destructed, this=&quot; &lt;&lt; c);
-    memFree(c, MEM_CLIENT_INFO);
+    debugs(77, 9, &quot;ClientInfo destructed, this=&quot; &lt;&lt; static_cast&lt;void*&gt;(this));
 }
 
 void

=== modified file 'src/dns_internal.cc'
--- src/dns_internal.cc	2016-04-03 23:41:58 +0000
+++ src/dns_internal.cc	2016-04-10 03:22:17 +0000
@@ -1626,7 +1626,6 @@
     }
 
     if (!init) {
-        memDataInit(MEM_IDNS_QUERY, &quot;idns_query&quot;, sizeof(idns_query), 0);
         memset(RcodeMatrix, '\0', sizeof(RcodeMatrix));
         idns_lookup_hash = hash_create((HASHCMP *) strcmp, 103, hash_string);
         ++init;

=== modified file 'src/fqdncache.cc'
--- src/fqdncache.cc	2016-01-01 00:12:18 +0000
+++ src/fqdncache.cc	2016-04-10 13:16:36 +0000
@@ -72,7 +72,6 @@
 #define FQDN_HIGH_WATER      95
 
 /**
- \ingroup FQDNCacheAPI
  * The data structure used for storing name-address mappings
  * is a small hashtable (static hash_table *fqdn_table),
  * where structures of type fqdncache_entry whose most
@@ -80,7 +79,12 @@
  */
 class fqdncache_entry
 {
+    MEMPROXY_CLASS(fqdncache_entry);
+
 public:
+    fqdncache_entry(const char *name);
+    ~fqdncache_entry();
+
     hash_link hash;     /* must be first */
     time_t lastref;
     time_t expires;
@@ -94,7 +98,9 @@
     dlink_node lru;
     unsigned short locks;
 
-    struct {
+    struct _flags {
+        _flags() : negcached(false), fromhosts(false) {}
+
         bool negcached;
         bool fromhosts;
     } flags;
@@ -117,7 +123,6 @@
 static IDNSCB fqdncacheHandleReply;
 static int fqdncacheParse(fqdncache_entry *, const rfc1035_rr *, int, const char *error_message);
 static void fqdncacheRelease(fqdncache_entry *);
-static fqdncache_entry *fqdncacheCreateEntry(const char *name);
 static void fqdncacheCallback(fqdncache_entry *, int wait);
 static fqdncache_entry *fqdncache_get(const char *);
 static int fqdncacheExpiredEntry(const fqdncache_entry *);
@@ -151,21 +156,10 @@
 static void
 fqdncacheRelease(fqdncache_entry * f)
 {
-    int k;
     hash_remove_link(fqdn_table, (hash_link *) f);
-
-    for (k = 0; k &lt; (int) f-&gt;name_count; ++k)
-        safe_free(f-&gt;names[k]);
-
     debugs(35, 5, &quot;fqdncacheRelease: Released FQDN record for '&quot; &lt;&lt; hashKeyStr(&amp;f-&gt;hash) &lt;&lt; &quot;'.&quot;);
-
     dlinkDelete(&amp;f-&gt;lru, &amp;lru_list);
-
-    safe_free(f-&gt;hash.key);
-
-    safe_free(f-&gt;error_message);
-
-    memFree(f, MEM_FQDNCACHE_ENTRY);
+    delete f;
 }
 
 /**
@@ -258,19 +252,19 @@
         fqdncacheRelease(i);
 }
 
-/**
- \ingroup FQDNCacheInternal
- *
- * Create blank fqdncache_entry
- */
-static fqdncache_entry *
-fqdncacheCreateEntry(const char *name)
+fqdncache_entry::fqdncache_entry(const char *name) :
+    lastref(0),
+    expires(squid_curtime + Config.negativeDnsTtl),
+    name_count(0),
+    handler(nullptr),
+    handlerData(nullptr),
+    error_message(nullptr),
+    locks(0) // XXX: use Lock
 {
-    static fqdncache_entry *f;
-    f = (fqdncache_entry *)memAllocate(MEM_FQDNCACHE_ENTRY);
-    f-&gt;hash.key = xstrdup(name);
-    f-&gt;expires = squid_curtime + Config.negativeDnsTtl;
-    return f;
+    hash.key = xstrdup(name);
+
+    memset(&amp;request_time, 0, sizeof(request_time));
+    memset(&amp;names, 0, sizeof(names));
 }
 
 /// \ingroup FQDNCacheInternal
@@ -464,7 +458,7 @@
 
     debugs(35, 5, &quot;fqdncache_nbgethostbyaddr: MISS for '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;);
     ++ FqdncacheStats.misses;
-    f = fqdncacheCreateEntry(name);
+    f = new fqdncache_entry(name);
     f-&gt;handler = handler;
     f-&gt;handlerData = cbdataReference(handlerData);
     f-&gt;request_time = current_time;
@@ -543,7 +537,7 @@
     storeAppendPrintf(sentry, &quot;FQDN Cache Statistics:\n&quot;);
 
     storeAppendPrintf(sentry, &quot;FQDNcache Entries In Use: %d\n&quot;,
-                      memInUse(MEM_FQDNCACHE_ENTRY));
+                      fqdncache_entry::UseCount());
 
     storeAppendPrintf(sentry, &quot;FQDNcache Entries Cached: %d\n&quot;,
                       fqdncacheCount());
@@ -609,16 +603,16 @@
 fqdncacheFreeEntry(void *data)
 {
     fqdncache_entry *f = (fqdncache_entry *)data;
-    int k;
-
-    for (k = 0; k &lt; (int) f-&gt;name_count; ++k)
-        safe_free(f-&gt;names[k]);
-
-    safe_free(f-&gt;hash.key);
-
-    safe_free(f-&gt;error_message);
-
-    memFree(f, MEM_FQDNCACHE_ENTRY);
+    delete f;
+}
+
+fqdncache_entry::~fqdncache_entry()
+{
+    for (int k = 0; k &lt; (int)name_count; ++k)
+        xfree(names[k]);
+
+    xfree(hash.key);
+    xfree(error_message);
 }
 
 /// \ingroup FQDNCacheAPI
@@ -675,7 +669,7 @@
         }
     }
 
-    fce = fqdncacheCreateEntry(addr);
+    fce = new fqdncache_entry(addr);
 
     while (hostnames) {
         fce-&gt;names[j] = xstrdup(hostnames-&gt;key);
@@ -734,9 +728,6 @@
     n = hashPrime(fqdncache_high / 4);
 
     fqdn_table = hash_create((HASHCMP *) strcmp, n, hash4);
-
-    memDataInit(MEM_FQDNCACHE_ENTRY, &quot;fqdncache_entry&quot;,
-                sizeof(fqdncache_entry), 0);
 }
 
 #if SQUID_SNMP

=== modified file 'src/icmp/net_db.cc'
--- src/icmp/net_db.cc	2016-04-03 23:41:58 +0000
+++ src/icmp/net_db.cc	2016-04-08 13:55:10 +0000
@@ -150,30 +150,34 @@
     hash_remove_link(addr_table, hptr);
 }
 
+net_db_name::net_db_name(const char *hostname, netdbEntry *e) :
+    next(e ? e-&gt;hosts : nullptr),
+    net_db_entry(e)
+{
+    if (e) {
+        e-&gt;hosts = this;
+        ++ e-&gt;link_count;
+    }
+}
+
 static void
 netdbHostInsert(netdbEntry * n, const char *hostname)
 {
-    net_db_name *x = (net_db_name *)memAllocate(MEM_NET_DB_NAME);
-    x-&gt;hash.key = xstrdup(hostname);
-    x-&gt;next = n-&gt;hosts;
-    n-&gt;hosts = x;
-    x-&gt;net_db_entry = n;
+    net_db_name *x = new net_db_name(hostname, n);
     assert(hash_lookup(host_table, hostname) == NULL);
     hash_join(host_table, &amp;x-&gt;hash);
-    ++ n-&gt;link_count;
 }
 
 static void
 netdbHostDelete(const net_db_name * x)
 {
-    netdbEntry *n;
-    net_db_name **X;
     assert(x != NULL);
     assert(x-&gt;net_db_entry != NULL);
-    n = x-&gt;net_db_entry;
+
+    netdbEntry *n = x-&gt;net_db_entry;
     -- n-&gt;link_count;
 
-    for (X = &amp;n-&gt;hosts; *X; X = &amp;(*X)-&gt;next) {
+    for (auto **X = &amp;n-&gt;hosts; *X; X = &amp;(*X)-&gt;next) {
         if (*X == x) {
             *X = x-&gt;next;
             break;
@@ -181,8 +185,7 @@
     }
 
     hash_remove_link(host_table, (hash_link *) x);
-    xfree(x-&gt;hash.key);
-    memFree((void *) x, MEM_NET_DB_NAME);
+    delete x;
 }
 
 static netdbEntry *
@@ -686,8 +689,7 @@
 netdbFreeNameEntry(void *data)
 {
     net_db_name *x = (net_db_name *)data;
-    xfree(x-&gt;hash.key);
-    memFree(x, MEM_NET_DB_NAME);
+    delete x;
 }
 
 static void

=== modified file 'src/icmp/net_db.h'
--- src/icmp/net_db.h	2016-01-01 00:12:18 +0000
+++ src/icmp/net_db.h	2016-04-08 13:49:24 +0000
@@ -11,6 +11,7 @@
 
 #include &quot;hash.h&quot;
 #include &quot;ip/forward.h&quot;
+#include &quot;mem/forward.h&quot;
 
 class CachePeer;
 class HttpRequest;
@@ -18,10 +19,14 @@
 class StoreEntry;
 class URL;
 
-// POD
 class net_db_name
 {
+    MEMPROXY_CLASS(net_db_name);
+
 public:
+    net_db_name(const char *name, netdbEntry *);
+    ~net_db_name() {xfree(hash.key);}
+
     hash_link hash;     /* must be first */
     net_db_name *next;
     netdbEntry *net_db_entry;

=== modified file 'src/ipcache.cc'
--- src/ipcache.cc	2016-01-01 00:12:18 +0000
+++ src/ipcache.cc	2016-04-10 11:49:15 +0000
@@ -78,7 +78,12 @@
  */
 class ipcache_entry
 {
+    MEMPROXY_CLASS(ipcache_entry);
+
 public:
+    ipcache_entry(const char *);
+    ~ipcache_entry();
+
     hash_link hash;     /* must be first */
     time_t lastref;
     time_t expires;
@@ -90,7 +95,9 @@
     struct timeval request_time;
     dlink_node lru;
     unsigned short locks;
-    struct {
+    struct _flags {
+        _flags() : negcached(false), fromhosts(false) {}
+
         bool negcached;
         bool fromhosts;
     } flags;
@@ -265,20 +272,19 @@
         ipcacheRelease(i);
 }
 
-/**
- \ingroup IPCacheInternal
- *
- * create blank ipcache_entry
- */
-static ipcache_entry *
-ipcacheCreateEntry(const char *name)
+ipcache_entry::ipcache_entry(const char *name) :
+    lastref(0),
+    expires(0),
+    handler(nullptr),
+    handlerData(nullptr),
+    error_message(nullptr),
+    locks(0) // XXX: use Lock type ?
 {
-    static ipcache_entry *i;
-    i = (ipcache_entry *)memAllocate(MEM_IPCACHE_ENTRY);
-    i-&gt;hash.key = xstrdup(name);
-    Tolower(static_cast&lt;char*&gt;(i-&gt;hash.key));
-    i-&gt;expires = squid_curtime + Config.negativeDnsTtl;
-    return i;
+    hash.key = xstrdup(name);
+    Tolower(static_cast&lt;char*&gt;(hash.key));
+    expires = squid_curtime + Config.negativeDnsTtl;
+
+    memset(&amp;request_time, 0, sizeof(request_time));
 }
 
 /// \ingroup IPCacheInternal
@@ -547,7 +553,7 @@
 
     debugs(14, 5, &quot;ipcache_nbgethostbyname: MISS for '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;);
     ++IpcacheStats.misses;
-    i = ipcacheCreateEntry(name);
+    i = new ipcache_entry(name);
     i-&gt;handler = handler;
     i-&gt;handlerData = cbdataReference(handlerData);
     i-&gt;request_time = current_time;
@@ -589,7 +595,6 @@
                            (float) Config.ipcache.low) / (float) 100);
     n = hashPrime(ipcache_high / 4);
     ip_table = hash_create((HASHCMP *) strcmp, n, hash4);
-    memDataInit(MEM_IPCACHE_ENTRY, &quot;ipcache_entry&quot;, sizeof(ipcache_entry), 0);
 
     ipcacheRegisterWithCacheManager();
 }
@@ -714,7 +719,7 @@
     assert(ip_table != NULL);
     storeAppendPrintf(sentry, &quot;IP Cache Statistics:\n&quot;);
     storeAppendPrintf(sentry, &quot;IPcache Entries In Use:  %d\n&quot;,
-                      memInUse(MEM_IPCACHE_ENTRY));
+                      ipcache_entry::UseCount());
     storeAppendPrintf(sentry, &quot;IPcache Entries Cached:  %d\n&quot;,
                       ipcacheCount());
     storeAppendPrintf(sentry, &quot;IPcache Requests: %d\n&quot;,
@@ -985,11 +990,15 @@
 ipcacheFreeEntry(void *data)
 {
     ipcache_entry *i = (ipcache_entry *)data;
-    safe_free(i-&gt;addrs.in_addrs);
-    safe_free(i-&gt;addrs.bad_mask);
-    safe_free(i-&gt;hash.key);
-    safe_free(i-&gt;error_message);
-    memFree(i, MEM_IPCACHE_ENTRY);
+    delete i;
+}
+
+ipcache_entry::~ipcache_entry()
+{
+    xfree(addrs.in_addrs);
+    xfree(addrs.bad_mask);
+    xfree(error_message);
+    xfree(hash.key);
 }
 
 /// \ingroup IPCacheAPI
@@ -1057,7 +1066,7 @@
         }
     }
 
-    i = ipcacheCreateEntry(name);
+    i = new ipcache_entry(name);
     i-&gt;addrs.count = 1;
     i-&gt;addrs.cur = 0;
     i-&gt;addrs.badcount = 0;

=== modified file 'src/ipcache.h'
--- src/ipcache.h	2016-01-01 00:12:18 +0000
+++ src/ipcache.h	2016-04-10 06:11:47 +0000
@@ -10,19 +10,19 @@
 #define _SQUID_IPCACHE_H
 
 #include &quot;dns/forward.h&quot;
+#include &quot;ip/forward.h&quot;
 
-namespace Ip
+class ipcache_addrs
 {
-class Address;
-}
+public:
+    ipcache_addrs() : in_addrs(nullptr), bad_mask(nullptr), count(0), cur(0), badcount(0) {}
 
-typedef struct _ipcache_addrs {
     Ip::Address *in_addrs;
     unsigned char *bad_mask;
     unsigned char count;
     unsigned char cur;
     unsigned char badcount;
-} ipcache_addrs;
+};
 
 typedef void IPH(const ipcache_addrs *, const Dns::LookupDetails &amp;details, void *);
 

=== modified file 'src/main.cc'
--- src/main.cc	2016-04-03 23:41:58 +0000
+++ src/main.cc	2016-04-09 07:51:51 +0000
@@ -17,6 +17,7 @@
 #include &quot;base/Subscription.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;cache_cf.h&quot;
+#include &quot;CachePeer.h&quot;
 #include &quot;carp.h&quot;
 #include &quot;client_db.h&quot;
 #include &quot;client_side.h&quot;

=== modified file 'src/mem/forward.h'
--- src/mem/forward.h	2016-01-01 00:12:18 +0000
+++ src/mem/forward.h	2016-04-11 16:16:12 +0000
@@ -46,22 +46,12 @@
     MEM_64K_BUF,
     MEM_ACL_DENY_INFO_LIST,
     MEM_ACL_NAME_LIST,
-    MEM_CLIENT_INFO,
     MEM_LINK_LIST,
     MEM_DLINK_NODE,
     MEM_DREAD_CTRL,
     MEM_DWRITE_Q,
-    MEM_HTTP_HDR_CONTENT_RANGE,
     MEM_MD5_DIGEST,
     MEM_NETDBENTRY,
-    MEM_NET_DB_NAME,
-    // IMPORTANT: leave this here. pools above are initialized early with memInit()
-    MEM_DONTFREE,
-    // following pools are initialized late by their component if needed (or never)
-    MEM_FQDNCACHE_ENTRY,
-    MEM_FWD_SERVER,
-    MEM_IDNS_QUERY,
-    MEM_IPCACHE_ENTRY,
     MEM_MAX
 } mem_type;
 

=== modified file 'src/mem/old_api.cc'
--- src/mem/old_api.cc	2016-03-31 10:02:08 +0000
+++ src/mem/old_api.cc	2016-04-11 16:16:28 +0000
@@ -411,9 +411,6 @@
     MemPools::GetInstance().setIdleLimit(new_pool_limit);
 }
 
-/* XXX make these classes do their own memory management */
-#include &quot;HttpHdrContRange.h&quot;
-
 void
 Mem::Init(void)
 {
@@ -452,10 +449,7 @@
     memDataInit(MEM_DLINK_NODE, &quot;dlink_node&quot;, sizeof(dlink_node), 10);
     memDataInit(MEM_DREAD_CTRL, &quot;dread_ctrl&quot;, sizeof(dread_ctrl), 0);
     memDataInit(MEM_DWRITE_Q, &quot;dwrite_q&quot;, sizeof(dwrite_q), 0);
-    memDataInit(MEM_HTTP_HDR_CONTENT_RANGE, &quot;HttpHdrContRange&quot;, sizeof(HttpHdrContRange), 0);
     memDataInit(MEM_NETDBENTRY, &quot;netdbEntry&quot;, sizeof(netdbEntry), 0);
-    memDataInit(MEM_NET_DB_NAME, &quot;net_db_name&quot;, sizeof(net_db_name), 0);
-    memDataInit(MEM_CLIENT_INFO, &quot;ClientInfo&quot;, sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, &quot;MD5 digest&quot;, SQUID_MD5_DIGEST_LENGTH, 0);
     GetPool(MEM_MD5_DIGEST)-&gt;setChunkSize(512 * 1024);
 
@@ -489,11 +483,10 @@
 {
     mem_type t = MEM_NONE;
 
-    while (++t &lt; MEM_DONTFREE) {
+    while (++t &lt; MEM_MAX) {
         /*
          * If you hit this assertion, then you forgot to add a
          * memDataInit() line for type 't'.
-         * Or placed the pool type in the wrong section of the enum list.
          */
         assert(GetPool(t));
     }

=== modified file 'src/peer_select.cc'
--- src/peer_select.cc	2016-01-24 17:41:43 +0000
+++ src/peer_select.cc	2016-04-09 09:36:48 +0000
@@ -70,8 +70,7 @@
 {
     while (servers) {
         FwdServer *next = servers-&gt;next;
-        cbdataReferenceDone(servers-&gt;_peer);
-        memFree(servers, MEM_FWD_SERVER);
+        delete servers;
         servers = next;
     }
 
@@ -236,7 +235,7 @@
             Comm::ConnectionPointer p = new Comm::Connection();
             p-&gt;remote = req-&gt;clientConnectionManager-&gt;clientConnection-&gt;local;
             p-&gt;peerType = ORIGINAL_DST; // fs-&gt;code is DIRECT. This fixes the display.
-            p-&gt;setPeer(fs-&gt;_peer);
+            p-&gt;setPeer(fs-&gt;_peer.get());
 
             // check for a configured outgoing address for this destination...
             getOutgoingAddress(psstate-&gt;request, p);
@@ -245,8 +244,7 @@
 
         // clear the used fs and continue
         psstate-&gt;servers = fs-&gt;next;
-        cbdataReferenceDone(fs-&gt;_peer);
-        memFree(fs, MEM_FWD_SERVER);
+        delete fs;
         peerSelectDnsPaths(psstate);
         return;
     }
@@ -254,7 +252,7 @@
     // convert the list of FwdServer destinations into destinations IP addresses
     if (fs &amp;&amp; psstate-&gt;paths-&gt;size() &lt; (unsigned int)Config.forward_max_tries) {
         // send the next one off for DNS lookup.
-        const char *host = fs-&gt;_peer ? fs-&gt;_peer-&gt;host : psstate-&gt;request-&gt;url.host();
+        const char *host = fs-&gt;_peer.valid() ? fs-&gt;_peer-&gt;host : psstate-&gt;request-&gt;url.host();
         debugs(44, 2, &quot;Find IP destination for: &quot; &lt;&lt; psstate-&gt;url() &lt;&lt; &quot;' via &quot; &lt;&lt; host);
         ipcache_nbgethostbyname(host, peerSelectDnsResults, psstate);
         return;
@@ -267,8 +265,7 @@
         assert(fs == psstate-&gt;servers);
         while (fs) {
             psstate-&gt;servers = fs-&gt;next;
-            cbdataReferenceDone(fs-&gt;_peer);
-            memFree(fs, MEM_FWD_SERVER);
+            delete fs;
             fs = psstate-&gt;servers;
         }
     }
@@ -336,7 +333,7 @@
                 break;
 
             // for TPROXY spoofing we must skip unusable addresses.
-            if (psstate-&gt;request-&gt;flags.spoofClientIp &amp;&amp; !(fs-&gt;_peer &amp;&amp; fs-&gt;_peer-&gt;options.no_tproxy) ) {
+            if (psstate-&gt;request-&gt;flags.spoofClientIp &amp;&amp; !(fs-&gt;_peer.valid() &amp;&amp; fs-&gt;_peer-&gt;options.no_tproxy) ) {
                 if (ia-&gt;in_addrs[ip].isIPv4() != psstate-&gt;request-&gt;client_addr.isIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
                     continue;
@@ -348,21 +345,21 @@
 
             // when IPv6 is disabled we cannot use it
             if (!Ip::EnableIpv6 &amp;&amp; p-&gt;remote.isIPv6()) {
-                const char *host = (fs-&gt;_peer ? fs-&gt;_peer-&gt;host : psstate-&gt;request-&gt;url.host());
+                const char *host = (fs-&gt;_peer.valid() ? fs-&gt;_peer-&gt;host : psstate-&gt;request-&gt;url.host());
                 ipcacheMarkBadAddr(host, p-&gt;remote);
                 continue;
             }
 
-            p-&gt;remote.port(fs-&gt;_peer ? fs-&gt;_peer-&gt;http_port : psstate-&gt;request-&gt;url.port());
+            p-&gt;remote.port(fs-&gt;_peer.valid() ? fs-&gt;_peer-&gt;http_port : psstate-&gt;request-&gt;url.port());
             p-&gt;peerType = fs-&gt;code;
-            p-&gt;setPeer(fs-&gt;_peer);
+            p-&gt;setPeer(fs-&gt;_peer.get());
 
             // check for a configured outgoing address for this destination...
             getOutgoingAddress(psstate-&gt;request, p);
             psstate-&gt;paths-&gt;push_back(p);
         }
     } else {
-        debugs(44, 3, &quot;Unknown host: &quot; &lt;&lt; (fs-&gt;_peer ? fs-&gt;_peer-&gt;host : psstate-&gt;request-&gt;url.host()));
+        debugs(44, 3, &quot;Unknown host: &quot; &lt;&lt; (fs-&gt;_peer.valid() ? fs-&gt;_peer-&gt;host : psstate-&gt;request-&gt;url.host()));
         // discard any previous error.
         delete psstate-&gt;lastError;
         psstate-&gt;lastError = NULL;
@@ -373,8 +370,7 @@
     }
 
     psstate-&gt;servers = fs-&gt;next;
-    cbdataReferenceDone(fs-&gt;_peer);
-    memFree(fs, MEM_FWD_SERVER);
+    delete fs;
 
     // see if more paths can be found
     peerSelectDnsPaths(psstate);
@@ -769,7 +765,6 @@
 peerSelectInit(void)
 {
     memset(&amp;PeerStats, '\0', sizeof(PeerStats));
-    memDataInit(MEM_FWD_SERVER, &quot;FwdServer&quot;, sizeof(FwdServer), 0);
 }
 
 static void
@@ -931,12 +926,10 @@
 static void
 peerAddFwdServer(FwdServer ** FSVR, CachePeer * p, hier_code code)
 {
-    FwdServer *fs = (FwdServer *)memAllocate(MEM_FWD_SERVER);
     debugs(44, 5, &quot;peerAddFwdServer: adding &quot; &lt;&lt;
            (p ? p-&gt;host : &quot;DIRECT&quot;)  &lt;&lt; &quot; &quot; &lt;&lt;
            hier_code_str[code]  );
-    fs-&gt;_peer = cbdataReference(p);
-    fs-&gt;code = code;
+    FwdServer *fs = new FwdServer(p, code);
 
     while (*FSVR)
         FSVR = &amp;(*FSVR)-&gt;next;

</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005580.html">[squid-dev] [PATCH] Do not hide important/critical messages
</A></li>
	<LI>Next message: <A HREF="005607.html">[squid-dev] [PATCH] libmem API cleanup pt2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5585">[ date ]</a>
              <a href="thread.html#5585">[ thread ]</a>
              <a href="subject.html#5585">[ subject ]</a>
              <a href="author.html#5585">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
