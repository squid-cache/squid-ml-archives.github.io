<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] PeerConnector shuffling to libsecurity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PeerConnector%20shuffling%20to%20libsecurity&In-Reply-To=%3C571A3DCA.5040308%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005599.html">
   <LINK REL="Next"  HREF="005597.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] PeerConnector shuffling to libsecurity</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20PeerConnector%20shuffling%20to%20libsecurity&In-Reply-To=%3C571A3DCA.5040308%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] PeerConnector shuffling to libsecurity">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Apr 22 15:05:46 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005599.html">[squid-dev] [PATCH] PeerConnector shuffling to libsecurity
</A></li>
        <LI>Next message: <A HREF="005597.html">[squid-dev] [PATCH] Remove SquidList / link_list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5612">[ date ]</a>
              <a href="thread.html#5612">[ thread ]</a>
              <a href="subject.html#5612">[ subject ]</a>
              <a href="author.html#5612">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 15/04/2016 5:27 a.m., Alex Rousskov wrote:
&gt;<i> On 04/14/2016 06:23 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> This patch shuffles the Ssl::PeerConnector to Security::TlsPeerEncryptor
</I>&gt;&gt;<i> and Ssl::BlindPeerConnector to Security::BlindTlsPeerEncryptor.
</I>&gt;<i> 
</I>&gt;<i> I have already given up on fighting you about pointless and inconsistent
</I>&gt;<i> SSL/TLS/Security renames, but please at least do not nest layers until
</I>&gt;<i> we actually need that nesting: Use either Security::PeerEncryptor or
</I>&gt;<i> TlsPeerEncryptor, not Security::TlsPeerEncryptor. I recommend
</I>&gt;<i> Security::PeerEncryptor because the API users do not care much about the
</I>&gt;<i> protocol being used.
</I>&gt;<i> 
</I>
Okay, dropped the &quot;Tls&quot; part.

&gt;<i> 
</I>&gt;&gt;<i> +#elif USE_GNUTLS
</I>&gt;&gt;<i> +    // XXX: no GnuTLS support for cert validation helper yet
</I>&gt;&gt;<i> +#endif
</I>&gt;<i> ...
</I>&gt;&gt;<i> +#elif USE_GNUTLS
</I>&gt;&gt;<i> +        // TODO
</I>&gt;&gt;<i> +#endif
</I>&gt;<i> ...
</I>&gt;<i> 
</I>&gt;<i> I object to ongoing pollution of innocent code with USE_GNUTLS that
</I>&gt;<i> cannot be used: Having to deal with USE_OPENSSL is bad enough. Please do
</I>&gt;<i> not quadruple the problem by adding [unused] #USE_GNUTLS everywhere!
</I>&gt;<i> 
</I>&gt;&gt;<i> +#if USE_OPENSSL
</I>&gt;&gt;<i>      if (serverConnection()-&gt;getPeer() &amp;&amp; !SSL_session_reused(ssl)) {
</I>&gt;<i> ...
</I>&gt;&gt;<i> +#elif USE_GNUTLS
</I>&gt;&gt;<i> +    if (serverConnection()-&gt;getPeer() &amp;&amp; !gnutls_session_is_resumed(ssl)) {
</I>&gt;&gt;<i> +#endif
</I>&gt;<i> 
</I>&gt;<i> The above is just one of many examples of how GnuTLS support should
</I>&gt;<i> _not_ be introduced. The above code should look like this:
</I>&gt;<i> 
</I>&gt;<i>   if (serverConnection()-&gt;getPeer() &amp;&amp; ssl-&gt;resumedSession())
</I>&gt;<i>     ...
</I>&gt;<i> 
</I>&gt;<i> or, at the very least, like this:
</I>&gt;<i> 
</I>&gt;<i>   if (serverConnection()-&gt;getPeer() &amp;&amp; !session_is_resumed(ssl))
</I>&gt;<i>     ...
</I>&gt;<i> 
</I>&gt;<i> No duplication of logic, no constant thinking of what API each library
</I>&gt;<i> uses, no #ifdefs, and no invasive predictions about what GnuTLS code
</I>&gt;<i> will need when GnuTLS support is actually added. If you are not ready to
</I>&gt;<i> add GnuTLS support the right way, please do not add GnuTLS support at all!
</I>&gt;<i> 
</I>&gt;<i> The &quot;wrong way to move towards GnuTLS support&quot; problem discussed above
</I>&gt;<i> is the biggest problem with the proposed patch that I can see. Please do
</I>&gt;<i> not commit until that problem is resolved.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> This shuffling is a required step to simplify converting the basic TLS
</I>&gt;&gt;<i> I/O logic to libsecurity and for GnuTLS to actually begin adding useful
</I>&gt;&gt;<i> implementation bits.
</I>&gt;<i> 
</I>&gt;<i> This required step was done in the wrong direction IMO: The proposed
</I>&gt;<i> patch adds a dozen new &quot;#if USE_&quot;s. If we are moving &quot;basic TLS I/O
</I>&gt;<i> logic to libsecurity&quot;, then we should be reducing the number of ifdefs,
</I>&gt;<i> not increasing them. Is this is a necessary pain to see some beautiful
</I>&gt;<i> results in the future? Should not we wait with the pain until that
</I>&gt;<i> future becomes a reality so that we can judge whether it is worth the pain?
</I>&gt;<i> 
</I>
Sorry. The empty ones were supposed to go before submission. Removed in
this patch.

&gt;<i> 
</I>&gt;&gt;<i> -#if USE_OPENSSL
</I>&gt;&gt;<i> -    /// Gives PeerConnector access to Answer in the TunnelStateData callback dialer.
</I>&gt;&gt;<i> -    class MyAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
</I>&gt;&gt;<i> +#if USE_OPENSSL || USE_GNUTLS
</I>&gt;&gt;<i> +    /// Gives Securit::TlsPeerEncryptor access to Answer in the TunnelStateData callback dialer.
</I>&gt;&gt;<i> +    class MyAnswerDialer: public CallDialer, public Security::TlsPeerEncryptor::CbDialer
</I>&gt;<i> 
</I>&gt;<i> I understand why MyAnswerDialer was wrapped in USE_OPENSSL before -- it
</I>&gt;<i> was using an Ssl::PeerConnector, and stuff in src/ssl/ is not generic.
</I>&gt;<i> However, now, it is using Security::TlsPeerEncryptor and src/security
</I>&gt;<i> API is supposed to be OpenSSL-neutral. Can we remove USE_OPENSSL from
</I>&gt;<i> this (and possibly some other) tunnel.cc parts now instead of adding
</I>&gt;<i> USE_GNUTLS?
</I>&gt;<i> 
</I>
Done. I was going to do that later when the I/O stuff was ready. But it
can be done now.

&gt;<i> 
</I>&gt;&gt;<i> -class IcapPeerConnector: public PeerConnector {
</I>&gt;&gt;<i> +class IcapPeerConnector: public Security::TlsPeerEncryptor {
</I>&gt;<i> 
</I>&gt;<i> Why was not this class renamed as well?
</I>&gt;<i> 
</I>
I am not moving it out of the Ssl namespace in this patch, and it still
contains OpenSSL specific code lines dealing with the session re-use. So
left the rename to happen later when that is cleared up in a followup patch.

&gt;<i> 
</I>&gt;&gt;<i> -Ssl::CreateClient(Security::ContextPtr sslContext, const int fd, const char *squidCtx)
</I>&gt;&gt;<i> -{
</I>&gt;&gt;<i> -    return SslCreate(sslContext, fd, Ssl::Bio::BIO_TO_SERVER, squidCtx);
</I>&gt;&gt;<i> -}
</I>&gt;<i> 
</I>&gt;<i> That function seemed like a perfect pair for the CreateServer() which
</I>&gt;<i> you did not remove. Why introduce such inconsistency and bother callers
</I>&gt;<i> with such ugly details as BIO_TO_SERVER constants?
</I>&gt;<i> 
</I>
These are being replaced by the *Options class createContext() method.
But this one did not really need doing this early. So reverted.


&gt;<i> 
</I>&gt;&gt;<i> -               theName.termedBuf(),static_cast&lt;int64_t&gt;(theSize), xstrerr(savedError));
</I>&gt;&gt;<i> +               theName.termedBuf(), static_cast&lt;int64_t&gt;(theSize), xstrerr(savedError));
</I>&gt;<i> 
</I>&gt;<i> Out-of-scope formatting change.
</I>&gt;<i> 
</I>
Weird. Not sure where that came from. Reverted.

&gt;<i> 
</I>&gt;&gt;<i> -    if (!Comm::IsConnOpen(serverConnection()) || fd_table[serverConnection()-&gt;fd].closing())
</I>&gt;&gt;<i> +    if (!Comm::IsConnOpen(serverConnection()))
</I>&gt;<i> 
</I>&gt;<i> Out-of-scope optimization(?) change.
</I>
This is to avoid unused variable warning/errors in the non-OpenSSL
builds while also ensuring that the available stack variables are
consistent across all builds.

&gt;<i> 
</I>&gt;&gt;<i> -    if (request != NULL)
</I>&gt;&gt;<i> +    if (request)
</I>&gt;<i> 
</I>&gt;<i> Out-of-scope code style change.
</I>
Reverted and one or two others.

New patch attached.

Amos
-------------- next part --------------
=== modified file 'src/FwdState.cc'
--- src/FwdState.cc	2016-03-12 20:27:35 +0000
+++ src/FwdState.cc	2016-04-18 08:06:05 +0000
@@ -45,9 +45,9 @@
 #include &quot;pconn.h&quot;
 #include &quot;PeerPoolMgr.h&quot;
 #include &quot;PeerSelectState.h&quot;
+#include &quot;security/BlindPeerEncryptor.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
-#include &quot;ssl/BlindPeerConnector.h&quot;
 #include &quot;ssl/PeekingPeerConnector.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;StoreClient.h&quot;
@@ -79,7 +79,7 @@
 CBDATA_CLASS_INIT(FwdState);
 
 #if USE_OPENSSL
-class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+class FwdStatePeerAnswerDialer: public CallDialer, public Security::PeerEncryptor::CbDialer
 {
 public:
     typedef void (FwdState::*Method)(Security::EncryptorAnswer &amp;);
@@ -94,7 +94,7 @@
         os &lt;&lt; '(' &lt;&lt; fwd_.get() &lt;&lt; &quot;, &quot; &lt;&lt; answer_ &lt;&lt; ')';
     }
 
-    /* Ssl::PeerConnector::CbDialer API */
+    /* Security::PeerEncryptor::CbDialer API */
     virtual Security::EncryptorAnswer &amp;answer() { return answer_; }
 
 private:
@@ -700,11 +700,11 @@
                                                     FwdStatePeerAnswerDialer(&amp;FwdState::connectedToPeer, this));
             // Use positive timeout when less than one second is left.
             const time_t sslNegotiationTimeout = max(static_cast&lt;time_t&gt;(1), timeLeft());
-            Ssl::PeerConnector *connector = NULL;
+            Security::PeerEncryptor *connector = nullptr;
             if (request-&gt;flags.sslPeek)
                 connector = new Ssl::PeekingPeerConnector(requestPointer, serverConnection(), clientConn, callback, al, sslNegotiationTimeout);
             else
-                connector = new Ssl::BlindPeerConnector(requestPointer, serverConnection(), callback, al, sslNegotiationTimeout);
+                connector = new Security::BlindPeerEncryptor(requestPointer, serverConnection(), callback, al, sslNegotiationTimeout);
             AsyncJob::Start(connector); // will call our callback
             return;
         }

=== modified file 'src/PeerPoolMgr.cc'
--- src/PeerPoolMgr.cc	2016-02-02 15:39:23 +0000
+++ src/PeerPoolMgr.cc	2016-04-18 08:06:05 +0000
@@ -7,6 +7,7 @@
  */
 
 #include &quot;squid.h&quot;
+#include &quot;AccessLogEntry.h&quot;
 #include &quot;base/AsyncJobCalls.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;CachePeer.h&quot;
@@ -20,25 +21,23 @@
 #include &quot;neighbors.h&quot;
 #include &quot;pconn.h&quot;
 #include &quot;PeerPoolMgr.h&quot;
+#include &quot;security/BlindPeerEncryptor.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
-#include &quot;ssl/BlindPeerConnector.h&quot;
 
 CBDATA_CLASS_INIT(PeerPoolMgr);
 
-#if USE_OPENSSL
-/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+/// Gives Security::PeerEncryptor access to Answer in the PeerPoolMgr callback dialer.
 class MyAnswerDialer: public UnaryMemFunT&lt;PeerPoolMgr, Security::EncryptorAnswer, Security::EncryptorAnswer&amp;&gt;,
-    public Ssl::PeerConnector::CbDialer
+    public Security::PeerEncryptor::CbDialer
 {
 public:
     MyAnswerDialer(const JobPointer &amp;aJob, Method aMethod):
         UnaryMemFunT&lt;PeerPoolMgr, Security::EncryptorAnswer, Security::EncryptorAnswer&amp;&gt;(aJob, aMethod, Security::EncryptorAnswer()) {}
 
-    /* Ssl::PeerConnector::CbDialer API */
+    /* Security::PeerEncryptor::CbDialer API */
     virtual Security::EncryptorAnswer &amp;answer() { return arg1; }
 };
-#endif
 
 PeerPoolMgr::PeerPoolMgr(CachePeer *aPeer): AsyncJob(&quot;PeerPoolMgr&quot;),
     peer(cbdataReference(aPeer)),
@@ -109,8 +108,7 @@
 
     Must(params.conn != NULL);
 
-#if USE_OPENSSL
-    // Handle SSL peers.
+    // Handle TLS encrypted peers.
     if (peer-&gt;secure.encryptTransport) {
         typedef CommCbMemFunT&lt;PeerPoolMgr, CommCloseCbParams&gt; CloserDialer;
         closer = JobCallback(48, 3, CloserDialer, this,
@@ -125,14 +123,10 @@
         const int timeUsed = squid_curtime - params.conn-&gt;startTime();
         // Use positive timeout when less than one second is left for conn.
         const int timeLeft = max(1, (peerTimeout - timeUsed));
-        Ssl::BlindPeerConnector *connector =
-            new Ssl::BlindPeerConnector(request, params.conn, securer, NULL, timeLeft);
-        AsyncJob::Start(connector); // will call our callback
-        return;
-    }
-#endif
-
-    pushNewConnection(params.conn);
+        auto *encryptor = new Security::BlindPeerEncryptor(request, params.conn, securer, nullptr, timeLeft);
+        AsyncJob::Start(encryptor); // will call our callback
+    } else
+        pushNewConnection(params.conn);
 }
 
 void

=== modified file 'src/PeerPoolMgr.h'
--- src/PeerPoolMgr.h	2016-01-01 00:12:18 +0000
+++ src/PeerPoolMgr.h	2016-04-18 08:06:05 +0000
@@ -51,7 +51,7 @@
     /// Comm::ConnOpener calls this when done opening a connection for us
     void handleOpenedConnection(const CommConnectCbParams &amp;params);
 
-    /// Ssl::PeerConnector callback
+    /// Security::PeerEncryptor callback
     void handleSecuredPeer(Security::EncryptorAnswer &amp;answer);
 
     /// called when the connection we are trying to secure is closed by a 3rd party

=== modified file 'src/adaptation/icap/Xaction.cc'
--- src/adaptation/icap/Xaction.cc	2016-02-02 15:39:23 +0000
+++ src/adaptation/icap/Xaction.cc	2016-04-22 13:13:59 +0000
@@ -34,22 +34,22 @@
 #include &quot;SquidTime.h&quot;
 
 #if USE_OPENSSL
-/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+/// Gives Security::PeerEncryptor access to Answer in the PeerPoolMgr callback dialer.
 class MyIcapAnswerDialer: public UnaryMemFunT&lt;Adaptation::Icap::Xaction, Security::EncryptorAnswer, Security::EncryptorAnswer&amp;&gt;,
-    public Ssl::PeerConnector::CbDialer
+    public Security::PeerEncryptor::CbDialer
 {
 public:
     MyIcapAnswerDialer(const JobPointer &amp;aJob, Method aMethod):
         UnaryMemFunT&lt;Adaptation::Icap::Xaction, Security::EncryptorAnswer, Security::EncryptorAnswer&amp;&gt;(aJob, aMethod, Security::EncryptorAnswer()) {}
 
-    /* Ssl::PeerConnector::CbDialer API */
+    /* Security::PeerEncryptor::CbDialer API */
     virtual Security::EncryptorAnswer &amp;answer() { return arg1; }
 };
 
 namespace Ssl
 {
 /// A simple PeerConnector for Secure ICAP services. No SslBump capabilities.
-class IcapPeerConnector: public PeerConnector {
+class IcapPeerConnector: public Security::PeerEncryptor {
     CBDATA_CLASS(IcapPeerConnector);
 public:
     IcapPeerConnector(
@@ -59,10 +59,10 @@
         AccessLogEntry::Pointer const &amp;alp,
         const time_t timeout = 0):
         AsyncJob(&quot;Ssl::IcapPeerConnector&quot;),
-        PeerConnector(aServerConn, aCallback, alp, timeout), icapService(service) {}
+        Security::PeerEncryptor(aServerConn, aCallback, alp, timeout), icapService(service) {}
 
-    /* PeerConnector API */
-    virtual Security::SessionPtr initializeSsl();
+    /* Security::PeerEncryptor API */
+    virtual Security::SessionPtr initialize();
     virtual void noteNegotiationDone(ErrorState *error);
     virtual Security::ContextPtr getSslContext() {return icapService-&gt;sslContext;}
 
@@ -311,7 +311,6 @@
         securer = asyncCall(93, 4, &quot;Adaptation::Icap::Xaction::handleSecuredPeer&quot;,
                             MyIcapAnswerDialer(me, &amp;Adaptation::Icap::Xaction::handleSecuredPeer));
 
-        Ssl::PeerConnector::HttpRequestPointer tmpReq(NULL);
         Ssl::IcapPeerConnector *sslConnector =
             new Ssl::IcapPeerConnector(theService, io.conn, securer, masterLogEntry(), TheConfig.connect_timeout(service().cfg().bypass));
         AsyncJob::Start(sslConnector); // will call our callback
@@ -711,9 +710,9 @@
 
 #if USE_OPENSSL
 Security::SessionPtr
-Ssl::IcapPeerConnector::initializeSsl()
+Ssl::IcapPeerConnector::initialize()
 {
-    auto ssl = Ssl::PeerConnector::initializeSsl();
+    auto ssl = Security::PeerEncryptor::initialize();
     if (!ssl)
         return nullptr;
 

=== modified file 'src/adaptation/icap/Xaction.h'
--- src/adaptation/icap/Xaction.h	2016-02-23 08:51:22 +0000
+++ src/adaptation/icap/Xaction.h	2016-04-18 15:52:13 +0000
@@ -16,9 +16,7 @@
 #include &quot;HttpReply.h&quot;
 #include &quot;ipcache.h&quot;
 #include &quot;sbuf/SBuf.h&quot;
-#if USE_OPENSSL
-#include &quot;ssl/PeerConnector.h&quot;
-#endif
+#include &quot;security/PeerEncryptor.h&quot;
 
 class MemBuf;
 

=== renamed file 'src/ssl/BlindPeerConnector.cc' =&gt; 'src/security/BlindPeerEncryptor.cc'
--- src/ssl/BlindPeerConnector.cc	2016-01-27 16:56:38 +0000
+++ src/security/BlindPeerEncryptor.cc	2016-04-22 13:12:39 +0000
@@ -9,17 +9,18 @@
 #include &quot;squid.h&quot;
 #include &quot;CachePeer.h&quot;
 #include &quot;comm/Connection.h&quot;
+#include &quot;errorpage.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;neighbors.h&quot;
+#include &quot;security/BlindPeerEncryptor.h&quot;
 #include &quot;security/NegotiationHistory.h&quot;
 #include &quot;SquidConfig.h&quot;
-#include &quot;ssl/BlindPeerConnector.h&quot;
 
-CBDATA_NAMESPACED_CLASS_INIT(Ssl, BlindPeerConnector);
+CBDATA_NAMESPACED_CLASS_INIT(Security, BlindPeerEncryptor);
 
 Security::ContextPtr
-Ssl::BlindPeerConnector::getSslContext()
+Security::BlindPeerEncryptor::getSslContext()
 {
     if (const CachePeer *peer = serverConnection()-&gt;getPeer()) {
         assert(peer-&gt;secure.encryptTransport);
@@ -30,9 +31,9 @@
 }
 
 Security::SessionPtr
-Ssl::BlindPeerConnector::initializeSsl()
+Security::BlindPeerEncryptor::initialize()
 {
-    auto ssl = Ssl::PeerConnector::initializeSsl();
+    auto ssl = Security::PeerEncryptor::initialize();
     if (!ssl)
         return nullptr;
 
@@ -42,22 +43,27 @@
         // NP: domain may be a raw-IP but it is now always set
         assert(!peer-&gt;secure.sslDomain.isEmpty());
 
+#if USE_OPENSSL
         // const loss is okay here, ssl_ex_index_server is only read and not assigned a destructor
         SBuf *host = new SBuf(peer-&gt;secure.sslDomain);
         SSL_set_ex_data(ssl, ssl_ex_index_server, host);
 
         if (peer-&gt;sslSession)
             SSL_set_session(ssl, peer-&gt;sslSession);
+#endif
+
     } else {
+#if USE_OPENSSL
         SBuf *hostName = new SBuf(request-&gt;url.host());
         SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
+#endif
     }
 
     return ssl;
 }
 
 void
-Ssl::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
+Security::BlindPeerEncryptor::noteNegotiationDone(ErrorState *error)
 {
     if (error) {
         // XXX: forward.cc calls peerConnectSucceeded() after an OK TCP connect but
@@ -70,6 +76,7 @@
         return;
     }
 
+#if USE_OPENSSL
     const int fd = serverConnection()-&gt;fd;
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
     if (serverConnection()-&gt;getPeer() &amp;&amp; !SSL_session_reused(ssl)) {
@@ -78,5 +85,6 @@
 
         serverConnection()-&gt;getPeer()-&gt;sslSession = SSL_get1_session(ssl);
     }
+#endif
 }
 

=== renamed file 'src/ssl/BlindPeerConnector.h' =&gt; 'src/security/BlindPeerEncryptor.h'
--- src/ssl/BlindPeerConnector.h	2016-02-02 15:39:23 +0000
+++ src/security/BlindPeerEncryptor.h	2016-04-22 13:12:49 +0000
@@ -6,47 +6,46 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SRC_SSL_BLINDPEERCONNECTOR_H
-#define SQUID_SRC_SSL_BLINDPEERCONNECTOR_H
-
-#include &quot;ssl/PeerConnector.h&quot;
-
-#if USE_OPENSSL
-
-namespace Ssl
+#ifndef SQUID_SRC_SECURITY_BLINDPEERENCRYPTOR_H
+#define SQUID_SRC_SECURITY_BLINDPEERENCRYPTOR_H
+
+#include &quot;security/PeerEncryptor.h&quot;
+
+class ErrorState;
+
+namespace Security
 {
 
-/// A simple PeerConnector for SSL/TLS cache_peers. No SslBump capabilities.
-class BlindPeerConnector: public PeerConnector {
-    CBDATA_CLASS(BlindPeerConnector);
+/// A simple PeerEncryptor for TLS cache_peers. No SslBump capabilities.
+class BlindPeerEncryptor: public Security::PeerEncryptor {
+    CBDATA_CLASS(BlindPeerEncryptor);
 public:
-    BlindPeerConnector(HttpRequestPointer &amp;aRequest,
-                       const Comm::ConnectionPointer &amp;aServerConn,
-                       AsyncCall::Pointer &amp;aCallback,
-                       const AccessLogEntryPointer &amp;alp,
-                       const time_t timeout = 0) :
-        AsyncJob(&quot;Ssl::BlindPeerConnector&quot;),
-        PeerConnector(aServerConn, aCallback, alp, timeout)
+    BlindPeerEncryptor(HttpRequestPointer &amp;aRequest,
+                          const Comm::ConnectionPointer &amp;aServerConn,
+                          AsyncCall::Pointer &amp;aCallback,
+                          const AccessLogEntryPointer &amp;alp,
+                          const time_t timeout = 0) :
+        AsyncJob(&quot;Security::BlindPeerEncryptor&quot;),
+        Security::PeerEncryptor(aServerConn, aCallback, alp, timeout)
     {
         request = aRequest;
     }
 
-    /* PeerConnector API */
+    /* Security::PeerEncryptor API */
 
-    /// Calls parent initializeSSL, configure the created SSL object to try reuse SSL session
-    /// and sets the hostname to use for certificates validation
-    virtual Security::SessionPtr initializeSsl();
+    /// Calls parent initialize(), configures the created TLS session object
+    /// to try and reuse a TLS session and sets the hostname to use for
+    /// certificate validation
+    virtual Security::SessionPtr initialize();
 
     /// Return the configured Security::ContextPtr object
     virtual Security::ContextPtr getSslContext();
 
-    /// On error calls peerConnectFailed function, on success store the used SSL session
-    /// for later use
-    virtual void noteNegotiationDone(ErrorState *error);
+    /// On error calls peerConnectFailed().
+    /// On success store the used TLS session for later use.
+    virtual void noteNegotiationDone(ErrorState *);
 };
 
-} // namespace Ssl
-
-#endif /* USE_OPENSSL */
-#endif /* SQUID_SRC_SSL_BLINDPEERCONNECTOR_H */
-
+} // namespace Security
+
+#endif /* SQUID_SRC_SECURITY_BLINDPEERENCRYPTOR_H */

=== modified file 'src/security/Makefile.am'
--- src/security/Makefile.am	2016-02-17 21:03:29 +0000
+++ src/security/Makefile.am	2016-04-18 08:06:01 +0000
@@ -13,6 +13,8 @@
 noinst_LTLIBRARIES = libsecurity.la
 
 libsecurity_la_SOURCES= \
+	BlindPeerEncryptor.cc \
+	BlindPeerEncryptor.h \
 	Context.h \
 	EncryptorAnswer.cc \
 	EncryptorAnswer.h \
@@ -21,6 +23,8 @@
 	LockingPointer.h \
 	NegotiationHistory.cc \
 	NegotiationHistory.h \
+	PeerEncryptor.cc \
+	PeerEncryptor.h \
 	PeerOptions.cc \
 	PeerOptions.h \
 	ServerOptions.cc \

=== renamed file 'src/ssl/PeerConnector.cc' =&gt; 'src/security/PeerEncryptor.cc'
--- src/ssl/PeerConnector.cc	2016-02-13 07:51:20 +0000
+++ src/security/PeerEncryptor.cc	2016-04-22 13:20:31 +0000
@@ -15,15 +15,17 @@
 #include &quot;fde.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;SquidConfig.h&quot;
+#include &quot;security/PeerEncryptor.h&quot;
+#if USE_OPENSSL
 #include &quot;ssl/cert_validate_message.h&quot;
 #include &quot;ssl/Config.h&quot;
 #include &quot;ssl/helper.h&quot;
-#include &quot;ssl/PeerConnector.h&quot;
-
-CBDATA_NAMESPACED_CLASS_INIT(Ssl, PeerConnector);
-
-Ssl::PeerConnector::PeerConnector(const Comm::ConnectionPointer &amp;aServerConn, AsyncCall::Pointer &amp;aCallback, const AccessLogEntryPointer &amp;alp, const time_t timeout) :
-    AsyncJob(&quot;Ssl::PeerConnector&quot;),
+#endif
+
+CBDATA_NAMESPACED_CLASS_INIT(Security, PeerEncryptor);
+
+Security::PeerEncryptor::PeerEncryptor(const Comm::ConnectionPointer &amp;aServerConn, AsyncCall::Pointer &amp;aCallback, const AccessLogEntryPointer &amp;alp, const time_t timeout) :
+    AsyncJob(&quot;Security::PeerEncryptor&quot;),
     serverConn(aServerConn),
     al(alp),
     callback(aCallback),
@@ -35,75 +37,81 @@
     Must(dynamic_cast&lt;CbDialer*&gt;(callback-&gt;getDialer()));
 }
 
-Ssl::PeerConnector::~PeerConnector()
+Security::PeerEncryptor::~PeerEncryptor()
 {
-    debugs(83, 5, &quot;Peer connector &quot; &lt;&lt; this &lt;&lt; &quot; gone&quot;);
+    debugs(83, 5, &quot;Peer encryptor &quot; &lt;&lt; this &lt;&lt; &quot; gone&quot;);
 }
 
-bool Ssl::PeerConnector::doneAll() const
+bool Security::PeerEncryptor::doneAll() const
 {
     return (!callback || callback-&gt;canceled()) &amp;&amp; AsyncJob::doneAll();
 }
 
 /// Preps connection and SSL state. Calls negotiate().
 void
-Ssl::PeerConnector::start()
+Security::PeerEncryptor::start()
 {
     AsyncJob::start();
 
-    if (prepareSocket() &amp;&amp; initializeSsl())
-        negotiateSsl();
+    if (prepareSocket() &amp;&amp; initialize())
+        negotiate();
 }
 
 void
-Ssl::PeerConnector::commCloseHandler(const CommCloseCbParams &amp;params)
+Security::PeerEncryptor::commCloseHandler(const CommCloseCbParams &amp;params)
 {
-    debugs(83, 5, &quot;FD &quot; &lt;&lt; params.fd &lt;&lt; &quot;, Ssl::PeerConnector=&quot; &lt;&lt; params.data);
-    connectionClosed(&quot;Ssl::PeerConnector::commCloseHandler&quot;);
+    debugs(83, 5, &quot;FD &quot; &lt;&lt; params.fd &lt;&lt; &quot;, Security::PeerEncryptor=&quot; &lt;&lt; params.data);
+    connectionClosed(&quot;Security::PeerEncryptor::commCloseHandler&quot;);
 }
 
 void
-Ssl::PeerConnector::connectionClosed(const char *reason)
+Security::PeerEncryptor::connectionClosed(const char *reason)
 {
     mustStop(reason);
     callback = NULL;
 }
 
 bool
-Ssl::PeerConnector::prepareSocket()
+Security::PeerEncryptor::prepareSocket()
 {
     const int fd = serverConnection()-&gt;fd;
     if (!Comm::IsConnOpen(serverConn) || fd_table[serverConn-&gt;fd].closing()) {
-        connectionClosed(&quot;Ssl::PeerConnector::prepareSocket&quot;);
+        connectionClosed(&quot;Security::PeerEncryptor::prepareSocket&quot;);
         return false;
     }
 
     // watch for external connection closures
-    typedef CommCbMemFunT&lt;Ssl::PeerConnector, CommCloseCbParams&gt; Dialer;
-    closeHandler = JobCallback(9, 5, Dialer, this, Ssl::PeerConnector::commCloseHandler);
+    typedef CommCbMemFunT&lt;Security::PeerEncryptor, CommCloseCbParams&gt; Dialer;
+    closeHandler = JobCallback(9, 5, Dialer, this, Security::PeerEncryptor::commCloseHandler);
     comm_add_close_handler(fd, closeHandler);
     return true;
 }
 
 Security::SessionPtr
-Ssl::PeerConnector::initializeSsl()
+Security::PeerEncryptor::initialize()
 {
     Security::ContextPtr sslContext(getSslContext());
     assert(sslContext);
 
-    const int fd = serverConnection()-&gt;fd;
-
-    auto ssl = Ssl::CreateClient(sslContext, fd, &quot;server https start&quot;);
+#if USE_OPENSSL
+    auto ssl = Ssl::CreateServer(sslContext, serverConnection()-&gt;fd, &quot;server https start&quot;);
+#else
+    Security::SessionPtr ssl = nullptr;
+#endif
     if (!ssl) {
         ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request.getRaw());
         anErr-&gt;xerrno = errno;
+#if USE_OPENSSL
         debugs(83, DBG_IMPORTANT, &quot;Error allocating SSL handle: &quot; &lt;&lt; ERR_error_string(ERR_get_error(), NULL));
-
+#else
+        debugs(83, DBG_IMPORTANT, &quot;Error allocating SSL handle: SSL not supported&quot;);
+#endif
         noteNegotiationDone(anErr);
         bail(anErr);
         return nullptr;
     }
 
+#if USE_OPENSSL
     // If CertValidation Helper used do not lookup checklist for errors,
     // but keep a list of errors to send it to CertValidator
     if (!Ssl::TheConfig.ssl_crt_validator) {
@@ -116,11 +124,13 @@
             SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
         }
     }
+#endif
+
     return ssl;
 }
 
 void
-Ssl::PeerConnector::setReadTimeout()
+Security::PeerEncryptor::setReadTimeout()
 {
     int timeToRead;
     if (negotiationTimeout) {
@@ -134,14 +144,20 @@
 }
 
 void
-Ssl::PeerConnector::negotiateSsl()
+Security::PeerEncryptor::negotiate()
 {
-    if (!Comm::IsConnOpen(serverConnection()) || fd_table[serverConnection()-&gt;fd].closing())
+    if (!Comm::IsConnOpen(serverConnection()))
         return;
 
     const int fd = serverConnection()-&gt;fd;
-    Security::SessionPtr ssl = fd_table[fd].ssl.get();
-    const int result = SSL_connect(ssl);
+    if (fd_table[fd].closing())
+        return;
+
+#if USE_OPENSSL
+    const int result = SSL_connect(fd_table[fd].ssl.get());
+#else
+    const int result = 0;
+#endif
     if (result &lt;= 0) {
         handleNegotiateError(result);
         return; // we might be gone by now
@@ -154,8 +170,9 @@
 }
 
 bool
-Ssl::PeerConnector::sslFinalized()
+Security::PeerEncryptor::sslFinalized()
 {
+#if USE_OPENSSL
     if (Ssl::TheConfig.ssl_crt_validator &amp;&amp; useCertValidator_) {
         const int fd = serverConnection()-&gt;fd;
         Security::SessionPtr ssl = fd_table[fd].ssl.get();
@@ -174,7 +191,7 @@
             validationRequest.errors = NULL;
         try {
             debugs(83, 5, &quot;Sending SSL certificate for validation to ssl_crtvd.&quot;);
-            AsyncCall::Pointer call = asyncCall(83,5, &quot;Ssl::PeerConnector::sslCrtvdHandleReply&quot;, Ssl::CertValidationHelper::CbDialer(this, &amp;Ssl::PeerConnector::sslCrtvdHandleReply, nullptr));
+            AsyncCall::Pointer call = asyncCall(83,5, &quot;Security::PeerEncryptor::sslCrtvdHandleReply&quot;, Ssl::CertValidationHelper::CbDialer(this, &amp;Security::PeerEncryptor::sslCrtvdHandleReply, nullptr));
             Ssl::CertValidationHelper::GetInstance()-&gt;sslSubmit(validationRequest, call);
             return false;
         } catch (const std::exception &amp;e) {
@@ -191,13 +208,15 @@
             return true;
         }
     }
+#endif
 
     noteNegotiationDone(NULL);
     return true;
 }
 
+#if USE_OPENSSL
 void
-Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse::Pointer validationResponse)
+Security::PeerEncryptor::sslCrtvdHandleReply(Ssl::CertValidationResponse::Pointer validationResponse)
 {
     Must(validationResponse != NULL);
 
@@ -239,12 +258,14 @@
     serverConn-&gt;close();
     return;
 }
+#endif
 
+#if USE_OPENSSL
 /// Checks errors in the cert. validator response against sslproxy_cert_error.
 /// The first honored error, if any, is returned via errDetails parameter.
 /// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
 Ssl::CertErrors *
-Ssl::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &amp;resp, Ssl::ErrorDetail *&amp; errDetails)
+Security::PeerEncryptor::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &amp;resp, Ssl::ErrorDetail *&amp; errDetails)
 {
     Ssl::CertErrors *errs = NULL;
 
@@ -296,19 +317,21 @@
 
     return errs;
 }
+#endif
 
 /// A wrapper for Comm::SetSelect() notifications.
 void
-Ssl::PeerConnector::NegotiateSsl(int, void *data)
+Security::PeerEncryptor::Negotiate(int, void *data)
 {
-    PeerConnector *pc = static_cast&lt;PeerConnector*&gt;(data);
+    PeerEncryptor *pc = static_cast&lt;Security::PeerEncryptor *&gt;(data);
     // Use job calls to add done() checks and other job logic/protections.
-    CallJobHere(83, 7, pc, Ssl::PeerConnector, negotiateSsl);
+    CallJobHere(83, 7, pc, Security::PeerEncryptor, negotiate);
 }
 
 void
-Ssl::PeerConnector::handleNegotiateError(const int ret)
+Security::PeerEncryptor::handleNegotiateError(const int ret)
 {
+#if USE_OPENSSL
     const int fd = serverConnection()-&gt;fd;
     unsigned long ssl_lib_error = SSL_ERROR_NONE;
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
@@ -332,29 +355,32 @@
         // no special error handling for all other errors
         break;
     }
-    noteSslNegotiationError(ret, ssl_error, ssl_lib_error);
+    noteNegotiationError(ret, ssl_error, ssl_lib_error);
+#endif
 }
 
 void
-Ssl::PeerConnector::noteWantRead()
+Security::PeerEncryptor::noteWantRead()
 {
     setReadTimeout();
     const int fd = serverConnection()-&gt;fd;
-    Comm::SetSelect(fd, COMM_SELECT_READ, &amp;NegotiateSsl, this, 0);
+    Comm::SetSelect(fd, COMM_SELECT_READ, &amp;Negotiate, this, 0);
 }
 
 void
-Ssl::PeerConnector::noteWantWrite()
+Security::PeerEncryptor::noteWantWrite()
 {
     const int fd = serverConnection()-&gt;fd;
-    Comm::SetSelect(fd, COMM_SELECT_WRITE, &amp;NegotiateSsl, this, 0);
+    Comm::SetSelect(fd, COMM_SELECT_WRITE, &amp;Negotiate, this, 0);
     return;
 }
 
 void
-Ssl::PeerConnector::noteSslNegotiationError(const int ret, const int ssl_error, const int ssl_lib_error)
+Security::PeerEncryptor::noteNegotiationError(const int ret, const int ssl_error, const int ssl_lib_error)
 {
-#ifdef EPROTO
+#if USE_OPENSSL
+
+#if defined(EPROTO)
     int sysErrNo = EPROTO;
 #else
     int sysErrNo = EACCES;
@@ -377,7 +403,7 @@
     anErr-&gt;xerrno = sysErrNo;
 
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
-    Ssl::ErrorDetail *errFromFailure = (Ssl::ErrorDetail *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail);
+    Ssl::ErrorDetail *errFromFailure = static_cast&lt;Ssl::ErrorDetail *&gt;(SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail));
     if (errFromFailure != NULL) {
         // The errFromFailure is attached to the ssl object
         // and will be released when ssl object destroyed.
@@ -395,10 +421,11 @@
 
     noteNegotiationDone(anErr);
     bail(anErr);
+#endif
 }
 
 void
-Ssl::PeerConnector::bail(ErrorState *error)
+Security::PeerEncryptor::bail(ErrorState *error)
 {
     Must(error); // or the recepient will not know there was a problem
     Must(callback != NULL);
@@ -416,7 +443,7 @@
 }
 
 void
-Ssl::PeerConnector::callBack()
+Security::PeerEncryptor::callBack()
 {
     AsyncCall::Pointer cb = callback;
     // Do this now so that if we throw below, swanSong() assert that we _tried_
@@ -433,7 +460,7 @@
 }
 
 void
-Ssl::PeerConnector::swanSong()
+Security::PeerEncryptor::swanSong()
 {
     // XXX: unregister fd-closure monitoring and CommSetSelect interest, if any
     AsyncJob::swanSong();
@@ -447,7 +474,7 @@
 }
 
 const char *
-Ssl::PeerConnector::status() const
+Security::PeerEncryptor::status() const
 {
     static MemBuf buf;
     buf.reset();

=== renamed file 'src/ssl/PeerConnector.h' =&gt; 'src/security/PeerEncryptor.h'
--- src/ssl/PeerConnector.h	2016-02-13 07:51:20 +0000
+++ src/security/PeerEncryptor.h	2016-04-22 13:21:45 +0000
@@ -6,50 +6,51 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SRC_SSL_PEERCONNECTOR_H
-#define SQUID_SRC_SSL_PEERCONNECTOR_H
+#ifndef SQUID_SRC_SECURITY_PEERENCRYPTOR_H
+#define SQUID_SRC_SECURITY_PEERENCRYPTOR_H
 
 #include &quot;acl/Acl.h&quot;
 #include &quot;base/AsyncCbdataCalls.h&quot;
 #include &quot;base/AsyncJob.h&quot;
 #include &quot;CommCalls.h&quot;
+#include &quot;http/forward.h&quot;
 #include &quot;security/EncryptorAnswer.h&quot;
+#include &quot;security/forward.h&quot;
+#if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
+#endif
 
 #include &lt;iosfwd&gt;
 
-#if USE_OPENSSL
-
-class HttpRequest;
 class ErrorState;
 class AccessLogEntry;
 typedef RefCount&lt;AccessLogEntry&gt; AccessLogEntryPointer;
 
-namespace Ssl
+namespace Security
 {
 
 /**
  \par
- * Connects Squid to SSL/TLS-capable peers or services.
- * Contains common code and interfaces of various specialized PeerConnectors,
+ * Initiates encryption on a connection to peers or servers.
+ * Contains common code and interfaces of various specialized PeerEncryptors,
  * including peer certificate validation code.
  \par
  * The caller receives a call back with Security::EncryptorAnswer. If answer.error
- * is not nil, then there was an error and the SSL connection to the SSL peer
+ * is not nil, then there was an error and the encryption to the peer or server
  * was not fully established. The error object is suitable for error response
  * generation.
  \par
  * The caller must monitor the connection for closure because this
  * job will not inform the caller about such events.
  \par
- * PeerConnector class curently supports a form of SSL negotiation timeout,
- * which accounted only when sets the read timeout from SSL peer.
+ * PeerEncryptor class curently supports a form of TLS negotiation timeout,
+ * which is accounted only when sets the read timeout from encrypted peers/servers.
  * For a complete solution, the caller must monitor the overall connection
  * establishment timeout and close the connection on timeouts. This is probably
  * better than having dedicated (or none at all!) timeouts for peer selection,
  * DNS lookup, TCP handshake, SSL handshake, etc. Some steps may have their
  * own timeout, but not all steps should be forced to have theirs.
- * XXX: tunnel.cc and probably other subsystems does not have an &quot;overall
+ * XXX: tunnel.cc and probably other subsystems do not have an &quot;overall
  * connection establishment&quot; timeout. We need to change their code so that they
  * start monitoring earlier and close on timeouts. This change may need to be
  * discussed on squid-dev.
@@ -57,28 +58,26 @@
  * This job never closes the connection, even on errors. If a 3rd-party
  * closes the connection, this job simply quits without informing the caller.
  */
-class PeerConnector: virtual public AsyncJob
+class PeerEncryptor: virtual public AsyncJob
 {
-    CBDATA_CLASS(PeerConnector);
+    CBDATA_CLASS(PeerEncryptor);
 
 public:
-    /// Callback dialier API to allow PeerConnector to set the answer.
+    /// Callback dialier API to allow PeerEncryptor to set the answer.
     class CbDialer
     {
     public:
         virtual ~CbDialer() {}
-        /// gives PeerConnector access to the in-dialer answer
+        /// gives PeerEncryptor access to the in-dialer answer
         virtual Security::EncryptorAnswer &amp;answer() = 0;
     };
 
-    typedef RefCount&lt;HttpRequest&gt; HttpRequestPointer;
-
 public:
-    PeerConnector(const Comm::ConnectionPointer &amp;aServerConn,
+    PeerEncryptor(const Comm::ConnectionPointer &amp;aServerConn,
                   AsyncCall::Pointer &amp;aCallback,
                   const AccessLogEntryPointer &amp;alp,
                   const time_t timeout = 0);
-    virtual ~PeerConnector();
+    virtual ~PeerEncryptor();
 
 protected:
     // AsyncJob API
@@ -102,21 +101,22 @@
     /// silent server
     void setReadTimeout();
 
-    virtual Security::SessionPtr initializeSsl(); ///&lt; Initializes SSL state
+    /// Initializes encryption state
+    virtual Security::SessionPtr initialize();
 
     /// Performs a single secure connection negotiation step.
-    /// It is called multiple times untill the negotiation finish or aborted.
-    void negotiateSsl();
+    /// It is called multiple times untill the negotiation finishes or aborts.
+    void negotiate();
 
-    /// Called after SSL negotiations have finished. Cleans up SSL state.
+    /// Called after negotiation has finished. Cleans up TLS/SSL state.
     /// Returns false if we are now waiting for the certs validation job.
     /// Otherwise, returns true, regardless of negotiation success/failure.
     bool sslFinalized();
 
-    /// Called when the SSL negotiation step aborted because data needs to
-    /// be transferred to/from SSL server or on error. In the first case
+    /// Called when the negotiation step aborted because data needs to
+    /// be transferred to/from server or on error. In the first case
     /// setups the appropriate Comm::SetSelect handler. In second case
-    /// fill an error and report to the PeerConnector caller.
+    /// fill an error and report to the PeerEncryptor caller.
     void handleNegotiateError(const int result);
 
     /// Called when the openSSL SSL_connect fnction request more data from
@@ -132,7 +132,7 @@
     /// \param result the SSL_connect return code
     /// \param ssl_error the error code returned from the SSL_get_error function
     /// \param ssl_lib_error the error returned from the ERR_Get_Error function
-    virtual void noteSslNegotiationError(const int result, const int ssl_error, const int ssl_lib_error);
+    virtual void noteNegotiationError(const int result, const int ssl_error, const int ssl_lib_error);
 
     /// Called when the SSL negotiation to the server completed and the certificates
     /// validated using the cert validator.
@@ -140,16 +140,16 @@
     virtual void noteNegotiationDone(ErrorState *error) {}
 
     /// Must implemented by the kid classes to return the Security::ContextPtr object to use
-    /// for building the SSL objects.
+    /// for building the encryption context objects.
     virtual Security::ContextPtr getSslContext() = 0;
 
     /// mimics FwdState to minimize changes to FwdState::initiate/negotiateSsl
     Comm::ConnectionPointer const &amp;serverConnection() const { return serverConn; }
 
-    void bail(ErrorState *error); ///&lt; Return an error to the PeerConnector caller
+    void bail(ErrorState *error); ///&lt; Return an error to the PeerEncryptor caller
 
     /// Callback the caller class, and pass the ready to communicate secure
-    /// connection or an error if PeerConnector failed.
+    /// connection or an error if PeerEncryptor failed.
     void callBack();
 
     /// If called the certificates validator will not used
@@ -160,25 +160,26 @@
     AccessLogEntryPointer al; ///&lt; info for the future access.log entry
     AsyncCall::Pointer callback; ///&lt; we call this with the results
 private:
-    PeerConnector(const PeerConnector &amp;); // not implemented
-    PeerConnector &amp;operator =(const PeerConnector &amp;); // not implemented
+    PeerEncryptor(const PeerEncryptor &amp;); // not implemented
+    PeerEncryptor &amp;operator =(const PeerEncryptor &amp;); // not implemented
 
+#if USE_OPENSSL
     /// Process response from cert validator helper
     void sslCrtvdHandleReply(Ssl::CertValidationResponsePointer);
 
     /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
     Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &amp;, Ssl::ErrorDetail *&amp;);
+#endif
 
-    /// A wrapper function for negotiateSsl for use with Comm::SetSelect
-    static void NegotiateSsl(int fd, void *data);
+    /// A wrapper function for negotiate() for use with Comm::SetSelect
+    static void Negotiate(int fd, void *data);
     AsyncCall::Pointer closeHandler; ///&lt; we call this when the connection closed
-    time_t negotiationTimeout; ///&lt; the SSL connection timeout to use
-    time_t startTime; ///&lt; when the peer connector negotiation started
-    bool useCertValidator_; ///&lt; whether the certificate validator should bypassed
+    time_t negotiationTimeout; ///&lt; the encryption timeout to use
+    time_t startTime; ///&lt; when the encryption negotiation started
+    bool useCertValidator_; ///&lt; whether the certificate validator should be bypassed
 };
 
-} // namespace Ssl
+} // namespace Security
 
-#endif /* USE_OPENSSL */
-#endif /* SQUID_SRC_SSL_PEERCONNECTOR_H */
+#endif /* SQUID_SRC_SECURITY_PEERENCRYPTOR_H */
 

=== modified file 'src/security/Session.h'
--- src/security/Session.h	2016-02-13 12:12:10 +0000
+++ src/security/Session.h	2016-04-18 08:06:01 +0000
@@ -31,6 +31,10 @@
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer&lt;SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL&gt; SessionPointer;
 
+typedef SSL_SESSION* SessionStatePtr;
+CtoCpp1(SSL_SESSION_free, SSL_SESSION *);
+typedef LockingPointer&lt;SSL_SESSION, Security::SSL_SESSION_free_cpp, CRYPTO_LOCK_SSL_SESSION&gt; SessionStatePointer;
+
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
 CtoCpp1(gnutls_deinit, gnutls_session_t);

=== modified file 'src/security/forward.h'
--- src/security/forward.h	2016-01-01 00:12:18 +0000
+++ src/security/forward.h	2016-04-18 08:06:01 +0000
@@ -32,10 +32,6 @@
 namespace Security
 {
 
-class EncryptorAnswer;
-class PeerOptions;
-class ServerOptions;
-
 #if USE_OPENSSL
 CtoCpp1(X509_free, X509 *)
 typedef Security::LockingPointer&lt;X509, X509_free_cpp, CRYPTO_LOCK_X509&gt; CertPointer;
@@ -65,7 +61,11 @@
 typedef void *DhePointer;
 #endif
 
+class EncryptorAnswer;
 class KeyData;
+class PeerOptions;
+class ServerOptions;
+class PeerEncryptor;
 
 } // namespace Security
 

=== modified file 'src/ssl/Makefile.am'
--- src/ssl/Makefile.am	2016-02-01 11:52:03 +0000
+++ src/ssl/Makefile.am	2016-04-18 08:06:02 +0000
@@ -14,8 +14,6 @@
 libsslsquid_la_SOURCES = \
 	bio.cc \
 	bio.h \
-	BlindPeerConnector.cc \
-	BlindPeerConnector.h \
 	cert_validate_message.cc \
 	cert_validate_message.h \
 	context_storage.cc \
@@ -28,8 +26,6 @@
 	ErrorDetailManager.h \
 	PeekingPeerConnector.cc \
 	PeekingPeerConnector.h \
-	PeerConnector.cc \
-	PeerConnector.h \
 	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \

=== modified file 'src/ssl/PeekingPeerConnector.cc'
--- src/ssl/PeekingPeerConnector.cc	2016-02-13 07:51:20 +0000
+++ src/ssl/PeekingPeerConnector.cc	2016-04-22 13:21:24 +0000
@@ -97,7 +97,7 @@
         srvBio-&gt;holdWrite(false);
         srvBio-&gt;recordInput(false);
         debugs(83,5, &quot;Retry the fwdNegotiateSSL on FD &quot; &lt;&lt; serverConn-&gt;fd);
-        Ssl::PeerConnector::noteWantWrite();
+        Security::PeerEncryptor::noteWantWrite();
     } else {
         splice = true;
         // Ssl Negotiation stops here. Last SSL checks for valid certificates
@@ -134,9 +134,9 @@
 }
 
 Security::SessionPtr
-Ssl::PeekingPeerConnector::initializeSsl()
+Ssl::PeekingPeerConnector::initialize()
 {
-    auto ssl = Ssl::PeerConnector::initializeSsl();
+    auto ssl = Security::PeerEncryptor::initialize();
     if (!ssl)
         return nullptr;
 
@@ -282,11 +282,11 @@
         return;
     }
 
-    Ssl::PeerConnector::noteWantWrite();
+    Security::PeerEncryptor::noteWantWrite();
 }
 
 void
-Ssl::PeekingPeerConnector::noteSslNegotiationError(const int result, const int ssl_error, const int ssl_lib_error)
+Ssl::PeekingPeerConnector::noteNegotiationError(const int result, const int ssl_error, const int ssl_lib_error)
 {
     const int fd = serverConnection()-&gt;fd;
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
@@ -327,7 +327,7 @@
     }
 
     // else call parent noteNegotiationError to produce an error page
-    Ssl::PeerConnector::noteSslNegotiationError(result, ssl_error, ssl_lib_error);
+    Security::PeerEncryptor::noteNegotiationError(result, ssl_error, ssl_lib_error);
 }
 
 void

=== modified file 'src/ssl/PeekingPeerConnector.h'
--- src/ssl/PeekingPeerConnector.h	2016-02-12 10:45:47 +0000
+++ src/ssl/PeekingPeerConnector.h	2016-04-22 13:21:35 +0000
@@ -9,7 +9,7 @@
 #ifndef SQUID_SRC_SSL_PEEKINGPEERCONNECTOR_H
 #define SQUID_SRC_SSL_PEEKINGPEERCONNECTOR_H
 
-#include &quot;ssl/PeerConnector.h&quot;
+#include &quot;security/PeerEncryptor.h&quot;
 
 #if USE_OPENSSL
 
@@ -17,7 +17,7 @@
 {
 
 /// A PeerConnector for HTTP origin servers. Capable of SslBumping.
-class PeekingPeerConnector: public PeerConnector {
+class PeekingPeerConnector: public Security::PeerEncryptor {
     CBDATA_CLASS(PeekingPeerConnector);
 public:
     PeekingPeerConnector(HttpRequestPointer &amp;aRequest,
@@ -27,7 +27,7 @@
                          const AccessLogEntryPointer &amp;alp,
                          const time_t timeout = 0) :
         AsyncJob(&quot;Ssl::PeekingPeerConnector&quot;),
-        PeerConnector(aServerConn, aCallback, alp, timeout),
+        Security::PeerEncryptor(aServerConn, aCallback, alp, timeout),
         clientConn(aClientConn),
         splice(false),
         resumingSession(false),
@@ -36,11 +36,11 @@
         request = aRequest;
     }
 
-    /* PeerConnector API */
-    virtual Security::SessionPtr initializeSsl();
+    /* Security::PeerEncryptor API */
+    virtual Security::SessionPtr initialize();
     virtual Security::ContextPtr getSslContext();
     virtual void noteWantWrite();
-    virtual void noteSslNegotiationError(const int result, const int ssl_error, const int ssl_lib_error);
+    virtual void noteNegotiationError(const int result, const int ssl_error, const int ssl_lib_error);
     virtual void noteNegotiationDone(ErrorState *error);
 
     /// Updates associated client connection manager members

=== modified file 'src/ssl/helper.h'
--- src/ssl/helper.h	2016-02-01 11:52:03 +0000
+++ src/ssl/helper.h	2016-04-18 08:06:02 +0000
@@ -12,6 +12,7 @@
 #include &quot;base/AsyncJobCalls.h&quot;
 #include &quot;base/LruMap.h&quot;
 #include &quot;helper/forward.h&quot;
+#include &quot;security/forward.h&quot;
 #include &quot;ssl/cert_validate_message.h&quot;
 #include &quot;ssl/crtd_message.h&quot;
 
@@ -39,13 +40,12 @@
 };
 #endif
 
-class PeerConnector;
 class CertValidationRequest;
 class CertValidationResponse;
 class CertValidationHelper
 {
 public:
-    typedef UnaryMemFunT&lt;Ssl::PeerConnector, CertValidationResponse::Pointer&gt; CbDialer;
+    typedef UnaryMemFunT&lt;Security::PeerEncryptor, CertValidationResponse::Pointer&gt; CbDialer;
 
     typedef void CVHCB(void *, Ssl::CertValidationResponse const &amp;);
     static CertValidationHelper * GetInstance(); ///&lt; Instance class.

=== modified file 'src/tests/stub_libsecurity.cc'
--- src/tests/stub_libsecurity.cc	2016-01-26 21:02:00 +0000
+++ src/tests/stub_libsecurity.cc	2016-04-22 13:21:12 +0000
@@ -7,15 +7,49 @@
  */
 
 #include &quot;squid.h&quot;
+#include &quot;AccessLogEntry.h&quot;
 #include &quot;comm/Connection.h&quot;
+#include &quot;HttpRequest.h&quot;
 
 #define STUB_API &quot;security/libsecurity.la&quot;
 #include &quot;tests/STUB.h&quot;
 
+#include &quot;security/BlindPeerEncryptor.h&quot;
+CBDATA_NAMESPACED_CLASS_INIT(Security, BlindPeerEncryptor);
+Security::SessionPtr Security::BlindPeerEncryptor::initialize() STUB_RETVAL(nullptr)
+Security::ContextPtr Security::BlindPeerEncryptor::getSslContext() STUB_RETVAL(nullptr)
+void Security::BlindPeerEncryptor::noteNegotiationDone(ErrorState *) STUB
+
 #include &quot;security/EncryptorAnswer.h&quot;
 Security::EncryptorAnswer::~EncryptorAnswer() {}
 std::ostream &amp;Security::operator &lt;&lt;(std::ostream &amp;os, const Security::EncryptorAnswer &amp;) STUB_RETVAL(os)
 
+#include &quot;security/PeerEncryptor.h&quot;
+Security::PeerEncryptor::PeerEncryptor(const Comm::ConnectionPointer &amp;, AsyncCall::Pointer &amp;, const AccessLogEntryPointer &amp;, const time_t):
+    AsyncJob(&quot;Security::PeerEncryptor&quot;),
+    negotiationTimeout(0),
+    startTime(0),
+    useCertValidator_(false)
+{STUB}
+Security::PeerEncryptor::~PeerEncryptor() {STUB}
+void Security::PeerEncryptor::start() STUB
+bool Security::PeerEncryptor::doneAll() const STUB_RETVAL(true)
+void Security::PeerEncryptor::swanSong() STUB
+const char *Security::PeerEncryptor::status() const STUB_RETVAL(&quot;&quot;)
+void Security::PeerEncryptor::commCloseHandler(const CommCloseCbParams &amp;) STUB
+void Security::PeerEncryptor::connectionClosed(const char *) STUB
+bool Security::PeerEncryptor::prepareSocket() STUB
+void Security::PeerEncryptor::setReadTimeout() STUB
+Security::SessionPtr Security::PeerEncryptor::initialize() STUB_RETVAL(nullptr)
+void Security::PeerEncryptor::negotiate() STUB
+bool Security::PeerEncryptor::sslFinalized() STUB_RETVAL(false)
+void Security::PeerEncryptor::handleNegotiateError(const int) STUB
+void Security::PeerEncryptor::noteWantRead() STUB
+void Security::PeerEncryptor::noteWantWrite() STUB
+void Security::PeerEncryptor::noteNegotiationError(const int, const int, const int) STUB
+void Security::PeerEncryptor::bail(ErrorState *) STUB
+void Security::PeerEncryptor::callBack() STUB
+
 #include &quot;security/PeerOptions.h&quot;
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB

=== modified file 'src/tunnel.cc'
--- src/tunnel.cc	2016-04-03 23:41:58 +0000
+++ src/tunnel.cc	2016-04-19 12:00:39 +0000
@@ -33,9 +33,9 @@
 #include &quot;MemBuf.h&quot;
 #include &quot;PeerSelectState.h&quot;
 #include &quot;sbuf/SBuf.h&quot;
+#include &quot;security/BlindPeerEncryptor.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
-#include &quot;ssl/BlindPeerConnector.h&quot;
 #include &quot;StatCounters.h&quot;
 #if USE_OPENSSL
 #include &quot;ssl/bio.h&quot;
@@ -172,9 +172,8 @@
     void connectToPeer();
 
 private:
-#if USE_OPENSSL
-    /// Gives PeerConnector access to Answer in the TunnelStateData callback dialer.
-    class MyAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+    /// Gives Security::PeerEncryptor access to Answer in the TunnelStateData callback dialer.
+    class MyAnswerDialer: public CallDialer, public Security::PeerEncryptor::CbDialer
     {
     public:
         typedef void (TunnelStateData::*Method)(Security::EncryptorAnswer &amp;);
@@ -189,7 +188,7 @@
             os &lt;&lt; '(' &lt;&lt; tunnel_.get() &lt;&lt; &quot;, &quot; &lt;&lt; answer_ &lt;&lt; ')';
         }
 
-        /* Ssl::PeerConnector::CbDialer API */
+        /* Security::PeerEncryptor::CbDialer API */
         virtual Security::EncryptorAnswer &amp;answer() { return answer_; }
 
     private:
@@ -197,7 +196,6 @@
         CbcPointer&lt;TunnelStateData&gt; tunnel_;
         Security::EncryptorAnswer answer_;
     };
-#endif
 
     /// callback handler after connection setup (including any encryption)
     void connectedToPeer(Security::EncryptorAnswer &amp;answer);
@@ -1092,19 +1090,16 @@
 void
 TunnelStateData::connectToPeer()
 {
-#if USE_OPENSSL
     if (CachePeer *p = server.conn-&gt;getPeer()) {
         if (p-&gt;secure.encryptTransport) {
             AsyncCall::Pointer callback = asyncCall(5,4,
                                                     &quot;TunnelStateData::ConnectedToPeer&quot;,
                                                     MyAnswerDialer(&amp;TunnelStateData::connectedToPeer, this));
-            Ssl::BlindPeerConnector *connector =
-                new Ssl::BlindPeerConnector(request, server.conn, callback, al);
-            AsyncJob::Start(connector); // will call our callback
+            auto *encryptor = new Security::BlindPeerEncryptor(request, server.conn, callback, al);
+            AsyncJob::Start(encryptor); // will call our callback
             return;
         }
     }
-#endif
 
     Security::EncryptorAnswer nil;
     connectedToPeer(nil);

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005599.html">[squid-dev] [PATCH] PeerConnector shuffling to libsecurity
</A></li>
	<LI>Next message: <A HREF="005597.html">[squid-dev] [PATCH] Remove SquidList / link_list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5612">[ date ]</a>
              <a href="thread.html#5612">[ thread ]</a>
              <a href="subject.html#5612">[ subject ]</a>
              <a href="author.html#5612">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
