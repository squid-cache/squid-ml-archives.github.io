<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] GnuTLS session redo
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20GnuTLS%20session%20redo&In-Reply-To=%3Cbf48fb40-6266-3537-b77a-a1d8f4b2e91f%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006597.html">
   <LINK REL="Next"  HREF="006510.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] GnuTLS session redo</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20GnuTLS%20session%20redo&In-Reply-To=%3Cbf48fb40-6266-3537-b77a-a1d8f4b2e91f%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] GnuTLS session redo">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Aug  4 05:57:00 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006597.html">[squid-dev] Benchmarking Performance with reuseport
</A></li>
        <LI>Next message: <A HREF="006510.html">[squid-dev] [PATCH] GnuTLS session redo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6509">[ date ]</a>
              <a href="thread.html#6509">[ thread ]</a>
              <a href="subject.html#6509">[ subject ]</a>
              <a href="author.html#6509">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Attached is an updated version of the TLS session resume patch which was
previously reverted due to a crash issue.

Trunk no longer needs the implicit conversion that turned out to be
behind that issue. However, I would still like to get this change tested
by someone with OpenSSL to confirm that there is nothing else hiding.

Cheers
Amos
-------------- next part --------------
=== modified file 'src/CachePeer.cc'
--- src/CachePeer.cc	2016-07-18 12:36:38 +0000
+++ src/CachePeer.cc	2016-08-01 13:05:56 +0000
@@ -25,41 +25,40 @@
     typelist(NULL),
     access(NULL),
     weight(1),
     basetime(0),
 #if USE_CACHE_DIGESTS
     digest(NULL),
     digest_url(NULL),
 #endif
     tcp_up(0),
     n_addresses(0),
     rr_count(0),
     next(NULL),
     testing_now(false),
     login(NULL),
     connect_timeout(0),
     connect_fail_limit(0),
     max_conn(0),
     domain(NULL),
 #if USE_OPENSSL
     sslContext(NULL),
-    sslSession(NULL),
 #endif
     front_end_https(0),
     connection_auth(2 /* auto */)
 {
     memset(&amp;stats, 0, sizeof(stats));
     stats.logged_state = PEER_ALIVE;
 
     memset(&amp;icp, 0, sizeof(icp));
     icp.port = CACHE_ICP_PORT;
     icp.version = ICP_VERSION_CURRENT;
 
 #if USE_HTCP
     memset(&amp;htcp, 0, sizeof(htcp));
 #endif
     memset(&amp;options, 0, sizeof(options));
     memset(&amp;mcast, 0, sizeof(mcast));
     memset(&amp;carp, 0, sizeof(carp));
 #if USE_AUTH
     memset(&amp;userhash, 0, sizeof(userhash));
 #endif
@@ -85,26 +84,23 @@
 
 #if USE_CACHE_DIGESTS
     cbdataReferenceDone(digest);
     xfree(digest_url);
 #endif
 
     delete next;
 
     xfree(login);
 
     delete standby.pool;
 
     // the mgr job will notice that its owner is gone and stop
     PeerPoolMgr::Checkpoint(standby.mgr, &quot;peer gone&quot;);
 
     xfree(domain);
 
 #if USE_OPENSSL
     if (sslContext)
         SSL_CTX_free(sslContext);
-
-    if (sslSession)
-        SSL_SESSION_free(sslSession);
 #endif
 }
 

=== modified file 'src/CachePeer.h'
--- src/CachePeer.h	2016-07-18 12:36:38 +0000
+++ src/CachePeer.h	2016-08-01 13:05:56 +0000
@@ -167,30 +167,28 @@
         unsigned int hash;
         double load_multiplier;
         double load_factor; /* normalized weight value */
     } sourcehash;
 
     char *login;        /* Proxy authorization */
     time_t connect_timeout;
     int connect_fail_limit;
     int max_conn;
     struct {
         PconnPool *pool; ///&lt; idle connection pool for this peer
         CbcPointer&lt;PeerPoolMgr&gt; mgr; ///&lt; pool manager
         int limit; ///&lt; the limit itself
         bool waitingForClose; ///&lt; a conn must close before we open a standby conn
     } standby; ///&lt; optional &quot;cache_peer standby=limit&quot; feature
     char *domain;       /* Forced domain */
 
     /// security settings for peer connection
     Security::PeerOptions secure;
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
     int front_end_https;
     int connection_auth;
 };
 
 #endif /* SQUID_CACHEPEER_H_ */
 

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2016-08-01 11:11:47 +0000
+++ src/Makefile.am	2016-08-03 17:42:21 +0000
@@ -529,46 +529,46 @@
 	$(BUILT_SOURCES)
 
 squid_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	clients/libclients.la \
 	servers/libservers.la \
 	ftp/libftp.la \
 	helper/libhelper.la \
 	http/libhttp.la \
 	dns/libdns.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	DiskIO/libdiskio.la \
+	comm/libcomm.la \
+	security/libsecurity.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
-	comm/libcomm.la \
-	security/libsecurity.la \
 	parser/libparser.la \
 	eui/libeui.la \
 	icmp/libicmp.la \
 	log/liblog.la \
 	format/libformat.la \
 	sbuf/libsbuf.la \
 	$(XTRA_OBJS) \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SNMP_LIBS) \
 	mem/libmem.la \
 	store/libstore.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(ATOMICLIB) \

=== modified file 'src/adaptation/icap/ServiceRep.cc'
--- src/adaptation/icap/ServiceRep.cc	2016-07-18 12:36:38 +0000
+++ src/adaptation/icap/ServiceRep.cc	2016-08-01 13:05:56 +0000
@@ -17,43 +17,40 @@
 #include &quot;adaptation/icap/ServiceRep.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 
 #define DEFAULT_ICAP_PORT   1344
 #define DEFAULT_ICAPS_PORT 11344
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &amp;svcCfg):
     AsyncJob(&quot;Adaptation::Icap::ServiceRep&quot;), Adaptation::Service(svcCfg),
     sslContext(NULL),
-#if USE_OPENSSL
-    sslSession(NULL),
-#endif
     theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
     connOverloadReported(false),
     theIdleConns(NULL),
     isSuspended(0), notifying(false),
     updateScheduled(false),
     wasAnnouncedUp(true), // do not announce an &quot;up&quot; service at startup
     isDetached(false)
 {
     setMaxConnections();
     theIdleConns = new IdleConnList(&quot;ICAP Service&quot;, NULL);
 }
 
 Adaptation::Icap::ServiceRep::~ServiceRep()
 {
     delete theIdleConns;
     Must(!theOptionsFetcher);
     delete theOptions;
 }

=== modified file 'src/adaptation/icap/ServiceRep.h'
--- src/adaptation/icap/ServiceRep.h	2016-07-18 12:36:38 +0000
+++ src/adaptation/icap/ServiceRep.h	2016-08-01 13:05:56 +0000
@@ -94,43 +94,41 @@
 
     void noteNewWaiter() {theAllWaiters++;} ///&lt; New xaction waiting for service to be up or available
     void noteGoneWaiter(); ///&lt; An xaction is not waiting any more for service to be available
     bool existWaiters() const {return (theAllWaiters &gt; 0);} ///&lt; if there are xactions waiting for the service to be available
 
     //AsyncJob virtual methods
     virtual bool doneAll() const { return Adaptation::Initiator::doneAll() &amp;&amp; false;}
     virtual void callException(const std::exception &amp;e);
 
     virtual void detach();
     virtual bool detached() const;
 
 public: // treat these as private, they are for callbacks only
     void noteTimeToUpdate();
     void noteTimeToNotify();
 
     // receive either an ICAP OPTIONS response header or an abort message
     virtual void noteAdaptationAnswer(const Answer &amp;answer);
 
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
 private:
     // stores Prepare() callback info
 
     struct Client {
         Pointer service; // one for each client to preserve service
         AsyncCall::Pointer callback;
     };
 
     typedef std::vector&lt;Client&gt; Clients;
     // TODO: rename to theUpWaiters
     Clients theClients; // all clients waiting for a call back
 
     Options *theOptions;
     CbcPointer&lt;Adaptation::Initiate&gt; theOptionsFetcher; // pending ICAP OPTIONS transaction
     time_t theLastUpdate; // time the options were last updated
 
     /// FIFO queue of xactions waiting for a connection slot and not yet notified
     /// about it; xaction is removed when notification is scheduled
     std::deque&lt;Client&gt; theNotificationWaiters;

=== modified file 'src/adaptation/icap/Xaction.cc'
--- src/adaptation/icap/Xaction.cc	2016-07-27 11:06:57 +0000
+++ src/adaptation/icap/Xaction.cc	2016-08-01 13:34:30 +0000
@@ -693,74 +693,62 @@
 void Adaptation::Icap::Xaction::fillDoneStatus(MemBuf &amp;buf) const
 {
     if (haveConnection() &amp;&amp; commEof)
         buf.appendf(&quot;Comm(%d)&quot;, connection-&gt;fd);
 
     if (stopReason != NULL)
         buf.append(&quot;Stopped&quot;, 7);
 }
 
 bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &amp;) const
 {
     return false;
 }
 
 bool
 Ssl::IcapPeerConnector::initializeTls(Security::SessionPointer &amp;serverSession)
 {
     if (!Security::PeerConnector::initializeTls(serverSession))
         return false;
 
-#if USE_OPENSSL
     assert(!icapService-&gt;cfg().secure.sslDomain.isEmpty());
+#if USE_OPENSSL
     SBuf *host = new SBuf(icapService-&gt;cfg().secure.sslDomain);
     SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
 
     ACLFilledChecklist *check = static_cast&lt;ACLFilledChecklist *&gt;(SSL_get_ex_data(serverSession.get(), ssl_ex_index_cert_error_check));
     if (check)
         check-&gt;dst_peer_name = *host;
+#endif
 
-    if (icapService-&gt;sslSession)
-        SSL_set_session(serverSession.get(), icapService-&gt;sslSession);
-
+    Security::SetSessionResumeData(serverSession, icapService-&gt;sslSession);
     return true;
-#else
-    return false;
-#endif
 }
 
 void
 Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
 {
     if (error)
         return;
 
-#if USE_OPENSSL
     const int fd = serverConnection()-&gt;fd;
-    auto ssl = fd_table[fd].ssl.get();
-    assert(ssl);
-    if (!SSL_session_reused(ssl)) {
-        if (icapService-&gt;sslSession)
-            SSL_SESSION_free(icapService-&gt;sslSession);
-        icapService-&gt;sslSession = SSL_get1_session(ssl);
-    }
-#endif
+    Security::GetSessionResumeData(fd_table[fd].ssl, icapService-&gt;sslSession);
 }
 
 void
 Adaptation::Icap::Xaction::handleSecuredPeer(Security::EncryptorAnswer &amp;answer)
 {
     Must(securer != NULL);
     securer = NULL;
 
     if (closer != NULL) {
         if (answer.conn != NULL)
             comm_remove_close_handler(answer.conn-&gt;fd, closer);
         else
             closer-&gt;cancel(&quot;securing completed&quot;);
         closer = NULL;
     }
 
     if (answer.error.get()) {
         if (answer.conn != NULL)
             answer.conn-&gt;close();
         debugs(93, 2, typeName &lt;&lt;

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2016-08-01 11:11:47 +0000
+++ src/client_side.cc	2016-08-01 13:05:56 +0000
@@ -2638,41 +2638,41 @@
         /* NOTREACHED */
     }
     return 1;
 }
 
 /** negotiate an SSL connection */
 static void
 clientNegotiateSSL(int fd, void *data)
 {
     ConnStateData *conn = (ConnStateData *)data;
     X509 *client_cert;
     auto ssl = fd_table[fd].ssl.get();
 
     int ret;
     if ((ret = Squid_SSL_accept(conn, clientNegotiateSSL)) &lt;= 0) {
         if (ret &lt; 0) // An error
             conn-&gt;clientConnection-&gt;close();
         return;
     }
 
-    if (SSL_session_reused(ssl)) {
+    if (Security::SessionIsResumed(fd_table[fd].ssl)) {
         debugs(83, 2, &quot;clientNegotiateSSL: Session &quot; &lt;&lt; SSL_get_session(ssl) &lt;&lt;
                &quot; reused on FD &quot; &lt;&lt; fd &lt;&lt; &quot; (&quot; &lt;&lt; fd_table[fd].ipaddr &lt;&lt; &quot;:&quot; &lt;&lt; (int)fd_table[fd].remote_port &lt;&lt; &quot;)&quot;);
     } else {
         if (Debug::Enabled(83, 4)) {
             /* Write out the SSL session details.. actually the call below, but
              * OpenSSL headers do strange typecasts confusing GCC.. */
             /* PEM_write_SSL_SESSION(debug_log, SSL_get_session(ssl)); */
 #if defined(OPENSSL_VERSION_NUMBER) &amp;&amp; OPENSSL_VERSION_NUMBER &gt;= 0x00908000L
             PEM_ASN1_write((i2d_of_void *)i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, debug_log, (char *)SSL_get_session(ssl), NULL,NULL,0,NULL,NULL);
 
 #elif (ALLOW_ALWAYS_SSL_SESSION_DETAIL == 1)
 
             /* When using gcc 3.3.x and OpenSSL 0.9.7x sometimes a compile error can occur here.
             * This is caused by an unpredicatble gcc behaviour on a cast of the first argument
             * of PEM_ASN1_write(). For this reason this code section is disabled. To enable it,
             * define ALLOW_ALWAYS_SSL_SESSION_DETAIL=1.
             * Because there are two possible usable cast, if you get an error here, try the other
             * commented line. */
 
             PEM_ASN1_write((int(*)())i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, debug_log, (char *)SSL_get_session(ssl), NULL,NULL,0,NULL,NULL);

=== modified file 'src/security/BlindPeerConnector.cc'
--- src/security/BlindPeerConnector.cc	2016-07-27 11:06:57 +0000
+++ src/security/BlindPeerConnector.cc	2016-08-01 13:18:47 +0000
@@ -29,56 +29,49 @@
     return ::Config.ssl_client.sslContext;
 }
 
 bool
 Security::BlindPeerConnector::initializeTls(Security::SessionPointer &amp;serverSession)
 {
     if (!Security::PeerConnector::initializeTls(serverSession))
         return false;
 
     if (const CachePeer *peer = serverConnection()-&gt;getPeer()) {
         assert(peer);
 
         // NP: domain may be a raw-IP but it is now always set
         assert(!peer-&gt;secure.sslDomain.isEmpty());
 
 #if USE_OPENSSL
         // const loss is okay here, ssl_ex_index_server is only read and not assigned a destructor
         SBuf *host = new SBuf(peer-&gt;secure.sslDomain);
         SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
 
-        if (peer-&gt;sslSession)
-            SSL_set_session(serverSession.get(), peer-&gt;sslSession);
+        Security::SetSessionResumeData(serverSession, peer-&gt;sslSession);
     } else {
         SBuf *hostName = new SBuf(request-&gt;url.host());
         SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, (void*)hostName);
 #endif
     }
     return true;
 }
 
 void
 Security::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
 {
     if (error) {
         // XXX: forward.cc calls peerConnectSucceeded() after an OK TCP connect but
         // we call peerConnectFailed() if SSL failed afterwards. Is that OK?
         // It is not clear whether we should call peerConnectSucceeded/Failed()
         // based on TCP results, SSL results, or both. And the code is probably not
         // consistent in this aspect across tunnelling and forwarding modules.
         if (CachePeer *p = serverConnection()-&gt;getPeer())
             peerConnectFailed(p);
         return;
     }
 
-#if USE_OPENSSL
-    const int fd = serverConnection()-&gt;fd;
-    Security::SessionPtr ssl = fd_table[fd].ssl.get();
-    if (serverConnection()-&gt;getPeer() &amp;&amp; !SSL_session_reused(ssl)) {
-        if (serverConnection()-&gt;getPeer()-&gt;sslSession)
-            SSL_SESSION_free(serverConnection()-&gt;getPeer()-&gt;sslSession);
-
-        serverConnection()-&gt;getPeer()-&gt;sslSession = SSL_get1_session(ssl);
+    if (auto *peer = serverConnection()-&gt;getPeer()) {
+        const int fd = serverConnection()-&gt;fd;
+        Security::GetSessionResumeData(fd_table[fd].ssl, peer-&gt;sslSession);
     }
-#endif
 }
 

=== modified file 'src/security/Session.cc'
--- src/security/Session.cc	2016-07-18 12:36:38 +0000
+++ src/security/Session.cc	2016-08-04 05:25:27 +0000
@@ -1,38 +1,77 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;ipc/MemMap.h&quot;
 #include &quot;security/Session.h&quot;
 #include &quot;SquidConfig.h&quot;
 
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
+bool
+Security::SessionIsResumed(const Security::SessionPointer &amp;s)
+{
+    return
+#if USE_OPENSSL
+        SSL_session_reused(s.get()) == 1;
+#elif USE_GNUTLS
+        gnutls_session_is_resumed(s.get()) != 0;
+#else
+        false;
+#endif
+}
+
+void
+Security::GetSessionResumeData(const Security::SessionPointer &amp;s, Security::SessionStatePointer &amp;data)
+{
+    if (!SessionIsResumed(s)) {
+#if USE_OPENSSL
+        data.reset(SSL_get1_session(s.get()));
+#elif USE_GNUTLS
+        gnutls_datum_t *tmp = nullptr;
+        (void)gnutls_session_get_data2(s.get(), tmp);
+        data.reset(tmp);
+#endif
+    }
+}
+
+void
+Security::SetSessionResumeData(const Security::SessionPointer &amp;s, const Security::SessionStatePointer &amp;data)
+{
+    if (data) {
+#if USE_OPENSSL
+        (void)SSL_set_session(s.get(), data.get());
+#elif USE_GNUTLS
+        (void)gnutls_session_set_data(s.get(), data-&gt;data, data-&gt;size);
+#endif
+    }
+}
+
 static bool
 isTlsServer()
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != nullptr; s = s-&gt;next) {
         if (s-&gt;secure.encryptTransport)
             return true;
         if (s-&gt;flags.tunnelSslBumping)
             return true;
     }
 
     return false;
 }
 
 void
 initializeSessionCache()
 {
 #if USE_OPENSSL
     // Check if the MemMap keys and data are enough big to hold
     // session ids and session data
     assert(SSL_SESSION_ID_SIZE &gt;= MEMMAP_SLOT_KEY_SIZE);

=== modified file 'src/security/Session.h'
--- src/security/Session.h	2016-07-18 12:36:38 +0000
+++ src/security/Session.h	2016-08-02 05:17:39 +0000
@@ -1,54 +1,73 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_SESSION_H
 #define SQUID_SRC_SECURITY_SESSION_H
 
+#include &quot;base/HardFun.h&quot;
 #include &quot;security/LockingPointer.h&quot;
 
 #include &lt;memory&gt;
 
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 #endif
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_GNUTLS_H
 #include &lt;gnutls/gnutls.h&gt;
 #endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
 typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer&lt;SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL&gt; SessionPointer;
 
+typedef std::unique_ptr&lt;SSL_SESSION, HardFun&lt;void, SSL_SESSION*, &amp;SSL_SESSION_free&gt;&gt; SessionStatePointer;
+
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
 // Locks can be implemented attaching locks counter to gnutls_session_t
 // objects using the gnutls_session_set_ptr()/gnutls_session_get_ptr ()
 // library functions
 CtoCpp1(gnutls_deinit, gnutls_session_t);
 typedef LockingPointer&lt;struct gnutls_session_int, gnutls_deinit_cpp, -1&gt; SessionPointer;
 
+// wrapper function to get around gnutls_free being a typedef
+inline void squid_gnutls_free(void *d) {gnutls_free(d);}
+typedef std::unique_ptr&lt;gnutls_datum_t, HardFun&lt;void, void*, &amp;Security::squid_gnutls_free&gt;&gt; SessionStatePointer;
+
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
 CtoCpp1(xfree, SessionPtr);
 typedef LockingPointer&lt;void, xfree_cpp, -1&gt; SessionPointer;
 
+typedef std::unique_ptr&lt;int&gt; SessionStatePointer;
+
 #endif
 
+/// whether the session is a resumed one
+bool SessionIsResumed(const Security::SessionPointer &amp;);
+
+/// Retrieve the data needed to resume this session on a later connection
+void GetSessionResumeData(const Security::SessionPointer &amp;, Security::SessionStatePointer &amp;);
+
+/// Set the data for resuming a previous session.
+/// Needs to be done before using the SessionPointer for a handshake.
+void SetSessionResumeData(const Security::SessionPointer &amp;, const Security::SessionStatePointer &amp;);
+
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
 

=== modified file 'src/tests/stub_libsecurity.cc'
--- src/tests/stub_libsecurity.cc	2016-07-27 21:16:35 +0000
+++ src/tests/stub_libsecurity.cc	2016-08-04 05:25:31 +0000
@@ -69,20 +69,27 @@
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
 Security::ContextPtr Security::PeerOptions::createClientContext(bool) STUB_RETVAL(NULL)
 void Security::PeerOptions::updateTlsVersionLimits() STUB
 Security::ContextPtr Security::PeerOptions::createBlankContext() const STUB
 void Security::PeerOptions::updateContextCa(Security::ContextPtr &amp;) STUB
 void Security::PeerOptions::updateContextCrl(Security::ContextPtr &amp;) STUB
 void Security::PeerOptions::dumpCfg(Packable*, char const*) const STUB
 long Security::PeerOptions::parseOptions() STUB_RETVAL(0)
 long Security::PeerOptions::parseFlags() STUB_RETVAL(0)
 void parse_securePeerOptions(Security::PeerOptions *) STUB
 
 #include &quot;security/ServerOptions.h&quot;
 //Security::ServerOptions::ServerOptions(const Security::ServerOptions &amp;) STUB
 void Security::ServerOptions::parse(const char *) STUB
 void Security::ServerOptions::dumpCfg(Packable *, const char *) const STUB
 Security::ContextPtr Security::ServerOptions::createBlankContext() const STUB
 bool Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &amp;) STUB_RETVAL(false)
 void Security::ServerOptions::updateContextEecdh(Security::ContextPtr &amp;) STUB
 
+#include &quot;security/Session.h&quot;
+namespace Security {
+bool SessionIsResumed(const Security::SessionPointer &amp;) STUB_RETVAL(false)
+void GetSessionResumeData(const Security::SessionPointer &amp;, Security::SessionStatePointer &amp;) STUB
+void SetSessionResumeData(const Security::SessionPointer &amp;, const Security::SessionStatePointer &amp;) STUB
+} // namespace Security
+

</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006597.html">[squid-dev] Benchmarking Performance with reuseport
</A></li>
	<LI>Next message: <A HREF="006510.html">[squid-dev] [PATCH] GnuTLS session redo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6509">[ date ]</a>
              <a href="thread.html#6509">[ thread ]</a>
              <a href="subject.html#6509">[ subject ]</a>
              <a href="author.html#6509">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
