<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Revalidate without Last-Modified
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Revalidate%20without%20Last-Modified&In-Reply-To=%3C95eb6599-8ec3-3622-fa6c-ff82aac4eb7b%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006630.html">
   <LINK REL="Next"  HREF="006638.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Revalidate without Last-Modified</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Revalidate%20without%20Last-Modified&In-Reply-To=%3C95eb6599-8ec3-3622-fa6c-ff82aac4eb7b%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Revalidate without Last-Modified">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Aug 25 16:41:25 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006630.html">[squid-dev] [PATCH] Revalidate without Last-Modified
</A></li>
        <LI>Next message: <A HREF="006638.html">[squid-dev] [PATCH] Revalidate without Last-Modified
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6632">[ date ]</a>
              <a href="thread.html#6632">[ thread ]</a>
              <a href="subject.html#6632">[ subject ]</a>
              <a href="author.html#6632">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 26/08/2016 3:52 a.m., Alex Rousskov wrote:
&gt;<i> On 08/25/2016 04:04 AM, Eduard Bagdasaryan wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Therefore, we could use the timestamp if Last-Modified is unavailable.
</I>&gt;<i> 
</I>&gt;<i> I do not understand why the patch hides the lastmod field behind a basic
</I>&gt;<i> getter. If we assert that a timestamp-based last modification value
</I>&gt;<i> should be used in many cases, then we need to force the calling code to
</I>&gt;<i> make an important choice between a raw lastmod and a timestamp-based
</I>&gt;<i> last modification value.
</I>&gt;<i> 
</I>&gt;<i> The patch does not force the caller to make that choice because
</I>&gt;<i> developers will naturally call lastModified() getter instead of
</I>&gt;<i> effectiveModificationTime(). If calling lastModified() produces more
</I>&gt;<i> problems like the one you are trying to fix (with reviewers not being
</I>&gt;<i> able to guess that the wrong method was called), then renaming lastmod_
</I>&gt;<i> accomplished nothing. Similarly, if calling lastModified() produces no
</I>&gt;<i> new problems (because the lastmod usage case you were fixing happened to
</I>&gt;<i> be exceptional rather than the norm), then renaming lastmod_ also
</I>&gt;<i> accomplished nothing.
</I>&gt;<i> 
</I>&gt;<i> The patch does use effectiveModificationTime() in several places already
</I>&gt;<i> so I suspect its usage is not that exceptional -- many, possibly even
</I>&gt;<i> most contexts should use effectiveModificationTime(). If you agree, then
</I>&gt;<i> we should make using lastmod_ getter more difficult -- the developer and
</I>&gt;<i> the reviewer should be forced to pay attention to such use because it is
</I>&gt;<i> likely to indicate a bug in new code (i.e., the new code should have
</I>&gt;<i> called effectiveModificationTime() instead).
</I>&gt;<i> 
</I>&gt;<i> Moreover, these raw lastmod abuse problems might be already surfacing in
</I>&gt;<i> your own patch! I see several raw lastmod value uses there:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 1. Misleading debugging:
</I>&gt;<i> 
</I>&gt;&gt;<i> +    const time_t lastmod = http-&gt;storeEntry()-&gt;effectiveModificationTime();
</I>&gt;&gt;<i> +    http-&gt;request-&gt;lastmod = lastmod;
</I>&gt;<i> ...
</I>&gt;&gt;<i> -    debugs(88, 5, &quot;clientReplyContext::processExpired : lastmod &quot; &lt;&lt; entry-&gt;lastmod );
</I>&gt;&gt;<i> +    debugs(88, 5, &quot;lastmod &quot; &lt;&lt; entry-&gt;lastModified());
</I>&gt;<i> 
</I>&gt;<i> In other words, Squid is going to use the effective modification time,
</I>&gt;<i> but we are logging raw time to make triage harder.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2. Writing -1 to cache store metadata:
</I>&gt;<i> 
</I>&gt;&gt;<i>      currentEntry(sd-&gt;addDiskRestore(key,
</I>&gt;&gt;<i>                                      tmpe.timestamp,
</I>&gt;<i> ...
</I>&gt;&gt;<i> -                                    tmpe.lastmod,
</I>&gt;&gt;<i> +                                    tmpe.lastModified(),
</I>&gt;<i> 
</I>&gt;<i> and
</I>&gt;<i> 
</I>&gt;&gt;<i>      StoreSwapLogData s;
</I>&gt;&gt;<i>      s.timestamp = e.timestamp;
</I>&gt;<i> ...
</I>&gt;&gt;<i> -    s.lastmod = e.lastmod;
</I>&gt;&gt;<i> +    s.lastmod = e.lastModified();
</I>&gt;<i> 
</I>&gt;<i> and
</I>&gt;<i> 
</I>&gt;&gt;<i> -    basics.lastmod = from.lastmod;
</I>&gt;&gt;<i> +    basics.lastmod = from.lastModified();
</I>&gt;<i> 
</I>&gt;<i> Does a store need raw lastmod or effective modification time? I suspect
</I>&gt;<i> it is the latter, but perhaps I am missing some valid use cases for the
</I>&gt;<i> former. This needs a careful consideration.
</I>&gt;<i> 
</I>&gt;<i> If we are lucky, there is a relatively simple way to answer this
</I>&gt;<i> question: If the stored lastmod value is only used to re-initialize some
</I>&gt;<i> future StoreEntry::lastmod_ value _and_ all non-debugging uses of
</I>&gt;<i> StoreEntry::lastmod_ are going to be via effectiveModificationTime(),
</I>&gt;<i> then we can store effective modification time instead of -1!
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 3. Sending an HTCP message to another service.
</I>&gt;<i> 
</I>&gt;&gt;<i> -            hdr.putTime(Http::HdrType::LAST_MODIFIED, e-&gt;lastmod);
</I>&gt;&gt;<i> +        if (e &amp;&amp; e-&gt;lastModified() &gt; -1)
</I>&gt;&gt;<i> +            hdr.putTime(Http::HdrType::LAST_MODIFIED, e-&gt;lastModified());
</I>&gt;<i> 
</I>&gt;<i> Is this a conditional/revalidation request? If yes, then should we use
</I>&gt;<i> an effective modification time instead, like we do in use case #1?
</I>

NP: From the protocol perspective Last-Modified can always be
synthesized from either Date or Date+Age, for *any* request. At worst it
will be conservatively *later* than the real (but absent) LM timestamp.

Thus effectiveModificationTime() is always acceptible as the lastmod
value. Even when its not taken from an actual L-M header.

AFAIK, the only actual need uses of lastModified() getter are when
checking for the headers explicit existence. Which should be doing so
via the HttpHeader object listing headers, not the Store metadata
(calculated) values.

Amos

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006630.html">[squid-dev] [PATCH] Revalidate without Last-Modified
</A></li>
	<LI>Next message: <A HREF="006638.html">[squid-dev] [PATCH] Revalidate without Last-Modified
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6632">[ date ]</a>
              <a href="thread.html#6632">[ thread ]</a>
              <a href="subject.html#6632">[ subject ]</a>
              <a href="author.html#6632">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
