<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Compilation fix for v5 r14973
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Compilation%20fix%20for%20v5%20r14973&In-Reply-To=%3C83dc447a-b696-54d7-6825-8aff8f863cc3%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007490.html">
   <LINK REL="Next"  HREF="007492.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Compilation fix for v5 r14973</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Compilation%20fix%20for%20v5%20r14973&In-Reply-To=%3C83dc447a-b696-54d7-6825-8aff8f863cc3%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Compilation fix for v5 r14973">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Dec 12 08:16:56 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007490.html">[squid-dev] [PATCH] Compilation fix for v5 r14973
</A></li>
        <LI>Next message: <A HREF="007492.html">[squid-dev] [PATCH] Compilation fix for v5 r14973
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7491">[ date ]</a>
              <a href="thread.html#7491">[ thread ]</a>
              <a href="subject.html#7491">[ subject ]</a>
              <a href="author.html#7491">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/12/2016 10:35 p.m., Eduard Bagdasaryan wrote:
&gt;<i> Attached a patch witch removes SquidConfig  dependency
</I>&gt;<i> on vector&lt;SchemesConfigs&gt; and uses vector&lt;SchemesConfigs&gt; *.
</I>&gt;<i> instead. This fixes pinger linking error.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Eduard.
</I>&gt;<i> 
</I>
Attached is an alternative that fits better (but not completely) with
the HotConf project goals.

Specifically the change is to move the auth specific config object into
Auth:: namespace scope insead of placing it within SquidConfig.

I have not in this patch refactored the existing Auth::Config to contain
both auth_params and auth_schemes data. Or moved the new accessList
raw-pointer. This is just a quick shuffle to fix the current link errors.

Alex: Care to make the call between one of these two patches or wait a
day or so more for the full refactor ?

Amos


&gt;<i> On 10.12.2016 23:55, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 11/12/2016 6:12 a.m., Christos Tsantilas wrote:
</I>&gt;&gt;&gt;<i> I applied the patch, however still exist problem. The icmp pinger does
</I>&gt;&gt;&gt;<i> not build correctly.
</I>&gt;&gt;&gt;<i> We should add libsbuf library to pinger libraries, but still there are
</I>&gt;&gt;&gt;<i> references to HistStat.cc file (maybe add HistStat stub files for
</I>&gt;&gt;&gt;<i> pinger?).
</I>&gt;&gt;<i> pinger does not use the Auth:: things, so it really should not pull them
</I>&gt;&gt;<i> + dependencies in.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The correct fix I think is to refactor the Auth::Config so that the
</I>&gt;&gt;<i> various global auth* directives can all be stored there. I'm working on
</I>&gt;&gt;<i> that right now.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Amos
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> squid-dev mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i> 
</I>
-------------- next part --------------
=== modified file 'src/SquidConfig.h'
--- src/SquidConfig.h	2016-12-10 04:48:25 +0000
+++ src/SquidConfig.h	2016-12-11 07:26:50 +0000
@@ -1,35 +1,32 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SQUIDCONFIG_H_
 #define SQUID_SQUIDCONFIG_H_
 
 #include &quot;acl/forward.h&quot;
-#if USE_AUTH
-#include &quot;auth/SchemesConfig.h&quot;
-#endif
 #include &quot;base/RefCount.h&quot;
 #include &quot;base/YesNoNone.h&quot;
 #include &quot;ClientDelayConfig.h&quot;
 #include &quot;DelayConfig.h&quot;
 #include &quot;helper/ChildConfig.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;Notes.h&quot;
 #include &quot;security/forward.h&quot;
 #include &quot;SquidTime.h&quot;
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 #include &quot;store/forward.h&quot;
 
 #if USE_OPENSSL
 class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
 
@@ -526,44 +523,40 @@
 
 #if USE_LOADABLE_MODULES
     wordlist *loadable_module_names;
 #endif
 
     int client_ip_max_connections;
 
     char *redirector_extras;
 
     struct UrlHelperTimeout {
         int action;
         char *response;
     } onUrlRewriteTimeout;
 
     char *storeId_extras;
 
     struct {
         int v4_first;       ///&lt; Place IPv4 first in the order of DNS results.
         ssize_t packet_max; ///&lt; maximum size EDNS advertised for DNS replies.
     } dns;
-
-#if USE_AUTH
-    Auth::SchemesConfigs authSchemesConfigs;
-#endif
 };
 
 extern SquidConfig Config;
 
 class SquidConfig2
 {
 public:
     void clear() {
         *this = SquidConfig2();
     }
 
     struct {
         int enable_purge = 0;
     } onoff;
     uid_t effectiveUserID = 0;
     gid_t effectiveGroupID = 0;
 };
 
 extern SquidConfig2 Config2;
 

=== modified file 'src/auth/SchemesConfig.cc'
--- src/auth/SchemesConfig.cc	2016-12-10 04:48:25 +0000
+++ src/auth/SchemesConfig.cc	2016-12-11 10:19:34 +0000
@@ -1,34 +1,39 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;auth/Config.h&quot;
 #include &quot;auth/SchemesConfig.h&quot;
 #include &quot;fatal.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 
+namespace Auth
+{
+std::vector&lt;Auth::SchemesConfig&gt; SchemeListConfig;
+}
+
 static void
 addUnique(const SBuf &amp;scheme, std::vector&lt;SBuf&gt; &amp;vec)
 {
     static const SBuf all(&quot;ALL&quot;);
     if (scheme == all) {
         for (const auto config: Auth::TheConfig)
             addUnique(SBuf(config-&gt;type()), vec);
     } else if (std::find(vec.begin(), vec.end(), scheme) == vec.end())
         vec.push_back(scheme);
 }
 
 void
 Auth::SchemesConfig::expand()
 {
     static const CharacterSet delimiters(&quot;delimiters&quot;, &quot;,&quot;);
     static const CharacterSet quotedDelimiters(&quot;quotedDelimiters&quot;, &quot;, &quot;);
     const CharacterSet *resultDelimiters = quoted ? &amp;quotedDelimiters : &delimiters;
     std::vector&lt;SBuf&gt; expanded;
     Parser::Tokenizer t(schemes);
     SBuf scheme;

=== modified file 'src/auth/SchemesConfig.h'
--- src/auth/SchemesConfig.h	2016-12-10 04:48:25 +0000
+++ src/auth/SchemesConfig.h	2016-12-11 10:19:01 +0000
@@ -26,27 +26,27 @@
 public:
     SchemesConfig(const char *s, const bool q) : schemes(s), quoted(q), rawSchemes(schemes.c_str()) {}
     /// Expands special &quot;ALL&quot; scheme name (if provided), removes
     /// duplicates and fills authConfigs vector.
     void expand();
 
 public:
     /// corresponding vector of Auth::Config objects
     ConfigVector authConfigs;
 
 private:
     /// raw auth schemes list (may have duplicates)
     SBuf schemes;
     const bool quoted;
 
 public:
     /// optimization for storing schemes.c_str()
     const char *rawSchemes;
 };
 
-typedef std::vector&lt;SchemesConfig&gt; SchemesConfigs;
+extern std::vector&lt;Auth::SchemesConfig&gt; SchemeListConfig;
 
 } // namespace Auth
 
 #endif /* USE_AUTH */
 #endif /* SQUID_SCHEMES_CONFIG_H */
 

=== modified file 'src/auth/UserRequest.cc'
--- src/auth/UserRequest.cc	2016-12-10 04:48:25 +0000
+++ src/auth/UserRequest.cc	2016-12-11 10:27:20 +0000
@@ -450,47 +450,47 @@
             request-&gt;auth_user_request = t;
         }
         return t-&gt;lastReply;
     }
 
     // ok, call the actual authenticator routine.
     AuthAclState result = authenticate(aUR, headertype, request, conn, src_addr, al);
 
     // auth process may have changed the UserRequest we are dealing with
     t = authTryGetUser(*aUR, conn, request);
 
     if (t != NULL &amp;&amp; result != AUTH_ACL_CANNOT_AUTHENTICATE &amp;&amp; result != AUTH_ACL_HELPER)
         t-&gt;lastReply = result;
 
     return result;
 }
 
 static Auth::ConfigVector &amp;
 schemesConfig(HttpRequest *request, HttpReply *rep)
 {
-    if (::Config.accessList.authSchemes) {
+    if (!Auth::SchemeListConfig.empty()) {
         ACLFilledChecklist ch(NULL, request, NULL);
         ch.reply = rep;
         HTTPMSGLOCK(ch.reply);
         const allow_t answer = ch.fastCheck(::Config.accessList.authSchemes);
         if (answer == ACCESS_ALLOWED)
-            return ::Config.authSchemesConfigs.at(answer.kind).authConfigs;
+            return Auth::SchemeListConfig.at(answer.kind).authConfigs;
     }
     return Auth::TheConfig;
 }
 
 void
 Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal)
 /* send the auth types we are configured to support (and have compiled in!) */
 {
     Http::HdrType type;
 
     switch (rep-&gt;sline.status()) {
 
     case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
         type = Http::HdrType::PROXY_AUTHENTICATE;
         break;
 
     case Http::scUnauthorized:
         /* WWW Authorisation needed */
         type = Http::HdrType::WWW_AUTHENTICATE;

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2016-12-10 16:27:09 +0000
+++ src/cache_cf.cc	2016-12-11 14:34:53 +0000
@@ -1,40 +1,41 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 03    Configuration File Parsing */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/AclDenyInfoList.h&quot;
 #include &quot;acl/AclSizeLimit.h&quot;
 #include &quot;acl/Address.h&quot;
 #include &quot;acl/Gadgets.h&quot;
 #include &quot;acl/MethodData.h&quot;
 #include &quot;acl/Tree.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;anyp/UriScheme.h&quot;
+#include &quot;auth/SchemesConfig.h&quot;
 #include &quot;AuthReg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;CachePeer.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;CpuAffinityMap.h&quot;
 #include &quot;DiskIO/DiskIOModule.h&quot;
 #include &quot;eui/Config.h&quot;
 #include &quot;ExternalACL.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;ftp/Elements.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;icmp/IcmpConfig.h&quot;
 #include &quot;ident/Config.h&quot;
 #include &quot;ip/Intercept.h&quot;
 #include &quot;ip/QosConfig.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;ipc/Kids.h&quot;
 #include &quot;log/Config.h&quot;
@@ -929,41 +930,41 @@
         Config.pipeline_max_prefetch = 0;
     }
 
 #if USE_AUTH
     /*
      * disable client side request pipelining. There is a race with
      * Negotiate and NTLM when the client sends a second request on an
      * connection before the authenticate challenge is sent. With
      * pipelining OFF, the client may fail to authenticate, but squid's
      * state will be preserved.
      */
     if (Config.pipeline_max_prefetch &gt; 0) {
         Auth::Config *nego = Auth::Config::Find(&quot;Negotiate&quot;);
         Auth::Config *ntlm = Auth::Config::Find(&quot;NTLM&quot;);
         if ((nego &amp;&amp; nego-&gt;active()) || (ntlm &amp;&amp; ntlm-&gt;active())) {
             debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: pipeline_prefetch breaks NTLM and Negotiate authentication. Forced pipeline_prefetch 0.&quot;);
             Config.pipeline_max_prefetch = 0;
         }
     }
 
-    for (auto &amp;authSchemes: Config.authSchemesConfigs) {
+    for (auto &amp;authSchemes : Auth::SchemeListConfig) {
         authSchemes.expand();
         if (authSchemes.authConfigs.empty()) {
             debugs(3, DBG_CRITICAL, &quot;auth_schemes: at least one scheme name is required; got: &quot; &lt;&lt; authSchemes.rawSchemes);
             self_destruct();
         }
     }
 #endif
 }
 
 /** Parse a line containing an obsolete directive.
  * To upgrade it where possible instead of just &quot;Bungled config&quot; for
  * directives which cannot be marked as simply aliases of the some name.
  * For example if the parameter order and content has changed.
  * Or if the directive has been completely removed.
  */
 void
 parse_obsolete(const char *name)
 {
     // Directives which have been radically changed rather than removed
     if (!strcmp(name, &quot;url_rewrite_concurrency&quot;)) {
@@ -1827,58 +1828,58 @@
         Auth::Init();
     }
 }
 
 static void
 dump_authparam(StoreEntry * entry, const char *name, Auth::ConfigVector cfg)
 {
     for (Auth::ConfigVector::iterator  i = cfg.begin(); i != cfg.end(); ++i)
         (*i)-&gt;dump(entry, name, (*i));
 }
 
 static void
 parse_AuthSchemes(acl_access **authSchemes)
 {
     const char *tok = ConfigParser::NextQuotedToken();
     if (!tok) {
         debugs(29, DBG_CRITICAL, &quot;FATAL: auth_schemes missing the parameter&quot;);
         self_destruct();
         return;
     }
-    Config.authSchemesConfigs.push_back(Auth::SchemesConfig(tok, ConfigParser::LastTokenWasQuoted()));
-    const allow_t action = allow_t(ACCESS_ALLOWED, Config.authSchemesConfigs.size() - 1);
+    Auth::SchemeListConfig.emplace_back(tok, ConfigParser::LastTokenWasQuoted());
+    const allow_t action = allow_t(ACCESS_ALLOWED, Auth::SchemeListConfig.size() - 1);
     ParseAclWithAction(authSchemes, action, &quot;auth_schemes&quot;);
 }
 
 static void
 free_AuthSchemes(acl_access **authSchemes)
 {
-    Config.authSchemesConfigs.clear();
+    Auth::SchemeListConfig.clear();
     free_acl_access(authSchemes);
 }
 
 static void
 dump_AuthSchemes(StoreEntry *entry, const char *name, acl_access *authSchemes)
 {
     if (authSchemes)
         dump_SBufList(entry, authSchemes-&gt;treeDump(name, [](const allow_t &amp;action) {
-        return Config.authSchemesConfigs.at(action.kind).rawSchemes;
+        return Auth::SchemeListConfig.at(action.kind).rawSchemes;
     }));
 }
 
 #endif /* USE_AUTH */
 
 static void
 ParseAclWithAction(acl_access **access, const allow_t &amp;action, const char *desc, ACL *acl)
 {
     assert(access);
     SBuf name;
     if (!*access) {
         *access = new Acl::Tree;
         name.Printf(&quot;(%s rules)&quot;, desc);
         (*access)-&gt;context(name.c_str(), config_input_line);
     }
     Acl::AndNode *rule = new Acl::AndNode;
     name.Printf(&quot;(%s rule)&quot;, desc);
     rule-&gt;context(name.c_str(), config_input_line);
     acl ? rule-&gt;add(acl) : rule-&gt;lineParse();
     (*access)-&gt;add(rule, action);

=== modified file 'src/tests/stub_libauth.cc'
--- src/tests/stub_libauth.cc	2016-12-10 04:48:25 +0000
+++ src/tests/stub_libauth.cc	2016-12-11 17:54:05 +0000
@@ -58,24 +58,28 @@
 void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &amp;) STUB
 void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer) STUB
 int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer) STUB_RETVAL(0)
 int authenticateUserAuthenticated(Auth::UserRequest::Pointer) STUB_RETVAL(0)
 Auth::Direction Auth::UserRequest::direction() STUB_RETVAL(Auth::CRED_ERROR)
 void Auth::UserRequest::addAuthenticationInfoHeader(HttpReply *, int) STUB
 void Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply *, int) STUB
 void Auth::UserRequest::releaseAuthServer() STUB
 const char * Auth::UserRequest::connLastHeader() STUB_RETVAL(&quot;stub&quot;)
 AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &amp;, AccessLogEntry::Pointer &amp;) STUB_RETVAL(AUTH_AUTHENTICATED)
 AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &amp;, AccessLogEntry::Pointer &amp;) STUB_RETVAL(AUTH_AUTHENTICATED)
 void Auth::UserRequest::addReplyAuthHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int) STUB
 Auth::Scheme::Pointer Auth::UserRequest::scheme() const STUB_RETVAL(NULL)
 
 #include &quot;AuthReg.h&quot;
 void Auth::Init() STUB_NOP
 
 #include &quot;auth/SchemesConfig.h&quot;
-void Auth::SchemesConfig::expand() STUB
+namespace Auth
+{
+std::vector&lt;Auth::SchemesConfig&gt; SchemeListConfig;
+void SchemesConfig::expand() STUB
+}
 
 #endif /* USE_AUTH */
 

</PRE>


































































































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007490.html">[squid-dev] [PATCH] Compilation fix for v5 r14973
</A></li>
	<LI>Next message: <A HREF="007492.html">[squid-dev] [PATCH] Compilation fix for v5 r14973
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7491">[ date ]</a>
              <a href="thread.html#7491">[ thread ]</a>
              <a href="subject.html#7491">[ subject ]</a>
              <a href="author.html#7491">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
