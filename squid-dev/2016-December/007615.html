<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] refactor Auth::Config
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20refactor%20Auth%3A%3AConfig&In-Reply-To=%3Cccbaf6d7-0973-1ccd-4e89-4a0795cd03c5%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007593.html">
   <LINK REL="Next"  HREF="007616.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] refactor Auth::Config</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20refactor%20Auth%3A%3AConfig&In-Reply-To=%3Cccbaf6d7-0973-1ccd-4e89-4a0795cd03c5%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] refactor Auth::Config">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Dec 20 18:05:56 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007593.html">[squid-dev] Fix for the bug 4648
</A></li>
        <LI>Next message: <A HREF="007616.html">[squid-dev] [PATCH] refactor Auth::Config
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7615">[ date ]</a>
              <a href="thread.html#7615">[ thread ]</a>
              <a href="subject.html#7615">[ subject ]</a>
              <a href="author.html#7615">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is the patch refactoring the Auth::Config objects to get v5
building again.

The object storing auth_param settings is renamed to SchemeConfig.

A new Auth::Config object is added. The objects holding auth_param,
auth_schemes and other authenticate_* directives settings are stored
there instead of just auth_params.

Lots of outdated doxygen docs that have more up to date copies elsewhere
are removed. The &quot;\ingroup AuthAPI&quot; are left for now since some auth
things are not yet in the Auth:: namespace, but other auth related
groups are dropped completely.

Code parsing and dumping auth_param lines has been de-duplicated. Along
with the keep_alive and utf8 settings, which are shared by multiple
schemes. This allows dropping several virtual methods from NTLM and
Negotiate scheme objects.

An auth/forward.h file is added for predefines. Some initial Auth::
symbols are listed there. It is not complete, but others can be added as
needed later.

Some unnecessary includes have been removed. There are probably more. I
just did the obvious ones related to the new auth/forward.h and
auth/Config.h files at this time.

Amos
-------------- next part --------------
=== removed file 'doc/Programming-Guide/BasicAuthentication.dox'
--- doc/Programming-Guide/BasicAuthentication.dox	2016-01-01 00:12:18 +0000
+++ doc/Programming-Guide/BasicAuthentication.dox	1970-01-01 00:00:00 +0000
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/**
-\defgroup AuthAPIBasic Basic Authentication
-\ingroup AuthAPI
-
-\par
-Basic authentication provides a username and password.  These
-are written to the authentication module processes on a single
-line, separated by a space:
-\code
-&lt;USERNAME&gt; &lt;PASSWORD&gt;
-\endcode
-
-\par
-	The authentication module process reads username, password pairs
-	on stdin and returns either &quot;OK&quot; or &quot;ERR&quot; on stdout for
-	each input line.
-
-\par
-	The following simple perl script demonstrates how the
-	authentication module works.  This script allows any
-	user named &quot;Dirk&quot; (without checking the password)
-	and allows any user that uses the password &quot;Sekrit&quot;:
-
-\code
-#!/usr/bin/perl -w
-$|=1;		# no buffering, important!
-while (&lt;&gt;) {
-        chop;
-        ($u,$p) = split;
-        $ans = &amp;check($u,$p);
-        print &quot;$ans\n&quot;;
-}
-
-sub check {
-        local($u,$p) = @_;
-        return 'ERR' unless (defined $p &amp;&amp; defined $u);
-        return 'OK' if ('Dirk' eq $u);
-        return 'OK' if ('Sekrit' eq $p);
-        return 'ERR';
-}
-\endcode
-
- */

=== modified file 'src/SquidConfig.h'
--- src/SquidConfig.h	2016-12-10 04:48:25 +0000
+++ src/SquidConfig.h	2016-12-19 14:14:57 +0000
@@ -1,35 +1,32 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SQUIDCONFIG_H_
 #define SQUID_SQUIDCONFIG_H_
 
 #include &quot;acl/forward.h&quot;
-#if USE_AUTH
-#include &quot;auth/SchemesConfig.h&quot;
-#endif
 #include &quot;base/RefCount.h&quot;
 #include &quot;base/YesNoNone.h&quot;
 #include &quot;ClientDelayConfig.h&quot;
 #include &quot;DelayConfig.h&quot;
 #include &quot;helper/ChildConfig.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;Notes.h&quot;
 #include &quot;security/forward.h&quot;
 #include &quot;SquidTime.h&quot;
 #if USE_OPENSSL
 #include &quot;ssl/support.h&quot;
 #endif
 #include &quot;store/forward.h&quot;
 
 #if USE_OPENSSL
 class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
 
@@ -184,43 +181,40 @@
     char *effectiveGroup;
 
     struct {
         wordlist *redirect;
         wordlist *store_id;
 #if USE_UNLINKD
 
         char *unlinkd;
 #endif
 
         char *diskd;
 #if USE_OPENSSL
 
         char *ssl_password;
 #endif
 
     } Program;
 
     Helper::ChildConfig redirectChildren;
     Helper::ChildConfig storeIdChildren;
-    time_t authenticateGCInterval;
-    time_t authenticateTTL;
-    time_t authenticateIpTTL;
 
     struct {
         char *surrogate_id;
     } Accel;
     char *appendDomain;
     size_t appendDomainLen;
     char *pidFilename;
     char *netdbFilename;
     char *mimeTablePathname;
     char *etcHostsPath;
     char *visibleHostname;
     char *uniqueHostname;
     wordlist *hostnameAliases;
     char *errHtmlText;
 
     struct {
         char *host;
         char *file;
         time_t period;
         unsigned short port;
@@ -383,43 +377,40 @@
 
 #if USE_OPENSSL
         acl_access *ssl_bump;
 #endif
 #if FOLLOW_X_FORWARDED_FOR
         acl_access *followXFF;
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
         /// acceptible PROXY protocol clients
         acl_access *proxyProtocol;
 
         /// spoof_client_ip squid.conf acl.
         /// nil unless configured
         acl_access* spoof_client_ip;
         acl_access *on_unsupported_protocol;
 
         acl_access *ftp_epsv;
 
         acl_access *forceRequestBodyContinuation;
         acl_access *serverPconnForNonretriable;
-#if USE_AUTH
-        acl_access *authSchemes;
-#endif
     } accessList;
     AclDenyInfoList *denyInfoList;
 
     struct {
         size_t list_width;
         int list_wrap;
         char *anon_user;
         int passive;
         int epsv_all;
         int epsv;
         int eprt;
         int sanitycheck;
         int telnet;
     } Ftp;
     RefreshPattern *Refresh;
 
     Store::DiskConfig cacheSwap;
 
     struct {
         char *directory;
@@ -526,44 +517,40 @@
 
 #if USE_LOADABLE_MODULES
     wordlist *loadable_module_names;
 #endif
 
     int client_ip_max_connections;
 
     char *redirector_extras;
 
     struct UrlHelperTimeout {
         int action;
         char *response;
     } onUrlRewriteTimeout;
 
     char *storeId_extras;
 
     struct {
         int v4_first;       ///&lt; Place IPv4 first in the order of DNS results.
         ssize_t packet_max; ///&lt; maximum size EDNS advertised for DNS replies.
     } dns;
-
-#if USE_AUTH
-    Auth::SchemesConfigs authSchemesConfigs;
-#endif
 };
 
 extern SquidConfig Config;
 
 class SquidConfig2
 {
 public:
     void clear() {
         *this = SquidConfig2();
     }
 
     struct {
         int enable_purge = 0;
     } onoff;
     uid_t effectiveUserID = 0;
     gid_t effectiveGroupID = 0;
 };
 
 extern SquidConfig2 Config2;
 

=== added file 'src/auth/Config.cc'
--- src/auth/Config.cc	1970-01-01 00:00:00 +0000
+++ src/auth/Config.cc	2016-12-19 13:25:50 +0000
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/* DEBUG: section 29    Authenticator */
+
+#include &quot;squid.h&quot;
+#include &quot;acl/Tree.h&quot;
+#include &quot;auth/Config.h&quot;
+
+Auth::Config Auth::TheConfig;
+

=== added file 'src/auth/Config.h'
--- src/auth/Config.h	1970-01-01 00:00:00 +0000
+++ src/auth/Config.h	2016-12-19 14:21:57 +0000
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_AUTH_CONFIG_H
+#define SQUID_SRC_AUTH_CONFIG_H
+
+#if USE_AUTH
+
+#include &quot;acl/forward.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
+#include &quot;auth/SchemesConfig.h&quot;
+
+namespace Auth
+{
+
+class Config
+{
+public:
+    /// set of auth_params directives
+    Auth::ConfigVector schemes;
+
+    /// set of auth_schemes directives
+    std::vector&lt;Auth::SchemesConfig&gt; schemeLists;
+
+    /// the ACL list for auth_schemes directives
+    acl_access *schemeAccess = nullptr;
+
+    /// the authenticate_cache_garbage_interval
+    time_t authenticateGCInterval;
+
+    /// the authenticate_ttl
+    time_t authenticateTTL;
+
+    /// the authenticate_ip_ttl
+    time_t authenticateIpTTL;
+};
+
+extern Auth::Config TheConfig;
+
+} // namespace Auth
+
+#endif /* USE_AUTH */
+#endif /* SQUID_SRC_AUTH_CONFIG_H */
+

=== modified file 'src/auth/CredentialsCache.cc'
--- src/auth/CredentialsCache.cc	2016-11-15 09:34:16 +0000
+++ src/auth/CredentialsCache.cc	2016-12-19 15:30:31 +0000
@@ -1,38 +1,37 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Gadgets.h&quot;
+#include &quot;auth/Config.h&quot;
 #include &quot;auth/CredentialsCache.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;event.h&quot;
-#include &quot;SquidConfig.h&quot;
-#include &quot;SquidTime.h&quot;
 
 namespace Auth {
 
 class CredentialCacheRr : public RegisteredRunner
 {
 public:
     explicit CredentialCacheRr(const char *n, CredentialsCache * const c) :
         name(n),
         whichCache(c)
     {}
 
     virtual ~CredentialCacheRr() {
         debugs(29, 5, &quot;Terminating Auth credentials cache: &quot; &lt;&lt; name);
         // invalidate the CBDATA reference.
         // causes Auth::*::User::Cache() to produce nil / invalid pointer
         delete whichCache.get();
     }
 
     virtual void endingShutdown() override {
         debugs(29, 5, &quot;Clearing Auth credentials cache: &quot; &lt;&lt; name);
@@ -68,41 +67,41 @@
     debugs(29, 6, &quot;lookup for &quot; &lt;&lt; userKey);
     auto p = store_.find(userKey);
     if (p == store_.end())
         return User::Pointer(nullptr);
     return p-&gt;second;
 }
 
 void
 CredentialsCache::Cleanup(void *data)
 {
     debugs(29, 5, &quot;checkpoint&quot;);
     // data is this in disguise
     CredentialsCache *self = static_cast&lt;CredentialsCache *&gt;(data);
     self-&gt;cleanup();
 }
 
 void
 CredentialsCache::cleanup()
 {
     // cache entries with expiretime &lt;= expirationTime are to be evicted
-    const time_t expirationTime =  current_time.tv_sec - ::Config.authenticateTTL;
+    const time_t expirationTime =  current_time.tv_sec - Auth::TheConfig.authenticateTTL;
 
     const auto end = store_.end();
     for (auto i = store_.begin(); i != end;) {
         debugs(29, 6, &quot;considering &quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;(expires in &quot; &lt;&lt;
                (expirationTime - i-&gt;second-&gt;expiretime) &lt;&lt; &quot; sec)&quot;);
         if (i-&gt;second-&gt;expiretime &lt;= expirationTime) {
             debugs(29, 6, &quot;evicting &quot; &lt;&lt; i-&gt;first);
             i = store_.erase(i); //erase advances i
         } else {
             ++i;
         }
     }
     gcScheduled_ = false;
     scheduleCleanup();
 }
 
 void
 CredentialsCache::insert(const SBuf &amp;userKey, Auth::User::Pointer anAuth_user)
 {
     debugs(29, 6, &quot;adding &quot; &lt;&lt; userKey &lt;&lt; &quot; (&quot; &lt;&lt; anAuth_user-&gt;username() &lt;&lt; &quot;)&quot;);
@@ -116,37 +115,37 @@
 CredentialsCache::sortedUsersList() const
 {
     std::vector&lt;Auth::User::Pointer&gt; rv(size(), nullptr);
     std::transform(store_.begin(), store_.end(), rv.begin(),
     [](StoreType::value_type v) { return v.second; }
                   );
     std::sort(rv.begin(), rv.end(),
     [](const Auth::User::Pointer &amp;lhs, const Auth::User::Pointer &amp;rhs) {
         return strcmp(lhs-&gt;username(), rhs-&gt;username()) &lt; 0;
     }
              );
     return rv;
 }
 
 void
 CredentialsCache::scheduleCleanup()
 {
     if (!gcScheduled_ &amp;&amp; store_.size()) {
         gcScheduled_ = true;
         eventAdd(cacheCleanupEventName, &amp;CredentialsCache::Cleanup,
-                 this, ::Config.authenticateGCInterval, 1);
+                 this, Auth::TheConfig.authenticateGCInterval, 1);
     }
 }
 
 void
 CredentialsCache::doConfigChangeCleanup()
 {
     // purge expired entries entirely
     cleanup();
     // purge the ACL match data stored in the credentials
     for (auto i : store_) {
         aclCacheMatchFlush(&amp;i.second-&gt;proxy_match_cache);
     }
 }
 
 } /* namespace Auth */
 

=== modified file 'src/auth/Gadgets.cc'
--- src/auth/Gadgets.cc	2016-01-24 17:41:43 +0000
+++ src/auth/Gadgets.cc	2016-12-20 10:20:36 +0000
@@ -22,128 +22,126 @@
 #include &quot;auth/digest/User.h&quot;
 #include &quot;auth/Gadgets.h&quot;
 #include &quot;auth/negotiate/User.h&quot;
 #include &quot;auth/ntlm/User.h&quot;
 #include &quot;auth/Scheme.h&quot;
 #include &quot;auth/User.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;http/Stream.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 
 /**** PUBLIC FUNCTIONS (ALL GENERIC!)  ****/
 
 int
 authenticateActiveSchemeCount(void)
 {
     int rv = 0;
 
-    for (Auth::ConfigVector::iterator i = Auth::TheConfig.begin(); i != Auth::TheConfig.end(); ++i)
-        if ((*i)-&gt;configured())
+    for (auto *scheme : Auth::TheConfig.schemes) {
+        if (scheme-&gt;configured())
             ++rv;
+    }
 
     debugs(29, 9, HERE &lt;&lt; rv &lt;&lt; &quot; active.&quot;);
 
     return rv;
 }
 
 int
 authenticateSchemeCount(void)
 {
     int rv = Auth::Scheme::GetSchemes().size();
 
     debugs(29, 9, HERE &lt;&lt; rv &lt;&lt; &quot; active.&quot;);
 
     return rv;
 }
 
 static void
 authenticateRegisterWithCacheManager(Auth::ConfigVector * config)
 {
-    for (Auth::ConfigVector::iterator i = config-&gt;begin(); i != config-&gt;end(); ++i) {
-        Auth::Config *scheme = *i;
+    for (auto *scheme : *config)
         scheme-&gt;registerWithCacheManager();
-    }
 }
 
 void
 authenticateInit(Auth::ConfigVector * config)
 {
     /* If we do not have any auth config state to create stop now. */
     if (!config)
         return;
 
-    for (Auth::ConfigVector::iterator i = config-&gt;begin(); i != config-&gt;end(); ++i) {
-        Auth::Config *schemeCfg = *i;
-
-        if (schemeCfg-&gt;configured())
-            schemeCfg-&gt;init(schemeCfg);
+    for (auto *scheme : *config) {
+        if (scheme-&gt;configured())
+            scheme-&gt;init(scheme);
     }
 
     authenticateRegisterWithCacheManager(config);
 }
 
 void
 authenticateRotate(void)
 {
-    for (Auth::ConfigVector::iterator i = Auth::TheConfig.begin(); i != Auth::TheConfig.end(); ++i)
-        if ((*i)-&gt;configured())
-            (*i)-&gt;rotateHelpers();
+    for (auto *scheme : Auth::TheConfig.schemes) {
+        if (scheme-&gt;configured())
+            scheme-&gt;rotateHelpers();
+    }
 }
 
 void
 authenticateReset(void)
 {
     debugs(29, 2, &quot;Reset authentication State.&quot;);
 
     // username cache is cleared via Runner registry
 
     /* schedule shutdown of the helpers */
     authenticateRotate();
 
     /* free current global config details too. */
-    Auth::TheConfig.clear();
+    Auth::TheConfig.schemes.clear();
 }
 
 std::vector&lt;Auth::User::Pointer&gt;
 authenticateCachedUsersList()
 {
     auto aucp_compare = [=](const Auth::User::Pointer lhs, const Auth::User::Pointer rhs) {
         return lhs-&gt;userKey() &lt; rhs-&gt;userKey();
     };
     std::vector&lt;Auth::User::Pointer&gt; v1, v2, rv, u1, u2;
 #if HAVE_AUTH_MODULE_BASIC
-    if (Auth::Config::Find(&quot;basic&quot;) != nullptr)
+    if (Auth::SchemeConfig::Find(&quot;basic&quot;))
         u1 = Auth::Basic::User::Cache()-&gt;sortedUsersList();
 #endif
 #if HAVE_AUTH_MODULE_DIGEST
-    if (Auth::Config::Find(&quot;digest&quot;) != nullptr)
+    if (Auth::SchemeConfig::Find(&quot;digest&quot;))
         u2 = Auth::Digest::User::Cache()-&gt;sortedUsersList();
 #endif
     if (u1.size() &gt; 0 || u2.size() &gt; 0) {
         v1.reserve(u1.size()+u2.size());
         std::merge(u1.begin(), u1.end(),u2.begin(), u2.end(),
                    std::back_inserter(v1), aucp_compare);
         u1.clear();
         u2.clear();
     }
 #if HAVE_AUTH_MODULE_NEGOTIATE
-    if (Auth::Config::Find(&quot;negotiate&quot;) != nullptr)
+    if (Auth::SchemeConfig::Find(&quot;negotiate&quot;))
         u1 = Auth::Negotiate::User::Cache()-&gt;sortedUsersList();
 #endif
 #if HAVE_AUTH_MODULE_NTLM
-    if (Auth::Config::Find(&quot;ntlm&quot;) != nullptr)
+    if (Auth::SchemeConfig::Find(&quot;ntlm&quot;))
         u2 = Auth::Ntlm::User::Cache()-&gt;sortedUsersList();
 #endif
     if (u1.size() &gt; 0 || u2.size() &gt; 0) {
         v2.reserve(u1.size()+u2.size());
         std::merge(u1.begin(), u1.end(),u2.begin(), u2.end(),
                    std::back_inserter(v2), aucp_compare);
     }
     rv.reserve(v1.size()+v2.size());
     std::merge(v1.begin(), v1.end(),v2.begin(), v2.end(),
                std::back_inserter(rv), aucp_compare);
     return rv;
 }
 

=== modified file 'src/auth/Gadgets.h'
--- src/auth/Gadgets.h	2016-01-01 00:12:18 +0000
+++ src/auth/Gadgets.h	2016-12-19 13:25:57 +0000
@@ -1,48 +1,40 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_GADGETS_H
 #define SQUID_AUTH_GADGETS_H
 
 #if USE_AUTH
 
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/User.h&quot;
 #include &quot;hash.h&quot;
 
-namespace Auth
-{
-class Scheme;
-}
 class ConnStateData;
 class StoreEntry;
 
-/**
- \ingroup AuthAPI
- \todo this should be a generic cachemgr API type ?
- */
+// TODO this should be a generic cachemgr API type ?
 typedef void AUTHSSTATS(StoreEntry *);
 
 /// \ingroup AuthAPI
 void authenticateInit(Auth::ConfigVector *);
 
 /** \ingroup AuthAPI
  * Remove all idle authentication state. Intended for use by reconfigure.
  *
  * Removes the username cache contents and global configuration state.
  * Stops just short of detaching the auth components completely.
  *
  * Currently active requests should finish. Howevee new requests will not use
  * authentication unless something causes the global config to be rebuilt.
  * Such as a configure load action adding config and re-running authenticateInit().
  */
 void authenticateReset(void);
 
 void authenticateRotate(void);
 
 /// \ingroup AuthAPI

=== modified file 'src/auth/Makefile.am'
--- src/auth/Makefile.am	2016-12-10 04:48:25 +0000
+++ src/auth/Makefile.am	2016-12-19 13:25:57 +0000
@@ -8,45 +8,48 @@
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
 SUBDIRS = $(AUTH_MODULES)
 DIST_SUBDIRS = basic digest negotiate ntlm
 
 noinst_LTLIBRARIES = libauth.la libacls.la
 ## not needed? $(AUTH_LIBS_TO_BUILD)
 ## EXTRA_LTLIBRARIES = libdigest.la libntlm.la libnegotiate.la
 
 ## authentication framework; this library is always built
 libauth_la_SOURCES = \
 	Type.h \
 	Type.cc \
 	Config.cc \
 	Config.h \
 	CredentialsCache.h \
 	CredentialsCache.cc \
 	CredentialState.cc \
 	CredentialState.h \
+	forward.h \
 	Gadgets.cc \
 	Gadgets.h \
 	QueueNode.h \
 	Scheme.cc \
 	Scheme.h \
+	SchemeConfig.cc \
+	SchemeConfig.h \
 	SchemesConfig.h \
 	SchemesConfig.cc \
 	State.h \
 	State.cc \
 	User.h \
 	User.cc \
 	UserRequest.h \
 	UserRequest.cc
 
 libauth_la_LIBADD = $(AUTH_LIBS_TO_BUILD)
 libauth_la_DEPENDENCIES = $(AUTH_LIBS_TO_BUILD)
 
 ## authentication-dependent ACLs and authentication code they share
 libacls_la_SOURCES = \
 	Acl.cc \
 	Acl.h \
 	\
 	AclMaxUserIp.cc \
 	AclMaxUserIp.h \
 	AclProxyAuth.cc \

=== modified file 'src/auth/QueueNode.h'
--- src/auth/QueueNode.h	2016-01-01 00:12:18 +0000
+++ src/auth/QueueNode.h	2016-12-19 13:25:58 +0000
@@ -1,31 +1,32 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_AUTH_QUEUENODE_H
 #define SQUID_SRC_AUTH_QUEUENODE_H
 
+#include &quot;auth/forward.h&quot;
 #include &quot;cbdata.h&quot;
 
 namespace Auth
 {
 
 /**
  * A queue of auth requests waiting for verification to occur.
  *
  * Certain authentication schemes such a Basic and Bearer auth
  * permit credentials tokens to be repeated from multiple sources
  * simultaneously. This queue node allows multiple validation
  * queries to be collapsed into one backend helper lookup.
  * CBDATA and handlers stored in these queue nodes can be notified
  * all at once with a result when the lookup completes.
  */
 class QueueNode
 {
     MEMPROXY_CLASS(Auth::QueueNode);
 
 private:

=== modified file 'src/auth/Scheme.cc'
--- src/auth/Scheme.cc	2016-01-01 00:12:18 +0000
+++ src/auth/Scheme.cc	2016-12-19 13:25:59 +0000
@@ -1,34 +1,34 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 #include &quot;squid.h&quot;
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/Gadgets.h&quot;
 #include &quot;auth/Scheme.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;globals.h&quot;
 
 std::vector&lt;Auth::Scheme::Pointer&gt; *Auth::Scheme::_Schemes = NULL;
 
 void
 Auth::Scheme::AddScheme(Auth::Scheme::Pointer instance)
 {
     iterator i = GetSchemes().begin();
 
     while (i != GetSchemes().end()) {
         assert(strcmp((*i)-&gt;type(), instance-&gt;type()) != 0);
         ++i;
     }
 
     GetSchemes().push_back(instance);
 }
 
 Auth::Scheme::Pointer
 Auth::Scheme::Find(const char *typestr)
 {

=== modified file 'src/auth/Scheme.h'
--- src/auth/Scheme.h	2016-01-01 00:12:18 +0000
+++ src/auth/Scheme.h	2016-12-19 13:26:00 +0000
@@ -1,88 +1,77 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_SCHEME_H
 #define SQUID_AUTH_SCHEME_H
 
 #if USE_AUTH
 
+#include &quot;auth/forward.h&quot;
 #include &quot;base/RefCount.h&quot;
 
-#include &lt;vector&gt;
-
-/**
- \defgroup AuthSchemeAPI    Authentication Scheme API
- \ingroup AuthAPI
- */
-
 namespace Auth
 {
 
-class Config;
-
 /**
- * \ingroup AuthAPI
- * \ingroup AuthSchemeAPI
- * \par
  * I represent an authentication scheme. For now my children
  * store the scheme metadata.
- * \par
+ *
  * Should we need multiple configs of a single scheme,
  * a new class should be made, and the config specific calls on Auth::Scheme moved to it.
  */
 class Scheme : public RefCountable
 {
 public:
     typedef RefCount&lt;Scheme&gt; Pointer;
     typedef std::vector&lt;Scheme::Pointer&gt;::iterator iterator;
     typedef std::vector&lt;Scheme::Pointer&gt;::const_iterator const_iterator;
 
 public:
     Scheme() : initialised (false) {};
     virtual ~Scheme() {};
 
     static void AddScheme(Scheme::Pointer);
 
     /**
      * Final termination of all authentication components.
      * To be used only on shutdown. All global pointers are released.
      * After this all schemes will appear completely unsupported
      * until a call to InitAuthModules().
      * Release the Auth::TheConfig handles instead to disable authentication
      * without terminiating all support.
      */
     static void FreeAll();
 
     /**
      * Locate an authentication scheme component by Name.
      */
     static Scheme::Pointer Find(const char *);
 
     /* per scheme methods */
     virtual char const *type() const = 0;
     virtual void shutdownCleanup() = 0;
-    virtual Auth::Config *createConfig() = 0;
+    virtual Auth::SchemeConfig *createConfig() = 0;
 
     // Not implemented
     Scheme(Scheme const &amp;);
     Scheme &amp;operator=(Scheme const&amp;);
 
     static std::vector&lt;Scheme::Pointer&gt; &amp;GetSchemes();
 
 protected:
     bool initialised;
 
 private:
     static std::vector&lt;Scheme::Pointer&gt; *_Schemes;
 };
 
 } // namespace Auth
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_SCHEME_H */
 

=== renamed file 'src/auth/Config.cc' =&gt; 'src/auth/SchemeConfig.cc'
--- src/auth/Config.cc	2016-12-10 04:48:25 +0000
+++ src/auth/SchemeConfig.cc	2016-12-20 13:49:00 +0000
@@ -1,103 +1,103 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 #include &quot;squid.h&quot;
 #include &quot;auth/Config.h&quot;
+#include &quot;auth/forward.h&quot;
 #include &quot;auth/Gadgets.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;wordlist.h&quot;
 
-Auth::ConfigVector Auth::TheConfig;
-
 /**
  * Get an User credentials object filled out for the given Proxy- or WWW-Authenticate header.
  * Any decoding which needs to be done will be done.
  *
  * It may be a cached AuthUser or a new Unauthenticated object.
  * It may also be NULL reflecting that no user could be created.
  */
 Auth::UserRequest::Pointer
-Auth::Config::CreateAuthUser(const char *proxy_auth, AccessLogEntry::Pointer &amp;al)
+Auth::SchemeConfig::CreateAuthUser(const char *proxy_auth, AccessLogEntry::Pointer &amp;al)
 {
     assert(proxy_auth != NULL);
     debugs(29, 9, HERE &lt;&lt; &quot;header = '&quot; &lt;&lt; proxy_auth &lt;&lt; &quot;'&quot;);
 
-    Auth::Config *config = Find(proxy_auth);
+    Auth::SchemeConfig *config = Find(proxy_auth);
 
     if (config == NULL || !config-&gt;active()) {
         debugs(29, (shutting_down?3:DBG_IMPORTANT), (shutting_down?&quot;&quot;:&quot;WARNING: &quot;) &lt;&lt;
                &quot;Unsupported or unconfigured/inactive proxy-auth scheme, '&quot; &lt;&lt; proxy_auth &lt;&lt; &quot;'&quot;);
         return NULL;
     }
     static MemBuf rmb;
     rmb.reset();
     if (config-&gt;keyExtras) {
         // %credentials and %username, which normally included in
         // request_format, are - at this time, but that is OK
         // because user name is added to key explicitly, and we do
         // not want to store authenticated credentials at all.
         config-&gt;keyExtras-&gt;assemble(rmb, al, 0);
     }
 
     return config-&gt;decode(proxy_auth, rmb.hasContent() ? rmb.content() : NULL);
 }
 
-Auth::Config *
-Auth::Config::Find(const char *proxy_auth)
+Auth::SchemeConfig *
+Auth::SchemeConfig::Find(const char *proxy_auth)
 {
-    for (Auth::ConfigVector::iterator  i = Auth::TheConfig.begin(); i != Auth::TheConfig.end(); ++i)
-        if (strncasecmp(proxy_auth, (*i)-&gt;type(), strlen((*i)-&gt;type())) == 0)
-            return *i;
+    for (auto *scheme : Auth::TheConfig.schemes) {
+        if (strncasecmp(proxy_auth, scheme-&gt;type(), strlen(scheme-&gt;type())) == 0)
+            return scheme;
+    }
 
     return NULL;
 }
 
-Auth::Config *
-Auth::Config::GetParsed(const char *proxy_auth)
+Auth::SchemeConfig *
+Auth::SchemeConfig::GetParsed(const char *proxy_auth)
 {
     if (auto *cfg = Find(proxy_auth))
         return cfg;
     fatalf(&quot;auth_schemes: required authentication method '%s' is not configured&quot;, proxy_auth);
     return nullptr;
 }
 
 /** Default behaviour is to expose nothing */
 void
-Auth::Config::registerWithCacheManager(void)
+Auth::SchemeConfig::registerWithCacheManager(void)
 {}
 
 void
-Auth::Config::parse(Auth::Config * scheme, int, char *param_str)
+Auth::SchemeConfig::parse(Auth::SchemeConfig * scheme, int, char *param_str)
 {
     if (strcmp(param_str, &quot;program&quot;) == 0) {
         if (authenticateProgram)
             wordlistDestroy(&amp;authenticateProgram);
 
         parse_wordlist(&amp;authenticateProgram);
 
         requirePathnameExists(&quot;Authentication helper program&quot;, authenticateProgram-&gt;key);
 
     } else if (strcmp(param_str, &quot;realm&quot;) == 0) {
         realm.clear();
 
         char *token = ConfigParser::NextQuotedOrToEol();
 
         while (token &amp;&amp; *token &amp;&amp; xisspace(*token))
             ++token;
 
         if (!token || !*token) {
             debugs(29, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;ERROR: Missing auth_param &quot; &lt;&lt; scheme-&gt;type() &lt;&lt; &quot; realm&quot;);
             self_destruct();
@@ -109,60 +109,72 @@
     } else if (strcmp(param_str, &quot;children&quot;) == 0) {
         authenticateChildren.parseConfig();
 
     } else if (strcmp(param_str, &quot;key_extras&quot;) == 0) {
         keyExtrasLine = ConfigParser::NextQuotedToken();
         Format::Format *nlf =  new ::Format::Format(scheme-&gt;type());
         if (!nlf-&gt;parse(keyExtrasLine.termedBuf())) {
             debugs(29, DBG_CRITICAL, &quot;FATAL: Failed parsing key_extras formatting value&quot;);
             self_destruct();
             return;
         }
         if (keyExtras)
             delete keyExtras;
 
         keyExtras = nlf;
 
         if (char *t = strtok(NULL, w_space)) {
             debugs(29, DBG_CRITICAL, &quot;FATAL: Unexpected argument '&quot; &lt;&lt; t &lt;&lt; &quot;' after request_format specification&quot;);
             self_destruct();
         }
+    } else if (strcmp(param_str, &quot;keep_alive&quot;) == 0) {
+        parse_onoff(&amp;keep_alive);
+    } else if (strcmp(param_str, &quot;utf8&quot;) == 0) {
+        parse_onoff(&amp;utf8);
     } else {
         debugs(29, DBG_CRITICAL, &quot;Unrecognised &quot; &lt;&lt; scheme-&gt;type() &lt;&lt; &quot; auth scheme parameter '&quot; &lt;&lt; param_str &lt;&lt; &quot;'&quot;);
     }
 }
 
 bool
-Auth::Config::dump(StoreEntry *entry, const char *name, Auth::Config *scheme) const
+Auth::SchemeConfig::dump(StoreEntry *entry, const char *name, Auth::SchemeConfig *scheme) const
 {
     if (!authenticateProgram)
         return false; // not configured
 
+    const char *schemeType = scheme-&gt;type();
+
     wordlist *list = authenticateProgram;
-    storeAppendPrintf(entry, &quot;%s %s&quot;, name, scheme-&gt;type());
+    storeAppendPrintf(entry, &quot;%s %s&quot;, name, schemeType);
     while (list != NULL) {
         storeAppendPrintf(entry, &quot; %s&quot;, list-&gt;key);
         list = list-&gt;next;
     }
     storeAppendPrintf(entry, &quot;\n&quot;);
 
-    storeAppendPrintf(entry, &quot;%s %s realm &quot; SQUIDSBUFPH &quot;\n&quot;, name, scheme-&gt;type(), SQUIDSBUFPRINT(realm));
+    storeAppendPrintf(entry, &quot;%s %s realm &quot; SQUIDSBUFPH &quot;\n&quot;, name, schemeType, SQUIDSBUFPRINT(realm));
 
     storeAppendPrintf(entry, &quot;%s %s children %d startup=%d idle=%d concurrency=%d\n&quot;,
-                      name, scheme-&gt;type(),
+                      name, schemeType,
                       authenticateChildren.n_max, authenticateChildren.n_startup,
                       authenticateChildren.n_idle, authenticateChildren.concurrency);
 
-    if (keyExtrasLine.size() &gt; 0)
-        storeAppendPrintf(entry, &quot;%s %s key_extras \&quot;%s\&quot;\n&quot;, name, scheme-&gt;type(), keyExtrasLine.termedBuf());
+    if (keyExtrasLine.size() &gt; 0) // default is none
+        storeAppendPrintf(entry, &quot;%s %s key_extras \&quot;%s\&quot;\n&quot;, name, schemeType, keyExtrasLine.termedBuf());
+
+    if (!keep_alive) // default is on
+        storeAppendPrintf(entry, &quot;%s %s keep_alive off\n&quot;, name, schemeType);
+
+    if (utf8) // default is off
+        storeAppendPrintf(entry, &quot;%s %s utf8 on\n&quot;, name, schemeType);
 
     return true;
 }
 
 void
-Auth::Config::done()
+Auth::SchemeConfig::done()
 {
     delete keyExtras;
     keyExtras = NULL;
     keyExtrasLine.clean();
 }
 

=== renamed file 'src/auth/Config.h' =&gt; 'src/auth/SchemeConfig.h'
--- src/auth/Config.h	2016-12-10 04:48:25 +0000
+++ src/auth/SchemeConfig.h	2016-12-20 12:15:10 +0000
@@ -1,77 +1,78 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_AUTH_CONFIG_H
-#define SQUID_AUTH_CONFIG_H
+#ifndef SQUID_SRC_AUTH_SCHEMECONFIG_H
+#define SQUID_SRC_AUTH_SCHEMECONFIG_H
 
 #if USE_AUTH
 
 #include &quot;AccessLogEntry.h&quot;
+#include &quot;auth/forward.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;helper/ChildConfig.h&quot;
 
 class StoreEntry;
 class HttpReply;
 class HttpRequest;
 class wordlist;
 
 /* for Http::HdrType parameters-by-value */
 #include &quot;HttpHeader.h&quot;
 
 namespace Format
 {
 class Format;
 }
 
 namespace Auth
 {
 
 /**
  * \ingroup AuthAPI
  * \par
  * I am the configuration for an auth scheme.
  * Currently each scheme has only one instance of me,
  * but this may change.
  * \par
  * This class is treated like a ref counted class.
  * If the children ever stop being singletons, implement the
  * ref counting...
  */
-class Config
+class SchemeConfig
 {
 
 public:
     static UserRequest::Pointer CreateAuthUser(const char *proxy_auth, AccessLogEntry::Pointer &amp;al);
 
-    static Config *Find(const char *proxy_auth);
+    static SchemeConfig *Find(const char *proxy_auth);
     /// Call this method if you need a guarantee that all auth schemes has been
     /// already configured.
-    static Config *GetParsed(const char *proxy_auth);
-    Config() : authenticateChildren(20), authenticateProgram(NULL), keyExtras(NULL) {}
+    static SchemeConfig *GetParsed(const char *proxy_auth);
+    SchemeConfig() : authenticateChildren(20) {}
 
-    virtual ~Config() {}
+    virtual ~SchemeConfig() {}
 
     /**
      * Used by squid to determine whether the auth module has successfully initialised itself with the current configuration.
      *
      \retval true   Authentication Module loaded and running.
      \retval false  No Authentication Module loaded.
      */
     virtual bool active() const = 0;
 
     /**
      * new decode API: virtual factory pattern
      \par
      * Responsible for decoding the passed authentication header, creating or
      * linking to a AuthUser object and for storing any needed details to complete
      * authentication in Auth::UserRequest::authenticate().
      *
      \param proxy_auth  Login Pattern to parse.
      \retval *      Details needed to authenticate.
      */
     virtual UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm) = 0;
@@ -89,57 +90,55 @@
      * The configured function is used to see if the auth module has been given valid
      * parameters and is able to handle authentication requests.
      *
      \retval true   Authentication Module configured ready for use.
      \retval false  Not configured or Configuration Error.
      *          No other module functions except Shutdown/Dump/Parse/FreeConfig will be called by Squid.
      */
     virtual bool configured() const = 0;
 
     /**
      * Shutdown just the auth helpers.
      * For use by log rotate etc. where auth needs to stay running, with the helpers restarted.
      */
     virtual void rotateHelpers(void) = 0;
 
     /**
      * Responsible for writing to the StoreEntry the configuration parameters that a user
      * would put in a config file to recreate the running configuration.
      * Returns whether the scheme is configured.
      */
-    virtual bool dump(StoreEntry *, const char *, Config *) const;
+    virtual bool dump(StoreEntry *, const char *, SchemeConfig *) const;
 
     /** add headers as needed when challenging for auth */
     virtual void fixHeader(UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *) = 0;
 
     /** prepare to handle requests */
-    virtual void init(Config *) = 0;
+    virtual void init(SchemeConfig *) = 0;
 
     /** expose any/all statistics to a CacheManager */
     virtual void registerWithCacheManager(void);
 
     /** parse config options */
-    virtual void parse(Config *, int, char *);
+    virtual void parse(SchemeConfig *, int, char *);
 
     /** the http string id */
     virtual const char * type() const = 0;
 
 public:
     Helper::ChildConfig authenticateChildren;
-    wordlist *authenticateProgram; ///&lt; Helper program to run, includes all parameters
+    wordlist *authenticateProgram = nullptr; ///&lt; Helper program to run, includes all parameters
     String keyExtrasLine;  ///&lt; The format of the request to the auth helper
-    Format::Format *keyExtras; ///&lt; The compiled request format
+    Format::Format *keyExtras = nullptr; ///&lt; The compiled request format
+    int keep_alive = 1; ///&lt; whether to close the connection on auth challenges. default: on
+    int utf8 = 0; ///&lt; wheter to accept UTF-8 characterset instead of ASCII. default: off
 
 protected:
     /// RFC 7235 section 2.2 - Protection Space (Realm)
     SBuf realm;
 };
 
-typedef std::vector&lt;Config *&gt; ConfigVector;
-
-extern ConfigVector TheConfig;
-
 } // namespace Auth
 
 #endif /* USE_AUTH */
-#endif /* SQUID_AUTHCONFIG_H */
+#endif /* SQUID_SRC_AUTH_SCHEMECONFIG_H */
 

=== modified file 'src/auth/SchemesConfig.cc'
--- src/auth/SchemesConfig.cc	2016-12-10 04:48:25 +0000
+++ src/auth/SchemesConfig.cc	2016-12-19 13:26:03 +0000
@@ -1,47 +1,46 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;auth/Config.h&quot;
-#include &quot;auth/SchemesConfig.h&quot;
 #include &quot;fatal.h&quot;
 #include &quot;parser/Tokenizer.h&quot;
 
 static void
 addUnique(const SBuf &amp;scheme, std::vector&lt;SBuf&gt; &amp;vec)
 {
     static const SBuf all(&quot;ALL&quot;);
     if (scheme == all) {
-        for (const auto config: Auth::TheConfig)
+        for (const auto config: Auth::TheConfig.schemes)
             addUnique(SBuf(config-&gt;type()), vec);
     } else if (std::find(vec.begin(), vec.end(), scheme) == vec.end())
         vec.push_back(scheme);
 }
 
 void
 Auth::SchemesConfig::expand()
 {
     static const CharacterSet delimiters(&quot;delimiters&quot;, &quot;,&quot;);
     static const CharacterSet quotedDelimiters(&quot;quotedDelimiters&quot;, &quot;, &quot;);
     const CharacterSet *resultDelimiters = quoted ? &amp;quotedDelimiters : &delimiters;
     std::vector&lt;SBuf&gt; expanded;
     Parser::Tokenizer t(schemes);
     SBuf scheme;
     while (t.token(scheme, *resultDelimiters))
         addUnique(scheme, expanded);
     t.skipAllTrailing(CharacterSet::SP + CharacterSet::HTAB);
     if (!t.remaining().isEmpty())
         addUnique(t.remaining(), expanded);
 
     authConfigs.clear();
     transform(expanded.begin(), expanded.end(),
     back_inserter(authConfigs), [](SBuf &amp;s) {
-        return Auth::Config::GetParsed(s.c_str());
+        return Auth::SchemeConfig::GetParsed(s.c_str());
     });
 }
 

=== modified file 'src/auth/SchemesConfig.h'
--- src/auth/SchemesConfig.h	2016-12-10 04:48:25 +0000
+++ src/auth/SchemesConfig.h	2016-12-19 13:26:04 +0000
@@ -1,52 +1,49 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SCHEMES_CONFIG_H
 #define SQUID_SCHEMES_CONFIG_H
 
 #if USE_AUTH
 
-#include &quot;auth/Config.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 
 namespace Auth
 {
 
 /**
- * \ingroup AuthAPI
  * Stores authentication schemes list, configured by auth_schemes
  * directive.
  */
 class SchemesConfig
 {
 public:
     SchemesConfig(const char *s, const bool q) : schemes(s), quoted(q), rawSchemes(schemes.c_str()) {}
     /// Expands special &quot;ALL&quot; scheme name (if provided), removes
     /// duplicates and fills authConfigs vector.
     void expand();
 
 public:
     /// corresponding vector of Auth::Config objects
-    ConfigVector authConfigs;
+    Auth::ConfigVector authConfigs;
 
 private:
     /// raw auth schemes list (may have duplicates)
     SBuf schemes;
     const bool quoted;
 
 public:
     /// optimization for storing schemes.c_str()
     const char *rawSchemes;
 };
 
-typedef std::vector&lt;SchemesConfig&gt; SchemesConfigs;
-
 } // namespace Auth
 
 #endif /* USE_AUTH */
 #endif /* SQUID_SCHEMES_CONFIG_H */
 

=== modified file 'src/auth/User.cc'
--- src/auth/User.cc	2016-07-05 05:45:44 +0000
+++ src/auth/User.cc	2016-12-19 15:32:50 +0000
@@ -1,45 +1,44 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Gadgets.h&quot;
 #include &quot;auth/Config.h&quot;
 #include &quot;auth/CredentialsCache.h&quot;
 #include &quot;auth/Gadgets.h&quot;
 #include &quot;auth/User.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;event.h&quot;
 #include &quot;globals.h&quot;
-#include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 
-Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
+Auth::User::User(Auth::SchemeConfig *aConfig, const char *aRequestRealm) :
     auth_type(Auth::AUTH_UNKNOWN),
     config(aConfig),
     ipcount(0),
     expiretime(0),
     credentials_state(Auth::Unchecked),
     username_(nullptr),
     requestRealm_(aRequestRealm)
 {
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
     ip_list.head = ip_list.tail = NULL;
     debugs(29, 5, HERE &lt;&lt; &quot;Initialised auth_user '&quot; &lt;&lt; this &lt;&lt; &quot;'.&quot;);
 }
 
 Auth::CredentialState
 Auth::User::credentials() const
 {
     return credentials_state;
 }
 
 void
@@ -184,98 +183,98 @@
 
 void
 Auth::User::addIp(Ip::Address ipaddr)
 {
     AuthUserIP *ipdata = (AuthUserIP *) ip_list.head;
     int found = 0;
 
     /*
      * we walk the entire list to prevent the first item in the list
      * preventing old entries being flushed and locking a user out after
      * a timeout+reconfigure
      */
     while (ipdata) {
         AuthUserIP *tempnode = (AuthUserIP *) ipdata-&gt;node.next;
         /* walk the ip list */
 
         if (ipdata-&gt;ipaddr == ipaddr) {
             /* This ip has already been seen. */
             found = 1;
             /* update IP ttl */
-            ipdata-&gt;ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
+            ipdata-&gt;ip_expiretime = squid_curtime + Auth::TheConfig.authenticateIpTTL;
         } else if (ipdata-&gt;ip_expiretime &lt;= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&amp;ipdata-&gt;node, &amp;ip_list);
             delete ipdata;
             /* catch incipient underflow */
             assert(ipcount);
             -- ipcount;
         }
 
         ipdata = tempnode;
     }
 
     if (found)
         return;
 
     /* This ip is not in the seen list */
-    ipdata = new AuthUserIP(ipaddr, squid_curtime + ::Config.authenticateIpTTL);
+    ipdata = new AuthUserIP(ipaddr, squid_curtime + Auth::TheConfig.authenticateIpTTL);
 
     dlinkAddTail(ipdata, &amp;ipdata-&gt;node, &amp;ip_list);
 
     ++ipcount;
 
     debugs(29, 2, HERE &lt;&lt; &quot;user '&quot; &lt;&lt; username() &lt;&lt; &quot;' has been seen at a new IP address (&quot; &lt;&lt; ipaddr &lt;&lt; &quot;)&quot;);
 }
 
 SBuf
 Auth::User::BuildUserKey(const char *username, const char *realm)
 {
     SBuf key;
     if (realm)
         key.Printf(&quot;%s:%s&quot;, username, realm);
     else
         key.append(username, strlen(username));
     return key;
 }
 
 /**
  * Dump the username cache statictics for viewing...
  */
 void
 Auth::User::CredentialsCacheStats(StoreEntry *output)
 {
     auto userlist = authenticateCachedUsersList();
     storeAppendPrintf(output, &quot;Cached Usernames: %d&quot;, static_cast&lt;int32_t&gt;(userlist.size()));
     storeAppendPrintf(output, &quot;\n%-15s %-9s %-9s %-9s %s\t%s\n&quot;,
                       &quot;Type&quot;,
                       &quot;State&quot;,
                       &quot;Check TTL&quot;,
                       &quot;Cache TTL&quot;,
                       &quot;Username&quot;, &quot;Key&quot;);
     storeAppendPrintf(output, &quot;--------------- --------- --------- --------- ------------------------------\n&quot;);
     for ( auto auth_user : userlist ) {
         storeAppendPrintf(output, &quot;%-15s %-9s %-9d %-9d %s\t&quot; SQUIDSBUFPH &quot;\n&quot;,
                           Auth::Type_str[auth_user-&gt;auth_type],
                           CredentialState_str[auth_user-&gt;credentials()],
                           auth_user-&gt;ttl(),
-                          static_cast&lt;int32_t&gt;(auth_user-&gt;expiretime - squid_curtime + ::Config.authenticateTTL),
+                          static_cast&lt;int32_t&gt;(auth_user-&gt;expiretime - squid_curtime + Auth::TheConfig.authenticateTTL),
                           auth_user-&gt;username(),
                           SQUIDSBUFPRINT(auth_user-&gt;userKey())
                          );
     }
 }
 
 void
 Auth::User::username(char const *aString)
 {
     if (aString) {
         assert(!username_);
         username_ = xstrdup(aString);
         // NP: param #2 is working around a c_str() data-copy performance regression
         userKey_ = BuildUserKey(username_, (!requestRealm_.isEmpty() ? requestRealm_.c_str() : NULL));
     } else {
         safe_free(username_);
         userKey_.clear();
     }
 }
 

=== modified file 'src/auth/User.h'
--- src/auth/User.h	2016-02-23 08:51:22 +0000
+++ src/auth/User.h	2016-12-19 13:26:10 +0000
@@ -1,72 +1,70 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_USER_H
 #define SQUID_AUTH_USER_H
 
 #if USE_AUTH
 
 #include &quot;auth/CredentialState.h&quot;
+#include &quot;auth/forward.h&quot;
 #include &quot;auth/Type.h&quot;
 #include &quot;base/CbcPointer.h&quot;
 #include &quot;base/RefCount.h&quot;
 #include &quot;dlink.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;Notes.h&quot;
 #include &quot;sbuf/SBuf.h&quot;
 
 class StoreEntry;
 
 namespace Auth
 {
 
-class Config;
-class CredentialsCache;
-
 /**
  * This is the main user related structure. It stores user-related data,
  * and is persistent across requests. It can even persist across
  * multiple external authentications. One major benefit of preserving this
  * structure is the cached ACL match results. This structure, is private to
  * the authentication framework.
  */
 class User : public RefCountable
 {
 public:
     typedef RefCount&lt;User&gt; Pointer;
 
 protected:
-    User(Auth::Config *, const char *requestRealm);
+    User(Auth::SchemeConfig *, const char *requestRealm);
 public:
     virtual ~User();
 
     /* extra fields for proxy_auth */
     /** \deprecated this determines what scheme owns the user data. */
     Auth::Type auth_type;
     /** the config for this user */
-    Auth::Config *config;
+    Auth::SchemeConfig *config;
     dlink_list proxy_match_cache;
     size_t ipcount;
     long expiretime;
 
     /// list of key=value pairs the helper produced
     NotePairs notes;
 
 public:
     static SBuf BuildUserKey(const char *username, const char *realm);
 
     void absorb(Auth::User::Pointer from);
     char const *username() const { return username_; }
     void username(char const *); ///&lt; set stored username and userKey
 
     // NP: key is set at the same time as username_. Until then both are empty/NULL.
     const SBuf userKey() const {return userKey_;}
 
     /**
      * How long these credentials are still valid for.
      * Negative numbers means already expired.

=== modified file 'src/auth/UserRequest.cc'
--- src/auth/UserRequest.cc	2016-12-10 04:48:25 +0000
+++ src/auth/UserRequest.cc	2016-12-19 14:28:42 +0000
@@ -1,50 +1,45 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 /* The functions in this file handle authentication.
  * They DO NOT perform access control or auditing.
  * See acl.c for access control and client_side.c for auditing */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;auth/Config.h&quot;
-#include &quot;auth/Scheme.h&quot;
-#include &quot;auth/SchemesConfig.h&quot;
-#include &quot;auth/User.h&quot;
-#include &quot;auth/UserRequest.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;fatal.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;http/Stream.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;MemBuf.h&quot;
-#include &quot;SquidConfig.h&quot;
 
 /* Generic Functions */
 
 char const *
 Auth::UserRequest::username() const
 {
     if (user() != NULL)
         return user()-&gt;username();
     else
         return NULL;
 }
 
 /**** PUBLIC FUNCTIONS (ALL GENERIC!)  ****/
 
 /* send the initial data to an authenticator module */
 void
 Auth::UserRequest::start(HttpRequest *request, AccessLogEntry::Pointer &amp;al, AUTHCB * handler, void *data)
 {
     assert(handler);
     assert(data);
@@ -321,57 +316,57 @@
 
         /* remove this request struct - the link is already authed and it can't be to reauth. */
 
         /* This should _only_ ever occur on the first pass through
          * authenticateAuthenticate
          */
         assert(*auth_user_request == NULL);
         conn-&gt;setAuth(NULL, &quot;changed credentials token&quot;);
     }
 
     /* we have a proxy auth header and as far as we know this connection has
      * not had bungled connection oriented authentication happen on it. */
     debugs(29, 9, HERE &lt;&lt; &quot;header &quot; &lt;&lt; (proxy_auth ? proxy_auth : &quot;-&quot;) &lt;&lt; &quot;.&quot;);
 
     if (*auth_user_request == NULL) {
         if (conn != NULL) {
             debugs(29, 9, HERE &lt;&lt; &quot;This is a new checklist test on:&quot; &lt;&lt; conn-&gt;clientConnection);
         }
 
         if (proxy_auth &amp;&amp; request-&gt;auth_user_request == NULL &amp;&amp; conn != NULL &amp;&amp; conn-&gt;getAuth() != NULL) {
-            Auth::Config * scheme = Auth::Config::Find(proxy_auth);
+            Auth::SchemeConfig * scheme = Auth::SchemeConfig::Find(proxy_auth);
 
             if (conn-&gt;getAuth()-&gt;user() == NULL || conn-&gt;getAuth()-&gt;user()-&gt;config != scheme) {
                 debugs(29, DBG_IMPORTANT, &quot;WARNING: Unexpected change of authentication scheme from '&quot; &lt;&lt;
                        (conn-&gt;getAuth()-&gt;user()!=NULL?conn-&gt;getAuth()-&gt;user()-&gt;config-&gt;type():&quot;[no user]&quot;) &lt;&lt;
                        &quot;' to '&quot; &lt;&lt; proxy_auth &lt;&lt; &quot;' (client &quot; &lt;&lt;
                        src_addr &lt;&lt; &quot;)&quot;);
 
                 conn-&gt;setAuth(NULL, &quot;changed auth scheme&quot;);
             }
         }
 
         if (request-&gt;auth_user_request == NULL &amp;&amp; (conn == NULL || conn-&gt;getAuth() == NULL)) {
             /* beginning of a new request check */
             debugs(29, 4, HERE &lt;&lt; &quot;No connection authentication type&quot;);
 
-            *auth_user_request = Auth::Config::CreateAuthUser(proxy_auth, al);
+            *auth_user_request = Auth::SchemeConfig::CreateAuthUser(proxy_auth, al);
             if (*auth_user_request == NULL)
                 return AUTH_ACL_CHALLENGE;
             else if (!(*auth_user_request)-&gt;valid()) {
                 /* the decode might have left a username for logging, or a message to
                  * the user */
 
                 if ((*auth_user_request)-&gt;username()) {
                     request-&gt;auth_user_request = *auth_user_request;
                 }
 
                 *auth_user_request = NULL;
                 return AUTH_ACL_CHALLENGE;
             }
 
         } else if (request-&gt;auth_user_request != NULL) {
             *auth_user_request = request-&gt;auth_user_request;
         } else {
             assert (conn != NULL);
             if (conn-&gt;getAuth() != NULL) {
                 *auth_user_request = conn-&gt;getAuth();
@@ -450,92 +445,90 @@
             request-&gt;auth_user_request = t;
         }
         return t-&gt;lastReply;
     }
 
     // ok, call the actual authenticator routine.
     AuthAclState result = authenticate(aUR, headertype, request, conn, src_addr, al);
 
     // auth process may have changed the UserRequest we are dealing with
     t = authTryGetUser(*aUR, conn, request);
 
     if (t != NULL &amp;&amp; result != AUTH_ACL_CANNOT_AUTHENTICATE &amp;&amp; result != AUTH_ACL_HELPER)
         t-&gt;lastReply = result;
 
     return result;
 }
 
 static Auth::ConfigVector &amp;
 schemesConfig(HttpRequest *request, HttpReply *rep)
 {
-    if (::Config.accessList.authSchemes) {
+    if (!Auth::TheConfig.schemeLists.empty() &amp;&amp; Auth::TheConfig.schemeAccess) {
         ACLFilledChecklist ch(NULL, request, NULL);
         ch.reply = rep;
         HTTPMSGLOCK(ch.reply);
-        const allow_t answer = ch.fastCheck(::Config.accessList.authSchemes);
+        const allow_t answer = ch.fastCheck(Auth::TheConfig.schemeAccess);
         if (answer == ACCESS_ALLOWED)
-            return ::Config.authSchemesConfigs.at(answer.kind).authConfigs;
+            return Auth::TheConfig.schemeLists.at(answer.kind).authConfigs;
     }
-    return Auth::TheConfig;
+    return Auth::TheConfig.schemes;
 }
 
 void
 Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal)
 /* send the auth types we are configured to support (and have compiled in!) */
 {
     Http::HdrType type;
 
     switch (rep-&gt;sline.status()) {
 
     case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
         type = Http::HdrType::PROXY_AUTHENTICATE;
         break;
 
     case Http::scUnauthorized:
         /* WWW Authorisation needed */
         type = Http::HdrType::WWW_AUTHENTICATE;
         break;
 
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
         type = Http::HdrType::BAD_HDR;
         break;
     }
 
     debugs(29, 9, &quot;headertype:&quot; &lt;&lt; type &lt;&lt; &quot; authuser:&quot; &lt;&lt; auth_user_request);
 
     if (((rep-&gt;sline.status() == Http::scProxyAuthenticationRequired)
             || (rep-&gt;sline.status() == Http::scUnauthorized)) &amp;&amp; internal)
         /* this is a authenticate-needed response */
     {
 
         if (auth_user_request != NULL &amp;&amp; auth_user_request-&gt;direction() == Auth::CRED_CHALLENGE)
             /* add the scheme specific challenge header to the response */
             auth_user_request-&gt;user()-&gt;config-&gt;fixHeader(auth_user_request, rep, type, request);
         else {
-            /* call each configured &amp; running authscheme */
+            /* call each configured &amp; running auth scheme */
             Auth::ConfigVector &amp;configs = schemesConfig(request, rep);
-            for (Auth::ConfigVector::iterator i = configs.begin(); i != configs.end(); ++i) {
-                Auth::Config *scheme = *i;
-
+            for (auto *scheme : configs) {
                 if (scheme-&gt;active()) {
                     if (auth_user_request != NULL &amp;&amp; auth_user_request-&gt;scheme()-&gt;type() == scheme-&gt;type())
                         scheme-&gt;fixHeader(auth_user_request, rep, type, request);
                     else
                         scheme-&gt;fixHeader(NULL, rep, type, request);
                 } else
                     debugs(29, 4, HERE &lt;&lt; &quot;Configured scheme &quot; &lt;&lt; scheme-&gt;type() &lt;&lt; &quot; not Active&quot;);
             }
         }
 
     }
 
     /*
      * allow protocol specific headers to be _added_ to the existing
      * response - currently Digest or Negotiate auth
      */
     if (auth_user_request != NULL) {
         auth_user_request-&gt;addAuthenticationInfoHeader(rep, accelerated);
         if (auth_user_request-&gt;lastReply != AUTH_AUTHENTICATED)
             auth_user_request-&gt;lastReply = AUTH_ACL_CANNOT_AUTHENTICATE;

=== modified file 'src/auth/basic/Config.cc'
--- src/auth/basic/Config.cc	2016-01-01 00:12:18 +0000
+++ src/auth/basic/Config.cc	2016-12-20 12:18:51 +0000
@@ -79,87 +79,83 @@
         debugs(29, 9, &quot;Sending type:&quot; &lt;&lt; hdrType &lt;&lt; &quot; header: 'Basic realm=\&quot;&quot; &lt;&lt; realm &lt;&lt; &quot;\&quot;'&quot;);
         httpHeaderPutStrf(&amp;rep-&gt;header, hdrType, &quot;Basic realm=\&quot;&quot; SQUIDSBUFPH &quot;\&quot;&quot;, SQUIDSBUFPRINT(realm));
     }
 }
 
 void
 Auth::Basic::Config::rotateHelpers()
 {
     /* schedule closure of existing helpers */
     if (basicauthenticators) {
         helperShutdown(basicauthenticators);
     }
 
     /* NP: dynamic helper restart will ensure they start up again as needed. */
 }
 
 /** shutdown the auth helpers and free any allocated configuration details */
 void
 Auth::Basic::Config::done()
 {
-    Auth::Config::done();
+    Auth::SchemeConfig::done();
 
     authbasic_initialised = 0;
 
     if (basicauthenticators) {
         helperShutdown(basicauthenticators);
     }
 
     delete basicauthenticators;
     basicauthenticators = NULL;
 
     if (authenticateProgram)
         wordlistDestroy(&amp;authenticateProgram);
 }
 
 bool
-Auth::Basic::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme) const
+Auth::Basic::Config::dump(StoreEntry * entry, const char *name, Auth::SchemeConfig * scheme) const
 {
-    if (!Auth::Config::dump(entry, name, scheme))
+    if (!Auth::SchemeConfig::dump(entry, name, scheme))
         return false; // not configured
 
     storeAppendPrintf(entry, &quot;%s basic credentialsttl %d seconds\n&quot;, name, (int) credentialsTTL);
     storeAppendPrintf(entry, &quot;%s basic casesensitive %s\n&quot;, name, casesensitive ? &quot;on&quot; : &quot;off&quot;);
-    storeAppendPrintf(entry, &quot;%s basic utf8 %s\n&quot;, name, utf8 ? &quot;on&quot; : &quot;off&quot;);
     return true;
 }
 
 Auth::Basic::Config::Config() :
     credentialsTTL( 2*60*60 ),
-    casesensitive(0),
-    utf8(0)
+    casesensitive(0)
 {
     static const SBuf defaultRealm(&quot;Squid proxy-caching web server&quot;);
     realm = defaultRealm;
 }
 
 void
-Auth::Basic::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
+Auth::Basic::Config::parse(Auth::SchemeConfig * scheme, int n_configured, char *param_str)
 {
     if (strcmp(param_str, &quot;credentialsttl&quot;) == 0) {
         parse_time_t(&amp;credentialsTTL);
     } else if (strcmp(param_str, &quot;casesensitive&quot;) == 0) {
         parse_onoff(&amp;casesensitive);
-    } else if (strcmp(param_str, &quot;utf8&quot;) == 0) {
-        parse_onoff(&amp;utf8);
     } else
-        Auth::Config::parse(scheme, n_configured, param_str);
+        Auth::SchemeConfig::parse(scheme, n_configured, param_str);
 }
 
 static void
 authenticateBasicStats(StoreEntry * sentry)
 {
     if (basicauthenticators)
         basicauthenticators-&gt;packStatsInto(sentry, &quot;Basic Authenticator Statistics&quot;);
 }
 
 char *
 Auth::Basic::Config::decodeCleartext(const char *httpAuthHeader)
 {
     const char *proxy_auth = httpAuthHeader;
 
     /* trim BASIC from string */
     while (xisgraph(*proxy_auth))
         ++proxy_auth;
 
     /* Trim leading whitespace before decoding */
     while (xisspace(*proxy_auth))
@@ -262,41 +258,41 @@
         lb-&gt;addToNameCache();
 
         auth_user = lb;
         assert(auth_user != NULL);
     } else {
         /* replace the current cached password with the new one */
         Auth::Basic::User *basic_auth = dynamic_cast&lt;Auth::Basic::User *&gt;(auth_user.getRaw());
         assert(basic_auth);
         basic_auth-&gt;updateCached(local_basic);
         auth_user = basic_auth;
     }
 
     /* link the request to the in-cache user */
     auth_user_request-&gt;user(auth_user);
     return auth_user_request;
 }
 
 /** Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
 void
-Auth::Basic::Config::init(Auth::Config *)
+Auth::Basic::Config::init(Auth::SchemeConfig *)
 {
     if (authenticateProgram) {
         authbasic_initialised = 1;
 
         if (basicauthenticators == NULL)
             basicauthenticators = new helper(&quot;basicauthenticator&quot;);
 
         basicauthenticators-&gt;cmdline = authenticateProgram;
 
         basicauthenticators-&gt;childs.updateLimits(authenticateChildren);
 
         basicauthenticators-&gt;ipc_type = IPC_STREAM;
 
         helperOpenServers(basicauthenticators);
     }
 }
 
 void
 Auth::Basic::Config::registerWithCacheManager(void)
 {

=== modified file 'src/auth/basic/Config.h'
--- src/auth/basic/Config.h	2016-01-01 00:12:18 +0000
+++ src/auth/basic/Config.h	2016-12-20 12:14:04 +0000
@@ -1,58 +1,57 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef __AUTH_BASIC_H__
 #define __AUTH_BASIC_H__
 
 #if HAVE_AUTH_MODULE_BASIC
 
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/Gadgets.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;helper/forward.h&quot;
 
 namespace Auth
 {
 namespace Basic
 {
 
 /** Basic authentication configuration data */
-class Config : public Auth::Config
+class Config : public Auth::SchemeConfig
 {
 public:
     Config();
     virtual bool active() const;
     virtual bool configured() const;
     virtual Auth::UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm);
     virtual void done();
     virtual void rotateHelpers();
-    virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
+    virtual bool dump(StoreEntry *, const char *, Auth::SchemeConfig *) const;
     virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
-    virtual void init(Auth::Config *);
-    virtual void parse(Auth::Config *, int, char *);
+    virtual void init(Auth::SchemeConfig *);
+    virtual void parse(Auth::SchemeConfig *, int, char *);
     void decode(char const *httpAuthHeader, Auth::UserRequest::Pointer);
     virtual void registerWithCacheManager(void);
     virtual const char * type() const;
 
 public:
     time_t credentialsTTL;
     int casesensitive;
-    int utf8;
 
 private:
     char * decodeCleartext(const char *httpAuthHeader);
 };
 
 } // namespace Basic
 } // namespace Auth
 
 extern helper *basicauthenticators;
 
 #endif /* HAVE_AUTH_MODULE_BASIC */
 #endif /* __AUTH_BASIC_H__ */
 

=== modified file 'src/auth/basic/Scheme.cc'
--- src/auth/basic/Scheme.cc	2016-01-01 00:12:18 +0000
+++ src/auth/basic/Scheme.cc	2016-12-19 13:27:07 +0000
@@ -23,27 +23,27 @@
     }
     return _instance;
 }
 
 char const *
 Auth::Basic::Scheme::type() const
 {
     return &quot;basic&quot;;
 }
 
 void
 Auth::Basic::Scheme::shutdownCleanup()
 {
     if (_instance == NULL)
         return;
 
     _instance = NULL;
     debugs(29, DBG_CRITICAL, &quot;Shutdown: Basic authentication.&quot;);
 }
 
-Auth::Config *
+Auth::SchemeConfig *
 Auth::Basic::Scheme::createConfig()
 {
     Auth::Basic::Config *newCfg = new Auth::Basic::Config;
-    return dynamic_cast&lt;Auth::Config*&gt;(newCfg);
+    return dynamic_cast&lt;Auth::SchemeConfig*&gt;(newCfg);
 }
 

=== modified file 'src/auth/basic/Scheme.h'
--- src/auth/basic/Scheme.h	2016-01-01 00:12:18 +0000
+++ src/auth/basic/Scheme.h	2016-12-19 13:27:08 +0000
@@ -2,47 +2,46 @@
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_BASIC_SCHEME_H
 #define SQUID_AUTH_BASIC_SCHEME_H
 
 #if HAVE_AUTH_MODULE_BASIC
 
 #include &quot;auth/Scheme.h&quot;
 
 namespace Auth
 {
 namespace Basic
 {
 
 /// \ingroup AuthAPI
-/// \ingroup AuthSchemeAPI
 class Scheme : public Auth::Scheme
 {
 
 public:
     static Auth::Scheme::Pointer GetInstance();
     Scheme() {};
     virtual ~Scheme() {}
 
     /* per scheme */
     virtual char const *type() const;
     virtual void shutdownCleanup();
-    virtual Auth::Config *createConfig();
+    virtual Auth::SchemeConfig *createConfig();
     /* Not implemented */
     Scheme(Scheme const &amp;);
     Scheme &amp;operator=(Scheme const &amp;);
 
 private:
     static Auth::Scheme::Pointer _instance;
 };
 
 } // namespace Basic
 } // namespace Auth
 
 #endif /* HAVE_AUTH_MODULE_BASIC */
 #endif /* SQUID_AUTH_BASIC_SCHEME_H */
 

=== modified file 'src/auth/basic/User.cc'
--- src/auth/basic/User.cc	2016-01-01 00:12:18 +0000
+++ src/auth/basic/User.cc	2016-12-19 14:43:15 +0000
@@ -1,56 +1,55 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;auth/basic/Config.h&quot;
 #include &quot;auth/basic/User.h&quot;
+#include &quot;auth/Config.h&quot;
 #include &quot;auth/CredentialsCache.h&quot;
 #include &quot;Debug.h&quot;
-#include &quot;SquidConfig.h&quot;
-#include &quot;SquidTime.h&quot;
 
-Auth::Basic::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
+Auth::Basic::User::User(Auth::SchemeConfig *aConfig, const char *aRequestRealm) :
     Auth::User(aConfig, aRequestRealm),
     passwd(NULL),
     queue(NULL),
     currentRequest(NULL)
 {}
 
 Auth::Basic::User::~User()
 {
     safe_free(passwd);
 }
 
 int32_t
 Auth::Basic::User::ttl() const
 {
     if (credentials() != Auth::Ok &amp;&amp; credentials() != Auth::Pending)
         return -1; // TTL is obsolete NOW.
 
     int32_t basic_ttl = expiretime - squid_curtime + static_cast&lt;Auth::Basic::Config*&gt;(config)-&gt;credentialsTTL;
-    int32_t global_ttl = static_cast&lt;int32_t&gt;(expiretime - squid_curtime + ::Config.authenticateTTL);
+    int32_t global_ttl = static_cast&lt;int32_t&gt;(expiretime - squid_curtime + Auth::TheConfig.authenticateTTL);
 
     return min(basic_ttl, global_ttl);
 }
 
 bool
 Auth::Basic::User::authenticated() const
 {
     if ((credentials() == Auth::Ok) &amp;&amp; (expiretime + static_cast&lt;Auth::Basic::Config*&gt;(config)-&gt;credentialsTTL &gt; squid_curtime))
         return true;
 
     debugs(29, 4, &quot;User not authenticated or credentials need rechecking.&quot;);
 
     return false;
 }
 
 bool
 Auth::Basic::User::valid() const
 {
     if (username() == NULL)
         return false;

=== modified file 'src/auth/basic/User.h'
--- src/auth/basic/User.h	2016-01-01 00:12:18 +0000
+++ src/auth/basic/User.h	2016-12-19 13:27:10 +0000
@@ -1,52 +1,52 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_AUTH_BASIC_USER_H
 #define _SQUID_AUTH_BASIC_USER_H
 
 #if HAVE_AUTH_MODULE_BASIC
 
 #include &quot;auth/User.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 
 namespace Auth
 {
 
-class Config;
+class SchemeConfig;
 class QueueNode;
 
 namespace Basic
 {
 
 /** User credentials for the Basic authentication protocol */
 class User : public Auth::User
 {
     MEMPROXY_CLASS(Auth::Basic::User);
 
 public:
-    User(Auth::Config *, const char *requestRealm);
+    User(Auth::SchemeConfig *, const char *requestRealm);
     virtual ~User();
     bool authenticated() const;
     bool valid() const;
 
     /** Update the cached password for a username. */
     void updateCached(User *from);
     virtual int32_t ttl() const override;
 
     /* Auth::User API */
     static CbcPointer&lt;Auth::CredentialsCache&gt; Cache();
     virtual void addToNameCache() override;
 
     char *passwd;
 
     QueueNode *queue;
 
 private:
     Auth::UserRequest::Pointer currentRequest;
 };
 

=== modified file 'src/auth/basic/UserRequest.cc'
--- src/auth/basic/UserRequest.cc	2016-01-01 00:12:18 +0000
+++ src/auth/basic/UserRequest.cc	2016-12-19 13:27:11 +0000
@@ -42,89 +42,89 @@
 Auth::Basic::UserRequest::credentialsStr()
 {
     Auth::Basic::User const *basic_auth = dynamic_cast&lt;Auth::Basic::User const *&gt;(user().getRaw());
     if (basic_auth)
         return basic_auth-&gt;passwd;
     return NULL;
 }
 
 /* log a basic user in
  */
 void
 Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, Http::HdrType)
 {
     assert(user() != NULL);
 
     /* if the password is not ok, do an identity */
     if (!user() || user()-&gt;credentials() != Auth::Ok)
         return;
 
     /* are we about to recheck the credentials externally? */
-    if ((user()-&gt;expiretime + static_cast&lt;Auth::Basic::Config*&gt;(Auth::Config::Find(&quot;basic&quot;))-&gt;credentialsTTL) &lt;= squid_curtime) {
+    if ((user()-&gt;expiretime + static_cast&lt;Auth::Basic::Config*&gt;(Auth::SchemeConfig::Find(&quot;basic&quot;))-&gt;credentialsTTL) &lt;= squid_curtime) {
         debugs(29, 4, HERE &lt;&lt; &quot;credentials expired - rechecking&quot;);
         return;
     }
 
     /* we have been through the external helper, and the credentials haven't expired */
     debugs(29, 9, HERE &lt;&lt; &quot;user '&quot; &lt;&lt; user()-&gt;username() &lt;&lt; &quot;' authenticated&quot;);
 
     /* Decode now takes care of finding the AuthUser struct in the cache */
     /* after external auth occurs anyway */
     user()-&gt;expiretime = current_time.tv_sec;
 }
 
 Auth::Direction
 Auth::Basic::UserRequest::module_direction()
 {
     /* null auth_user is checked for by Auth::UserRequest::direction() */
     if (user()-&gt;auth_type != Auth::AUTH_BASIC)
         return Auth::CRED_ERROR;
 
     switch (user()-&gt;credentials()) {
 
     case Auth::Unchecked:
     case Auth::Pending:
         return Auth::CRED_LOOKUP;
 
     case Auth::Ok:
-        if (user()-&gt;expiretime + static_cast&lt;Auth::Basic::Config*&gt;(Auth::Config::Find(&quot;basic&quot;))-&gt;credentialsTTL &lt;= squid_curtime)
+        if (user()-&gt;expiretime + static_cast&lt;Auth::Basic::Config*&gt;(Auth::SchemeConfig::Find(&quot;basic&quot;))-&gt;credentialsTTL &lt;= squid_curtime)
             return Auth::CRED_LOOKUP;
         return Auth::CRED_VALID;
 
     case Auth::Failed:
         return Auth::CRED_VALID;
 
     default:
         return Auth::CRED_ERROR;
     }
 }
 
 /* send the initial data to a basic authenticator module */
 void
 Auth::Basic::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &amp;al, AUTHCB * handler, void *data)
 {
     assert(user()-&gt;auth_type == Auth::AUTH_BASIC);
     Auth::Basic::User *basic_auth = dynamic_cast&lt;Auth::Basic::User *&gt;(user().getRaw());
     assert(basic_auth != NULL);
     debugs(29, 9, HERE &lt;&lt; &quot;'&quot; &lt;&lt; basic_auth-&gt;username() &lt;&lt; &quot;:&quot; &lt;&lt; basic_auth-&gt;passwd &lt;&lt; &quot;'&quot;);
 
-    if (static_cast&lt;Auth::Basic::Config*&gt;(Auth::Config::Find(&quot;basic&quot;))-&gt;authenticateProgram == NULL) {
+    if (static_cast&lt;Auth::Basic::Config*&gt;(Auth::SchemeConfig::Find(&quot;basic&quot;))-&gt;authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, &quot;ERROR: No Basic authentication program configured.&quot;);
         handler(data);
         return;
     }
 
     /* check to see if the auth_user already has a request outstanding */
     if (user()-&gt;credentials() == Auth::Pending) {
         /* there is a request with the same credentials already being verified */
 
         Auth::QueueNode *node = new Auth::QueueNode(this, handler, data);
 
         /* queue this validation request to be infored of the pending lookup results */
         node-&gt;next = basic_auth-&gt;queue;
         basic_auth-&gt;queue = node;
         return;
     }
     // otherwise submit this request to the auth helper(s) for validation
 
     /* mark this user as having verification in progress */
     user()-&gt;credentials(Auth::Pending);

=== modified file 'src/auth/digest/Config.cc'
--- src/auth/digest/Config.cc	2016-11-27 13:57:50 +0000
+++ src/auth/digest/Config.cc	2016-12-20 12:18:55 +0000
@@ -198,41 +198,41 @@
 
 #endif
 
         assert(!nonce-&gt;flags.incache);
 
         safe_free(nonce-&gt;key);
 
         digest_nonce_pool-&gt;freeOne(nonce);
     }
 }
 
 static void
 authenticateDigestNonceSetup(void)
 {
     if (!digest_nonce_pool)
         digest_nonce_pool = memPoolCreate(&quot;Digest Scheme nonce's&quot;, sizeof(digest_nonce_h));
 
     if (!digest_nonce_cache) {
         digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
         assert(digest_nonce_cache);
-        eventAdd(&quot;Digest nonce cache maintenance&quot;, authenticateDigestNonceCacheCleanup, NULL, static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;nonceGCInterval, 1);
+        eventAdd(&quot;Digest nonce cache maintenance&quot;, authenticateDigestNonceCacheCleanup, NULL, static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;nonceGCInterval, 1);
     }
 }
 
 void
 authenticateDigestNonceShutdown(void)
 {
     /*
      * We empty the cache of any nonces left in there.
      */
     digest_nonce_h *nonce;
 
     if (digest_nonce_cache) {
         debugs(29, 2, &quot;Shutting down nonce cache&quot;);
         hash_first(digest_nonce_cache);
 
         while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
             assert(nonce-&gt;flags.incache);
             authDigestNoncePurge(nonce);
         }
     }
@@ -261,42 +261,42 @@
     debugs(29, 3, &quot;Current time: &quot; &lt;&lt; current_time.tv_sec);
     hash_first(digest_nonce_cache);
 
     while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
         debugs(29, 3, &quot;nonce entry  : &quot; &lt;&lt; nonce &lt;&lt; &quot; '&quot; &lt;&lt; (char *) nonce-&gt;key &lt;&lt; &quot;'&quot;);
         debugs(29, 4, &quot;Creation time: &quot; &lt;&lt; nonce-&gt;noncedata.creationtime);
 
         if (authDigestNonceIsStale(nonce)) {
             debugs(29, 4, &quot;Removing nonce &quot; &lt;&lt; (char *) nonce-&gt;key &lt;&lt; &quot; from cache due to timeout.&quot;);
             assert(nonce-&gt;flags.incache);
             /* invalidate nonce so future requests fail */
             nonce-&gt;flags.valid = false;
             /* if it is tied to a auth_user, remove the tie */
             authDigestNonceUserUnlink(nonce);
             authDigestNoncePurge(nonce);
         }
     }
 
     debugs(29, 3, &quot;Finished cleaning the nonce cache.&quot;);
 
-    if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;active())
-        eventAdd(&quot;Digest nonce cache maintenance&quot;, authenticateDigestNonceCacheCleanup, NULL, static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;nonceGCInterval, 1);
+    if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;active())
+        eventAdd(&quot;Digest nonce cache maintenance&quot;, authenticateDigestNonceCacheCleanup, NULL, static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;nonceGCInterval, 1);
 }
 
 static void
 authDigestNonceLink(digest_nonce_h * nonce)
 {
     assert(nonce != NULL);
     ++nonce-&gt;references;
     debugs(29, 9, &quot;nonce '&quot; &lt;&lt; nonce &lt;&lt; &quot;' now at '&quot; &lt;&lt; nonce-&gt;references &lt;&lt; &quot;'.&quot;);
 }
 
 #if NOT_USED
 static int
 authDigestNonceLinks(digest_nonce_h * nonce)
 {
     if (!nonce)
         return -1;
 
     return nonce-&gt;references;
 }
 
@@ -349,162 +349,161 @@
 }
 
 int
 authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
 {
     unsigned long intnc;
     /* do we have a nonce ? */
 
     if (!nonce)
         return 0;
 
     intnc = strtol(nc, NULL, 16);
 
     /* has it already been invalidated ? */
     if (!nonce-&gt;flags.valid) {
         debugs(29, 4, &quot;Nonce already invalidated&quot;);
         return 0;
     }
 
     /* is the nonce-count ok ? */
-    if (!static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;CheckNonceCount) {
+    if (!static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;CheckNonceCount) {
         /* Ignore client supplied NC */
         intnc = nonce-&gt;nc + 1;
     }
 
-    if ((static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;NonceStrictness &amp;&amp; intnc != nonce-&gt;nc + 1) ||
+    if ((static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;NonceStrictness &amp;&amp; intnc != nonce-&gt;nc + 1) ||
             intnc &lt; nonce-&gt;nc + 1) {
         debugs(29, 4, &quot;Nonce count doesn't match&quot;);
         nonce-&gt;flags.valid = false;
         return 0;
     }
 
     /* increment the nonce count - we've already checked that intnc is a
      *  valid representation for us, so we don't need the test here.
      */
     nonce-&gt;nc = intnc;
 
     return !authDigestNonceIsStale(nonce);
 }
 
 int
 authDigestNonceIsStale(digest_nonce_h * nonce)
 {
     /* do we have a nonce ? */
 
     if (!nonce)
         return -1;
 
     /* Is it already invalidated? */
     if (!nonce-&gt;flags.valid)
         return -1;
 
     /* has it's max duration expired? */
-    if (nonce-&gt;noncedata.creationtime + static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;noncemaxduration &lt; current_time.tv_sec) {
+    if (nonce-&gt;noncedata.creationtime + static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;noncemaxduration &lt; current_time.tv_sec) {
         debugs(29, 4, &quot;Nonce is too old. &quot; &lt;&lt;
                nonce-&gt;noncedata.creationtime &lt;&lt; &quot; &quot; &lt;&lt;
-               static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;noncemaxduration &lt;&lt; &quot; &quot; &lt;&lt;
+               static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;noncemaxduration &lt;&lt; &quot; &quot; &lt;&lt;
                current_time.tv_sec);
 
         nonce-&gt;flags.valid = false;
         return -1;
     }
 
     if (nonce-&gt;nc &gt; 99999998) {
         debugs(29, 4, &quot;Nonce count overflow&quot;);
         nonce-&gt;flags.valid = false;
         return -1;
     }
 
-    if (nonce-&gt;nc &gt; static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;noncemaxuses) {
+    if (nonce-&gt;nc &gt; static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;noncemaxuses) {
         debugs(29, 4, &quot;Nonce count over user limit&quot;);
         nonce-&gt;flags.valid = false;
         return -1;
     }
 
     /* seems ok */
     return 0;
 }
 
 /**
  * \retval  0    the digest is not stale yet
  * \retval -1    the digest will be stale on the next request
  */
 int
 authDigestNonceLastRequest(digest_nonce_h * nonce)
 {
     if (!nonce)
         return -1;
 
     if (nonce-&gt;nc == 99999997) {
         debugs(29, 4, &quot;Nonce count about to overflow&quot;);
         return -1;
     }
 
-    if (nonce-&gt;nc &gt;= static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;noncemaxuses - 1) {
+    if (nonce-&gt;nc &gt;= static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;noncemaxuses - 1) {
         debugs(29, 4, &quot;Nonce count about to hit user limit&quot;);
         return -1;
     }
 
     /* and other tests are possible. */
     return 0;
 }
 
 void
 authDigestNoncePurge(digest_nonce_h * nonce)
 {
     if (!nonce)
         return;
 
     if (!nonce-&gt;flags.incache)
         return;
 
     hash_remove_link(digest_nonce_cache, nonce);
 
     nonce-&gt;flags.incache = false;
 
     /* the cache's link */
     authDigestNonceUnlink(nonce);
 }
 
 void
 Auth::Digest::Config::rotateHelpers()
 {
     /* schedule closure of existing helpers */
     if (digestauthenticators) {
         helperShutdown(digestauthenticators);
     }
 
     /* NP: dynamic helper restart will ensure they start up again as needed. */
 }
 
 bool
-Auth::Digest::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme) const
+Auth::Digest::Config::dump(StoreEntry * entry, const char *name, Auth::SchemeConfig * scheme) const
 {
-    if (!Auth::Config::dump(entry, name, scheme))
+    if (!Auth::SchemeConfig::dump(entry, name, scheme))
         return false;
 
     storeAppendPrintf(entry, &quot;%s %s nonce_max_count %d\n%s %s nonce_max_duration %d seconds\n%s %s nonce_garbage_interval %d seconds\n&quot;,
                       name, &quot;digest&quot;, noncemaxuses,
                       name, &quot;digest&quot;, (int) noncemaxduration,
                       name, &quot;digest&quot;, (int) nonceGCInterval);
-    storeAppendPrintf(entry, &quot;%s digest utf8 %s\n&quot;, name, utf8 ? &quot;on&quot; : &quot;off&quot;);
     return true;
 }
 
 bool
 Auth::Digest::Config::active() const
 {
     return authdigest_initialised == 1;
 }
 
 bool
 Auth::Digest::Config::configured() const
 {
     if ((authenticateProgram != NULL) &amp;&amp;
             (authenticateChildren.n_max != 0) &amp;&amp;
             !realm.isEmpty() &amp;&amp; (noncemaxduration &gt; -1))
         return true;
 
     return false;
 }
 
@@ -529,124 +528,114 @@
             }
         }
     }
     if (!nonce) {
         nonce = authenticateDigestNonceNew();
     }
 
     debugs(29, 9, &quot;Sending type:&quot; &lt;&lt; hdrType &lt;&lt;
            &quot; header: 'Digest realm=\&quot;&quot; &lt;&lt; realm &lt;&lt; &quot;\&quot;, nonce=\&quot;&quot; &lt;&lt;
            authenticateDigestNonceNonceb64(nonce) &lt;&lt; &quot;\&quot;, qop=\&quot;&quot; &lt;&lt; QOP_AUTH &lt;&lt;
            &quot;\&quot;, stale=&quot; &lt;&lt; (stale ? &quot;true&quot; : &quot;false&quot;));
 
     /* in the future, for WWW auth we may want to support the domain entry */
     httpHeaderPutStrf(&amp;rep-&gt;header, hdrType, &quot;Digest realm=\&quot;&quot; SQUIDSBUFPH &quot;\&quot;, nonce=\&quot;%s\&quot;, qop=\&quot;%s\&quot;, stale=%s&quot;,
                       SQUIDSBUFPRINT(realm), authenticateDigestNonceNonceb64(nonce), QOP_AUTH, stale ? &quot;true&quot; : &quot;false&quot;);
 }
 
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
 void
-Auth::Digest::Config::init(Auth::Config *)
+Auth::Digest::Config::init(Auth::SchemeConfig *)
 {
     if (authenticateProgram) {
         authenticateDigestNonceSetup();
         authdigest_initialised = 1;
 
         if (digestauthenticators == NULL)
             digestauthenticators = new helper(&quot;digestauthenticator&quot;);
 
         digestauthenticators-&gt;cmdline = authenticateProgram;
 
         digestauthenticators-&gt;childs.updateLimits(authenticateChildren);
 
         digestauthenticators-&gt;ipc_type = IPC_STREAM;
 
         helperOpenServers(digestauthenticators);
     }
 }
 
 void
 Auth::Digest::Config::registerWithCacheManager(void)
 {
     Mgr::RegisterAction(&quot;digestauthenticator&quot;,
                         &quot;Digest User Authenticator Stats&quot;,
                         authenticateDigestStats, 0, 1);
 }
 
 /* free any allocated configuration details */
 void
 Auth::Digest::Config::done()
 {
-    Auth::Config::done();
+    Auth::SchemeConfig::done();
 
     authdigest_initialised = 0;
 
     if (digestauthenticators)
         helperShutdown(digestauthenticators);
 
     if (!shutting_down)
         return;
 
     delete digestauthenticators;
     digestauthenticators = NULL;
 
     if (authenticateProgram)
         wordlistDestroy(&amp;authenticateProgram);
 }
 
 Auth::Digest::Config::Config() :
     nonceGCInterval(5*60),
     noncemaxduration(30*60),
     noncemaxuses(50),
     NonceStrictness(0),
     CheckNonceCount(1),
-    PostWorkaround(0),
-    utf8(0)
+    PostWorkaround(0)
 {}
 
 void
-Auth::Digest::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
+Auth::Digest::Config::parse(Auth::SchemeConfig * scheme, int n_configured, char *param_str)
 {
-    if (strcmp(param_str, &quot;program&quot;) == 0) {
-        if (authenticateProgram)
-            wordlistDestroy(&amp;authenticateProgram);
-
-        parse_wordlist(&amp;authenticateProgram);
-
-        requirePathnameExists(&quot;auth_param digest program&quot;, authenticateProgram-&gt;key);
-    } else if (strcmp(param_str, &quot;nonce_garbage_interval&quot;) == 0) {
+    if (strcmp(param_str, &quot;nonce_garbage_interval&quot;) == 0) {
         parse_time_t(&amp;nonceGCInterval);
     } else if (strcmp(param_str, &quot;nonce_max_duration&quot;) == 0) {
         parse_time_t(&amp;noncemaxduration);
     } else if (strcmp(param_str, &quot;nonce_max_count&quot;) == 0) {
         parse_int((int *) &amp;noncemaxuses);
     } else if (strcmp(param_str, &quot;nonce_strictness&quot;) == 0) {
         parse_onoff(&amp;NonceStrictness);
     } else if (strcmp(param_str, &quot;check_nonce_count&quot;) == 0) {
         parse_onoff(&amp;CheckNonceCount);
     } else if (strcmp(param_str, &quot;post_workaround&quot;) == 0) {
         parse_onoff(&amp;PostWorkaround);
-    } else if (strcmp(param_str, &quot;utf8&quot;) == 0) {
-        parse_onoff(&amp;utf8);
     } else
-        Auth::Config::parse(scheme, n_configured, param_str);
+        Auth::SchemeConfig::parse(scheme, n_configured, param_str);
 }
 
 const char *
 Auth::Digest::Config::type() const
 {
     return Auth::Digest::Scheme::GetInstance()-&gt;type();
 }
 
 static void
 authenticateDigestStats(StoreEntry * sentry)
 {
     if (digestauthenticators)
         digestauthenticators-&gt;packStatsInto(sentry, &quot;Digest Authenticator Statistics&quot;);
 }
 
 /* NonceUserUnlink: remove the reference to auth_user and unlink the node from the list */
 
 static void
 authDigestNonceUserUnlink(digest_nonce_h * nonce)
 {
@@ -709,41 +698,41 @@
 
     authDigestNonceLink(nonce);
 
     /* ping this nonce to this auth user */
     assert((nonce-&gt;user == NULL) || (nonce-&gt;user == user));
 
     /* we don't lock this reference because removing the user removes the
      * hash too. Of course if that changes we're stuffed so read the code huh?
      */
     nonce-&gt;user = user;
 }
 
 /* setup the necessary info to log the username */
 static Auth::UserRequest::Pointer
 authDigestLogUsername(char *username, Auth::UserRequest::Pointer auth_user_request, const char *requestRealm)
 {
     assert(auth_user_request != NULL);
 
     /* log the username */
     debugs(29, 9, &quot;Creating new user for logging '&quot; &lt;&lt; (username?username:&quot;[no username]&quot;) &lt;&lt; &quot;'&quot;);
-    Auth::User::Pointer digest_user = new Auth::Digest::User(static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;)), requestRealm);
+    Auth::User::Pointer digest_user = new Auth::Digest::User(static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;)), requestRealm);
     /* save the credentials */
     digest_user-&gt;username(username);
     /* set the auth_user type */
     digest_user-&gt;auth_type = Auth::AUTH_BROKEN;
     /* link the request to the user */
     auth_user_request-&gt;user(digest_user);
     return auth_user_request;
 }
 
 /*
  * Decode a Digest [Proxy-]Auth string, placing the results in the passed
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
 Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
 {
     const char *item;
     const char *p;
     const char *pos = NULL;
     char *username = NULL;

=== modified file 'src/auth/digest/Config.h'
--- src/auth/digest/Config.h	2016-01-01 00:12:18 +0000
+++ src/auth/digest/Config.h	2016-12-20 12:14:14 +0000
@@ -1,35 +1,35 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef __AUTH_DIGEST_H__
 #define __AUTH_DIGEST_H__
 
 #if HAVE_AUTH_MODULE_DIGEST
 
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/Gadgets.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;helper/forward.h&quot;
 #include &quot;rfc2617.h&quot;
 
 namespace Auth
 {
 namespace Digest
 {
 class User;
 }
 }
 
 /* Generic */
 typedef struct _digest_nonce_data digest_nonce_data;
 typedef struct _digest_nonce_h digest_nonce_h;
 
 /* data to be encoded into the nonce's b64 representation */
 struct _digest_nonce_data {
     time_t creationtime;
     /* in memory address of the nonce struct (similar purpose to an ETag) */
@@ -54,57 +54,56 @@
         bool incache;
     } flags;
 };
 
 void authDigestNonceUnlink(digest_nonce_h * nonce);
 int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
 int authDigestNonceIsStale(digest_nonce_h * nonce);
 const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
 int authDigestNonceLastRequest(digest_nonce_h * nonce);
 void authenticateDigestNonceShutdown(void);
 void authDigestNoncePurge(digest_nonce_h * nonce);
 void authDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce);
 digest_nonce_h *authenticateDigestNonceNew(void);
 
 namespace Auth
 {
 namespace Digest
 {
 
 /** Digest Authentication configuration data */
-class Config : public Auth::Config
+class Config : public Auth::SchemeConfig
 {
 public:
     Config();
     virtual bool active() const;
     virtual bool configured() const;
     virtual Auth::UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm);
     virtual void done();
     virtual void rotateHelpers();
-    virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
+    virtual bool dump(StoreEntry *, const char *, Auth::SchemeConfig *) const;
     virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
-    virtual void init(Auth::Config *);
-    virtual void parse(Auth::Config *, int, char *);
+    virtual void init(Auth::SchemeConfig *);
+    virtual void parse(Auth::SchemeConfig *, int, char *);
     virtual void registerWithCacheManager(void);
     virtual const char * type() const;
 
 public:
     time_t nonceGCInterval;
     time_t noncemaxduration;
     unsigned int noncemaxuses;
     int NonceStrictness;
     int CheckNonceCount;
     int PostWorkaround;
-    int utf8;
 };
 
 } // namespace Digest
 } // namespace Auth
 
 /* strings */
 #define QOP_AUTH &quot;auth&quot;
 
 extern helper *digestauthenticators;
 
 #endif /* HAVE_AUTH_MODULE_DIGEST */
 #endif
 

=== modified file 'src/auth/digest/Scheme.cc'
--- src/auth/digest/Scheme.cc	2016-01-01 00:12:18 +0000
+++ src/auth/digest/Scheme.cc	2016-12-19 13:27:31 +0000
@@ -26,27 +26,27 @@
 }
 
 char const *
 Auth::Digest::Scheme::type() const
 {
     return &quot;digest&quot;;
 }
 
 void
 Auth::Digest::Scheme::shutdownCleanup()
 {
     if (_instance == NULL)
         return;
 
     authenticateDigestNonceShutdown();
 
     _instance = NULL;
     debugs(29, DBG_CRITICAL, &quot;Shutdown: Digest authentication.&quot;);
 }
 
-Auth::Config *
+Auth::SchemeConfig *
 Auth::Digest::Scheme::createConfig()
 {
     Auth::Digest::Config *digestCfg = new Auth::Digest::Config;
-    return dynamic_cast&lt;Auth::Config*&gt;(digestCfg);
+    return dynamic_cast&lt;Auth::SchemeConfig*&gt;(digestCfg);
 }
 

=== modified file 'src/auth/digest/Scheme.h'
--- src/auth/digest/Scheme.h	2016-01-01 00:12:18 +0000
+++ src/auth/digest/Scheme.h	2016-12-19 13:27:32 +0000
@@ -1,50 +1,49 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_DIGEST_SCHEME_H
 #define SQUID_AUTH_DIGEST_SCHEME_H
 
 #if HAVE_AUTH_MODULE_DIGEST
 
 #include &quot;auth/Scheme.h&quot;
 
 namespace Auth
 {
 namespace Digest
 {
 
-/// \ingroup AuthSchemeAPI
 /// \ingroup AuthAPI
 class Scheme : public Auth::Scheme
 {
 
 public:
     static Auth::Scheme::Pointer GetInstance();
     Scheme() {};
     virtual ~Scheme() {}
 
     /* per scheme */
     virtual char const *type () const;
     virtual void shutdownCleanup();
-    virtual Auth::Config *createConfig();
+    virtual Auth::SchemeConfig *createConfig();
 
     /* Not implemented */
     Scheme(Scheme const &amp;);
     Scheme &amp;operator=(Scheme const &amp;);
 
 private:
     static Auth::Scheme::Pointer _instance;
 
 };
 
 } // namespace Digest
 } // namespace Auth
 
 #endif /* HAVE_AUTH_MODULE_DIGEST */
 #endif /* SQUID_AUTH_DIGEST_SCHEME_H */
 

=== modified file 'src/auth/digest/User.cc'
--- src/auth/digest/User.cc	2016-01-01 00:12:18 +0000
+++ src/auth/digest/User.cc	2016-12-19 14:50:30 +0000
@@ -1,78 +1,77 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
+#include &quot;auth/Config.h&quot;
 #include &quot;auth/CredentialsCache.h&quot;
 #include &quot;auth/digest/Config.h&quot;
 #include &quot;auth/digest/User.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;dlink.h&quot;
-#include &quot;SquidConfig.h&quot;
-#include &quot;SquidTime.h&quot;
 
-Auth::Digest::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
+Auth::Digest::User::User(Auth::SchemeConfig *aConfig, const char *aRequestRealm) :
     Auth::User(aConfig, aRequestRealm),
     HA1created(0)
 {
     memset(HA1, 0, sizeof(HA1));
 }
 
 Auth::Digest::User::~User()
 {
     dlink_node *link, *tmplink;
     link = nonces.head;
 
     while (link) {
         tmplink = link;
         link = link-&gt;next;
         dlinkDelete(tmplink, &amp;nonces);
         authDigestNoncePurge(static_cast &lt; digest_nonce_h * &gt;(tmplink-&gt;data));
         authDigestNonceUnlink(static_cast &lt; digest_nonce_h * &gt;(tmplink-&gt;data));
         delete tmplink;
     }
 }
 
 int32_t
 Auth::Digest::User::ttl() const
 {
-    int32_t global_ttl = static_cast&lt;int32_t&gt;(expiretime - squid_curtime + ::Config.authenticateTTL);
+    int32_t global_ttl = static_cast&lt;int32_t&gt;(expiretime - squid_curtime + Auth::TheConfig.authenticateTTL);
 
     /* find the longest lasting nonce. */
     int32_t latest_nonce = -1;
     dlink_node *link = nonces.head;
     while (link) {
         digest_nonce_h *nonce = static_cast&lt;digest_nonce_h *&gt;(link-&gt;data);
         if (nonce-&gt;flags.valid &amp;&amp; nonce-&gt;noncedata.creationtime &gt; latest_nonce)
             latest_nonce = nonce-&gt;noncedata.creationtime;
 
         link = link-&gt;next;
     }
     if (latest_nonce == -1)
         return min(-1, global_ttl);
 
-    int32_t nonce_ttl = latest_nonce - current_time.tv_sec + static_cast&lt;Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;noncemaxduration;
+    int32_t nonce_ttl = latest_nonce - current_time.tv_sec + static_cast&lt;Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;noncemaxduration;
 
     return min(nonce_ttl, global_ttl);
 }
 
 digest_nonce_h *
 Auth::Digest::User::currentNonce()
 {
     digest_nonce_h *nonce = NULL;
     dlink_node *link = nonces.tail;
     if (link) {
         nonce = static_cast&lt;digest_nonce_h *&gt;(link-&gt;data);
         if (authDigestNonceIsStale(nonce))
             nonce = NULL;
     }
     return nonce;
 }
 
 CbcPointer&lt;Auth::CredentialsCache&gt;
 Auth::Digest::User::Cache()
 {

=== modified file 'src/auth/digest/User.h'
--- src/auth/digest/User.h	2016-01-01 00:12:18 +0000
+++ src/auth/digest/User.h	2016-12-19 13:27:34 +0000
@@ -9,41 +9,41 @@
 #ifndef _SQUID_AUTH_DIGEST_USER_H
 #define _SQUID_AUTH_DIGEST_USER_H
 
 #if HAVE_AUTH_MODULE_DIGEST
 
 #include &quot;auth/digest/Config.h&quot;
 #include &quot;auth/User.h&quot;
 #include &quot;rfc2617.h&quot;
 
 namespace Auth
 {
 namespace Digest
 {
 
 /** User credentials for the Digest authentication protocol */
 class User : public Auth::User
 {
     MEMPROXY_CLASS(Auth::Digest::User);
 
 public:
-    User(Auth::Config *, const char *requestRealm);
+    User(Auth::SchemeConfig *, const char *requestRealm);
     virtual ~User();
     int authenticated() const;
     virtual int32_t ttl() const override;
 
     /* Auth::User API */
     static CbcPointer&lt;Auth::CredentialsCache&gt; Cache();
     virtual void addToNameCache() override;
 
     HASH HA1;
     int HA1created;
 
     /* what nonces have been allocated to this user */
     dlink_list nonces;
 
     digest_nonce_h * currentNonce();
 };
 
 } // namespace Digest
 } // namespace Auth
 

=== modified file 'src/auth/digest/UserRequest.cc'
--- src/auth/digest/UserRequest.cc	2016-11-27 13:57:50 +0000
+++ src/auth/digest/UserRequest.cc	2016-12-19 13:27:35 +0000
@@ -110,41 +110,41 @@
 
     DigestCalcHA1(digest_request-&gt;algorithm, NULL, NULL, NULL,
                   authenticateDigestNonceNonceb64(digest_request-&gt;nonce),
                   digest_request-&gt;cnonce,
                   digest_user-&gt;HA1, SESSIONKEY);
     SBuf sTmp = request-&gt;method.image();
     DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request-&gt;nonce),
                        digest_request-&gt;nc, digest_request-&gt;cnonce, digest_request-&gt;qop,
                        sTmp.c_str(), digest_request-&gt;uri, HA2, Response);
 
     debugs(29, 9, &quot;\nResponse = '&quot; &lt;&lt; digest_request-&gt;response &lt;&lt; &quot;'\nsquid is = '&quot; &lt;&lt; Response &lt;&lt; &quot;'&quot;);
 
     if (strcasecmp(digest_request-&gt;response, Response) != 0) {
         if (!digest_request-&gt;flags.helper_queried) {
             /* Query the helper in case the password has changed */
             digest_request-&gt;flags.helper_queried = true;
             auth_user-&gt;credentials(Auth::Pending);
             return;
         }
 
-        if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;PostWorkaround &amp;&amp; request-&gt;method != Http::METHOD_GET) {
+        if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;PostWorkaround &amp;&amp; request-&gt;method != Http::METHOD_GET) {
             /* Ugly workaround for certain very broken browsers using the
              * wrong method to calculate the request-digest on POST request.
              * This should be deleted once Digest authentication becomes more
              * widespread and such broken browsers no longer are commonly
              * used.
              */
             sTmp = HttpRequestMethod(Http::METHOD_GET).image();
             DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request-&gt;nonce),
                                digest_request-&gt;nc, digest_request-&gt;cnonce, digest_request-&gt;qop,
                                sTmp.c_str(), digest_request-&gt;uri, HA2, Response);
 
             if (strcasecmp(digest_request-&gt;response, Response)) {
                 auth_user-&gt;credentials(Auth::Failed);
                 digest_request-&gt;flags.invalid_password = true;
                 digest_request-&gt;setDenyMessage(&quot;Incorrect password&quot;);
                 return;
             } else {
                 const char *useragent = request-&gt;header.getStr(Http::HdrType::USER_AGENT);
 
                 static Ip::Address last_broken_addr;
@@ -216,41 +216,41 @@
 }
 
 void
 Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
 {
     Http::HdrType type;
 
     /* don't add to authentication error pages */
     if ((!accel &amp;&amp; rep-&gt;sline.status() == Http::scProxyAuthenticationRequired)
             || (accel &amp;&amp; rep-&gt;sline.status() == Http::scUnauthorized))
         return;
 
     type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
 #if WAITING_FOR_TE
     /* test for http/1.1 transfer chunked encoding */
     if (chunkedtest)
         return;
 #endif
 
-    if ((static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;authenticateProgram) &amp;&amp; authDigestNonceLastRequest(nonce)) {
+    if ((static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;authenticateProgram) &amp;&amp; authDigestNonceLastRequest(nonce)) {
         flags.authinfo_sent = true;
         Auth::Digest::User *digest_user = dynamic_cast&lt;Auth::Digest::User *&gt;(user().getRaw());
         if (!digest_user)
             return;
 
         digest_nonce_h *nextnonce = digest_user-&gt;currentNonce();
         if (!nextnonce || authDigestNonceLastRequest(nonce)) {
             nextnonce = authenticateDigestNonceNew();
             authDigestUserLinkNonce(digest_user, nextnonce);
         }
         debugs(29, 9, &quot;Sending type:&quot; &lt;&lt; type &lt;&lt; &quot; header: 'nextnonce=\&quot;&quot; &lt;&lt; authenticateDigestNonceNonceb64(nextnonce) &lt;&lt; &quot;\&quot;&quot;);
         httpHeaderPutStrf(&amp;rep-&gt;header, type, &quot;nextnonce=\&quot;%s\&quot;&quot;, authenticateDigestNonceNonceb64(nextnonce));
     }
 }
 
 #if WAITING_FOR_TE
 void
 Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int accel)
 {
     int type;
@@ -274,48 +274,48 @@
         nonce = digest_user-&gt;currentNonce();
         if (!nonce) {
             nonce = authenticateDigestNonceNew();
             authDigestUserLinkNonce(digest_user, nonce);
         }
         debugs(29, 9, &quot;Sending type:&quot; &lt;&lt; type &lt;&lt; &quot; header: 'nextnonce=\&quot;&quot; &lt;&lt; authenticateDigestNonceNonceb64(nonce) &lt;&lt; &quot;\&quot;&quot;);
         httpTrailerPutStrf(&amp;rep-&gt;header, type, &quot;nextnonce=\&quot;%s\&quot;&quot;, authenticateDigestNonceNonceb64(nonce));
     }
 }
 #endif
 
 /* send the initial data to a digest authenticator module */
 void
 Auth::Digest::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &amp;al, AUTHCB * handler, void *data)
 {
     char buf[8192];
 
     assert(user() != NULL &amp;&amp; user()-&gt;auth_type == Auth::AUTH_DIGEST);
     debugs(29, 9, HERE &lt;&lt; &quot;'\&quot;&quot; &lt;&lt; user()-&gt;username() &lt;&lt; &quot;\&quot;:\&quot;&quot; &lt;&lt; realm &lt;&lt; &quot;\&quot;'&quot;);
 
-    if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;authenticateProgram == NULL) {
+    if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, &quot;ERROR: No Digest authentication program configured.&quot;);
         handler(data);
         return;
     }
 
     const char *keyExtras = helperRequestKeyExtras(request, al);
-    if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::Config::Find(&quot;digest&quot;))-&gt;utf8) {
+    if (static_cast&lt;Auth::Digest::Config*&gt;(Auth::SchemeConfig::Find(&quot;digest&quot;))-&gt;utf8) {
         char userstr[1024];
         latin1_to_utf8(userstr, sizeof(userstr), user()-&gt;username());
         if (keyExtras)
             snprintf(buf, 8192, &quot;\&quot;%s\&quot;:\&quot;%s\&quot; %s\n&quot;, userstr, realm, keyExtras);
         else
             snprintf(buf, 8192, &quot;\&quot;%s\&quot;:\&quot;%s\&quot;\n&quot;, userstr, realm);
     } else {
         if (keyExtras)
             snprintf(buf, 8192, &quot;\&quot;%s\&quot;:\&quot;%s\&quot; %s\n&quot;, user()-&gt;username(), realm, keyExtras);
         else
             snprintf(buf, 8192, &quot;\&quot;%s\&quot;:\&quot;%s\&quot;\n&quot;, user()-&gt;username(), realm);
     }
 
     helperSubmit(digestauthenticators, buf, Auth::Digest::UserRequest::HandleReply,
                  new Auth::StateData(this, handler, data));
 }
 
 void
 Auth::Digest::UserRequest::HandleReply(void *data, const Helper::Reply &amp;reply)
 {

=== added file 'src/auth/forward.h'
--- src/auth/forward.h	1970-01-01 00:00:00 +0000
+++ src/auth/forward.h	2016-12-19 13:27:53 +0000
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_AUTH_FORWARD_H
+#define SQUID_SRC_AUTH_FORWARD_H
+
+#if USE_AUTH
+
+#include &lt;vector&gt;
+
+/// HTTP Authentication
+namespace Auth
+{
+
+class CredentialsCache;
+
+class Scheme;
+class SchemeConfig;
+typedef std::vector&lt;Auth::SchemeConfig *&gt; ConfigVector;
+
+} // namespace Auth
+
+#endif /* USE_AUTH */
+#endif /* SQUID_SRC_AUTH_FORWARD_H */
+

=== modified file 'src/auth/negotiate/Config.cc'
--- src/auth/negotiate/Config.cc	2016-01-24 17:41:43 +0000
+++ src/auth/negotiate/Config.cc	2016-12-20 11:17:35 +0000
@@ -14,132 +14,94 @@
 
 #include &quot;squid.h&quot;
 #include &quot;auth/Gadgets.h&quot;
 #include &quot;auth/negotiate/Config.h&quot;
 #include &quot;auth/negotiate/Scheme.h&quot;
 #include &quot;auth/negotiate/User.h&quot;
 #include &quot;auth/negotiate/UserRequest.h&quot;
 #include &quot;auth/State.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;helper.h&quot;
 #include &quot;http/Stream.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;mgr/Registration.h&quot;
 #include &quot;SquidTime.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;wordlist.h&quot;
 
-/**
- \defgroup AuthNegotiateInternal Negotiate Authenticator Internals
- \ingroup AuthNegotiateAPI
- */
-
-/* Negotiate Scheme */
 static AUTHSSTATS authenticateNegotiateStats;
 
-/// \ingroup AuthNegotiateInternal
 statefulhelper *negotiateauthenticators = NULL;
 
-/// \ingroup AuthNegotiateInternal
 static int authnegotiate_initialised = 0;
 
-/// \ingroup AuthNegotiateInternal
 static hash_table *proxy_auth_cache = NULL;
 
 void
 Auth::Negotiate::Config::rotateHelpers()
 {
     /* schedule closure of existing helpers */
     if (negotiateauthenticators) {
         helperStatefulShutdown(negotiateauthenticators);
     }
 
     /* NP: dynamic helper restart will ensure they start up again as needed. */
 }
 
 void
 Auth::Negotiate::Config::done()
 {
-    Auth::Config::done();
+    Auth::SchemeConfig::done();
 
     authnegotiate_initialised = 0;
 
     if (negotiateauthenticators) {
         helperStatefulShutdown(negotiateauthenticators);
     }
 
     if (!shutting_down)
         return;
 
     delete negotiateauthenticators;
     negotiateauthenticators = NULL;
 
     if (authenticateProgram)
         wordlistDestroy(&amp;authenticateProgram);
 
     debugs(29, DBG_IMPORTANT, &quot;Reconfigure: Negotiate authentication configuration cleared.&quot;);
 }
 
-bool
-Auth::Negotiate::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme) const
-{
-    if (!Auth::Config::dump(entry, name, scheme))
-        return false;
-
-    storeAppendPrintf(entry, &quot;%s negotiate keep_alive %s\n&quot;, name, keep_alive ? &quot;on&quot; : &quot;off&quot;);
-    return true;
-}
-
-Auth::Negotiate::Config::Config() : keep_alive(1)
-{ }
-
-void
-Auth::Negotiate::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
-{
-    if (strcmp(param_str, &quot;program&quot;) == 0) {
-        if (authenticateProgram)
-            wordlistDestroy(&amp;authenticateProgram);
-
-        parse_wordlist(&amp;authenticateProgram);
-
-        requirePathnameExists(&quot;auth_param negotiate program&quot;, authenticateProgram-&gt;key);
-    } else if (strcmp(param_str, &quot;keep_alive&quot;) == 0) {
-        parse_onoff(&amp;keep_alive);
-    } else
-        Auth::Config::parse(scheme, n_configured, param_str);
-}
-
 const char *
 Auth::Negotiate::Config::type() const
 {
     return Auth::Negotiate::Scheme::GetInstance()-&gt;type();
 }
 
 /**
  * Initialize helpers and the like for this auth scheme.
  * Called AFTER parsing the config file
  */
 void
-Auth::Negotiate::Config::init(Auth::Config *)
+Auth::Negotiate::Config::init(Auth::SchemeConfig *)
 {
     if (authenticateProgram) {
 
         authnegotiate_initialised = 1;
 
         if (negotiateauthenticators == NULL)
             negotiateauthenticators = new statefulhelper(&quot;negotiateauthenticator&quot;);
 
         if (!proxy_auth_cache)
             proxy_auth_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
 
         assert(proxy_auth_cache);
 
         negotiateauthenticators-&gt;cmdline = authenticateProgram;
 
         negotiateauthenticators-&gt;childs.updateLimits(authenticateChildren);
 
         negotiateauthenticators-&gt;ipc_type = IPC_STREAM;
 
         helperStatefulOpenServers(negotiateauthenticators);
@@ -155,42 +117,40 @@
 }
 
 bool
 Auth::Negotiate::Config::active() const
 {
     return authnegotiate_initialised == 1;
 }
 
 bool
 Auth::Negotiate::Config::configured() const
 {
     if (authenticateProgram &amp;&amp; (authenticateChildren.n_max != 0)) {
         debugs(29, 9, HERE &lt;&lt; &quot;returning configured&quot;);
         return true;
     }
 
     debugs(29, 9, HERE &lt;&lt; &quot;returning unconfigured&quot;);
     return false;
 }
 
-/* Negotiate Scheme */
-
 void
 Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType reqType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;
 
     /* Need keep-alive */
     if (!request-&gt;flags.proxyKeepalive &amp;&amp; request-&gt;flags.mustKeepalive)
         return;
 
     /* New request, no user details */
     if (auth_user_request == NULL) {
         debugs(29, 9, HERE &lt;&lt; &quot;Sending type:&quot; &lt;&lt; reqType &lt;&lt; &quot; header: 'Negotiate'&quot;);
         httpHeaderPutStrf(&amp;rep-&gt;header, reqType, &quot;Negotiate&quot;);
 
         if (!keep_alive) {
             /* drop the connection */
             rep-&gt;header.delByName(&quot;keep-alive&quot;);
             request-&gt;flags.proxyKeepalive = false;
         }
@@ -239,34 +199,34 @@
             debugs(29, DBG_CRITICAL, &quot;ERROR: Negotiate auth fixHeader: state &quot; &lt;&lt; negotiate_request-&gt;user()-&gt;credentials() &lt;&lt; &quot;.&quot;);
             fatal(&quot;unexpected state in AuthenticateNegotiateFixErrorHeader.\n&quot;);
         }
     }
 }
 
 static void
 authenticateNegotiateStats(StoreEntry * sentry)
 {
     if (negotiateauthenticators)
         negotiateauthenticators-&gt;packStatsInto(sentry, &quot;Negotiate Authenticator Statistics&quot;);
 }
 
 /*
  * Decode a Negotiate [Proxy-]Auth string, placing the results in the passed
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
 Auth::Negotiate::Config::decode(char const *proxy_auth, const char *aRequestRealm)
 {
-    Auth::Negotiate::User *newUser = new Auth::Negotiate::User(Auth::Config::Find(&quot;negotiate&quot;), aRequestRealm);
+    Auth::Negotiate::User *newUser = new Auth::Negotiate::User(Auth::SchemeConfig::Find(&quot;negotiate&quot;), aRequestRealm);
     Auth::UserRequest *auth_user_request = new Auth::Negotiate::UserRequest();
     assert(auth_user_request-&gt;user() == NULL);
 
     auth_user_request-&gt;user(newUser);
     auth_user_request-&gt;user()-&gt;auth_type = Auth::AUTH_NEGOTIATE;
 
     auth_user_request-&gt;user()-&gt;BuildUserKey(proxy_auth, aRequestRealm);
 
     /* all we have to do is identify that it's Negotiate - the helper does the rest */
     debugs(29, 9, HERE &lt;&lt; &quot;decode Negotiate authentication&quot;);
     return auth_user_request;
 }
 

=== modified file 'src/auth/negotiate/Config.h'
--- src/auth/negotiate/Config.h	2016-01-01 00:12:18 +0000
+++ src/auth/negotiate/Config.h	2016-12-20 11:16:46 +0000
@@ -1,52 +1,46 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef __AUTH_NEGOTIATE_H__
 #define __AUTH_NEGOTIATE_H__
 
 #if HAVE_AUTH_MODULE_NEGOTIATE
 
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/Gadgets.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;helper/forward.h&quot;
 
 namespace Auth
 {
 namespace Negotiate
 {
 
 /** Negotiate Authentication configuration data */
-class Config : public Auth::Config
+class Config : public Auth::SchemeConfig
 {
 public:
-    Config();
     virtual bool active() const;
     virtual bool configured() const;
     virtual Auth::UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm);
     virtual void done();
     virtual void rotateHelpers();
-    virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
     virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
-    virtual void init(Auth::Config *);
-    virtual void parse(Auth::Config *, int, char *);
+    virtual void init(Auth::SchemeConfig *);
     virtual void registerWithCacheManager(void);
     virtual const char * type() const;
-
-public:
-    int keep_alive;
 };
 
 } // namespace Negotiate
 } // namespace Auth
 
 extern statefulhelper *negotiateauthenticators;
 
 #endif /* HAVE_AUTH_MODULE_NEGOTIATE */
 #endif
 

=== modified file 'src/auth/negotiate/Scheme.cc'
--- src/auth/negotiate/Scheme.cc	2016-01-01 00:12:18 +0000
+++ src/auth/negotiate/Scheme.cc	2016-12-19 13:28:02 +0000
@@ -23,27 +23,27 @@
     }
     return _instance;
 }
 
 char const *
 Auth::Negotiate::Scheme::type() const
 {
     return &quot;negotiate&quot;;
 }
 
 void
 Auth::Negotiate::Scheme::shutdownCleanup()
 {
     if (_instance == NULL)
         return;
 
     _instance = NULL;
     debugs(29, DBG_CRITICAL, &quot;Shutdown: Negotiate authentication.&quot;);
 }
 
-Auth::Config *
+Auth::SchemeConfig *
 Auth::Negotiate::Scheme::createConfig()
 {
     Auth::Negotiate::Config *negotiateCfg = new Auth::Negotiate::Config;
-    return dynamic_cast&lt;Auth::Config*&gt;(negotiateCfg);
+    return dynamic_cast&lt;Auth::SchemeConfig*&gt;(negotiateCfg);
 }
 

=== modified file 'src/auth/negotiate/Scheme.h'
--- src/auth/negotiate/Scheme.h	2016-01-01 00:12:18 +0000
+++ src/auth/negotiate/Scheme.h	2016-12-19 13:28:04 +0000
@@ -1,49 +1,48 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_NEGOTIATE_SCHEME_H
 #define SQUID_AUTH_NEGOTIATE_SCHEME_H
 
 #if HAVE_AUTH_MODULE_NEGOTIATE
 
 #include &quot;auth/Scheme.h&quot;
 
 namespace Auth
 {
 namespace Negotiate
 {
 
-/// \ingroup AuthSchemeAPI
 /// \ingroup AuthAPI
 class Scheme : public Auth::Scheme
 {
 
 public:
     static Auth::Scheme::Pointer GetInstance();
     Scheme() {};
     virtual ~Scheme() {};
 
     /* per scheme */
     virtual char const *type() const;
     virtual void shutdownCleanup();
-    virtual Auth::Config *createConfig();
+    virtual Auth::SchemeConfig *createConfig();
 
     /* Not implemented */
     Scheme (Scheme const &amp;);
     Scheme &amp;operator=(Scheme const &amp;);
 
 private:
     static Auth::Scheme::Pointer _instance;
 };
 
 } // namespace Negotiate
 } // namespace Auth
 
 #endif /* HAVE_AUTH_MODULE_NEGOTIATE */
 #endif /* SQUID_AUTH_NEGOTIATE_SCHEME_H */
 

=== modified file 'src/auth/negotiate/User.cc'
--- src/auth/negotiate/User.cc	2016-01-01 00:12:18 +0000
+++ src/auth/negotiate/User.cc	2016-12-19 13:28:05 +0000
@@ -1,35 +1,35 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/CredentialsCache.h&quot;
 #include &quot;auth/negotiate/User.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;Debug.h&quot;
 
-Auth::Negotiate::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
+Auth::Negotiate::User::User(Auth::SchemeConfig *aConfig, const char *aRequestRealm) :
     Auth::User(aConfig, aRequestRealm)
 {
 }
 
 Auth::Negotiate::User::~User()
 {
     debugs(29, 5, HERE &lt;&lt; &quot;doing nothing to clear Negotiate scheme data for '&quot; &lt;&lt; this &lt;&lt; &quot;'&quot;);
 }
 
 int32_t
 Auth::Negotiate::User::ttl() const
 {
     return -1; // Negotiate cannot be cached.
 }
 
 CbcPointer&lt;Auth::CredentialsCache&gt;
 Auth::Negotiate::User::Cache()
 {
     static CbcPointer&lt;Auth::CredentialsCache&gt; p(new Auth::CredentialsCache(&quot;negotiate&quot;, &quot;GC Negotiate user credentials&quot;));
     return p;

=== modified file 'src/auth/negotiate/User.h'
--- src/auth/negotiate/User.h	2016-01-01 00:12:18 +0000
+++ src/auth/negotiate/User.h	2016-12-19 13:28:06 +0000
@@ -1,46 +1,46 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_AUTH_NEGOTIATE_USER_H
 #define _SQUID_AUTH_NEGOTIATE_USER_H
 
 #if HAVE_AUTH_MODULE_NEGOTIATE
 
 #include &quot;auth/User.h&quot;
 
 namespace Auth
 {
 
-class Config;
+class SchemeConfig;
 
 namespace Negotiate
 {
 
 /** User credentials for the Negotiate authentication protocol */
 class User : public Auth::User
 {
     MEMPROXY_CLASS(Auth::Negotiate::User);
 
 public:
-    User(Auth::Config *, const char *requestRealm);
+    User(Auth::SchemeConfig *, const char *requestRealm);
     virtual ~User();
     virtual int32_t ttl() const override;
 
     /* Auth::User API */
     static CbcPointer&lt;Auth::CredentialsCache&gt; Cache();
     virtual void addToNameCache() override;
 
     dlink_list proxy_auth_list;
 };
 
 } // namespace Negotiate
 } // namespace Auth
 
 #endif /* HAVE_AUTH_MODULE_NEGOTIATE */
 #endif /* _SQUID_AUTH_NEGOTIATE_USER_H */
 

=== modified file 'src/auth/negotiate/UserRequest.cc'
--- src/auth/negotiate/UserRequest.cc	2016-01-24 17:41:43 +0000
+++ src/auth/negotiate/UserRequest.cc	2016-12-19 13:28:07 +0000
@@ -111,41 +111,41 @@
     case Auth::Failed:
         return Auth::CRED_ERROR; // XXX: really? not VALID or CHALLENGE?
 
     default:
         debugs(29, DBG_IMPORTANT, &quot;WARNING: Negotiate Authentication in unexpected state: &quot; &lt;&lt; user()-&gt;credentials());
         return Auth::CRED_ERROR;
     }
 }
 
 void
 Auth::Negotiate::UserRequest::startHelperLookup(HttpRequest *, AccessLogEntry::Pointer &amp;al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
     assert(data);
     assert(handler);
 
     assert(user() != NULL);
     assert(user()-&gt;auth_type == Auth::AUTH_NEGOTIATE);
 
-    if (static_cast&lt;Auth::Negotiate::Config*&gt;(Auth::Config::Find(&quot;negotiate&quot;))-&gt;authenticateProgram == NULL) {
+    if (static_cast&lt;Auth::Negotiate::Config*&gt;(Auth::SchemeConfig::Find(&quot;negotiate&quot;))-&gt;authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, &quot;ERROR: No Negotiate authentication program configured.&quot;);
         handler(data);
         return;
     }
 
     debugs(29, 8, HERE &lt;&lt; &quot;credentials state is '&quot; &lt;&lt; user()-&gt;credentials() &lt;&lt; &quot;'&quot;);
 
     const char *keyExtras = helperRequestKeyExtras(request, al);
     int printResult = 0;
     if (user()-&gt;credentials() == Auth::Pending) {
         if (keyExtras)
             printResult = snprintf(buf, sizeof(buf), &quot;YR %s %s\n&quot;, client_blob, keyExtras);
         else
             printResult = snprintf(buf, sizeof(buf), &quot;YR %s\n&quot;, client_blob); //CHECKME: can ever client_blob be 0 here?
     } else {
         if (keyExtras)
             printResult = snprintf(buf, sizeof(buf), &quot;KK %s %s\n&quot;, client_blob, keyExtras);
         else
             printResult = snprintf(buf, sizeof(buf), &quot;KK %s\n&quot;, client_blob);
     }

=== modified file 'src/auth/negotiate/UserRequest.h'
--- src/auth/negotiate/UserRequest.h	2016-01-01 00:12:18 +0000
+++ src/auth/negotiate/UserRequest.h	2016-12-19 13:28:08 +0000
@@ -6,41 +6,40 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_SRC_AUTH_NEGOTIATE_USERREQUEST_H
 #define _SQUID_SRC_AUTH_NEGOTIATE_USERREQUEST_H
 
 #if HAVE_AUTH_MODULE_NEGOTIATE
 
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;helper/forward.h&quot;
 
 class ConnStateData;
 class HttpReply;
 class HttpRequest;
 
 namespace Auth
 {
 namespace Negotiate
 {
 
-/// \ingroup AuthNegotiateAPI
 class UserRequest : public Auth::UserRequest
 {
     MEMPROXY_CLASS(Auth::Negotiate::UserRequest);
 
 public:
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &amp;al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     virtual const char * connLastHeader();
 
     /* we need to store the helper server between requests */
     helper_stateful_server *authserver;
     void releaseAuthServer(void); ///&lt; Release the authserver helper server properly.
 
     /* what connection is this associated with */

=== modified file 'src/auth/ntlm/Config.cc'
--- src/auth/ntlm/Config.cc	2016-01-24 17:41:43 +0000
+++ src/auth/ntlm/Config.cc	2016-12-20 11:18:30 +0000
@@ -37,99 +37,70 @@
 statefulhelper *ntlmauthenticators = NULL;
 static int authntlm_initialised = 0;
 
 static hash_table *proxy_auth_cache = NULL;
 
 void
 Auth::Ntlm::Config::rotateHelpers()
 {
     /* schedule closure of existing helpers */
     if (ntlmauthenticators) {
         helperStatefulShutdown(ntlmauthenticators);
     }
 
     /* NP: dynamic helper restart will ensure they start up again as needed. */
 }
 
 /* free any allocated configuration details */
 void
 Auth::Ntlm::Config::done()
 {
-    Auth::Config::done();
+    Auth::SchemeConfig::done();
 
     authntlm_initialised = 0;
 
     if (ntlmauthenticators) {
         helperStatefulShutdown(ntlmauthenticators);
     }
 
     if (!shutting_down)
         return;
 
     delete ntlmauthenticators;
     ntlmauthenticators = NULL;
 
     if (authenticateProgram)
         wordlistDestroy(&amp;authenticateProgram);
 
     debugs(29, DBG_IMPORTANT, &quot;Reconfigure: NTLM authentication configuration cleared.&quot;);
 }
 
-bool
-Auth::Ntlm::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme) const
-{
-    if (!Auth::Config::dump(entry, name, scheme))
-        return false;
-
-    storeAppendPrintf(entry, &quot;%s ntlm keep_alive %s\n&quot;, name, keep_alive ? &quot;on&quot; : &quot;off&quot;);
-    return true;
-}
-
-Auth::Ntlm::Config::Config() : keep_alive(1)
-{ }
-
-void
-Auth::Ntlm::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
-{
-    if (strcmp(param_str, &quot;program&quot;) == 0) {
-        if (authenticateProgram)
-            wordlistDestroy(&amp;authenticateProgram);
-
-        parse_wordlist(&amp;authenticateProgram);
-
-        requirePathnameExists(&quot;auth_param ntlm program&quot;, authenticateProgram-&gt;key);
-    } else if (strcmp(param_str, &quot;keep_alive&quot;) == 0) {
-        parse_onoff(&amp;keep_alive);
-    } else
-        Auth::Config::parse(scheme, n_configured, param_str);
-}
-
 const char *
 Auth::Ntlm::Config::type() const
 {
     return Auth::Ntlm::Scheme::GetInstance()-&gt;type();
 }
 
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
 void
-Auth::Ntlm::Config::init(Auth::Config *)
+Auth::Ntlm::Config::init(Auth::SchemeConfig *)
 {
     if (authenticateProgram) {
 
         authntlm_initialised = 1;
 
         if (ntlmauthenticators == NULL)
             ntlmauthenticators = new statefulhelper(&quot;ntlmauthenticator&quot;);
 
         if (!proxy_auth_cache)
             proxy_auth_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
 
         assert(proxy_auth_cache);
 
         ntlmauthenticators-&gt;cmdline = authenticateProgram;
 
         ntlmauthenticators-&gt;childs.updateLimits(authenticateChildren);
 
         ntlmauthenticators-&gt;ipc_type = IPC_STREAM;
 
         helperStatefulOpenServers(ntlmauthenticators);
@@ -219,34 +190,34 @@
             debugs(29, DBG_CRITICAL, &quot;NTLM Auth fixHeader: state &quot; &lt;&lt; ntlm_request-&gt;user()-&gt;credentials() &lt;&lt; &quot;.&quot;);
             fatal(&quot;unexpected state in AuthenticateNTLMFixErrorHeader.\n&quot;);
         }
     }
 }
 
 static void
 authenticateNTLMStats(StoreEntry * sentry)
 {
     if (ntlmauthenticators)
         ntlmauthenticators-&gt;packStatsInto(sentry, &quot;NTLM Authenticator Statistics&quot;);
 }
 
 /*
  * Decode a NTLM [Proxy-]Auth string, placing the results in the passed
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
 Auth::Ntlm::Config::decode(char const *proxy_auth, const char *aRequestRealm)
 {
-    Auth::Ntlm::User *newUser = new Auth::Ntlm::User(Auth::Config::Find(&quot;ntlm&quot;), aRequestRealm);
+    Auth::Ntlm::User *newUser = new Auth::Ntlm::User(Auth::SchemeConfig::Find(&quot;ntlm&quot;), aRequestRealm);
     Auth::UserRequest::Pointer auth_user_request = new Auth::Ntlm::UserRequest();
     assert(auth_user_request-&gt;user() == NULL);
 
     auth_user_request-&gt;user(newUser);
     auth_user_request-&gt;user()-&gt;auth_type = Auth::AUTH_NTLM;
 
     auth_user_request-&gt;user()-&gt;BuildUserKey(proxy_auth, aRequestRealm);
 
     /* all we have to do is identify that it's NTLM - the helper does the rest */
     debugs(29, 9, HERE &lt;&lt; &quot;decode: NTLM authentication&quot;);
     return auth_user_request;
 }
 

=== modified file 'src/auth/ntlm/Config.h'
--- src/auth/ntlm/Config.h	2016-01-01 00:12:18 +0000
+++ src/auth/ntlm/Config.h	2016-12-20 11:17:01 +0000
@@ -1,55 +1,49 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef __AUTH_NTLM_H__
 #define __AUTH_NTLM_H__
 
 #if HAVE_AUTH_MODULE_NTLM
 
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/Gadgets.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;helper/forward.h&quot;
 
 class HttpRequest;
 class StoreEntry;
 
 namespace Auth
 {
 namespace Ntlm
 {
 
 /** NTLM Authentication configuration data */
-class Config : public Auth::Config
+class Config : public Auth::SchemeConfig
 {
 public:
-    Config();
     virtual bool active() const;
     virtual bool configured() const;
     virtual Auth::UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm);
     virtual void done();
     virtual void rotateHelpers();
-    virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
     virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
-    virtual void init(Auth::Config *);
-    virtual void parse(Auth::Config *, int, char *);
+    virtual void init(Auth::SchemeConfig *);
     virtual void registerWithCacheManager(void);
     virtual const char * type() const;
-
-public:
-    int keep_alive;
 };
 
 } // namespace Ntlm
 } // namespace Auth
 
 extern statefulhelper *ntlmauthenticators;
 
 #endif /* HAVE_AUTH_MODULE_NTLM */
 #endif
 

=== modified file 'src/auth/ntlm/Scheme.cc'
--- src/auth/ntlm/Scheme.cc	2016-01-01 00:12:18 +0000
+++ src/auth/ntlm/Scheme.cc	2016-12-19 13:28:29 +0000
@@ -23,27 +23,27 @@
     }
     return _instance;
 }
 
 char const *
 Auth::Ntlm::Scheme::type() const
 {
     return &quot;ntlm&quot;;
 }
 
 void
 Auth::Ntlm::Scheme::shutdownCleanup()
 {
     if (_instance == NULL)
         return;
 
     _instance = NULL;
     debugs(29, DBG_CRITICAL, &quot;Shutdown: NTLM authentication.&quot;);
 }
 
-Auth::Config *
+Auth::SchemeConfig *
 Auth::Ntlm::Scheme::createConfig()
 {
     Auth::Ntlm::Config *ntlmCfg = new Auth::Ntlm::Config;
-    return dynamic_cast&lt;Auth::Config*&gt;(ntlmCfg);
+    return dynamic_cast&lt;Auth::SchemeConfig*&gt;(ntlmCfg);
 }
 

=== modified file 'src/auth/ntlm/Scheme.h'
--- src/auth/ntlm/Scheme.h	2016-01-01 00:12:18 +0000
+++ src/auth/ntlm/Scheme.h	2016-12-19 13:28:30 +0000
@@ -1,53 +1,52 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_NTLM_SCHEME_H
 #define SQUID_AUTH_NTLM_SCHEME_H
 
 #if HAVE_AUTH_MODULE_NTLM
 
 #include &quot;auth/Scheme.h&quot;
 
 namespace Auth
 {
 namespace Ntlm
 {
 
-/// \ingroup AuthSchemeAPI
 /// \ingroup AuthAPI
 class Scheme : public Auth::Scheme
 {
 
 public:
     static Auth::Scheme::Pointer GetInstance();
     Scheme() {};
     virtual ~Scheme() {};
 
     /* per scheme */
     virtual char const *type() const;
     virtual void shutdownCleanup();
-    virtual Auth::Config *createConfig();
+    virtual Auth::SchemeConfig *createConfig();
 
     /* Not implemented */
     Scheme (Scheme const &amp;);
     Scheme &amp;operator=(Scheme const &amp;);
 
 private:
     /**
      * Main instance of this authentication Scheme.
      * NULL when the scheme is not being used.
      */
     static Auth::Scheme::Pointer _instance;
 };
 
 } // namespace Ntlm
 } // namespace Auth
 
 #endif /* HAVE_AUTH_MODULE_NTLM */
 #endif /* SQUID_AUTH_NTLM_SCHEME_H */
 

=== modified file 'src/auth/ntlm/User.cc'
--- src/auth/ntlm/User.cc	2016-01-01 00:12:18 +0000
+++ src/auth/ntlm/User.cc	2016-12-19 13:28:31 +0000
@@ -1,35 +1,35 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
-#include &quot;auth/Config.h&quot;
 #include &quot;auth/CredentialsCache.h&quot;
 #include &quot;auth/ntlm/User.h&quot;
+#include &quot;auth/SchemeConfig.h&quot;
 #include &quot;Debug.h&quot;
 
-Auth::Ntlm::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
+Auth::Ntlm::User::User(Auth::SchemeConfig *aConfig, const char *aRequestRealm) :
     Auth::User(aConfig, aRequestRealm)
 {
 }
 
 Auth::Ntlm::User::~User()
 {
     debugs(29, 5, HERE &lt;&lt; &quot;doing nothing to clear NTLM scheme data for '&quot; &lt;&lt; this &lt;&lt; &quot;'&quot;);
 }
 
 int32_t
 Auth::Ntlm::User::ttl() const
 {
     return -1; // NTLM credentials cannot be cached.
 }
 
 CbcPointer&lt;Auth::CredentialsCache&gt;
 Auth::Ntlm::User::Cache()
 {
     static CbcPointer&lt;Auth::CredentialsCache&gt; p(new Auth::CredentialsCache(&quot;ntlm&quot;, &quot;GC NTLM user credentials&quot;));
     return p;

=== modified file 'src/auth/ntlm/User.h'
--- src/auth/ntlm/User.h	2016-01-01 00:12:18 +0000
+++ src/auth/ntlm/User.h	2016-12-19 13:28:32 +0000
@@ -1,46 +1,44 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_AUTH_NTLM_USER_H
 #define _SQUID_AUTH_NTLM_USER_H
 
 #if HAVE_AUTH_MODULE_NTLM
 
 #include &quot;auth/User.h&quot;
 
 namespace Auth
 {
 
-class Config;
-
 namespace Ntlm
 {
 
 /** User credentials for the NTLM authentication protocol */
 class User : public Auth::User
 {
     MEMPROXY_CLASS(Auth::Ntlm::User);
 
 public:
-    User(Auth::Config *, const char *requestRealm);
+    User(Auth::SchemeConfig *, const char *requestRealm);
     virtual ~User();
     virtual int32_t ttl() const override;
 
     /* Auth::User API */
     static CbcPointer&lt;Auth::CredentialsCache&gt; Cache();
     virtual void addToNameCache() override;
 
     dlink_list proxy_auth_list;
 };
 
 } // namespace Ntlm
 } // namespace Auth
 
 #endif /* HAVE_AUTH_MODULE_NTLM */
 #endif /* _SQUID_AUTH_NTLM_USER_H */
 

=== modified file 'src/auth/ntlm/UserRequest.cc'
--- src/auth/ntlm/UserRequest.cc	2016-01-24 17:41:43 +0000
+++ src/auth/ntlm/UserRequest.cc	2016-12-19 13:28:33 +0000
@@ -107,41 +107,41 @@
     case Auth::Ok:
         return Auth::CRED_VALID;
 
     case Auth::Failed:
         return Auth::CRED_ERROR; // XXX: really? not VALID or CHALLENGE?
 
     default:
         debugs(29, DBG_IMPORTANT, &quot;WARNING: NTLM Authentication in unexpected state: &quot; &lt;&lt; user()-&gt;credentials());
         return Auth::CRED_ERROR;
     }
 }
 
 void
 Auth::Ntlm::UserRequest::startHelperLookup(HttpRequest *, AccessLogEntry::Pointer &amp;al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
     assert(data);
     assert(handler);
 
-    if (static_cast&lt;Auth::Ntlm::Config*&gt;(Auth::Config::Find(&quot;ntlm&quot;))-&gt;authenticateProgram == NULL) {
+    if (static_cast&lt;Auth::Ntlm::Config*&gt;(Auth::SchemeConfig::Find(&quot;ntlm&quot;))-&gt;authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, &quot;ERROR: NTLM Start: no NTLM program configured.&quot;);
         handler(data);
         return;
     }
 
     debugs(29, 8, HERE &lt;&lt; &quot;credentials state is '&quot; &lt;&lt; user()-&gt;credentials() &lt;&lt; &quot;'&quot;);
 
     const char *keyExtras = helperRequestKeyExtras(request, al);
     int printResult = 0;
     if (user()-&gt;credentials() == Auth::Pending) {
         if (keyExtras)
             printResult = snprintf(buf, sizeof(buf), &quot;YR %s %s\n&quot;, client_blob, keyExtras);
         else
             printResult = snprintf(buf, sizeof(buf), &quot;YR %s\n&quot;, client_blob); //CHECKME: can ever client_blob be 0 here?
     } else {
         if (keyExtras)
             printResult = snprintf(buf, sizeof(buf), &quot;KK %s %s\n&quot;, client_blob, keyExtras);
         else
             printResult = snprintf(buf, sizeof(buf), &quot;KK %s\n&quot;, client_blob);
     }

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2016-12-10 16:27:09 +0000
+++ src/cache_cf.cc	2016-12-19 13:29:15 +0000
@@ -1,40 +1,42 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 03    Configuration File Parsing */
 
 #include &quot;squid.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/AclDenyInfoList.h&quot;
 #include &quot;acl/AclSizeLimit.h&quot;
 #include &quot;acl/Address.h&quot;
 #include &quot;acl/Gadgets.h&quot;
 #include &quot;acl/MethodData.h&quot;
 #include &quot;acl/Tree.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;anyp/UriScheme.h&quot;
+#include &quot;auth/Config.h&quot;
+#include &quot;auth/Scheme.h&quot;
 #include &quot;AuthReg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;CachePeer.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;CpuAffinityMap.h&quot;
 #include &quot;DiskIO/DiskIOModule.h&quot;
 #include &quot;eui/Config.h&quot;
 #include &quot;ExternalACL.h&quot;
 #include &quot;format/Format.h&quot;
 #include &quot;ftp/Elements.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
 #include &quot;icmp/IcmpConfig.h&quot;
 #include &quot;ident/Config.h&quot;
 #include &quot;ip/Intercept.h&quot;
 #include &quot;ip/QosConfig.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;ipc/Kids.h&quot;
 #include &quot;log/Config.h&quot;
@@ -60,45 +62,40 @@
 #include &quot;store/Disks.h&quot;
 #include &quot;StoreFileSystem.h&quot;
 #include &quot;tools.h&quot;
 #include &quot;util.h&quot;
 #include &quot;wordlist.h&quot;
 /* wccp2 has its own conditional definitions */
 #include &quot;wccp2.h&quot;
 #if USE_ADAPTATION
 #include &quot;adaptation/Config.h&quot;
 #endif
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/Config.h&quot;
 #endif
 #if USE_ECAP
 #include &quot;adaptation/ecap/Config.h&quot;
 #endif
 #if USE_OPENSSL
 #include &quot;ssl/Config.h&quot;
 #include &quot;ssl/support.h&quot;
 #endif
-#if USE_AUTH
-#include &quot;auth/Config.h&quot;
-#include &quot;auth/Scheme.h&quot;
-#include &quot;auth/SchemesConfig.h&quot;
-#endif
 #if USE_SQUID_ESI
 #include &quot;esi/Parser.h&quot;
 #endif
 #if SQUID_SNMP
 #include &quot;snmp.h&quot;
 #endif
 
 #if HAVE_GLOB_H
 #include &lt;glob.h&gt;
 #endif
 #include &lt;limits&gt;
 #include &lt;list&gt;
 #if HAVE_PWD_H
 #include &lt;pwd.h&gt;
 #endif
 #if HAVE_GRP_H
 #include &lt;grp.h&gt;
 #endif
 #if HAVE_SYS_STAT_H
 #include &lt;sys/stat.h&gt;
@@ -921,49 +918,49 @@
 
     /*
      * Disable client side request pipelining if client_persistent_connections OFF.
      * Waste of resources queueing any pipelined requests when the first will close the connection.
      */
     if (Config.pipeline_max_prefetch &gt; 0 &amp;&amp; !Config.onoff.client_pconns) {
         debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: pipeline_prefetch &quot; &lt;&lt; Config.pipeline_max_prefetch &lt;&lt;
                &quot; requires client_persistent_connections ON. Forced pipeline_prefetch 0.&quot;);
         Config.pipeline_max_prefetch = 0;
     }
 
 #if USE_AUTH
     /*
      * disable client side request pipelining. There is a race with
      * Negotiate and NTLM when the client sends a second request on an
      * connection before the authenticate challenge is sent. With
      * pipelining OFF, the client may fail to authenticate, but squid's
      * state will be preserved.
      */
     if (Config.pipeline_max_prefetch &gt; 0) {
-        Auth::Config *nego = Auth::Config::Find(&quot;Negotiate&quot;);
-        Auth::Config *ntlm = Auth::Config::Find(&quot;NTLM&quot;);
+        Auth::SchemeConfig *nego = Auth::SchemeConfig::Find(&quot;Negotiate&quot;);
+        Auth::SchemeConfig *ntlm = Auth::SchemeConfig::Find(&quot;NTLM&quot;);
         if ((nego &amp;&amp; nego-&gt;active()) || (ntlm &amp;&amp; ntlm-&gt;active())) {
             debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), &quot;WARNING: pipeline_prefetch breaks NTLM and Negotiate authentication. Forced pipeline_prefetch 0.&quot;);
             Config.pipeline_max_prefetch = 0;
         }
     }
 
-    for (auto &amp;authSchemes: Config.authSchemesConfigs) {
+    for (auto &amp;authSchemes : Auth::TheConfig.schemeLists) {
         authSchemes.expand();
         if (authSchemes.authConfigs.empty()) {
             debugs(3, DBG_CRITICAL, &quot;auth_schemes: at least one scheme name is required; got: &quot; &lt;&lt; authSchemes.rawSchemes);
             self_destruct();
         }
     }
 #endif
 }
 
 /** Parse a line containing an obsolete directive.
  * To upgrade it where possible instead of just &quot;Bungled config&quot; for
  * directives which cannot be marked as simply aliases of the some name.
  * For example if the parameter order and content has changed.
  * Or if the directive has been completely removed.
  */
 void
 parse_obsolete(const char *name)
 {
     // Directives which have been radically changed rather than removed
     if (!strcmp(name, &quot;url_rewrite_concurrency&quot;)) {
@@ -1775,110 +1772,110 @@
     return s == NULL;
 }
 
 #if USE_AUTH
 static void
 parse_authparam(Auth::ConfigVector * config)
 {
     char *type_str = ConfigParser::NextToken();
     if (!type_str) {
         self_destruct();
         return;
     }
 
     char *param_str = ConfigParser::NextToken();
     if (!param_str) {
         self_destruct();
         return;
     }
 
     /* find a configuration for the scheme in the currently parsed configs... */
-    Auth::Config *schemeCfg = Auth::Config::Find(type_str);
+    Auth::SchemeConfig *schemeCfg = Auth::SchemeConfig::Find(type_str);
 
     if (schemeCfg == NULL) {
         /* Create a configuration based on the scheme info */
         Auth::Scheme::Pointer theScheme = Auth::Scheme::Find(type_str);
 
         if (theScheme == NULL) {
             debugs(3, DBG_CRITICAL, &quot;Parsing Config File: Unknown authentication scheme '&quot; &lt;&lt; type_str &lt;&lt; &quot;'.&quot;);
             self_destruct();
             return;
         }
 
         config-&gt;push_back(theScheme-&gt;createConfig());
-        schemeCfg = Auth::Config::Find(type_str);
+        schemeCfg = Auth::SchemeConfig::Find(type_str);
         if (schemeCfg == NULL) {
             debugs(3, DBG_CRITICAL, &quot;Parsing Config File: Corruption configuring authentication scheme '&quot; &lt;&lt; type_str &lt;&lt; &quot;'.&quot;);
             self_destruct();
             return;
         }
     }
 
     schemeCfg-&gt;parse(schemeCfg, config-&gt;size(), param_str);
 }
 
 static void
 free_authparam(Auth::ConfigVector * cfg)
 {
     /* Wipe the Auth globals and Detach/Destruct component config + state. */
     cfg-&gt;clear();
 
     /* on reconfigure initialize new auth schemes for the new config. */
     if (reconfiguring) {
         Auth::Init();
     }
 }
 
 static void
 dump_authparam(StoreEntry * entry, const char *name, Auth::ConfigVector cfg)
 {
-    for (Auth::ConfigVector::iterator  i = cfg.begin(); i != cfg.end(); ++i)
-        (*i)-&gt;dump(entry, name, (*i));
+    for (auto *scheme : cfg)
+        scheme-&gt;dump(entry, name, scheme);
 }
 
 static void
 parse_AuthSchemes(acl_access **authSchemes)
 {
     const char *tok = ConfigParser::NextQuotedToken();
     if (!tok) {
         debugs(29, DBG_CRITICAL, &quot;FATAL: auth_schemes missing the parameter&quot;);
         self_destruct();
         return;
     }
-    Config.authSchemesConfigs.push_back(Auth::SchemesConfig(tok, ConfigParser::LastTokenWasQuoted()));
-    const allow_t action = allow_t(ACCESS_ALLOWED, Config.authSchemesConfigs.size() - 1);
+    Auth::TheConfig.schemeLists.emplace_back(tok, ConfigParser::LastTokenWasQuoted());
+    const allow_t action = allow_t(ACCESS_ALLOWED, Auth::TheConfig.schemeLists.size() - 1);
     ParseAclWithAction(authSchemes, action, &quot;auth_schemes&quot;);
 }
 
 static void
 free_AuthSchemes(acl_access **authSchemes)
 {
-    Config.authSchemesConfigs.clear();
+    Auth::TheConfig.schemeLists.clear();
     free_acl_access(authSchemes);
 }
 
 static void
 dump_AuthSchemes(StoreEntry *entry, const char *name, acl_access *authSchemes)
 {
     if (authSchemes)
         dump_SBufList(entry, authSchemes-&gt;treeDump(name, [](const allow_t &amp;action) {
-        return Config.authSchemesConfigs.at(action.kind).rawSchemes;
+        return Auth::TheConfig.schemeLists.at(action.kind).rawSchemes;
     }));
 }
 
 #endif /* USE_AUTH */
 
 static void
 ParseAclWithAction(acl_access **access, const allow_t &amp;action, const char *desc, ACL *acl)
 {
     assert(access);
     SBuf name;
     if (!*access) {
         *access = new Acl::Tree;
         name.Printf(&quot;(%s rules)&quot;, desc);
         (*access)-&gt;context(name.c_str(), config_input_line);
     }
     Acl::AndNode *rule = new Acl::AndNode;
     name.Printf(&quot;(%s rule)&quot;, desc);
     rule-&gt;context(name.c_str(), config_input_line);
     acl ? rule-&gt;add(acl) : rule-&gt;lineParse();
     (*access)-&gt;add(rule, action);

=== modified file 'src/cf.data.depend'
--- src/cf.data.depend	2016-12-10 04:48:25 +0000
+++ src/cf.data.depend	2016-12-15 06:41:12 +0000
@@ -1,39 +1,39 @@
 ## Copyright (C) 1996-2016 The Squid Software Foundation and contributors
 ##
 ## Squid software is distributed under GPLv2+ license and includes
 ## contributions from numerous individuals and organizations.
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 #
 # type			dependencies
 #
 access_log		acl	logformat
 acl			external_acl_type auth_param
 acl_access		acl
 acl_address		acl
 acl_b_size_t		acl
 acl_tos			acl
 acl_nfmark		acl
 address
 authparam
-AuthSchemes
+AuthSchemes		acl auth_param
 b_int64_t
 b_size_t
 b_ssize_t
 cachedir		cache_replacement_policy
 cachemgrpasswd
 ConfigAclTos
 configuration_includes_quoted_values
 CpuAffinityMap
 debug
 delay_pool_access	acl	delay_class
 delay_pool_class	delay_pools
 delay_pool_count
 delay_pool_rates	delay_class
 client_delay_pool_access	acl
 client_delay_pool_count
 client_delay_pool_rates
 denyinfo		acl
 eol
 externalAclHelper	auth_param
 HelperChildConfig

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2016-12-10 04:48:25 +0000
+++ src/cf.data.pre	2016-12-20 12:37:28 +0000
@@ -464,41 +464,41 @@
 	&quot;optimistic&quot; kernel simply kills Squid kid with a SIGBUS signal.
 	Some of the memory limits enforced by the kernel are currently
 	poorly understood: We do not know how to detect and check them. This
 	option ensures that the mapped memory will be available. 
 
 	This option may have a positive performance side-effect: Locking
 	memory at start avoids runtime paging I/O. Paging slows Squid down.
 
 	Locking memory may require a large enough RLIMIT_MEMLOCK OS limit,
 	CAP_IPC_LOCK capability, or equivalent.
 DOC_END
 
 COMMENT_START
  OPTIONS FOR AUTHENTICATION
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: auth_param
 TYPE: authparam
 IFDEF: USE_AUTH
-LOC: Auth::TheConfig
+LOC: Auth::TheConfig.schemes
 DEFAULT: none
 DOC_START
 	This is used to define parameters for the various authentication
 	schemes supported by Squid.
 
 		format: auth_param scheme parameter [setting]
 
 	The order in which authentication schemes are presented to the client is
 	dependent on the order the scheme first appears in config file. IE
 	has a bug (it's not RFC 2617 compliant) in that it will use the basic
 	scheme if basic is the first entry presented, even if more secure
 	schemes are presented. For now use the order in the recommended
 	settings section below. If other browsers have difficulties (don't
 	recognize the schemes offered even if you are using basic) either
 	put basic first, or disable the other schemes (by commenting out their
 	program entry).
 
 	Once an authentication scheme is fully configured, it can only be
 	shutdown by shutting squid down and restarting. Changes can be made on
 	the fly and activated with a reconfigure. I.E. You can change to a
@@ -600,239 +600,177 @@
 		on-persistent-overload option applies.
 
 		The on-persistent-overload=action option specifies Squid
 		reaction to a new helper request arriving when the helper
 		has been overloaded for more that 3 minutes already. The number
 		of queued requests determines whether the helper is overloaded
 		(see the queue-size option).
 
 		Two actions are supported:
 
 		  die	Squid worker quits. This is the default behavior.
 
 		  ERR	Squid treats the helper request as if it was
 			immediately submitted, and the helper immediately
 			replied with an ERR response. This action has no effect
 			on the already queued and in-progress helper requests.
 
 		NOTE: NTLM and Negotiate schemes do not support concurrency
 			in the Squid code module even though some helpers can.
 
+	&quot;keep_alive&quot; on|off
+		If you experience problems with PUT/POST requests when using
+		the NTLM or Negotiate schemes then you can try setting this
+		to off. This will cause Squid to forcibly close the connection
+		on the initial request where the browser asks which schemes
+		are supported by the proxy.
 
-IF HAVE_AUTH_MODULE_BASIC
-	=== Basic authentication parameters ===
+		For Basic and Digest this parameter is ignored.
 
 	&quot;utf8&quot; on|off
 		HTTP uses iso-latin-1 as character set, while some
 		authentication backends such as LDAP expects UTF-8. If this is
 		set to on Squid will translate the HTTP iso-latin-1 charset to
 		UTF-8 before sending the username and password to the helper.
 
+		For NTLM and Negotiate this parameter is ignored.
+
+IF HAVE_AUTH_MODULE_BASIC
+	=== Basic authentication parameters ===
+
 	&quot;credentialsttl&quot; timetolive
 		Specifies how long squid assumes an externally validated
 		username:password pair is valid for - in other words how
 		often the helper program is called for that user. Set this
 		low to force revalidation with short lived passwords.
 
 		NOTE: setting this high does not impact your susceptibility
 		to replay attacks unless you are using an one-time password
 		system (such as SecureID). If you are using such a system,
 		you will be vulnerable to replay attacks unless you also
 		use the max_user_ip ACL in an http_access rule.
 
 	&quot;casesensitive&quot; on|off
 		Specifies if usernames are case sensitive. Most user databases
 		are case insensitive allowing the same username to be spelled
 		using both lower and upper case letters, but some are case
 		sensitive. This makes a big difference for user_max_ip ACL
 		processing and similar.
 
 ENDIF
 IF HAVE_AUTH_MODULE_DIGEST
 	=== Digest authentication parameters ===
 
-	&quot;utf8&quot; on|off
-		HTTP uses iso-latin-1 as character set, while some
-		authentication backends such as LDAP expects UTF-8. If this is
-		set to on Squid will translate the HTTP iso-latin-1 charset to
-		UTF-8 before sending the username and password to the helper.
-
 	&quot;nonce_garbage_interval&quot; timeinterval
 		Specifies the interval that nonces that have been issued
 		to client_agent's are checked for validity.
 
 	&quot;nonce_max_duration&quot; timeinterval
 		Specifies the maximum length of time a given nonce will be
 		valid for.
 
 	&quot;nonce_max_count&quot; number
 		Specifies the maximum number of times a given nonce can be
 		used.
 
 	&quot;nonce_strictness&quot; on|off
 		Determines if squid requires strict increment-by-1 behavior
 		for nonce counts, or just incrementing (off - for use when
 		user agents generate nonce counts that occasionally miss 1
 		(ie, 1,2,4,6)). Default off.
 
 	&quot;check_nonce_count&quot; on|off
 		This directive if set to off can disable the nonce count check
 		completely to work around buggy digest qop implementations in
 		certain mainstream browser versions. Default on to check the
 		nonce count to protect from authentication replay attacks.
 
 	&quot;post_workaround&quot; on|off
 		This is a workaround to certain buggy browsers who send an
 		incorrect request digest in POST requests when reusing the
 		same nonce as acquired earlier on a GET request.
 
 ENDIF
-IF HAVE_AUTH_MODULE_NEGOTIATE
-	=== Negotiate authentication parameters ===
-
-	&quot;keep_alive&quot; on|off
-		If you experience problems with PUT/POST requests when using
-		the this authentication scheme then you can try setting this
-		to off. This will cause Squid to forcibly close the connection
-		on the initial request where the browser asks which schemes
-		are supported by the proxy.
-
-ENDIF
-IF HAVE_AUTH_MODULE_NTLM
-	=== NTLM authentication parameters ===
-
-	&quot;keep_alive&quot; on|off
-		If you experience problems with PUT/POST requests when using
-		the this authentication scheme then you can try setting this
-		to off. This will cause Squid to forcibly close the connection
-		on the initial request where the browser asks which schemes
-		are supported by the proxy.
-ENDIF
 
 	=== Example Configuration ===
 
 	This configuration displays the recommended authentication scheme
 	order from most to least secure with recommended minimum configuration
 	settings for each scheme:
 
 #auth_param negotiate program &lt;uncomment and complete this line to activate&gt;
 #auth_param negotiate children 20 startup=0 idle=1
-#auth_param negotiate keep_alive on
 #
 #auth_param digest program &lt;uncomment and complete this line to activate&gt;
 #auth_param digest children 20 startup=0 idle=1
 #auth_param digest realm Squid proxy-caching web server
 #auth_param digest nonce_garbage_interval 5 minutes
 #auth_param digest nonce_max_duration 30 minutes
 #auth_param digest nonce_max_count 50
 #
 #auth_param ntlm program &lt;uncomment and complete this line to activate&gt;
 #auth_param ntlm children 20 startup=0 idle=1
-#auth_param ntlm keep_alive on
 #
 #auth_param basic program &lt;uncomment and complete this line&gt;
 #auth_param basic children 5 startup=5 idle=1
-#auth_param basic realm Squid proxy-caching web server
 #auth_param basic credentialsttl 2 hours
 DOC_END
 
 NAME: authenticate_cache_garbage_interval
+IFDEF: USE_AUTH
 TYPE: time_t
 DEFAULT: 1 hour
-LOC: Config.authenticateGCInterval
+LOC: Auth::TheConfig.authenticateGCInterval
 DOC_START
 	The time period between garbage collection across the username cache.
 	This is a trade-off between memory utilization (long intervals - say
 	2 days) and CPU (short intervals - say 1 minute). Only change if you
 	have good reason to.
 DOC_END
 
 NAME: authenticate_ttl
+IFDEF: USE_AUTH
 TYPE: time_t
 DEFAULT: 1 hour
-LOC: Config.authenticateTTL
+LOC: Auth::TheConfig.authenticateTTL
 DOC_START
 	The time a user &amp; their credentials stay in the logged in
 	user cache since their last request. When the garbage
 	interval passes, all user credentials that have passed their
 	TTL are removed from memory.
 DOC_END
 
 NAME: authenticate_ip_ttl
+IFDEF: USE_AUTH
 TYPE: time_t
-LOC: Config.authenticateIpTTL
+LOC: Auth::TheConfig.authenticateIpTTL
 DEFAULT: 1 second
 DOC_START
 	If you use proxy authentication and the 'max_user_ip' ACL,
 	this directive controls how long Squid remembers the IP
 	addresses associated with each user.  Use a small value
 	(e.g., 60 seconds) if your users might change addresses
 	quickly, as is the case with dialup.   You might be safe
 	using a larger value (e.g., 2 hours) in a corporate LAN
 	environment with relatively static address assignments.
 DOC_END
 
-NAME: auth_schemes
-TYPE: AuthSchemes
-IFDEF: USE_AUTH
-LOC: Config.accessList.authSchemes
-DEFAULT: none
-DEFAULT_DOC: use all auth_param schemes in their configuration order
-DOC_START
-	Use this directive to customize authentication schemes presence and
-	order in Squid's Unauthorized and Authentication Required responses.
-
-		auth_schemes scheme1,scheme2,... [!]aclname ...
-
-	where schemeN is the name of one of the authentication schemes
-	configured using auth_param directives. At least one scheme name is
-	required. Multiple scheme names are separated by commas. Either
-	avoid whitespace or quote the entire schemes list.
-
-	A special &quot;ALL&quot; scheme name expands to all auth_param-configured
-	schemes in their configuration order. This directive cannot be used
-	to configure Squid to offer no authentication schemes at all.
-
-	The first matching auth_schemes rule determines the schemes order
-	for the current Authentication Required transaction. Note that the
-	future response is not yet available during auth_schemes evaluation.
-
-	If this directive is not used or none of its rules match, then Squid
-	responds with all configured authentication schemes in the order of
-	auth_param directives in the configuration file.
-
-	This directive does not determine when authentication is used or
-	how each authentication scheme authenticates clients.
-
-	The following example sends basic and negotiate authentication
-	schemes, in that order, when requesting authentication of HTTP
-	requests matching the isIE ACL (not shown) while sending all
-	auth_param schemes in their configuration order to other clients:
-
-		auth_schemes basic,negotiate isIE
-		auth_schemes ALL all # explicit default
-
-	This directive supports fast ACLs only.
-
-	See also: auth_param.
-DOC_END
-
 COMMENT_START
  ACCESS CONTROLS
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: external_acl_type
 TYPE: externalAclHelper
 LOC: Config.externalAclHelperList
 DEFAULT: none
 DOC_START
 	This option defines external acl classes using a helper program
 	to look up the status
 
 	  external_acl_type name [options] FORMAT /path/to/helper [helper arguments]
 
 	Options:
 
 	  ttl=n		TTL in seconds for cached results (defaults to 3600
 			for 1 hour)
 
@@ -1914,40 +1852,85 @@
 
 	Currently, this directive has effect on intercepted connections and
 	bumped tunnels only. Other cases are not supported because Squid
 	cannot know the intended destination of other traffic.
 
 	For example:
 	  # define what Squid errors indicate receiving non-HTTP traffic:
 	  acl foreignProtocol squid_error ERR_PROTOCOL_UNKNOWN ERR_TOO_BIG
 	  # define what Squid errors indicate receiving nothing:
 	  acl serverTalksFirstProtocol squid_error ERR_REQUEST_START_TIMEOUT
 	  # tunnel everything that does not look like HTTP:
           on_unsupported_protocol tunnel foreignProtocol
 	  # tunnel if we think the client waits for the server to talk first:
 	  on_unsupported_protocol tunnel serverTalksFirstProtocol
 	  # in all other error cases, just send an HTTP &quot;error page&quot; response:
 	  on_unsupported_protocol respond all
 
 	See also: squid_error ACL
 DOC_END
 
+NAME: auth_schemes
+TYPE: AuthSchemes
+IFDEF: USE_AUTH
+LOC: Auth::TheConfig.schemeAccess
+DEFAULT: none
+DEFAULT_DOC: use all auth_param schemes in their configuration order
+DOC_START
+	Use this directive to customize authentication schemes presence and
+	order in Squid's Unauthorized and Authentication Required responses.
+
+		auth_schemes scheme1,scheme2,... [!]aclname ...
+
+	where schemeN is the name of one of the authentication schemes
+	configured using auth_param directives. At least one scheme name is
+	required. Multiple scheme names are separated by commas. Either
+	avoid whitespace or quote the entire schemes list.
+
+	A special &quot;ALL&quot; scheme name expands to all auth_param-configured
+	schemes in their configuration order. This directive cannot be used
+	to configure Squid to offer no authentication schemes at all.
+
+	The first matching auth_schemes rule determines the schemes order
+	for the current Authentication Required transaction. Note that the
+	future response is not yet available during auth_schemes evaluation.
+
+	If this directive is not used or none of its rules match, then Squid
+	responds with all configured authentication schemes in the order of
+	auth_param directives in the configuration file.
+
+	This directive does not determine when authentication is used or
+	how each authentication scheme authenticates clients.
+
+	The following example sends basic and negotiate authentication
+	schemes, in that order, when requesting authentication of HTTP
+	requests matching the isIE ACL (not shown) while sending all
+	auth_param schemes in their configuration order to other clients:
+
+		auth_schemes basic,negotiate isIE
+		auth_schemes ALL all # explicit default
+
+	This directive supports fast ACLs only.
+
+	See also: auth_param.
+DOC_END
+
 COMMENT_START
  NETWORK OPTIONS
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: http_port ascii_port
 TYPE: PortCfg
 DEFAULT: none
 LOC: HttpPortList
 DOC_START
 	Usage:	port [mode] [options]
 		hostname:port [mode] [options]
 		1.2.3.4:port [mode] [options]
 
 	The socket addresses where Squid will listen for HTTP client
 	requests.  You may specify multiple socket addresses.
 	There are three forms: port alone, hostname with port, and
 	IP address with port.  If you specify a hostname or IP
 	address, Squid binds the socket to that specific
 	address. Most likely, you do not need to bind to a specific

=== modified file 'src/main.cc'
--- src/main.cc	2016-10-03 04:33:08 +0000
+++ src/main.cc	2016-12-19 13:36:49 +0000
@@ -1,34 +1,36 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 01    Startup and Main Loop */
 
 #include &quot;squid.h&quot;
 #include &quot;AccessLogEntry.h&quot;
 #include &quot;acl/Acl.h&quot;
 #include &quot;acl/Asn.h&quot;
+#include &quot;auth/Config.h&quot;
+#include &quot;auth/Gadgets.h&quot;
 #include &quot;AuthReg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;base/Subscription.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;cache_cf.h&quot;
 #include &quot;CachePeer.h&quot;
 #include &quot;carp.h&quot;
 #include &quot;client_db.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;comm.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;CpuAffinity.h&quot;
 #include &quot;DiskIO/DiskIOModule.h&quot;
 #include &quot;dns/forward.h&quot;
 #include &quot;errorpage.h&quot;
 #include &quot;event.h&quot;
 #include &quot;EventLoop.h&quot;
 #include &quot;ExternalACL.h&quot;
 #include &quot;fd.h&quot;
 #include &quot;format/Token.h&quot;
@@ -70,43 +72,40 @@
 #include &quot;store/Disks.h&quot;
 #include &quot;store_log.h&quot;
 #include &quot;StoreFileSystem.h&quot;
 #include &quot;tools.h&quot;
 #include &quot;unlinkd.h&quot;
 #include &quot;URL.h&quot;
 #include &quot;wccp.h&quot;
 #include &quot;wccp2.h&quot;
 #include &quot;WinSvc.h&quot;
 
 #if USE_ADAPTATION
 #include &quot;adaptation/Config.h&quot;
 #endif
 #if USE_ECAP
 #include &quot;adaptation/ecap/Config.h&quot;
 #endif
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/Config.h&quot;
 #include &quot;adaptation/icap/icap_log.h&quot;
 #endif
-#if USE_AUTH
-#include &quot;auth/Gadgets.h&quot;
-#endif
 #if USE_DELAY_POOLS
 #include &quot;ClientDelayConfig.h&quot;
 #endif
 #if USE_DELAY_POOLS
 #include &quot;DelayPools.h&quot;
 #endif
 #if USE_LOADABLE_MODULES
 #include &quot;LoadableModules.h&quot;
 #endif
 #if USE_OPENSSL
 #include &quot;ssl/context_storage.h&quot;
 #include &quot;ssl/helper.h&quot;
 #endif
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/Config.h&quot;
 #endif
 #if USE_ECAP
 #include &quot;adaptation/ecap/Config.h&quot;
 #endif
 #if USE_ADAPTATION
@@ -947,41 +946,41 @@
     enableAdaptation = Adaptation::Ecap::TheConfig.onoff || enableAdaptation;
 #endif
     Adaptation::Config::Finalize(enableAdaptation);
 #endif
 
 #if ICAP_CLIENT
     icapLogOpen();
 #endif
     storeLogOpen();
     Dns::Init();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()-&gt;Init();
 #endif
 #if USE_OPENSSL
     if (Ssl::CertValidationHelper::GetInstance())
         Ssl::CertValidationHelper::GetInstance()-&gt;Init();
 #endif
 
     redirectInit();
 #if USE_AUTH
-    authenticateInit(&amp;Auth::TheConfig);
+    authenticateInit(&amp;Auth::TheConfig.schemes);
 #endif
     externalAclInit();
 
     if (IamPrimaryProcess()) {
 #if USE_WCCP
 
         wccpInit();
 #endif
 #if USE_WCCPv2
 
         wccp2Init();
 #endif
     }
 
     serverConnectionsOpen();
 
     neighbors_init();
 
     storeDirOpenSwapLogs();
 
@@ -1014,41 +1013,41 @@
     if (AvoidSignalAction(&quot;log rotation&quot;, do_rotate))
         return;
 
     icmpEngine.Close();
     redirectShutdown();
 #if USE_AUTH
     authenticateRotate();
 #endif
     externalAclShutdown();
 
     _db_rotate_log();       /* cache.log */
     storeDirWriteCleanLogs(1);
     storeLogRotate();       /* store.log */
     accessLogRotate();      /* access.log */
 #if ICAP_CLIENT
     icapLogRotate();               /*icap.log*/
 #endif
     icmpEngine.Open();
     redirectInit();
 #if USE_AUTH
-    authenticateInit(&amp;Auth::TheConfig);
+    authenticateInit(&amp;Auth::TheConfig.schemes);
 #endif
     externalAclInit();
 }
 
 static void
 setEffectiveUser(void)
 {
     keepCapabilities();
     leave_suid();       /* Run as non privilegied user */
 #if _SQUID_OS2_
 
     return;
 #endif
 
     if (geteuid() == 0) {
         debugs(0, DBG_CRITICAL, &quot;Squid is not safe to run as root!  If you must&quot;);
         debugs(0, DBG_CRITICAL, &quot;start Squid as root, then you must configure&quot;);
         debugs(0, DBG_CRITICAL, &quot;it to run as a non-priveledged user with the&quot;);
         debugs(0, DBG_CRITICAL, &quot;'cache_effective_user' option in the config file.&quot;);
         fatal(&quot;Don't run Squid as root, set 'cache_effective_user'!&quot;);
@@ -1158,41 +1157,41 @@
 
     ipcache_init();
 
     fqdncache_init();
 
     parseEtcHosts();
 
     Dns::Init();
 
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()-&gt;Init();
 #endif
 
 #if USE_OPENSSL
     if (Ssl::CertValidationHelper::GetInstance())
         Ssl::CertValidationHelper::GetInstance()-&gt;Init();
 #endif
 
     redirectInit();
 #if USE_AUTH
-    authenticateInit(&amp;Auth::TheConfig);
+    authenticateInit(&amp;Auth::TheConfig.schemes);
 #endif
     externalAclInit();
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
     errorInitialize();
 
     accessLogInit();
 
 #if ICAP_CLIENT
     icapLogOpen();
 #endif
 
 #if USE_IDENT
     Ident::Init();
 #endif
 
 #if SQUID_SNMP
 
     snmpInit();

=== modified file 'src/tests/stub_libauth.cc'
--- src/tests/stub_libauth.cc	2016-12-10 04:48:25 +0000
+++ src/tests/stub_libauth.cc	2016-12-19 13:43:02 +0000
@@ -1,81 +1,84 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 
 #define STUB_API &quot;auth/libauth.la&quot;
 #include &quot;STUB.h&quot;
 
 #if USE_AUTH
-#include &quot;auth/Config.h&quot;
-Auth::UserRequest::Pointer Auth::Config::CreateAuthUser(const char *, AccessLogEntry::Pointer &amp;al) STUB_RETVAL(NULL)
-Auth::Config * Auth::Config::Find(const char *) STUB_RETVAL(NULL)
-void Auth::Config::registerWithCacheManager(void) STUB_NOP
-Auth::ConfigVector Auth::TheConfig;
+#include &quot;auth/SchemeConfig.h&quot;
+namespace Auth
+{
+Auth::UserRequest::Pointer SchemeConfig::CreateAuthUser(const char *, AccessLogEntry::Pointer &amp;al) STUB_RETVAL(NULL)
+Auth::SchemeConfig * SchemeConfig::Find(const char *) STUB_RETVAL(NULL)
+void SchemeConfig::registerWithCacheManager(void) STUB_NOP
+Auth::ConfigVector TheConfig;
+}
 
 #include &quot;auth/Gadgets.h&quot;
 int authenticateActiveSchemeCount(void) STUB_RETVAL(0)
 int authenticateSchemeCount(void) STUB_RETVAL(0)
 void authenticateInit(Auth::ConfigVector *) STUB
 void authenticateRotate(void) STUB
 void authenticateReset(void) STUB
 
 #include &quot;auth/Scheme.h&quot;
 #include &lt;vector&gt;
 std::vector&lt;Auth::Scheme::Pointer&gt; *Auth::Scheme::_Schemes = NULL;
 void Auth::Scheme::AddScheme(Auth::Scheme::Pointer) STUB
 Auth::Scheme::Pointer Auth::Scheme::Find(const char *) STUB_RETVAL(NULL)
 std::vector&lt;Auth::Scheme::Pointer&gt; &amp; Auth::Scheme::GetSchemes() STUB_RETVAL(*_Schemes);
 void Auth::Scheme::FreeAll() STUB
 
+#include &quot;auth/SchemesConfig.h&quot;
+void Auth::SchemesConfig::expand() STUB
+
 #include &quot;auth/User.h&quot;
-Auth::User::User(Auth::Config *, const char *) STUB
+Auth::User::User(Auth::SchemeConfig *, const char *) STUB
 Auth::CredentialState Auth::User::credentials() const STUB_RETVAL(credentials_state)
 void Auth::User::credentials(CredentialState) STUB
 void Auth::User::absorb(Auth::User::Pointer) STUB
 Auth::User::~User() STUB_NOP
 void Auth::User::clearIp() STUB
 void Auth::User::removeIp(Ip::Address) STUB
 void Auth::User::addIp(Ip::Address) STUB
 void Auth::User::CredentialsCacheStats(StoreEntry *) STUB
 
 #include &quot;auth/UserRequest.h&quot;
 char const * Auth::UserRequest::username() const STUB_RETVAL(&quot;stub_username&quot;)
 void Auth::UserRequest::start(HttpRequest *, AccessLogEntry::Pointer &amp;, AUTHCB *, void *) STUB
 bool Auth::UserRequest::valid() const STUB_RETVAL(false)
 void * Auth::UserRequest::operator new (size_t) STUB_RETVAL((void *)1)
 void Auth::UserRequest::operator delete (void *) STUB
 Auth::UserRequest::UserRequest() STUB
 Auth::UserRequest::~UserRequest() STUB
 void Auth::UserRequest::setDenyMessage(char const *) STUB
 char const * Auth::UserRequest::getDenyMessage() STUB_RETVAL(&quot;stub&quot;)
 char const * Auth::UserRequest::denyMessage(char const * const) STUB_RETVAL(&quot;stub&quot;)
 void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &amp;) STUB
 void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer) STUB
 int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer) STUB_RETVAL(0)
 int authenticateUserAuthenticated(Auth::UserRequest::Pointer) STUB_RETVAL(0)
 Auth::Direction Auth::UserRequest::direction() STUB_RETVAL(Auth::CRED_ERROR)
 void Auth::UserRequest::addAuthenticationInfoHeader(HttpReply *, int) STUB
 void Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply *, int) STUB
 void Auth::UserRequest::releaseAuthServer() STUB
 const char * Auth::UserRequest::connLastHeader() STUB_RETVAL(&quot;stub&quot;)
 AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &amp;, AccessLogEntry::Pointer &amp;) STUB_RETVAL(AUTH_AUTHENTICATED)
 AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &amp;, AccessLogEntry::Pointer &amp;) STUB_RETVAL(AUTH_AUTHENTICATED)
 void Auth::UserRequest::addReplyAuthHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int) STUB
 Auth::Scheme::Pointer Auth::UserRequest::scheme() const STUB_RETVAL(NULL)
 
 #include &quot;AuthReg.h&quot;
 void Auth::Init() STUB_NOP
 
-#include &quot;auth/SchemesConfig.h&quot;
-void Auth::SchemesConfig::expand() STUB
-
 #endif /* USE_AUTH */
 

=== modified file 'src/tests/testAuth.cc'
--- src/tests/testAuth.cc	2016-01-01 00:12:18 +0000
+++ src/tests/testAuth.cc	2016-12-19 13:43:38 +0000
@@ -1,35 +1,34 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 
 #if USE_AUTH
 
 #include &quot;auth/Config.h&quot;
 #include &quot;auth/Gadgets.h&quot;
-#include &quot;auth/Scheme.h&quot;
 #include &quot;auth/UserRequest.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;testAuth.h&quot;
 #include &quot;unitTestMain.h&quot;
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuth );
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuthConfig );
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuthUserRequest );
 #if HAVE_AUTH_MODULE_BASIC
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuthBasicUserRequest );
 #endif
 #if HAVE_AUTH_MODULE_DIGEST
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuthDigestUserRequest );
 #endif
 #if HAVE_AUTH_MODULE_NTLM
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuthNTLMUserRequest );
 #endif
 #if HAVE_AUTH_MODULE_NEGOTIATE
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuthNegotiateUserRequest );
 #endif

</PRE>




























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007593.html">[squid-dev] Fix for the bug 4648
</A></li>
	<LI>Next message: <A HREF="007616.html">[squid-dev] [PATCH] refactor Auth::Config
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7615">[ date ]</a>
              <a href="thread.html#7615">[ thread ]</a>
              <a href="subject.html#7615">[ subject ]</a>
              <a href="author.html#7615">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
