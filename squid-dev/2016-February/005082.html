<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] implement RFC3986
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56B8215F.9000702%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005153.html">
   <LINK REL="Next"  HREF="005083.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] implement RFC3986</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56B8215F.9000702%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] implement RFC3986">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Feb  8 05:02:23 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005153.html">[squid-dev] [PATCH] Include intermediate certs to client when using peek/stare
</A></li>
        <LI>Next message: <A HREF="005083.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5082">[ date ]</a>
              <a href="thread.html#5082">[ thread ]</a>
              <a href="subject.html#5082">[ subject ]</a>
              <a href="author.html#5082">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Okay, I have done some of the major reimplementation changes and pushed
the result to lp:~squid/squid/rfc3986-mk2

I omitted the reserve() optimizations, but left in the SBuf::push_back
change.

The desired for-loop cannot be used apparently because SBuf lacks a
const_iterator definition. That will need to happen before we can apply
this, or put up with several very nasty const_cast.


The following audit changes have yet to be done:

On 29/12/2015 8:01 a.m., Kinkie wrote:
&gt;<i> On Mon, Dec 28, 2015 at 5:46 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 12/28/2015 07:01 AM, Kinkie wrote:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +static int
</I>&gt;&gt;&gt;<i> +fromhex(char ch)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
</I>&gt;&gt;&gt;<i> +        return ch - '0';
</I>&gt;&gt;&gt;<i> +    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')
</I>&gt;&gt;&gt;<i> +        return ch - 'a' + 10;
</I>&gt;&gt;&gt;<i> +    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')
</I>&gt;&gt;&gt;<i> +        return ch - 'A' + 10;
</I>&gt;&gt;&gt;<i> +    return -1;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you are after performance, an unconditional lookup in a 256-member
</I>&gt;&gt;<i> int vector would be faster.
</I>&gt;<i> 
</I>&gt;<i> Performance is good, but it's not the primary objective. For now I'd
</I>&gt;<i> leave as-is.
</I>&gt;<i> 
</I>
&gt;&gt;&gt;<i> +// return a static 2-char buffer with a hex representation of argument
</I>&gt;&gt;&gt;<i> +static char*
</I>&gt;&gt;&gt;<i> +tohex(const unsigned char c)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +    static char rv[3];
</I>&gt;&gt;&gt;<i> +    (void) snprintf ( rv, 3, &quot;%02X&quot;, c);
</I>&gt;&gt;&gt;<i> +    return rv;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you are after performance, an unconditional lookup in a 256-member
</I>&gt;&gt;<i> char* vector would be much faster.
</I>&gt;<i> 
</I>&gt;<i> Same as above.
</I>&gt;<i> 
</I>
&gt;&gt;<i> If you can return a const pointer, please return a const pointer.
</I>&gt;<i> 
</I>&gt;<i> It's not possible with the current implementation. If we decide to
</I>&gt;<i> move to an array-based one, sure.
</I>&gt;<i> 
</I>
&gt;&gt;&gt;<i> +    for (auto in = s.begin(); in != e; ++in) {
</I>&gt;&gt;&gt;<i> +        if (*in != '%') { // normal case, copy and continue
</I>&gt;&gt;&gt;<i> +            rv.push_back(*in);
</I>&gt;&gt;&gt;<i> +            continue;
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I cannot validate that low-level C code. Can you use a Tokenizer
</I>&gt;&gt;<i> instead? Is it critical to provide copy-less performance for helpers
</I>&gt;&gt;<i> using std::string instead of SBuf?
</I>&gt;<i> 
</I>&gt;<i> Performance for helpers is not really critical IMO.
</I>&gt;<i> SBuf is a lot of code and it really depends on infrastructure provided
</I>&gt;<i> by squid (e.g. mempools).
</I>&gt;<i> Outside squid it really makes not much sense to bring in that much
</I>&gt;<i> scaffolding - which would also have include stubs etc.
</I>&gt;<i> It's much better to be API-compatible and use std::string there.
</I>&gt;<i> 
</I>
&gt;&gt;&gt;<i> +public:
</I>&gt;&gt;&gt;<i> +    const static CharacterSet
</I>&gt;&gt;&gt;<i> +        Unsafe,  // RFC 1738 unsafe set
</I>&gt;&gt;&gt;<i> +        Ctrls,   // control characters (\0x00 to \0x1f)
</I>&gt;&gt;&gt;<i> +        UnsafeAndCtrls, // RFC 1738 Unsafe and Ctrls
</I>&gt;&gt;&gt;<i> +        Reserved1738, // RFC 1738 Reserved set
</I>&gt;&gt;&gt;<i> +        GenDelims,// RFC 3986 gen-delims set
</I>&gt;&gt;&gt;<i> +        SubDelims,// RFC 3986 sub-delims set
</I>&gt;&gt;&gt;<i> +        Reserved, // RFC 3986 reserved characters set
</I>&gt;&gt;&gt;<i> +        Unreserved, // RFC 3986 unreserved characters set
</I>&gt;&gt;&gt;<i> +        Unescaped,//ctrls and unsafe except for percent symbol
</I>&gt;&gt;&gt;<i> +        All;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is not a class but a namespace.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please s/RFC3986/Rfc3986/ for consistency with similar &quot;let's group RFC
</I>&gt;&gt;<i> concepts in one namespace&quot; SslBump code posted by Christos earlier (IIRC).
</I>&gt;&gt;<i>
</I>
I was not able to find that posting yet. Have done the split into two
namespaces anyway. But would like to check against Factory ideas anyway
to make sure we are not diverging implementation style.

Amos

</PRE>






























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005153.html">[squid-dev] [PATCH] Include intermediate certs to client when using peek/stare
</A></li>
	<LI>Next message: <A HREF="005083.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5082">[ date ]</a>
              <a href="thread.html#5082">[ thread ]</a>
              <a href="subject.html#5082">[ subject ]</a>
              <a href="author.html#5082">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
