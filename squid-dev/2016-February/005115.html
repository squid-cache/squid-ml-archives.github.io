<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] implement RFC3986
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56BB5E7B.2060402%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005083.html">
   <LINK REL="Next"  HREF="005116.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] implement RFC3986</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56BB5E7B.2060402%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] implement RFC3986">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Feb 10 15:59:55 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005083.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
        <LI>Next message: <A HREF="005116.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5115">[ date ]</a>
              <a href="thread.html#5115">[ thread ]</a>
              <a href="subject.html#5115">[ subject ]</a>
              <a href="author.html#5115">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is the updated patch implementing RFC 3986 URI coding ('URL-escaping').

So far all the audit suggestions except Tokenizer usage have been
implemented. Tokenizer is omitted because we still want helpers to be
able to instantiate these templates functions with std::string.

Amos
-------------- next part --------------
=== modified file 'src/Makefile.am'
--- src/Makefile.am	2016-02-09 08:57:33 +0000
+++ src/Makefile.am	2016-02-10 14:53:12 +0000
@@ -3819,6 +3819,27 @@
 	$(XTRA_LIBS)
 tests_testYesNoNone_LDFLAGS = $(LIBADD_DL)
 
+check_PROGRAMS += tests/testRFC3986
+tests_testRFC3986_SOURCES= \
+	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
+	tests/stub_SBufDetailedStats.cc \
+	tests/testRFC3986.h \
+	tests/testRFC3986.cc
+nodist_tests_testRFC3986_SOURCES= \
+	$(SBUF_SOURCE) \
+	String.cc \
+	$(TESTSOURCES)
+tests_testRFC3986_LDADD= \
+	anyp/libanyp.la \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscencoding.la \
+	$(COMPAT_LIB) \
+	$(SQUID_CPPUNIT_LA) \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(XTRA_LIBS)
+tests_testRFC3986_LDFLAGS= $(LIBADD_DL)
+
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script

=== modified file 'src/SBuf.h'
--- src/SBuf.h	2016-02-08 11:22:48 +0000
+++ src/SBuf.h	2016-02-10 14:53:46 +0000
@@ -234,6 +234,7 @@
 
     /// Append a single character. The character may be NUL (\0).
     SBuf&amp; append(const char c);
+    SBuf&amp; push_back(const char c) {return append(c);}
 
     /** Append operation for C-style strings.
      *

=== modified file 'src/anyp/Makefile.am'
--- src/anyp/Makefile.am	2016-01-01 00:12:18 +0000
+++ src/anyp/Makefile.am	2016-02-10 15:02:15 +0000
@@ -17,6 +17,8 @@
 	ProtocolType.cc \
 	ProtocolType.h \
 	ProtocolVersion.h \
+	Rfc3986.cc \
+	Rfc3986.h \
 	TrafficMode.h \
 	UriScheme.cc \
 	UriScheme.h

=== added file 'src/anyp/Rfc3986.cc'
--- src/anyp/Rfc3986.cc	1970-01-01 00:00:00 +0000
+++ src/anyp/Rfc3986.cc	2016-02-10 15:02:22 +0000
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include &quot;squid.h&quot;
+#include &quot;anyp/Rfc3986.h&quot;
+
+const CharacterSet
+Rfc1738::Unsafe(&quot;rfc1738:unsafe&quot;, &quot;&lt;&gt;\&quot;# %{}|\\^~[]`'&quot;),
+Rfc1738::Ctrls(&quot;rfc1738:ctrls&quot;, {{0x00, 0x1f}, {0x7f,0xff}}),
+Rfc1738::Reserved(&quot;rfc1738:reserved&quot;, &quot;;/?:@=&amp;&quot;),
+Rfc1738::UnsafeAndCtrls = Rfc1738::Unsafe + Rfc1738::Ctrls,
+         Rfc1738::Unescaped = (Rfc1738::UnsafeAndCtrls - CharacterSet(nullptr,&quot;%&quot;) ).rename(&quot;rfc1738:unescaped&quot;)
+                              ;
+
+const CharacterSet
+Rfc3986::GenDelims(&quot;rfc3986:gen-delims&quot;,&quot;:/?#[]@&quot;),
+        Rfc3986::SubDelims(&quot;rfc3986:sub-delims&quot;,&quot;!$&amp;'()*+,;=&quot;),
+        Rfc3986::Reserved = (Rfc3986::GenDelims + Rfc3986::SubDelims).rename(&quot;rfc3986:reserved&quot;),
+                 Rfc3986::Unreserved = CharacterSet(&quot;rfc3986:unreserved&quot;,&quot;-._~&quot;) +
+                                       CharacterSet::ALPHA + CharacterSet::DIGIT,
+                                       Rfc3986::All = (Rfc1738::UnsafeAndCtrls + Rfc3986::Reserved).rename(&quot;rfc3986:all&quot;)
+                                               ;
+
+const char *Rfc1738::toHexTable[256] = {
+    &quot;00&quot;, &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;,
+    &quot;08&quot;, &quot;09&quot;, &quot;0A&quot;, &quot;0B&quot;, &quot;0C&quot;, &quot;0D&quot;, &quot;0E&quot;, &quot;0F&quot;,
+    &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;,
+    &quot;18&quot;, &quot;19&quot;, &quot;1A&quot;, &quot;1B&quot;, &quot;1C&quot;, &quot;1D&quot;, &quot;1E&quot;, &quot;1F&quot;,
+    &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;,
+    &quot;28&quot;, &quot;29&quot;, &quot;2A&quot;, &quot;2B&quot;, &quot;2C&quot;, &quot;2D&quot;, &quot;2E&quot;, &quot;2F&quot;,
+    &quot;30&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;,
+    &quot;38&quot;, &quot;39&quot;, &quot;3A&quot;, &quot;3B&quot;, &quot;3C&quot;, &quot;3D&quot;, &quot;3E&quot;, &quot;3F&quot;,
+    &quot;40&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;, &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;47&quot;,
+    &quot;48&quot;, &quot;49&quot;, &quot;4A&quot;, &quot;4B&quot;, &quot;4C&quot;, &quot;4D&quot;, &quot;4E&quot;, &quot;4F&quot;,
+    &quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot;,
+    &quot;58&quot;, &quot;59&quot;, &quot;5A&quot;, &quot;5B&quot;, &quot;5C&quot;, &quot;5D&quot;, &quot;5E&quot;, &quot;5F&quot;,
+    &quot;60&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;, &quot;64&quot;, &quot;65&quot;, &quot;66&quot;, &quot;67&quot;,
+    &quot;68&quot;, &quot;69&quot;, &quot;6A&quot;, &quot;6B&quot;, &quot;6C&quot;, &quot;6D&quot;, &quot;6E&quot;, &quot;6F&quot;,
+    &quot;70&quot;, &quot;71&quot;, &quot;72&quot;, &quot;73&quot;, &quot;74&quot;, &quot;75&quot;, &quot;76&quot;, &quot;77&quot;,
+    &quot;78&quot;, &quot;79&quot;, &quot;7A&quot;, &quot;7B&quot;, &quot;7C&quot;, &quot;7D&quot;, &quot;7E&quot;, &quot;7F&quot;,
+    &quot;80&quot;, &quot;81&quot;, &quot;82&quot;, &quot;83&quot;, &quot;84&quot;, &quot;85&quot;, &quot;86&quot;, &quot;87&quot;,
+    &quot;88&quot;, &quot;89&quot;, &quot;8A&quot;, &quot;8B&quot;, &quot;8C&quot;, &quot;8D&quot;, &quot;8E&quot;, &quot;8F&quot;,
+    &quot;90&quot;, &quot;91&quot;, &quot;92&quot;, &quot;93&quot;, &quot;94&quot;, &quot;95&quot;, &quot;96&quot;, &quot;97&quot;,
+    &quot;98&quot;, &quot;99&quot;, &quot;9A&quot;, &quot;9B&quot;, &quot;9C&quot;, &quot;9D&quot;, &quot;9E&quot;, &quot;9F&quot;,
+    &quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;, &quot;A6&quot;, &quot;A7&quot;,
+    &quot;A8&quot;, &quot;A9&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;AD&quot;, &quot;AE&quot;, &quot;AF&quot;,
+    &quot;B0&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;, &quot;B4&quot;, &quot;B5&quot;, &quot;B6&quot;, &quot;B7&quot;,
+    &quot;B8&quot;, &quot;B9&quot;, &quot;BA&quot;, &quot;BB&quot;, &quot;BC&quot;, &quot;BD&quot;, &quot;BE&quot;, &quot;BF&quot;,
+    &quot;C0&quot;, &quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;, &quot;C5&quot;, &quot;C6&quot;, &quot;C7&quot;,
+    &quot;C8&quot;, &quot;C9&quot;, &quot;CA&quot;, &quot;CB&quot;, &quot;CC&quot;, &quot;CD&quot;, &quot;CE&quot;, &quot;CF&quot;,
+    &quot;D0&quot;, &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;, &quot;D4&quot;, &quot;D5&quot;, &quot;D6&quot;, &quot;D7&quot;,
+    &quot;D8&quot;, &quot;D9&quot;, &quot;DA&quot;, &quot;DB&quot;, &quot;DC&quot;, &quot;DD&quot;, &quot;DE&quot;, &quot;DF&quot;,
+    &quot;E0&quot;, &quot;E1&quot;, &quot;E2&quot;, &quot;E3&quot;, &quot;E4&quot;, &quot;E5&quot;, &quot;E6&quot;, &quot;E7&quot;,
+    &quot;E8&quot;, &quot;E9&quot;, &quot;EA&quot;, &quot;EB&quot;, &quot;EC&quot;, &quot;ED&quot;, &quot;EE&quot;, &quot;EF&quot;,
+    &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, &quot;F3&quot;, &quot;F4&quot;, &quot;F5&quot;, &quot;F6&quot;, &quot;F7&quot;,
+    &quot;F8&quot;, &quot;F9&quot;, &quot;FA&quot;, &quot;FB&quot;, &quot;FC&quot;, &quot;FD&quot;, &quot;FE&quot;, &quot;FF&quot;
+};
+
+const int16_t Rfc1738::fromHexTable[256] = {
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
+    -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+};
+

=== added file 'src/anyp/Rfc3986.h'
--- src/anyp/Rfc3986.h	1970-01-01 00:00:00 +0000
+++ src/anyp/Rfc3986.h	2016-02-10 15:02:24 +0000
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_ANYP_RFC3986_H
+#define SQUID_SRC_ANYP_RFC3986_H
+
+#include &quot;base/CharacterSet.h&quot;
+
+/// RFC 1738 symbol and charset definitions
+namespace Rfc1738
+{
+
+extern const CharacterSet
+Unsafe,         // RFC 1738 unsafe set
+Ctrls,          // CTL characters (\0x00 to \0x1f)
+UnsafeAndCtrls, // RFC 1738 Unsafe and Ctrls
+Unescaped,      // ctrls and unsafe (except for percent symbol)
+Reserved;       // RFC 1738 Reserved set
+
+extern const char *toHexTable[256];
+extern const int16_t fromHexTable[256];
+
+/// \return the numeric representation of the HEXDIG argument ch, or -1 if invalid.
+inline const int16_t
+FromHex(unsigned char ch)
+{
+    // no need to check bounds, the lookup table has 256 entries
+    return fromHexTable[ch];
+}
+
+/// \return a static 2-char zero-terminated buffer with a HEXDIG
+///         representation of argument c
+inline const char*
+ToHex(const unsigned char c)
+{
+    // no need to check bounds, the lookup table has 256 entries
+    return toHexTable[c];
+}
+
+} // namespace Rfc1738
+
+/// RFC 3986 symbol and charset definitions
+namespace Rfc3986
+{
+
+extern const CharacterSet
+GenDelims,// RFC 3986 gen-delims set
+SubDelims,// RFC 3986 sub-delims set
+Reserved, // RFC 3986 reserved characters set
+Unreserved, // RFC 3986 unreserved characters set
+All;
+
+template &lt;class Str&gt;
+Str
+Escape(const Str &amp;s, const CharacterSet &amp;escapeChars = Rfc1738::UnsafeAndCtrls)
+{
+    Str rv;
+    bool didEscape = false;
+    // XXX: SBuf lacking reserve(N)
+    // rv.reserve(s.length()*2); //TODO: optimize arbitrary constant
+    for (const auto c : s) {
+        if (escapeChars[c]) {
+            rv.push_back('%');
+            const char *hex = Rfc1738::ToHex(c);
+            rv.push_back(hex[0]);
+            rv.push_back(hex[1]);
+            didEscape = true;
+        } else {
+            rv.push_back(c);
+        }
+    }
+    if (didEscape)
+        return rv;
+    else
+        return s;
+}
+
+/** unescape a percent-encoded string
+ *
+ * API-compatible with std::string and SBuf
+ */
+template &lt;class Str&gt;
+Str
+Unescape(const Str &amp;s)
+{
+    typename Str::size_type pos=s.find('%');
+    if (pos == Str::npos)
+        return s;
+    Str rv;
+    // rv.reserve(s.length()); // XXX: SBuf lacking reserve(N)
+    const auto e = s.end();
+    for (auto in = s.begin(); in != e; ++in) {
+        if (*in != '%') { // normal case, copy and continue
+            rv.push_back(*in);
+            continue;
+        }
+        auto ti = in;
+        ++ti;
+        if (ti == e) { // String ends in %
+            rv.push_back(*in);
+            break;
+        }
+        if (*ti == '%') { //double '%' escaping
+            rv.push_back(*in);
+            ++in;
+            continue;
+        }
+        const int v1 = Rfc1738::FromHex(*ti);
+        if (v1 &lt; 0) { // decoding failed at first hextdigit
+            rv.push_back(*in);
+            continue;
+        }
+        ++ti;
+        if (ti == e) { // String ends in '%[[:hexdigit:]]'
+            rv.push_back(*in);
+            continue;
+        }
+        const int v2 = Rfc1738::FromHex(*ti);
+        if (v2 &lt; 0) { // decoding failed at second hextdigit
+            rv.push_back(*in);
+            continue;
+        }
+        const int x = v1 &lt;&lt; 4 | v2;
+        if (x &gt; 0 &amp;&amp; x &lt;= 255) {
+            rv.push_back(static_cast&lt;char&gt;(x));
+            ++in;
+            ++in;
+            continue;
+        }
+        rv.push_back(*in);
+    }
+    return rv;
+}
+
+} // namespace Rfc3986
+
+#endif /* SQUID_SRC_ANYP_RFC3986_H */
+

=== added file 'src/tests/testRFC3986.cc'
--- src/tests/testRFC3986.cc	1970-01-01 00:00:00 +0000
+++ src/tests/testRFC3986.cc	2016-02-10 15:30:17 +0000
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include &quot;squid.h&quot;
+#include &quot;anyp/Rfc3986.h&quot;
+#include &quot;rfc1738.h&quot;
+#include &quot;SBuf.h&quot;
+#include &quot;testRFC3986.h&quot;
+#include &quot;unitTestMain.h&quot;
+
+#include &lt;cassert&gt;
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testRFC3986 );
+
+static void
+performDecodingTest(const std::string &amp;encoded_str, const std::string &amp;plaintext_str)
+{
+    std::string decoded_str = Rfc3986::Unescape(encoded_str);
+    CPPUNIT_ASSERT_EQUAL(plaintext_str, decoded_str);
+
+    SBuf encoded_sbuf(encoded_str);
+    SBuf plaintext_sbuf(plaintext_str);
+    SBuf decoded_sbuf = Rfc3986::Unescape(encoded_sbuf);
+    CPPUNIT_ASSERT_EQUAL(plaintext_sbuf, decoded_sbuf);
+}
+
+/* Regular Format de-coding tests */
+void testRFC3986::testUrlDecode()
+{
+    performDecodingTest(&quot;%2Fdata%2Fsource%2Fpath&quot;,&quot;/data/source/path&quot;);
+    performDecodingTest(&quot;<A HREF="http://foo.invalid%2Fdata%2Fsource%2Fpath">http://foo.invalid%2Fdata%2Fsource%2Fpath</A>&quot;,
+                        &quot;<A HREF="http://foo.invalid/data/source/path">http://foo.invalid/data/source/path</A>&quot;);
+    // TODO query string
+
+    performDecodingTest(&quot;1 w%0Ard&quot;,&quot;1 w\nrd&quot;); // Newline %0A encoded
+    performDecodingTest(&quot;2 w%rd&quot;,&quot;2 w%rd&quot;); // Un-encoded %
+    performDecodingTest(&quot;3 w%%rd&quot;,&quot;3 w%rd&quot;); // encoded %
+    performDecodingTest(&quot;5 Bad String %1&quot;,&quot;5 Bad String %1&quot;); // corrupt string
+    performDecodingTest(&quot;6 Bad String %1A%3&quot;,&quot;6 Bad String \032%3&quot;); //partly corrupt string
+    performDecodingTest(&quot;7 Good String %1A&quot;,&quot;7 Good String \032&quot;); // non corrupt string
+    //test various endings
+    performDecodingTest(&quot;8 word%&quot;,&quot;8 word%&quot;);
+    performDecodingTest(&quot;9 word%z&quot;,&quot;9 word%z&quot;);
+    performDecodingTest(&quot;10 word%1&quot;,&quot;10 word%1&quot;);
+    performDecodingTest(&quot;11 word%1q&quot;,&quot;11 word%1q&quot;);
+    performDecodingTest(&quot;12 word%1a&quot;,&quot;12 word\032&quot;);
+}
+
+// perform a test for std::string, SBuf and if rfc1738flag is != 0 compare
+//  against rfc1738 implementation
+static void
+performEncodingTest(const char *plaintext_str, const char *encoded_str, int rfc1738flag, const CharacterSet  &amp;rfc3986CSet)
+{
+    CPPUNIT_ASSERT_EQUAL(std::string(encoded_str), Rfc3986::Escape(std::string(plaintext_str), rfc3986CSet));
+    CPPUNIT_ASSERT_EQUAL(SBuf(encoded_str), Rfc3986::Escape(SBuf(plaintext_str), rfc3986CSet));
+    if (!rfc1738flag)
+        return;
+    char *result = rfc1738_do_escape(plaintext_str, rfc1738flag);
+    CPPUNIT_ASSERT_EQUAL(std::string(encoded_str), std::string(result));
+}
+
+void testRFC3986::testUrlEncode()
+{
+    /* TEST: Escaping only unsafe characters */
+    performEncodingTest(&quot;<A HREF="http://foo.invalid/data/source/path">http://foo.invalid/data/source/path</A>&quot;,
+                        &quot;<A HREF="http://foo.invalid/data/source/path">http://foo.invalid/data/source/path</A>&quot;,
+                        RFC1738_ESCAPE_UNSAFE, Rfc1738::Unsafe);
+
+    /* regular URL (no encoding needed) */
+    performEncodingTest(&quot;<A HREF="http://foo.invalid/data/source/path">http://foo.invalid/data/source/path</A>&quot;,
+                        &quot;<A HREF="http://foo.invalid/data/source/path">http://foo.invalid/data/source/path</A>&quot;,
+                        RFC1738_ESCAPE_UNSAFE, Rfc1738::Unsafe);
+
+    /* long string of unsafe # characters */
+    performEncodingTest(&quot;################ ################ ################ ################ ################ ################ ################ ################&quot;,
+                        &quot;%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%20%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23%23&quot;,
+                        RFC1738_ESCAPE_UNSAFE, Rfc1738::Unsafe);
+
+    /* TEST: escaping only reserved characters */
+
+    /* regular URL (full encoding requested) */
+    performEncodingTest(&quot;<A HREF="http://foo.invalid/data/source/path">http://foo.invalid/data/source/path</A>&quot;,
+                        &quot;http%3A%2F%2Ffoo.invalid%2Fdata%2Fsource%2Fpath&quot;,
+                        RFC1738_ESCAPE_RESERVED, Rfc3986::Reserved);
+
+    /* regular path (encoding wanted for ALL special chars) */
+    performEncodingTest(&quot;/data/source/path&quot;,
+                        &quot;%2Fdata%2Fsource%2Fpath&quot;,
+                        RFC1738_ESCAPE_RESERVED, Rfc3986::Reserved);
+
+    /* TEST: safety-escaping a string already partially escaped */
+
+    /* escaping of dangerous characters in a partially escaped string */
+    performEncodingTest(&quot;<A HREF="http://foo.invalid/data%2Fsource[">http://foo.invalid/data%2Fsource[</A>]&quot;,
+                        &quot;<A HREF="http://foo.invalid/data%2Fsource%5B%5D">http://foo.invalid/data%2Fsource%5B%5D</A>&quot;,
+                        RFC1738_ESCAPE_UNESCAPED, Rfc1738::Unescaped);
+
+    /* escaping of hexadecimal 0xFF characters in a partially escaped string */
+    performEncodingTest(&quot;<A HREF="http://foo.invalid/data%2Fsource\xFF\xFF">http://foo.invalid/data%2Fsource\xFF\xFF</A>&quot;,
+                        &quot;<A HREF="http://foo.invalid/data%2Fsource%FF%FF">http://foo.invalid/data%2Fsource%FF%FF</A>&quot;,
+                        RFC1738_ESCAPE_UNESCAPED, Rfc1738::Unescaped);
+}
+
+/** SECURITY BUG TESTS: avoid null truncation attacks by skipping %00 bytes */
+void testRFC3986::PercentZeroNullDecoding()
+{
+    /* Attack with %00 encoded NULL */
+    performDecodingTest(&quot;w%00rd&quot;, &quot;w%00rd&quot;);
+
+    /* Attack with %0 encoded NULL */
+    performDecodingTest(&quot;w%0rd&quot;, &quot;w%0rd&quot;);
+
+    /* Handle '0' bytes embeded in encoded % */
+    performDecodingTest(&quot;w%%00%rd&quot;, &quot;w%00%rd&quot;);
+
+    /* Handle NULL bytes with encoded % */
+    performDecodingTest(&quot;w%%%00%rd&quot;, &quot;w%%00%rd&quot;);
+}
+

=== added file 'src/tests/testRFC3986.h'
--- src/tests/testRFC3986.h	1970-01-01 00:00:00 +0000
+++ src/tests/testRFC3986.h	2016-02-10 15:43:56 +0000
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_LIB_TEST_RFC3986_H
+#define SQUID_LIB_TEST_RFC3986_H
+
+#include &lt;cppunit/extensions/HelperMacros.h&gt;
+
+/**
+ * Test the URL coder RFC 3986 Engine
+ */
+class testRFC3986 : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testRFC3986 );
+    CPPUNIT_TEST( testUrlDecode );
+    CPPUNIT_TEST( testUrlEncode );
+    CPPUNIT_TEST( PercentZeroNullDecoding );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    void testUrlDecode();
+    void testUrlEncode();
+
+    // bugs.
+    void PercentZeroNullDecoding();
+};
+
+#endif /* SQUID_LIB_TEST_RFC3986_H */
+

</PRE>

























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005083.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
	<LI>Next message: <A HREF="005116.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5115">[ date ]</a>
              <a href="thread.html#5115">[ thread ]</a>
              <a href="subject.html#5115">[ subject ]</a>
              <a href="author.html#5115">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
