<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Squid: Small packets and low performance between	squid and icap
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%3A%20Small%20packets%20and%20low%20performance%20between%0A%09squid%20and%20icap&In-Reply-To=%3CCAMFQPn8_gPj-T4Hi80ahNuQEQPHkAL-p_GqrUkeU%2BTA97hmmVg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005142.html">
   <LINK REL="Next"  HREF="005156.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Squid: Small packets and low performance between	squid and icap</H1>
    <B>Prashanth Prabhu</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%3A%20Small%20packets%20and%20low%20performance%20between%0A%09squid%20and%20icap&In-Reply-To=%3CCAMFQPn8_gPj-T4Hi80ahNuQEQPHkAL-p_GqrUkeU%2BTA97hmmVg%40mail.gmail.com%3E"
       TITLE="[squid-dev] Squid: Small packets and low performance between	squid and icap">prashanth.prabhu at gmail.com
       </A><BR>
    <I>Wed Feb 17 00:55:37 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005142.html">[squid-dev] Squid: Small packets and low performance between	squid and icap
</A></li>
        <LI>Next message: <A HREF="005156.html">[squid-dev] Squid: Small packets and low performance between	squid and icap
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5146">[ date ]</a>
              <a href="thread.html#5146">[ thread ]</a>
              <a href="subject.html#5146">[ subject ]</a>
              <a href="author.html#5146">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>[+ squid-dev; bcc ssquid-users]

Hi Alex,

Sorry about the late reply.

Please see inline.

&gt;&gt;<i> Here's the behavior I have seen: When the connection is set up, the
</I>&gt;&gt;<i> buffer gets a size of 16KB (default). Squid reads from the socket,
</I>&gt;&gt;<i> parses the data, and then sends it towards c-icap as appropriate. Now,
</I>&gt;&gt;<i> as part of parsing the data, the buffer is NUL-terminated via a call
</I>&gt;&gt;<i> to c_str(). This NUL-termination, however, is not accounted for by an
</I>&gt;&gt;<i> increase in the &quot;offset&quot; (off) in the underlying MemBlob, therefore,
</I>&gt;&gt;<i> the offset and size go out of sync.
</I>&gt;<i>
</I>&gt;<i> Just to avoid a misunderstanding:
</I>&gt;<i>
</I>&gt;<i> * MemBlob does not have an &quot;offset&quot;.
</I>
Indeed. I was imprecise in my explanation -- the effect of drafting
email even as I was in the middle of investigating the code.

The c_str() code doesn't increment SBuf::len_. As a result the
MemBlob::canAppend() call, which takes in SBuf::off_ and SBuf::len_
doesn't match the MemBlob::size_, which was incremented as part of the
c_str() call.


&gt;<i> * A call to c_str() should not increase SBuf::len_  either because it
</I>&gt;<i> does not add a new character to the SBuf object. That call just
</I>&gt;<i> terminates the underlying buffer.
</I>
Well, without an increment of the MemBlob::size_ (or with an increment
to the SBuf::len_) this would have been OK. However, once that 'size_'
is incremented, we have the SBuf concept of how much buffer is used
being &quot;out of sync&quot; with the MemBlob's conception of buffer usage.

FWIW I don't quite understand how the NUL-char doesn't add a new
character to the SBuf object. Yes, it is terminating the string, but
in 'C' it is also a legit character. So, unclear what we are
attempting with this magic; or why. Seems to me, not incrementing
'len_' is a mistake.


&gt;<i> Single-owner optimizations aside (a known TODO), the above is the
</I>&gt;<i> desired behavior according to the documented c_str() guarantees:
</I>
Can you please explain or point me to a document that has more info
about this &quot;Single-owner&quot; optimization?

&gt;<i>
</I>&gt;&gt;<i>      * The returned value points to an internal location whose contents
</I>&gt;&gt;<i>      * are guaranteed to remain unchanged only until the next call
</I>&gt;&gt;<i>      * to a non-constant member function of the SBuf object.
</I>&gt;<i>
</I>&gt;<i> In other words, we cannot allow some _other_ SBuf object to overwrite
</I>&gt;<i> our null-termination character in the MemBlob we share with that other SBuf.
</I>&gt;<i>
</I>&gt;<i> The high price for that strong guarantee is one of the reasons we should
</I>&gt;<i> avoid c_str() calls in Squid code.
</I>
Note that the issue that I have explained is from a mostly stock squid
3.5.1 codebase. This isn't stemming from new c_str() calls added to
the codebase.


&gt;&gt;<i> When canAppend() fails, a new
</I>&gt;&gt;<i> buffer is re-allocated. When this reallocation occurs, however, the
</I>&gt;&gt;<i> new size of the buffer is dependent on the size being reserved.
</I>&gt;<i>
</I>&gt;<i> If we are still talking about the I/O buffer (and not just some random
</I>&gt;<i> SBuf string somewhere), then the I/O buffer _capacity_ should not shrink
</I>&gt;<i> below a certain minimum, regardless of how much content the buffer has
</I>&gt;<i> already stored. There should be some Squid code that ensures the minimum
</I>&gt;<i> capacity of the I/O buffer used to read requests. If it is missing, it
</I>&gt;<i> is a Squid bug.
</I>
It does shrink, as you can see from the debugs that I posted earlier.


&gt;&gt;<i> As a temporary measure, I have an experimental change that checks
</I>&gt;&gt;<i> whether the body size is known and if known always reserves a large
</I>&gt;&gt;<i> enough size (currently 16K).
</I>&gt;<i>
</I>&gt;<i> It is difficult to discuss this without seeing your changes, but the
</I>&gt;<i> reservation should probably be unconditional -- the I/O buffer capacity
</I>&gt;<i> should always be at least 16KB (or whatever size we start with).
</I>
Yes, that would be another way of fixing this issue.

I have posted the current changes that are currently working for the
most part below. It uses current capacity size as a heuristic to bump
size up. The diff also has some previous fixes, that were pointed out
to me on the thread, embedded in it.

---
diff --git a/3rdparty/squid-3.5.1/src/MemBlob.h b/3rdparty/squid-3.5.1/src/Mem
Blob.h
index b96330e..d265576 100644
--- a/3rdparty/squid-3.5.1/src/MemBlob.h
+++ b/3rdparty/squid-3.5.1/src/MemBlob.h
@@ -94,6 +94,8 @@ public:
     /// extends the available space to the entire allocated blob
     void clear() { size = 0; }

+    size_type currentCapacity() const { return (capacity); };
+
     /// dump debugging information
     std::ostream &amp; dump(std::ostream &amp;os) const;

diff --git a/3rdparty/squid-3.5.1/src/SBuf.cc b/3rdparty/squid-3.5.1/src/SBuf.
cc
index 53221d6..91886a0 100644
--- a/3rdparty/squid-3.5.1/src/SBuf.cc
+++ b/3rdparty/squid-3.5.1/src/SBuf.cc
@@ -76,7 +76,7 @@ SBufStats::operator +=(const SBufStats&amp; ss)
 SBuf::SBuf()
     : store_(GetStorePrototype()), off_(0), len_(0)
 {
-    debugs(24, 8, id &lt;&lt; &quot; created&quot;);
+    debugs(24, 8, id &lt;&lt; &quot; created, size=&quot; &lt;&lt; spaceSize());
     ++stats.alloc;
     ++stats.live;
 }
@@ -171,6 +171,7 @@ SBuf::rawSpace(size_type minSpace)
     // the store knows the last-used portion. If
     // it's available, we're effectively claiming ownership
     // of it. If it's not, we need to go away (realloc)
+    debugs(24, 7, &quot;off_=&quot; &lt;&lt; off_ &lt;&lt; &quot;; len_=&quot; &lt;&lt; len_ &lt;&lt; &quot;; size=&quot;
&lt;&lt; store_-&gt;size);
     if (store_-&gt;canAppend(off_+len_, minSpace)) {
         debugs(24, 7, &quot;not growing&quot;);
         return bufEnd();
diff --git a/3rdparty/squid-3.5.1/src/SBuf.h b/3rdparty/squid-3.5.1/src/SBuf.h
index ef77733..5bb3ef4 100644
--- a/3rdparty/squid-3.5.1/src/SBuf.h
+++ b/3rdparty/squid-3.5.1/src/SBuf.h
@@ -541,6 +541,8 @@ public:
     /// std::string export function
     std::string toStdString() const { return std::string(buf(),length()); }

+    size_type currentCapacity() const { return (store_-&gt;currentCapacity()); }
+
     // TODO: possibly implement erase() similar to std::string's erase
     // TODO: possibly implement a replace() call
 private:
diff --git a/3rdparty/squid-3.5.1/src/client_side.cc
b/3rdparty/squid-3.5.1/src/client_side.cc
index f2d0ce0..e191550 100644
--- a/3rdparty/squid-3.5.1/src/client_side.cc
+++ b/3rdparty/squid-3.5.1/src/client_side.cc
@@ -2347,6 +2348,9 @@ ConnStateData::In::maybeMakeSpaceAvailable()
             buf.reserveCapacity(wantCapacity);
         }
         debugs(33, 2, &quot;growing request buffer: available=&quot; &lt;&lt;
buf.spaceSize() &lt;&lt; &quot; used=&quot; &lt;&lt; buf.length());
+    } else if (buf.spaceSize() &lt; buf.currentCapacity() / 2) {
+        debugs(33, 2, &quot;growing request buffer: available=&quot; &lt;&lt;
buf.spaceSize() &lt;&lt; &quot; used=&quot; &lt;&lt; buf.length());
+        buf.reserveCapacity(CLIENT_REQ_BUF_SZ * 4);
     }
     return (buf.spaceSize() &gt;= 2);
 }
@@ -3244,6 +3248,7 @@ ConnStateData::clientReadRequest(const CommIoCbParams &amp;io)
      * Plus, it breaks our lame *HalfClosed() detection
      */

+    in.maybeMakeSpaceAvailable();
     CommIoCbParams rd(this); // will be expanded with ReadNow results
     rd.conn = io.conn;
     switch (Comm::ReadNow(rd, in.buf)) {
@@ -3354,11 +3359,13 @@ ConnStateData::handleRequestBodyData()
             return false;
         }
     } else { // identity encoding
-        debugs(33,5, HERE &lt;&lt; &quot;handling plain request body for &quot; &lt;&lt;
clientConnection);
-        putSize = bodyPipe-&gt;putMoreData(in.buf.c_str(), in.buf.length());
-        if (!bodyPipe-&gt;mayNeedMoreData()) {
-            // BodyPipe will clear us automagically when we produced everything
-            bodyPipe = NULL;
+        debugs(33,5, HERE &lt;&lt; &quot;handling plain request body for &quot; &lt;&lt;
clientConnection &lt;&lt; &quot;; len=&quot; &lt;&lt; in.buf.length());
+        if (in.buf.length() &gt; 0) {
+            putSize = bodyPipe-&gt;putMoreData(in.buf.c_str(), in.buf.length());
+            if (!bodyPipe-&gt;mayNeedMoreData()) {
+                // BodyPipe will clear us automagically when we
produced everything
+                bodyPipe = NULL;
+            }
         }
     }

@@ -3537,9 +3544,6 @@ ConnStateData::start()
     BodyProducer::start();
     HttpControlMsgSink::start();

-    // ensure a buffer is present for this connection
-    in.maybeMakeSpaceAvailable();
-
     if (port-&gt;disable_pmtu_discovery != DISABLE_PMTU_OFF &amp;&amp;
             (transparent() || port-&gt;disable_pmtu_discovery ==
DISABLE_PMTU_ALWAYS)) {
 #if defined(IP_MTU_DISCOVER) &amp;&amp; defined(IP_PMTUDISC_DONT)
---


Regards.
Prashanth

On 9 February 2016 at 13:54, Alex Rousskov
&lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
&gt;<i> [this should be on squid-dev instead]
</I>&gt;<i>
</I>&gt;<i> On 02/09/2016 01:20 PM, Prashanth Prabhu wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Here's the behavior I have seen: When the connection is set up, the
</I>&gt;&gt;<i> buffer gets a size of 16KB (default). Squid reads from the socket,
</I>&gt;&gt;<i> parses the data, and then sends it towards c-icap as appropriate. Now,
</I>&gt;&gt;<i> as part of parsing the data, the buffer is NUL-terminated via a call
</I>&gt;&gt;<i> to c_str(). This NUL-termination, however, is not accounted for by an
</I>&gt;&gt;<i> increase in the &quot;offset&quot; (off) in the underlying MemBlob, therefore,
</I>&gt;&gt;<i> the offset and size go out of sync.
</I>&gt;<i>
</I>&gt;<i> Just to avoid a misunderstanding:
</I>&gt;<i>
</I>&gt;<i> * MemBlob does not have an &quot;offset&quot;.
</I>&gt;<i>
</I>&gt;<i> * SBuf::off_ should not change when we are adding characters to SBuf
</I>&gt;<i> because it is the start of the buffer, not the end of it.
</I>&gt;<i>
</I>&gt;<i> * A call to c_str() should not increase SBuf::len_  either because it
</I>&gt;<i> does not add a new character to the SBuf object. That call just
</I>&gt;<i> terminates the underlying buffer.
</I>&gt;<i>
</I>&gt;<i> Based on your comments below, I think I know what you mean by &quot;go out of
</I>&gt;<i> sync&quot;, but everything is as &quot;in sync&quot; as it can be when one adds
</I>&gt;<i> termination characters that are not really there from SBuf::length()
</I>&gt;<i> point of view. The bug is elsewhere.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> MemBlob::canAppend() failing because
</I>&gt;&gt;<i> MemBlob::isAppendOffset() fails -- the 'off' and 'size' are not the
</I>&gt;&gt;<i> same due to the above c_str() call.
</I>&gt;<i>
</I>&gt;<i> Single-owner optimizations aside (a known TODO), the above is the
</I>&gt;<i> desired behavior according to the documented c_str() guarantees:
</I>&gt;<i>
</I>&gt;&gt;<i>      * The returned value points to an internal location whose contents
</I>&gt;&gt;<i>      * are guaranteed to remain unchanged only until the next call
</I>&gt;&gt;<i>      * to a non-constant member function of the SBuf object.
</I>&gt;<i>
</I>&gt;<i> In other words, we cannot allow some _other_ SBuf object to overwrite
</I>&gt;<i> our null-termination character in the MemBlob we share with that other SBuf.
</I>&gt;<i>
</I>&gt;<i> The high price for that strong guarantee is one of the reasons we should
</I>&gt;<i> avoid c_str() calls in Squid code.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> When canAppend() fails, a new
</I>&gt;&gt;<i> buffer is re-allocated. When this reallocation occurs, however, the
</I>&gt;&gt;<i> new size of the buffer is dependent on the size being reserved.
</I>&gt;<i>
</I>&gt;<i> If we are still talking about the I/O buffer (and not just some random
</I>&gt;<i> SBuf string somewhere), then the I/O buffer _capacity_ should not shrink
</I>&gt;<i> below a certain minimum, regardless of how much content the buffer has
</I>&gt;<i> already stored. There should be some Squid code that ensures the minimum
</I>&gt;<i> capacity of the I/O buffer used to read requests. If it is missing, it
</I>&gt;<i> is a Squid bug.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> As a temporary measure, I have an experimental change that checks
</I>&gt;&gt;<i> whether the body size is known and if known always reserves a large
</I>&gt;&gt;<i> enough size (currently 16K).
</I>&gt;<i>
</I>&gt;<i> It is difficult to discuss this without seeing your changes, but the
</I>&gt;<i> reservation should probably be unconditional -- the I/O buffer capacity
</I>&gt;<i> should always be at least 16KB (or whatever size we start with).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I></PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005142.html">[squid-dev] Squid: Small packets and low performance between	squid and icap
</A></li>
	<LI>Next message: <A HREF="005156.html">[squid-dev] Squid: Small packets and low performance between	squid and icap
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5146">[ date ]</a>
              <a href="thread.html#5146">[ thread ]</a>
              <a href="subject.html#5146">[ subject ]</a>
              <a href="author.html#5146">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
