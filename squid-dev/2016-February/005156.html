<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Squid: Small packets and low performance between	squid and icap
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%3A%20Small%20packets%20and%20low%20performance%20between%0A%09squid%20and%20icap&In-Reply-To=%3C56C4F68F.5020500%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005146.html">
   <LINK REL="Next"  HREF="005111.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Squid: Small packets and low performance between	squid and icap</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%3A%20Small%20packets%20and%20low%20performance%20between%0A%09squid%20and%20icap&In-Reply-To=%3C56C4F68F.5020500%40measurement-factory.com%3E"
       TITLE="[squid-dev] Squid: Small packets and low performance between	squid and icap">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Feb 17 22:39:11 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005146.html">[squid-dev] Squid: Small packets and low performance between	squid and icap
</A></li>
        <LI>Next message: <A HREF="005111.html">[squid-dev] Build failed in Jenkins: trunk-polygraph #945
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5156">[ date ]</a>
              <a href="thread.html#5156">[ thread ]</a>
              <a href="subject.html#5156">[ subject ]</a>
              <a href="author.html#5156">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/16/2016 05:55 PM, Prashanth Prabhu wrote:
&gt;&gt;<i> * A call to c_str() should not increase SBuf::len_  either because it
</I>&gt;&gt;<i> does not add a new character to the SBuf object. That call just
</I>&gt;&gt;<i> terminates the underlying buffer.
</I>&gt;<i> 
</I>&gt;<i> Well, without an increment of the MemBlob::size_ (or with an increment
</I>&gt;<i> to the SBuf::len_) this would have been OK. However, once that 'size_'
</I>&gt;<i> is incremented, we have the SBuf concept of how much buffer is used
</I>&gt;<i> being &quot;out of sync&quot; with the MemBlob's conception of buffer usage.
</I>
AFAICT, your definition of &quot;sync&quot; does not match the code's definition
of &quot;sync&quot;. You do not like something that the code does on purpose.


&gt;<i> FWIW I don't quite understand how the NUL-char doesn't add a new
</I>&gt;<i> character to the SBuf object. Yes, it is terminating the string, but
</I>&gt;<i> in 'C' it is also a legit character.
</I>
By definition, c_str() does not add any new characters to the SBuf
object. SBuf::c_str() is defined to leave SBuf contents (i.e., the
characters inside SBuf that you can access using SBuf public interfaces)
unchanged. You may not like that, but that is how this method is defined
to work. You may propose to change it (after making sure all callers are
fine with your change), or you may propose to add a new method.

FWIW, SBuf::c_str() models std::string::c_str() behavior.


&gt;<i> So, unclear what we are
</I>&gt;<i> attempting with this magic; or why. Seems to me, not incrementing
</I>&gt;<i> 'len_' is a mistake.
</I>
In many contexts, incrementing len_ will add an [extra] NUL character to
SBuf, and that NUL character will then be passed to other callers,
logged, written to HTTP agents, etc. Also, calling SBuf::c_str() twice
for the same SBuf object will add two NUL characters...

It would be possible to add an SBuf::terminate() method (or similar)
that does add a NUL character to SBuf, but that would be a different
method, used for different purposes.


&gt;&gt;<i> Single-owner optimizations aside (a known TODO), the above is the
</I>&gt;&gt;<i> desired behavior according to the documented c_str() guarantees:
</I>&gt;<i> 
</I>&gt;<i> Can you please explain or point me to a document that has more info
</I>&gt;<i> about this &quot;Single-owner&quot; optimization?
</I>
Please see MemBlob.h:

&gt;<i> bool canAppend(const size_type off, const size_type n) const {
</I>&gt;<i>     // TODO: ignore offset (and adjust size) when the blob is not shared?
</I>&gt;<i>     return isAppendOffset(off) &amp;&amp; willFit(n);
</I>&gt;<i> }
</I>
The TODO instructions are not very precise so please be careful to
preserve canAppend() functionality if you decide to optimize this.


&gt;&gt;&gt;<i>      * The returned value points to an internal location whose contents
</I>&gt;&gt;&gt;<i>      * are guaranteed to remain unchanged only until the next call
</I>&gt;&gt;&gt;<i>      * to a non-constant member function of the SBuf object.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In other words, we cannot allow some _other_ SBuf object to overwrite
</I>&gt;&gt;<i> our null-termination character in the MemBlob we share with that other SBuf.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The high price for that strong guarantee is one of the reasons we should
</I>&gt;&gt;<i> avoid c_str() calls in Squid code.
</I>&gt;<i> 
</I>&gt;<i> Note that the issue that I have explained is from a mostly stock squid
</I>&gt;<i> 3.5.1 codebase. This isn't stemming from new c_str() calls added to
</I>&gt;<i> the codebase.
</I>
Yes, IIRC, the issue you have described stems from a single c_str()
call, but there are many more (and growing) number of such calls, often
with poorly understood performance side effects.


&gt;<i> I have posted the current changes that are currently working for the
</I>&gt;<i> most part below. It uses current capacity size as a heuristic to bump
</I>&gt;<i> size up. The diff also has some previous fixes, that were pointed out
</I>&gt;<i> to me on the thread, embedded in it.
</I>

I will only comment on the change that seems to be directly related to
our recent discussion:

&gt;<i> +    } else if (buf.spaceSize() &lt; buf.currentCapacity() / 2) {
</I>&gt;<i> +        buf.reserveCapacity(CLIENT_REQ_BUF_SZ * 4);
</I>
&gt;<i>From performance point of view, this change is problematic long-term
</I>because reserveCapacity() guarantees single-ownership of the underlying
MemBlob and that guarantee is both expensive and not needed here. We
need a space to read, not single ownership. This is why rawSpace() was
added, BTW, but it is a little awkward to use in this context.

I am not sure what the best solution is (I do not have enough time to
study all the interactions and side effects), but we may need to either

A) add a new SBuf method (that does not provide such a guarantee) or
B) change in reserveCapacity() to remove the guarantee.

A study of current reserveCapacity() uses should determine the best of
the two options (if those two options are the best ones available).
After the new method is added or reserveCapacity() is changed, we should
call the new method or reserveCapacity() unconditionally, eliminating
most of your other patch changes.


HTH,

Alex.

</PRE>

















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005146.html">[squid-dev] Squid: Small packets and low performance between	squid and icap
</A></li>
	<LI>Next message: <A HREF="005111.html">[squid-dev] Build failed in Jenkins: trunk-polygraph #945
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5156">[ date ]</a>
              <a href="thread.html#5156">[ thread ]</a>
              <a href="subject.html#5156">[ subject ]</a>
              <a href="author.html#5156">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
