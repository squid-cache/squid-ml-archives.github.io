<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] implement RFC3986
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56CBAD9B.40209%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005183.html">
   <LINK REL="Next"  HREF="005085.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] implement RFC3986</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56CBAD9B.40209%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] implement RFC3986">rousskov at measurement-factory.com
       </A><BR>
    <I>Tue Feb 23 00:53:47 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005183.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
        <LI>Next message: <A HREF="005085.html">[squid-dev] [PATCH] SBuf const iterator fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5184">[ date ]</a>
              <a href="thread.html#5184">[ thread ]</a>
              <a href="subject.html#5184">[ subject ]</a>
              <a href="author.html#5184">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/22/2016 02:53 PM, Kinkie wrote:
&gt;<i> On Sun, Feb 21, 2016 at 4:51 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 02/20/2016 11:27 AM, Kinkie wrote:
</I>&gt;&gt;&gt;<i> Sorry to bring this topic up again, but honestly I don't understand
</I>&gt;&gt;&gt;<i> your position.
</I>
&gt;&gt;&gt;<i> I believe that the deadlock we currently are in
</I>
&gt;&gt;<i> There is no deadlock.
</I>&gt;&gt;<i> I am not bold enough to stop you from committing [your changes].
</I>
&gt;<i> Unfortunately there is: I am prepared to abandon this effort unless we
</I>&gt;<i> reach consensus - at least non-opposition. It'd be a pity, as it's an
</I>&gt;<i> useful feature.
</I>
This is not a deadlock. You have many possible ways forward, including:

1. Commit your changes despite my opinion.

2. Suspend your changes and work on the infrastructure to enable similar
functionality in the future but without the alleged drawbacks of the
current approach.

3. Work on changing my opinion.

I am not sure what you want from _me_ though. I have detailed my opinion
more than once. I am not blocking you. If, in addition to that, you also
want me to feel *happy* about the direction of your changes, then you
need to master remote mind control or come up with some other way to
change my opinion.


&gt;&gt;<i> I think helpers should use whatever works best for them, given the
</I>&gt;&gt;<i> available Squid APIs and other factors. The question is not about what
</I>&gt;&gt;<i> helpers should use but whether Squid code should bend over backwards
</I>&gt;&gt;<i> (e.g., providing a templated function to escape strings and adjust SBuf
</I>&gt;&gt;<i> to work with that function) to accommodate a helper. The answer, IMO, is
</I>&gt;&gt;<i> &quot;no&quot;. It is much better to
</I>&gt;<i> 
</I>&gt;&gt;<i> * provide SBuf to helpers that want top performance
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> and
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * provide a trivial std::string-escaping function (that uses
</I>&gt;&gt;<i> SBuf-escaping function internally) to helpers that want to use C-strings
</I>&gt;&gt;<i> or std::strings.
</I>

&gt;<i> Ok, I believe here is the crux of the issue.
</I>
I do not think so. The crux of the issue is that you are defending a
medium-size template function as a necessary and small evil, while I am
attacking the principle or direction of accommodating helper needs by
making Squid code worse.


&gt;<i> rfc3986 is a library; we
</I>&gt;<i> could split it into two versions, one to be used by helpers and one to
</I>&gt;<i> be used by squid. The two versions would be remarkably similar and
</I>&gt;<i> have a lot of code duplications, or as you propose be one an adapter
</I>&gt;<i> of the other.
</I>
Those are not the only two options, but yes, those two options do exist.


&gt;<i> An adapter exposing a std::string API and using SBuf internally would
</I>&gt;<i> be quite inefficient as it'd need to copy data back and forth.
</I>
Yes.


&gt;<i> Performance is not a big concern when it comes to helpers, 
</I>
There are probably Perl, Python, Javascript, etc. string-escaping
libraries available for helpers that are not especially concerned about
performance.


&gt;<i> but I argue that this approach would require more code, 
</I>
That depends. I do not think the wrapper/adapter approach requires more
code. It probably requires less code long-term. The wrapper itself is a
couple of simple lines. The SBuf-focused implementation may be even
shorter than the proposed template.

It is also a pretty vague statement. More code in headers where every
line ought to count as three (if we are counting lines)? No. More
duplicated code? No.

[ And if a helper uses either naked SBuf or some 3rd party std::string
library for escaping then there is no &quot;more code&quot; at all! ]


&gt;<i> be less efficient, and
</I>
Yes, but you said it is not a big concern during this discussion.


&gt;<i> increase coupling between squid and helpers than the template-based
</I>&gt;<i> approach.
</I>
Yes. Some might consider that to be a good thing for areas where helpers
and Squid have to do similar things.


&gt;<i> In order to clarify, when I talk about couplign I mean link-time
</I>&gt;<i> coupling. This can be directly understood from the list of objects
</I>&gt;<i> needed for testSBuf: between headers, objects and stubs that's about
</I>&gt;<i> 30 files (on top of the testSBuf files themselves).
</I>
If testSBuf has 30 dependencies, then I doubt testSBuf is a good example
of how things should be done. Overall, if we want helpers to use Squid
code, SBuf can be a part of the convenience library that can be linked
with helpers without 30 &quot;extra&quot; or &quot;stub&quot; files. The number of files in
that convenience library is pretty much irrelevant.


&gt;<i> I still can't see the long-term harm
</I>
Yes, that is why we disagree. You think the decision making stops with
your escape function. I think it starts there. Once Squid begins
accommodating helpers by doing crazy things like writing templated
functions to escape a string, it will be difficult to stop. There will
be more and more cases where a helper needs something from Squid, but
refuses to use Squid APIs to get it. And we will spend more and more
time on workarounds and Squid core changes just to make helpers happy.


&gt;<i> To the cost of repeating myself, we want a SBuf API for squid where
</I>&gt;<i> performance and COW matter a lot. I wish a std::string API for helpers
</I>
Yes, that is understood. I am not sure you would be happy when your wish
is granted though. It is not clear to me that helpers that we write in
C++ and that do things similar to what Squid does, should use something
other than SBuf that Squid should be using everywhere.


&gt;<i> to avoid having to link 30+ squid files and stubs for each helper
</I>&gt;<i> (object size is not a concern, it's more about maintaining this long
</I>&gt;<i> list of dependencies).
</I>
I am oversimplifying a little, but there should be only one dependency:
&quot;libsquidstring.la&quot; or &quot;libsquidbase.la&quot; or some other &quot;core&quot; library
like that. The number of files in that convenience library is not the
issue IMO because all of them are used by Squid anyway.

The correct first step, IMO, would be to fix the &quot;30 stubs&quot; problem
instead of working around that problem by creating templated escape
functions. Yes, the former is more difficult. Squid code is full of bugs
stemming from basic development principles violation because, in part,
it is &quot;easier&quot; to write code that way.


&gt;&gt;<i> If you are right about performance and safety across all helpers, then
</I>&gt;&gt;<i> there is no benefit in using SBuf in Squid.
</I>&gt;<i> 
</I>&gt;<i> Here I disagree. SBuf is relevant for squid. It is not for helpers.
</I>
Why is a faster string designed for parsing/packing not relevant to
helpers as far as performance and safety are concerned?


&gt;<i> It doesn't depend from cachemgr to work, but it links to it. This can
</I>&gt;<i> probably be refactored to decrease decoupling.
</I>
s/can probably be/should be/

And please note that we cannot use the usual &quot;it was broken before me&quot;
excuse because we created SBuf from scratch! It did not have to depend
on anything unrelated to SBuf, such as a cache manager, but it was
probably &quot;easier&quot; to create such dependencies than to avoid them.

Alex.

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005183.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
	<LI>Next message: <A HREF="005085.html">[squid-dev] [PATCH] SBuf const iterator fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5184">[ date ]</a>
              <a href="thread.html#5184">[ thread ]</a>
              <a href="subject.html#5184">[ subject ]</a>
              <a href="author.html#5184">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
