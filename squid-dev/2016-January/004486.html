<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SBuf API improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C8b39add516c01c6ee9be7b64a7bc7c6c%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004513.html">
   <LINK REL="Next"  HREF="004489.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SBuf API improvements</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C8b39add516c01c6ee9be7b64a7bc7c6c%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] SBuf API improvements">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jan  2 02:28:25 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004513.html">[squid-dev] [PATCH] improve CharacterSet
</A></li>
        <LI>Next message: <A HREF="004489.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4486">[ date ]</a>
              <a href="thread.html#4486">[ thread ]</a>
              <a href="subject.html#4486">[ subject ]</a>
              <a href="author.html#4486">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 2015-12-31 05:29, Alex Rousskov wrote:
&gt;<i> On 12/30/2015 03:42 AM, Kinkie wrote:
</I>&gt;&gt;<i> reserveSpace(n) is actually just
</I>&gt;&gt;<i> reserveCapacity(n+length()); what about simply getting rid of
</I>&gt;&gt;<i> reserveSpace and rename reserveCapacity to reserve? Minimum surprise
</I>&gt;&gt;<i> here for users here.
</I>&gt;<i> 
</I>&gt;<i> I will use reductio ad absurdum to highlight what I perceive as a flaw
</I>&gt;<i> in your question:
</I>&gt;<i> 
</I>&gt;<i> C++ is just assembly language with a few keywords and curly braces
</I>&gt;<i> added. What about getting rid of those keywords and curly braces and
</I>&gt;<i> just using pure assembly? Minimum surprise for users!
</I>&gt;<i> 
</I>
By the considerations I use to judge whether a helper submission is 
suitable assembly is one language that could indeed pass for acceptance.

It would probably fail on the readability, and code safety 
considerations. But that depends on the specific helper design. The 
language itself is portable enough not to be a reason for rejection in 
itself.


&gt;<i> Yes, you can remove protections, but that usually results in a 
</I>&gt;<i> different
</I>&gt;<i> kind of surprises -- the ones you want to avoid the most. I am pretty
</I>&gt;<i> sure that given a statistically significant sample, the amount of buggy
</I>&gt;<i> code calling reserve(length() + n) would be significantly larger than
</I>&gt;<i> the amount of buggy code code calling reserveSpace(n).
</I>
Maybe I'm missing something over the last few days discussion, but why 
does reserve(length() + n) imply bugs?
  I was of the understanding that this proposal was to make that the 
right/only way to reserve ?


&gt;<i> 
</I>&gt;&gt;<i> I wouldn't call them &quot;tightly integrated&quot; but simply
</I>&gt;&gt;<i> &quot;bundled&quot;. What I'm trying to do is to make them more readable, secure
</I>&gt;&gt;<i> and adaptable first by using c++ in place of the c-with-thin-c++-paint
</I>&gt;&gt;<i> they currently are coded as. Making them more maintainable, hopefully
</I>&gt;&gt;<i> robust and readable is the main goal. In fact, as we can assume that
</I>&gt;&gt;<i> they will be used as reference by others writing their own helpers,
</I>&gt;&gt;<i> it's in everyone's best interests if they are as readable and compact
</I>&gt;&gt;<i> as possible.
</I>&gt;<i> 
</I>&gt;<i> If your goals are readability and adaptability combined with the ease 
</I>&gt;<i> of
</I>&gt;<i> distribution, a scripting language may work [much] better than C++.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Let's consider mempools for instance. Having a build-time, static,
</I>&gt;&gt;<i> mechanism which can prevent linking against mempools is IMO tricky and
</I>&gt;&gt;<i> fragile;
</I>
Lets not. Except to confirm that the bundled C/C++ helpers are not and 
will not depend on mempools or any other src/ code.

Enforcing that dependency separation is a major reason why I moved the 
helpers/ directory to build before src/ all those years ago in the first 
place.

Further enforcing the split and reducing the remaining build issues is 
part of why I moved the mempools from include/lib to src/mem/ more 
recently.

&gt;<i> 
</I>&gt;<i> It is difficult to argue efficiently with fuzzy characteristics like
</I>&gt;<i> &quot;tricky&quot; and &quot;fragile&quot;, but I think that making SBuf available without
</I>&gt;<i> mempools is better than making SBuf-driven algorithms generic. The
</I>&gt;<i> alternatives (such as generics) are not necessarily trickier or more
</I>&gt;<i> fragile, but nevertheless worse overall.
</I>&gt;<i> 
</I>
Nod. If anyone is looking at using heavyweight components of Squid (like 
mempools, SBuf etc) in the helpers then it is probably a situation where 
the helper is not a helper but a new mode of operation for Squid 
workers.

For example; Diskers ride that line of distinction - having a relatively 
small scope of operations (Store) but that scope is a heavyweight 
component. As compared to the diskd helper which does similar tasks but 
with simpler components.


&gt;<i> 
</I>&gt;&gt;<i> Let me restrict the scope to &quot;the C-ish and C++ helpers we bundle&quot;
</I>&gt;<i> 
</I>&gt;<i> It could have been worse. Imagine us bundling helpers written in
</I>&gt;<i> assembly. After you reject that image as obviously absurd, I hope you
</I>&gt;<i> will notice a funny aftertaste questions lingering for a few seconds:
</I>&gt;<i> Why are we bundling *C++* helpers? If we continue to bundle C++ 
</I>&gt;<i> helpers,
</I>&gt;<i> what does it say about our true goals with regard to bundled helper
</I>&gt;<i> qualities? Are we after ease of writing? Ease of reading? Ease of
</I>&gt;<i> adapting? Ease of maintaining? Ease of bundling? Performance?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Since Squid is (or should be) using standard encodings, I suspect 
</I>&gt;&gt;&gt;<i> there
</I>&gt;&gt;&gt;<i> are libraries and modules (for various programming languages) that
</I>&gt;&gt;&gt;<i> already provide appropriate encoding support. We would not have to
</I>&gt;&gt;&gt;<i> maintain any of those implementations.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> There are. However:
</I>&gt;<i> 
</I>&gt;<i> Please note that I was only talking about &quot;libraries and modules&quot; to 
</I>&gt;<i> use
</I>&gt;<i> with _helpers_, not with Squid proper.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> - the ones I could find seem to be quite generic, we have different
</I>&gt;&gt;<i> needs in different contexts
</I>&gt;<i> 
</I>&gt;<i> This item is too general to agree or disagree with.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> - impedence mismatch. These are either C or use std::string; this
</I>&gt;&gt;<i> generally means two more data-copies if we wish to use SBuf (or
</I>&gt;&gt;<i> std::string with a custom allocator)
</I>&gt;<i> 
</I>&gt;<i> I lost you here. If helpers wish to use SBuf, then they do not need 3rd
</I>&gt;<i> party libraries and Squid does not need to make its SBuf algorithms
</I>&gt;<i> generic. If helpers do not wish to use SBuf, then 3rd party libraries 
</I>&gt;<i> do
</I>&gt;<i> not introduce any extra copies (from SBufs).
</I>&gt;<i> 
</I>
Nod. IMO, the need for a third-party RFC1738/3986 coder library is 
primarily for the helpers, not Squid itself. We already have this 
adequate coder logic for Squid internals. Moving the helpers to a 
third-party library we can then adapt our custom logic for better 
suiting SBuf etc.

This both helps with simplifying the helpers dependency on Squid code 
and eases third-party helpers being written as they no longer have to 
cut-n-paste our rfc1738 code.

So, if you found a FOSS library that provides RFC1738/3986 encoding and 
supports std:string please look at adopting it for the helpers/ code.


&gt;<i> 
</I>&gt;&gt;<i> - finding one which is generally available on all OSes we care about
</I>&gt;&gt;<i> seems not trivial.
</I>&gt;<i> 
</I>&gt;<i> Agreed. We can add portability or ease of deployment to the bundled
</I>&gt;<i> helper criteria. It is a topic on its own!
</I>&gt;<i> 
</I>
Portability is already one of the main criteria for bundled helpers. But 
just important, not critical. What is critical is being able to detect 
the OS environments where they will fail to execute or build and avoid 
auto-enabling them.

&gt;<i> 
</I>&gt;&gt;&gt;<i> However, let's assume that our ultimate goal[1] is to ship fast,
</I>&gt;&gt;&gt;<i> production-quality helpers that are built without external 
</I>&gt;&gt;&gt;<i> dependencies
</I>&gt;&gt;&gt;<i> (i.e., built using Squid libraries) and that Squid code is (or will 
</I>&gt;&gt;&gt;<i> be)
</I>&gt;&gt;&gt;<i> using SBuf for most string and buffering operations.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> Quality helpers are likely to need a variety of string and buffering
</I>&gt;&gt;&gt;<i> operations. Which of the following approaches is better long-term?
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> A. Support a growing number of templated algorithms while making SBuf
</I>&gt;&gt;&gt;<i> API more and more interchangeable with std::string (while at the same
</I>&gt;&gt;&gt;<i> time providing a growing number of SBuf methods for raw buffer 
</I>&gt;&gt;&gt;<i> operations).
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> B. Make SBufs and SBuf-driven algorithms easily available in helpers 
</I>&gt;&gt;&gt;<i> by
</I>&gt;&gt;&gt;<i> making SBuf storage/memory backing (and any other current 
</I>&gt;&gt;&gt;<i> dependencies
</I>&gt;&gt;&gt;<i> on Squid core) easily replaceable with something that does not need 
</I>&gt;&gt;&gt;<i> any
</I>&gt;&gt;&gt;<i> integration with Squid core.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> To me, option B looks like the right overall direction.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Could be, but we'd then need to redesign mempools to be stub-able, or
</I>&gt;&gt;<i> templatize SBuf with an allocator and isolate it from mempools (I
</I>&gt;&gt;<i> focus on these as these are the dependency bringing in most baggage.
</I>&gt;<i> 
</I>&gt;<i> I hope there are better ways to get B because, IIRC, SBufs do not know
</I>&gt;<i> [much] about mempools. I am oversimplifying, but I suspect that
</I>&gt;<i> separating SBufs from needless hard-coded dependencies requires not 
</I>&gt;<i> much
</I>&gt;<i> more than providing a memAllocString() and memFreeString() function
</I>&gt;<i> implementations that do not depend on memory pools. After a bit of
</I>&gt;<i> cleanup, it would be just a matter of linking with the right object 
</I>&gt;<i> file
</I>&gt;<i> (Squid gets trueMem.o while helpers get fakeMem.o) or internal library.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Given the fact that we won't probably require many common algorithms,
</I>&gt;&gt;<i> I believe that A is not a bad an option as you do.
</I>&gt;<i> 
</I>&gt;<i> Glad you at least agree that A is bad. I know that is not enough to 
</I>&gt;<i> stop
</I>&gt;<i> you from implementing it, but I still hope that you will try to do B
</I>&gt;<i> instead.
</I>
Both A and B are bad.

I prefer C; ensuring helper code is a simple as possible with as few 
dependencies - *particularly* from the complex code within src/.


IMHO, our primary goal with these helpers is to provide good quality 
demo code for others to use as template for writing their own. With 
secondary goal of acting as a source of some ready-made helpers for 
common installation needs.

That places code readability (not quite quality), stand-alone 
simplicity, and performance/speed fir the first goal above language or 
portability. Though the latter two are still high importance as they 
pertain to the second goal.

The C++ nature of the helpers is due to our personal preferences for 
coding that way (more experienced dev attention and code quality etc) 
combined with the bundling providing a guarantee of C++ compiler being 
available (portability), nothing more.

Amos

</PRE>



























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004513.html">[squid-dev] [PATCH] improve CharacterSet
</A></li>
	<LI>Next message: <A HREF="004489.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4486">[ date ]</a>
              <a href="thread.html#4486">[ thread ]</a>
              <a href="subject.html#4486">[ subject ]</a>
              <a href="author.html#4486">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
