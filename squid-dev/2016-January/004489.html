<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SBuf API improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56881063.80609%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004486.html">
   <LINK REL="Next"  HREF="004491.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SBuf API improvements</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SBuf%20API%20improvements&In-Reply-To=%3C56881063.80609%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] SBuf API improvements">rousskov at measurement-factory.com
       </A><BR>
    <I>Sat Jan  2 18:01:07 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004486.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
        <LI>Next message: <A HREF="004491.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4489">[ date ]</a>
              <a href="thread.html#4489">[ thread ]</a>
              <a href="subject.html#4489">[ subject ]</a>
              <a href="author.html#4489">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/01/2016 07:28 PM, Amos Jeffries wrote:
&gt;<i> On 2015-12-31 05:29, Alex Rousskov wrote:
</I>&gt;&gt;<i> Yes, you can remove protections, but that usually results in a different
</I>&gt;&gt;<i> kind of surprises -- the ones you want to avoid the most. I am pretty
</I>&gt;&gt;<i> sure that given a statistically significant sample, the amount of buggy
</I>&gt;&gt;<i> code calling reserve(length() + n) would be significantly larger than
</I>&gt;&gt;<i> the amount of buggy code code calling reserveSpace(n).
</I>&gt;<i> 
</I>&gt;<i> Maybe I'm missing something over the last few days discussion, but why
</I>&gt;<i> does reserve(length() + n) imply bugs?
</I>
I did not say imply, but this is just a basic design principle: When a
developer is forced to compute something, the probability that the
developer computes (or the reviewer reads) something wrong goes up. In
this particular case, it is easy to forget to compute the sum or get the
length() from the wrong buffer for example.


&gt;<i> Lets not. Except to confirm that the bundled C/C++ helpers are not and
</I>&gt;<i> will not depend on mempools or any other src/ code.
</I>
I agree that bundled helpers should not depend on mempools (but probably
not for the reasons you think they should not).

As for the separation of ./lib and ./src/, it should be driven by things
other than the names of those directories. If we want to write powerful
C++ helpers, the current separation is wrong because it forces Kinkie to
generalize SBuf-driven algorithms to work with std::strings.


&gt;<i> Nod. If anyone is looking at using heavyweight components of Squid (like
</I>&gt;<i> mempools, SBuf etc) in the helpers then it is probably a situation where
</I>&gt;<i> the helper is not a helper but a new mode of operation for Squid workers.
</I>
I do not consider SBuf component &quot;heavy&quot; but perhaps our definition of
&quot;heavy&quot; differs.



&gt;&gt;&gt;&gt;<i> Since Squid is (or should be) using standard encodings, I suspect there
</I>&gt;&gt;&gt;&gt;<i> are libraries and modules (for various programming languages) that
</I>&gt;&gt;&gt;&gt;<i> already provide appropriate encoding support. We would not have to
</I>&gt;&gt;&gt;&gt;<i> maintain any of those implementations.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> There are. However:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please note that I was only talking about &quot;libraries and modules&quot; to use
</I>&gt;&gt;<i> with _helpers_, not with Squid proper.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> - the ones I could find seem to be quite generic, we have different
</I>&gt;&gt;&gt;<i> needs in different contexts
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This item is too general to agree or disagree with.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> - impedence mismatch. These are either C or use std::string; this
</I>&gt;&gt;&gt;<i> generally means two more data-copies if we wish to use SBuf (or
</I>&gt;&gt;&gt;<i> std::string with a custom allocator)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I lost you here. If helpers wish to use SBuf, then they do not need 3rd
</I>&gt;&gt;<i> party libraries and Squid does not need to make its SBuf algorithms
</I>&gt;&gt;<i> generic. If helpers do not wish to use SBuf, then 3rd party libraries do
</I>&gt;&gt;<i> not introduce any extra copies (from SBufs).
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Nod. IMO, the need for a third-party RFC1738/3986 coder library is
</I>&gt;<i> primarily for the helpers, not Squid itself. We already have this
</I>&gt;<i> adequate coder logic for Squid internals. Moving the helpers to a
</I>&gt;<i> third-party library we can then adapt our custom logic for better
</I>&gt;<i> suiting SBuf etc.
</I>&gt;<i> 
</I>&gt;<i> This both helps with simplifying the helpers dependency on Squid code
</I>&gt;<i> and eases third-party helpers being written as they no longer have to
</I>&gt;<i> cut-n-paste our rfc1738 code.
</I>&gt;<i> 
</I>&gt;<i> So, if you found a FOSS library that provides RFC1738/3986 encoding and
</I>&gt;<i> supports std:string please look at adopting it for the helpers/ code.
</I>

I disagree that using two encoding libraries (one for Squid proper and
one for bundled helpers) is the best solution. If possible, I would
recommend using one encoding library for both Squid proper and helpers.
That direction implies an SBuf-driven library and SBuf use in C++ helpers.


&gt;&gt;&gt;&gt;<i> However, let's assume that our ultimate goal[1] is to ship fast,
</I>&gt;&gt;&gt;&gt;<i> production-quality helpers that are built without external dependencies
</I>&gt;&gt;&gt;&gt;<i> (i.e., built using Squid libraries) and that Squid code is (or will be)
</I>&gt;&gt;&gt;&gt;<i> using SBuf for most string and buffering operations.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Quality helpers are likely to need a variety of string and buffering
</I>&gt;&gt;&gt;&gt;<i> operations. Which of the following approaches is better long-term?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> A. Support a growing number of templated algorithms while making SBuf
</I>&gt;&gt;&gt;&gt;<i> API more and more interchangeable with std::string (while at the same
</I>&gt;&gt;&gt;&gt;<i> time providing a growing number of SBuf methods for raw buffer
</I>&gt;&gt;&gt;&gt;<i> operations).
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> B. Make SBufs and SBuf-driven algorithms easily available in helpers by
</I>&gt;&gt;&gt;&gt;<i> making SBuf storage/memory backing (and any other current dependencies
</I>&gt;&gt;&gt;&gt;<i> on Squid core) easily replaceable with something that does not need any
</I>&gt;&gt;&gt;&gt;<i> integration with Squid core.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> To me, option B looks like the right overall direction.
</I>

&gt;<i> Both A and B are bad.
</I>&gt;<i> 
</I>&gt;<i> I prefer C; ensuring helper code is a simple as possible with as few
</I>&gt;<i> dependencies - *particularly* from the complex code within src/.
</I>
Option C implies re-implementing encoding algorithms just to avoid
dependencies. This may be the worst option of all three. No matter what
you do, the helpers will depend on common encoding algorithms (and other
things). Either you make the helpers depend on Squid code or on some
external libraries. This logic applies to both C++ and non-C++ helpers
(except non-C++ helpers should not depend on Squid code, of course).


&gt;<i> IMHO, our primary goal with these helpers is to provide good quality
</I>&gt;<i> demo code for others to use as template for writing their own. With
</I>&gt;<i> secondary goal of acting as a source of some ready-made helpers for
</I>&gt;<i> common installation needs.
</I>
All three options (A, B, and C) can more-or-less satisfy the above vague
criteria, although I doubt that &quot;good quality demo helper code&quot; should
be written in C++.

Alex.

</PRE>

























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004486.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
	<LI>Next message: <A HREF="004491.html">[squid-dev] [PATCH] SBuf API improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4489">[ date ]</a>
              <a href="thread.html#4489">[ thread ]</a>
              <a href="subject.html#4489">[ subject ]</a>
              <a href="author.html#4489">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
