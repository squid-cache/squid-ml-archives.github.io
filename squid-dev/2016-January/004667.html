<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] The situation with helpers/
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20The%20situation%20with%20helpers/&In-Reply-To=%3C5696B88F.1080003%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004663.html">
   <LINK REL="Next"  HREF="004669.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] The situation with helpers/</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20The%20situation%20with%20helpers/&In-Reply-To=%3C5696B88F.1080003%40treenet.co.nz%3E"
       TITLE="[squid-dev] [RFC] The situation with helpers/">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Jan 13 20:50:23 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004663.html">[squid-dev] [RFC] The situation with helpers/
</A></li>
        <LI>Next message: <A HREF="004669.html">[squid-dev] [RFC] The situation with helpers/
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4667">[ date ]</a>
              <a href="thread.html#4667">[ thread ]</a>
              <a href="subject.html#4667">[ subject ]</a>
              <a href="author.html#4667">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 14/01/2016 4:43 a.m., Alex Rousskov wrote:
&gt;<i> On 01/13/2016 06:12 AM, Kinkie wrote:
</I>&gt;&gt;<i> On Tue, Jan 5, 2016 at 6:01 PM, Alex Rousskov
</I>&gt;&gt;<i> &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> On 01/04/2016 08:58 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> The SBuf and CharacterSet patch auditing has brought up the questions of
</I>&gt;&gt;&gt;&gt;<i> why helpers/ is separate from src/, built first, what cross-dependency
</I>&gt;&gt;&gt;&gt;<i> there can be, and even why we are bundling C++ helpers to begin with.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> So lets clarify it formally once and for all.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Q1: why is helpers/ built before src/ ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> A1: Primarily for historical and paranoia reasons.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Q2: why is helpers/ separate from src/ ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> A2: Primarily for historical and paranoia reasons.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> should we shuffle them back to src/*/helpers/ directories on a
</I>&gt;&gt;&gt;&gt;<i> per-component basis ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yes w.r.t. src/. There is no known good reason to enact artificial hard
</I>&gt;&gt;&gt;<i> barriers between parts of Squid code. All Squid code should be in src/.
</I>&gt;<i> 
</I>&gt;&gt;<i> Could or could not. For sure it would help with dependency tracking
</I>&gt;&gt;<i> where needed, and there are cases where it is needed.
</I>&gt;<i> 
</I>&gt;<i> Yes, that is one reason I said &quot;should&quot;, not &quot;could&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> * it does somewhat hinder anyone wanting to manually build a single
</I>&gt;&gt;&gt;&gt;<i> helper. Though I have not heard of anyone doing so in many years.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The move does not preclude anyone from building a helper. The fact that
</I>&gt;&gt;&gt;<i> a few more things may be built along the way is a minor detail IMO.
</I>&gt;&gt;&gt;<i> Patches to improve dependency tracking (by migrating away from recursive
</I>&gt;&gt;&gt;<i> Makefiles??) are welcomed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ugh. see src/Makefile.am for the monster file this would yield.
</I>&gt;<i> 
</I>&gt;<i> And see src/Makefile.am for the monster file the current
</I>&gt;<i> lets-track-complex-dependencies-manually approach has created. I do not
</I>&gt;<i> know exactly what the best solution to the current src/Makefile.am
</I>&gt;<i> problem is. I know that is a big problem. I suspect the solution
</I>&gt;<i> involves more than simply migrating away from recursive Makefiles. I do
</I>&gt;<i> not want to discuss that problem in this thread. That is why I said
</I>&gt;<i> exactly what I said, including the question marks.
</I>
Small side-track (sorry):

My experiments in fixing that makefile dependencies situation have
resulted in a few conclusions. Though nowhere near complete the
lp:~yadi/squid/makefile-deps branch has the latest version of what I
think it should look like.

* First stage, bar none is to simply stop adding new foo_DEPENDENCIES
lines to any .am file. We can/should/need all do that right now.

* Second stage is to remove existing *_DEPENDENCIES where possible. I
have found that needs to be done with care, bulk erasing or moving the
entris to LDADD lists is not always correct. The branch did it and a few
test binaries had inconsistent builds until their SOURCES were
corrected. Still not sure I got them all yet.

* Third stage is to reduce the SOURCES and LDADD lists to the actual
minimal set needed (maybe increase to full set needed). Stubs helps
there a lot, but a) some new ones are needed, b) some existing are
incorrect, and c) more/better use of the ones we have improves automake
results.

* Fourth stage I am experimenting with in the branch now is
non-recursive unit tests. By using src/*/UnitTest.am files we can have
the tests defined in their respective sudir, but actually built and run
non-recursive by the src/Makefile.

It is taking a lot of slow work to make happen. But so far shown some
good results with smaller unit tests and better dependency tracking
overall despite the mixed non-/recursive layout.

automake itself is migrating upstream to a model where it assumes
recursive Makefiles and deals better with those sometimes than
non-recursive. eg. the whole subdirs feature in 1.12+. So I do not think
moving away from recursive matters.

IMO the recursive design is better. We have to take care where we put
things in either case. But with recursive we can reduce the focus to
only the dirs, not every individual file in the sources.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> * it does mean we should probably discard the goal of having the helpers
</I>&gt;&gt;&gt;&gt;<i> be demo code examples for people to base their custom helpers on.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> The location of the helper code is pretty much irrelevant for the above
</I>&gt;&gt;&gt;<i> goal. However, if we want to provide demo helpers that are easy to
</I>&gt;&gt;&gt;<i> understand and customize, then we probably should not use C++ to write
</I>&gt;&gt;&gt;<i> those demo helpers.
</I>&gt;<i> 
</I>&gt;&gt;<i> I don't agree. We should use whatever tool makes sense, depending on
</I>&gt;&gt;<i> the availability of libraries, complexity, volunteer time etc.
</I>&gt;<i> 
</I>&gt;<i> Not sure what you do not agree with:
</I>&gt;<i> 
</I>&gt;<i> * Your statement does not contradict what I said about the location of
</I>&gt;<i> the helper code being pretty much irrelevant.
</I>&gt;<i> 
</I>&gt;<i> * If you are focusing on the second part of my statement, then please
</I>&gt;<i> note that it is possible, perhaps even likely that the &quot;tools&quot; that
</I>&gt;<i> &quot;make sense&quot; in our situation are not appropriate for some goals. When
</I>&gt;<i> that happens, the goals have to be re-evaluated to match reality so that
</I>&gt;<i> unrealistic goals do not misdirect our decisions.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> * If we want to provide the smallest set of default helpers for the
</I>&gt;&gt;&gt;<i> widest possible set of deployment environments, then internal
</I>&gt;&gt;&gt;<i> dependencies are preferred to the external ones and, hence, C++ is the
</I>&gt;&gt;&gt;<i> best language choice.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * If we want to provide default production-quality helpers for the most
</I>&gt;&gt;&gt;<i> demanding deployment environments, then internal dependencies are
</I>&gt;&gt;&gt;<i> irrelevant, and C++ is the best language choice. Please note that I do
</I>&gt;&gt;&gt;<i> not know whether it is wise to declare performance the primary goal,
</I>&gt;&gt;&gt;<i> given the performance deficiencies of the helper interface itself and
</I>&gt;&gt;&gt;<i> the current Squid Project resources.
</I>&gt;&gt;&gt;<i> Any open source helper can be examined, customized, and cloned, of
</I>&gt;&gt;&gt;<i> course. Our decision with regard to programming language and
</I>&gt;&gt;&gt;<i> dependencies may make it easier or more difficult, but not impossible.
</I>&gt;&gt;&gt;<i> It is a question of the primary optimization target: ease of
</I>&gt;&gt;&gt;<i> understanding/customizability versus supported platforms versus performance.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I believe our goals should be, in descending order of importance:
</I>&gt;&gt;<i> 1- cover a reasonable set of needs
</I>&gt;&gt;<i> 2- provide a gallery of examples for administrators who have special
</I>&gt;&gt;<i> needs not covered by the provided set of helpers. 
</I>&gt;<i> 
</I>&gt;<i> Goal #2, as stated, is not a goal but a side-effect: Whatever helpers we
</I>&gt;<i> provide to satisfy goal #1 will automatically become a &quot;gallery of
</I>&gt;<i> examples&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Corollaries of this objective are:
</I>&gt;&gt;<i> 2a- bundled helpers should aim at being as readable as possible.
</I>&gt;<i> 
</I>&gt;<i> Any code should aim at being as readable as possible so this statement
</I>&gt;<i> is not a corollary and does not really bring anything new to the debate.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> 2b- bundled helpers should try to avoid relying on Squid internal code
</I>&gt;&gt;<i> within reason. We can expect administrators embarking in the task to
</I>&gt;&gt;<i> be competent programmers, asking them to be also competent Squid
</I>&gt;&gt;<i> coders is maybe too much to ask.
</I>&gt;<i> 
</I>&gt;<i> Relying on Squid libraries/APIs is not that much different than relying
</I>&gt;<i> on external libraries/APIs. Thus, I disagree that a reasonable use of
</I>&gt;<i> Squid code in helpers forces helper writers to become competent Squid
</I>&gt;<i> coders. It is a question of how much use is &quot;reasonable&quot; given our
</I>&gt;<i> still-being-debated goals, of course.
</I>&gt;<i> 
</I>
Our Squid code is somewhat warped by its own transitional nature.
Improving, but not even close to being done yet. While competence in the
Squid code style may not be necessary in all cases, it usually is not as
easy to deal with as other code might be, just because of its
Squid-specific oddness.

I am more worried about the volatile nature of it though. Linking the
helpers to src/* means they are now even more dependent code that needs
to be managed whenever things are touched.

So the definition of &quot;reasonable use&quot; is one that has a lot of
importance. That is why I raised the &quot;heavyweight&quot; vs other Squid
components distinction earlier.

Amos


</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004663.html">[squid-dev] [RFC] The situation with helpers/
</A></li>
	<LI>Next message: <A HREF="004669.html">[squid-dev] [RFC] The situation with helpers/
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4667">[ date ]</a>
              <a href="thread.html#4667">[ thread ]</a>
              <a href="subject.html#4667">[ subject ]</a>
              <a href="author.html#4667">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
