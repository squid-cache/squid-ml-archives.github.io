<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] YesNoNone class updates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20YesNoNone%20class%20updates&In-Reply-To=%3C5697DA3E.5050802%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004672.html">
   <LINK REL="Next"  HREF="004678.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] YesNoNone class updates</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20YesNoNone%20class%20updates&In-Reply-To=%3C5697DA3E.5050802%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] YesNoNone class updates">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Jan 14 17:26:22 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004672.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
        <LI>Next message: <A HREF="004678.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4676">[ date ]</a>
              <a href="thread.html#4676">[ thread ]</a>
              <a href="subject.html#4676">[ subject ]</a>
              <a href="author.html#4676">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/13/2016 03:56 PM, Amos Jeffries wrote:
&gt;<i> On 13/01/2016 5:11 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 01/11/2016 06:36 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> Distinction is made between implicit and explicit configuration.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why do we need this increased complexity?
</I>
&gt;<i> This was written in context of using it to complete the final audit
</I>&gt;<i> request for the bug 4005 patch instead of multiple bools.
</I>
Noted, thank you.


&gt;&gt;&gt;<i> +bool
</I>&gt;&gt;&gt;<i> +YesNoNone::operator !() const
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +    assert(option != YesNoNone::optUnspecified);
</I>&gt;&gt;&gt;<i> +    return option == YesNoNone::optDisabled;
</I>&gt;&gt;&gt;<i>  }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please never reverse the existing operator bool code. Inline the
</I>&gt;&gt;<i> negation of that operator call instead.
</I>
[ excuses snipped without review ]

If you cannot simply negate the existing &quot;bool&quot; conversion operator, for
any reason, then you must not add the &quot;bool&quot; operator in the first place!


After further consideration, I think I can make an even stronger and
simpler rule for the logical not operator in new code:

There is one and only one reason to add a logical not operator to a
C++11 class: Optimization of a boolean conversion operator (for rare
cases where &quot;!foo&quot; is much faster to compute than &quot;foo&quot;).

Please correct me if I missed any other cases where an explicit logical
not operator should be added to a C++11 class.


&gt;<i> +    /** forbidden operation.
</I>&gt;<i> +     * Use x.configure(bool) when the value is configured.
</I>&gt;<i> +     * Use x = YesNoNone(bool) to assign defaults.
</I>&gt;<i> +     */
</I>&gt;<i> +    YesNoNone &amp;operator =(bool) = delete;
</I>
Why do we need to delete something that does not exist? If you do not
add the above code, do you really gain the ability to assign booleans to
YesNoNone objects? If not, please remove.


&gt;<i> +    uint8_t setWith; ///&lt; initialized instead of configured
</I>
Stale comment. Consider using &quot;how the value was set&quot; description instead.

Stale type. Should be SetWith AFAICT.


&gt;<i> +    enum SetWith : uint8_t { optUnspecified = 0, optImplicit = 1, optConfigured = 2 };
</I>

Why do we need to specify the exact enum storage size in this case? If
there is a good reason, please add a source code comment to explain. If
there is not, remove storage type specification.

BTW, if you need to minimize storage overhead at the expense of
value-testing performance, you can encode all the information (both
setWith and option members) in 8 bits, of course.

Please consider renaming SetWith to something that matches the enum
values better: &quot;set with configured&quot; does not work well. I suggest
&quot;SetHow&quot; and optUnspecified, optImplicitly, and optConfigured values.


&gt;<i> +    bool option; ///&lt; configured value or false
</I>
Or an implicitly set value. I would rephrase the description to
something like:

bool option; /// specified yes/no value; meaningless if optUnspecified


&gt;<i> +    bool option; ///&lt; configured value or false
</I>&gt;<i> +    uint8_t setWith; ///&lt; initialized instead of configured
</I>
Please reorder to minimize padding, especially if setWith type changes.



&gt;<i> +    Config.memShared = YesNoNone(false);
</I>&gt;<i> -        writeableCfg().connectionEncryption.configure(true);
</I>&gt;<i> +        writeableCfg().connectionEncryption = YesNoNone(true);
</I>
The new code that configures &quot;implicit&quot; values looks unnecessary
awkward/complex. I suggest adding a method to change the value (in
addition to the constructor):

    Config.memShared.defaultTo(false);
    writeableCfg().connectionEncryption.defaultTo(true);

As an added benefit, the method can throw if optConfigured values are
reset using defaultTo() calls!


&gt;<i> -YesNoNone::operator void*() const
</I>&gt;<i> -{
</I>&gt;<i> -    assert(option != 0); // must call configure() first
</I>&gt;<i> -    return option &gt; 0 ? (void*)this : NULL;
</I>&gt;<i> -}
</I>
&gt;<i> +    explicit operator bool() const {
</I>&gt;<i> +        assert(setWith != optUnspecified);
</I>&gt;<i> +        return option;
</I>&gt;<i> +    }
</I>
To reduce chances for getting another CVE for a reconfiguration crash, I
suggest that new configuration-related code does not assert() but throws
(e.g., via Must()). Whether that implies moving the above code back to
.cc file is your call.


&gt;<i> If there are no objections I will apply this patch and the bug 4005 fix
</I>&gt;<i> that depends on it tomorrow.
</I>
I object to the current YesNoNone patch, but I hope that the above
comments give you enough info to polish it without another review round.

FWIW, I have not seen a bug 4005 patch that depends on this. The old mk2
does not seem to use the changes introduced here. On the other hand, I
cannot promise to review the updated patch so others should decide
whether they have to see it before it goes in.


Thank you,

Alex.

</PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004672.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
	<LI>Next message: <A HREF="004678.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4676">[ date ]</a>
              <a href="thread.html#4676">[ thread ]</a>
              <a href="subject.html#4676">[ subject ]</a>
              <a href="author.html#4676">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
