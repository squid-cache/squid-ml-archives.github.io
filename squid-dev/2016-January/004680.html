<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] YesNoNone class updates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20YesNoNone%20class%20updates&In-Reply-To=%3C56982377.8080406%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004678.html">
   <LINK REL="Next"  HREF="004681.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] YesNoNone class updates</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20YesNoNone%20class%20updates&In-Reply-To=%3C56982377.8080406%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] YesNoNone class updates">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Jan 14 22:38:47 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004678.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
        <LI>Next message: <A HREF="004681.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4680">[ date ]</a>
              <a href="thread.html#4680">[ thread ]</a>
              <a href="subject.html#4680">[ subject ]</a>
              <a href="author.html#4680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/14/2016 12:31 PM, Amos Jeffries wrote:
&gt;<i> On 15/01/2016 6:26 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 01/13/2016 03:56 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 13/01/2016 5:11 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> On 01/11/2016 06:36 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> +    /** forbidden operation.
</I>&gt;&gt;&gt;<i> +     * Use x.configure(bool) when the value is configured.
</I>&gt;&gt;&gt;<i> +     * Use x = YesNoNone(bool) to assign defaults.
</I>&gt;&gt;&gt;<i> +     */
</I>&gt;&gt;&gt;<i> +    YesNoNone &amp;operator =(bool) = delete;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why do we need to delete something that does not exist? If you do not
</I>&gt;&gt;<i> add the above code, do you really gain the ability to assign booleans to
</I>&gt;&gt;<i> YesNoNone objects? If not, please remove.
</I>

&gt;<i> We have a bool constructor and implicit copy-assignment. Which tempts
</I>&gt;<i> the compiler to try bool constructing then copying. 
</I>
Fortunately, we do not have just any &quot;bool constructor&quot;. We have an
_explicit_ bool constructor which prohibits implicit &quot;bool constructing
then copying&quot;, no matter how tempting it might seem to the compiler.

What would be the purpose of marking the constructor &quot;explicit&quot; if the
imaginary conversion sequence you have described would still be
possible, depending on the compiler or other factors? [Rhetorical]

Please either remove the bool assignment operator (instead of deleting
what does not exist) or provide a use case where its deleted existence
changes something other than the compiler error message text.

FWIW, in my tests, without the operator, the errors look like this:

error: conversion from ‘bool’ to non-scalar type ‘YesNoNone’ requested


In this particular case, deleting what does not exist is just a minor
annoyance because the class is very simple and efficient. I am insisting
on this change because I do not want to create a precedent where folks
starting to =delete more and more stuff elsewhere, simply out of
irrational phobias, complicating an already complex code.

C++11 is supposed to make our life easier and our code safer, not force
us fear more black magic. It is not like we suddenly need to go through
all of our classes and =delete stuff because we now can or because we
now fear some new implicitly generated methods. A correctly written
C++09 class should continue to work correctly without =delete.


&gt;&gt;&gt;<i> +    bool option; ///&lt; configured value or false
</I>&gt;&gt;&gt;<i> +    uint8_t setWith; ///&lt; initialized instead of configured
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please reorder to minimize padding, especially if setWith type changes.
</I>

&gt;<i> Do you have a good way to test for that?
</I>
Since we are talking about reducing padding and not eliminating or
prohibiting it, I do not think there is such a way. You can test
manually, of course, but that is not a good way.

A good rule of thumb is to put boolean data members last.


&gt;&gt;<i> Please consider renaming SetWith to something that matches the enum
</I>&gt;&gt;<i> values better: &quot;set with configured&quot; does not work well. I suggest
</I>&gt;&gt;<i> &quot;SetHow&quot; and optUnspecified, optImplicitly, and optConfigured values.
</I>

&gt;<i> Sure. Done.
</I>
s/optImplicit/optImplicitly/:

 - Set how?
 - Implicitly.


&gt;&gt;&gt;<i> -YesNoNone::operator void*() const
</I>&gt;&gt;&gt;<i> -{
</I>&gt;&gt;&gt;<i> -    assert(option != 0); // must call configure() first
</I>&gt;&gt;&gt;<i> -    return option &gt; 0 ? (void*)this : NULL;
</I>&gt;&gt;&gt;<i> -}
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +    explicit operator bool() const {
</I>&gt;&gt;&gt;<i> +        assert(setWith != optUnspecified);
</I>&gt;&gt;&gt;<i> +        return option;
</I>&gt;&gt;&gt;<i> +    }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To reduce chances for getting another CVE for a reconfiguration crash, I
</I>&gt;&gt;<i> suggest that new configuration-related code does not assert() but throws
</I>&gt;&gt;<i> (e.g., via Must()). Whether that implies moving the above code back to
</I>&gt;&gt;<i> .cc file is your call.
</I>&gt;<i> 
</I>&gt;<i> I am a little wary that this could lead to mysterious uncaught
</I>&gt;<i> exceptions when these config values are tested by code outside the
</I>&gt;<i> AsyncCall protections.
</I>

&gt;<i>From a CVE point of view, mysterious uncaught exceptions are no worse
</I>than assertions. And if the exception is caught, then there are more
chances to avoid a CVE.

Forcing one of these exceptions by temporary modifying configuration
code and testing what actually happens is a good idea, but not a
prerequisite.

We do need code/instrumentation to convert admin-selected exception(s)
into assertions for debugging/triage (without recompiling Squid), but
that is a different topic and not a precondition for using exceptions in
new code IMO.


I do not think another round of reviews is needed.


HTH,

Alex.

</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004678.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
	<LI>Next message: <A HREF="004681.html">[squid-dev] [PATCH] YesNoNone class updates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4680">[ date ]</a>
              <a href="thread.html#4680">[ thread ]</a>
              <a href="subject.html#4680">[ subject ]</a>
              <a href="author.html#4680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
