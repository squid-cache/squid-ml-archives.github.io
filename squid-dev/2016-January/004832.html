<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] ftruncate() failures on OS X (Darwin)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20ftruncate%28%29%20failures%20on%20OS%20X%20%28Darwin%29&In-Reply-To=%3CCA%2BY8hcMw44UpPB%3DzkVf_d7kQXYgsO3zGshJ_87m1B-SuCZOtNg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004831.html">
   <LINK REL="Next"  HREF="004833.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] ftruncate() failures on OS X (Darwin)</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20ftruncate%28%29%20failures%20on%20OS%20X%20%28Darwin%29&In-Reply-To=%3CCA%2BY8hcMw44UpPB%3DzkVf_d7kQXYgsO3zGshJ_87m1B-SuCZOtNg%40mail.gmail.com%3E"
       TITLE="[squid-dev] ftruncate() failures on OS X (Darwin)">gkinkie at gmail.com
       </A><BR>
    <I>Thu Jan 21 05:53:52 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004831.html">[squid-dev] ftruncate() failures on OS X (Darwin)
</A></li>
        <LI>Next message: <A HREF="004833.html">[squid-dev] ftruncate() failures on OS X (Darwin)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4832">[ date ]</a>
              <a href="thread.html#4832">[ thread ]</a>
              <a href="subject.html#4832">[ subject ]</a>
              <a href="author.html#4832">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Great job!
Thank you
On Jan 21, 2016 6:34 AM, &quot;Markus Mayer&quot; &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">code at mmayer.net</A>&gt; wrote:

&gt;<i> There are several bug reports out there that squid is failing to start up
</I>&gt;<i> on OS X with an error similar to this:
</I>&gt;<i>
</I>&gt;<i> Ipc::Mem::Segment::create failed to ftruncate(/squid-cf__metadata.shm):
</I>&gt;<i> (22) Invalid argument
</I>&gt;<i>
</I>&gt;<i> It may be one of the other shared memory segments that is failing, but the
</I>&gt;<i> problem is always the same: upon restarting squid, ftruncate() bails with
</I>&gt;<i> EINVAL and squid subsequently aborts. If one is lucky and waits long
</I>&gt;<i> enough, restarting squid may eventually succeed. Or one may need to reboot.
</I>&gt;<i>
</I>&gt;<i> From what I was able to find, the root cause for this has never really
</I>&gt;<i> been determined, and there hasn't been a fix in squid that addresses this.
</I>&gt;<i> (It was still happening to me intermittently on OS X 10.11.2 and the most
</I>&gt;<i> recent squid from GIT.)
</I>&gt;<i>
</I>&gt;<i> So, I took some time to dig into this, down to first looking at the Darwin
</I>&gt;<i> kernel sources (
</I>&gt;<i> <A HREF="http://www.opensource.apple.com/source/xnu/xnu-3248.20.55/bsd/kern/posix_shm.c">http://www.opensource.apple.com/source/xnu/xnu-3248.20.55/bsd/kern/posix_shm.c</A>)
</I>&gt;<i> and subsequently downloading XNU, instrumenting posix_shm.c and running my
</I>&gt;<i> own custom built Darwin kernel (which was surprisingly straight forward).
</I>&gt;<i> Since there are several places where ftruncate() and, specifically,
</I>&gt;<i> pshm_truncate() can return EINVAL, instrumenting the kernel seemed to be
</I>&gt;<i> the most promising way of figuring out which EINVAL squid is hitting and
</I>&gt;<i> why.
</I>&gt;<i>
</I>&gt;<i> Turns out it's this one:
</I>&gt;<i>
</I>&gt;<i> if ((pinfo-&gt;pshm_flags &amp; (PSHM_DEFINED|PSHM_ALLOCATING|PSHM_ALLOCATED))
</I>&gt;<i> != PSHM_DEFINED) {
</I>&gt;<i> PSHM_SUBSYS_UNLOCK();
</I>&gt;<i> return(EINVAL);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> It happens because PSHM_ALLOCATED is already set. Luckily, the only place
</I>&gt;<i> where PSHM_ALLOCATED gets set is at the end of pshm_truncate() itself. So,
</I>&gt;<i> finding the culprit for setting it was easy.
</I>&gt;<i>
</I>&gt;<i> What this means is that OS X will only support ftruncate() *ONCE* on a shm
</I>&gt;<i> segment, and this is done fully on purpose. The first time pshm_truncate()
</I>&gt;<i> is called, it'll do all the required mapping and so forth, then set
</I>&gt;<i> PSHM_ALLOCATED for that segment. When one tries to call ftruncate() on the
</I>&gt;<i> same shm region again, it'll return EINVAL, because PSHM_ALLOCATED is set.
</I>&gt;<i>
</I>&gt;<i> There are cases where shm regions don't get removed when squid terminates.
</I>&gt;<i> So, upon restarting squid, shm_open() will return the already existing shm
</I>&gt;<i> segment (or segments) which will have been &quot;allocated&quot; already. squid will
</I>&gt;<i> try to call ftruncate() anyway -- and fail.
</I>&gt;<i>
</I>&gt;<i> Now, one could argue that OS X should really be able to handle ftruncate()
</I>&gt;<i> on an existing shm segment (like other POSIX systems do), and it probably
</I>&gt;<i> should. Convincing Apple of that is likely not going to be easy. Even if it
</I>&gt;<i> were to succeed, it would only fix future releases, not the current OS X
</I>&gt;<i> releases.
</I>&gt;<i>
</I>&gt;<i> So, I see the following solutions squid could implement, which could be
</I>&gt;<i> Darwin-only code, so as to not burden other OSes with this workaround.
</I>&gt;<i>
</I>&gt;<i> - Try to ensure squid can't leave shm segments behind when it terminates.
</I>&gt;<i> Not sure how realistic this is. It could always fail in a way that prevents
</I>&gt;<i> it from cleaning up after itself. Or somebody could send it a SIGKILL, in
</I>&gt;<i> which case it definitely couldn't clean up after itself.
</I>&gt;<i> - Simply accepting ftruncate() failing with EINVAL as non fatal condition
</I>&gt;<i> on OS X and continue. This would be easy to do, but there are several
</I>&gt;<i> different reasons why EINVAL may be returned. It wouldn't be a good idea to
</I>&gt;<i> continue in all those cases. So this won't really work reliably.
</I>&gt;<i> - Run statSize() on the memory segment after successfully opening it. If
</I>&gt;<i> the size returned is greater than 0, we know ftruncate() will fail on OS X,
</I>&gt;<i> because the segment isn't a new one. So, squid could call ftruncate() only
</I>&gt;<i> if size is 0 and maybe call memset() otherwise to zero it out.
</I>&gt;<i> - Just unconditionally call unlink() before shm_open(). If the segment
</I>&gt;<i> didn't exist, unlink() will fail, but that won't really matter. This would
</I>&gt;<i> likely take the least amount of code.
</I>&gt;<i> - Call shm_open with O_EXCL, so that it'll fail if the shm segment already
</I>&gt;<i> exists. If the call fails with EEXIST, unlink the shm segment and retry.
</I>&gt;<i> This one may not even need to be Darwin-specific. Would be unnecessary on
</I>&gt;<i> other platforms, but wouldn't really hurt.
</I>&gt;<i>
</I>&gt;<i> I did create a sample implementation of the last option. According to my
</I>&gt;<i> tests, it does seem to work as intended.
</I>&gt;<i>
</I>&gt;<i> --- a/src/ipc/mem/Segment.cc
</I>&gt;<i> +++ b/src/ipc/mem/Segment.cc
</I>&gt;<i> @@ -85,12 +85,31 @@ Ipc::Mem::Segment::Enabled()
</I>&gt;<i>  void
</I>&gt;<i>  Ipc::Mem::Segment::create(const off_t aSize)
</I>&gt;<i>  {
</I>&gt;<i> +    bool do_retry = false;
</I>&gt;<i> +
</I>&gt;<i>      assert(aSize &gt; 0);
</I>&gt;<i>      assert(theFD &lt; 0);
</I>&gt;<i>
</I>&gt;<i> -    // OS X does not allow using O_TRUNC here.
</I>&gt;<i> -    theFD = shm_open(theName.termedBuf(), O_CREAT | O_RDWR,
</I>&gt;<i> -                     S_IRUSR | S_IWUSR);
</I>&gt;<i> +    do {
</I>&gt;<i> +        // OS X does not allow using O_TRUNC with shm_open.
</I>&gt;<i> +        // Also, OS X only permits ftruncate() on new shared memory areas.
</I>&gt;<i> +        // Therefore, we know that ftruncate() will fail if the shared
</I>&gt;<i> memory
</I>&gt;<i> +        // area already exists. To prevent this, we delete and re-create
</I>&gt;<i> the
</I>&gt;<i> +        // area if it exsisted previously (i.e. from an unclean shutdown).
</I>&gt;<i> +        theFD = shm_open(theName.termedBuf(), O_CREAT | O_EXCL | O_RDWR,
</I>&gt;<i> +                         S_IRUSR | S_IWUSR);
</I>&gt;<i> +        if (theFD &lt; 0 &amp;&amp; errno == EEXIST) {
</I>&gt;<i> +            int old_errno = errno;
</I>&gt;<i> +            unlink();
</I>&gt;<i> +            // We want to report the shm_open failure, not the unlink
</I>&gt;<i> failure.
</I>&gt;<i> +            errno = old_errno;
</I>&gt;<i> +            // Retry once, but only once.
</I>&gt;<i> +            do_retry = !do_retry;
</I>&gt;<i> +        } else {
</I>&gt;<i> +            do_retry = false;
</I>&gt;<i> +        }
</I>&gt;<i> +    } while (do_retry);
</I>&gt;<i> +
</I>&gt;<i>      if (theFD &lt; 0) {
</I>&gt;<i>          debugs(54, 5, HERE &lt;&lt; &quot;shm_open &quot; &lt;&lt; theName &lt;&lt; &quot;: &quot; &lt;&lt;
</I>&gt;<i> xstrerror());
</I>&gt;<i>          fatalf(&quot;Ipc::Mem::Segment::create failed to shm_open(%s): %s\n&quot;,
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> -Markus
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160121/866fb1a0/attachment-0001.html">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160121/866fb1a0/attachment-0001.html</A>&gt;
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004831.html">[squid-dev] ftruncate() failures on OS X (Darwin)
</A></li>
	<LI>Next message: <A HREF="004833.html">[squid-dev] ftruncate() failures on OS X (Darwin)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4832">[ date ]</a>
              <a href="thread.html#4832">[ thread ]</a>
              <a href="subject.html#4832">[ subject ]</a>
              <a href="author.html#4832">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
