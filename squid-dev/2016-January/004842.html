<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Http::StreamContext refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Http%3A%3AStreamContext%20refactoring&In-Reply-To=%3C56A37D61.6010503%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004840.html">
   <LINK REL="Next"  HREF="004682.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Http::StreamContext refactoring</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Http%3A%3AStreamContext%20refactoring&In-Reply-To=%3C56A37D61.6010503%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Http::StreamContext refactoring">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jan 23 13:17:21 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004840.html">[squid-dev] [PATCH] Http::StreamContext refactoring
</A></li>
        <LI>Next message: <A HREF="004682.html">[squid-dev] Build failed in Jenkins: trunk-matrix » gcc,d-centos-7 #505
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4842">[ date ]</a>
              <a href="thread.html#4842">[ thread ]</a>
              <a href="subject.html#4842">[ subject ]</a>
              <a href="author.html#4842">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 23/01/2016 7:59 a.m., Alex Rousskov wrote:
&gt;<i> On 01/14/2016 05:53 AM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> The ClientSocketContext is renamed and shuffled to Http::StreamContext.
</I>&gt;<i> 
</I>&gt;<i> This class does not belong to the Http namespace. It represents the user
</I>&gt;<i> side of a master transaction.
</I>
No, that is HttpRequest.

StreamContext represents an HTTP &quot;stream&quot;. The formal definition is at
&lt;<A HREF="http://tools.ietf.org/html/rfc7540#section-5">http://tools.ietf.org/html/rfc7540#section-5</A>&gt; and HTTP/1 equivalence is
hinted at in the text of &lt;<A HREF="http://tools.ietf.org/html/rfc7230#section-5.7">http://tools.ietf.org/html/rfc7230#section-5.7</A>&gt;.

It points to both the HttpRequest ('user side') and HttpReply, and
AdaptedX, and clientStreams processing trail, and any deferred I/O
buffers waiting write(2), and (for now) the Job which is processing all
that data.


&gt;<i> While Squid historically uses classes
</I>&gt;<i> named after HTTP to represent various master transaction aspects (e.g.,
</I>&gt;<i> HttpRequest and HttpReply), we should not fall into this trap when
</I>&gt;<i> naming new classes or renaming the old ones. As you know, the user side
</I>&gt;<i> of a master transaction may correspond to any of these (at least):
</I>&gt;<i> 
</I>&gt;<i>   * An HTTP stream (user coming from an http_port or alike).
</I>&gt;<i>   * An FTP stream (user coming from an ftp_port).
</I>&gt;<i>   * An internal stream (various Squid-originated downloads).
</I>
... and HTTP/2 server-initiated streams (PUSH_PROMISE, Bi-Directional
HTTP, etc) will also need to be handled by this class due to it being
the stream object stored in Pipeline.
 The alternative would be a more complex design involving yet another
class to go in Pipeline that references some stream sub-class depending
on what type of protocol and direction of stream etc. IMO that is going
too far right now. These StreamContext are already just a data store for
the crossover between ::Server/ConnStateData and ClientHttpRequest Job
logics.
 One day we might merge it into MasterXaction as just transaction state
data, but you already objected to storing MasterXaction directly in
Pipeline in 2011 when my initial Pipeline design attempted it.


... the FTP relation to &quot;stream&quot; is that one actual FTP transaction is
mapped to *multiple* HTTP streams internally.

IMO FTP transactions should either be storing state data in another
object type entirely, or the FTP code is mapping to these objects
(plural) in their role as HTTP stream. That can be decided later since
it does not prevent these particular objects semantically being HTTP
streams. (it *will* affect ClientHttpRequest decisions when we get to
them, but that is later).

The internal requests generated by Squid are HTTP, so the stream
represents them directly as streams.


&gt;<i> The &quot;Context&quot; suffix adds nothing to the meaning of the new name. It is
</I>&gt;<i> essentially noise, like most &quot;State&quot;, &quot;Data&quot;, and &quot;Object&quot; suffixes. I
</I>&gt;<i> suggest dropping it.
</I>
Okay.


&gt;<i> 
</I>&gt;<i> Since there are many Squid things that can be considered &quot;streams&quot;, we
</I>&gt;<i> do need some distinguishing qualifier for the new name. As you know, we
</I>&gt;<i> are avoiding old &quot;client/server side&quot; terminology so ClientStream would
</I>&gt;<i> not work. If this thing is going to be specific to user traffic, we
</I>&gt;<i> could call it UserStream. If you think it will be eventually used for
</I>&gt;<i> peer/origin transactions as well, then a different qualifier is needed.
</I>
That is part of why they were specifically under the Http:: prefix.
Http::Stream being what the object is supposed to be (turn into).

clientStream is already taken by the client-streams payload processing
feature. So that is doubly bad.

As mentioned above squid-initiated and server-initiated streams are also
represented by these. So 'user' is not part of the definition.


&gt;<i> 
</I>&gt;<i> The renaming/moving part of the patch scope changes lots of code. It is
</I>&gt;<i> very unfortunate that you have decided to combine the above
</I>&gt;<i> functionality-preserving polishing with the functionality changes below.
</I>&gt;<i> The former makes it very difficult to see the latter. If I had enough
</I>&gt;<i> guts, I would -1 this patch for this reason alone. Renaming/moving
</I>&gt;<i> changes should have been done separately!
</I>
The Pipeline related ID changes are small and only needed for HTTP/2
(the combo was due to being sponsored as an line-item). I can separate
them out again.

With that Pipeline update gone there is no need for an audit of the
shuffling according to our policy. Once we settle on the naming (above)
are you happy for the non-logic shuffling bit to go in? and a new patch
to audit only the Pipeline ID part?


&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Pipeline class is updated to use the ID number to manage its contents
</I>&gt;&gt;<i> rather than Pointer value matching. It is also updated to drop the
</I>&gt;&gt;<i> HTTP/1 specific assumptions within the Pipeline implementation. As a
</I>&gt;&gt;<i> behavioural requirement the sequential flow is now left for the Server
</I>&gt;&gt;<i> and ClientHttpRequest Jobs to ensure correctness.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The new Pipeline::popById() method is a bad idea IMO: Linear search is
</I>&gt;<i> wrong for both HTTP/1 and HTTP/2.
</I>&gt;<i> 
</I>
Do you have a better algorithm? it needs to pop using only an ID (HTTP/2
limit due to framing) and works on linear/list storage (optimal for
HTTP/1 sequentialism).


&gt;<i> 
</I>&gt;&gt;<i> The old &quot;client-side&quot; classes are now split along the following scopes:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> * ::Server / ConnStateData/ *::Server
</I>&gt;&gt;<i>  - the AsynJob managing I/O on a client connection.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * ClientHttpRequest
</I>&gt;&gt;<i>  - the AsyncJob operating transaction internal behaviours and Calls.
</I>&gt;&gt;<i> Will make use of ConnStateData and Http::StreamContext to perform its
</I>&gt;&gt;<i> duties (has not yet been refactored to do so cleanly yet).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Http::StreamContext
</I>&gt;&gt;<i>  - the state data for a transaction. Refcounted and used by the Server
</I>&gt;&gt;<i> and ClientHttpRequest Jobs for their mutual data storage.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> As I said earlier, I will have to come back to this part later, but
</I>&gt;<i> perhaps you can already clarify whether this patch has actually changed
</I>&gt;<i> any of the above (besides renaming)?
</I>&gt;<i> 
</I>
Besides renaming and re-documenting: no.

The &quot;split&quot; is already existing, this is mostly documentation update to
formalize it so we can see better what logics are out of scope in their
current position. ::Server + children and ClientHttpRequest are Jobs.
Stream is just transaction data storage.


There is one or two static functions that had to be made non-static and
some methods de-duplicated by making a virtual override. But the code in
them and the order that code runs is unchanged.

Amos

</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004840.html">[squid-dev] [PATCH] Http::StreamContext refactoring
</A></li>
	<LI>Next message: <A HREF="004682.html">[squid-dev] Build failed in Jenkins: trunk-matrix » gcc,d-centos-7 #505
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4842">[ date ]</a>
              <a href="thread.html#4842">[ thread ]</a>
              <a href="subject.html#4842">[ subject ]</a>
              <a href="author.html#4842">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
