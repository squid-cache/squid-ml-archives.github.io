<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Planning for experiments with Digest, Link and metalink files.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Planning%20for%20experiments%20with%20Digest%2C%0A%20Link%20and%20metalink%20files.&In-Reply-To=%3C56AA01EC.1050605%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="004861.html">
   <LINK REL="Next"  HREF="004864.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Planning for experiments with Digest, Link and metalink files.</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Planning%20for%20experiments%20with%20Digest%2C%0A%20Link%20and%20metalink%20files.&In-Reply-To=%3C56AA01EC.1050605%40treenet.co.nz%3E"
       TITLE="[squid-dev] Planning for experiments with Digest, Link and metalink files.">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Jan 28 11:56:28 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004861.html">[squid-dev] Planning for experiments with Digest,	Link and metalink files.
</A></li>
        <LI>Next message: <A HREF="004864.html">[squid-dev] [PATCH] securiy_fake_certv ;	aka helpers/ shuffling exemplar
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4863">[ date ]</a>
              <a href="thread.html#4863">[ thread ]</a>
              <a href="subject.html#4863">[ subject ]</a>
              <a href="author.html#4863">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 28/01/2016 9:18 p.m., Eliezer Croitoru wrote:
&gt;<i> I have been working for some time on experimenting things related to
</I>&gt;<i> metalinks files and I have couple things in my mind about it.
</I>&gt;<i> Now I am running for more then 4 month my local proxy service with
</I>&gt;<i> SHA256 live digesting of all traffic using an eCAP module.
</I>&gt;<i> It's a small service and cannot take too much weight but it seems that
</I>&gt;<i> with digest enabled or disabled squid doesn't loose enough speed that I
</I>&gt;<i> seem to care.
</I>&gt;<i> 
</I>
The other one to test is AES hashing. IIRC, that should be faster than
SHA256 (but slower than MD5).


&gt;<i> Now I wanted to move into another side of my experiment and to implement
</I>&gt;<i> some web service that uses the metalinks files data.
</I>&gt;<i> Since metalinks are for files or static objects the first thing is a
</I>&gt;<i> simple file server.
</I>&gt;<i> 
</I>&gt;<i> I do not know what header to use for the digest hashes? I have seen that
</I>&gt;<i> fedora mirror server uses &quot;Digest: TYPE=hash&quot; but from what I remember
</I>&gt;<i> Henrik was talking about Content-MD5 and similar.
</I>&gt;<i> I can implement both Content-TYPE headers and Digest but what standards
</I>&gt;<i> are the up-to-date?
</I>&gt;<i> 
</I>
AFAIK, the header should be defined in the metalinks RFC document,
(whichever that is). Content-MD5 is related, but when I looked at its
specification it was locked to MD5 algorithm and not extensible to
better hashes.


&gt;<i> Also the other question, how should the If-None-Match or another
</I>&gt;<i> conditional should be used(since it was meant for ETAG)?
</I>
The metalinks does not use conditional headers at all.
&lt;<A HREF="https://tools.ietf.org/html/rfc6249#section-6">https://tools.ietf.org/html/rfc6249#section-6</A>&gt; defines either a GET
requet with Range headers or a HEAD request as the way to fetch the
Links and Digest header details.

The idea is to fetch the headers from each mirror and compare the Digest
value and/or ETag to ensure it is providing the right object.
Accumulating any new Links to the possible set as things progress. If
the Digest does not match those headers are probably &quot;broken&quot; and
another mirror needs to be tried.

Metalinks use-case is for resuming a broken fetch or splitting download
of a large object across multiple mirrors in an attempt to boost D/L
speed with parallelisation - but we dont like that second one because
Squid still lacks Range/partial caching of the resulting parts.


There is an &quot;If:&quot; header in WebDAV that seems to provide the necessary
semantics for passing the hashes in conditional requests. But the text
is not very clear on what field-value format to use, or how to interpret
the lists it contains.
&lt;<A HREF="http://tools.ietf.org/html/rfc4918#section-10.4">http://tools.ietf.org/html/rfc4918#section-10.4</A>&gt;


&gt;<i> 
</I>&gt;<i> For now I am only working on a full hash match leaving aside any partial
</I>&gt;<i> content pieces matching.
</I>&gt;<i> 
</I>&gt;<i> The options to validate file hash vs a static web service are:
</I>&gt;<i> - via some POST request(which can return a 304\302\200)
</I>&gt;<i> - via special if-none-match header
</I>&gt;<i> 
</I>&gt;<i> Also I had in my mind a situation that the client has couple hashes and
</I>&gt;<i> want to verify a full match to the whole set or to at-least one from a
</I>&gt;<i> set. What do you think should be done?
</I>&gt;<i> 
</I>&gt;<i> The current implementations relies on the fact that everybody uses the
</I>&gt;<i> same default hash but I am almost sure that somewhere in the future
</I>&gt;<i> people would like to run Digest match to some kind of salted algorithm
</I>&gt;<i> so I am considering what would be the right way to allow\implement
</I>&gt;<i> support for such cases.
</I>&gt;<i> Am I dreaming too much?
</I>&gt;<i> 
</I>&gt;<i> Another issue is a PUT requests, does it makes sense to attach some
</I>&gt;<i> Digest or other headers by the user that will be stored with the file
</I>&gt;<i> metadata or metalink file? compared.. to uploading two files one for the
</I>&gt;<i> object and another one for the metalink file?
</I>
We want to eventually be storing the payload/body of the PUT, and
updating its URL / Store-ID entry to be based on the response
Content-Location header that comes back from the server.

In light of that, doing a hash of that body makes sense. The problem is
just that Squid does not currently implement that storage idea at all.
So there is nothing stored until a later GET pulls it back into the proxy.

HTH
Amos

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004861.html">[squid-dev] Planning for experiments with Digest,	Link and metalink files.
</A></li>
	<LI>Next message: <A HREF="004864.html">[squid-dev] [PATCH] securiy_fake_certv ;	aka helpers/ shuffling exemplar
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4863">[ date ]</a>
              <a href="thread.html#4863">[ thread ]</a>
              <a href="subject.html#4863">[ subject ]</a>
              <a href="author.html#4863">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
