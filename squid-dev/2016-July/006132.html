<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Care and feeding of ConnStateData
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Care%20and%20feeding%20of%20ConnStateData&In-Reply-To=%3C577EAC09.4070101%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006131.html">
   <LINK REL="Next"  HREF="006134.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Care and feeding of ConnStateData</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Care%20and%20feeding%20of%20ConnStateData&In-Reply-To=%3C577EAC09.4070101%40measurement-factory.com%3E"
       TITLE="[squid-dev] Care and feeding of ConnStateData">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Jul  7 19:22:49 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006131.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
        <LI>Next message: <A HREF="006134.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6132">[ date ]</a>
              <a href="thread.html#6132">[ thread ]</a>
              <a href="subject.html#6132">[ subject ]</a>
              <a href="author.html#6132">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/06/2016 10:52 PM, Amos Jeffries wrote:
&gt;<i> On 7/07/2016 10:24 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> Q1. What is ConnStateData (and related client_side.* code)?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   C1. ConnStateData is the code shared among all Servers (BB1).
</I>&gt;&gt;<i>   C2. ConnStateData ends where request routing code (BB2) begins.
</I>

&gt;<i> Last time we went over this issue AFAIK we agreed that the above was to
</I>&gt;<i> be the defintion of ::Server.
</I>
Yes, it is a definition of the future Server class.

IIRC, last time we talked about it, the C2 rule specifically and BB2
role in general have not been discussed. Now C2 became important for the
right Downloader placement (and it has other nice side effects that I am
not discussing here to stay focused).


&gt;<i> Pieces of ConnStateData which are meeting that description should be
</I>&gt;<i> suffled up into Server.
</I>
I strongly disagree! Isolating and moving pieces of C1/C2 compliant code
into a parent class not only results in a lot more work but also forces
us to create temporary pure virtual functions to tie the two classes
together and it tempts folks to inherit from the wrong class. It creates
complex relationships that are not needed today and will then have to be
dismantled later.

The correct approach is to move pieces that do _not_ satisfy the above
rules out of ConnStateData and then eventually rename ConnStateData to
Server. This approach creates no extra work and actually reduces
complexity with virtually every step.

More on that further below where Q4 is discussed.


&gt;&gt;<i> Q2. Where does the pending Downloader class belong?
</I>
&gt;<i> In overview I think if we have a good Downloader design those other
</I>&gt;<i> things and ESIInclude should probably be converted into Downloader or
</I>&gt;<i> children of it.
</I>
Yes, but if and only if ESI needs to download small SBuf-storable
things. If ESI needs potentially large HTTP response bodies, then ESI
cannot be refactored to use Downloader.



&gt;&gt;<i> Q3. Where does the future Http::Two::Server class belong?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Today, that common parent for the two siblings is ConnStateData.
</I>&gt;&gt;<i> Tomorrow, we may split and/or rename ConnStateData, of course, but
</I>&gt;&gt;<i> Http::One::Server and Http::Two::Server classes are likely to remain
</I>&gt;&gt;<i> siblings with a common base that contains the code they share.
</I>
&gt;<i> My draft branch uses ::Server as parent to Http2::Server. I've not yet
</I>&gt;<i> run across anything in ConnStateData that needed it to be a child of
</I>&gt;<i> that. Though there are things that need moving up to the Server parent
</I>&gt;<i> class.
</I>
The last two sentences seem to contradict each other, but this
particular difference in opinion does not seem to be very important at
the moment: If your Http2::Server works as a Server child, it can work
as a ConnStateData child with very little extra effort. I do object to
moving stuff from ConnStateData to Server, but that is a separate
problem discussed below.



&gt;&gt;<i> Q4. What to do with the existing src/servers/Server.h?
</I>
&gt;&gt;<i> Today, that class is a nuisance:
</I>

&gt;&gt;<i> * It is not a common base for all servers (its stated purpose).
</I>
&gt;<i> Which servers is it not a base for exactly?
</I>
All of them! Http::One::Server and Ftp::Server base is ConnStateData,
not the current class in src/servers/Server.h. And, if my answer to Q3
is correct, Http::Two::Server base will be ConnStateData and not the
current class in src/servers/Server.h either.


&gt;<i> Note that as parent of ConnStateData for now anything which implements
</I>&gt;<i> ConnStateData implements Server.
</I>
This is not quite accurate, actually (children can hide parent
interfaces), but it is irrelevant for the above bullet. ConnStateData
kids do not know about and do not benefit from src/servers/Server.h
existence or the ConnStateData split. The class in src/servers/Server.h
is not their common base. ConnStateData is.


&gt;&gt;<i> * It does not fully encapsulate connection-managing code of its kids
</I>&gt;&gt;<i> (its stated usage).
</I>
&gt;<i> ... those changes to make it so got blocked in audit.
</I>
Whether some future changes will or will not address this part of the
problem is pretty much irrelevant to the problem existence (it only
confirms that existence if you will).


&gt;&gt;<i> * It is essentially unused (it is not used as an API by others and has
</I>&gt;&gt;<i> only one kid).
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> ... the other child class go blocked in audit initially and still
</I>&gt;<i> waiting the major redesign to be completed before it can be re-suvmitted.
</I>
Similar to the above, I do not think it is a good idea to keep that
currently broken class just because it might be needed in the future.
Moreover, I would not be surprised if its wrongful existence already
exerts negative influence on that future code!


&gt;<i> The two grandchildren in trunk we planned to make direct children of it
</I>&gt;<i> (yes we, all three of us at the time agreed). The intermediate kid being
</I>&gt;<i> the ConnStateData mess still *temporarily* in the middle of the hierarchy.
</I>

*If* I agreed on moving Server code out of ConnStateData instead of
moving non-Server code out of ConnStateData, then I made a major mistake!

What anybody did or did not say years ago is secondary to the current
discussion, but I know that in 2014 I said pretty much the same thing I
am saying now[4]: &quot;Keep ConnStateData as is for now, until somebody
volunteers to extract HTTP code from it and place the extracted HTTP
code into servers/HttpServer, moving the remaining generic code into
src/servers/Server and src/http/&quot;.

In other words:

  1. Extract HTTP server-specific code from ConnStateData.

  ...once #1 is done, ConnStateData will only have generic code left...

  2. Move that remaining generic code into src/servers/Server and src/http/.

We all have been doing step #1 since then, but we are not yet ready for
step #2 because ConnStateData still has HTTP server-specific code in it.

When we are ready for step #2, the &quot;move&quot; will be exactly that -- we
will be moving files and renaming classes to match their new location.
There is no time in this plan where there are two Server classes, one
called &quot;Server&quot; and one called &quot;ConnStateData&quot;!

[4] <A HREF="http://www.squid-cache.org/mail-archive/squid-dev/201408/0145.html">http://www.squid-cache.org/mail-archive/squid-dev/201408/0145.html</A>


&gt;&gt;<i> * It forces new code to add pure virtual methods that ConnStateData then
</I>&gt;&gt;<i> overrides and implements, reminding me of the old Store class that
</I>&gt;&gt;<i> slowly accumulated dozens of such methods because we needed to add
</I>&gt;&gt;<i> something that one of the Store kids implemented.
</I>
&gt;<i> This is backwards.
</I>
Exactly! The ConnStateData split forces us to do things backwards.


&gt;<i> ConnStateData is the old class that has accumulated
</I>&gt;<i> all those extra bits.
</I>
Yes.


&gt;<i> We are trying to remove that ConnStateData scope creep.
</I>
The correct way to remove code misplaced in ConnStateData is to move
that misplaced code (rather than to split ConnStateData in two and then
move everything else into the second class, leaving misplaced code in
ConnStateData, as misplaced as it was when we started).


&gt;<i> virtuals in Server are ideally implemented by the end-child
</I>&gt;<i> HTTP/FTP/whatever Server class. The ones that are implemented by
</I>&gt;<i> ConnStateData itself are in a temporary stage, until they can either be
</I>&gt;<i> pushed down to the childs, or the bits they depend on using from
</I>&gt;<i> ConnStateData and also moved up to Server and the virtual-ness dropped.
</I>
True. The ConnStateData split forces us to add temporary complexity that
is completely unnecessary.



&gt;&gt;<i> I recommend merging it back into ConnStateData until Squid actually
</I>&gt;&gt;<i> needs it (or needs something like it). Merging it into ConnStateData
</I>&gt;&gt;<i> would preserve all code improvements we have done after it was split. If
</I>&gt;&gt;<i> somebody finds that useful, we can even keep its method definitions
</I>&gt;&gt;<i> inside Server.cc, at least for a while.
</I>
&gt;<i> Doing that undermines 3 years work towards getting rid of ConnStateData.
</I>
I do not see how it undermines anything. To get rid of ConnStateData, we
need to get rid of non-Server code in ConnStateData and then rename
ConnStateData. Splitting ConnStateData in two does not help with that.
It actually hurts!


I may be very wrong, but I sense that you might be attaching some
special significance to the 13 letters &quot;ConnStateData&quot;. It may be
spelled &quot;ConnStateData&quot; but it reads &quot;Server&quot;. We just did not want to
rename that class while it is still bloated with non-Server code, that's
all. I even said that explicitly[4]: &quot;For example, when documenting
something about ConnStateData inside FwdState, call it Server instead of
ConnStateData. This will reduce future changes as the classes get renamed&quot;.

I certainly regret if something I said earlier was misinterpreted as the
need to create a Server class that slowly accumulates code already
properly placed in ConnStateData. I hope the above arguments prove that
we must do the opposite. Pretty much everything in design and code
refactoring is a matter of opinion, but this choice is as close to being
&quot;formally provable&quot; as it gets.


Thank you,

Alex.

</PRE>






























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006131.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
	<LI>Next message: <A HREF="006134.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6132">[ date ]</a>
              <a href="thread.html#6132">[ thread ]</a>
              <a href="subject.html#6132">[ subject ]</a>
              <a href="author.html#6132">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
