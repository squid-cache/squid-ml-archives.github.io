<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3Cb92e8992-b28d-1182-5d1d-d2b6b88b5ad8%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006126.html">
   <LINK REL="Next"  HREF="006135.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3Cb92e8992-b28d-1182-5d1d-d2b6b88b5ad8%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Jul  7 19:40:39 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006126.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006135.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6133">[ date ]</a>
              <a href="thread.html#6133">[ thread ]</a>
              <a href="subject.html#6133">[ subject ]</a>
              <a href="author.html#6133">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 4/07/2016 5:39 a.m., Alex Rousskov wrote:
&gt;<i> On 06/29/2016 05:45 AM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>  /**
</I>&gt;&gt;<i> + * A pointer that deletes the object it points to when the pointer's owner or
</I>&gt;&gt;<i> + * context is gone. [...]
</I>&gt;&gt;<i>   */
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    explicit LockingPointer(const SelfType &amp;o) : raw(nullptr) { resetAndLock(o.get()); }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Something went wrong here: If both the class description and the copy
</I>&gt;<i> constructor are correct, then the following pseudo code ought to crash
</I>&gt;<i> Squid:
</I>&gt;<i> 
</I>&gt;<i>   LockingPointer a(OpenSSL_new(...)); // a points to a new object X
</I>&gt;<i>   {
</I>&gt;<i>       LockingPointer b(a); // a and b point to the same object X
</I>&gt;<i>       ...
</I>&gt;<i>       // b context ends so b deletes X
</I>&gt;<i>   }
</I>&gt;<i>   ...
</I>&gt;<i>   // a context ends so a deletes X
</I>&gt;<i>   // Squid crashes because the same X was deleted twice
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I hope that Squid code is actually correct, but the proposed class
</I>&gt;<i> description is not. LockingPointer does _not_ delete the object it
</I>&gt;<i> points to when the pointer's owner or context is gone. LockingPointer is
</I>&gt;<i> actually a reference counting pointer like shared_ptr (not a unique_ptr
</I>&gt;<i> or auto_ptr!). There is no concept of [a single] owner here -- the
</I>&gt;<i> object is _shared_ among many &quot;owners&quot;. That makes copy assignment safe.
</I>
Yes the description was incorrect. OpenSSL does ref-counting done in the
*_new() and *_free() functions (mostly).

&gt;<i> 
</I>&gt;<i> If I am right, then we need to fix the LockingPointer class description
</I>&gt;<i> (and make sure the implementation matches it). There several ways to do
</I>&gt;<i> that, including the following three:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> A. Provide two different LockingPointer classes, one for OpenSSL, and
</I>&gt;<i> one for GnuTLS. The tricky shared pointer code will be duplicated (bad),
</I>&gt;<i> but each class itself would be easy to comprehend because it will lack
</I>&gt;<i> #ifdefs (good):
</I>&gt;<i> 
</I>&gt;<i>    #if USE_OPENSSL
</I>&gt;<i>      template &lt;...&gt;
</I>&gt;<i>      class LockingPointer ...
</I>&gt;<i>    #elif USE_GNUTLS
</I>&gt;<i>      template &lt;...&gt;
</I>&gt;<i>      class LockingPointer ...
</I>&gt;<i>    #else
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> B. Provide a single LockingPointer class along with two wrappers that
</I>&gt;<i> customize template parameters, one for OpenSSL, and one for GnuTLS. No
</I>&gt;<i> tricky shared pointer duplication (good), but an extra level of wrapping
</I>&gt;<i> would complicate comprehension (bad):
</I>&gt;<i> 
</I>&gt;<i>    template &lt;...&gt;
</I>&gt;<i>    class LockingPointer ...
</I>&gt;<i> 
</I>&gt;<i>    #if USE_OPENSSL
</I>&gt;<i>    template &lt;...&gt;
</I>&gt;<i>    using OpenSslLockingPointer = LockingPointer&lt;...&gt;
</I>&gt;<i>    #elif USE_GNUTLS
</I>&gt;<i>    template &lt;...&gt;
</I>&gt;<i>    class GnuTlsLockingPointer = LockingPointer&lt;...&gt;
</I>&gt;<i>    #else
</I>&gt;<i> 
</I>&gt;<i> I have attached a sketch for B in case you want to see what that would
</I>&gt;<i> look like.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> C. Provide a single LockingPointer class sprinkled with #ifdefs
</I>&gt;<i> customizing its API and implementation for each library. No tricky
</I>&gt;<i> shared pointer duplication (good), but large number of #ifdefs,
</I>&gt;<i> including #ifdefs in class template parameters, will make the code
</I>&gt;<i> difficult to comprehend (bad).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> We are currently doing C. I have no objections to us continuing doing C,
</I>&gt;<i> at least for now. If you pick C, then the fixed LockingPointer class
</I>&gt;<i> documentation may look like the following (compare that with the
</I>&gt;<i> documentation for LockingPointer in the attached sketch for B):
</I>
I'm opting to do the below suggested fixes and merge when we are both
okay with it. Then attempt the LockingPointer replacement with
shared_ptr on a case by case basis in followups.

&gt;<i> 
</I>&gt;<i> -----
</I>&gt;<i> A shared pointer to a reference-counting Object with library-specific
</I>&gt;<i> absorption, locking, and unlocking implementations. The API largely
</I>&gt;<i> follows std::shared_ptr.
</I>&gt;<i> 
</I>&gt;<i> The constructor and the absorb() method import a raw Object pointer.
</I>&gt;<i> Normally, absorb() would just lock(), but libraries like OpenSSL
</I>&gt;<i> pre-lock objects before they are fed to LockingPointer, necessitating
</I>&gt;<i> this customization hook.
</I>&gt;<i> 
</I>&gt;<i> The lock() method increments Object's reference counter.
</I>&gt;<i> 
</I>&gt;<i> The unlock() method decrements Object's reference counter and destroys
</I>&gt;<i> the object when the counter reaches zero.
</I>&gt;<i> -----
</I>
Done.
Though I've used resetWithoutLocking() instead of absorb() until the
below details with reset() and clear() are settled.

&gt;<i> 
</I>&gt;<i> The absorb/lock/unlock split above may help with seamless GnuTLS
</I>&gt;<i> support, assuming GnuTLS does not pre-lock objects like OpenSSL does.
</I>&gt;<i> However, somebody familiar with GnuTLS should check whether it has other
</I>&gt;<i> special needs not addressed by the above LockingPointer sketch. For
</I>&gt;<i> example, if GnuTLS does not have a concept of locking at all, then we
</I>&gt;<i> may be better of with approach A where GnuTLS code just uses
</I>&gt;<i> std::shared_ptr!
</I>
I believe that is the case yes.

However, there is currently still a lot of Ssl:: code switching between
the FooPointer and FooPtr types which does not let shared_ptr do its
copying properly. To avoid #ifdef all over the places reset() is used we
also need to make sure the matching OpenSSL pointer can be a shared_ptr
as well.
This is the main reason I want to update those bits that as a followup.

&gt;<i> 
</I>&gt;&gt;<i> +    /// Deallocate raw pointer. Become a nil pointer.
</I>&gt;&gt;<i> +    void deletePointer() {
</I>&gt;&gt;<i> +        if (raw)
</I>&gt;&gt;<i> +            DeAllocator(raw);
</I>&gt;&gt;<i> +        raw = nullptr;
</I>&gt;&gt;<i> +    }
</I>&gt;<i> 
</I>&gt;<i> please rename to unlock(). We are not deleting the pointer here and,
</I>&gt;<i> depending on the lock count, we are not deleting the object either!
</I>&gt;<i> Renaming DeAllocator to Unlock or Unlocker is also a good idea -- we
</I>&gt;<i> have wasted enough time being confused by OpenSSL _free() functions not
</I>&gt;<i> freeing locked objects!
</I>&gt;<i> 
</I>
Nod. Done.

&gt;<i> 
</I>&gt;&gt;<i> +    /// Reset raw pointer - delete last one and save new one.
</I>&gt;&gt;<i> +    void reset(T *t) {
</I>&gt;&gt;<i> +        deletePointer();
</I>&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> I do not think we can have a reset() method like this because the
</I>&gt;<i> standard shared_ptr::reset() has a very different semantics. Let's call
</I>&gt;<i> this absorb(). This is like a raw pointer assignment operator, but we
</I>&gt;<i> want to keep it &quot;explicit&quot; because we think this is a dangerous operation.
</I>&gt;<i> 
</I>
What different semantics do you see in there?

&lt;<A HREF="http://en.cppreference.com/w/cpp/memory/shared_ptr/reset">http://en.cppreference.com/w/cpp/memory/shared_ptr/reset</A>&gt; description
of reset(Y*) variant #2 seems to describe exactly what our custom
reset(T*) actually does, including the undefined behaviour case. That
similarity is a bit clearer after the 'deletePointer' is renamed.

We just dont provide nor use the other variants.


&gt;<i> 
</I>&gt;&gt;<i>      void resetAndLock(T *t) {
</I>&gt;&gt;<i>          if (t != this-&gt;get()) {
</I>&gt;&gt;<i>              this-&gt;reset(t);
</I>&gt;&gt;<i>  #if USE_OPENSSL
</I>&gt;&gt;<i>              if (t)
</I>&gt;&gt;<i>                  CRYPTO_add(&amp;t-&gt;references, 1, lock);
</I>&gt;&gt;<i>  #elif USE_GNUTLS
</I>&gt;&gt;<i>              // XXX: GnuTLS does not provide locking ?
</I>&gt;&gt;<i>  #else
</I>&gt;&gt;<i>              assert(false);
</I>&gt;&gt;<i>  #endif
</I>&gt;&gt;<i>          }
</I>&gt;&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> Please rewrite as a pair of public reset(t) and private lock(void)
</I>&gt;<i> methods. reset(t) calls lock() for non-nil t, of course.
</I>
Replaced its internals with those. Though left the name for now.

&gt;<i> 
</I>&gt;<i> Please also add a public clear(void) method that reset(t) will call
</I>&gt;<i> instead of lock() when t is nil. Alternatively, add a reset(void) method
</I>&gt;<i> with the same semantics as clear(void) -- that is what std::shared_ptr does.
</I>
I do not see any clear() method in shared_ptr documentation.
&lt;<A HREF="http://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&amp;search=clear%28%29">http://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&amp;search=clear%28%29</A>&gt;

&gt;<i> 
</I>&gt;<i> To resolve conflicts between abused reset() in the old code and the new
</I>&gt;<i> reset(), I suggest the following procedure:
</I>&gt;<i> 
</I>&gt;<i> 1. Add absorb() and clear(void)/reset(void) methods as discussed above.
</I>&gt;<i> 
</I>&gt;<i> 2. Remove LockingPointer::reset(x). Replace all calls to
</I>&gt;<i> LockingPointer::reset(x) with absorb() and clear(void)/reset(void),
</I>&gt;<i> depending on whether x is nil. See earlier emails on how to find all
</I>&gt;<i> those calls. IIRC, Christos has certified that all those old reset(x)
</I>&gt;<i> calls are meant to be either non-locking absorption or clearance calls.
</I>&gt;<i> 
</I>&gt;<i> 3. Rename LockingPointer::resetAndLock(x) to reset(x). Replace all calls
</I>&gt;<i> to LockingPointer::resetAndLock() with reset(x).
</I>&gt;<i> 
</I>&gt;<i> You may argue that these reset()-related changes are outside this
</I>&gt;<i> project scope, but I think it is too dangerous to commit LockingPointer
</I>&gt;<i> with a reset(x) method that does not work like shared_ptr::reset(x). In
</I>&gt;<i> the current trunk code, we are calling TidyPointer::reset(), which is
</I>&gt;<i> already very ugly, but can at least be half-justified because
</I>&gt;<i> TidyPointer::reset() does what it is supposed to do. Moving that method
</I>&gt;<i> from TidyPointer to LockingPointer moves the needle from &quot;terribly ugly&quot;
</I>&gt;<i> to &quot;unacceptably dangerous&quot; IMO.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +            void operator()(argument_type a) { sk_object ## _pop_free(a, freefunction); } \
</I>&gt;<i> 
</I>&gt;<i> If you can make this operator &quot;const&quot;, please make it &quot;const&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Please note that the originally proposed commit message no longer
</I>&gt;<i> applies to your changes so we need a new one.
</I>&gt;<i> 
</I>
&quot;
This replaces TidyPointer with std::unique_ptr and re-implements the
part of TidyPointer which LockingPointer was using. Removing the
inheritence in the process and updating methods names for clarity.

The LockingPointer still has some of the issues which led us down the
path to getting here. I've chosen to submit for review at this point to
ensure we still have a fully working Squid before going further down
this trail.
&quot;


Amos
-------------- next part --------------
=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2016-01-15 06:47:59 +0000
+++ src/base/Makefile.am	2016-06-29 03:56:37 +0000
@@ -21,22 +21,21 @@
 	AsyncCallQueue.h \
 	ByteCounter.h \
 	CbcPointer.h \
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
 	EnumIterator.h \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
 	LruMap.h \
 	Packable.h \
 	PackableStream.h \
 	RegexPattern.cc \
 	RegexPattern.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	TidyPointer.h \
 	YesNoNone.h

=== removed file 'src/base/TidyPointer.h'
--- src/base/TidyPointer.h	2016-07-01 17:35:00 +0000
+++ src/base/TidyPointer.h	1970-01-01 00:00:00 +0000
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_BASE_TIDYPOINTER_H
-#define SQUID_BASE_TIDYPOINTER_H
-
-/**
- * A pointer that deletes the object it points to when the pointer's owner or
- * context is gone. Similar to std::unique_ptr but without confusing assignment
- * and with a customizable cleanup method. Prevents memory leaks in
- * the presence of exceptions and processing short cuts.
-*/
-template &lt;typename T, void (*DeAllocator)(T *t)&gt; class TidyPointer
-{
-public:
-    /// Delete callback.
-    typedef void DCB (T *t);
-    TidyPointer(T *t = NULL)
-        :   raw(t) {}
-public:
-    bool operator !() const { return !raw; }
-    explicit operator bool() const { return raw; }
-    T* operator -&gt;() const { return get(); }
-
-    /// Returns raw and possibly NULL pointer
-    T *get() const { return raw; }
-
-    /// Reset raw pointer - delete last one and save new one.
-    void reset(T *t) {
-        deletePointer();
-        raw = t;
-    }
-
-    /// Forget the raw pointer without freeing it. Become a nil pointer.
-    T *release() {
-        T *ret = raw;
-        raw = NULL;
-        return ret;
-    }
-    /// Deallocate raw pointer.
-    ~TidyPointer() {
-        deletePointer();
-    }
-private:
-    /// Forbidden copy constructor.
-    TidyPointer(TidyPointer&lt;T, DeAllocator&gt; const &amp;);
-    /// Forbidden assigment operator.
-    TidyPointer &lt;T, DeAllocator&gt; &amp; operator = (TidyPointer&lt;T, DeAllocator&gt; const &amp;);
-    /// Deallocate raw pointer. Become a nil pointer.
-    void deletePointer() {
-        if (raw) {
-            DeAllocator(raw);
-        }
-        raw = NULL;
-    }
-    T *raw; ///&lt; pointer to T object or NULL
-};
-
-/// DeAllocator for pointers that need free(3) from the std C library
-template&lt;typename T&gt; void tidyFree(T *p)
-{
-    xfree(p);
-}
-
-#endif // SQUID_BASE_TIDYPOINTER_H
-

=== modified file 'src/client_side_request.cc'
--- src/client_side_request.cc	2016-06-25 14:35:41 +0000
+++ src/client_side_request.cc	2016-07-04 16:22:18 +0000
@@ -160,41 +160,41 @@
     conn_(NULL)
 #if USE_OPENSSL
     , sslBumpNeed_(Ssl::bumpEnd)
 #endif
 #if USE_ADAPTATION
     , request_satisfaction_mode(false)
     , request_satisfaction_offset(0)
 #endif
 {
     setConn(aConn);
     al = new AccessLogEntry;
     al-&gt;cache.start_time = current_time;
     if (aConn) {
         al-&gt;tcpClient = clientConnection = aConn-&gt;clientConnection;
         al-&gt;cache.port = aConn-&gt;port;
         al-&gt;cache.caddr = aConn-&gt;log_addr;
 
 #if USE_OPENSSL
         if (aConn-&gt;clientConnection != NULL &amp;&amp; aConn-&gt;clientConnection-&gt;isOpen()) {
             if (auto ssl = fd_table[aConn-&gt;clientConnection-&gt;fd].ssl.get())
-                al-&gt;cache.sslClientCert.reset(SSL_get_peer_certificate(ssl));
+                al-&gt;cache.sslClientCert.resetWithoutLocking(SSL_get_peer_certificate(ssl));
         }
 #endif
     }
     dlinkAdd(this, &amp;active, &amp;ClientActiveRequests);
 }
 
 /*
  * returns true if client specified that the object must come from the cache
  * without contacting origin server
  */
 bool
 ClientHttpRequest::onlyIfCached()const
 {
     assert(request);
     return request-&gt;cache_control &amp;&amp;
            request-&gt;cache_control-&gt;onlyIfCached();
 }
 
 /**
  * This function is designed to serve a fairly specific purpose.

=== modified file 'src/comm.cc'
--- src/comm.cc	2016-06-15 15:37:44 +0000
+++ src/comm.cc	2016-07-04 16:42:13 +0000
@@ -821,41 +821,41 @@
     if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &amp;L, sizeof(L)) &lt; 0) {
         int xerrno = errno;
         debugs(50, DBG_CRITICAL, &quot;ERROR: Closing FD &quot; &lt;&lt; fd &lt;&lt; &quot; with TCP RST: &quot; &lt;&lt; xstrerr(xerrno));
     }
     comm_close(fd);
 }
 
 #if USE_OPENSSL
 void
 commStartSslClose(const FdeCbParams &amp;params)
 {
     assert(fd_table[params.fd].ssl);
     ssl_shutdown_method(fd_table[params.fd].ssl.get());
 }
 #endif
 
 void
 comm_close_complete(const FdeCbParams &amp;params)
 {
     fde *F = &amp;fd_table[params.fd];
-    F-&gt;ssl.reset(nullptr);
+    F-&gt;ssl.resetWithoutLocking(nullptr);
 
 #if USE_OPENSSL
     if (F-&gt;dynamicSslContext) {
         SSL_CTX_free(F-&gt;dynamicSslContext);
         F-&gt;dynamicSslContext = NULL;
     }
 #endif
     fd_close(params.fd);        /* update fdstat */
     close(params.fd);
 
     ++ statCounter.syscalls.sock.closes;
 
     /* When one connection closes, give accept() a chance, if need be */
     Comm::AcceptLimiter::Instance().kick();
 }
 
 /*
  * Close the socket fd.
  *
  * + call write handlers with ERR_CLOSING

=== modified file 'src/fde.h'
--- src/fde.h	2016-01-26 21:02:00 +0000
+++ src/fde.h	2016-07-04 15:22:24 +0000
@@ -150,39 +150,39 @@
         memset(&amp;flags,0,sizeof(_fde_flags));
         bytes_read = 0;
         bytes_written = 0;
         pconn.uses = 0;
 #if USE_DELAY_POOLS
         clientInfo = NULL;
 #endif
         epoll_state = 0;
         read_handler = NULL;
         read_data = NULL;
         write_handler = NULL;
         write_data = NULL;
         timeoutHandler = NULL;
         timeout = 0;
         writeStart = 0;
         lifetime_data = NULL;
         closeHandler = NULL;
         halfClosedReader = NULL;
         read_method = NULL;
         write_method = NULL;
-        ssl.reset(nullptr);
+        ssl.resetWithoutLocking(nullptr);
         dynamicSslContext = NULL;
 #if _SQUID_WINDOWS_
         win32.handle = (long)NULL;
 #endif
         tosFromServer = '\0';
         nfmarkFromServer = 0;
     }
 };
 
 #define fd_table fde::Table
 
 int fdNFree(void);
 
 #define FD_READ_METHOD(fd, buf, len) (*fd_table[fd].read_method)(fd, buf, len)
 #define FD_WRITE_METHOD(fd, buf, len) (*fd_table[fd].write_method)(fd, buf, len)
 
 #endif /* SQUID_FDE_H */
 

=== modified file 'src/security/LockingPointer.h'
--- src/security/LockingPointer.h	2016-03-31 23:33:45 +0000
+++ src/security/LockingPointer.h	2016-07-04 15:22:20 +0000
@@ -1,89 +1,136 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_LOCKINGPOINTER_H
 #define SQUID_SRC_SECURITY_LOCKINGPOINTER_H
 
-#include &quot;base/TidyPointer.h&quot;
-
 #if USE_OPENSSL
 #if HAVE_OPENSSL_CRYPTO_H
 #include &lt;openssl/crypto.h&gt;
 #endif
 
 // Macro to be used to define the C++ wrapper function of a sk_*_pop_free
 // openssl family functions. The C++ function suffixed with the _free_wrapper
 // extension
 #define sk_free_wrapper(sk_object, argument, freefunction) \
         extern &quot;C++&quot; inline void sk_object ## _free_wrapper(argument a) { \
             sk_object ## _pop_free(a, freefunction); \
         }
 
-#endif
+#endif /* USE_OPENSSL */
 
 // Macro to be used to define the C++ equivalent function of an extern &quot;C&quot;
 // function. The C++ function suffixed with the _cpp extension
 #define CtoCpp1(function, argument) \
         extern &quot;C++&quot; inline void function ## _cpp(argument a) { \
             function(a); \
         }
 
 namespace Security
 {
 
 /**
- * Add SSL locking (a.k.a. reference counting) and assignment to TidyPointer
+ * A shared pointer to a reference-counting Object with library-specific
+ * absorption, locking, and unlocking implementations. The API largely
+ * follows std::shared_ptr.
+ *
+ * The constructor and the resetWithoutLocking() method import a raw Object pointer.
+ * Normally, reset() would lock(), but libraries like OpenSSL
+ * pre-lock objects before they are fed to LockingPointer, necessitating
+ * this resetWithoutLocking() customization hook.
+ *
+ * The lock() method increments Object's reference counter.
+ *
+ * The unlock() method decrements Object's reference counter and destroys
+ * the object when the counter reaches zero.
  */
-template &lt;typename T, void (*DeAllocator)(T *t), int lock&gt;
-class LockingPointer: public TidyPointer&lt;T, DeAllocator&gt;
+template &lt;typename T, void (*UnLocker)(T *t), int lockId&gt;
+class LockingPointer
 {
 public:
-    typedef TidyPointer&lt;T, DeAllocator&gt; Parent;
-    typedef LockingPointer&lt;T, DeAllocator, lock&gt; SelfType;
+    /// a helper label to simplify this objects API definitions below
+    typedef LockingPointer&lt;T, UnLocker, lockId&gt; SelfType;
 
-    explicit LockingPointer(T *t = nullptr): Parent(t) {}
+    /**
+     * Construct directly from a raw pointer.
+     * This action requires that the producer of that pointer has already
+     * created one reference lock for the object pointed to.
+     * Our destructor will do the matching unlock.
+     */
+    explicit LockingPointer(T *t = nullptr): raw(t) {}
 
-    explicit LockingPointer(const SelfType &amp;o): Parent() {
-        resetAndLock(o.get());
-    }
+    /// use the custom UnLocker to unlock any value still stored.
+    ~LockingPointer() { unlock(); }
 
+    // copy semantics are okay only when adding a lock reference
+    explicit LockingPointer(const SelfType &amp;o) : raw(nullptr) { resetAndLock(o.get()); }
     SelfType &amp;operator =(const SelfType &amp; o) {
         resetAndLock(o.get());
         return *this;
     }
 
-#if __cplusplus &gt;= 201103L
-    explicit LockingPointer(LockingPointer&lt;T, DeAllocator, lock&gt; &amp;&amp;o): Parent(o.release()) {
+    // move semantics are definitely okay, when possible
+    explicit LockingPointer(SelfType &amp;&amp;) = default;
+    SelfType &amp;operator =(SelfType &amp;&amp;o) {
+        if (o.get() != raw)
+            resetWithoutLocking(o.release());
+        return *this;
     }
 
-    LockingPointer&lt;T, DeAllocator, lock&gt; &amp;operator =(LockingPointer&lt;T, DeAllocator, lock&gt; &amp;&amp;o) {
-        if (o.get() != this-&gt;get())
-            this-&gt;reset(o.release());
-        return *this;
+    bool operator !() const { return !raw; }
+    explicit operator bool() const { return raw; }
+
+    /// Returns raw and possibly nullptr pointer
+    T *get() const { return raw; }
+
+    /// Reset raw pointer - unlock any previous one and save new one without locking.
+    void resetWithoutLocking(T *t) {
+        unlock();
+        raw = t;
     }
-#endif
 
     void resetAndLock(T *t) {
-        if (t != this-&gt;get()) {
-            this-&gt;reset(t);
+        if (t != get()) {
+            resetWithoutLocking(t);
+            lock(t);
+        }
+    }
+
+    /// Forget the raw pointer without unlocking it. Become a nil pointer.
+    T *release() {
+        T *ret = raw;
+        raw = nullptr;
+        return ret;
+    }
+
+private:
+    void lock(T *t) {
 #if USE_OPENSSL
             if (t)
-                CRYPTO_add(&amp;t-&gt;references, 1, lock);
+                CRYPTO_add(&amp;t-&gt;references, 1, lockId);
 #elif USE_GNUTLS
             // XXX: GnuTLS does not provide locking ?
 #else
             assert(false);
 #endif
-        }
     }
+
+    /// Unlock the raw pointer. Become a nil pointer.
+    void unlock() {
+        if (raw)
+            UnLocker(raw);
+        raw = nullptr;
+    }
+
+    T *raw; ///&lt; pointer to T object or nullptr
 };
 
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_LOCKINGPOINTER_H */
 

=== modified file 'src/security/ServerOptions.cc'
--- src/security/ServerOptions.cc	2016-07-05 17:00:36 +0000
+++ src/security/ServerOptions.cc	2016-07-05 23:39:23 +0000
@@ -144,41 +144,41 @@
     DH *dhp = nullptr;
     if (FILE *in = fopen(dhParamsFile.c_str(), &quot;r&quot;)) {
         dhp = PEM_read_DHparams(in, NULL, NULL, NULL);
         fclose(in);
     }
 
     if (!dhp) {
         debugs(83, DBG_IMPORTANT, &quot;WARNING: Failed to read DH parameters '&quot; &lt;&lt; dhParamsFile &lt;&lt; &quot;'&quot;);
         return;
     }
 
     int codes;
     if (DH_check(dhp, &amp;codes) == 0) {
         if (codes) {
             debugs(83, DBG_IMPORTANT, &quot;WARNING: Failed to verify DH parameters '&quot; &lt;&lt; dhParamsFile &lt;&lt; &quot;' (&quot; &lt;&lt; std::hex &lt;&lt; codes &lt;&lt; &quot;)&quot;);
             DH_free(dhp);
             dhp = nullptr;
         }
     }
 
-    parsedDhParams.reset(dhp);
+    parsedDhParams.resetWithoutLocking(dhp);
 #endif
 }
 
 void
 Security::ServerOptions::updateContextEecdh(Security::ContextPtr &amp;ctx)
 {
     // set Elliptic Curve details into the server context
     if (!eecdhCurve.isEmpty()) {
         debugs(83, 9, &quot;Setting Ephemeral ECDH curve to &quot; &lt;&lt; eecdhCurve &lt;&lt; &quot;.&quot;);
 
 #if USE_OPENSSL &amp;&amp; OPENSSL_VERSION_NUMBER &gt;= 0x0090800fL &amp;&amp; !defined(OPENSSL_NO_ECDH)
         int nid = OBJ_sn2nid(eecdhCurve.c_str());
         if (!nid) {
             debugs(83, DBG_CRITICAL, &quot;ERROR: Unknown EECDH curve '&quot; &lt;&lt; eecdhCurve &lt;&lt; &quot;'&quot;);
             return;
         }
 
         auto ecdh = EC_KEY_new_by_curve_name(nid);
         if (!ecdh) {
             auto ssl_error = ERR_get_error();

=== modified file 'src/security/Session.cc'
--- src/security/Session.cc	2016-06-30 22:10:55 +0000
+++ src/security/Session.cc	2016-07-07 11:22:07 +0000
@@ -1,38 +1,45 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;ipc/MemMap.h&quot;
 #include &quot;security/Session.h&quot;
 #include &quot;SquidConfig.h&quot;
 
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
+#if USE_GNUTLS
+void
+squid_datum_free(gnutls_datum_t *D) {
+    gnutls_free(D);
+}
+#endif
+
 bool
 Security::SessionIsResumed(const Security::SessionPointer &amp;s)
 {
     return
 #if USE_OPENSSL
         SSL_session_reused(s.get()) == 1;
 #elif USE_GNUTLS
         gnutls_session_is_resumed(s.get()) != 0;
 #else
         false;
 #endif
 }
 
 void
 Security::GetSessionResumeData(const Security::SessionPointer &amp;s, Security::SessionStatePointer &amp;data)
 {
     if (!SessionIsResumed(s)) {
 #if USE_OPENSSL
         data.reset(SSL_get1_session(s.get()));
 #elif USE_GNUTLS

=== modified file 'src/security/Session.h'
--- src/security/Session.h	2016-06-30 22:10:55 +0000
+++ src/security/Session.h	2016-07-07 11:27:25 +0000
@@ -1,72 +1,72 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_SESSION_H
 #define SQUID_SRC_SECURITY_SESSION_H
 
-// LockingPointer.h instead of TidyPointer.h for CtoCpp1()
 #include &quot;security/LockingPointer.h&quot;
 
+#include &lt;memory&gt;
+
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 #endif
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_GNUTLS_H
 #include &lt;gnutls/gnutls.h&gt;
 #endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
 typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer&lt;SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL&gt; SessionPointer;
 
-typedef SSL_SESSION* SessionStatePtr;
-CtoCpp1(SSL_SESSION_free, SSL_SESSION *);
-typedef LockingPointer&lt;SSL_SESSION, Security::SSL_SESSION_free_cpp, CRYPTO_LOCK_SSL_SESSION&gt; SessionStatePointer;
+typedef std::unique_ptr&lt;SSL_SESSION, std::function&lt;decltype(SSL_SESSION_free)&gt;&gt; SessionStatePointer;
 
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
-CtoCpp1(gnutls_deinit, gnutls_session_t);
-// TODO: Convert to Locking pointer.
 // Locks can be implemented attaching locks counter to gnutls_session_t
 // objects using the gnutls_session_set_ptr()/gnutls_session_get_ptr ()
 // library functions
-typedef TidyPointer&lt;struct gnutls_session_int, Security::gnutls_deinit_cpp&gt; SessionPointer;
+CtoCpp1(gnutls_deinit, gnutls_session_t);
+typedef LockingPointer&lt;struct gnutls_session_int, gnutls_deinit_cpp, -1&gt; SessionPointer;
 
-typedef gnutls_datum_t *SessionStatePtr;
-CtoCpp1(gnutls_free, gnutls_datum_t *);
-typedef TidyPointer&lt;gnutls_datum_t, Security::gnutls_free_cpp&gt; SessionStatePointer;
+/// wrapper function to avoid compile errors with gnutls_free() being a typedef.
+void squid_datum_free(gnutls_datum_t *D);
+typedef std::unique_ptr&lt;gnutls_datum_t, std::function&lt;decltype(squid_datum_free)&gt;&gt; SessionStatePointer;
 
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
-typedef TidyPointer&lt;void, nullptr&gt; SessionPointer;
-typedef TidyPointer&lt;void, nullptr&gt; SessionStatePointer;
+CtoCpp1(xfree, SessionPtr);
+typedef LockingPointer&lt;void, xfree_cpp, -1&gt; SessionPointer;
+
+typedef std::unique_ptr&lt;int&gt; SessionStatePointer;
 
 #endif
 
 /// whether the session is a resumed one
 bool SessionIsResumed(const Security::SessionPointer &amp;);
 
 /// Retrieve the data needed to resume this session on a later connection
 void GetSessionResumeData(const Security::SessionPointer &amp;, Security::SessionStatePointer &amp;);
 
 /// Set the data for resuming a previous session.
 /// Needs to be done before using the SessionPointer for a handshake.
 void SetSessionResumeData(const Security::SessionPtr &amp;, const Security::SessionStatePointer &amp;);
 
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
 

=== modified file 'src/security/cert_generators/file/certificate_db.cc'
--- src/security/cert_generators/file/certificate_db.cc	2016-02-13 16:10:26 +0000
+++ src/security/cert_generators/file/certificate_db.cc	2016-07-04 16:39:09 +0000
@@ -1,33 +1,34 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;security/cert_generators/file/certificate_db.h&quot;
 
 #include &lt;cerrno&gt;
 #include &lt;fstream&gt;
+#include &lt;memory&gt;
 #include &lt;stdexcept&gt;
 #if HAVE_SYS_STAT_H
 #include &lt;sys/stat.h&gt;
 #endif
 #if HAVE_SYS_FILE_H
 #include &lt;sys/file.h&gt;
 #endif
 #if HAVE_FCNTL_H
 #include &lt;fcntl.h&gt;
 #endif
 
 #define HERE &quot;(security_file_certgen) &quot; &lt;&lt; __FILE__ &lt;&lt; ':' &lt;&lt; __LINE__ &lt;&lt; &quot;: &quot;
 
 Ssl::Lock::Lock(std::string const &amp;aFilename) :
     filename(aFilename),
 #if _SQUID_WINDOWS_
     hFile(INVALID_HANDLE_VALUE)
 #else
     fd(-1)
 #endif
@@ -235,137 +236,136 @@
     return strcmp(aa, bb);
 }
 
 unsigned long Ssl::CertificateDb::index_name_hash(const char **a) {
     return(lh_strhash(a[Ssl::CertificateDb::cnlName]));
 }
 
 int Ssl::CertificateDb::index_name_cmp(const char **a, const char **b) {
     return(strcmp(a[Ssl::CertificateDb::cnlName], b[CertificateDb::cnlName]));
 }
 
 const std::string Ssl::CertificateDb::db_file(&quot;index.txt&quot;);
 const std::string Ssl::CertificateDb::cert_dir(&quot;certs&quot;);
 const std::string Ssl::CertificateDb::size_file(&quot;size&quot;);
 
 Ssl::CertificateDb::CertificateDb(std::string const &amp; aDb_path, size_t aMax_db_size, size_t aFs_block_size)
     :  db_path(aDb_path),
        db_full(aDb_path + &quot;/&quot; + db_file),
        cert_full(aDb_path + &quot;/&quot; + cert_dir),
        size_full(aDb_path + &quot;/&quot; + size_file),
-       db(NULL),
        max_db_size(aMax_db_size),
        fs_block_size((aFs_block_size ? aFs_block_size : 2048)),
        dbLock(db_full),
        enabled_disk_store(true) {
     if (db_path.empty() &amp;&amp; !max_db_size)
         enabled_disk_store = false;
     else if ((db_path.empty() &amp;&amp; max_db_size) || (!db_path.empty() &amp;&amp; !max_db_size))
         throw std::runtime_error(&quot;security_file_certgen is missing the required parameter. There should be -s and -M parameters together.&quot;);
 }
 
 bool Ssl::CertificateDb::find(std::string const &amp; host_name, Security::CertPointer &amp; cert, Ssl::EVP_PKEY_Pointer &amp; pkey) {
     const Locker locker(dbLock, Here);
     load();
     return pure_find(host_name, cert, pkey);
 }
 
 bool Ssl::CertificateDb::purgeCert(std::string const &amp; key) {
     const Locker locker(dbLock, Here);
     load();
     if (!db)
         return false;
 
     if (!deleteByHostname(key))
         return false;
 
     save();
     return true;
 }
 
 bool Ssl::CertificateDb::addCertAndPrivateKey(Security::CertPointer &amp; cert, Ssl::EVP_PKEY_Pointer &amp; pkey, std::string const &amp; useName) {
     const Locker locker(dbLock, Here);
     load();
     if (!db || !cert || !pkey)
         return false;
     Row row;
     ASN1_INTEGER * ai = X509_get_serialNumber(cert.get());
     std::string serial_string;
     Ssl::BIGNUM_Pointer serial(ASN1_INTEGER_to_BN(ai, NULL));
     {
-        TidyPointer&lt;char, tidyFree&gt; hex_bn(BN_bn2hex(serial.get()));
+        std::unique_ptr&lt;char, std::function&lt;decltype(xfree)&gt;&gt; hex_bn(BN_bn2hex(serial.get()));
         serial_string = std::string(hex_bn.get());
     }
     row.setValue(cnlSerial, serial_string.c_str());
     char ** rrow = TXT_DB_get_by_index(db.get(), cnlSerial, row.getRow());
     // We are creating certificates with unique serial numbers. If the serial
     // number is found in the database, the same certificate is already stored.
     if (rrow != NULL) {
         // TODO: check if the stored row is valid.
         return true;
     }
 
     {
-        TidyPointer&lt;char, tidyFree&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
+        std::unique_ptr&lt;char, std::function&lt;decltype(xfree)&gt;&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), nullptr, 0));
         Security::CertPointer findCert;
         Ssl::EVP_PKEY_Pointer findPkey;
         if (pure_find(useName.empty() ? subject.get() : useName, findCert, findPkey)) {
             // Replace with database certificate
-            cert.reset(findCert.release());
-            pkey.reset(findPkey.release());
+            cert = std::move(findCert);
+            pkey = std::move(findPkey);
             return true;
         }
         // pure_find may fail because the entry is expired, or because the
         // certs file is corrupted. Remove any entry with given hostname
         deleteByHostname(useName.empty() ? subject.get() : useName);
     }
 
     // check db size while trying to minimize calls to size()
     size_t dbSize = size();
     if ((dbSize == 0 &amp;&amp; hasRows()) ||
             (dbSize &gt; 0 &amp;&amp; !hasRows()) ||
             (dbSize &gt;  10 * max_db_size)) {
         // Invalid database size, rebuild
         dbSize = rebuildSize();
     }
     while (dbSize &gt; max_db_size &amp;&amp; deleteInvalidCertificate()) {
         dbSize = size(); // get the current database size
         // and try to find another invalid certificate if needed
     }
     // there are no more invalid ones, but there must be valid certificates
     while (dbSize &gt; max_db_size) {
         if (!deleteOldestCertificate()) {
             rebuildSize(); // No certificates in database.Update the size file.
             save(); // Some entries may have been removed. Update the index file.
             return false; // errors prevented us from freeing enough space
         }
         dbSize = size(); // get the current database size
     }
 
     row.setValue(cnlType, &quot;V&quot;);
     ASN1_UTCTIME * tm = X509_get_notAfter(cert.get());
     row.setValue(cnlExp_date, std::string(reinterpret_cast&lt;char *&gt;(tm-&gt;data), tm-&gt;length).c_str());
     row.setValue(cnlFile, &quot;unknown&quot;);
     if (!useName.empty())
         row.setValue(cnlName, useName.c_str());
     else {
-        TidyPointer&lt;char, tidyFree&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
+        std::unique_ptr&lt;char, std::function&lt;decltype(xfree)&gt;&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), nullptr, 0));
         row.setValue(cnlName, subject.get());
     }
 
     if (!TXT_DB_insert(db.get(), row.getRow())) {
         // failed to add index (???) but we may have already modified
         // the database so save before exit
         save();
         return false;
     }
     rrow = row.getRow();
     row.reset();
 
     std::string filename(cert_full + &quot;/&quot; + serial_string + &quot;.pem&quot;);
     if (!writeCertAndPrivateKeyToFile(cert, pkey, filename.c_str())) {
         //remove row from txt_db and save
         sq_TXT_DB_delete(db.get(), (const char **)rrow);
         save();
         return false;
     }
     addSize(filename);

=== modified file 'src/security/cert_generators/file/security_file_certgen.cc'
--- src/security/cert_generators/file/security_file_certgen.cc	2016-05-02 03:17:18 +0000
+++ src/security/cert_generators/file/security_file_certgen.cc	2016-07-04 16:40:18 +0000
@@ -187,42 +187,42 @@
         throw std::runtime_error(&quot;Error while parsing the crtd request: &quot; + error);
 
     Ssl::CertificateDb db(db_path, max_db_size, fs_block_size);
 
     Security::CertPointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
     std::string &amp;cert_subject = certProperties.dbKey();
 
     bool dbFailed = false;
     try {
         db.find(cert_subject, cert, pkey);
     } catch (std::runtime_error &amp;err) {
         dbFailed = true;
         error = err.what();
     }
 
     if (cert.get()) {
         if (!Ssl::certificateMatchesProperties(cert.get(), certProperties)) {
             // The certificate changed (renewed or other reason).
             // Generete a new one with the updated fields.
-            cert.reset(NULL);
-            pkey.reset(NULL);
+            cert.resetWithoutLocking(nullptr);
+            pkey.resetWithoutLocking(nullptr);
             db.purgeCert(cert_subject);
         }
     }
 
     if (!cert || !pkey) {
         if (!Ssl::generateSslCertificate(cert, pkey, certProperties))
             throw std::runtime_error(&quot;Cannot create ssl certificate or private key.&quot;);
 
         if (!dbFailed &amp;&amp; db.IsEnabledDiskStore()) {
             try {
                 if (!db.addCertAndPrivateKey(cert, pkey, cert_subject)) {
                     dbFailed = true;
                     error = &quot;Cannot add certificate to db.&quot;;
                 }
             } catch (const std::runtime_error &amp;err) {
                 dbFailed = true;
                 error = err.what();
             }
         }
     }

=== modified file 'src/security/forward.h'
--- src/security/forward.h	2016-01-01 00:12:18 +0000
+++ src/security/forward.h	2016-06-29 15:28:46 +0000
@@ -2,40 +2,50 @@
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_FORWARD_H
 #define SQUID_SRC_SECURITY_FORWARD_H
 
 #include &quot;security/Context.h&quot;
 #include &quot;security/Session.h&quot;
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_X509_H
 #include &lt;gnutls/x509.h&gt;
 #endif
 #endif
 #include &lt;list&gt;
 
+#if USE_OPENSSL
+// Macro to be used to define the C++ wrapper functor of the sk_*_pop_free
+// OpenSSL family of functions. The C++ functor is suffixed with the _free_wrapper
+// extension
+#define sk_dtor_wrapper(sk_object, argument_type, freefunction) \
+        struct sk_object ## _free_wrapper { \
+            void operator()(argument_type a) { sk_object ## _pop_free(a, freefunction); } \
+        }
+#endif /* USE_OPENSSL */
+
 /* flags a SSL connection can be configured with */
 #define SSL_FLAG_NO_DEFAULT_CA      (1&lt;&lt;0)
 #define SSL_FLAG_DELAYED_AUTH       (1&lt;&lt;1)
 #define SSL_FLAG_DONT_VERIFY_PEER   (1&lt;&lt;2)
 #define SSL_FLAG_DONT_VERIFY_DOMAIN (1&lt;&lt;3)
 #define SSL_FLAG_NO_SESSION_REUSE   (1&lt;&lt;4)
 #define SSL_FLAG_VERIFY_CRL         (1&lt;&lt;5)
 #define SSL_FLAG_VERIFY_CRL_ALL     (1&lt;&lt;6)
 
 /// Network/connection security abstraction layer
 namespace Security
 {
 
 class EncryptorAnswer;
 class PeerOptions;
 class ServerOptions;
 
 #if USE_OPENSSL
 CtoCpp1(X509_free, X509 *)
 typedef Security::LockingPointer&lt;X509, X509_free_cpp, CRYPTO_LOCK_X509&gt; CertPointer;

=== modified file 'src/ssl/PeekingPeerConnector.cc'
--- src/ssl/PeekingPeerConnector.cc	2016-05-18 16:35:36 +0000
+++ src/ssl/PeekingPeerConnector.cc	2016-07-04 15:22:24 +0000
@@ -322,55 +322,55 @@
     Ssl::PeerConnector::noteSslNegotiationError(result, ssl_error, ssl_lib_error);
 }
 
 void
 Ssl::PeekingPeerConnector::handleServerCertificate()
 {
     if (serverCertificateHandled)
         return;
 
     if (ConnStateData *csd = request-&gt;clientConnectionManager.valid()) {
         const int fd = serverConnection()-&gt;fd;
         Security::SessionPtr ssl = fd_table[fd].ssl.get();
         Security::CertPointer serverCert(SSL_get_peer_certificate(ssl));
         if (!serverCert.get())
             return;
 
         serverCertificateHandled = true;
 
         // remember the server certificate for later use
         if (Ssl::ServerBump *serverBump = csd-&gt;serverBump()) {
-            serverBump-&gt;serverCert.reset(serverCert.release());
+            serverBump-&gt;serverCert = std::move(serverCert);
         }
     }
 }
 
 void
 Ssl::PeekingPeerConnector::serverCertificateVerified()
 {
     if (ConnStateData *csd = request-&gt;clientConnectionManager.valid()) {
         Security::CertPointer serverCert;
         if(Ssl::ServerBump *serverBump = csd-&gt;serverBump())
             serverCert.resetAndLock(serverBump-&gt;serverCert.get());
         else {
             const int fd = serverConnection()-&gt;fd;
             Security::SessionPtr ssl = fd_table[fd].ssl.get();
-            serverCert.reset(SSL_get_peer_certificate(ssl));
+            serverCert.resetWithoutLocking(SSL_get_peer_certificate(ssl));
         }
         if (serverCert.get()) {
             csd-&gt;resetSslCommonName(Ssl::CommonHostName(serverCert.get()));
             debugs(83, 5, &quot;HTTPS server CN: &quot; &lt;&lt; csd-&gt;sslCommonName() &lt;&lt;
                    &quot; bumped: &quot; &lt;&lt; *serverConnection());
         }
     }
 }
 
 void
 Ssl::PeekingPeerConnector::tunnelInsteadOfNegotiating()
 {
     Must(callback != NULL);
     CbDialer *dialer = dynamic_cast&lt;CbDialer*&gt;(callback-&gt;getDialer());
     Must(dialer);
     dialer-&gt;answer().tunneled = true;
     debugs(83, 5, &quot;The SSL negotiation with server aborted&quot;);
 }
 

=== modified file 'src/ssl/gadgets.cc'
--- src/ssl/gadgets.cc	2016-06-14 18:12:14 +0000
+++ src/ssl/gadgets.cc	2016-07-04 16:37:08 +0000
@@ -113,59 +113,59 @@
     if (!bio)
         return false;
     if (!BIO_write_filename(bio.get(), const_cast&lt;char *&gt;(filename)))
         return false;
 
     if (!PEM_write_bio_X509(bio.get(), cert.get()))
         return false;
 
     if (!PEM_write_bio_PrivateKey(bio.get(), pkey.get(), NULL, NULL, 0, NULL, NULL))
         return false;
 
     return true;
 }
 
 bool Ssl::readCertAndPrivateKeyFromMemory(Security::CertPointer &amp; cert, Ssl::EVP_PKEY_Pointer &amp; pkey, char const * bufferToRead)
 {
     Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
     BIO_puts(bio.get(), bufferToRead);
 
     X509 * certPtr = NULL;
-    cert.reset(PEM_read_bio_X509(bio.get(), &amp;certPtr, 0, 0));
+    cert.resetWithoutLocking(PEM_read_bio_X509(bio.get(), &amp;certPtr, 0, 0));
     if (!cert)
         return false;
 
     EVP_PKEY * pkeyPtr = NULL;
-    pkey.reset(PEM_read_bio_PrivateKey(bio.get(), &amp;pkeyPtr, 0, 0));
+    pkey.resetWithoutLocking(PEM_read_bio_PrivateKey(bio.get(), &amp;pkeyPtr, 0, 0));
     if (!pkey)
         return false;
 
     return true;
 }
 
 bool Ssl::readCertFromMemory(Security::CertPointer &amp; cert, char const * bufferToRead)
 {
     Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
     BIO_puts(bio.get(), bufferToRead);
 
     X509 * certPtr = NULL;
-    cert.reset(PEM_read_bio_X509(bio.get(), &amp;certPtr, 0, 0));
+    cert.resetWithoutLocking(PEM_read_bio_X509(bio.get(), &amp;certPtr, 0, 0));
     if (!cert)
         return false;
 
     return true;
 }
 
 // According to RFC 5280 (Section A.1), the common name length in a certificate
 // can be at most 64 characters
 static const size_t MaxCnLen = 64;
 
 // Replace certs common name with the given
 static bool replaceCommonName(Security::CertPointer &amp; cert, std::string const &amp;rawCn)
 {
     std::string cn = rawCn;
 
     if (cn.length() &gt; MaxCnLen) {
         // In the case the length od CN is more than the maximum supported size
         // try to use the first upper level domain.
         size_t pos = 0;
         do {
@@ -494,81 +494,81 @@
             }
         }
 
         addedExtensions += mimicExtensions(cert, properties.mimicCert, properties.signWithX509);
 
         // According to RFC 5280, using extensions requires v3 certificate.
         if (addedExtensions)
             X509_set_version(cert.get(), 2); // value 2 means v3
     }
 
     return true;
 }
 
 static bool generateFakeSslCertificate(Security::CertPointer &amp; certToStore, Ssl::EVP_PKEY_Pointer &amp; pkeyToStore, Ssl::CertificateProperties const &amp;properties,  Ssl::BIGNUM_Pointer const &amp;serial)
 {
     Ssl::EVP_PKEY_Pointer pkey;
     // Use signing certificates private key as generated certificate private key
     if (properties.signWithPkey.get())
         pkey.resetAndLock(properties.signWithPkey.get());
     else // if not exist generate one
-        pkey.reset(Ssl::createSslPrivateKey());
+        pkey.resetWithoutLocking(Ssl::createSslPrivateKey());
 
     if (!pkey)
         return false;
 
     Security::CertPointer cert(X509_new());
     if (!cert)
         return false;
 
     // Set pub key and serial given by the caller
     if (!X509_set_pubkey(cert.get(), pkey.get()))
         return false;
     if (!setSerialNumber(X509_get_serialNumber(cert.get()), serial.get()))
         return false;
 
     // Fill the certificate with the required properties
     if (!buildCertificate(cert, properties))
         return false;
 
     int ret = 0;
     // Set issuer name, from CA or our subject name for self signed cert
     if (properties.signAlgorithm != Ssl::algSignSelf &amp;&amp; properties.signWithX509.get())
         ret = X509_set_issuer_name(cert.get(), X509_get_subject_name(properties.signWithX509.get()));
     else // Self signed certificate, set issuer to self
         ret = X509_set_issuer_name(cert.get(), X509_get_subject_name(cert.get()));
     if (!ret)
         return false;
 
     const  EVP_MD *hash = properties.signHash ? properties.signHash : EVP_get_digestbyname(SQUID_SSL_SIGN_HASH_IF_NONE);
     assert(hash);
     /*Now sign the request */
     if (properties.signAlgorithm != Ssl::algSignSelf &amp;&amp; properties.signWithPkey.get())
         ret = X509_sign(cert.get(), properties.signWithPkey.get(), hash);
     else //else sign with self key (self signed request)
         ret = X509_sign(cert.get(), pkey.get(), hash);
 
     if (!ret)
         return false;
 
-    certToStore.reset(cert.release());
-    pkeyToStore.reset(pkey.release());
+    certToStore = std::move(cert);
+    pkeyToStore = std::move(pkey);
     return true;
 }
 
 static  BIGNUM *createCertSerial(unsigned char *md, unsigned int n)
 {
 
     assert(n == 20); //for sha1 n is 20 (for md5 n is 16)
 
     BIGNUM *serial = NULL;
     serial = BN_bin2bn(md, n, NULL);
 
     // if the serial is &quot;0&quot; set it to '1'
     if (BN_is_zero(serial) == true)
         BN_one(serial);
 
     // serial size does not exceed 20 bytes
     assert(BN_num_bits(serial) &lt;= 160);
 
     // According the RFC 5280, serial is an 20 bytes ASN.1 INTEGER (a signed big integer)
     // and the maximum value for X.509 certificate serial number is 2^159-1 and
@@ -659,45 +659,45 @@
     return certificate;
 }
 
 EVP_PKEY * Ssl::readSslPrivateKey(char const * keyFilename, pem_password_cb *passwd_callback)
 {
     if (!keyFilename)
         return NULL;
     Ssl::BIO_Pointer bio(BIO_new(BIO_s_file_internal()));
     if (!bio)
         return NULL;
     if (!BIO_read_filename(bio.get(), keyFilename))
         return NULL;
     EVP_PKEY *pkey = PEM_read_bio_PrivateKey(bio.get(), NULL, passwd_callback, NULL);
     return pkey;
 }
 
 void Ssl::readCertAndPrivateKeyFromFiles(Security::CertPointer &amp; cert, Ssl::EVP_PKEY_Pointer &amp; pkey, char const * certFilename, char const * keyFilename)
 {
     if (keyFilename == NULL)
         keyFilename = certFilename;
-    pkey.reset(readSslPrivateKey(keyFilename));
-    cert.reset(readSslX509Certificate(certFilename));
+    pkey.resetWithoutLocking(readSslPrivateKey(keyFilename));
+    cert.resetWithoutLocking(readSslX509Certificate(certFilename));
     if (!pkey || !cert || !X509_check_private_key(cert.get(), pkey.get())) {
-        pkey.reset(NULL);
-        cert.reset(NULL);
+        pkey.resetWithoutLocking(nullptr);
+        cert.resetWithoutLocking(nullptr);
     }
 }
 
 bool Ssl::sslDateIsInTheFuture(char const * date)
 {
     ASN1_UTCTIME tm;
     tm.flags = 0;
     tm.type = 23;
     tm.data = (unsigned char *)date;
     tm.length = strlen(date);
 
     return (X509_cmp_current_time(&amp;tm) &gt; 0);
 }
 
 /// Print the time represented by a ASN1_TIME struct to a string using GeneralizedTime format
 static bool asn1timeToGeneralizedTimeStr(ASN1_TIME *aTime, char *buf, int bufLen)
 {
     // ASN1_Time  holds time to UTCTime or GeneralizedTime form.
     // UTCTime has the form YYMMDDHHMMSS[Z | [+|-]offset]
     // GeneralizedTime has the form YYYYMMDDHHMMSS[Z | [+|-] offset]

=== modified file 'src/ssl/gadgets.h'
--- src/ssl/gadgets.h	2016-06-14 15:56:12 +0000
+++ src/ssl/gadgets.h	2016-06-29 15:28:46 +0000
@@ -22,87 +22,75 @@
 
 namespace Ssl
 {
 /**
  \defgroup SslCrtdSslAPI SSL certificate generator API
  These functions must not depend on Squid runtime code such as debug()
  because they are used by security_file_certgen helper.
  */
 
 #if SQUID_USE_CONST_SSL_METHOD
 typedef const SSL_METHOD * ContextMethod;
 #else
 typedef SSL_METHOD * ContextMethod;
 #endif
 
 #if !defined(SQUID_SSL_SIGN_HASH_IF_NONE)
 #define SQUID_SSL_SIGN_HASH_IF_NONE &quot;sha256&quot;
 #endif
 
 /**
- \ingroup SslCrtdSslAPI
- * TidyPointer typedefs for  common SSL objects
+ * std::unique_ptr typedefs for common SSL objects
  */
-sk_free_wrapper(sk_X509, STACK_OF(X509) *, X509_free)
-typedef TidyPointer&lt;STACK_OF(X509), sk_X509_free_wrapper&gt; X509_STACK_Pointer;
+sk_dtor_wrapper(sk_X509, STACK_OF(X509) *, X509_free);
+typedef std::unique_ptr&lt;STACK_OF(X509), sk_X509_free_wrapper&gt; X509_STACK_Pointer;
 
 CtoCpp1(EVP_PKEY_free, EVP_PKEY *)
 typedef Security::LockingPointer&lt;EVP_PKEY, EVP_PKEY_free_cpp, CRYPTO_LOCK_EVP_PKEY&gt; EVP_PKEY_Pointer;
 
-CtoCpp1(BN_free, BIGNUM *)
-typedef TidyPointer&lt;BIGNUM, BN_free_cpp&gt; BIGNUM_Pointer;
+typedef std::unique_ptr&lt;BIGNUM, std::function&lt;decltype(BN_free)&gt;&gt; BIGNUM_Pointer;
 
-CtoCpp1(BIO_free, BIO *)
-typedef TidyPointer&lt;BIO, BIO_free_cpp&gt; BIO_Pointer;
+typedef std::unique_ptr&lt;BIO, std::function&lt;decltype(BIO_free)&gt;&gt; BIO_Pointer;
 
-CtoCpp1(ASN1_INTEGER_free, ASN1_INTEGER *)
-typedef TidyPointer&lt;ASN1_INTEGER, ASN1_INTEGER_free_cpp&gt; ASN1_INT_Pointer;
+typedef std::unique_ptr&lt;ASN1_INTEGER, std::function&lt;decltype(ASN1_INTEGER_free)&gt;&gt; ASN1_INT_Pointer;
 
-CtoCpp1(ASN1_OCTET_STRING_free, ASN1_OCTET_STRING *)
-typedef TidyPointer&lt;ASN1_OCTET_STRING, ASN1_OCTET_STRING_free_cpp&gt; ASN1_OCTET_STRING_Pointer;
+typedef std::unique_ptr&lt;ASN1_OCTET_STRING, std::function&lt;decltype(ASN1_OCTET_STRING_free)&gt;&gt; ASN1_OCTET_STRING_Pointer;
 
-CtoCpp1(TXT_DB_free, TXT_DB *)
-typedef TidyPointer&lt;TXT_DB, TXT_DB_free_cpp&gt; TXT_DB_Pointer;
+typedef std::unique_ptr&lt;TXT_DB, std::function&lt;decltype(TXT_DB_free)&gt;&gt; TXT_DB_Pointer;
 
-CtoCpp1(X509_NAME_free, X509_NAME *)
-typedef TidyPointer&lt;X509_NAME, X509_NAME_free_cpp&gt; X509_NAME_Pointer;
+typedef std::unique_ptr&lt;X509_NAME, std::function&lt;decltype(X509_NAME_free)&gt;&gt; X509_NAME_Pointer;
 
-CtoCpp1(RSA_free, RSA *)
-typedef TidyPointer&lt;RSA, RSA_free_cpp&gt; RSA_Pointer;
+typedef std::unique_ptr&lt;RSA, std::function&lt;decltype(RSA_free)&gt;&gt; RSA_Pointer;
 
-CtoCpp1(X509_REQ_free, X509_REQ *)
-typedef TidyPointer&lt;X509_REQ, X509_REQ_free_cpp&gt; X509_REQ_Pointer;
+typedef std::unique_ptr&lt;X509_REQ, std::function&lt;decltype(X509_REQ_free)&gt;&gt; X509_REQ_Pointer;
 
-sk_free_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free)
-typedef TidyPointer&lt;STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper&gt; X509_NAME_STACK_Pointer;
+sk_dtor_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free);
+typedef std::unique_ptr&lt;STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper&gt; X509_NAME_STACK_Pointer;
 
-CtoCpp1(AUTHORITY_KEYID_free, AUTHORITY_KEYID *)
-typedef TidyPointer&lt;AUTHORITY_KEYID, AUTHORITY_KEYID_free_cpp&gt; AUTHORITY_KEYID_Pointer;
+typedef std::unique_ptr&lt;AUTHORITY_KEYID, std::function&lt;decltype(AUTHORITY_KEYID_free)&gt;&gt; AUTHORITY_KEYID_Pointer;
 
-sk_free_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free)
-typedef TidyPointer&lt;STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper&gt; GENERAL_NAME_STACK_Pointer;
+sk_dtor_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free);
+typedef std::unique_ptr&lt;STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper&gt; GENERAL_NAME_STACK_Pointer;
 
-CtoCpp1(GENERAL_NAME_free, GENERAL_NAME *)
-typedef TidyPointer&lt;GENERAL_NAME, GENERAL_NAME_free_cpp&gt; GENERAL_NAME_Pointer;
+typedef std::unique_ptr&lt;GENERAL_NAME, std::function&lt;decltype(GENERAL_NAME_free)&gt;&gt; GENERAL_NAME_Pointer;
 
-CtoCpp1(X509_EXTENSION_free, X509_EXTENSION *)
-typedef TidyPointer&lt;X509_EXTENSION, X509_EXTENSION_free_cpp&gt; X509_EXTENSION_Pointer;
+typedef std::unique_ptr&lt;X509_EXTENSION, std::function&lt;decltype(X509_EXTENSION_free)&gt;&gt; X509_EXTENSION_Pointer;
 
 /**
  \ingroup SslCrtdSslAPI
  * Create 1024 bits rsa key.
  */
 EVP_PKEY * createSslPrivateKey();
 
 /**
  \ingroup SslCrtdSslAPI
  * Write private key and SSL certificate to memory.
  */
 bool writeCertAndPrivateKeyToMemory(Security::CertPointer const &amp; cert, EVP_PKEY_Pointer const &amp; pkey, std::string &amp; bufferToWrite);
 
 /**
  \ingroup SslCrtdSslAPI
  * Append SSL certificate to bufferToWrite.
  */
 bool appendCertToMemory(Security::CertPointer const &amp; cert, std::string &amp; bufferToWrite);
 
 /**

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2016-07-05 17:00:36 +0000
+++ src/ssl/support.cc	2016-07-05 23:39:23 +0000
@@ -298,41 +298,41 @@
             debugs(83, 5, err_descr &lt;&lt; &quot;: &quot; &lt;&lt; buffer);
         else
             debugs(83, DBG_IMPORTANT, &quot;SSL unknown certificate error &quot; &lt;&lt; error_no &lt;&lt; &quot; in &quot; &lt;&lt; buffer);
 
         // Check if the certificate error can be bypassed.
         // Infinity validation loop errors can not bypassed.
         if (error_no != SQUID_X509_V_ERR_INFINITE_VALIDATION) {
             if (check) {
                 ACLFilledChecklist *filledCheck = Filled(check);
                 assert(!filledCheck-&gt;sslErrors);
                 filledCheck-&gt;sslErrors = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
                 filledCheck-&gt;serverCert.resetAndLock(peer_cert);
                 if (check-&gt;fastCheck() == ACCESS_ALLOWED) {
                     debugs(83, 3, &quot;bypassing SSL error &quot; &lt;&lt; error_no &lt;&lt; &quot; in &quot; &lt;&lt; buffer);
                     ok = 1;
                 } else {
                     debugs(83, 5, &quot;confirming SSL error &quot; &lt;&lt; error_no);
                 }
                 delete filledCheck-&gt;sslErrors;
                 filledCheck-&gt;sslErrors = NULL;
-                filledCheck-&gt;serverCert.reset(NULL);
+                filledCheck-&gt;serverCert.resetWithoutLocking(nullptr);
             }
             // If the certificate validator is used then we need to allow all errors and
             // pass them to certficate validator for more processing
             else if (Ssl::TheConfig.ssl_crt_validator) {
                 ok = 1;
             }
         }
     }
 
     if (Ssl::TheConfig.ssl_crt_validator) {
         // Check if we have stored certificates chain. Store if not.
         if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
             STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
             if (certStack &amp;&amp; !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
                 sk_X509_pop_free(certStack, X509_free);
         }
     }
 
     if (!ok &amp;&amp; !SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) ) {
 
@@ -1250,45 +1250,45 @@
     return certificate;
 }
 
 void Ssl::readCertChainAndPrivateKeyFromFiles(Security::CertPointer &amp; cert, EVP_PKEY_Pointer &amp; pkey, X509_STACK_Pointer &amp; chain, char const * certFilename, char const * keyFilename)
 {
     if (keyFilename == NULL)
         keyFilename = certFilename;
 
     if (certFilename == NULL)
         certFilename = keyFilename;
 
     debugs(83, DBG_IMPORTANT, &quot;Using certificate in &quot; &lt;&lt; certFilename);
 
     if (!chain)
         chain.reset(sk_X509_new_null());
     if (!chain)
         debugs(83, DBG_IMPORTANT, &quot;WARNING: unable to allocate memory for cert chain&quot;);
     // XXX: ssl_ask_password_cb needs SSL_CTX_set_default_passwd_cb_userdata()
     // so this may not fully work iff Config.Program.ssl_password is set.
     pem_password_cb *cb = ::Config.Program.ssl_password ? &amp;ssl_ask_password_cb : NULL;
-    pkey.reset(readSslPrivateKey(keyFilename, cb));
-    cert.reset(readSslX509CertificatesChain(certFilename, chain.get()));
+    pkey.resetWithoutLocking(readSslPrivateKey(keyFilename, cb));
+    cert.resetWithoutLocking(readSslX509CertificatesChain(certFilename, chain.get()));
     if (!pkey || !cert || !X509_check_private_key(cert.get(), pkey.get())) {
-        pkey.reset(NULL);
-        cert.reset(NULL);
+        pkey.resetWithoutLocking(nullptr);
+        cert.resetWithoutLocking(nullptr);
     }
 }
 
 bool Ssl::generateUntrustedCert(Security::CertPointer &amp;untrustedCert, EVP_PKEY_Pointer &amp;untrustedPkey, Security::CertPointer const  &amp;cert, EVP_PKEY_Pointer const &amp; pkey)
 {
     // Generate the self-signed certificate, using a hard-coded subject prefix
     Ssl::CertificateProperties certProperties;
     if (const char *cn = CommonHostName(cert.get())) {
         certProperties.commonName = &quot;Not trusted by \&quot;&quot;;
         certProperties.commonName += cn;
         certProperties.commonName += &quot;\&quot;&quot;;
     } else if (const char *org = getOrganization(cert.get())) {
         certProperties.commonName =  &quot;Not trusted by \&quot;&quot;;
         certProperties.commonName += org;
         certProperties.commonName += &quot;\&quot;&quot;;
     } else
         certProperties.commonName =  &quot;Not trusted&quot;;
     certProperties.setCommonName = true;
     // O, OU, and other CA subject fields will be mimicked
     // Expiration date and other common properties will be mimicked
@@ -1296,41 +1296,41 @@
     certProperties.signWithPkey.resetAndLock(pkey.get());
     certProperties.mimicCert.resetAndLock(cert.get());
     return Ssl::generateSslCertificate(untrustedCert, untrustedPkey, certProperties);
 }
 
 SSL *
 SslCreate(Security::ContextPtr sslContext, const int fd, Ssl::Bio::Type type, const char *squidCtx)
 {
     if (fd &lt; 0) {
         debugs(83, DBG_IMPORTANT, &quot;Gone connection&quot;);
         return NULL;
     }
 
     const char *errAction = NULL;
     int errCode = 0;
     if (auto ssl = SSL_new(sslContext)) {
         // without BIO, we would call SSL_set_fd(ssl, fd) instead
         if (BIO *bio = Ssl::Bio::Create(fd, type)) {
             Ssl::Bio::Link(ssl, bio); // cannot fail
 
-            fd_table[fd].ssl.reset(ssl);
+            fd_table[fd].ssl.resetWithoutLocking(ssl);
             fd_table[fd].read_method = &amp;ssl_read_method;
             fd_table[fd].write_method = &amp;ssl_write_method;
             fd_note(fd, squidCtx);
             return ssl;
         }
         errCode = ERR_get_error();
         errAction = &quot;failed to initialize I/O&quot;;
         SSL_free(ssl);
     } else {
         errCode = ERR_get_error();
         errAction = &quot;failed to allocate handle&quot;;
     }
 
     debugs(83, DBG_IMPORTANT, &quot;ERROR: &quot; &lt;&lt; squidCtx &lt;&lt; ' ' &lt;&lt; errAction &lt;&lt;
            &quot;: &quot; &lt;&lt; ERR_error_string(errCode, NULL));
     return NULL;
 }
 
 SSL *
 Ssl::CreateClient(Security::ContextPtr sslContext, const int fd, const char *squidCtx)

</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006126.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006135.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6133">[ date ]</a>
              <a href="thread.html#6133">[ thread ]</a>
              <a href="subject.html#6133">[ subject ]</a>
              <a href="author.html#6133">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
