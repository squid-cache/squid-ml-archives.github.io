<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Care and feeding of ConnStateData
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Care%20and%20feeding%20of%20ConnStateData&In-Reply-To=%3C2fff1895-4f2f-e0a6-a795-e3dbde4715da%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006132.html">
   <LINK REL="Next"  HREF="006139.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Care and feeding of ConnStateData</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Care%20and%20feeding%20of%20ConnStateData&In-Reply-To=%3C2fff1895-4f2f-e0a6-a795-e3dbde4715da%40treenet.co.nz%3E"
       TITLE="[squid-dev] Care and feeding of ConnStateData">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Jul  7 22:16:01 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006132.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
        <LI>Next message: <A HREF="006139.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6134">[ date ]</a>
              <a href="thread.html#6134">[ thread ]</a>
              <a href="subject.html#6134">[ subject ]</a>
              <a href="author.html#6134">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 8/07/2016 7:22 a.m., Alex Rousskov wrote:
&gt;<i> On 07/06/2016 10:52 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 7/07/2016 10:24 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> Q1. What is ConnStateData (and related client_side.* code)?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   C1. ConnStateData is the code shared among all Servers (BB1).
</I>&gt;&gt;&gt;<i>   C2. ConnStateData ends where request routing code (BB2) begins.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Last time we went over this issue AFAIK we agreed that the above was to
</I>&gt;&gt;<i> be the defintion of ::Server.
</I>&gt;<i> 
</I>&gt;<i> Yes, it is a definition of the future Server class.
</I>&gt;<i> 
</I>&gt;<i> IIRC, last time we talked about it, the C2 rule specifically and BB2
</I>&gt;<i> role in general have not been discussed. Now C2 became important for the
</I>&gt;<i> right Downloader placement (and it has other nice side effects that I am
</I>&gt;<i> not discussing here to stay focused).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Pieces of ConnStateData which are meeting that description should be
</I>&gt;&gt;<i> suffled up into Server.
</I>&gt;<i> 
</I>&gt;<i> I strongly disagree! Isolating and moving pieces of C1/C2 compliant code
</I>&gt;<i> into a parent class not only results in a lot more work but also forces
</I>&gt;<i> us to create temporary pure virtual functions to tie the two classes
</I>&gt;<i> together and it tempts folks to inherit from the wrong class. It creates
</I>&gt;<i> complex relationships that are not needed today and will then have to be
</I>&gt;<i> dismantled later.
</I>&gt;<i> 
</I>&gt;<i> The correct approach is to move pieces that do _not_ satisfy the above
</I>&gt;<i> rules out of ConnStateData and then eventually rename ConnStateData to
</I>&gt;<i> Server. This approach creates no extra work and actually reduces
</I>&gt;<i> complexity with virtually every step.
</I>&gt;<i> 
</I>&gt;<i> More on that further below where Q4 is discussed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Q2. Where does the pending Downloader class belong?
</I>&gt;<i> 
</I>&gt;&gt;<i> In overview I think if we have a good Downloader design those other
</I>&gt;&gt;<i> things and ESIInclude should probably be converted into Downloader or
</I>&gt;&gt;<i> children of it.
</I>&gt;<i> 
</I>&gt;<i> Yes, but if and only if ESI needs to download small SBuf-storable
</I>&gt;<i> things. If ESI needs potentially large HTTP response bodies, then ESI
</I>&gt;<i> cannot be refactored to use Downloader.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Q3. Where does the future Http::Two::Server class belong?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Today, that common parent for the two siblings is ConnStateData.
</I>&gt;&gt;&gt;<i> Tomorrow, we may split and/or rename ConnStateData, of course, but
</I>&gt;&gt;&gt;<i> Http::One::Server and Http::Two::Server classes are likely to remain
</I>&gt;&gt;&gt;<i> siblings with a common base that contains the code they share.
</I>&gt;<i> 
</I>&gt;&gt;<i> My draft branch uses ::Server as parent to Http2::Server. I've not yet
</I>&gt;&gt;<i> run across anything in ConnStateData that needed it to be a child of
</I>&gt;&gt;<i> that. Though there are things that need moving up to the Server parent
</I>&gt;&gt;<i> class.
</I>&gt;<i> 
</I>&gt;<i> The last two sentences seem to contradict each other, but this
</I>&gt;<i> particular difference in opinion does not seem to be very important at
</I>&gt;<i> the moment: If your Http2::Server works as a Server child, it can work
</I>&gt;<i> as a ConnStateData child with very little extra effort. I do object to
</I>&gt;<i> moving stuff from ConnStateData to Server, but that is a separate
</I>&gt;<i> problem discussed below.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Q4. What to do with the existing src/servers/Server.h?
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Today, that class is a nuisance:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> * It is not a common base for all servers (its stated purpose).
</I>&gt;<i> 
</I>&gt;&gt;<i> Which servers is it not a base for exactly?
</I>&gt;<i> 
</I>&gt;<i> All of them! Http::One::Server and Ftp::Server base is ConnStateData,
</I>&gt;<i> not the current class in src/servers/Server.h. And, if my answer to Q3
</I>&gt;<i> is correct, Http::Two::Server base will be ConnStateData and not the
</I>&gt;<i> current class in src/servers/Server.h either.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Note that as parent of ConnStateData for now anything which implements
</I>&gt;&gt;<i> ConnStateData implements Server.
</I>&gt;<i> 
</I>&gt;<i> This is not quite accurate, actually (children can hide parent
</I>&gt;<i> interfaces), but it is irrelevant for the above bullet. ConnStateData
</I>&gt;<i> kids do not know about and do not benefit from src/servers/Server.h
</I>&gt;<i> existence or the ConnStateData split. The class in src/servers/Server.h
</I>&gt;<i> is not their common base. ConnStateData is.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> * It does not fully encapsulate connection-managing code of its kids
</I>&gt;&gt;&gt;<i> (its stated usage).
</I>&gt;<i> 
</I>&gt;&gt;<i> ... those changes to make it so got blocked in audit.
</I>&gt;<i> 
</I>&gt;<i> Whether some future changes will or will not address this part of the
</I>&gt;<i> problem is pretty much irrelevant to the problem existence (it only
</I>&gt;<i> confirms that existence if you will).
</I>
Its pretty significant that you blocked a class being implemented to
match its design and now use the fact that its not happeed as a reason
against the class existing at all.


&gt;<i> 
</I>&gt;&gt;&gt;<i> * It is essentially unused (it is not used as an API by others and has
</I>&gt;&gt;&gt;<i> only one kid).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ... the other child class go blocked in audit initially and still
</I>&gt;&gt;<i> waiting the major redesign to be completed before it can be re-suvmitted.
</I>&gt;<i> 
</I>&gt;<i> Similar to the above, I do not think it is a good idea to keep that
</I>&gt;<i> currently broken class just because it might be needed in the future.
</I>&gt;<i> Moreover, I would not be surprised if its wrongful existence already
</I>&gt;<i> exerts negative influence on that future code!
</I>
Our disgareement is about which class of the two is &quot;broken&quot;.

IMO a class lacking some of its needed API (::Server) is far less broken
than a class with a lot of differently scoped bits tacked on all over
the place (ConnStateData).

An incomplete class can easily be completed without braking the things
depending on the existing parts. Not so the 'kitcen sink' one.

&gt;<i> 
</I>&gt;&gt;<i> The two grandchildren in trunk we planned to make direct children of it
</I>&gt;&gt;<i> (yes we, all three of us at the time agreed). The intermediate kid being
</I>&gt;&gt;<i> the ConnStateData mess still *temporarily* in the middle of the hierarchy.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> *If* I agreed on moving Server code out of ConnStateData instead of
</I>&gt;<i> moving non-Server code out of ConnStateData, then I made a major mistake!
</I>&gt;<i> 
</I>&gt;<i> What anybody did or did not say years ago is secondary to the current
</I>&gt;<i> discussion,
</I>
It is the status-quo design basis on which the current discussion is
taking place. So yeah, it is relevant.


&gt;<i> but I know that in 2014 I said pretty much the same thing I
</I>&gt;<i> am saying now[4]: &quot;Keep ConnStateData as is for now, until somebody
</I>&gt;<i> volunteers to extract HTTP code from it and place the extracted HTTP
</I>&gt;<i> code into servers/HttpServer, moving the remaining generic code into
</I>&gt;<i> src/servers/Server and src/http/&quot;.
</I>&gt;<i> 
</I>
Yes, exactly. As the person who for all those years has been attemping
to *do* that work...


&gt;<i> In other words:
</I>&gt;<i> 
</I>&gt;<i>   1. Extract HTTP server-specific code from ConnStateData.
</I>&gt;<i> 
</I>&gt;<i>   ...once #1 is done, ConnStateData will only have generic code left...
</I>&gt;<i> 
</I>
Assuming the extraction happens and audit does not block it. Which was
my point above.

I *have* been proposing exactly those changes and getting blocks thrown
up constantly preventing stuff being moved out of ConnStateData.

Usually on grounds that as a parial-measure its not good enough, like
ConnStateData as a whole (huge and messy as it is) must be retained and
perfected in a single step before anything is acceptible.


&gt;<i>   2. Move that remaining generic code into src/servers/Server and src/http/.
</I>&gt;<i> 
</I>&gt;<i> We all have been doing step #1 since then, but we are not yet ready for
</I>&gt;<i> step #2 because ConnStateData still has HTTP server-specific code in it.
</I>
Apart from auditing all I'm seeing from Factory is more and more
non-Server things being added to ConnStateData. First it was 1xx message
handling, then ssl-bump, then all the FTP translation logics, then
Downloader (thanks for reversing on that one).

If not for those specific projects ConnStateData would be around half
its current size with a much simpler Server &lt;-&gt;BB2 split.

&gt;<i> 
</I>&gt;<i> When we are ready for step #2, the &quot;move&quot; will be exactly that -- we
</I>&gt;<i> will be moving files and renaming classes to match their new location.
</I>&gt;<i> There is no time in this plan where there are two Server classes, one
</I>&gt;<i> called &quot;Server&quot; and one called &quot;ConnStateData&quot;!
</I>
I dont think you quite appreciate the current _location_ of the
ConnStateData logic.

The .h and .cc files are shared with ClientSocketContext and
ClientHttpRequest. Which are more or less all of BB2 between them.

Since a fairly big portion of the ConnStateData logic is also BB2 scope
stuff done in the wrong class it just gets a rename in-place during
stage #1.

So in order to get any given file ready for a rename/move. We either

a) shuffle _all_ the BB2 scoped stuff out of its currently locations
(regardless of whether its in ConnStateData or not). OR,

b) shuffle the (relatively smaller) pieces of ConnStateData out to
Server.* during step #1 and the rename/move is to change the file into
whatever the BB2 component name is.

Since the protocol agnostic parts are the *minority* of ConnStateData
logic in client_side* it is simpler in terms of file renaming to do (b)
han (a). That is where we are partially through with stage #1 now. I
don't see why you want to reverse direction completely and do the much
larger code shuffling just so you can avoid a temporary transitional state.

FYI: the very first thing I did way back was try to shuffle all three
classes out to different .cc files without rearranging the code
dependencies first. That is where I ran quickly into trouble with them
accessing each others internals and sharing static functions in the .cc

&gt;<i> 
</I>&gt;<i> [4] <A HREF="http://www.squid-cache.org/mail-archive/squid-dev/201408/0145.html">http://www.squid-cache.org/mail-archive/squid-dev/201408/0145.html</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> * It forces new code to add pure virtual methods that ConnStateData then
</I>&gt;&gt;&gt;<i> overrides and implements, reminding me of the old Store class that
</I>&gt;&gt;&gt;<i> slowly accumulated dozens of such methods because we needed to add
</I>&gt;&gt;&gt;<i> something that one of the Store kids implemented.
</I>&gt;<i> 
</I>&gt;&gt;<i> This is backwards.
</I>&gt;<i> 
</I>&gt;<i> Exactly! The ConnStateData split forces us to do things backwards.
</I>
No I meant your proposal is backwards. Moving a mountain instead of a
molehill.

&gt;<i> 
</I>&gt;&gt;<i> ConnStateData is the old class that has accumulated
</I>&gt;&gt;<i> all those extra bits.
</I>&gt;<i> 
</I>&gt;<i> Yes.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> We are trying to remove that ConnStateData scope creep.
</I>&gt;<i> 
</I>&gt;<i> The correct way to remove code misplaced in ConnStateData is to move
</I>&gt;<i> that misplaced code (rather than to split ConnStateData in two and then
</I>&gt;<i> move everything else into the second class, leaving misplaced code in
</I>&gt;<i> ConnStateData, as misplaced as it was when we started).
</I>&gt;<i> 
</I>
What remains will be BB2.

&gt;<i> 
</I>&gt;&gt;<i> virtuals in Server are ideally implemented by the end-child
</I>&gt;&gt;<i> HTTP/FTP/whatever Server class. The ones that are implemented by
</I>&gt;&gt;<i> ConnStateData itself are in a temporary stage, until they can either be
</I>&gt;&gt;<i> pushed down to the childs, or the bits they depend on using from
</I>&gt;&gt;<i> ConnStateData and also moved up to Server and the virtual-ness dropped.
</I>&gt;<i> 
</I>&gt;<i> True. The ConnStateData split forces us to add temporary complexity that
</I>&gt;<i> is completely unnecessary.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> I recommend merging it back into ConnStateData until Squid actually
</I>&gt;&gt;&gt;<i> needs it (or needs something like it). Merging it into ConnStateData
</I>&gt;&gt;&gt;<i> would preserve all code improvements we have done after it was split. If
</I>&gt;&gt;&gt;<i> somebody finds that useful, we can even keep its method definitions
</I>&gt;&gt;&gt;<i> inside Server.cc, at least for a while.
</I>&gt;<i> 
</I>&gt;&gt;<i> Doing that undermines 3 years work towards getting rid of ConnStateData.
</I>&gt;<i> 
</I>&gt;<i> I do not see how it undermines anything. To get rid of ConnStateData, we
</I>&gt;<i> need to get rid of non-Server code in ConnStateData and then rename
</I>&gt;<i> ConnStateData. Splitting ConnStateData in two does not help with that.
</I>&gt;<i> It actually hurts!
</I>
You are calling to revert the changes that separate the Server logics
from the BB2+Server logics still in ConnStateData. The result of that
will be us spending an indefinite amount of years manually policing that
the one set of methods never call the other set of methods despite
sharing class scope, member variables etc.

&gt;<i> 
</I>&gt;<i> I may be very wrong, but I sense that you might be attaching some
</I>&gt;<i> special significance to the 13 letters &quot;ConnStateData&quot;. It may be
</I>&gt;<i> spelled &quot;ConnStateData&quot; but it reads &quot;Server&quot;. We just did not want to
</I>&gt;<i> rename that class while it is still bloated with non-Server code, that's
</I>&gt;<i> all. I even said that explicitly[4]: &quot;For example, when documenting
</I>&gt;<i> something about ConnStateData inside FwdState, call it Server instead of
</I>&gt;<i> ConnStateData. This will reduce future changes as the classes get renamed&quot;.
</I>&gt;<i> 
</I>&gt;<i> I certainly regret if something I said earlier was misinterpreted as the
</I>&gt;<i> need to create a Server class that slowly accumulates code already
</I>&gt;<i> properly placed in ConnStateData. I hope the above arguments prove that
</I>&gt;<i> we must do the opposite. Pretty much everything in design and code
</I>&gt;<i> refactoring is a matter of opinion, but this choice is as close to being
</I>&gt;<i> &quot;formally provable&quot; as it gets.
</I>
You seem to have forgotten the reason why you agreed to it after (3?)
months of discussion last time around. I dont think that was ever
written down exactly so can't point at it, but I do remember you
agreeing to it early one morning for me.

I certainly regret that you think anything at all of the current logic
should be retained in ConnStateData. Even if it gets a name change.


Whichever way we go what the ::Server needs is:
1)
 a) read I/O handlers that pass off to
 b) a child-supplied Parser, and take the resulting Parser object to
construct
 c) an HttpMsg / HttpRequest and Http::Xaction. Adds that to
 d) a Pipeline set of transactions being done.

 NP: the *child* triggers BB2 to do its thing for each xaction in a
child-specific way.
 Also (1c) objects can be child-specific, which will help with FTP.

2)
 a) clientStreams? output API which
 b) Packs a message for output in a child-specific way, and calls a
 c) generic write I/O method, which sends the packed buffer blob and
shedules a child-provided Call on completion.

3) traffic accounting for (1) and (2). Possibly including use of
client_delay_pools, but child-specific assignment of what pools are applied.


Thats it. The 5 (HTTP/2 makes 6) protocols supported for client I/O do
not share anything else.

Some things to note about that list vs where we are today:

* the design of ::Server presenting generic I/O does not exist in
ConnStateData. Never has. What it has is logics for Http1::Server child
to read and write directly to the socket. That is making all the child
protocols except HTTP/1 more complicated than they should be.

* that ssl-bump, PROXY protocol, HTTP/1 vs h2 vs FTP, HTTP/1 1XX status
handling etc are all BB2 or Server-child specific activities. The child
duty in some places may be simplified down to passing an appropriate
Parser/Packer object for the ::Server to use via its Parser/Packable API
- but that is still child specific.

* all the above pieces except Pipeline [done-ish] and the (2a) API [not
yet discussed] have already been proposed, discussed and then blocked in
audit months or years ago.

* the remaining task to drop ConnStateData from existence is to
untangle/rename/move its protocol-specific logic out to the child
classes and BB2 components.
 We dont need to go near the existing Server vs ConnStateData separation
to do that shuffling. In fact ConnStateData is acting somewhat as a TODO
list of things yet to be shuffled.

Amos

</PRE>






























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006132.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
	<LI>Next message: <A HREF="006139.html">[squid-dev] Care and feeding of ConnStateData
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6134">[ date ]</a>
              <a href="thread.html#6134">[ thread ]</a>
              <a href="subject.html#6134">[ subject ]</a>
              <a href="author.html#6134">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
