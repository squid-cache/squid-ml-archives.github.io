<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C7ca9996c-afd8-7e6c-7550-4db214594704%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006135.html">
   <LINK REL="Next"  HREF="006137.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C7ca9996c-afd8-7e6c-7550-4db214594704%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Jul  8 06:44:37 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006135.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006137.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6136">[ date ]</a>
              <a href="thread.html#6136">[ thread ]</a>
              <a href="subject.html#6136">[ subject ]</a>
              <a href="author.html#6136">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 8/07/2016 11:24 a.m., Alex Rousskov wrote:
&gt;<i> On 07/07/2016 01:40 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 4/07/2016 5:39 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> +    /// Reset raw pointer - delete last one and save new one.
</I>&gt;&gt;&gt;&gt;<i> +    void reset(T *t) {
</I>&gt;&gt;&gt;&gt;<i> +        deletePointer();
</I>&gt;&gt;&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;&gt;&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> I do not think we can have a reset() method like this because the
</I>&gt;&gt;&gt;<i> standard shared_ptr::reset() has a very different semantics. Let's call
</I>&gt;&gt;&gt;<i> this absorb(). This is like a raw pointer assignment operator, but we
</I>&gt;&gt;&gt;<i> want to keep it &quot;explicit&quot; because we think this is a dangerous operation.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> What different semantics do you see in there?
</I>&gt;<i> 
</I>&gt;<i> Good question! This issue is confusing for me, so I apologize if this
</I>&gt;<i> explanation is messy:
</I>&gt;<i> 
</I>&gt;<i> Facts:
</I>&gt;<i> 
</I>&gt;<i> * resetWithoutLocking(x) does not increment the reference counter for x.
</I>&gt;<i> * resetAndLock(x) increments the reference counter for x.
</I>&gt;<i> 
</I>&gt;<i> What does the standard shared_ptr::reset(x) method do?
</I>&gt;<i> 
</I>&gt;<i> * If shared_ptr counts all references to x, internal and external, then
</I>&gt;<i> shared_ptr::reset(x) is like our resetAndLock(x) -- it increments the
</I>&gt;<i> counter.
</I>&gt;<i> 
</I>&gt;<i> * If standard shared_ptr only counts external references, then
</I>&gt;<i> shared_ptr::reset(x) is like our resetWithoutLocking(x) -- it does not
</I>&gt;<i> increment the counter.
</I>&gt;<i> 
</I>&gt;<i> This logic is totally flawed, on several levels, but this trap might
</I>&gt;<i> help illustrating why I find this issue confusing.
</I>&gt;<i> 
</I>&gt;<i> To fix our logic, we should not misrepresent what shared_ptr does
</I>&gt;<i> internally, but look at its API instead. The standard API guarantees
</I>&gt;<i> that the following sequence leads to object X destruction:
</I>&gt;<i> 
</I>&gt;<i>   {
</I>&gt;<i>       std::shared_ptr s;
</I>&gt;<i>       X *x = createX();
</I>&gt;<i>       s.reset(x);
</I>&gt;<i>       // s is destroyed upon exiting its scope
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i> Which of our two LockingPointer::reset*() methods provides the same
</I>&gt;<i> guarantee?
</I>&gt;<i> 
</I>&gt;<i> The correct answer is: None! In our case, the reset*() caller has to
</I>&gt;<i> know createX() details to call the right reset*() method, even though
</I>&gt;<i> createX() returns a &quot;raw&quot; pointer that knows nothing about our
</I>&gt;<i> LockingPointer. Similarly, the caller must know createX() details to
</I>&gt;<i> decide whether it is safe to call the LockingPointer constructor!
</I>&gt;<i> 
</I>&gt;<i> This mess happens because, in some cases, OpenSSL effectively returns an
</I>&gt;<i> already managed pointer, even though it does not know about our
</I>&gt;<i> LockingPointer. Or, in other words, it happens because we [have to]
</I>&gt;<i> share the pointer management mechanism with OpenSSL, but that mechanism
</I>&gt;<i> does not come in a form of a smart pointer -- it is hidden inside the X
</I>&gt;<i> object itself.
</I>&gt;<i> 
</I>&gt;<i> With a standard API, there is only one reset(x). In our case, we have to
</I>&gt;<i> have two. Thus, none of them can be called reset()! We have to force the
</I>&gt;<i> caller to make a choice, depending on the context (i.e., the source of x).
</I>&gt;<i> 
</I>&gt;<i> BTW, your decision to name both methods reset*() is superior to my
</I>&gt;<i> earlier suggestion to name them absorb() and reset(). Let's leave your
</I>&gt;<i> reset*() names intact.
</I>&gt;<i> 
</I>
:<i>-)
</I>
&gt;<i> We may also want to hide the constructor behind two static methods for
</I>&gt;<i> similar reasons -- whether X is properly destructed in the following
</I>&gt;<i> example depends on createX() details, and it really should not:
</I>&gt;<i> 
</I>&gt;<i>   {
</I>&gt;<i>       LockingPointer lp(createX());
</I>&gt;<i>   }
</I>&gt;<i> 
</I>
In the context of how we agreed to shrink the library specific #if
wrapped parts down to specific action nuggets as much as possible. eg
how the session resume functons are defined:

I have been thinking the abstract API should use Pointer instead of Ptr
so the minimal #if part can do that library-specific initialization of
the Pointer and avoid constructing these things in generic code.
 If that works widely enough we can possibly get rid of the raw-ptr
constructor entirely for non-OpenSSL.

NP: trunk rev.14734 is a step along that path which demonstrates how it
could make things a fair bit simpler. With a caveat that I'm not sure
its going to be universally applicable, or just a best-effort idea.

Though slightly counter to that I'm also considering using that
constructor as the preferred way to initialize OpenSSL LockingPointer
objects so we can use the assignment operators (both copy and move) in
preference over the custom reset*() methods as a way to ease the
shared_ptr conversion as much as possible. You can see at least two
cases of that with X = std::move(Y) in these patches.

May be wishful thinking, but if all that works out we can have custom
LockingPointer exclusively for OpenSSL, and shared_ptr for GnuTLS (and
non-TLS builds). With the library agnostic code using only the
overlapping API between the two types. Which should be mostly; get(),
bool operators, and assignments.


&gt;<i> 
</I>&gt;&gt;<i> +    void resetWithoutLocking(T *t) {
</I>&gt;&gt;<i> +        unlock();
</I>&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;<i>      }
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i>      void resetAndLock(T *t) {
</I>&gt;&gt;<i> +        if (t != get()) {
</I>&gt;&gt;<i> +            resetWithoutLocking(t);
</I>&gt;&gt;<i> +            lock(t);
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    }
</I>&gt;<i> 
</I>&gt;<i> We should probably add self-reset protection to both cases or to none.
</I>&gt;<i> 
</I>
Strange as it seems doing that would violate the non-locking guarantee
on the first one.

Both reset*() methods (and assignments) guarantee that the UnLocker is
called on any previously stored value. If that means the raw-pointer is
about to go invalid then its a caller bug for using that method of the
API. Because resetWithoutLocking() fully delegates lock control to the
caller this is not something we can make assumptions about in the
resetWithoutLocking() variant.

Doing a self-check to retain raw-pointer validity would behave the same
as if it had locked the pointer given. So even if we did the check we
would still have to leave the pointer as invalid at the end of it all.
Nasty situation, but thats part of what makes it a dangerous method in
the first place.


&gt;<i> 
</I>&gt;&gt;<i> +    void unlock() {
</I>&gt;&gt;<i> +        if (raw)
</I>&gt;&gt;<i> +            UnLocker(raw);
</I>&gt;&gt;<i> +        raw = nullptr;
</I>&gt;&gt;<i> +    }
</I>&gt;<i> 
</I>&gt;<i> Let's move assignment inside the if-statement to save a few CPU cycles.
</I>&gt;<i> 
</I>
Okay.

&gt;<i> 
</I>&gt;&gt;<i> +    T *raw; ///&lt; pointer to T object or nullptr
</I>&gt;<i> 
</I>&gt;<i> That description adds virtually no information. How about something like
</I>&gt;<i> this: &quot;Normally, no other code will have this raw pointer. However,
</I>&gt;<i> OpenSSL may keep raw pointers and manage their reference counts. When
</I>&gt;<i> OpenSSL shares a pointer with us, the caller must not use LockingPointer
</I>&gt;<i> constructor and must call resetAndLock().&quot;
</I>&gt;<i> 
</I>
Gone with a slightly different tack there. Not so adverse to
constructor, but emphasising the issue and that care needs to be taken.

&quot;
Normally, no other code will have this raw pointer.

However, OpenSSL does some strange and not always consistent things.
OpenSSL library may keep its own internal raw pointers and manage their
reference counts independently, or it may not. This varies between API
functions, though it is usually documented.

This means the caller code needs to be carefuly written to use the
correct reset method and avoid the raw-pointer constructor unless
OpenSSL function producing the pointer is clearly documented as
incrementing a lock for it.
&quot;

&gt;<i> 
</I>&gt;&gt;<i> +    explicit LockingPointer(T *t = nullptr): raw(t) {}
</I>&gt;<i> 
</I>&gt;<i> I recommend calling resetWithoutLocking() here even though it could
</I>&gt;<i> waste a few CPU cycles. This is the only dangerous part remaining in the
</I>&gt;<i> LockingPointer interface, and it may help being explicit here.
</I>&gt;<i> 
</I>
Okay. And added a comment about why is de-optimized.

&gt;<i> 
</I>&gt;&gt;<i>  typedef void* SessionPtr;
</I>&gt;&gt;<i> +CtoCpp1(xfree, SessionPtr);
</I>&gt;<i> 
</I>&gt;<i> xfree() is already a C++ function and does not need wrapping, right?
</I>&gt;<i> 
</I>
Hmm. Yes, I'll give it a try.

&gt;<i> 
</I>&gt;&gt;&gt;<i> Please also add a public clear(void) method that reset(t) will call
</I>&gt;&gt;&gt;<i> instead of lock() when t is nil. Alternatively, add a reset(void) method
</I>&gt;&gt;&gt;<i> with the same semantics as clear(void) -- that is what std::shared_ptr does.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I do not see any clear() method in shared_ptr documentation.
</I>&gt;&gt;<i> &lt;<A HREF="http://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&amp;search=clear%28%29">http://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&amp;search=clear%28%29</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> Yes, I know. As I said, they provide a reset(void) instead. If you think
</I>&gt;<i> we should add reset(void) instead of clear(), let's add that, but please
</I>&gt;<i> do add one instead of [ab]using reset*(nullptr).
</I>&gt;<i> 
</I>
Okay, going with reset(void) then to ease the shared_ptr transition as
much as possible.

&gt;<i> 
</I>&gt;&gt;<i> + * The lock() method increments Object's reference counter.
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * The unlock() method decrements Object's reference counter and destroys
</I>&gt;&gt;<i> + * the object when the counter reaches zero.
</I>&gt;<i> 
</I>&gt;<i> Please remove or move/merge these descriptions with their corresponding
</I>&gt;<i> private methods descriptions. No need to place this private info in the
</I>&gt;<i> class description. Sorry I did not mention that earlier.
</I>&gt;<i> 
</I>
Done. Though I've changed the second one to be:
&quot;
Become a nil pointer. Decrements any pointed-to Object's reference
counter using UnLocker which ideally destroys the object when the
counter reaches zero.
&quot;

Since UnLocker is externally provided there is no guarantee that the
destruction takes place. Decrement and Destruct is only an ideal design
for UnLocker implementation. eg. the non-TLS builds UnLocker will do
nothing and T will just be a void or int placeholder.


&gt;<i> 
</I>&gt;&gt;&gt;<i> Please note that the originally proposed commit message no longer
</I>&gt;&gt;&gt;<i> applies to your changes so we need a new one.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;
</I>&gt;&gt;<i> This replaces TidyPointer with std::unique_ptr and re-implements the
</I>&gt;&gt;<i> part of TidyPointer which LockingPointer was using. Removing the
</I>&gt;&gt;<i> inheritence in the process and updating methods names for clarity.
</I>&gt;<i> 
</I>&gt;<i> No serious objections, but I suggest:
</I>&gt;<i> 
</I>&gt;<i> -----------
</I>&gt;<i> Replaced TidyPointer with std::unique_ptr.
</I>&gt;<i> 
</I>&gt;<i> LockingPointer is now a stand-alone class that is understood (and
</I>&gt;<i> documented) as a typical shared pointer with OpenSSL-friendly object
</I>&gt;<i> importing methods. Replaced its TidyPointer::reset() abuse with an
</I>&gt;<i> explicit resetWithoutLocking() method after reviewing that all such
</I>&gt;<i> calls needed no locking indeed.
</I>&gt;<i> -----------
</I>&gt;<i> 
</I>
Sure.

&gt;<i> 
</I>&gt;&gt;<i> The LockingPointer still has some of the issues which led us down the
</I>&gt;&gt;<i> path to getting here. I've chosen to submit for review at this point to
</I>&gt;&gt;<i> ensure we still have a fully working Squid before going further down
</I>&gt;&gt;<i> this trail.
</I>&gt;<i> 
</I>&gt;<i> I do not recall any remaining in-scope LockingPointer issues except that
</I>&gt;<i> the constructor does not force the caller to pick the right importing
</I>&gt;<i> route. What issues did I forget about?
</I>&gt;<i> 
</I>
The absence of locks for GnuTLS and the need to use LockingPointer
without actual locking is still a bit painful.

The later work to actually use std::shared_ptr instead of LockingPointer
should get rid of that though.

&gt;<i> 
</I>&gt;<i> All of the above changes do not require another review round IMO.
</I>&gt;<i> 
</I>
Okay. Build testing the final version underway and will merged to trunk
when thats done.

Amos


</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006135.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006137.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6136">[ date ]</a>
              <a href="thread.html#6136">[ thread ]</a>
              <a href="subject.html#6136">[ subject ]</a>
              <a href="author.html#6136">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
