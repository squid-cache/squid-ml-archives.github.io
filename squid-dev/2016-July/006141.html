<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C578034D6.4060304%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006140.html">
   <LINK REL="Next"  HREF="006144.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C578034D6.4060304%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">rousskov at measurement-factory.com
       </A><BR>
    <I>Fri Jul  8 23:18:46 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006140.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006144.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6141">[ date ]</a>
              <a href="thread.html#6141">[ thread ]</a>
              <a href="subject.html#6141">[ subject ]</a>
              <a href="author.html#6141">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/08/2016 12:44 AM, Amos Jeffries wrote:
&gt;<i> On 8/07/2016 11:24 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> We may also want to hide the constructor behind two static methods for
</I>&gt;&gt;<i> similar reasons -- whether X is properly destructed in the following
</I>&gt;&gt;<i> example depends on createX() details, and it really should not:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   {
</I>&gt;&gt;<i>       LockingPointer lp(createX());
</I>&gt;&gt;<i>   }
</I>&gt;&gt;<i>
</I>
&gt;<i> In the context of how we agreed to shrink the library specific #if
</I>&gt;<i> wrapped parts down to specific action nuggets as much as possible. eg
</I>&gt;<i> how the session resume functons are defined:
</I>&gt;<i> 
</I>&gt;<i> I have been thinking the abstract API should use Pointer instead of Ptr
</I>&gt;<i> so the minimal #if part can do that library-specific initialization of
</I>&gt;<i> the Pointer and avoid constructing these things in generic code.
</I>
Your conclusion may be correct, but for different and much simpler
reasons: If parts of code need smart pointers to object X, then all code
must use smart pointers to object X. It is virtually impossible to write
sane and safe code that mixes dumb and smart pointers to the same
object. This is a universal principle.


&gt;&gt;&gt;<i> +    void resetWithoutLocking(T *t) {
</I>&gt;&gt;&gt;<i> +        unlock();
</I>&gt;&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;&gt;<i>      }
</I>&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;<i>      void resetAndLock(T *t) {
</I>&gt;&gt;&gt;<i> +        if (t != get()) {
</I>&gt;&gt;&gt;<i> +            resetWithoutLocking(t);
</I>&gt;&gt;&gt;<i> +            lock(t);
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +    }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We should probably add self-reset protection to both cases or to none.
</I>

&gt;<i> Strange as it seems doing that would violate the non-locking guarantee
</I>&gt;<i> on the first one.
</I>
How does the following code violate the non-locking guarantee?

    void resetWithoutLocking(T *t) {
        if (t != get() {
            unlock();
            raw = t;
        }
    }


&gt;<i> Both reset*() methods (and assignments) guarantee that the UnLocker is
</I>&gt;<i> called on any previously stored value.
</I>
Self-assignment and self-reset is a gray area. Each
assignment/reset-handling class can define what should happen under
those circumstances. The possible sane definitions are:

  1. Do nothing (side effects lead to leaks/crashes in non-benign cases)
  2. assertion/exception (explicit error in all cases)
  3. Do the usual (side effects lead to leaks/crashes in most cases)

Which definition to pick is our choice, but we should be _consistent_ in
that choice. I recommend #1, but it is a weak recommendation.

In the latest patch I have seen, resetAndLock() was using #1 but
resetWithoutLocking() was using #3.



&gt;<i> If that means the raw-pointer is
</I>&gt;<i> about to go invalid then its a caller bug for using that method of the
</I>&gt;<i> API. Because resetWithoutLocking() fully delegates lock control to the
</I>&gt;<i> caller this is not something we can make assumptions about in the
</I>&gt;<i> resetWithoutLocking() variant.
</I>
Self-assignment and self-reset is always a caller problem and is always
a gray area -- logical reasoning cannot arrive at a single &quot;correct&quot; or
&quot;best&quot; solution here.

A caller has delegated control of the already managed object locks to
us. Now the caller wants us to import the same object that was allegedly
pre-locked for our import. It is our decision whether to unlock/free the
object (#3), assert/throw (#2), or do nothing (#1).

I doubt we should pick #3, but that is not what I am complaining about
right now. I am complaining about inconsistency. If you are sure that
crashing the program in most cases is the best solution in the
LockingPointer context, then you should use that solution for all
reset*() and assignment methods.


&gt;<i> Doing a self-check to retain raw-pointer validity would behave the same
</I>&gt;<i> as if it had locked the pointer given.
</I>
You cannot know what self-check side effects will be because they depend
on the caller. Thus, any assertion that &quot;do nothing&quot; would behave the
same as &quot;do something&quot; is wrong.

For example, the following benign code triggers self-reset but has no
side effects at all if self-reset is handled using the &quot;do nothing&quot;
approach:

    p.reset(p-&gt;get()); // p = p


&gt;<i> the non-TLS builds UnLocker will do
</I>&gt;<i> nothing and T will just be a void or int placeholder.
</I>
That does not sound quite right to me: If we want TLS-incapable code to
use LockingPointer for TLS stuff that cannot exist in such code, then
UnLocker and lock() ought to assert! In other words, only nil
LockingPointers should be allowed in that special case.


&gt;&gt;<i> I do not recall any remaining in-scope LockingPointer issues except that
</I>&gt;&gt;<i> the constructor does not force the caller to pick the right importing
</I>&gt;&gt;<i> route. What issues did I forget about?
</I>
&gt;<i> The absence of locks for GnuTLS 
</I>
GnuTLS support is out of this change scope, I hope.


&gt;<i> and the need to use LockingPointer without actual locking 
</I>
Inside GnuTLS builds, you mean? Or is that a separate problem from the
insufficient GnuTLS support in Squid? If it is the latter, please detail it.


&gt;<i> Okay. Build testing the final version underway and will merged to trunk
</I>&gt;<i> when thats done.
</I>
Please resolve self-assignment/reset consistency, before or after that
merge.


Thank you,

Alex.

</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006140.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006144.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6141">[ date ]</a>
              <a href="thread.html#6141">[ thread ]</a>
              <a href="subject.html#6141">[ subject ]</a>
              <a href="author.html#6141">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
