<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3Ca0f8f30f-9565-5962-4da6-c2e1c159c5c7%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006141.html">
   <LINK REL="Next"  HREF="006149.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3Ca0f8f30f-9565-5962-4da6-c2e1c159c5c7%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jul  9 13:10:09 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006141.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006149.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6144">[ date ]</a>
              <a href="thread.html#6144">[ thread ]</a>
              <a href="subject.html#6144">[ subject ]</a>
              <a href="author.html#6144">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 9/07/2016 11:18 a.m., Alex Rousskov wrote:
&gt;<i> On 07/08/2016 12:44 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 8/07/2016 11:24 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +    void resetWithoutLocking(T *t) {
</I>&gt;&gt;&gt;&gt;<i> +        unlock();
</I>&gt;&gt;&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;&gt;&gt;<i>      }
</I>&gt;&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;&gt;<i>      void resetAndLock(T *t) {
</I>&gt;&gt;&gt;&gt;<i> +        if (t != get()) {
</I>&gt;&gt;&gt;&gt;<i> +            resetWithoutLocking(t);
</I>&gt;&gt;&gt;&gt;<i> +            lock(t);
</I>&gt;&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;&gt;<i> +    }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> We should probably add self-reset protection to both cases or to none.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Strange as it seems doing that would violate the non-locking guarantee
</I>&gt;&gt;<i> on the first one.
</I>&gt;<i> 
</I>&gt;<i> How does the following code violate the non-locking guarantee?
</I>&gt;<i> 
</I>&gt;<i>     void resetWithoutLocking(T *t) {
</I>&gt;<i>         if (t != get() {
</I>&gt;<i>             unlock();
</I>&gt;<i>             raw = t;
</I>&gt;<i>         }
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Both reset*() methods (and assignments) guarantee that the UnLocker is
</I>&gt;&gt;<i> called on any previously stored value.
</I>&gt;<i> 
</I>&gt;<i> Self-assignment and self-reset is a gray area. Each
</I>&gt;<i> assignment/reset-handling class can define what should happen under
</I>&gt;<i> those circumstances. The possible sane definitions are:
</I>&gt;<i> 
</I>&gt;<i>   1. Do nothing (side effects lead to leaks/crashes in non-benign cases)
</I>&gt;<i>   2. assertion/exception (explicit error in all cases)
</I>&gt;<i>   3. Do the usual (side effects lead to leaks/crashes in most cases)
</I>&gt;<i> 
</I>&gt;<i> Which definition to pick is our choice, but we should be _consistent_ in
</I>&gt;<i> that choice. I recommend #1, but it is a weak recommendation.
</I>&gt;<i> 
</I>&gt;<i> In the latest patch I have seen, resetAndLock() was using #1 but
</I>&gt;<i> resetWithoutLocking() was using #3.
</I>&gt;<i> 
</I>
resetAndLock() is doing #1 and there are no side effects. Because the
new lock() is performed by us, not the caller. So we can confidently do
nothing with no side effects.

resetWithoutLocking() cannot do #1 without adding the listed side
effects for all 'benign' cases.

The words &quot;most cases&quot; is incorrect on #3, because most cases will be
caller acting correctly and doing its +1 on the locks before our
unlock() is used. Only buggy callers will lead to the listed side effects.

I argue that these are bugs in the callers. Bugs we need to see (via
those side effects) and fix.

We cannot assert in the self-reset case because that is a legitimate
input from good callers. We can trust them to have locked. There is
nothing we can reliably use as assert() parameter.


&gt;<i> 
</I>&gt;&gt;<i> If that means the raw-pointer is
</I>&gt;&gt;<i> about to go invalid then its a caller bug for using that method of the
</I>&gt;&gt;<i> API. Because resetWithoutLocking() fully delegates lock control to the
</I>&gt;&gt;<i> caller this is not something we can make assumptions about in the
</I>&gt;&gt;<i> resetWithoutLocking() variant.
</I>&gt;<i> 
</I>&gt;<i> Self-assignment and self-reset is always a caller problem and is always
</I>&gt;<i> a gray area -- logical reasoning cannot arrive at a single &quot;correct&quot; or
</I>&gt;<i> &quot;best&quot; solution here.
</I>
In the generic case you might be right.

However, we have a situation here where OpenSSL functions either lock or
they don't lock. That black-and-white limitation works in our favour
here so we can calculate with code being either good or buggy and reason
from that.

&gt;<i> 
</I>&gt;<i> A caller has delegated control of the already managed object locks to
</I>&gt;<i> us.
</I>&gt;<i> Now the caller wants us to import the same object that was allegedly
</I>&gt;<i> pre-locked for our import. It is our decision whether to unlock/free the
</I>&gt;<i> object (#3), assert/throw (#2), or do nothing (#1).
</I>
This is a new caller allegedly with a pointer it has added a second lock
to. It doesn't matter that the value is self because that second lock
exists. resetWithoutLocking() is just discarding that old lock, and
taking responsibility for the new one.


A good caller code is one that has actually done the locking it should
have and delagating us the unlock() task. There will be no problem from
using UnLocker() on the previously stored value. This is the common case
for self-assignment/reset in good code.

A buggy caller code is one that is not adding that lock and still using
resetWithoutLocking(), so use of UnLocker will possibly lead to
deallocation and invalid pointer value stored.

This tells me that skipping the unlock() on self-assignments for
resetWithoutLocking() will hide bugs in bad code and add leaks in good
code. Which are not desirable results.

Yes the bugs are likely to be hard to track down. But they will be
impossible to trackdown if we actively add code to hide them. We will
instead just get bug reports about the leaks and waste time tracking
those down in what is actually good code.

&gt;<i> 
</I>&gt;<i> I doubt we should pick #3, but that is not what I am complaining about
</I>&gt;<i> right now. I am complaining about inconsistency. If you are sure that
</I>&gt;<i> crashing the program in most cases is the best solution in the
</I>&gt;<i> LockingPointer context, then you should use that solution for all
</I>&gt;<i> reset*() and assignment methods.
</I>
Crashing is *not* okay in the resetAndLock() pathway self-assignment.
That code is working correctly.

The inconsistency is forced by OpenSSL behaviour.

&gt;<i> 
</I>&gt;&gt;<i> Doing a self-check to retain raw-pointer validity would behave the same
</I>&gt;&gt;<i> as if it had locked the pointer given.
</I>&gt;<i> 
</I>&gt;<i> You cannot know what self-check side effects will be because they depend
</I>&gt;<i> on the caller. Thus, any assertion that &quot;do nothing&quot; would behave the
</I>&gt;<i> same as &quot;do something&quot; is wrong.
</I>&gt;<i> 
</I>
We can and do. There are exactly two cases. One where the caller adds a
lock, and one where it doesn't.

Which callers are good and which are broken is something we can figure
out with a code audit of callers. Which Christos did earlier before and
informed us the uses of reset() vs resetAndLock() were all correct.


&gt;<i> For example, the following benign code triggers self-reset but has no
</I>&gt;<i> side effects at all if self-reset is handled using the &quot;do nothing&quot;
</I>&gt;<i> approach:
</I>&gt;<i> 
</I>&gt;<i>     p.reset(p-&gt;get()); // p = p
</I>&gt;<i> 
</I>
I assume you meant to write resetWithoutLocking() there.

That code pattern is buggy. If you find any such uses please point them
out to be fixed.

Correct 'p = p' code is:

for 3.5:
  p.reset(p.release());

for trunk:
  p = std::move(p);


&gt;<i> 
</I>&gt;&gt;<i> the non-TLS builds UnLocker will do
</I>&gt;&gt;<i> nothing and T will just be a void or int placeholder.
</I>&gt;<i> 
</I>&gt;<i> That does not sound quite right to me: If we want TLS-incapable code to
</I>&gt;<i> use LockingPointer for TLS stuff that cannot exist in such code, then
</I>&gt;<i> UnLocker and lock() ought to assert! In other words, only nil
</I>&gt;<i> LockingPointers should be allowed in that special case.
</I>&gt;<i> 
</I>
The lock() method asserts if it is ever used on those builds. So its
caught on assignment, not destruct.


&gt;<i> 
</I>&gt;&gt;&gt;<i> I do not recall any remaining in-scope LockingPointer issues except that
</I>&gt;&gt;&gt;<i> the constructor does not force the caller to pick the right importing
</I>&gt;&gt;&gt;<i> route. What issues did I forget about?
</I>&gt;<i> 
</I>&gt;&gt;<i> The absence of locks for GnuTLS 
</I>&gt;<i> 
</I>&gt;<i> GnuTLS support is out of this change scope, I hope.
</I>&gt;<i> 
</I>
Since some of its types used TidyPointer and LockingPointer that code is
as much under consideration as the OpenSSL build, and in the same ways.

Each change in the patch was and continues to be tested for x3 builds;
* layer-00-default = GnuTLS
* layer-01-minimal = none
* layer-02-maximus = OpenSSL

&gt;<i> 
</I>&gt;&gt;<i> and the need to use LockingPointer without actual locking 
</I>&gt;<i> 
</I>&gt;<i> Inside GnuTLS builds, you mean? Or is that a separate problem from the
</I>&gt;<i> insufficient GnuTLS support in Squid? If it is the latter, please detail it.
</I>&gt;<i> 
</I>
Yes I mean for the GnuTLS builds in their current state.

&gt;<i> 
</I>&gt;&gt;<i> Okay. Build testing the final version underway and will merged to trunk
</I>&gt;&gt;<i> when thats done.
</I>&gt;<i> 
</I>&gt;<i> Please resolve self-assignment/reset consistency, before or after that
</I>&gt;<i> merge.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Thank you,
</I>&gt;<i> 
</I>&gt;<i> Alex.
</I>&gt;<i> 
</I>
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006141.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006149.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6144">[ date ]</a>
              <a href="thread.html#6144">[ thread ]</a>
              <a href="subject.html#6144">[ subject ]</a>
              <a href="author.html#6144">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
