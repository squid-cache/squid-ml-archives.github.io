<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH Bug 4534 and N-bit fixes for CacheDigest
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%20Bug%204534%20and%20N-bit%20fixes%20for%20CacheDigest&In-Reply-To=%3C7c7740db-b768-1870-ea28-ccfdb51ffde3%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006138.html">
   <LINK REL="Next"  HREF="006151.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH Bug 4534 and N-bit fixes for CacheDigest</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%20Bug%204534%20and%20N-bit%20fixes%20for%20CacheDigest&In-Reply-To=%3C7c7740db-b768-1870-ea28-ccfdb51ffde3%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH Bug 4534 and N-bit fixes for CacheDigest">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jul  9 13:37:02 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006138.html">[squid-dev] [PATCH] avoid flooding cache.log with &quot;uninitialized value&quot; messages from ext_wbinfo_group_acl helper script
</A></li>
        <LI>Next message: <A HREF="006151.html">[squid-dev] [PATCH Bug 4534 and N-bit fixes for CacheDigest
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6145">[ date ]</a>
              <a href="thread.html#6145">[ thread ]</a>
              <a href="subject.html#6145">[ subject ]</a>
              <a href="author.html#6145">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch converts the CacheDigest members and method parameters to use
explicitly sized data types more appropriate for what details they hold.

* 64-bit Digest capacity (entry count)
* 32-bit Mask Size (byte count)
*  8-bit Bit count per entry

Due to various store_digest.cc code still relying on masks not exceeding
2^31-1 worth of memory space we have to still assert that bitCount
calculation does not exceed that value.

Amos

-------------- next part --------------
=== modified file 'src/CacheDigest.cc'
--- src/CacheDigest.cc	2016-01-01 00:12:18 +0000
+++ src/CacheDigest.cc	2016-07-09 08:12:56 +0000
@@ -18,89 +18,89 @@
 
 #include &quot;CacheDigest.h&quot;
 #include &quot;util.h&quot;
 
 /* local types */
 
 typedef struct {
     int bit_count;      /* total number of bits */
     int bit_on_count;       /* #bits turned on */
     int bseq_len_sum;       /* sum of all bit seq length */
     int bseq_count;     /* number of bit seqs */
 } CacheDigestStats;
 
 /* local functions */
 static void cacheDigestHashKey(const CacheDigest * cd, const cache_key * key);
 
 /* static array used by cacheDigestHashKey for optimization purposes */
 static uint32_t hashed_keys[4];
 
 void
-CacheDigest::init(int newCapacity)
+CacheDigest::init(uint64_t newCapacity)
 {
     const auto newMaskSz = CacheDigest::CalcMaskSize(newCapacity, bits_per_entry);
     assert(newCapacity &gt; 0 &amp;&amp; bits_per_entry &gt; 0);
-    assert(newMaskSz &gt; 0);
+    assert(newMaskSz != 0);
     capacity = newCapacity;
     mask_size = newMaskSz;
     mask = static_cast&lt;char *&gt;(xcalloc(mask_size,1));
     debugs(70, 2, &quot;capacity: &quot; &lt;&lt; capacity &lt;&lt; &quot; entries, bpe: &quot; &lt;&lt; bits_per_entry &lt;&lt; &quot;; size: &quot;
            &lt;&lt; mask_size &lt;&lt; &quot; bytes&quot;);
 }
 
-CacheDigest::CacheDigest(int aCapacity, int bpe) :
+CacheDigest::CacheDigest(uint64_t aCapacity, uint8_t bpe) :
     mask(nullptr),
     mask_size(0),
     capacity(0),
     bits_per_entry(bpe),
     count(0),
     del_count(0)
 {
     assert(SQUID_MD5_DIGEST_LENGTH == 16);  /* our hash functions rely on 16 byte keys */
     updateCapacity(aCapacity);
 }
 
 CacheDigest::~CacheDigest()
 {
     xfree(mask);
 }
 
 CacheDigest *
 CacheDigest::clone() const
 {
     CacheDigest *cl = new CacheDigest(capacity, bits_per_entry);
     cl-&gt;count = count;
     cl-&gt;del_count = del_count;
     assert(mask_size == cl-&gt;mask_size);
     memcpy(cl-&gt;mask, mask, mask_size);
     return cl;
 }
 
 void
 CacheDigest::clear()
 {
     count = del_count = 0;
     memset(mask, 0, mask_size);
 }
 
 void
-CacheDigest::updateCapacity(int newCapacity)
+CacheDigest::updateCapacity(uint64_t newCapacity)
 {
     safe_free(mask);
     init(newCapacity); // will re-init mask and mask_size
 }
 
 bool
 CacheDigest::contains(const cache_key * key) const
 {
     assert(key);
     /* hash */
     cacheDigestHashKey(this, key);
     /* test corresponding bits */
     return
         CBIT_TEST(mask, hashed_keys[0]) &amp;&amp;
         CBIT_TEST(mask, hashed_keys[1]) &amp;&amp;
         CBIT_TEST(mask, hashed_keys[2]) &amp;&amp;
         CBIT_TEST(mask, hashed_keys[3]);
 }
 
 void
@@ -244,64 +244,65 @@
                       stats-&gt;falseHits, xpercent(stats-&gt;falseHits, tot_count),
                       stats-&gt;falseMisses, xpercent(stats-&gt;falseMisses, tot_count),
                       false_count, xpercent(false_count, tot_count));
     storeAppendPrintf(sentry, &quot;all\t %d\t %.2f\t %d\t %.2f\t %d\t %.2f\n&quot;,
                       hit_count, xpercent(hit_count, tot_count),
                       miss_count, xpercent(miss_count, tot_count),
                       tot_count, xpercent(tot_count, tot_count));
     storeAppendPrintf(sentry, &quot;\tclose_hits: %d ( %d%%) /* cd said hit, doc was in the peer cache, but we got a miss */\n&quot;,
                       stats-&gt;closeHits, xpercentInt(stats-&gt;closeHits, stats-&gt;falseHits));
 }
 
 void
 cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
 {
     CacheDigestStats stats;
     assert(cd &amp;&amp; e);
     cacheDigestStats(cd, &amp;stats);
     storeAppendPrintf(e, &quot;%s digest: size: %d bytes\n&quot;,
                       label ? label : &quot;&quot;, stats.bit_count / 8
                      );
-    storeAppendPrintf(e, &quot;\t entries: count: %d capacity: %d util: %d%%\n&quot;,
+    storeAppendPrintf(e, &quot;\t entries: count: %d capacity: %&quot; PRIu64 &quot; util: %d%%\n&quot;,
                       cd-&gt;count,
                       cd-&gt;capacity,
                       xpercentInt(cd-&gt;count, cd-&gt;capacity)
                      );
     storeAppendPrintf(e, &quot;\t deletion attempts: %d\n&quot;,
                       cd-&gt;del_count
                      );
     storeAppendPrintf(e, &quot;\t bits: per entry: %d on: %d capacity: %d util: %d%%\n&quot;,
                       cd-&gt;bits_per_entry,
                       stats.bit_on_count, stats.bit_count,
                       xpercentInt(stats.bit_on_count, stats.bit_count)
                      );
     storeAppendPrintf(e, &quot;\t bit-seq: count: %d avg.len: %.2f\n&quot;,
                       stats.bseq_count,
                       xdiv(stats.bseq_len_sum, stats.bseq_count)
                      );
 }
 
-size_t
-CacheDigest::CalcMaskSize(int cap, int bpe)
+uint32_t
+CacheDigest::CalcMaskSize(uint64_t cap, uint8_t bpe)
 {
-    // XXX: might 32-bit overflow during multiply
-    return (size_t) (cap * bpe + 7) / 8;
+    uint64_t bitCount = (cap * bpe) + 7;
+    assert(bitCount &lt; INT_MAX); // dont 31-bit overflow later
+    return static_cast&lt;uint32_t&gt;(bitCount / 8);
 }
 
 static void
 cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 {
-    const unsigned int bit_count = cd-&gt;mask_size * 8;
+    const uint32_t bit_count = cd-&gt;mask_size * 8;
     unsigned int tmp_keys[4];
     /* we must memcpy to ensure alignment */
     memcpy(tmp_keys, key, sizeof(tmp_keys));
     hashed_keys[0] = htonl(tmp_keys[0]) % bit_count;
     hashed_keys[1] = htonl(tmp_keys[1]) % bit_count;
     hashed_keys[2] = htonl(tmp_keys[2]) % bit_count;
     hashed_keys[3] = htonl(tmp_keys[3]) % bit_count;
     debugs(70, 9, &quot;cacheDigestHashKey: &quot; &lt;&lt; storeKeyText(key) &lt;&lt; &quot; -(&quot; &lt;&lt;
            bit_count &lt;&lt; &quot;)-&gt; &quot; &lt;&lt; hashed_keys[0] &lt;&lt; &quot; &quot; &lt;&lt; hashed_keys[1] &lt;&lt;
            &quot; &quot; &lt;&lt; hashed_keys[2] &lt;&lt; &quot; &quot; &lt;&lt; hashed_keys[3]);
 }
 
 #endif
 

=== modified file 'src/CacheDigest.h'
--- src/CacheDigest.h	2016-01-01 00:12:18 +0000
+++ src/CacheDigest.h	2016-07-09 05:33:28 +0000
@@ -4,65 +4,65 @@
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 70    Cache Digest */
 
 #ifndef SQUID_CACHEDIGEST_H_
 #define SQUID_CACHEDIGEST_H_
 
 #include &quot;mem/forward.h&quot;
 #include &quot;store_key_md5.h&quot;
 
 class CacheDigestGuessStats;
 class StoreEntry;
 
 class CacheDigest
 {
     MEMPROXY_CLASS(CacheDigest);
 public:
-    CacheDigest(int capacity, int bpe);
+    CacheDigest(uint64_t capacity, uint8_t bpe);
     ~CacheDigest();
 
     // NP: only used by broken unit-test
     /// produce a new identical copy of the digest object
     CacheDigest *clone() const;
 
     /// reset the digest mask and counters
     void clear();
 
     /// changes mask size to fit newCapacity, resets bits to 0
-    void updateCapacity(int newCapacity);
+    void updateCapacity(uint64_t newCapacity);
 
     void add(const cache_key * key);
     void remove(const cache_key * key);
 
     /// \returns true if the key belongs to the digest
     bool contains(const cache_key * key) const;
 
     /// percentage of mask bits which are used
     double usedMaskPercent() const;
 
     /// calculate the size of mask required to digest up to
     /// a specified capacity and bitsize.
-    static size_t CalcMaskSize(int cap, int bpe);
+    static uint32_t CalcMaskSize(uint64_t cap, uint8_t bpe);
 
 private:
-    void init(int newCapacity);
+    void init(uint64_t newCapacity);
 
 public:
     /* public, read-only */
     char *mask;         /* bit mask */
-    int mask_size;      /* mask size in bytes */
-    int capacity;       /* expected maximum for .count, not a hard limit */
-    int bits_per_entry;     /* number of bits allocated for each entry from capacity */
+    uint32_t mask_size; /* mask size in bytes */
+    uint64_t capacity;       /* expected maximum for .count, not a hard limit */
+    int8_t bits_per_entry;     /* number of bits allocated for each entry from capacity */
     int count;          /* number of digested entries */
     int del_count;      /* number of deletions performed so far */
 };
 
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
 void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
 
 #endif /* SQUID_CACHEDIGEST_H_ */
 

=== modified file 'src/PeerDigest.h'
--- src/PeerDigest.h	2016-01-01 00:12:18 +0000
+++ src/PeerDigest.h	2016-07-09 04:03:58 +0000
@@ -39,41 +39,41 @@
 
 class HttpRequest;
 class PeerDigest;
 class store_client;
 
 class DigestFetchState
 {
     CBDATA_CLASS(DigestFetchState);
 
 public:
     DigestFetchState(PeerDigest *,HttpRequest *);
     ~DigestFetchState();
 
     PeerDigest *pd;
     StoreEntry *entry;
     StoreEntry *old_entry;
     store_client *sc;
     store_client *old_sc;
     HttpRequest *request;
     int offset;
-    int mask_offset;
+    uint32_t mask_offset;
     time_t start_time;
     time_t resp_time;
     time_t expires;
 
     struct {
         int msg;
         int bytes;
     } sent, recv;
 
     char buf[SM_PAGE_SIZE];
     ssize_t bufofs;
     digest_read_state_t state;
 };
 
 class PeerDigest
 {
     CBDATA_CLASS(PeerDigest);
 
 public:
     CachePeer *peer;          /**&lt; pointer back to peer structure, argh */

=== modified file 'src/peer_digest.cc'
--- src/peer_digest.cc	2016-03-11 18:00:51 +0000
+++ src/peer_digest.cc	2016-07-09 04:07:04 +0000
@@ -729,41 +729,41 @@
     debugs(72, 6, step_name &lt;&lt; &quot;: peer &quot; &lt;&lt; host &lt;&lt; &quot;, offset: &quot; &lt;&lt;
            fetch-&gt;offset &lt;&lt; &quot; size: &quot; &lt;&lt; size &lt;&lt; &quot;.&quot;);
 
     /* continue checking (with pd and host known and valid) */
 
     if (!reason) {
         if (!cbdataReferenceValid(pd-&gt;peer))
             reason = &quot;peer disappeared&quot;;
         else if (size &lt; 0)
             reason = &quot;swap failure&quot;;
         else if (!fetch-&gt;entry)
             reason = &quot;swap aborted?!&quot;;
         else if (EBIT_TEST(fetch-&gt;entry-&gt;flags, ENTRY_ABORTED))
             reason = &quot;swap aborted&quot;;
     }
 
     /* continue checking (maybe-successful eof case) */
     if (!reason &amp;&amp; !size) {
         if (!pd-&gt;cd)
             reason = &quot;null digest?!&quot;;
-        else if (fetch-&gt;mask_offset != (int)pd-&gt;cd-&gt;mask_size)
+        else if (fetch-&gt;mask_offset != pd-&gt;cd-&gt;mask_size)
             reason = &quot;premature end of digest?!&quot;;
         else if (!peerDigestUseful(pd))
             reason = &quot;useless digest&quot;;
         else
             reason = no_bug = &quot;success&quot;;
     }
 
     /* finish if we have a reason */
     if (reason) {
         const int level = strstr(reason, &quot;?!&quot;) ? 1 : 3;
         debugs(72, level, &quot;&quot; &lt;&lt; step_name &lt;&lt; &quot;: peer &quot; &lt;&lt; host &lt;&lt; &quot;, exiting after '&quot; &lt;&lt; reason &lt;&lt; &quot;'&quot;);
         peerDigestReqFinish(fetch, buf,
                             1, pdcb_valid, pcb_valid, reason, !no_bug);
     } else {
         /* paranoid check */
         assert(pdcb_valid &amp;&amp; pcb_valid);
     }
 
     return reason != NULL;
 }

=== modified file 'src/store_digest.cc'
--- src/store_digest.cc	2016-01-01 00:12:18 +0000
+++ src/store_digest.cc	2016-07-09 10:54:40 +0000
@@ -423,105 +423,103 @@
     sd_state.rewrite_lock = NULL;
     ++sd_state.rewrite_count;
     eventAdd(&quot;storeDigestRewriteStart&quot;, storeDigestRewriteStart, NULL, (double)
              Config.digest.rewrite_period, 1);
     /* resume pending Rebuild if any */
 
     if (sd_state.rebuild_lock)
         storeDigestRebuildResume();
 }
 
 /* swaps out one digest &quot;chunk&quot; per invocation; schedules next swap out */
 static void
 storeDigestSwapOutStep(void *data)
 {
     StoreEntry *e = static_cast&lt;StoreEntry *&gt;(data);
     int chunk_size = Config.digest.swapout_chunk_size;
     assert(e == sd_state.rewrite_lock);
     assert(e);
     /* _add_ check that nothing bad happened while we were waiting @?@ @?@ */
 
-    if (sd_state.rewrite_offset + chunk_size &gt; store_digest-&gt;mask_size)
+    if (static_cast&lt;uint32_t&gt;(sd_state.rewrite_offset + chunk_size) &gt; store_digest-&gt;mask_size)
         chunk_size = store_digest-&gt;mask_size - sd_state.rewrite_offset;
 
     e-&gt;append(store_digest-&gt;mask + sd_state.rewrite_offset, chunk_size);
 
     debugs(71, 3, &quot;storeDigestSwapOutStep: size: &quot; &lt;&lt; store_digest-&gt;mask_size &lt;&lt;
            &quot; offset: &quot; &lt;&lt; sd_state.rewrite_offset &lt;&lt; &quot; chunk: &quot; &lt;&lt;
            chunk_size &lt;&lt; &quot; bytes&quot;);
 
     sd_state.rewrite_offset += chunk_size;
 
     /* are we done ? */
-    if (sd_state.rewrite_offset &gt;= store_digest-&gt;mask_size)
+    if (static_cast&lt;uint32_t&gt;(sd_state.rewrite_offset) &gt;= store_digest-&gt;mask_size)
         storeDigestRewriteFinish(e);
     else
         eventAdd(&quot;storeDigestSwapOutStep&quot;, storeDigestSwapOutStep, data, 0.0, 1, false);
 }
 
 static void
 storeDigestCBlockSwapOut(StoreEntry * e)
 {
     memset(&amp;sd_state.cblock, 0, sizeof(sd_state.cblock));
     sd_state.cblock.ver.current = htons(CacheDigestVer.current);
     sd_state.cblock.ver.required = htons(CacheDigestVer.required);
     sd_state.cblock.capacity = htonl(store_digest-&gt;capacity);
     sd_state.cblock.count = htonl(store_digest-&gt;count);
     sd_state.cblock.del_count = htonl(store_digest-&gt;del_count);
     sd_state.cblock.mask_size = htonl(store_digest-&gt;mask_size);
-    sd_state.cblock.bits_per_entry = (unsigned char)
-                                     Config.digest.bits_per_entry;
+    sd_state.cblock.bits_per_entry = Config.digest.bits_per_entry;
     sd_state.cblock.hash_func_count = (unsigned char) CacheDigestHashFuncCount;
     e-&gt;append((char *) &amp;sd_state.cblock, sizeof(sd_state.cblock));
 }
 
 /* calculates digest capacity */
 static int
 storeDigestCalcCap(void)
 {
     /*
      * To-Do: Bloom proved that the optimal filter utilization is 50% (half of
      * the bits are off). However, we do not have a formula to calculate the
      * number of _entries_ we want to pre-allocate for.
      */
     const int hi_cap = Store::Root().maxSize() / Config.Store.avgObjectSize;
     const int lo_cap = 1 + Store::Root().currentSize() / Config.Store.avgObjectSize;
     const int e_count = StoreEntry::inUseCount();
     int cap = e_count ? e_count :hi_cap;
     debugs(71, 2, &quot;storeDigestCalcCap: have: &quot; &lt;&lt; e_count &lt;&lt; &quot;, want &quot; &lt;&lt; cap &lt;&lt;
            &quot; entries; limits: [&quot; &lt;&lt; lo_cap &lt;&lt; &quot;, &quot; &lt;&lt; hi_cap &lt;&lt; &quot;]&quot;);
 
     if (cap &lt; lo_cap)
         cap = lo_cap;
 
     /* do not enforce hi_cap limit, average-based estimation may be wrong
      *if (cap &gt; hi_cap)
      *  cap = hi_cap;
      */
     return cap;
 }
 
 /* returns true if we actually resized the digest */
 static int
 storeDigestResize(void)
 {
     const int cap = storeDigestCalcCap();
-    int diff;
     assert(store_digest);
-    diff = abs(cap - store_digest-&gt;capacity);
+    uint64_t diff = abs(cap - store_digest-&gt;capacity);
     debugs(71, 2, &quot;storeDigestResize: &quot; &lt;&lt;
            store_digest-&gt;capacity &lt;&lt; &quot; -&gt; &quot; &lt;&lt; cap &lt;&lt; &quot;; change: &quot; &lt;&lt;
            diff &lt;&lt; &quot; (&quot; &lt;&lt; xpercentInt(diff, store_digest-&gt;capacity) &lt;&lt; &quot;%)&quot; );
     /* avoid minor adjustments */
 
     if (diff &lt;= store_digest-&gt;capacity / 10) {
         debugs(71, 2, &quot;storeDigestResize: small change, will not resize.&quot;);
         return 0;
     } else {
         debugs(71, 2, &quot;storeDigestResize: big change, resizing.&quot;);
         store_digest-&gt;updateCapacity(cap);
         return 1;
     }
 }
 
 #endif /* USE_CACHE_DIGESTS */
 

=== modified file 'src/tests/stub_CacheDigest.cc'
--- src/tests/stub_CacheDigest.cc	2016-01-01 00:12:18 +0000
+++ src/tests/stub_CacheDigest.cc	2016-07-09 10:24:06 +0000
@@ -1,33 +1,33 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;store_key_md5.h&quot;
 
 #define STUB_API &quot;CacheDigest.cc&quot;
 #include &quot;tests/STUB.h&quot;
 
 class CacheDigest;
 class CacheDigestGuessStats;
 class StoreEntry;
 
 #include &quot;CacheDigest.h&quot;
-CacheDigest::CacheDigest(int, int) {STUB}
+CacheDigest::CacheDigest(uint64_t, uint8_t) {STUB}
 CacheDigest::~CacheDigest() {STUB}
 CacheDigest *CacheDigest::clone() const STUB_RETVAL(nullptr)
 void CacheDigest::clear() STUB
-void CacheDigest::updateCapacity(int) STUB
+void CacheDigest::updateCapacity(uint64_t) STUB
 bool CacheDigest::contains(const cache_key *) const STUB_RETVAL(false)
 void CacheDigest::add(const cache_key *) STUB
 void CacheDigest::remove(const cache_key *) STUB
 double CacheDigest::usedMaskPercent() const STUB_RETVAL(0.0)
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats *, int, int) STUB
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats *, StoreEntry *, const char *) STUB
 void cacheDigestReport(CacheDigest *, const char *, StoreEntry *) STUB
-size_t CacheDigest::CalcMaskSize(int, int) STUB_RETVAL(1)
+uint32_t CacheDigest::CalcMaskSize(uint64_t, uint8_t) STUB_RETVAL(1)
 

</PRE>

























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006138.html">[squid-dev] [PATCH] avoid flooding cache.log with &quot;uninitialized value&quot; messages from ext_wbinfo_group_acl helper script
</A></li>
	<LI>Next message: <A HREF="006151.html">[squid-dev] [PATCH Bug 4534 and N-bit fixes for CacheDigest
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6145">[ date ]</a>
              <a href="thread.html#6145">[ thread ]</a>
              <a href="subject.html#6145">[ subject ]</a>
              <a href="author.html#6145">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
