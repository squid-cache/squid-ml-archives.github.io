<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C5781B52E.7090308%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006144.html">
   <LINK REL="Next"  HREF="006150.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C5781B52E.7090308%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Jul 10 02:38:38 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006144.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006150.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6149">[ date ]</a>
              <a href="thread.html#6149">[ thread ]</a>
              <a href="subject.html#6149">[ subject ]</a>
              <a href="author.html#6149">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/09/2016 07:10 AM, Amos Jeffries wrote:
&gt;<i> On 9/07/2016 11:18 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 07/08/2016 12:44 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 8/07/2016 11:24 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> +    void resetWithoutLocking(T *t) {
</I>&gt;&gt;&gt;&gt;&gt;<i> +        unlock();
</I>&gt;&gt;&gt;&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;&gt;&gt;&gt;<i>      }
</I>&gt;&gt;&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;&gt;&gt;<i>      void resetAndLock(T *t) {
</I>&gt;&gt;&gt;&gt;&gt;<i> +        if (t != get()) {
</I>&gt;&gt;&gt;&gt;&gt;<i> +            resetWithoutLocking(t);
</I>&gt;&gt;&gt;&gt;&gt;<i> +            lock(t);
</I>&gt;&gt;&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;&gt;&gt;<i> +    }
</I>
&gt;&gt;&gt;&gt;<i> We should probably add self-reset protection to both cases or to none.
</I>
&gt;&gt;<i> Self-assignment and self-reset is a gray area. Each
</I>&gt;&gt;<i> assignment/reset-handling class can define what should happen under
</I>&gt;&gt;<i> those circumstances. The possible sane definitions are:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   1. Do nothing (side effects lead to leaks/crashes in non-benign cases)
</I>&gt;&gt;<i>   2. assertion/exception (explicit error in all cases)
</I>&gt;&gt;<i>   3. Do the usual (side effects lead to leaks/crashes in most cases)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Which definition to pick is our choice, but we should be _consistent_ in
</I>&gt;&gt;<i> that choice. I recommend #1, but it is a weak recommendation.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In the latest patch I have seen, resetAndLock() was using #1 but
</I>&gt;&gt;<i> resetWithoutLocking() was using #3.
</I>

&gt;<i> resetAndLock() is doing #1
</I>
Agreed.


&gt;<i> and there are no side effects. Because the
</I>&gt;<i> new lock() is performed by us, not the caller. So we can confidently do
</I>&gt;<i> nothing with no side effects.
</I>
We cannot be confident that doing nothing will not cause problems. For
example, the following well-meaning caller code will assert due to those
unexpected &quot;side effects&quot; of approach #1:

void importCertificate(LockingPointer &amp;p, X509 *x)
{
    const int referenceCount = x-&gt;references;
    p.resetAndLock(x);
    // check that we actually locked the new certificate
    assert(x-&gt;references &gt; referenceCount);
}


... if importCertificate() is fed p that already manages certificate x.

Needless to say, such self-resets ought to be &quot;rare&quot;, but they are far
from impossible in complex programs where the original relationship
between two pointers can be unknown or lost/forgotten. This is no
different than self-assignment AFAICT.



&gt;<i> resetWithoutLocking() cannot do #1 without adding the listed side
</I>&gt;<i> effects for all 'benign' cases.
</I>
In what I call benign cases, approach #1 always works correctly:

    p.resetWithoutLocking(p-&gt;get()); // never a problem with #1!

To construct a case where approach #1 leads to problems you need
non-benign code. For example:

void importCertificate(LockingPointer &amp;p, X509 *x)
{
    const LockingPointer old = p;
    const int referenceCount = x-&gt;references;
    p.resetWithoutLocking(x);
    // check that we got rid of the old certificate
    assert(x-&gt;references &lt; referenceCount);
}

Needless to say, the above examples are just problem illustrations; real
code triggering these kind of problems is usually more convoluted.


&gt;<i> The words &quot;most cases&quot; is incorrect on #3, because most cases will be
</I>&gt;<i> caller acting correctly and doing its +1 on the locks before our
</I>&gt;<i> unlock() is used. Only buggy callers will lead to the listed side effects.
</I>
Unfortunately, #3 actually leads to leaks or crashes in benign cases
where caller _is_ doing its +1 (as well as in some non-benign cases, of
course). For example:

  x = newX509(); // creates and locks certificate x
  assert(x-&gt;references == 1); // OK, newX509() +1ed as expected
  LockingPointer p(x);
  assert(x-&gt;references == 1); // OK, our constructor did nothing
  p.resetWithoutLocking(x); // Opos, x is deleted here due to #3
  std::cout &lt;&lt; *p-&gt;get(); // crash

The same is true for resetAndLock(), of course -- the self-reset problem
is universal. The only possible difference between the two reset*()
methods is whether a conservative unlock() implementation asserts before
the cout usage crash illustrated above:

  unlock() {
      assert(x-&gt;references &gt; 0); // #3 resetAndLock() may assert here
      --x-&gt;references;
      if (!x-&gt;references) // we were the last one with a lock
          delete x; // of free(x), etc.
  }


&gt;<i> I argue that these are bugs in the callers. 
</I>
Yes, we agree that these self-resets are usually caller &quot;bugs&quot; or at
least &quot;problems&quot; of one kind or another.


&gt;<i> Bugs we need to see (via those side effects) and fix.
</I>
If you want to see bugs, you need approach #2. Neither #1 nor #3 are
reliable in exposing bugs (bad side effects may or may not happen,
depending on the caller).


&gt;<i> We cannot assert in the self-reset case because that is a legitimate
</I>&gt;<i> input from good callers. We can trust them to have locked. There is
</I>&gt;<i> nothing we can reliably use as assert() parameter.
</I>
The assert in #2 is just the guard condition. It works fine for regular
cases and only triggers in case of a self-assignment:

LockingPointer::reset*()
{
    // consider all self-resets to be bugs and expose them
    assert(t != get());

    ... do what is needed ...
}




&gt;&gt;&gt;<i> If that means the raw-pointer is
</I>&gt;&gt;&gt;<i> about to go invalid then its a caller bug for using that method of the
</I>&gt;&gt;&gt;<i> API. Because resetWithoutLocking() fully delegates lock control to the
</I>&gt;&gt;&gt;<i> caller this is not something we can make assumptions about in the
</I>&gt;&gt;&gt;<i> resetWithoutLocking() variant.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Self-assignment and self-reset is always a caller problem and is always
</I>&gt;&gt;<i> a gray area -- logical reasoning cannot arrive at a single &quot;correct&quot; or
</I>&gt;&gt;<i> &quot;best&quot; solution here.
</I>&gt;<i> 
</I>&gt;<i> In the generic case you might be right.
</I>&gt;<i> 
</I>&gt;<i> However, we have a situation here where OpenSSL functions either lock or
</I>&gt;<i> they don't lock. That black-and-white limitation works in our favour
</I>&gt;<i> here so we can calculate with code being either good or buggy and reason
</I>&gt;<i> from that.
</I>
Sorry, but [OpenSSL] locking has nothing to do with self-assignment or
self-reset. By definition, self-assignment is &quot;p=p&quot; or equivalent.
Similarly, self-reset is, by definition:

    p.reset*(p-&gt;get())

or equivalent. That is, you are resetting a smart pointer using the
smart pointer itSELF (or equivalent). That is what resetAndLock()
if-statement checks, and that is the check that resetWithoutLocking()
currently lacks.

If you were actually talking about a completely different problem of
checking whether resetWithoutLocking() caller incremented the lock, then
I agree that it is a goo idea for OpenSSL-specific build to check that,
provided this works for all OpenSSL objects fed to LockingPointer:

    void resetWithoutLocking(T *t) {
#if USE_OPENSSL
        assert(t-&gt;references &gt; 0); // the caller must lock!
#endif
         ... the reset code goes here ...
    }

Again, this is completely unrelated to the self-reset problem.


&gt;&gt;<i> A caller has delegated control of the already managed object locks to
</I>&gt;&gt;<i> us.
</I>&gt;&gt;<i> Now the caller wants us to import the same object that was allegedly
</I>&gt;&gt;<i> pre-locked for our import. It is our decision whether to unlock/free the
</I>&gt;&gt;<i> object (#3), assert/throw (#2), or do nothing (#1).
</I>
&gt;<i> This is a new caller allegedly with a pointer it has added a second lock
</I>&gt;<i> to. It doesn't matter that the value is self because that second lock
</I>&gt;<i> exists. resetWithoutLocking() is just discarding that old lock, and
</I>&gt;<i> taking responsibility for the new one.
</I>
There is no &quot;*second* lock&quot; guarantee in this context -- all external
resetWithoutLocking() callers believe they are supplying us a raw
pointer pre-locked by OpenSSL (and that OpenSSL expects us to unlock
some time later to avoid leaks), nothing more.


&gt;<i> A good caller code is one that has actually done the locking it should
</I>&gt;<i> have and delagating us the unlock() task. 
</I>
Yes.


&gt;<i> There will be no problem from using UnLocker() on the previously stored value. 
</I>
There may be. See above for specific self-reset examples that lead to
assertions in unlocker or right after it, depending on the unlocker
implementation.


&gt;<i> A buggy caller code is one that is not adding that lock and still using
</I>&gt;<i> resetWithoutLocking()
</I>
That would be indeed a bug, but it has nothing to do with self-reset.


&gt;&gt;<i> I doubt we should pick #3, but that is not what I am complaining about
</I>&gt;&gt;<i> right now. I am complaining about inconsistency. If you are sure that
</I>&gt;&gt;<i> crashing the program in most cases is the best solution in the
</I>&gt;&gt;<i> LockingPointer context, then you should use that solution for all
</I>&gt;&gt;<i> reset*() and assignment methods.
</I>&gt;<i> 
</I>&gt;<i> Crashing is *not* okay in the resetAndLock() pathway self-assignment.
</I>&gt;<i> That code is working correctly.
</I>&gt;<i> 
</I>&gt;<i> The inconsistency is forced by OpenSSL behaviour.
</I>
OpenSSL has nothing to do with the self-reset problem. The same
self-reset problem would exist for any TLS library implementation,
pre-locking or not.

OpenSSL inconsistencies force us to have two reset*() methods, but that
is where OpenSSL responsibilities for our problems end. We are
responsible for self-assignment and self-reset handling.



&gt;&gt;<i> For example, the following benign code triggers self-reset but has no
</I>&gt;&gt;<i> side effects at all if self-reset is handled using the &quot;do nothing&quot;
</I>&gt;&gt;<i> approach:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     p.reset(p-&gt;get()); // p = p
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> I assume you meant to write resetWithoutLocking() there.
</I>
No, the above applies to both reset*() methods.


&gt;<i> That code pattern is buggy.
</I>
Yes, and that is what self-reset handling is all about.



&gt;<i> Correct 'p = p' code is:
</I>&gt;<i> 
</I>&gt;<i> for 3.5:
</I>&gt;<i>   p.reset(p.release());
</I>
The above code has nothing to do with self-reset, just like the
following code is _not_ self-assignment, by *definition*:

  p1 = p;
  p = p1;



&gt;<i> for trunk:
</I>&gt;<i>   p = std::move(p);
</I>
That is self-assignment AFAICT, but let's finish with non-optimized code
before we tackle optimizations.




&gt;&gt;&gt;<i> the non-TLS builds UnLocker will do
</I>&gt;&gt;&gt;<i> nothing and T will just be a void or int placeholder.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That does not sound quite right to me: If we want TLS-incapable code to
</I>&gt;&gt;<i> use LockingPointer for TLS stuff that cannot exist in such code, then
</I>&gt;&gt;<i> UnLocker and lock() ought to assert! In other words, only nil
</I>&gt;&gt;<i> LockingPointers should be allowed in that special case.
</I>

&gt;<i> The lock() method asserts if it is ever used on those builds. So its
</I>&gt;<i> caught on assignment, not destruct.
</I>
That is good but not sufficient because resetWithoutLocking() and
LockingPointer constructor does not call lock(). Adding an assertion to
resetWithoutLocking() would address that; no need to assert in UnLocker
if you do that, but it would not hurt either (in case we missed another
spot where resetWithoutLocking should have been called but was not).


Please resolve self-assignment/reset consistency. I hope the above
clarifies why the already committed code should be fixed.


Thank you,

Alex.
P.S. Please note that, just like with self-assignment, it is probably
possible to implement #1 without if-statements that check for self-reset
explicitly. However, that is a code style question, not functionality
issue, so I am ignoring it for now since we have a bigger functionality
problem to solve first.

</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006144.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006150.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6149">[ date ]</a>
              <a href="thread.html#6149">[ thread ]</a>
              <a href="subject.html#6149">[ subject ]</a>
              <a href="author.html#6149">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
