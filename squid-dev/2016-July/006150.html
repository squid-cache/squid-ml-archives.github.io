<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C091211f0-1f07-1179-c482-5497fdcdeab7%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006149.html">
   <LINK REL="Next"  HREF="006157.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3C091211f0-1f07-1179-c482-5497fdcdeab7%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Jul 10 08:02:34 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006149.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006157.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6150">[ date ]</a>
              <a href="thread.html#6150">[ thread ]</a>
              <a href="subject.html#6150">[ subject ]</a>
              <a href="author.html#6150">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/07/2016 2:38 p.m., Alex Rousskov wrote:
&gt;<i> On 07/09/2016 07:10 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 9/07/2016 11:18 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 07/08/2016 12:44 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> On 8/07/2016 11:24 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +    void resetWithoutLocking(T *t) {
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +        unlock();
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +        raw = t;
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>      }
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>      void resetAndLock(T *t) {
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +        if (t != get()) {
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +            resetWithoutLocking(t);
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +            lock(t);
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> +    }
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;&gt;<i> We should probably add self-reset protection to both cases or to none.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Self-assignment and self-reset is a gray area. Each
</I>&gt;&gt;&gt;<i> assignment/reset-handling class can define what should happen under
</I>&gt;&gt;&gt;<i> those circumstances. The possible sane definitions are:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   1. Do nothing (side effects lead to leaks/crashes in non-benign cases)
</I>&gt;&gt;&gt;<i>   2. assertion/exception (explicit error in all cases)
</I>&gt;&gt;&gt;<i>   3. Do the usual (side effects lead to leaks/crashes in most cases)
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Which definition to pick is our choice, but we should be _consistent_ in
</I>&gt;&gt;&gt;<i> that choice. I recommend #1, but it is a weak recommendation.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In the latest patch I have seen, resetAndLock() was using #1 but
</I>&gt;&gt;&gt;<i> resetWithoutLocking() was using #3.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> resetAndLock() is doing #1
</I>&gt;<i> 
</I>&gt;<i> Agreed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> and there are no side effects. Because the
</I>&gt;&gt;<i> new lock() is performed by us, not the caller. So we can confidently do
</I>&gt;&gt;<i> nothing with no side effects.
</I>&gt;<i> 
</I>
I think you still have some confusion about the LockingPointer API
requirements.

In total:

* For the LockingPointer(T*) ctor and resetWithoutLocking() method
 the caller is responsible for:
 - doing a +1 lock itself, and
 - exactly once for *each time either is used*, and
 - doing it before the call/use.

* For release() the caller is taking on responsibility for exactly 1
un-lock operation.

* For all other methods and operators the recieving Pointer is
responsible for the locking.


Please reconsider your code examples in light of those requirements and
you should see where the bugs in the examples are confusing you.


&gt;<i> We cannot be confident that doing nothing will not cause problems. For
</I>&gt;<i> example, the following well-meaning caller code will assert due to those
</I>&gt;<i> unexpected &quot;side effects&quot; of approach #1:
</I>&gt;<i> 
</I>&gt;<i> void importCertificate(LockingPointer &amp;p, X509 *x)
</I>&gt;<i> {
</I>&gt;<i>     const int referenceCount = x-&gt;references;
</I>&gt;<i>     p.resetAndLock(x);
</I>&gt;<i>     // check that we actually locked the new certificate
</I>&gt;<i>     assert(x-&gt;references &gt; referenceCount);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ... if importCertificate() is fed p that already manages certificate x.
</I>&gt;<i> 
</I>
The p.resetAndLock() semantically increments the x references and
decrements the existing pointers references before it returns. Making
the assert '&gt;' a bug.

That is true for any proper reference counting. The self-check is an
optimization of that case. Not a requirement.


&gt;<i> 
</I>&gt;&gt;<i> resetWithoutLocking() cannot do #1 without adding the listed side
</I>&gt;&gt;<i> effects for all 'benign' cases.
</I>&gt;<i> 
</I>&gt;<i> In what I call benign cases, approach #1 always works correctly:
</I>&gt;<i> 
</I>&gt;<i>     p.resetWithoutLocking(p-&gt;get()); // never a problem with #1!
</I>&gt;<i> 
</I>
Bug:  caller of resetWithoutLocking() is not doing a +1 lock increment
itself before that method is called.


&gt;<i> To construct a case where approach #1 leads to problems you need
</I>&gt;<i> non-benign code. For example:
</I>&gt;<i> 
</I>&gt;<i> void importCertificate(LockingPointer &amp;p, X509 *x)
</I>&gt;<i> {
</I>&gt;<i>     const LockingPointer old = p;
</I>&gt;<i>     const int referenceCount = x-&gt;references;
</I>&gt;<i>     p.resetWithoutLocking(x);
</I>&gt;<i>     // check that we got rid of the old certificate
</I>&gt;<i>     assert(x-&gt;references &lt; referenceCount);
</I>&gt;<i> }
</I>&gt;<i> 
</I>
Bug:  caller of resetWithoutLocking() did not do the +1 lock it is
required to do before using that method.



&gt;<i> Needless to say, the above examples are just problem illustrations; real
</I>&gt;<i> code triggering these kind of problems is usually more convoluted.
</I>&gt;<i> 
</I>
Yes the bug location failing to do +1 may be somewhere in the caller of
the above importCertificate(). But in essence the whole chain of code
passing 'x' variable down to resetWithoutLocking() is responsible.

By not doing the +1 lock beore calling ResetWithoutLocking() its still a
bug in the caller(s).

&gt;<i> 
</I>&gt;&gt;<i> The words &quot;most cases&quot; is incorrect on #3, because most cases will be
</I>&gt;&gt;<i> caller acting correctly and doing its +1 on the locks before our
</I>&gt;&gt;<i> unlock() is used. Only buggy callers will lead to the listed side effects.
</I>&gt;<i> 
</I>&gt;<i> Unfortunately, #3 actually leads to leaks or crashes in benign cases
</I>&gt;<i> where caller _is_ doing its +1 (as well as in some non-benign cases, of
</I>&gt;<i> course). For example:
</I>&gt;<i> 
</I>&gt;<i>   x = newX509(); // creates and locks certificate x
</I>&gt;<i>   assert(x-&gt;references == 1); // OK, newX509() +1ed as expected
</I>&gt;<i>   LockingPointer p(x);
</I>
NP: the caller has delegated its lock to p constructor.
Making 'x' effectively a raw-pointer with *no* lock associated.

&gt;<i>   assert(x-&gt;references == 1); // OK, our constructor did nothing
</I>
That 1 reference is held by p now. *not x*.

&gt;<i>   p.resetWithoutLocking(x); // Opos, x is deleted here due to #3
</I>
Bug: using resetWithoutLocking() instead of resetAndLock(), when 'x' has
no caller lock associated.

&gt;<i>   std::cout &lt;&lt; *p-&gt;get(); // crash
</I>&gt;<i> 
</I>&gt;<i> The same is true for resetAndLock(), of course
</I>
No. If it was, then Reference Counting (the universal concept) would not
work anywhere.

resetAndLock() is the method by which regular normal reference counting
is done. The recipient smart-pointer taking care of any +1/-1 that needs
to happen and ordering them to ensure the pointer received stays valid.


&gt;<i> -- the self-reset problem
</I>&gt;<i> is universal. The only possible difference between the two reset*()
</I>&gt;<i> methods
</I>
... is their entire semantic behaviour design.


&gt;<i> is whether a conservative unlock() implementation asserts before
</I>&gt;<i> the cout usage crash illustrated above:
</I>&gt;<i> 
</I>&gt;<i>   unlock() {
</I>&gt;<i>       assert(x-&gt;references &gt; 0); // #3 resetAndLock() may assert here
</I>&gt;<i>       --x-&gt;references;
</I>&gt;<i>       if (!x-&gt;references) // we were the last one with a lock
</I>&gt;<i>           delete x; // of free(x), etc.
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> I argue that these are bugs in the callers. 
</I>&gt;<i> 
</I>&gt;<i> Yes, we agree that these self-resets are usually caller &quot;bugs&quot; or at
</I>&gt;<i> least &quot;problems&quot; of one kind or another.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Bugs we need to see (via those side effects) and fix.
</I>&gt;<i> 
</I>&gt;<i> If you want to see bugs, you need approach #2. Neither #1 nor #3 are
</I>&gt;<i> reliable in exposing bugs (bad side effects may or may not happen,
</I>&gt;<i> depending on the caller).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> We cannot assert in the self-reset case because that is a legitimate
</I>&gt;&gt;<i> input from good callers. We can trust them to have locked. There is
</I>&gt;&gt;<i> nothing we can reliably use as assert() parameter.
</I>&gt;<i> 
</I>&gt;<i> The assert in #2 is just the guard condition. It works fine for regular
</I>&gt;<i> cases and only triggers in case of a self-assignment:
</I>&gt;<i> 
</I>&gt;<i> LockingPointer::reset*()
</I>&gt;<i> {
</I>&gt;<i>     // consider all self-resets to be bugs and expose them
</I>&gt;<i>     assert(t != get());
</I>&gt;<i> 
</I>&gt;<i>     ... do what is needed ...
</I>&gt;<i> }
</I>
self-reset is perfectly fine IFF the caller meets the requirements I
outlined at the top. You can't make an assert that tests that reliably.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> If that means the raw-pointer is
</I>&gt;&gt;&gt;&gt;<i> about to go invalid then its a caller bug for using that method of the
</I>&gt;&gt;&gt;&gt;<i> API. Because resetWithoutLocking() fully delegates lock control to the
</I>&gt;&gt;&gt;&gt;<i> caller this is not something we can make assumptions about in the
</I>&gt;&gt;&gt;&gt;<i> resetWithoutLocking() variant.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Self-assignment and self-reset is always a caller problem and is always
</I>&gt;&gt;&gt;<i> a gray area -- logical reasoning cannot arrive at a single &quot;correct&quot; or
</I>&gt;&gt;&gt;<i> &quot;best&quot; solution here.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In the generic case you might be right.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> However, we have a situation here where OpenSSL functions either lock or
</I>&gt;&gt;<i> they don't lock. That black-and-white limitation works in our favour
</I>&gt;&gt;<i> here so we can calculate with code being either good or buggy and reason
</I>&gt;&gt;<i> from that.
</I>&gt;<i> 
</I>&gt;<i> Sorry, but [OpenSSL] locking has nothing to do with self-assignment or
</I>&gt;<i> self-reset. By definition, self-assignment is &quot;p=p&quot; or equivalent.
</I>&gt;<i> Similarly, self-reset is, by definition:
</I>
Then don't call it OpenSSL, call it Fubar for an appropriate acronym.

It has the properties of some calls externally doing a +1 to 'help' our
reference counting Pointers. But not doing the matching unlock.


&gt;<i>     p.reset*(p-&gt;get())
</I>&gt;<i> 
</I>&gt;<i> or equivalent. That is, you are resetting a smart pointer using the
</I>&gt;<i> smart pointer itSELF (or equivalent). That is what resetAndLock()
</I>&gt;<i> if-statement checks, and that is the check that resetWithoutLocking()
</I>&gt;<i> currently lacks.
</I>
For resetAndLock() that above code is fine. p ensures that pointer stays
valid through the locking/unlocking.

For resetWithoutLocking() its bug: caller not doing +1 itself before use
of the method.

&gt;<i> 
</I>&gt;<i> If you were actually talking about a completely different problem of
</I>&gt;<i> checking whether resetWithoutLocking() caller incremented the lock, then
</I>
I dont mean *checking* the lock. I mean the LockingPointer requirements
as listed at the top of this mail must be met.
 The callers which use non-locking interface must meet the lock +1
requirements in order to use that interface.


If you consider regular Refcount Pointers. If a caller did its own -1
reference operation you would call that a bug yes?

It is nasty that LockingPointer has to deal with external lock fiddling.
But we can't get away from that. All we can do is be very careful that
the alternative API is used correctly (in ways that meet the above
requirements).

&gt;<i> 
</I>&gt;&gt;<i> A buggy caller code is one that is not adding that lock and still using
</I>&gt;&gt;<i> resetWithoutLocking()
</I>&gt;<i> 
</I>&gt;<i> That would be indeed a bug, but it has nothing to do with self-reset.
</I>&gt;<i> 
</I>
All the presented examples of self-reset are demonstrations of callers
failing that one requirement.

I am completely certain that if the callers using the non-locking API
meet that requirement the locking math works out okay with the current
trunk code.

I am also completely certain that if we add the if-statement to prevent
self-reset/assign unlock() happening *inside* the resetWithoutLocking()
that callers will become unable to use it reliably in those cases.
 We would have to make all callers detect that self-reset/assign case
externally and have extra code to work around the non-unlocking behaviour.


How can I be so certain?

 1) The same behaviour can be implemented by ordering the new values +1
before the old values -1. With no self-protecting if-statement.
 --&gt; always both operations happen even on self-reset/assign.

 2) The normal pattern we are all familiar with wraps BOTH the lock and
unlock operations inside the if-statemet.
 --&gt; either both happen or neither.

When we come to the resetWithoutLocking() it is behaviourally only an
unlock for the old value.

Critically it does not lock on the new value. That means we CANNOT be
doing the 'BOTH' behaviour of (2) inside the method.

Therefore (1) has to be the implementation for use of this part of the
API. With the +1 step happening in caller, and the -1 inside
resetWithoutLocking().
 --&gt; this is where the requirements list I wrote at the top come from.


Is that clear enough now?

Amos

</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006149.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006157.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6150">[ date ]</a>
              <a href="thread.html#6150">[ thread ]</a>
              <a href="subject.html#6150">[ subject ]</a>
              <a href="author.html#6150">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
