<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fetch missing certificates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fetch%20missing%20certificates&In-Reply-To=%3C5783EFDB.6090504%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006189.html">
   <LINK REL="Next"  HREF="006171.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fetch missing certificates</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fetch%20missing%20certificates&In-Reply-To=%3C5783EFDB.6090504%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Fetch missing certificates">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Jul 11 19:13:31 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006189.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
        <LI>Next message: <A HREF="006171.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6164">[ date ]</a>
              <a href="thread.html#6164">[ thread ]</a>
              <a href="subject.html#6164">[ subject ]</a>
              <a href="author.html#6164">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/11/2016 10:18 AM, Christos Tsantilas wrote:

&gt;<i> +    /// The maximum allowed object size.
</I>&gt;<i> +    static const size_t MaxObjectSize = 1*1024*1024;
</I>

&gt;<i> +    bool existingContent = reply ? reply-&gt;content_length : 0;
</I>&gt;<i> +    bool exceedSize = (existingContent &gt; -1 &amp;&amp; (size_t)existingContent &gt; MaxObjectSize) || 
</I>&gt;<i> +        ((object.length() + receivedData.length) &gt; MaxObjectSize);
</I>
Wrong type for existingContent. Please use appropriate C++ type casts.

Please refactor to also account for SBuf::maxSize, even if the current
MaxObjectSize is much smaller.

If you can make them const, make them const.

Also, please s/exceedSize/tooLarge/ or s/excessiveSize/.


&gt;<i> +        status = Http::scInternalServerError;
</I>&gt;<i> +        callBack();
</I>
&gt;<i> +        status = Http::scOkay;
</I>&gt;<i> +        callBack();
</I>
&gt;<i> +        status = Http::scInternalServerError;
</I>&gt;<i> +        callBack();
</I>
&gt;<i> +        status = Http::scInternalServerError;
</I>&gt;<i> +        callBack();
</I>
Please make status a callBack() parameter instead of a Downloader data
member.


&gt;<i> +    /// Callback data to use with Downloader callbacks.
</I>&gt;<i> +    class CbDialer {
</I>&gt;<i> +    public:
</I>&gt;<i> +        CbDialer(): status(Http::scNone) {}
</I>&gt;<i> +        virtual ~CbDialer() {}
</I>&gt;<i> +        SBuf object;
</I>&gt;<i> +        Http::StatusCode status;
</I>&gt;<i> +    };
</I>
If you can make Downloader::CbDialer print the status parameter and
perhaps, for successful downloads, the beginning of object parameter
(via Raw), please do so. See CallDialer::print().


&gt;<i> +    debugs(33, 5, HERE);
</I>
&gt;<i> +    debugs(33 , 2, HERE);
</I>
&gt;<i> +    debugs(33, 6, HERE);
</I>
s/HERE/this/


&gt;<i> +    ClientHttpRequest *const http = new ClientHttpRequest(NULL);
</I>
s/NULL/nullptr/ in new code


The scope of the following few comments overlap. They should be
considered together.

&gt;<i> +/// Used to hold and pass the required info and buffers to the
</I>&gt;<i> +/// clientStream callbacks
</I>&gt;<i> +class DownloaderContext: public RefCountable
</I>
Why do we need a dedicated class with complex lifetime controls [instead
of using Downloader itself] for this? I am not saying this is wrong yet,
just asking why it is needed...


&gt;<i> +class DownloaderContext: public RefCountable
</I>&gt;<i> +{
</I>&gt;<i> +    CBDATA_CLASS(DownloaderContext);
</I>
The combination of cbdata and RefCountable can be deadly as both
interfaces compete for object lifetime control without knowing about
each other. IIRC, a few of these ticking time bombs remain in Squid code
today, but here we are adding new code so, unless existing API require
this, we should avoid this combination.

I assume that ClientStreams require cbdata; is RefCountable required by
some other existing API?


&gt;<i> +DownloaderContext::~DownloaderContext()
</I>&gt;<i> +{
</I>...
&gt;<i> +    if (http)
</I>&gt;<i> +        finished();
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +void
</I>&gt;<i> +DownloaderContext::finished()
</I>&gt;<i> +{
</I>&gt;<i> +    delete http;
</I>&gt;<i> +    http = NULL;
</I>&gt;<i> +}
</I>
&gt;<i> +void
</I>&gt;<i> +Downloader::downloadFinished()
</I>&gt;<i> +{
</I>&gt;<i> +    debugs(33, 7, this);
</I>&gt;<i> +    context_-&gt;finished();
</I>
If we do not need to delete &quot;http&quot; right when downloadFinished() is
called, then please merge finished() into the DownloaderContext
destructor. Otherwise, perhaps add a source comment to document that we
cannot delay http destruction until refcounting deletes DownloaderContext.


&gt;<i> +     // Calling deleteThis method here to finish Downloader
</I>&gt;<i> +     // may result to squid crash.
</I>&gt;<i> +     // This method called by handleReply method which maybe called
</I>&gt;<i> +     // by ClientHttpRequest::doCallouts. The doCallouts after this object
</I>&gt;<i> +     // deleted, may operate on non valid objects.
</I>&gt;<i> +     // Schedule a fake call here just to force squid to delete this object.
</I>&gt;<i> +     CallJobHere(33, 7, CbcPointer&lt;Downloader&gt;(this), Downloader, downloadFinished);
</I>
Does a single async call guarantee that doCallouts() will be able to
handle our destruction? What if doCallouts() schedules an async call as
well and comes back after our destruction? Is this a problem our patch
introduces or an existing/old doCallouts() flaw that we simply need to
work around, just like some other doCallouts() users?


&gt;<i> +    Downloader* downloader;
</I>
&gt;<i> +    if (!cbdataReferenceValid(context-&gt;downloader))
</I>&gt;<i> +        return;
</I>
The check only makes sense if context-&gt;downloader is a CbcPointer or
equivalent, not a raw pointer. Otherwise, to reliably test downloader
validity you need the downloader pointer to be valid (i.e., either it
always works and the check is not needed or it may crash and the check
is broken).


&gt;<i> +    /// Fake call used internally by Downloader.
</I>&gt;<i> +    void downloadFinished();
</I>
This method/call is as real as any other call. We are forced to call it
asynchronously because of doCallouts() limitations, but it is not fake.
I suggest documenting it as &quot;delays destruction to protect doCallouts()&quot;
or something like that.


&gt;<i> +     // Schedule a fake call here just to force squid to delete this object.
</I>
Similarly, s/a fake/an async/


&gt;<i> +    debugs(33, 4, &quot;Received &quot; &lt;&lt; receivedData.length &lt;&lt;
</I>&gt;<i> +           &quot; object data, offset: &quot; &lt;&lt; receivedData.offset &lt;&lt;
</I>&gt;<i> +           &quot; error flag:&quot; &lt;&lt; receivedData.flags.error);
</I>
Please move this debugging up, before we may exit the method.

Also, should not we check receivedData.flags.error _before_ we interpret
any receivedData.length and such?


&gt;<i> +    bool exceedSize = (existingContent &gt; -1 &amp;&amp; (size_t)existingContent &gt; MaxObjectSize) || 
</I>&gt;<i> +        ((object.length() + receivedData.length) &gt; MaxObjectSize);
</I>
...

&gt;<i> +    if (receivedData.length &gt; 0) {
</I>&gt;<i> +        object.append(receivedData.data, receivedData.length);
</I>&gt;<i> +        http-&gt;out.size += receivedData.length;
</I>&gt;<i> +        http-&gt;out.offset += receivedData.length;
</I>&gt;<i> +    }
</I>
The combination does not make sense as far as non-positive
receivedData.length is concerned:

* If receivedData.length cannot be negative, then the if-statement is
not needed.
* If receivedData.length can be negative, then it cannot be used in
exceedSize calculations without protection.


Thank you,

Alex.

</PRE>

































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006189.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
	<LI>Next message: <A HREF="006171.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6164">[ date ]</a>
              <a href="thread.html#6164">[ thread ]</a>
              <a href="subject.html#6164">[ subject ]</a>
              <a href="author.html#6164">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
