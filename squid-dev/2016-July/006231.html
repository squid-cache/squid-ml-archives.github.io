<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fetch missing certificates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fetch%20missing%20certificates&In-Reply-To=%3C578670DB.8080501%40chtsanti.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006171.html">
   <LINK REL="Next"  HREF="006232.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fetch missing certificates</H1>
    <B>Christos Tsantilas</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fetch%20missing%20certificates&In-Reply-To=%3C578670DB.8080501%40chtsanti.net%3E"
       TITLE="[squid-dev] [PATCH] Fetch missing certificates">christos at chtsanti.net
       </A><BR>
    <I>Wed Jul 13 16:48:27 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006171.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
        <LI>Next message: <A HREF="006232.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6231">[ date ]</a>
              <a href="thread.html#6231">[ thread ]</a>
              <a href="subject.html#6231">[ subject ]</a>
              <a href="author.html#6231">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/11/2016 10:13 PM, Alex Rousskov wrote:
&gt;<i> On 07/11/2016 10:18 AM, Christos Tsantilas wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> +    /// The maximum allowed object size.
</I>&gt;&gt;<i> +    static const size_t MaxObjectSize = 1*1024*1024;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    bool existingContent = reply ? reply-&gt;content_length : 0;
</I>&gt;&gt;<i> +    bool exceedSize = (existingContent &gt; -1 &amp;&amp; (size_t)existingContent &gt; MaxObjectSize) ||
</I>&gt;&gt;<i> +        ((object.length() + receivedData.length) &gt; MaxObjectSize);
</I>&gt;<i>
</I>&gt;<i> Wrong type for existingContent. Please use appropriate C++ type casts.
</I>&gt;<i>
</I>&gt;<i> Please refactor to also account for SBuf::maxSize, even if the current
</I>&gt;<i> MaxObjectSize is much smaller.
</I>
Stupid bug. I am expecting c++ error in such cases but...


&gt;<i>
</I>&gt;<i> If you can make them const, make them const.
</I>&gt;<i>
</I>&gt;<i> Also, please s/exceedSize/tooLarge/ or s/excessiveSize/.
</I>
OK on these. I hope they are ok now.


&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +        status = Http::scInternalServerError;
</I>&gt;&gt;<i> +        callBack();
</I>&gt;<i>
</I>&gt;&gt;<i> +        status = Http::scOkay;
</I>&gt;&gt;<i> +        callBack();
</I>&gt;<i>
</I>&gt;&gt;<i> +        status = Http::scInternalServerError;
</I>&gt;&gt;<i> +        callBack();
</I>&gt;<i>
</I>&gt;&gt;<i> +        status = Http::scInternalServerError;
</I>&gt;&gt;<i> +        callBack();
</I>&gt;<i>
</I>&gt;<i> Please make status a callBack() parameter instead of a Downloader data
</I>&gt;<i> member.
</I>
ok.


&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    /// Callback data to use with Downloader callbacks.
</I>&gt;&gt;<i> +    class CbDialer {
</I>&gt;&gt;<i> +    public:
</I>&gt;&gt;<i> +        CbDialer(): status(Http::scNone) {}
</I>&gt;&gt;<i> +        virtual ~CbDialer() {}
</I>&gt;&gt;<i> +        SBuf object;
</I>&gt;&gt;<i> +        Http::StatusCode status;
</I>&gt;&gt;<i> +    };
</I>&gt;<i>
</I>&gt;<i> If you can make Downloader::CbDialer print the status parameter and
</I>&gt;<i> perhaps, for successful downloads, the beginning of object parameter
</I>&gt;<i> (via Raw), please do so. See CallDialer::print().
</I>
I did not change anything here.
The PeerConnectorCertDownloaderDialer which is Downloader::CbDialer and 
CallDialer kid implements the print method.

If you prefer we can make the Downloader::CbDialer a CallDialer kid and 
implement the print method.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    debugs(33, 5, HERE);
</I>&gt;<i>
</I>&gt;&gt;<i> +    debugs(33 , 2, HERE);
</I>&gt;<i>
</I>&gt;&gt;<i> +    debugs(33, 6, HERE);
</I>&gt;<i>
</I>&gt;<i> s/HERE/this/
</I>
Well, I use your suggestion for destructors and Amos for functions.
For Downloader probably the AsyncJob::id should used, or print nothing, 
the AsyncJob destructor prints a message in destructor.
Anyway.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    ClientHttpRequest *const http = new ClientHttpRequest(NULL);
</I>&gt;<i>
</I>&gt;<i> s/NULL/nullptr/ in new code
</I>
ok

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The scope of the following few comments overlap. They should be
</I>&gt;<i> considered together.
</I>&gt;<i>
</I>&gt;&gt;<i> +/// Used to hold and pass the required info and buffers to the
</I>&gt;&gt;<i> +/// clientStream callbacks
</I>&gt;&gt;<i> +class DownloaderContext: public RefCountable
</I>&gt;<i>
</I>&gt;<i> Why do we need a dedicated class with complex lifetime controls [instead
</I>&gt;<i> of using Downloader itself] for this? I am not saying this is wrong yet,
</I>&gt;<i> just asking why it is needed...
</I>
Two reasons:
  1) The existing related code for client_side and esi uses a context 
class, and I just follow the same scheme.
  2) The clientStream code requires a RefCountable class.
Because Downloader is an AsyncJob cbdata class and used as cbdata class 
I did not feel safe to use it with clientStream code.

The DownloaderContext class is build for clientStream and destroyed by 
clientStream code after finished. I think it is better to keep this class.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +class DownloaderContext: public RefCountable
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    CBDATA_CLASS(DownloaderContext);
</I>&gt;<i>
</I>&gt;<i> The combination of cbdata and RefCountable can be deadly as both
</I>&gt;<i> interfaces compete for object lifetime control without knowing about
</I>&gt;<i> each other. IIRC, a few of these ticking time bombs remain in Squid code
</I>&gt;<i> today, but here we are adding new code so, unless existing API require
</I>&gt;<i> this, we should avoid this combination.
</I>&gt;<i>
</I>&gt;<i> I assume that ClientStreams require cbdata; is RefCountable required by
</I>&gt;<i> some other existing API?
</I>
No requires RefCoutanble. I added cbdata definitions just for memory 
pools and because I was influenced by the similar code in client_side 
and esi code.
There is not any need for cbdata for this class. I replaced with 
MEMPROXY_CLASS

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +DownloaderContext::~DownloaderContext()
</I>&gt;&gt;<i> +{
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    if (http)
</I>&gt;&gt;<i> +        finished();
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +void
</I>&gt;&gt;<i> +DownloaderContext::finished()
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    delete http;
</I>&gt;&gt;<i> +    http = NULL;
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;&gt;<i> +void
</I>&gt;&gt;<i> +Downloader::downloadFinished()
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    debugs(33, 7, this);
</I>&gt;&gt;<i> +    context_-&gt;finished();
</I>&gt;<i>
</I>&gt;<i> If we do not need to delete &quot;http&quot; right when downloadFinished() is
</I>&gt;<i> called, then please merge finished() into the DownloaderContext
</I>
We need to delete http here.
Unfortunately holds (inderectly) depedencies to context_ object.
The ClientHttpRequest destructor will cause the clientStream objects to 
be released, and also release clientStream refcount to context_ object.

(Yes confusing and difficult to follow. Maybe a subject for a &quot;routing 
parent for ConnStateData/Esi/Downloader classes&quot; project?)

&gt;<i> destructor. Otherwise, perhaps add a source comment to document that we
</I>&gt;<i> cannot delay http destruction until refcounting deletes DownloaderContext.
</I>
I add a comment which try to describe the problem.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +     // Calling deleteThis method here to finish Downloader
</I>&gt;&gt;<i> +     // may result to squid crash.
</I>&gt;&gt;<i> +     // This method called by handleReply method which maybe called
</I>&gt;&gt;<i> +     // by ClientHttpRequest::doCallouts. The doCallouts after this object
</I>&gt;&gt;<i> +     // deleted, may operate on non valid objects.
</I>&gt;&gt;<i> +     // Schedule a fake call here just to force squid to delete this object.
</I>&gt;&gt;<i> +     CallJobHere(33, 7, CbcPointer&lt;Downloader&gt;(this), Downloader, downloadFinished);
</I>&gt;<i>
</I>&gt;<i> Does a single async call guarantee that doCallouts() will be able to
</I>&gt;<i> handle our destruction? What if doCallouts() schedules an async call as
</I>&gt;<i> well and comes back after our destruction? Is this a problem our patch
</I>&gt;<i> introduces or an existing/old doCallouts() flaw that we simply need to
</I>&gt;<i> work around, just like some other doCallouts() users?
</I>
It is not a problem added by this patch.
It is the doCallouts design. For a reason does not affect other 
subsystems. Probably it is hiden because of tricks like this I did.

This asyncCall will delay ClientHttpRequest destruction after the 
doCallouts will be finished. Else the ClientHttpRequest object will be 
destroyed while the doCallouts runs.

If doCallouts schedule a new callback this is normally checks if the 
ClientHttpRequest object is still not NULL.


&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    Downloader* downloader;
</I>&gt;<i>
</I>&gt;&gt;<i> +    if (!cbdataReferenceValid(context-&gt;downloader))
</I>&gt;&gt;<i> +        return;
</I>&gt;<i>
</I>&gt;<i> The check only makes sense if context-&gt;downloader is a CbcPointer or
</I>&gt;<i> equivalent, not a raw pointer. Otherwise, to reliably test downloader
</I>&gt;<i> validity you need the downloader pointer to be valid (i.e., either it
</I>&gt;<i> always works and the check is not needed or it may crash and the check
</I>&gt;<i> is broken).
</I>
I can not see the mistake here.
The cotnext-&gt;downloader is set as cbdataReference of cbdata. The pointer 
is always valid but the object maybe is not valid.

I replaced with CbcPointer&lt;Downloader&gt;


&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    /// Fake call used internally by Downloader.
</I>&gt;&gt;<i> +    void downloadFinished();
</I>&gt;<i>
</I>&gt;<i> This method/call is as real as any other call. We are forced to call it
</I>&gt;<i> asynchronously because of doCallouts() limitations, but it is not fake.
</I>&gt;<i> I suggest documenting it as &quot;delays destruction to protect doCallouts()&quot;
</I>&gt;<i> or something like that.
</I>
ok

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +     // Schedule a fake call here just to force squid to delete this object.
</I>&gt;<i>
</I>&gt;<i> Similarly, s/a fake/an async/
</I>
ok

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    debugs(33, 4, &quot;Received &quot; &lt;&lt; receivedData.length &lt;&lt;
</I>&gt;&gt;<i> +           &quot; object data, offset: &quot; &lt;&lt; receivedData.offset &lt;&lt;
</I>&gt;&gt;<i> +           &quot; error flag:&quot; &lt;&lt; receivedData.flags.error);
</I>&gt;<i>
</I>&gt;<i> Please move this debugging up, before we may exit the method.
</I>
ok

&gt;<i>
</I>&gt;<i> Also, should not we check receivedData.flags.error _before_ we interpret
</I>&gt;<i> any receivedData.length and such?
</I>
Well. My sense is that for a reason nobody checks for this flag.
I add a check for failed reply, we may add some other related checks 
here in the future.
For now looks enough.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    bool exceedSize = (existingContent &gt; -1 &amp;&amp; (size_t)existingContent &gt; MaxObjectSize) ||
</I>&gt;&gt;<i> +        ((object.length() + receivedData.length) &gt; MaxObjectSize);
</I>&gt;<i>
</I>&gt;<i> ...
</I>&gt;<i>
</I>&gt;&gt;<i> +    if (receivedData.length &gt; 0) {
</I>&gt;&gt;<i> +        object.append(receivedData.data, receivedData.length);
</I>&gt;&gt;<i> +        http-&gt;out.size += receivedData.length;
</I>&gt;&gt;<i> +        http-&gt;out.offset += receivedData.length;
</I>&gt;&gt;<i> +    }
</I>&gt;<i>
</I>&gt;<i> The combination does not make sense as far as non-positive
</I>&gt;<i> receivedData.length is concerned:
</I>&gt;<i>
</I>&gt;<i> * If receivedData.length cannot be negative, then the if-statement is
</I>&gt;<i> not needed.
</I>&gt;<i> * If receivedData.length can be negative, then it cannot be used in
</I>&gt;<i> exceedSize calculations without protection.
</I>
It can be zero.
I replaced &quot;if (recevedData.length &gt;0)&quot;  with a &quot;if (receivedData.length)&quot;


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: SQUID-112-fetch-certificates-t3.patch
Type: text/x-patch
Size: 74954 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160713/f611aeda/attachment-0001.bin">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160713/f611aeda/attachment-0001.bin</A>&gt;
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006171.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
	<LI>Next message: <A HREF="006232.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6231">[ date ]</a>
              <a href="thread.html#6231">[ thread ]</a>
              <a href="subject.html#6231">[ subject ]</a>
              <a href="author.html#6231">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
