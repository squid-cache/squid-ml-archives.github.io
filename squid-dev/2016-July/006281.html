<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fetch missing certificates
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fetch%20missing%20certificates&In-Reply-To=%3C57880B26.7060206%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006463.html">
   <LINK REL="Next"  HREF="006290.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fetch missing certificates</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fetch%20missing%20certificates&In-Reply-To=%3C57880B26.7060206%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Fetch missing certificates">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Jul 14 21:59:02 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006463.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
        <LI>Next message: <A HREF="006290.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6281">[ date ]</a>
              <a href="thread.html#6281">[ thread ]</a>
              <a href="subject.html#6281">[ subject ]</a>
              <a href="author.html#6281">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/13/2016 10:48 AM, Christos Tsantilas wrote:
&gt;<i> On 07/11/2016 10:13 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 07/11/2016 10:18 AM, Christos Tsantilas wrote:
</I>&gt;&gt;&gt;<i> +        SBuf object;
</I>&gt;&gt;&gt;<i> +        Http::StatusCode status;
</I>&gt;&gt;&gt;<i> +    };
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you can make Downloader::CbDialer print the status parameter and
</I>&gt;&gt;<i> perhaps, for successful downloads, the beginning of object parameter
</I>&gt;&gt;<i> (via Raw), please do so. See CallDialer::print().
</I>&gt;<i> 
</I>&gt;<i> I did not change anything here.
</I>&gt;<i> The PeerConnectorCertDownloaderDialer which is Downloader::CbDialer and
</I>&gt;<i> CallDialer kid implements the print method.
</I>
Ah, I see. CbDialer is called &quot;dialer&quot; but it actually is not!


&gt;<i> If you prefer we can make the Downloader::CbDialer a CallDialer kid and
</I>&gt;<i> implement the print method.
</I>
Yes, please.

The PeerConnectorCertDownloaderDialer::print() method also prints
peerConnector_ which Downloader::CbDialer cannot print, but
peerConnector_ is not a call parameter (it is a part of the call
destination), and the AsyncCall itself will print enough information to
figure the destination out.

Someday, we will add proper callback API by separating call parameters
from call dialers and using relevant C++11 features, but that difficult
work is outside this project scope.


&gt;&gt;&gt;<i> +/// Used to hold and pass the required info and buffers to the
</I>&gt;&gt;&gt;<i> +/// clientStream callbacks
</I>&gt;&gt;&gt;<i> +class DownloaderContext: public RefCountable
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why do we need a dedicated class with complex lifetime controls [instead
</I>&gt;&gt;<i> of using Downloader itself] for this? I am not saying this is wrong yet,
</I>&gt;&gt;<i> just asking why it is needed...
</I>
&gt;<i>  2) The clientStream code requires a RefCountable class.
</I>&gt;<i> Because Downloader is an AsyncJob cbdata class and used as cbdata class
</I>&gt;<i> I did not feel safe to use it with clientStream code.
</I>&gt;<i> 
</I>&gt;<i> The DownloaderContext class is build for clientStream and destroyed by
</I>&gt;<i> clientStream code after finished. I think it is better to keep this class.
</I>
Understood. It looks like ClientStream APIs leaves us no choice here.
Your other changes to remove cbdata protection from DownloaderContext
address my concern here (to the extent it can be addressed given the
ClientStream API we have to use).



&gt;&gt;&gt;<i> +    Downloader* downloader;
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +    if (!cbdataReferenceValid(context-&gt;downloader))
</I>&gt;&gt;&gt;<i> +        return;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The check only makes sense if context-&gt;downloader is a CbcPointer or
</I>&gt;&gt;<i> equivalent, not a raw pointer. Otherwise, to reliably test downloader
</I>&gt;&gt;<i> validity you need the downloader pointer to be valid (i.e., either it
</I>&gt;&gt;<i> always works and the check is not needed or it may crash and the check
</I>&gt;&gt;<i> is broken).
</I>&gt;<i> 
</I>&gt;<i> I can not see the mistake here.
</I>&gt;<i> The cotnext-&gt;downloader is set as cbdataReference of cbdata.
</I>
... but its type was (and it was dereferenced as) a Downloader pointer.
This works only for simple cases where both &quot;downloader-&gt;toCbdata()&quot; and
&quot;downloader&quot; point to the same memory. With multiple inheritance, that
may not be the case. I bet your code was working fine, but innocent
changes in the Downloader-related class hierarchy like adding a
BackgroundDownloader child could trigger hard-to-find cbdata bugs in
your code. This is exactly why we added CbcPointer.

The &quot;either it always works and check is not needed&quot; part of my own
comment was incorrect. Sorry. I should have said, &quot;either you are lucky
that context-&gt;downloader points to cbdata&quot; instead. The check is always
needed, of course.

Your CbcPointer changes resolved this issue.


&gt;&gt;&gt;<i> +    bool exceedSize = (existingContent &gt; -1 &amp;&amp;
</I>&gt;&gt;&gt;<i> (size_t)existingContent &gt; MaxObjectSize) ||
</I>&gt;&gt;&gt;<i> +        ((object.length() + receivedData.length) &gt; MaxObjectSize);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ...
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +    if (receivedData.length &gt; 0) {
</I>&gt;&gt;&gt;<i> +        object.append(receivedData.data, receivedData.length);
</I>&gt;&gt;&gt;<i> +        http-&gt;out.size += receivedData.length;
</I>&gt;&gt;&gt;<i> +        http-&gt;out.offset += receivedData.length;
</I>&gt;&gt;&gt;<i> +    }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The combination does not make sense as far as non-positive
</I>&gt;&gt;<i> receivedData.length is concerned:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * If receivedData.length cannot be negative, then the if-statement is
</I>&gt;&gt;<i> not needed.
</I>&gt;&gt;<i> * If receivedData.length can be negative, then it cannot be used in
</I>&gt;&gt;<i> exceedSize calculations without protection.
</I>

&gt;<i> It can be zero.
</I>&gt;<i> I replaced &quot;if (recevedData.length &gt;0)&quot;  with a &quot;if (receivedData.length)&quot;
</I>
which I recommend removing as a [minor] waste of CPU cycles. The code
you are protecting should handle _rare_ zero receivedData.length values
just fine AFAICT. This is not a big deal, of course.


Personally, I do not plan to participate in another review round. I am
sure you can handle the above changes and address Amos' comments without it.


Thank you,

Alex.

</PRE>


























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006463.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
	<LI>Next message: <A HREF="006290.html">[squid-dev] [PATCH] Fetch missing certificates
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6281">[ date ]</a>
              <a href="thread.html#6281">[ thread ]</a>
              <a href="subject.html#6281">[ subject ]</a>
              <a href="author.html#6281">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
