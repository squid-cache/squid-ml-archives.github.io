<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Broken trunk after r14735, r14726
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Broken%20trunk%20after%20r14735%2C%20r14726&In-Reply-To=%3C578FA0FD.7050103%40chtsanti.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006373.html">
   <LINK REL="Next"  HREF="006392.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Broken trunk after r14735, r14726</H1>
    <B>Christos Tsantilas</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Broken%20trunk%20after%20r14735%2C%20r14726&In-Reply-To=%3C578FA0FD.7050103%40chtsanti.net%3E"
       TITLE="[squid-dev] Broken trunk after r14735, r14726">christos at chtsanti.net
       </A><BR>
    <I>Wed Jul 20 16:04:13 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006373.html">[squid-dev] Broken trunk after r14735, r14726
</A></li>
        <LI>Next message: <A HREF="006392.html">[squid-dev] Broken trunk after r14735, r14726
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6388">[ date ]</a>
              <a href="thread.html#6388">[ thread ]</a>
              <a href="subject.html#6388">[ subject ]</a>
              <a href="author.html#6388">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/19/2016 09:52 AM, Amos Jeffries wrote:
&gt;<i> On 18/07/2016 11:12 p.m., Christos Tsantilas wrote:
</I>&gt;&gt;<i> On 07/16/2016 03:56 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 16/07/2016 7:02 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> Hello,
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>       There are two more recent changes that broke trunk:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> * After r14735 (Replaced TidyPointer with std::unique_ptr), Squid cannot
</I>&gt;&gt;&gt;&gt;<i> start due to an &quot;std::bad_function_call&quot; exception.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> * After r14726 (GnuTLS: support for TLS session resume): Squid segfaults
</I>&gt;&gt;&gt;&gt;<i> when attempting to connect to a Secure ICAP service. Official Squid
</I>&gt;&gt;&gt;&gt;<i> v4.0.12 suffers from this bug.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Stack traces from both crashes are quoted at the end of this email.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Please fix these regressions or undo the changes that created or exposed
</I>&gt;&gt;&gt;&gt;<i> them.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &lt;snip&gt;
</I>&gt;&gt;&gt;&gt;<i> * segfault when attempting to connect to a Secure ICAP REQMOD service
</I>&gt;&gt;&gt;&gt;<i> (tested with r14726, r14734):
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Does this patch fix the session issue ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> === modified file 'src/security/Session.cc'
</I>&gt;&gt;&gt;<i> --- src/security/Session.cc     2016-07-07 19:03:02 +0000
</I>&gt;&gt;&gt;<i> +++ src/security/Session.cc     2016-07-16 12:43:38 +0000
</I>&gt;&gt;&gt;<i> @@ -53,7 +53,7 @@
</I>&gt;&gt;&gt;<i>    void
</I>&gt;&gt;&gt;<i>    Security::SetSessionResumeData(const Security::SessionPtr &amp;s, const
</I>&gt;&gt;&gt;<i> Security::SessionStatePointer &amp;data)
</I>&gt;&gt;&gt;<i>    {
</I>&gt;&gt;&gt;<i> -    if (s) {
</I>&gt;&gt;&gt;<i> +    if (data) {
</I>&gt;&gt;&gt;<i>    #if USE_OPENSSL
</I>&gt;&gt;&gt;<i>            (void)SSL_set_session(s, data.get());
</I>&gt;&gt;&gt;<i>    #elif USE_GNUTLS
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'm a little worried about the code calling SetSessionResumeData.
</I>&gt;&gt;&gt;<i> OpenSSL documentation states:
</I>&gt;&gt;&gt;<i>     &quot;If there is already a session set inside ssl (because it was set with
</I>&gt;&gt;&gt;<i> SSL_set_session() before or because the same ssl was already used for a
</I>&gt;&gt;&gt;<i> connection), SSL_SESSION_free() will be called for that session.&quot;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But our SetSessionResumeData() is called after setting up the sessions
</I>&gt;&gt;&gt;<i> host data, etc. So I'm thinking all that setup in
</I>&gt;&gt;&gt;<i> Ssl::BlindPeerConnector::initializeTls() may be thrown away by the
</I>&gt;&gt;&gt;<i> resume action being called.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Squid crashes at the first TLS connection trying to establish to the
</I>&gt;&gt;<i> ICAP server.  There is not any session to resume so the SSL session
</I>&gt;&gt;<i> related methods should not called at all.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is a strange crash. Is it a corrupted SSL object?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I must say that I am worrying a lot for all of these changes.
</I>&gt;&gt;<i> It is very difficult for me to follow them, and already I have
</I>&gt;&gt;<i> difficulties to read and debug squid openSSL relate code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We are using our own naming scheme for openSSL structures, eg
</I>&gt;&gt;<i> &quot;Security::SessionPtr&quot; instead of &quot;SSL *&quot; or
</I>&gt;&gt;<i> &quot;Security::SessionStatePointer&quot; instead of &quot;SSL_SESSION *&quot; and this is
</I>&gt;&gt;<i> make it very difficult to follow Squid/openSSL code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is difficult to read an example openSSL code and trying convert it to
</I>&gt;&gt;<i> squid, or reading a reference implementation and trying check against
</I>&gt;&gt;<i> squid code. Someone is obligated to search for definitions and
</I>&gt;&gt;<i> equivalents types all the time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I have not ever study for a good way to support both GnuTLS and openSSL
</I>&gt;&gt;<i> for squid, to know the problems,  but probably I would start to
</I>&gt;&gt;<i> implement openSSLAcceptor/gnuTlsAcceptor and
</I>&gt;&gt;<i> openSSLPeerConnector/gnuTLSPeerConnector classes.
</I>&gt;&gt;<i> Internally gnuTLS and openSSL should use their own types. This is will
</I>&gt;&gt;<i> help current and future squid developers.
</I>&gt;<i>
</I>&gt;<i> That is indeed where I started, and what I started doing. It turns out
</I>&gt;<i> we then have to maintain feature compatibility in those two relatively
</I>&gt;<i> high-level classes. Which are internally designed and implemented in
</I>&gt;<i> different ways. Thats a bit tricky to start with, but seemed reasonable.
</I>&gt;<i>    Then there is the killer fact that to do ssl-bump those classes are
</I>&gt;<i> all using fd_table[].ssl things shared between Server and Client and
</I>&gt;<i> Icap and Ecap 'sides' (head =&gt; meet brick wall, doh!).
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am just expressing my worries here, I do not want to impose anything
</I>&gt;&gt;<i> and if there was a related discussion in squid-dev, sorry that I do not
</I>&gt;&gt;<i> participate and I did not express my concerns earlier.
</I>&gt;<i>
</I>&gt;<i> As Alex noted, there has not been any detailed discussion. Just partial
</I>&gt;<i> coverage of some details during the occasional patch reviews. And it is
</I>&gt;<i> good to have opinions voiced/written.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As the one most recently looking at the ways to do combined API. I'm
</I>&gt;<i> just as frustrated as you. For the same reasons. Though in the reverse
</I>&gt;<i> direction. It has been quite hard to look at nice 3-4 line GnuTLS
</I>&gt;<i> examples and then trying to figure out a) what 10-20 OpenSSL calls are
</I>&gt;<i> used to do the equivalent, and even more annoyingly b) where those
</I>&gt;<i> OpenSSL calls are spinkled around the Squid codebase.
</I>&gt;<i>
</I>&gt;<i> Regarding (b); TBH, I'm quite impressed you can translate from the
</I>&gt;<i> OpenSSL examples to the Squid use of OpenSSL.
</I>
It is already difficult, squid openSSL related code is not  trivial, we 
should not make it worst.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The choices we have for combining basically come down to four ways:
</I>&gt;<i>
</I>&gt;<i> 1) implementing everything twice. The way OpenSSL is spreading its calls
</I>&gt;<i> all over the place that means the entire SSL-Bump, HTTPS receiving,
</I>&gt;<i> sending, BIO, and Comm I/O layers and FD socket handling.
</I>
About SSL-Bump, already there is a try to move out of openSSL huge 
parts. An example is the SSL messages parser.

You need to implement HTTPS receiving.sending, BIO, Comm I/O layers and 
fd socket twice. You can not avoid it.

&gt;<i>
</I>&gt;<i> A *huge* amount of duplication. Almost everything that stores OpenSSL
</I>&gt;<i> raw pointers today would need duplicating to work differently for
</I>&gt;<i> GnuTLS. Just because the pointer usage is different. Sometimes only in
</I>&gt;<i> the meaning of 0 return values - but thats enough.
</I>
Exactly.

&gt;<i> 2) picking one library API and writing our own compatibility layer for
</I>&gt;<i> other libraries using that API.
</I>&gt;<i>
</I>&gt;<i> Unfortunately, there is a history of people trying this. The GnuTLS
</I>&gt;<i> compatibility openssl.h header is lacking many OpenSSL API symbols for
</I>&gt;<i> good reasons which boil down to intentional major design differences in
</I>&gt;<i> the libraries:
</I>&gt;<i>   a) OpenSSL exposes these annoying but useful locking references. GnuTLS
</I>&gt;<i> hides any locking from the callers - leaving us unsure if something is
</I>&gt;<i> referenced or copied, but safe to use any pointers we're given.
</I>&gt;<i>   b) OpenSSL uses N more API calls to explicitly do all sorts of things,
</I>&gt;<i> with ordering dependencies IIRC - where GnuTLS uses far fewer calls.
</I>&gt;<i>
</I>&gt;<i> Sadly the Squid logics are sometimes heavily leveraging the locking
</I>&gt;<i> behaviour of OpenSSL to pass info from one context to another, by
</I>&gt;<i> updating shared structures.
</I>
This is has to do with internal OpenSSL operation. This is how this API 
works.

All of the above problems you are describing show me how difficult and 
maybe wrong is to try implement GnuTLS having in your mind the existing 
OpenSSL implementation.
The two SDKs although have similarities are different in philosophy.

Why do we need common types for both SDKs?

The only type needed by squid for openSSL is the &quot;SSL *&quot; which is stored 
inside fde class. And the gnutls_session_int for gnutls. These are 
should be enough
(maybe with some other like the certificate errors.).

Squid should use SSL or gnutls_session_int and pass it to openSSL or 
gnuTLS  related classes and should not need to know about other internal 
OpenSSL or GnuTLS structures.

Recently we split the PeerConnector classes from FwdState class, the 
FwdState now does not have strong dependencies to openSSL.

We can do the same for ConnStateData class.

If you decide to implement  NEW GnuTls PeerConnector class, without 
sslbump for the beggining, it is easy. The PeerConnector class is about 
500 lines of code and the BlindPeerConnector other 100 lines.

And after this is ready the common code like the certificates validation 
(150 lines of code) can be moved into a parent class.

But trying to fit GnuTLS and openSSL into the same PeerConnector class 
will fail and will make the code complex.

The SSLBump also is still under heavy development.
Again here the PeekingPeerConnector is about 400 lines of code. Is this 
code we are worrying that it will be duplicated?
Because most of the other SSL related code (~6000 lines of code) MUST 
reimplemented for gnutls.

Recently we implemented our own Handshake messages parser, we are not 
relying on openSSL for detecting SSL features and basic errors. The *Bio 
classes are very simple now, they just do buffering.
This is will help a future GnuTLS implementation too.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 3) sprinkling #if conditions like candy through the whole codebase.
</I>&gt;<i>
</I>&gt;<i> (Er, yuck). We have too much of that already for OpenSSL.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 4) designing our code to use an abstraction API that renames all the
</I>&gt;<i> library structures and functions to some thing we understand easier **.
</I>&gt;<i>
</I>&gt;<i> Still a lot of code re-writing, and even more re-arranging so the
</I>&gt;<i> library call(s) themselves happen away from the huge number of
</I>&gt;<i> components mentioned in (1). But doable within a decade (maybe).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> So, I've gone with this (4) and taking Alex suggestions on how to
</I>&gt;<i> abstract better as I go.
</I>
I believe that that the PeerConnector is a part of this API.
It is an AsyncJob which when finishes calls a callback function.


&gt;<i>
</I>&gt;<i> If you think its a good way to go, we might be able to use the reverse
</I>&gt;<i> compatibility direction for (3). ie. Using GnuTLS symbol names and
</I>&gt;<i> implementing them for OpenSSL API. But that wont help much when it comes
</I>&gt;<i> to supporting NSS for Fedora/RHEL/CentOS, PolarSSL (for SuSE? I forget),
</I>&gt;<i> or Crypto for MacOS.
</I>
On server side you do not need to use a lot of &quot;#if&quot;.

This is required for ConnStateData. But for ConnStateData we should go 
like we did for FwdState. We should implement a new class and put here 
the SSL related code.

I do not know the form of this class. Maybe we need an TlsConnStateData 
kid of ConnStateData, or maybe we need to implement TlsAcceptor classes.

Then this class should be implemented for openSSL and for gnuTls.

I know it is not easy.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ** YMMV on easier. I fully sympathize with the examples-vs-abstraction
</I>&gt;<i> problem. It might help if we communicated a bit better on that so it
</I>&gt;<i> turned out to be something you understand as well, not just my ideas.
</I>&gt;<i>   I had the idea that you were flooded with SSL-Bump problems? has that
</I>&gt;<i> situation eased?
</I>
The new naming scheme for SSL structures disrupted me, looks to me 
difficult to use it and adds an overhead.
I am just worry.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Amos
</I>&gt;<i>
</I></PRE>
























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006373.html">[squid-dev] Broken trunk after r14735, r14726
</A></li>
	<LI>Next message: <A HREF="006392.html">[squid-dev] Broken trunk after r14735, r14726
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6388">[ date ]</a>
              <a href="thread.html#6388">[ thread ]</a>
              <a href="subject.html#6388">[ subject ]</a>
              <a href="author.html#6388">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
