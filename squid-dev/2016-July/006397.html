<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] [PREVIEW] LockingPointer round 3.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20%5BPREVIEW%5D%20LockingPointer%20round%203.&In-Reply-To=%3C5790ED76.7040403%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006396.html">
   <LINK REL="Next"  HREF="006362.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] [PREVIEW] LockingPointer round 3.</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20%5BPREVIEW%5D%20LockingPointer%20round%203.&In-Reply-To=%3C5790ED76.7040403%40measurement-factory.com%3E"
       TITLE="[squid-dev] [RFC] [PREVIEW] LockingPointer round 3.">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Jul 21 15:42:46 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006396.html">[squid-dev] [RFC] [PREVIEW] LockingPointer round 3.
</A></li>
        <LI>Next message: <A HREF="006362.html">[squid-dev] Broken trunk after r14735, r14726
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6397">[ date ]</a>
              <a href="thread.html#6397">[ thread ]</a>
              <a href="subject.html#6397">[ subject ]</a>
              <a href="author.html#6397">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/21/2016 07:58 AM, Amos Jeffries wrote:
&gt;<i>      void resetWithoutLocking(T *t) {
</I>&gt;<i> +#if USE_OPENSSL
</I>&gt;<i> +        assert(!t || t-&gt;references &gt; 0);
</I>&gt;<i> +        assert(!raw || raw-&gt;references &gt; 0);
</I>&gt;<i> +        if (raw &amp;&amp; t == raw) {
</I>&gt;<i> +            assert(raw-&gt;references &gt; 1); // us plus caller locks
</I>&gt;<i> +        }
</I>&gt;<i> +#endif
</I>&gt;<i>          unlock();
</I>&gt;<i>          raw = t;
</I>&gt;<i>      }
</I>
The first assert() is correct.

The second assert() belongs to unlock() where it is already present.
Remove it from here.

The third assert() comment implies that self-reset is not supported (and
will assert) in some cases, but other self-reset cases are fine. If that
is what you are proposing, you should be explicit about it. Needless to
say, I am against such inconsistent behavior and recommend removing that
third assert.


&gt;<i> If you are referring to the self-reset assert(t != raw) and so adamant
</I>&gt;<i> that is right
</I>
I spent many hours discussing why such assert would be wrong [when the
other method has the opposite do-nothing implementation]. And now you
think I may consider it being correct and even call me adamant. Sigh.


&gt;<i> OpenSSL 1.1.0 is making a lot of
</I>&gt;<i> things opaque and that includes the reference counting. We may not be
</I>&gt;<i> able to access t-&gt;references for long.
</I>
Which is why it is probably a good idea to add MustBeLocked(const T*) or
AssertIfUnlocked(const T*) or similar static method (that does nothing
if it cannot check) instead of sprinkling code with #ifdefs and explicit
accesses to references. If the asserts above are fixed, one such method
would suffice AFAICT.



&gt;&gt;&gt;<i> // XXX: why not set fd_table if that add() succeeded ?
</I>
&gt;&gt;<i> The simple answer is that if you set fd_table after cache add()ing
</I>&gt;&gt;<i> succeeded, then both fd_table and the cache will delete the same
</I>&gt;&gt;<i> pointer, crashing Squid. Note that ctx is a raw pointer [to a smart
</I>&gt;&gt;<i> pointer]. However, I doubt this is the correct/best answer.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AFAICT, the poor-quality comments in the original code were supposed to
</I>&gt;&gt;<i> answer that question like this: The _only_ reason we add ctx to the
</I>&gt;&gt;<i> table is so that it gets eventually destroyed. The context object is not
</I>&gt;&gt;<i> needed in the table and should not be accessed from there. If we
</I>&gt;&gt;<i> successfully add ctx to the cache, then the cache becomes responsible
</I>&gt;&gt;<i> for its destruction and we do not need to add it to the table.
</I>

&gt;<i> So that means the fd_table member can be set *always*
</I>
Probably, but this is not my area of the expertise.


&gt;<i> On the other hand. I suspect that the use fd_table is being put to is
</I>&gt;<i> better served by one of the MasterXaction / AccessLogEntry /
</I>&gt;<i> ConnStateData objects relevant to the transaction using that context.
</I>
Not MasterXaction or AccessLogEntry -- the context is specific to the
connection, not transaction. ConnStateData is a good candidate but you
may find it difficult to share with those who need the context.

Pretty much any use of fd_table outside Comm code is a bug, but fixing
that bug is difficult.


&gt;<i> +            // fd_table is now responsible for reference counting of the pointer.
</I>
This comment is misleading. Both fd_table and the cache (if any) are
responsible. IMO, there is no need to retell what the code already
clearly says so I recommend removing that comment.


&gt;<i> +                    delete tmp; // dont leak tmp on failures
</I>
I recommend deleting that comment. It is misleading (more than just tmp
will leak without that delete) and misspelled. You may want to replace
it with &quot;XXX: leaks on exceptions&quot; or, better, use std::unique_ptr (and
release() it on add() success) to prevent those leaks.

&gt;<i> +    /**
</I>&gt;<i> +     * Construct directly from a raw pointer is forbidden.
</I>
s/Construct/Constructing/ or s/Construct/Construction/


&gt;<i> +     * Use the appropriate reset method instead.
</I>
This does not make sense -- if I need a _constructor_ I cannot use a
regular method.


&gt;<i> +    explicit LockingPointer(T *) = delete;
</I>
Did you mean to prohibit all from-pointer construction or just the
explicit one? If it is the former, I suggest removing &quot;explicit&quot;.


&gt;<i> How about?
</I>&gt;<i> 
</I>&gt;<i>   static SelfType&amp;&amp; MakeFromLockedOpenSslPointer(T *t) {
</I>&gt;<i>       SelfType out;
</I>&gt;<i>       out.resetWithoutLocking(t);
</I>&gt;<i>       return std::move(out);
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Theres something I'm not quite understanding going on with the
</I>&gt;<i> return-by-value for template types giving me compiler errors. Thus the
</I>&gt;<i> std::move, it seems to build but I'm not sure if it will run properly at
</I>&gt;<i> all.
</I>
I strongly recommend against writing optimization code you do not fully
understand. Add a simple static method that returns a SelfType instead.

This particular method clearly has nothing to do with OpenSsl. Using
OpenSsl in its name but calling it in GnuTLS-compiled code is very
confusing IMO. I recommend removing OpenSsl letters from its name. If
you want to restrict this method use to OpenSSL builds (for now), then
surround it with #ifdefs and document why others should not use it.


The word &quot;Make&quot; does not seem to add any value so I recommend removing
it from the method name:
   CrlPointer::FromLockedOpenSslPointer() is as clear as
   CrlPointer::MakeFromLockedOpenSslPointer()


&gt;<i> identifying this ambiguous use was the point of
</I>&gt;<i> the comment experiment.
</I>
It looks like the experiment is still ongoing. If not, please remove
stale experimental comments.


Thank you,

Alex.

</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006396.html">[squid-dev] [RFC] [PREVIEW] LockingPointer round 3.
</A></li>
	<LI>Next message: <A HREF="006362.html">[squid-dev] Broken trunk after r14735, r14726
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6397">[ date ]</a>
              <a href="thread.html#6397">[ thread ]</a>
              <a href="subject.html#6397">[ subject ]</a>
              <a href="author.html#6397">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
