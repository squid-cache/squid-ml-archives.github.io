<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Deletors for std::unique_ptr WAS: Re: Broken trunk after r14735
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Deletors%20for%20std%3A%3Aunique_ptr%20WAS%3A%20Re%3A%0A%20Broken%20trunk%20after%20r14735&In-Reply-To=%3C7feeaa27-1378-04ab-d21d-aaeafebd9499%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006459.html">
   <LINK REL="Next"  HREF="006462.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Deletors for std::unique_ptr WAS: Re: Broken trunk after r14735</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Deletors%20for%20std%3A%3Aunique_ptr%20WAS%3A%20Re%3A%0A%20Broken%20trunk%20after%20r14735&In-Reply-To=%3C7feeaa27-1378-04ab-d21d-aaeafebd9499%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Deletors for std::unique_ptr WAS: Re: Broken trunk after r14735">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jul 30 13:03:00 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006459.html">[squid-dev] [PATCH] Deletors for std::unique_ptr fixing r14735
</A></li>
        <LI>Next message: <A HREF="006462.html">[squid-dev] [PATCH] Deletors for std::unique_ptr WAS: Re: Broken trunk after r14735
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6461">[ date ]</a>
              <a href="thread.html#6461">[ thread ]</a>
              <a href="subject.html#6461">[ subject ]</a>
              <a href="author.html#6461">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 30/07/2016 6:29 a.m., Alex Rousskov wrote:
&gt;<i> On 07/29/2016 09:27 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> typedef std::unique_ptr&lt;BIO, std::function&lt;decltype(BIO_free)&gt;&gt; BIO_Pointer;
</I>&gt;<i> 
</I>&gt;&gt;<i> I got this config parsing crash replicated here and tried a dozen or so
</I>&gt;&gt;<i> combinations. It does seem to keep coming back to my earlier approach of
</I>&gt;&gt;<i> using per-type Functors as the most reliable solution.
</I>&gt;<i> 
</I>&gt;<i> AFAICT, this is not a question of reliability, and we should not be
</I>&gt;<i> fixing this by trying various combination of typedef characters until we
</I>&gt;<i> find one that does not immediately crash Squid. We should figure out
</I>&gt;<i> _why_ trunk code does not work (and then fix it accordingly).
</I>
Please clear your head of the notion that I'm tying things bindly or
randomly. As mentioned in IRC the other day I do know exactly what is
going wrong. Your outline in the paragraphs below is correct.

The difficulty as I mentioned already has been in finding a working
solution that is easily used without risking future bugs from people
misunderstanding the use of these Pointers. That is what I meant by
&quot;reliable&quot;. There are several different implementations that work and
are correct, but with varying amounts of complicated-looking/confusing
syntax needed.

I'm using the scientific method here. Reading the C++ documentation to
form hypothesis about the behaviour that will happen with the various
ways of using unique_ptr. Then performing an explicit and planned
experiment to (dis)prove it - including ways I know wont work just to
prove that knowledge correct.

By relibility above I was referring to ease of use with least future
bugs resulting from others not knowing the tricky details.

You have previously assured me[1] that using std::function&lt;declype(X)&gt;
was the way to go and would allow removal of the macros. That usage has
turned out to cause the null derefernce. For the reasons you outline
below. Those problem results should have been obvious, but hindsight is
clearer than foresight.

&gt;<i> 
</I>&gt;<i> The trunk code cannot work because we are telling std::unique_ptr that
</I>&gt;<i> our Deleter is std::function&lt;decltype(BIO_free)&gt;. What is
</I>&gt;<i> std::function&lt;decltype(BIO_free)&gt;? It is an std::function class. An
</I>&gt;<i> instance of that class can call any function that has the same
</I>&gt;<i> declaration as BIO_free. So, which function should our BIO_Pointer call?
</I>&gt;<i> We did not specify that! Thus, we get a bad_function_call exception when
</I>&gt;<i> unique_ptr object is trying to destroy its target pointer [using a
</I>&gt;<i> missing/unspecified deleter function].
</I>&gt;<i> 
</I>&gt;<i> In other words, trunk code is equivalent to this pseudo code:
</I>&gt;<i> 
</I>&gt;<i>   BIO *bio = ...;
</I>&gt;<i>   std::function&lt;int(BIO*)&gt; fun = NULL;
</I>&gt;<i>   fun(bio); // throws -- cannot call an unspecified function
</I>&gt;<i> 
</I>
Exactly. You understand the problem with the solution you previously
convinced me to implement.

&gt;<i> What we should be writing is this:
</I>&gt;<i> 
</I>&gt;<i>   BIO *bio = ...;
</I>&gt;<i>   std::function&lt;int(BIO*)&gt; fun = BIO_free;
</I>&gt;<i>   fun(bio); // frees bio
</I>&gt;<i> 
</I>&gt;<i> Since std::function supports default construction, the &quot;= NULL&quot; part is
</I>&gt;<i> implicit -- we do not need to pass NULL to std::unique for the default
</I>&gt;<i> std::function constructor to construct an empty/non-callable functor.
</I>&gt;<i> 
</I>
Exactly. Though actual implementation needs to be different. Repeating
that code setup every time we want to make a local variable or class
member would be terribly annoying.

&gt;<i> 
</I>&gt;&gt;<i> We could also wrap the std::unique_ptr definition parts inside the macro
</I>&gt;&gt;<i> for much smaller visible code. But that would prevent re-use of the
</I>&gt;&gt;<i> macro for other plain Functor definitions (not that anything else is
</I>&gt;&gt;<i> using it).
</I>&gt;<i> 
</I>&gt;<i> If possible, we should avoid macros and should learn how to use C++11
</I>&gt;<i> correctly. In general, it makes little sense to suffer the pains of
</I>&gt;<i> switching to C++11 and then use macros for things C++11 is supposed to
</I>&gt;<i> provide or support natively.
</I>&gt;<i> 
</I>
We have been in agreement on that for a long time. Thats why you so
easily convinced me to go with std::function in the first place.

Using C++11 &quot;correctly&quot; for this resulting bug involves choosing between
several varyingly complicated ways to typedef the Pointer, or to declare
instances of it.


&gt;<i> However, in this specific case, some macros may be unavoidable or even a
</I>&gt;<i> good idea because we are also dealing with C libraries that we cannot
</I>&gt;<i> convert to C++11. Please give me a few hours to think whether there is a
</I>&gt;<i> macro-free solution available.
</I>
Sure. The documentation indicates that we could use a template Functor
which expands instead of a Macro expansion. But gives no examples and my
memory of expanding template parameters dependent on other template
parameters was failing me yesterday.

I see from your followup posts that you found the two ways to go there.
I'm running my own tests on the resulting patch using the simple
template instead of macro and will apply that if it passes for me as well.


Amos

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006459.html">[squid-dev] [PATCH] Deletors for std::unique_ptr fixing r14735
</A></li>
	<LI>Next message: <A HREF="006462.html">[squid-dev] [PATCH] Deletors for std::unique_ptr WAS: Re: Broken trunk after r14735
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6461">[ date ]</a>
              <a href="thread.html#6461">[ thread ]</a>
              <a href="subject.html#6461">[ subject ]</a>
              <a href="author.html#6461">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
