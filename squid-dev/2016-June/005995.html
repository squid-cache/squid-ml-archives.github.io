<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Better support for unknown URL schemes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Better%20support%20for%20unknown%20URL%20schemes&In-Reply-To=%3Ce2df36b7-c6bf-6363-4b40-86dcb2466d44%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005993.html">
   <LINK REL="Next"  HREF="005997.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Better support for unknown URL schemes</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Better%20support%20for%20unknown%20URL%20schemes&In-Reply-To=%3Ce2df36b7-c6bf-6363-4b40-86dcb2466d44%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Better support for unknown URL schemes">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Jun 15 11:43:26 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005993.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
        <LI>Next message: <A HREF="005997.html">[squid-dev] [PATCH] Do not hide important/critical messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5995">[ date ]</a>
              <a href="thread.html#5995">[ thread ]</a>
              <a href="subject.html#5995">[ subject ]</a>
              <a href="author.html#5995">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 16/03/2016 5:52 a.m., Alex Rousskov wrote:
&gt;<i> On 03/15/2016 09:36 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> Squid already contains AnyP::PROTO_UNKNOWN support for unknown protocols
</I>&gt;&gt;<i> but currently does not preserve the actual string value received for them.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This adds a textual representation ('image') to the UriScheme object to
</I>&gt;&gt;<i> fill that gap and ensure that all URL representatinos (ie cache keys,
</I>&gt;&gt;<i> logs and outgoing messages) are generated with the scheme string as it
</I>&gt;&gt;<i> was received.
</I>&gt;<i> 
</I>&gt;<i> Preserving textual representation is the right thing to do, but the
</I>&gt;<i> implementation itself needs a lot more work IMO.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>      /// convert the URL scheme to that given
</I>&gt;&gt;<i>      void setScheme(const AnyP::ProtocolType &amp;p) {scheme_=p; touch();}
</I>&gt;&gt;<i> +    void setSchemeImage(const char *str) {scheme_.setImage(str); touch();}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The parameter type should be changed instead. Yes, that will require
</I>&gt;<i> more changes, but those changes are essential to properly support
</I>&gt;<i> foreign protocol names. Without those changes, you are creating an API
</I>&gt;<i> bug in addition to adding a useful feature.
</I>&gt;<i> 
</I>&gt;<i> We (mostly you) have already done similar work for foreign HTTP request
</I>&gt;<i> methods. This is similar -- UriScheme should be used nearly everywhere
</I>&gt;<i> (instead of ProtocolType that does not carry enough information). It
</I>&gt;<i> could be argued that the UriScheme class itself should be renamed to
</I>&gt;<i> something like Protocol, but I do not want to argue about that.
</I>&gt;<i> 
</I>
There are two distinct layers involved. I'm sure you know this, but I'll
reiterate for the sake of clarity.

- ProtocolType is the transfer or transport protocol type.
- UriScheme is the URL/URI/URN scheme label.

They have been conflated in the past and are still in the difficult
process of de-tangling. The URI scheme implies a protocol, but is not
one in and of itself. For example HTTP ProtocolType can be used to
transfer <A HREF="ftp://">ftp://</A> scheme URLs, etc.

Untangling them is happening, but not part of the scope of this patch
except to the point that the URL image() is being made to no longer
generate directly from the ProtocolType value in most cases.

&gt;<i> 
</I>&gt;&gt;<i> +    /// Sets the string representation of this scheme.
</I>&gt;&gt;<i> +    /// Only needed if the scheme type is PROTO_UNKNOWN.
</I>&gt;&gt;<i> +    void setImage(const char *str) {assert(theScheme_ == AnyP::PROTO_UNKNOWN); schemeImage_ = str;}
</I>&gt;<i> 
</I>&gt;<i> This method should be a constructor.
</I>
Done. Note that this has side effects on HttpRequest construction and
requires move semantics to be added to UriScheme. Not a problem exactly,
but scope creep.

&gt;<i> 
</I>&gt;&gt;<i>  char const *
</I>&gt;&gt;<i>  AnyP::UriScheme::c_str() const
</I>&gt;&gt;<i>  {
</I>&gt;<i> 
</I>&gt;<i> This method should be replaced with AnyP::UriScheme::image() returning SBuf.
</I>&gt;<i> 
</I>
Done.

&gt;<i> 
</I>&gt;&gt;<i> +    if (!schemeImage_.isEmpty())
</I>&gt;&gt;<i> +        return schemeImage_.c_str();
</I>&gt;&gt;<i> +
</I>&gt;<i> 
</I>&gt;<i> Why are we not lowering the case of a foreign protocol image if we are
</I>&gt;<i> lowering the case of standard protocol images below? Either both should
</I>&gt;<i> be lowered or there should be a source code comment explaining the
</I>&gt;<i> discrepancy.
</I>
Transfer Protocol type and Scheme labels are both case-sensitive (and
differently cased).

So when using an externally supplied scheme label we must take what was
given.

But, since our registered ProtocolType and its ProtocolType_str is
actually the message transfer protocol label (upper case) we need to
lower the case of ProtocolType_str when using it as implicit URI scheme
for one of the registered/known scheme names.


&gt;<i> 
</I>&gt;<i> If both should be lowered, the lowering should be done in the
</I>&gt;<i> constructor to avoid lowering the same string multiple times.
</I>&gt;<i> 
</I>
Trunk is what lowers the string multiple times (on each display of the
URL, including debugs). These patches make that happen only once and
stores the lowered result in the scheme image_ to re-use it for any
followup calls after the initial down-case.
 Initial patch did it on first display. After the ctor changes it now
happens one on construction regardless of whether display ever happens.


&gt;<i> 
</I>&gt;&gt;<i>      if (theScheme_ &gt; AnyP::PROTO_NONE &amp;&amp; theScheme_ &lt; AnyP::PROTO_MAX) {
</I>&gt;&gt;<i> -        const char *in = AnyP::ProtocolType_str[theScheme_];
</I>&gt;&gt;<i> -        for (; p &lt; (BUFSIZ-1) &amp;&amp; in[p] != '\0'; ++p)
</I>&gt;&gt;<i> -            out[p] = xtolower(in[p]);
</I>&gt;&gt;<i> +        schemeImage_ = AnyP::ProtocolType_str[theScheme_];
</I>&gt;&gt;<i> +        schemeImage_.toLower();
</I>&gt;&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> This slow code may not be needed at all if the rest of the changes are
</I>&gt;<i> implemented. If this code stays, please add an &quot;XXX: Slow.&quot; or a similar
</I>&gt;<i> comment after toLower(). There are many ways to fix/optimize this, but
</I>&gt;<i> the best way probably depends on the rest of the changes so I am not
</I>&gt;<i> going to suggest any specific TODO here.
</I>
AFAICT the best optimization we can do is just take the image string
from the urlParse logic. Which is what this patch is doing now after the
ctor changes.

The slow logic path is now only done for URI which are generated
internally by Squid from just a ProtocolType enum.

&gt;<i> 
</I>&gt;&gt;<i> @@ -157,6 +158,9 @@
</I>&gt;&gt;<i>      if (strncasecmp(b, &quot;whois&quot;, len) == 0)
</I>&gt;&gt;<i>          return AnyP::PROTO_WHOIS;
</I>&gt;&gt;<i>  
</I>&gt;&gt;<i> +    if (len &gt; 0)
</I>&gt;&gt;<i> +        return AnyP::PROTO_UNKNOWN;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>      return AnyP::PROTO_NONE;
</I>&gt;&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> This function should return a UriScheme object instead. Ideally, using
</I>&gt;<i> created-once constants for common protocols (so that we do not have to
</I>&gt;<i> deal with to-lower-case conversion every time a scheme image is needed).
</I>
This function is used to determine what outgoing ProtocolType module
should be used when forwarding the message upstream.

In an ideal world this and the parse itself would be a methods of the
URL object. But that is a much bigger change and I intend to do it in a
later patch, not this one. For now returning PROTO_UNKNOWN instead of
PROTO_NONE fixes the input validation that follow this function in the
parsing sequence.

By simply returning PROTO_UNKNOWN here on this len&gt;0 condition we do
trigger the external code path which can copy the scheme name from the
parse and avoid all that to-lower business.

&gt;<i> 
</I>&gt;&gt;<i> @@ -27,7 +28,7 @@
</I>&gt;&gt;<i>      ~UriScheme() {}
</I>&gt;<i> ...
</I>&gt;&gt;<i> +    /// the string representation to use for theScheme_
</I>&gt;&gt;<i> +    mutable SBuf schemeImage_;
</I>&gt;<i> 
</I>&gt;<i> Please do not name Foo members FooX. One Foo is enough!
</I>&gt;<i> 
</I>
Done.

&gt;<i> 
</I>&gt;&gt;<i> +    /// the string representation to use for theScheme_
</I>&gt;<i> 
</I>&gt;<i> s/to use for theScheme_//
</I>&gt;<i> or
</I>&gt;<i> s/to use for theScheme_/of the scheme//
</I>&gt;<i> 
</I>
Done.

&gt;<i> If you can make such a guarantee after all other changes, please add
</I>&gt;<i> something like &quot;; always in lower case&quot;.
</I>
Can't. It is what it is - case sensitive. see above.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    mutable SBuf schemeImage_;
</I>&gt;<i> 
</I>&gt;<i> Mutable may not be needed after all other changes.
</I>&gt;<i> 
</I>
Yes. Gone.

&gt;<i> 
</I>&gt;<i> It is difficult for me to review 4-line no-function-names diff, so
</I>&gt;<i> forgive me if I missed any context-dependent caveats.
</I>&gt;<i> 
</I>
Sorry. This one has 20 lines of context.

Can you remind me what the .bazaar.conf setting was to make this the
default? I lost the old bazaar.conf with a HDD earlier this year.

Amos
-------------- next part --------------
=== modified file 'src/HttpRequest.cc'
--- src/HttpRequest.cc	2016-03-25 20:11:29 +0000
+++ src/HttpRequest.cc	2016-04-15 18:04:33 +0000
@@ -26,60 +26,60 @@
 #include &quot;log/Config.h&quot;
 #include &quot;MemBuf.h&quot;
 #include &quot;sbuf/StringConvert.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;URL.h&quot;
 
 #if USE_AUTH
 #include &quot;auth/UserRequest.h&quot;
 #endif
 #if ICAP_CLIENT
 #include &quot;adaptation/icap/icap_log.h&quot;
 #endif
 
 HttpRequest::HttpRequest() :
     HttpMsg(hoRequest)
 {
     init();
 }
 
-HttpRequest::HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
+HttpRequest::HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aSchemeImg, const char *aUrlpath) :
     HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE &lt;&lt; &quot;constructed, this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; ++id);
     init();
-    initHTTP(aMethod, aProtocol, aUrlpath);
+    initHTTP(aMethod, aProtocol, aSchemeImg, aUrlpath);
 }
 
 HttpRequest::~HttpRequest()
 {
     clean();
     debugs(93,7, HERE &lt;&lt; &quot;destructed, this=&quot; &lt;&lt; this);
 }
 
 void
-HttpRequest::initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
+HttpRequest::initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aSchemeImg, const char *aUrlpath)
 {
     method = aMethod;
-    url.setScheme(aProtocol);
+    url.setScheme(aProtocol, aSchemeImg);
     url.path(aUrlpath);
 }
 
 void
 HttpRequest::init()
 {
     method = Http::METHOD_NONE;
     url.clear();
 #if USE_AUTH
     auth_user_request = NULL;
 #endif
     memset(&amp;flags, '\0', sizeof(flags));
     range = NULL;
     ims = -1;
     imslen = 0;
     lastmod = -1;
     client_addr.setEmpty();
     my_addr.setEmpty();
     body_pipe = NULL;
     // hier
@@ -162,45 +162,41 @@
 void
 HttpRequest::reset()
 {
     clean();
     init();
 }
 
 HttpRequest *
 HttpRequest::clone() const
 {
     HttpRequest *copy = new HttpRequest();
     copy-&gt;method = method;
     // TODO: move common cloning clone to Msg::copyTo() or copy ctor
     copy-&gt;header.append(&amp;header);
     copy-&gt;hdrCacheInit();
     copy-&gt;hdr_sz = hdr_sz;
     copy-&gt;http_ver = http_ver;
     copy-&gt;pstate = pstate; // TODO: should we assert a specific state here?
     copy-&gt;body_pipe = body_pipe;
 
-    copy-&gt;url.setScheme(url.getScheme());
-    copy-&gt;url.userInfo(url.userInfo());
-    copy-&gt;url.host(url.host());
-    copy-&gt;url.port(url.port());
-    copy-&gt;url.path(url.path());
+    copy-&gt;url = url;
 
     // range handled in hdrCacheInit()
     copy-&gt;ims = ims;
     copy-&gt;imslen = imslen;
     copy-&gt;hier = hier; // Is it safe to copy? Should we?
 
     copy-&gt;errType = errType;
 
     // XXX: what to do with copy-&gt;peer_login?
 
     copy-&gt;lastmod = lastmod;
     copy-&gt;etag = etag;
     copy-&gt;vary_headers = vary_headers;
     // XXX: what to do with copy-&gt;peer_domain?
 
     copy-&gt;tag = tag;
     copy-&gt;extacl_log = extacl_log;
     copy-&gt;extacl_message = extacl_message;
 
     const bool inheritWorked = copy-&gt;inheritProperties(this);

=== modified file 'src/HttpRequest.h'
--- src/HttpRequest.h	2016-03-25 20:11:29 +0000
+++ src/HttpRequest.h	2016-04-15 18:04:34 +0000
@@ -31,45 +31,45 @@
 #if USE_SQUID_EUI
 #include &quot;eui/Eui48.h&quot;
 #include &quot;eui/Eui64.h&quot;
 #endif
 
 class ConnStateData;
 
 /*  Http Request */
 void httpRequestPack(void *obj, Packable *p);
 
 class HttpHdrRange;
 
 class HttpRequest: public HttpMsg
 {
     MEMPROXY_CLASS(HttpRequest);
 
 public:
     typedef RefCount&lt;HttpRequest&gt; Pointer;
 
     HttpRequest();
-    HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
+    HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *schemeImage, const char *aUrlpath);
     ~HttpRequest();
     virtual void reset();
 
-    void initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
+    void initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *schemeImage, const char *aUrlpath);
 
     virtual HttpRequest *clone() const;
 
     /// Whether response to this request is potentially cachable
     /// \retval false  Not cacheable.
     /// \retval true   Possibly cacheable. Response factors will determine.
     bool maybeCacheable();
 
     bool conditional() const; ///&lt; has at least one recognized If-* header
 
     /// whether the client is likely to be able to handle a 1xx reply
     bool canHandle1xx() const;
 
 #if USE_ADAPTATION
     /// Returns possibly nil history, creating it if adapt. logging is enabled
     Adaptation::History::Pointer adaptLogHistory() const;
     /// Returns possibly nil history, creating it if requested
     Adaptation::History::Pointer adaptHistory(bool createIfNone = false) const;
     /// Makes their history ours, throwing on conflicts
     void adaptHistoryImport(const HttpRequest &amp;them);

=== modified file 'src/PeerPoolMgr.cc'
--- src/PeerPoolMgr.cc	2016-02-02 15:39:23 +0000
+++ src/PeerPoolMgr.cc	2016-06-15 11:32:59 +0000
@@ -45,41 +45,41 @@
     request(),
     opener(),
     securer(),
     closer(),
     addrUsed(0)
 {
 }
 
 PeerPoolMgr::~PeerPoolMgr()
 {
     cbdataReferenceDone(peer);
 }
 
 void
 PeerPoolMgr::start()
 {
     AsyncJob::start();
 
     // ErrorState, getOutgoingAddress(), and other APIs may require a request.
     // We fake one. TODO: Optionally send this request to peers?
-    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, &quot;*&quot;);
+    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, &quot;http&quot;, &quot;*&quot;);
     request-&gt;url.host(peer-&gt;host);
 
     checkpoint(&quot;peer initialized&quot;);
 }
 
 void
 PeerPoolMgr::swanSong()
 {
     AsyncJob::swanSong();
 }
 
 bool
 PeerPoolMgr::validPeer() const
 {
     return peer &amp;&amp; cbdataReferenceValid(peer) &amp;&amp; peer-&gt;standby.pool;
 }
 
 bool
 PeerPoolMgr::doneAll() const
 {

=== modified file 'src/URL.h'
--- src/URL.h	2016-02-23 08:51:22 +0000
+++ src/URL.h	2016-06-15 11:36:47 +0000
@@ -11,55 +11,69 @@
 
 #include &quot;anyp/UriScheme.h&quot;
 #include &quot;ip/Address.h&quot;
 #include &quot;rfc2181.h&quot;
 #include &quot;sbuf/SBuf.h&quot;
 
 #include &lt;iosfwd&gt;
 
 /**
  * The URL class represents a Uniform Resource Location
  *
  * Governed by RFC 3986
  */
 class URL
 {
     MEMPROXY_CLASS(URL);
 
 public:
     URL() : hostIsNumeric_(false), port_(0) {*host_=0;}
     URL(AnyP::UriScheme const &amp;aScheme);
+    URL(const URL &amp;other) {
+        this-&gt;operator =(other);
+    }
+    URL &amp;operator =(const URL &amp;o) {
+        scheme_ = o.scheme_;
+        userInfo_ = o.userInfo_;
+        memcpy(host_, o.host_, sizeof(host_));
+        hostIsNumeric_ = o.hostIsNumeric_;
+        hostAddr_ = o.hostAddr_;
+        port_ = o.port_;
+        path_ = o.path_;
+        touch();
+        return *this;
+    }
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
         hostIsNumeric_ = false;
         *host_ = 0;
         hostAddr_.setEmpty();
         port_ = 0;
         touch();
     }
     void touch(); ///&lt; clear the cached URI display forms
 
     AnyP::UriScheme const &amp; getScheme() const {return scheme_;}
 
     /// convert the URL scheme to that given
-    void setScheme(const AnyP::ProtocolType &amp;p) {scheme_=p; touch();}
+    void setScheme(const AnyP::ProtocolType &amp;p, const char *str) {scheme_ = AnyP::UriScheme(p, str); touch();}
 
     void userInfo(const SBuf &amp;s) {userInfo_=s; touch();}
     const SBuf &amp;userInfo() const {return userInfo_;}
 
     void host(const char *src);
     const char *host(void) const {return host_;}
     int hostIsNumeric(void) const {return hostIsNumeric_;}
     Ip::Address const &amp; hostIP(void) const {return hostAddr_;}
 
     void port(unsigned short p) {port_=p; touch();}
     unsigned short port() const {return port_;}
 
     void path(const char *p) {path_=p; touch();}
     void path(const SBuf &amp;p) {path_=p; touch();}
     const SBuf &amp;path() const;
 
     /// the static '/' default URL-path
     static const SBuf &amp;SlashPath();
 
     /// the static '*' pseudo-URL
@@ -114,43 +128,51 @@
     // XXX: uses char[] instead of SBUf to reduce performance regressions
     //      from c_str() since most code using this is not yet using SBuf
     char host_[SQUIDHOSTNAMELEN];   ///&lt; string representation of the URI authority name or IP
     bool hostIsNumeric_;            ///&lt; whether the authority 'host' is a raw-IP
     Ip::Address hostAddr_;          ///&lt; binary representation of the URI authority if it is a raw-IP
 
     unsigned short port_;   ///&lt; URL port
 
     // XXX: for now includes query-string.
     SBuf path_;     ///&lt; URL path segment
 
     // pre-assembled URL forms
     mutable SBuf authorityHttp_;     ///&lt; RFC 7230 section 5.3.3 authority, maybe without default-port
     mutable SBuf authorityWithPort_; ///&lt; RFC 7230 section 5.3.3 authority with explicit port
     mutable SBuf absolute_;          ///&lt; RFC 7230 section 5.3.2 absolute-URI
 };
 
 inline std::ostream &amp;
 operator &lt;&lt;(std::ostream &amp;os, const URL &amp;url)
 {
-    if (const char *sc = url.getScheme().c_str())
-        os &lt;&lt; sc &lt;&lt; &quot;:&quot;;
-    os &lt;&lt; &quot;//&quot; &lt;&lt; url.authority() &lt;&lt; url.path();
+    // none means explicit empty string for scheme.
+    if (url.getScheme() != AnyP::PROTO_NONE)
+        os &lt;&lt; url.getScheme().image();
+    os &lt;&lt; &quot;:&quot;;
+
+    // no authority section on URN
+    if (url.getScheme() != AnyP::PROTO_URN)
+        os &lt;&lt; &quot;//&quot; &lt;&lt; url.authority();
+
+    // path is what it is - including absent
+    os &lt;&lt; url.path();
     return os;
 }
 
 class HttpRequest;
 class HttpRequestMethod;
 
 void urlInitialize(void);
 HttpRequest *urlParse(const HttpRequestMethod&amp;, char *, HttpRequest *request = NULL);
 char *urlCanonicalClean(const HttpRequest *);
 const char *urlCanonicalFakeHttps(const HttpRequest * request);
 bool urlIsRelative(const char *);
 char *urlMakeAbsolute(const HttpRequest *, const char *);
 char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
 char *urlInternal(const char *dir, const char *name);
 
 /**
  * matchDomainName() compares a hostname (usually extracted from traffic)
  * with a domainname (usually from an ACL) according to the following rules:
  *
  *    HOST      |   DOMAIN    |   MATCH?

=== modified file 'src/anyp/UriScheme.cc'
--- src/anyp/UriScheme.cc	2016-01-01 00:12:18 +0000
+++ src/anyp/UriScheme.cc	2016-04-15 18:09:43 +0000
@@ -1,49 +1,51 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 23    URL Scheme parsing */
 
 #include &quot;squid.h&quot;
 #include &quot;anyp/UriScheme.h&quot;
 
-char const *
-AnyP::UriScheme::c_str() const
+AnyP::UriScheme::UriScheme(AnyP::ProtocolType const aScheme, const char *img) :
+    theScheme_(aScheme)
 {
-    if (theScheme_ == AnyP::PROTO_UNKNOWN)
-        return &quot;(unknown)&quot;;
-
-    static char out[BUFSIZ];
-    int p = 0;
-
-    if (theScheme_ &gt; AnyP::PROTO_NONE &amp;&amp; theScheme_ &lt; AnyP::PROTO_MAX) {
-        const char *in = AnyP::ProtocolType_str[theScheme_];
-        for (; p &lt; (BUFSIZ-1) &amp;&amp; in[p] != '\0'; ++p)
-            out[p] = xtolower(in[p]);
+    if (img)
+        // image could be provided explicitly (case-sensitive)
+        image_ = img;
+
+    else if (theScheme_ == AnyP::PROTO_UNKNOWN)
+        // image could be actually unknown and not provided
+        image_ = &quot;(unknown)&quot;;
+
+    else if (theScheme_ &gt; AnyP::PROTO_NONE &amp;&amp; theScheme_ &lt; AnyP::PROTO_MAX) {
+        // image could be implied by a registered transfer protocol
+        // which use upper-case labels, so down-case for scheme image
+        image_ = AnyP::ProtocolType_str[theScheme_];
+        image_.toLower();
     }
-    out[p] = '\0';
-    return out;
+    // else, image is an empty string (&quot;://example.com/&quot;)
 }
 
 unsigned short
 AnyP::UriScheme::defaultPort() const
 {
     switch (theScheme_) {
 
     case AnyP::PROTO_HTTP:
         return 80;
 
     case AnyP::PROTO_HTTPS:
         return 443;
 
     case AnyP::PROTO_FTP:
         return 21;
 
     case AnyP::PROTO_COAP:
     case AnyP::PROTO_COAPS:
         // <A HREF="coaps://">coaps://</A> default is TBA as of draft-ietf-core-coap-08.
         // Assuming IANA policy of allocating same port for base and TLS protocol versions will occur.

=== modified file 'src/anyp/UriScheme.h'
--- src/anyp/UriScheme.h	2016-01-01 00:12:18 +0000
+++ src/anyp/UriScheme.h	2016-06-15 11:06:36 +0000
@@ -1,59 +1,68 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ANYP_URISCHEME_H
 #define SQUID_ANYP_URISCHEME_H
 
 #include &quot;anyp/ProtocolType.h&quot;
+#include &quot;sbuf/SBuf.h&quot;
 
 #include &lt;iosfwd&gt;
 
 namespace AnyP
 {
 
 /** This class represents a URI Scheme such as <A HREF="http://">http://</A> <A HREF="https://,">https://,</A> <A HREF="wais://,">wais://,</A> urn: etc.
  * It does not represent the PROTOCOL that such schemes refer to.
  */
 class UriScheme
 {
 public:
     UriScheme() : theScheme_(AnyP::PROTO_NONE) {}
-    UriScheme(AnyP::ProtocolType const aScheme) : theScheme_(aScheme) {}
+    UriScheme(AnyP::ProtocolType const aScheme, const char *img = nullptr);
+    UriScheme(const AnyP::UriScheme &amp;o) : theScheme_(o.theScheme_), image_(o.image_) {}
+    UriScheme(AnyP::UriScheme &amp;&amp;) = default;
     ~UriScheme() {}
 
-    operator AnyP::ProtocolType() const { return theScheme_; }
+    AnyP::UriScheme&amp; operator=(const AnyP::UriScheme &amp;o) {
+        theScheme_ = o.theScheme_;
+        image_ = o.image_;
+        return *this;
+    }
+    AnyP::UriScheme&amp; operator=(AnyP::UriScheme &amp;&amp;) = default;
 
+    operator AnyP::ProtocolType() const { return theScheme_; }
+    // XXX: does not account for comparison of unknown schemes (by image)
     bool operator != (AnyP::ProtocolType const &amp; aProtocol) const { return theScheme_ != aProtocol; }
 
     /** Get a char string representation of the scheme.
-     * Does not include the ':' or '://&quot; terminators.
-     *
-     * An upper bound length of BUFSIZ bytes converted. Remainder will be truncated.
-     * The result of this call will remain usable only until any subsequest call
-     * and must be copied if persistence is needed.
+     * Does not include the ':' or &quot;://&quot; terminators.
      */
-    char const *c_str() const;
+    SBuf image() const {return image_;}
 
     unsigned short defaultPort() const;
 
 private:
     /// This is a typecode pointer into the enum/registry of protocols handled.
     AnyP::ProtocolType theScheme_;
+
+    /// the string representation
+    SBuf image_;
 };
 
 } // namespace AnyP
 
 inline std::ostream &amp;
 operator &lt;&lt; (std::ostream &amp;os, AnyP::UriScheme const &amp;scheme)
 {
-    os &lt;&lt; scheme.c_str();
+    os &lt;&lt; scheme.image();
     return os;
 }
 
 #endif /* SQUID_ANYP_URISCHEME_H */
 

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2016-04-03 23:41:58 +0000
+++ src/cache_cf.cc	2016-04-15 18:12:34 +0000
@@ -3329,41 +3329,41 @@
 check_null_IpAddress_list(const Ip::Address_list * s)
 {
     return NULL == s;
 }
 
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
 static void
 parsePortSpecification(const AnyP::PortCfgPointer &amp;s, char *token)
 {
     char *host = NULL;
     unsigned short port = 0;
     char *t = NULL;
     char *junk = NULL;
 
     s-&gt;disable_pmtu_discovery = DISABLE_PMTU_OFF;
     s-&gt;name = xstrdup(token);
     s-&gt;connection_auth_disabled = false;
 
-    const char *portType = AnyP::UriScheme(s-&gt;transport.protocol).c_str();
+    const SBuf &amp;portType = AnyP::UriScheme(s-&gt;transport.protocol).image();
 
     if (*token == '[') {
         /* [ipv6]:port */
         host = token + 1;
         t = strchr(host, ']');
         if (!t) {
             debugs(3, DBG_CRITICAL, &quot;FATAL: &quot; &lt;&lt; portType &lt;&lt; &quot;_port: missing ']' on IPv6 address: &quot; &lt;&lt; token);
             self_destruct();
         }
         *t = '\0';
         ++t;
         if (*t != ':') {
             debugs(3, DBG_CRITICAL, &quot;FATAL: &quot; &lt;&lt; portType &lt;&lt; &quot;_port: missing Port in: &quot; &lt;&lt; token);
             self_destruct();
         }
         if (!Ip::EnableIpv6) {
             debugs(3, DBG_CRITICAL, &quot;FATAL: &quot; &lt;&lt; portType &lt;&lt; &quot;_port: IPv6 is not available.&quot;);
             self_destruct();
         }
         port = xatos(t + 1);
@@ -3705,41 +3705,41 @@
             debugs(3,DBG_CRITICAL, &quot;FATAL: https_port: require-proxy-header option is not supported on HTTPS ports.&quot;);
             self_destruct();
         }
     } else if (protoName.cmp(&quot;FTP&quot;) == 0) {
         /* ftp_port does not support ssl-bump */
         if (s-&gt;flags.tunnelSslBumping) {
             debugs(3, DBG_CRITICAL, &quot;FATAL: ssl-bump is not supported for ftp_port.&quot;);
             self_destruct();
         }
         if (s-&gt;flags.proxySurrogate) {
             // Passive FTP data channel does not work without deep protocol inspection in the frontend.
             debugs(3,DBG_CRITICAL, &quot;FATAL: require-proxy-header option is not supported on ftp_port.&quot;);
             self_destruct();
         }
     }
 
     if (Ip::EnableIpv6&amp;IPV6_SPECIAL_SPLITSTACK &amp;&amp; s-&gt;s.isAnyAddr()) {
         // clone the port options from *s to *(s-&gt;next)
         s-&gt;next = s-&gt;clone();
         s-&gt;next-&gt;s.setIPv4();
-        debugs(3, 3, AnyP::UriScheme(s-&gt;transport.protocol).c_str() &lt;&lt; &quot;_port: clone wildcard address for split-stack: &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; and &quot; &lt;&lt; s-&gt;next-&gt;s);
+        debugs(3, 3, AnyP::UriScheme(s-&gt;transport.protocol).image() &lt;&lt; &quot;_port: clone wildcard address for split-stack: &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; and &quot; &lt;&lt; s-&gt;next-&gt;s);
     }
 
     while (*head != NULL)
         head = &amp;((*head)-&gt;next);
 
     *head = s;
 }
 
 static void
 dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfgPointer &amp;s)
 {
     char buf[MAX_IPSTRLEN];
 
     storeAppendPrintf(e, &quot;%s %s&quot;,
                       n,
                       s-&gt;s.toUrl(buf,MAX_IPSTRLEN));
 
     // MODES and specific sub-options.
     if (s-&gt;flags.natIntercept)
         storeAppendPrintf(e, &quot; intercept&quot;);
@@ -3749,41 +3749,41 @@
 
     else if (s-&gt;flags.proxySurrogate)
         storeAppendPrintf(e, &quot; require-proxy-header&quot;);
 
     else if (s-&gt;flags.accelSurrogate) {
         storeAppendPrintf(e, &quot; accel&quot;);
 
         if (s-&gt;vhost)
             storeAppendPrintf(e, &quot; vhost&quot;);
 
         if (s-&gt;vport &lt; 0)
             storeAppendPrintf(e, &quot; vport&quot;);
         else if (s-&gt;vport &gt; 0)
             storeAppendPrintf(e, &quot; vport=%d&quot;, s-&gt;vport);
 
         if (s-&gt;defaultsite)
             storeAppendPrintf(e, &quot; defaultsite=%s&quot;, s-&gt;defaultsite);
 
         // TODO: compare against prefix of 'n' instead of assuming http_port
         if (s-&gt;transport.protocol != AnyP::PROTO_HTTP)
-            storeAppendPrintf(e, &quot; protocol=%s&quot;, AnyP::UriScheme(s-&gt;transport.protocol).c_str());
+            storeAppendPrintf(e, &quot; protocol=%s&quot;, AnyP::ProtocolType_str[s-&gt;transport.protocol]);
 
         if (s-&gt;allow_direct)
             storeAppendPrintf(e, &quot; allow-direct&quot;);
 
         if (s-&gt;ignore_cc)
             storeAppendPrintf(e, &quot; ignore-cc&quot;);
 
     }
 
     // Generic independent options
 
     if (s-&gt;name)
         storeAppendPrintf(e, &quot; name=%s&quot;, s-&gt;name);
 
 #if USE_HTTP_VIOLATIONS
     if (!s-&gt;flags.accelSurrogate &amp;&amp; s-&gt;ignore_cc)
         storeAppendPrintf(e, &quot; ignore-cc&quot;);
 #endif
 
     if (s-&gt;connection_auth_disabled)

=== modified file 'src/carp.cc'
--- src/carp.cc	2016-01-01 00:12:18 +0000
+++ src/carp.cc	2016-04-15 18:12:37 +0000
@@ -150,41 +150,41 @@
     CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
     double high_score = 0;
 
     if (n_carp_peers == 0)
         return NULL;
 
     /* calculate hash key */
     debugs(39, 2, &quot;carpSelectParent: Calculating hash for &quot; &lt;&lt; request-&gt;effectiveRequestUri());
 
     /* select CachePeer */
     for (k = 0; k &lt; n_carp_peers; ++k) {
         SBuf key;
         tp = carp_peers[k];
         if (tp-&gt;options.carp_key.set) {
             // this code follows URI syntax pattern.
             // corner cases should use the full effective request URI
             if (tp-&gt;options.carp_key.scheme) {
-                key.append(request-&gt;url.getScheme().c_str());
+                key.append(request-&gt;url.getScheme().image());
                 if (key.length()) //if the scheme is not empty
                     key.append(&quot;://&quot;);
             }
             if (tp-&gt;options.carp_key.host) {
                 key.append(request-&gt;url.host());
             }
             if (tp-&gt;options.carp_key.port) {
                 key.appendf(&quot;:%u&quot;, request-&gt;url.port());
             }
             if (tp-&gt;options.carp_key.path) {
                 // XXX: fix when path and query are separate
                 key.append(request-&gt;url.path().substr(0,request-&gt;url.path().find('?'))); // 0..N
             }
             if (tp-&gt;options.carp_key.params) {
                 // XXX: fix when path and query are separate
                 SBuf::size_type pos;
                 if ((pos=request-&gt;url.path().find('?')) != SBuf::npos)
                     key.append(request-&gt;url.path().substr(pos)); // N..npos
             }
         }

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2016-05-20 13:20:27 +0000
+++ src/client_side.cc	2016-06-15 11:32:08 +0000
@@ -1202,92 +1202,96 @@
     const bool switchedToHttps = conn-&gt;switchedToHttps();
     const bool tryHostHeader = vhost || switchedToHttps;
     char *host = NULL;
     if (tryHostHeader &amp;&amp; (host = hp-&gt;getHeaderField(&quot;Host&quot;))) {
         debugs(33, 5, &quot;ACCEL VHOST REWRITE: vhost=&quot; &lt;&lt; host &lt;&lt; &quot; + vport=&quot; &lt;&lt; vport);
         char thost[256];
         if (vport &gt; 0) {
             thost[0] = '\0';
             char *t = NULL;
             if (host[strlen(host)] != ']' &amp;&amp; (t = strrchr(host,':')) != NULL) {
                 strncpy(thost, host, (t-host));
                 snprintf(thost+(t-host), sizeof(thost)-(t-host), &quot;:%d&quot;, vport);
                 host = thost;
             } else if (!t) {
                 snprintf(thost, sizeof(thost), &quot;%s:%d&quot;,host, vport);
                 host = thost;
             }
         } // else nothing to alter port-wise.
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen + strlen(host);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s">s://%s</A>&quot; SQUIDSBUFPH, AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(), host, SQUIDSBUFPRINT(url));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s&quot; SQUIDSBUFPH, SQUIDSBUFPRINT(scheme), host, SQUIDSBUFPRINT(url));
         debugs(33, 5, &quot;ACCEL VHOST REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else if (conn-&gt;port-&gt;defaultsite /* &amp;&amp; !vhost */) {
         debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: defaultsite=&quot; &lt;&lt; conn-&gt;port-&gt;defaultsite &lt;&lt; &quot; + vport=&quot; &lt;&lt; vport);
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen +
                            strlen(conn-&gt;port-&gt;defaultsite);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         char vportStr[32];
         vportStr[0] = '\0';
         if (vport &gt; 0) {
             snprintf(vportStr, sizeof(vportStr),&quot;:%d&quot;,vport);
         }
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s%s">s://%s%s</A>&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(), conn-&gt;port-&gt;defaultsite, vportStr, SQUIDSBUFPRINT(url));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s%s&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme), conn-&gt;port-&gt;defaultsite, vportStr, SQUIDSBUFPRINT(url));
         debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else if (vport &gt; 0 /* &amp;&amp; (!vhost || no Host:) */) {
         debugs(33, 5, &quot;ACCEL VPORT REWRITE: *_port IP + vport=&quot; &lt;&lt; vport);
         /* Put the local socket IP address as the hostname, with whatever vport we found  */
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         http-&gt;getConn()-&gt;clientConnection-&gt;local.toHostStr(ipbuf,MAX_IPSTRLEN);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s:%d">s://%s:%d</A>&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(),
-                 ipbuf, vport, SQUIDSBUFPRINT(url));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s:%d&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme), ipbuf, vport, SQUIDSBUFPRINT(url));
         debugs(33, 5, &quot;ACCEL VPORT REWRITE: &quot; &lt;&lt; http-&gt;uri);
     }
 }
 
 static void
 prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1::RequestParserPointer &amp;hp)
 {
     // TODO Must() on URI !empty when the parser supports throw. For now avoid assert().
     if (!hp-&gt;requestUri().isEmpty() &amp;&amp; hp-&gt;requestUri()[0] != '/')
         return; /* already in good shape */
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
 
     if (const char *host = hp-&gt;getHeaderField(&quot;Host&quot;)) {
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen +
                            strlen(host);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s">s://%s</A>&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(), host, SQUIDSBUFPRINT(hp-&gt;requestUri()));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme), host, SQUIDSBUFPRINT(hp-&gt;requestUri()));
         debugs(33, 5, &quot;TRANSPARENT HOST REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else {
         /* Put the local socket IP address as the hostname.  */
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         static char ipbuf[MAX_IPSTRLEN];
         http-&gt;getConn()-&gt;clientConnection-&gt;local.toHostStr(ipbuf,MAX_IPSTRLEN);
-        snprintf(http-&gt;uri, url_sz, &quot;%<A HREF="s://%s:%d">s://%s:%d</A>&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(http-&gt;getConn()-&gt;transferProtocol.protocol).c_str(),
+        const SBuf &amp;scheme = AnyP::UriScheme(http-&gt;getConn()-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s:%d&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme),
                  ipbuf, http-&gt;getConn()-&gt;clientConnection-&gt;local.port(), SQUIDSBUFPRINT(hp-&gt;requestUri()));
         debugs(33, 5, &quot;TRANSPARENT REWRITE: &quot; &lt;&lt; http-&gt;uri);
     }
 }
 
 /** Parse an HTTP request
  *
  *  \note Sets result-&gt;flags.parsed_ok to 0 if failed to parse the request,
  *          to 1 if the request was correctly parsed.
  *  \param[in] csd a ConnStateData. The caller must make sure it is not null
  *  \param[in] hp an Http1::RequestParser
  *  \param[out] mehtod_p will be set as a side-effect of the parsing.
  *          Pointed-to value will be set to Http::METHOD_NONE in case of
  *          parsing failure
  *  \param[out] http_ver will be set as a side-effect of the parsing
  *  \return NULL on incomplete requests,
  *          a Http::Stream on success or failure.
  */
 Http::Stream *
 parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &amp;hp)
@@ -1660,41 +1664,41 @@
         request-&gt;flags.intercepted = ((http-&gt;clientConnection-&gt;flags &amp; COMM_INTERCEPTION) != 0);
         request-&gt;flags.interceptTproxy = ((http-&gt;clientConnection-&gt;flags &amp; COMM_TRANSPARENT) != 0 ) ;
         static const bool proxyProtocolPort = (conn-&gt;port != NULL) ? conn-&gt;port-&gt;flags.proxySurrogate : false;
         if (request-&gt;flags.interceptTproxy &amp;&amp; !proxyProtocolPort) {
             if (Config.accessList.spoof_client_ip) {
                 ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.spoof_client_ip, http);
                 request-&gt;flags.spoofClientIp = (checklist-&gt;fastCheck() == ACCESS_ALLOWED);
                 delete checklist;
             } else
                 request-&gt;flags.spoofClientIp = true;
         } else
             request-&gt;flags.spoofClientIp = false;
     }
 
     if (internalCheck(request-&gt;url.path())) {
         if (internalHostnameIs(request-&gt;url.host()) &amp;&amp; request-&gt;url.port() == getMyPort()) {
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true));
             http-&gt;flags.internal = true;
         } else if (Config.onoff.global_internal_static &amp;&amp; internalStaticCheck(request-&gt;url.path())) {
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true) &lt;&lt; &quot; (global_internal_static on)&quot;);
-            request-&gt;url.setScheme(AnyP::PROTO_HTTP);
+            request-&gt;url.setScheme(AnyP::PROTO_HTTP, &quot;http&quot;);
             request-&gt;url.host(internalHostname());
             request-&gt;url.port(getMyPort());
             http-&gt;flags.internal = true;
         } else
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true) &lt;&lt; &quot; (not this proxy)&quot;);
     }
 
     request-&gt;flags.internal = http-&gt;flags.internal;
     setLogUri (http, urlCanonicalClean(request.getRaw()));
     request-&gt;client_addr = conn-&gt;clientConnection-&gt;remote; // XXX: remove reuest-&gt;client_addr member.
 #if FOLLOW_X_FORWARDED_FOR
     // indirect client gets stored here because it is an HTTP header result (from X-Forwarded-For:)
     // not a details about teh TCP connection itself
     request-&gt;indirect_client_addr = conn-&gt;clientConnection-&gt;remote;
 #endif /* FOLLOW_X_FORWARDED_FOR */
     request-&gt;my_addr = conn-&gt;clientConnection-&gt;local;
     request-&gt;myportname = conn-&gt;port-&gt;name;
 
     if (!isFtp) {
         // XXX: for non-HTTP messages instantiate a different HttpMsg child type
@@ -3431,41 +3435,41 @@
     }
     return true;
 }
 
 /// find any unused HttpSockets[] slot and store fd there or return false
 static bool
 AddOpenedHttpSocket(const Comm::ConnectionPointer &amp;conn)
 {
     bool found = false;
     for (int i = 0; i &lt; NHttpSockets &amp;&amp; !found; ++i) {
         if ((found = HttpSockets[i] &lt; 0))
             HttpSockets[i] = conn-&gt;fd;
     }
     return found;
 }
 
 static void
 clientHttpConnectionsOpen(void)
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
-        const char *scheme = AnyP::UriScheme(s-&gt;transport.protocol).c_str();
+        const SBuf &amp;scheme = AnyP::UriScheme(s-&gt;transport.protocol).image();
 
         if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, DBG_IMPORTANT, &quot;WARNING: You have too many '&quot; &lt;&lt; scheme &lt;&lt; &quot;_port' lines.&quot;);
             debugs(1, DBG_IMPORTANT, &quot;         The limit is &quot; &lt;&lt; MAXTCPLISTENPORTS &lt;&lt; &quot; HTTP ports.&quot;);
             continue;
         }
 
 #if USE_OPENSSL
         if (s-&gt;flags.tunnelSslBumping) {
             if (!Config.accessList.ssl_bump) {
                 debugs(33, DBG_IMPORTANT, &quot;WARNING: No ssl_bump configured. Disabling ssl-bump on &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s);
                 s-&gt;flags.tunnelSslBumping = false;
             }
             if (!s-&gt;secure.staticContext &amp;&amp; !s-&gt;generateHostCertificates) {
                 debugs(1, DBG_IMPORTANT, &quot;Will not bump SSL at &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to TLS initialization failure.&quot;);
                 s-&gt;flags.tunnelSslBumping = false;
                 if (s-&gt;transport.protocol == AnyP::PROTO_HTTP)
                     s-&gt;secure.encryptTransport = false;
             }
             if (s-&gt;flags.tunnelSslBumping) {

=== modified file 'src/client_side_reply.cc'
--- src/client_side_reply.cc	2016-06-02 09:49:19 +0000
+++ src/client_side_reply.cc	2016-06-15 11:28:54 +0000
@@ -2210,41 +2210,41 @@
         }
     }
 
     holdingBuffer = result;
     processReplyAccess();
     return;
 }
 
 /* Using this breaks the client layering just a little!
  */
 void
 clientReplyContext::createStoreEntry(const HttpRequestMethod&amp; m, RequestFlags reqFlags)
 {
     assert(http != NULL);
     /*
      * For erroneous requests, we might not have a h-&gt;request,
      * so make a fake one.
      */
 
     if (http-&gt;request == NULL) {
-        http-&gt;request = new HttpRequest(m, AnyP::PROTO_NONE, null_string);
+        http-&gt;request = new HttpRequest(m, AnyP::PROTO_NONE, &quot;http&quot;, null_string);
         HTTPMSGLOCK(http-&gt;request);
     }
 
     StoreEntry *e = storeCreateEntry(storeId(), http-&gt;log_uri, reqFlags, m);
 
     // Make entry collapsable ASAP, to increase collapsing chances for others,
     // TODO: every must-revalidate and similar request MUST reach the origin,
     // but do we have to prohibit others from collapsing on that request?
     if (Config.onoff.collapsed_forwarding &amp;&amp; reqFlags.cachable &amp;&amp;
             !reqFlags.needValidation &amp;&amp;
             (m == Http::METHOD_GET || m == Http::METHOD_HEAD)) {
         // make the entry available for future requests now
         Store::Root().allowCollapsing(e, reqFlags, m);
     }
 
     sc = storeClientListAdd(e, this);
 
 #if USE_DELAY_POOLS
     sc-&gt;setDelayId(DelayId::DelayClient(http));
 #endif

=== modified file 'src/errorpage.cc'
--- src/errorpage.cc	2016-04-17 11:49:54 +0000
+++ src/errorpage.cc	2016-04-19 11:04:53 +0000
@@ -929,41 +929,42 @@
 
     case 'O':
         if (!building_deny_info_url)
             do_quote = 0;
     case 'o':
         p = request ? request-&gt;extacl_message.termedBuf() : external_acl_message;
         if (!p &amp;&amp; !building_deny_info_url)
             p = &quot;[not available]&quot;;
         break;
 
     case 'p':
         if (request) {
             mb.appendf(&quot;%u&quot;, request-&gt;url.port());
         } else if (!building_deny_info_url) {
             p = &quot;[unknown port]&quot;;
         }
         break;
 
     case 'P':
         if (request) {
-            p = request-&gt;url.getScheme().c_str();
+            const SBuf &amp;m = request-&gt;url.getScheme().image();
+            mb.append(m.rawContent(), m.length());
         } else if (!building_deny_info_url) {
             p = &quot;[unknown protocol]&quot;;
         }
         break;
 
     case 'R':
         if (building_deny_info_url) {
             if (request != NULL) {
                 SBuf tmp = request-&gt;url.path();
                 p = tmp.c_str();
                 no_urlescape = 1;
             } else
                 p = &quot;[no request]&quot;;
             break;
         }
         if (request != NULL) {
             mb.appendf(SQUIDSBUFPH &quot; &quot; SQUIDSBUFPH &quot; %s/%d.%d\n&quot;,
                        SQUIDSBUFPRINT(request-&gt;method.image()),
                        SQUIDSBUFPRINT(request-&gt;url.path()),
                        AnyP::ProtocolType_str[request-&gt;http_ver.protocol],

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2016-03-25 13:03:30 +0000
+++ src/format/Format.cc	2016-04-15 18:14:34 +0000
@@ -979,41 +979,43 @@
             if (al-&gt;request) {
                 const SBuf &amp;s = al-&gt;request-&gt;method.image();
                 sb.append(s.rawContent(), s.length());
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_URI:
             // original client URI
             if (al-&gt;request) {
                 const SBuf &amp;s = al-&gt;request-&gt;effectiveRequestUri();
                 sb.append(s.rawContent(), s.length());
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_URLSCHEME:
             if (al-&gt;request) {
-                out = al-&gt;request-&gt;url.getScheme().c_str();
+                const SBuf s(al-&gt;request-&gt;url.getScheme().image());
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_URLDOMAIN:
             if (al-&gt;request) {
                 out = al-&gt;request-&gt;url.host();
                 quote = 1;
             }
             break;
 
         case LFT_CLIENT_REQ_URLPORT:
             if (al-&gt;request) {
                 outint = al-&gt;request-&gt;url.port();
                 doint = 1;
             }
             break;
 
         case LFT_REQUEST_URLPATH_OLD_31:
         case LFT_CLIENT_REQ_URLPATH:
@@ -1058,41 +1060,43 @@
             if (al-&gt;adapted_request) {
                 const SBuf &amp;s = al-&gt;adapted_request-&gt;method.image();
                 sb.append(s.rawContent(), s.length());
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URI:
             // adapted request URI sent to server/peer
             if (al-&gt;adapted_request) {
                 const SBuf &amp;s = al-&gt;adapted_request-&gt;effectiveRequestUri();
                 sb.append(s.rawContent(), s.length());
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLSCHEME:
             if (al-&gt;adapted_request) {
-                out = al-&gt;adapted_request-&gt;url.getScheme().c_str();
+                const SBuf s(al-&gt;adapted_request-&gt;url.getScheme().image());
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLDOMAIN:
             if (al-&gt;adapted_request) {
                 out = al-&gt;adapted_request-&gt;url.host();
                 quote = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLPORT:
             if (al-&gt;adapted_request) {
                 outint = al-&gt;adapted_request-&gt;url.port();
                 doint = 1;
             }
             break;
 
         case LFT_SERVER_REQ_URLPATH:
             if (al-&gt;adapted_request) {

=== modified file 'src/tests/stub_HttpRequest.cc'
--- src/tests/stub_HttpRequest.cc	2016-03-17 03:28:14 +0000
+++ src/tests/stub_HttpRequest.cc	2016-04-15 18:22:14 +0000
@@ -1,42 +1,42 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;AccessLogEntry.h&quot;
 #include &quot;HttpRequest.h&quot;
 
 #define STUB_API &quot;HttpRequest.cc&quot;
 #include &quot;tests/STUB.h&quot;
 
 // void httpRequestPack(void *obj, Packable *p);
 
 HttpRequest::HttpRequest() : HttpMsg(hoRequest) {STUB}
-HttpRequest::HttpRequest(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *) : HttpMsg(hoRequest) {STUB}
+HttpRequest::HttpRequest(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *, const char *) : HttpMsg(hoRequest) {STUB}
 HttpRequest::~HttpRequest() STUB
 void HttpRequest::reset() STUB
-void HttpRequest::initHTTP(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *) STUB
+void HttpRequest::initHTTP(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *, const char *) STUB
 HttpRequest * HttpRequest::clone() const STUB_RETVAL(NULL)
 bool HttpRequest::maybeCacheable() STUB_RETVAL(false)
 bool HttpRequest::conditional() const STUB_RETVAL(false)
 bool HttpRequest::canHandle1xx() const STUB_RETVAL(false)
 #if USE_ADAPTATION
 Adaptation::History::Pointer HttpRequest::adaptLogHistory() const STUB_RETVAL(Adaptation::History::Pointer())
 Adaptation::History::Pointer HttpRequest::adaptHistory(bool) const STUB_RETVAL(Adaptation::History::Pointer())
 void HttpRequest::adaptHistoryImport(const HttpRequest &amp;) STUB
 #endif
 #if ICAP_CLIENT
 Adaptation::Icap::History::Pointer HttpRequest::icapHistory() const STUB_RETVAL(Adaptation::Icap::History::Pointer())
 #endif
 void HttpRequest::recordLookup(const Dns::LookupDetails &amp;) STUB
 void HttpRequest::detailError(err_type, int) STUB
 void HttpRequest::clearError() STUB
 void HttpRequest::clean() STUB
 void HttpRequest::init() STUB
 static const SBuf nilSBuf;
 const SBuf &amp;HttpRequest::effectiveRequestUri() const STUB_RETVAL(nilSBuf)
 bool HttpRequest::multipartRangeRequest() const STUB_RETVAL(false)

=== modified file 'src/tests/testUriScheme.cc'
--- src/tests/testUriScheme.cc	2016-01-01 00:12:18 +0000
+++ src/tests/testUriScheme.cc	2016-04-15 18:24:08 +0000
@@ -95,43 +95,43 @@
 /*
  * we should be able to construct a AnyP::UriScheme from the old 'protocol_t' enum.
  */
 void
 testUriScheme::testConstructprotocol_t()
 {
     AnyP::UriScheme lhs_none(AnyP::PROTO_NONE), rhs_none(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(lhs_none, rhs_none);
 
     AnyP::UriScheme lhs_cacheobj(AnyP::PROTO_CACHE_OBJECT), rhs_cacheobj(AnyP::PROTO_CACHE_OBJECT);
     CPPUNIT_ASSERT_EQUAL(lhs_cacheobj, rhs_cacheobj);
     CPPUNIT_ASSERT(lhs_none != rhs_cacheobj);
 }
 
 /*
  * we should be able to get a char const * version of the method.
  */
 void
 testUriScheme::testC_str()
 {
-    String lhs(&quot;wais&quot;);
+    SBuf lhs(&quot;wais&quot;);
     AnyP::UriScheme wais(AnyP::PROTO_WAIS);
-    String rhs(wais.c_str());
+    SBuf rhs(wais.image());
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
 
 /*
  * a AnyP::UriScheme replaces protocol_t, so we should be able to test for equality on
  * either the left or right hand side seamlessly.
  */
 void
 testUriScheme::testEqualprotocol_t()
 {
     CPPUNIT_ASSERT(AnyP::UriScheme() == AnyP::PROTO_NONE);
     CPPUNIT_ASSERT(not (AnyP::UriScheme(AnyP::PROTO_WAIS) == AnyP::PROTO_HTTP));
     CPPUNIT_ASSERT(AnyP::PROTO_HTTP == AnyP::UriScheme(AnyP::PROTO_HTTP));
     CPPUNIT_ASSERT(not (AnyP::PROTO_CACHE_OBJECT == AnyP::UriScheme(AnyP::PROTO_HTTP)));
 }
 
 /*
  * a AnyP::UriScheme should testable for inequality with a protocol_t.
  */
 void

=== modified file 'src/url.cc'
--- src/url.cc	2016-05-02 15:18:33 +0000
+++ src/url.cc	2016-06-15 11:31:37 +0000
@@ -1,40 +1,41 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 23    URL Parsing */
 
 #include &quot;squid.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpRequest.h&quot;
 #include &quot;rfc1738.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidString.h&quot;
 #include &quot;URL.h&quot;
 
 static HttpRequest *urlParseFinish(const HttpRequestMethod&amp; method,
                                    const AnyP::ProtocolType protocol,
+                                   const char *const protoStr,
                                    const char *const urlpath,
                                    const char *const host,
                                    const SBuf &amp;login,
                                    const int port,
                                    HttpRequest *request);
 static HttpRequest *urnParse(const HttpRequestMethod&amp; method, char *urn, HttpRequest *request);
 static const char valid_hostname_chars_u[] =
     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
     &quot;abcdefghijklmnopqrstuvwxyz&quot;
     &quot;0123456789-._&quot;
     &quot;[:]&quot;
     ;
 static const char valid_hostname_chars[] =
     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
     &quot;abcdefghijklmnopqrstuvwxyz&quot;
     &quot;0123456789-.&quot;
     &quot;[:]&quot;
     ;
 
 const SBuf &amp;
@@ -140,40 +141,43 @@
         return AnyP::PROTO_COAP;
 
     if (strncasecmp(b, &quot;coaps&quot;, len) == 0)
         return AnyP::PROTO_COAPS;
 
     if (strncasecmp(b, &quot;gopher&quot;, len) == 0)
         return AnyP::PROTO_GOPHER;
 
     if (strncasecmp(b, &quot;wais&quot;, len) == 0)
         return AnyP::PROTO_WAIS;
 
     if (strncasecmp(b, &quot;cache_object&quot;, len) == 0)
         return AnyP::PROTO_CACHE_OBJECT;
 
     if (strncasecmp(b, &quot;urn&quot;, len) == 0)
         return AnyP::PROTO_URN;
 
     if (strncasecmp(b, &quot;whois&quot;, len) == 0)
         return AnyP::PROTO_WHOIS;
 
+    if (len &gt; 0)
+        return AnyP::PROTO_UNKNOWN;
+
     return AnyP::PROTO_NONE;
 }
 
 /*
  * Parse a URI/URL.
  *
  * If the 'request' arg is non-NULL, put parsed values there instead
  * of allocating a new HttpRequest.
  *
  * This abuses HttpRequest as a way of representing the parsed url
  * and its components.
  * method is used to switch parsers and to init the HttpRequest.
  * If method is Http::METHOD_CONNECT, then rather than a URL a hostname:port is
  * looked for.
  * The url is non const so that if its too long we can NULL-terminate it in place.
  */
 
 /*
  * This routine parses a URL. Its assumed that the URL is complete -
  * ie, the end of the string is the end of the URL. Don't pass a partial
@@ -197,42 +201,42 @@
     const char *src;
     char *dst;
     proto[0] = host[0] = urlpath[0] = login[0] = '\0';
 
     if ((l = strlen(url)) + Config.appendDomainLen &gt; (MAX_URL - 1)) {
         /* terminate so it doesn't overflow other buffers */
         *(url + (MAX_URL &gt;&gt; 1)) = '\0';
         debugs(23, DBG_IMPORTANT, &quot;urlParse: URL too large (&quot; &lt;&lt; l &lt;&lt; &quot; bytes)&quot;);
         return NULL;
     }
     if (method == Http::METHOD_CONNECT) {
         port = CONNECT_PORT;
 
         if (sscanf(url, &quot;[%[^]]]:%d&quot;, host, &amp;port) &lt; 1)
             if (sscanf(url, &quot;%[^:]:%d&quot;, host, &amp;port) &lt; 1)
                 return NULL;
 
     } else if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &amp;&amp;
                URL::Asterisk().cmp(url) == 0) {
         protocol = AnyP::PROTO_HTTP;
-        port = AnyP::UriScheme(protocol).defaultPort();
-        return urlParseFinish(method, protocol, url, host, SBuf(), port, request);
+        port = 80; // or the slow way ...  AnyP::UriScheme(protocol,&quot;http&quot;).defaultPort();
+        return urlParseFinish(method, protocol, &quot;http&quot;, url, host, SBuf(), port, request);
     } else if (!strncmp(url, &quot;urn:&quot;, 4)) {
         return urnParse(method, url, request);
     } else {
         /* Parse the URL: */
         src = url;
         i = 0;
         /* Find first : - everything before is protocol */
         for (i = 0, dst = proto; i &lt; l &amp;&amp; *src != ':'; ++i, ++src, ++dst) {
             *dst = *src;
         }
         if (i &gt;= l)
             return NULL;
         *dst = '\0';
 
         /* Then its :// */
         if ((i+3) &gt; l || *src != ':' || *(src + 1) != '/' || *(src + 2) != '/')
             return NULL;
         i += 3;
         src += 3;
 
@@ -405,115 +409,117 @@
             break;
 
         case URI_WHITESPACE_CHOP:
             *(urlpath + strcspn(urlpath, w_space)) = '\0';
             break;
 
         case URI_WHITESPACE_STRIP:
         default:
             t = q = urlpath;
             while (*t) {
                 if (!xisspace(*t)) {
                     *q = *t;
                     ++q;
                 }
                 ++t;
             }
             *q = '\0';
         }
     }
 
-    return urlParseFinish(method, protocol, urlpath, host, SBuf(login), port, request);
+    return urlParseFinish(method, protocol, proto, urlpath, host, SBuf(login), port, request);
 }
 
 /**
  * Update request with parsed URI data.  If the request arg is
  * non-NULL, put parsed values there instead of allocating a new
  * HttpRequest.
  */
 static HttpRequest *
 urlParseFinish(const HttpRequestMethod&amp; method,
                const AnyP::ProtocolType protocol,
+               const char *const protoStr, // for unknown protocols
                const char *const urlpath,
                const char *const host,
                const SBuf &amp;login,
                const int port,
                HttpRequest *request)
 {
     if (NULL == request)
-        request = new HttpRequest(method, protocol, urlpath);
+        request = new HttpRequest(method, protocol, protoStr, urlpath);
     else {
-        request-&gt;initHTTP(method, protocol, urlpath);
+        request-&gt;initHTTP(method, protocol, protoStr, urlpath);
     }
 
     request-&gt;url.host(host);
     request-&gt;url.userInfo(login);
     request-&gt;url.port(port);
     return request;
 }
 
 static HttpRequest *
 urnParse(const HttpRequestMethod&amp; method, char *urn, HttpRequest *request)
 {
     debugs(50, 5, &quot;urnParse: &quot; &lt;&lt; urn);
     if (request) {
-        request-&gt;initHTTP(method, AnyP::PROTO_URN, urn + 4);
+        request-&gt;initHTTP(method, AnyP::PROTO_URN, &quot;urn&quot;, urn + 4);
         return request;
     }
 
-    return new HttpRequest(method, AnyP::PROTO_URN, urn + 4);
+    return new HttpRequest(method, AnyP::PROTO_URN, &quot;urn&quot;, urn + 4);
 }
 
 void
 URL::touch()
 {
     absolute_.clear();
     authorityHttp_.clear();
     authorityWithPort_.clear();
 }
 
 SBuf &amp;
 URL::authority(bool requirePort) const
 {
     if (authorityHttp_.isEmpty()) {
 
         // both formats contain Host/IP
         authorityWithPort_.append(host());
         authorityHttp_ = authorityWithPort_;
 
         // authorityForm_ only has :port if it is non-default
         authorityWithPort_.appendf(&quot;:%u&quot;,port());
         if (port() != getScheme().defaultPort())
             authorityHttp_ = authorityWithPort_;
     }
 
     return requirePort ? authorityWithPort_ : authorityHttp_;
 }
 
 SBuf &amp;
 URL::absolute() const
 {
     if (absolute_.isEmpty()) {
         // TODO: most URL will be much shorter, avoid allocating this much
         absolute_.reserveCapacity(MAX_URL);
 
-        absolute_.appendf(&quot;%s:&quot;, getScheme().c_str());
+        absolute_.append(getScheme().image());
+        absolute_.append(&quot;:&quot;,1);
         if (getScheme() != AnyP::PROTO_URN) {
             absolute_.append(&quot;//&quot;, 2);
             const bool omitUserInfo = getScheme() == AnyP::PROTO_HTTP ||
                                       getScheme() != AnyP::PROTO_HTTPS ||
                                       userInfo().isEmpty();
             if (!omitUserInfo) {
                 absolute_.append(userInfo());
                 absolute_.append(&quot;@&quot;, 1);
             }
             absolute_.append(authority());
         }
         absolute_.append(path());
     }
 
     return absolute_;
 }
 
 /** \todo AYJ: Performance: This is an *almost* duplicate of HttpRequest::effectiveRequestUri(). But elides the query-string.
  *        After copying it on in the first place! Would be less code to merge the two with a flag parameter.
  *        and never copy the query-string part in the first place
@@ -603,42 +609,43 @@
  */
 char *
 urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 {
 
     if (req-&gt;method.id() == Http::METHOD_CONNECT) {
         return (NULL);
     }
 
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
     if (req-&gt;url.getScheme() == AnyP::PROTO_URN) {
         // XXX: this is what the original code did, but it seems to break the
         // intended behaviour of this function. It returns the stored URN path,
         // not converting the given one into a URN...
         snprintf(urlbuf, MAX_URL, SQUIDSBUFPH, SQUIDSBUFPRINT(req-&gt;url.absolute()));
         return (urlbuf);
     }
 
     SBuf authorityForm = req-&gt;url.authority(); // host[:port]
-    size_t urllen = snprintf(urlbuf, MAX_URL, &quot;%<A HREF="s://">s://</A>&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH,
-                             req-&gt;url.getScheme().c_str(),
+    const SBuf &amp;scheme = req-&gt;url.getScheme().image();
+    size_t urllen = snprintf(urlbuf, MAX_URL, SQUIDSBUFPH &quot;://&quot; SQUIDSBUFPH &quot;%s&quot; SQUIDSBUFPH,
+                             SQUIDSBUFPRINT(scheme),
                              SQUIDSBUFPRINT(req-&gt;url.userInfo()),
                              !req-&gt;url.userInfo().isEmpty() ? &quot;@&quot; : &quot;&quot;,
                              SQUIDSBUFPRINT(authorityForm));
 
     // if the first char is '/' assume its a relative path
     // XXX: this breaks on scheme-relative URLs,
     // but we should not see those outside ESI, and rarely there.
     // XXX: also breaks on any URL containing a '/' in the query-string portion
     if (relUrl[0] == '/') {
         xstrncpy(&amp;urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
     } else {
         SBuf path = req-&gt;url.path();
         SBuf::size_type lastSlashPos = path.rfind('/');
 
         if (lastSlashPos == SBuf::npos) {
             // replace the whole path with the given bit(s)
             urlbuf[urllen] = '/';
             ++urllen;
             xstrncpy(&amp;urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
         } else {

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005993.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
	<LI>Next message: <A HREF="005997.html">[squid-dev] [PATCH] Do not hide important/critical messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5995">[ date ]</a>
              <a href="thread.html#5995">[ thread ]</a>
              <a href="subject.html#5995">[ subject ]</a>
              <a href="author.html#5995">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
