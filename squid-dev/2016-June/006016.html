<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] LockingPointer API update
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20LockingPointer%20API%20update&In-Reply-To=%3C23c55e50-fda7-b058-30c3-1cdafa511103%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006015.html">
   <LINK REL="Next"  HREF="006024.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] LockingPointer API update</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20LockingPointer%20API%20update&In-Reply-To=%3C23c55e50-fda7-b058-30c3-1cdafa511103%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] LockingPointer API update">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Jun 22 04:32:31 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006015.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
        <LI>Next message: <A HREF="006024.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6016">[ date ]</a>
              <a href="thread.html#6016">[ thread ]</a>
              <a href="subject.html#6016">[ subject ]</a>
              <a href="author.html#6016">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 22/06/2016 1:02 p.m., Alex Rousskov wrote:
&gt;<i> On 06/21/2016 04:00 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> With GnuTLS support it is sometimes more useful to use a TidyPointer
</I>&gt;&gt;<i> where a LockingPointer is used by OpenSSL.
</I>&gt;<i> 
</I>&gt;<i> Are there examples of such code in Squid trunk already? If yes, please
</I>&gt;<i> point to one or two to set the context. I could not quickly identify
</I>&gt;<i> them while looking at the patch... If not, perhaps you can cut-and-paste
</I>&gt;<i> them from your GnuTLS branch?
</I>
There are no examples in trunk that I know of. The partial GnuTLS
conversion does okay so far using -1 as LockingPointer lock type.

But in order to create actual locking for GnuTLS session details we have
to implement LockingPointer properly. Which will require either a nasty
looking hack to get LockingPointer to do what its supposed to in the one
case, or change the API and use the more appropriate pointer in all cases.

The session resume patch makes use of this. But does not technically
have to if we continue to define -1 or such locking type value as being
a special non-locking LockingPointer (yuck).

&gt;<i> 
</I>&gt;<i> IMHO, the following rule of thumb is relevant to this discussion:
</I>&gt;<i> Library-agnostic APIs (e.g., Security) must be the same, regardless of
</I>&gt;<i> the library Squid is being compiled with.
</I>&gt;<i> 
</I>&gt;<i> The implementation of those Library-agnostic APIs may depend on the
</I>&gt;<i> library, of course. It is also perfectly fine for GnuTLS-specific code
</I>&gt;<i> to use types that are different from types used by OpenSSL-specific
</I>&gt;<i> code. However, the library-agnostic APIs must remain the same.
</I>&gt;<i> 
</I>&gt;<i> For example, do not add and/or rely on something like this:
</I>&gt;<i> 
</I>&gt;<i>     namespace Security {
</I>&gt;<i>         #if USE_OPENSSL
</I>&gt;<i>             typedef LockingPointer&lt;...&gt; SessionPointer;
</I>&gt;<i>         #elif USE_GNUTLS
</I>&gt;<i>             typedef TidyPointer&lt;...&gt; SessionPointer;
</I>&gt;<i>         #endif
</I>&gt;<i>     };
</I>&gt;<i> 
</I>&gt;<i> unless LockingPointer and TidyPointer have the same API.
</I>&gt;<i> 
</I>&gt;<i> Violating this rule will lead to library-agnostic code that compiles and
</I>&gt;<i> works fine with one library but either does not compile or, worse, does
</I>&gt;<i> not work with the other library.
</I>&gt;<i> 
</I>&gt;<i> Please note that I am not trying to accuse the proposed patch of
</I>&gt;<i> violating the above rule! I just feel it is important to mention that
</I>&gt;<i> rule here because trunk code already violates that rule, the patch might
</I>&gt;<i> be trying to work around existing violations, and future patch
</I>&gt;<i> modifications may have to work with this rule.
</I>&gt;<i> 
</I>
Nod. Agreed.

&gt;<i> 
</I>&gt;<i> Now to the specific change being proposed:
</I>&gt;<i> 
</I>&gt;&gt;<i> This patch converts the LockingPointer resetAndLock() to a virtual
</I>&gt;&gt;<i> reset() so callers can use the right one without needing to care which
</I>&gt;&gt;<i> type of pointer they are handling.
</I>&gt;<i> 
</I>&gt;<i> The two LockingPointer methods, inherited reset(X) and &quot;direct&quot;
</I>&gt;<i> resetAndLock(X) give different results: The former does not lock X while
</I>&gt;<i> the latter does. Proposed renaming essentially removes one of the
</I>&gt;<i> methods. That can be done only if either
</I>&gt;<i> 
</I>&gt;<i>   A) nobody outside LockingPointer calls its inherited reset() method OR
</I>&gt;<i>   B) all such calls are buggy.
</I>&gt;<i> 
</I>&gt;<i> (A) is false -- there are ~15 external LockingPointer::reset() calls,
</I>&gt;<i> without even counting those that simply reset the pointer to nil. You
</I>&gt;<i> have not asserted (B) AFAICT, and I am worried that it might also be false.
</I>&gt;<i> 
</I>&gt;<i> I have attached a list of relevant trunk calls. It may be incomplete.
</I>&gt;<i> 
</I>
Thank you.

The two I saw were:

1) PeekingPeerConnector::handleServerCertificate() doing
serverBump-&gt;serverCert.reset(serverCert.release())

On much closer inspection it appears not a bug. But is doing move
semantics without a move operator relying heavily on specific
implementation detail of TidyPointer API exposure.


2) PeekingPeerConnector::serverCertificateVerified() doing two different
reset() vs resetAndLock() depending on the data source.

The OpenSSL docs do say the call increments a reference count itself.
But I still think this is leaking. Since we explicitly unlock on
destruct as well as calling the necessary free API method in OpenSSL.


&gt;<i> 
</I>&gt;&gt;<i> Doing this has already uncovered two instances of the
</I>&gt;&gt;<i> TidyPointer::reset() being wrongly used on cert LockingPointer objects.
</I>&gt;<i> 
</I>&gt;<i> AFAIK, a LockingPointer::reset(X) call is legitimate if something locked
</I>&gt;<i> X for us and/or the previous owner is losing ownership without
</I>&gt;<i> decreasing the lock count. Can you point to the two instances you found
</I>&gt;<i> please? If those two are indeed bugs, they should be fixed separately,
</I>&gt;<i> before your changes go in IMO -- we should record where those bugs were.
</I>&gt;<i> 
</I>&gt;<i> There are also LockingPointer::reset(nil) calls but those are benign and
</I>&gt;<i> should be replaced with clear() calls that are faster and, well, clearer.
</I>&gt;<i> 
</I>
Nod.


&gt;<i> 
</I>&gt;&gt;<i> There may be more hidden away
</I>&gt;<i> 
</I>&gt;<i> Indeed! The ability to _accidentally_ call LockingPointer::reset() is a
</I>&gt;<i> major LockingPointer API bug IMO. And the fact that we cannot be sure
</I>&gt;<i> whether the existing external LockingPointer::reset() calls are
</I>&gt;<i> accidental is a lesser LockingPointer API bug.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> There are two sane ways to proceed AFAICT:
</I>&gt;<i> 
</I>&gt;<i> 1. Assert that all external LockingPointer::reset() calls are bugs.
</I>&gt;<i>    Hide LockingPointer::reset() from external callers and then
</I>&gt;<i>    fix &quot;LockingPointer&lt;&gt;::reset(T*) is private&quot; compilation errors,
</I>&gt;<i>    arriving at LockingPointer with a single reset method.
</I>&gt;<i>    Revisit your patch: Do other differences in two classes APIs matter?
</I>&gt;<i> 
</I>&gt;<i> 2. Assert that some external LockingPointer::reset() calls are needed.
</I>&gt;<i>    Provide LockingPointer::resetWithoutLocking() instead,
</I>&gt;<i>    hide LockingPointer::reset() from external callers, and
</I>&gt;<i>    fix &quot;LockingPointer&lt;&gt;::reset(T*) is private&quot; compilation errors.
</I>&gt;<i>    Reject your patch (because LockingPointer has two reset methods) and
</I>&gt;<i>    study Security/GnuTLS needs to propose a different solution.
</I>&gt;<i> 
</I>&gt;<i> If it turns out that some external LockingPointer::reset() calls are
</I>&gt;<i> needed, I would be happy to try to help you find a different solution.
</I>&gt;<i> 
</I>
I'm trying #1, with an eye on #2 if it runs into trouble or much
complexity getting down to one reset() method.

Amos

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006015.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
	<LI>Next message: <A HREF="006024.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6016">[ date ]</a>
              <a href="thread.html#6016">[ thread ]</a>
              <a href="subject.html#6016">[ subject ]</a>
              <a href="author.html#6016">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
