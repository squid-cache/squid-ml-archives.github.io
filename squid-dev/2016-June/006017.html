<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] GnuTLS session resume
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20GnuTLS%20session%20resume&In-Reply-To=%3C5d1b3524-f558-a6c7-7c01-86acbb41e6c0%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006023.html">
   <LINK REL="Next"  HREF="006048.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] GnuTLS session resume</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20GnuTLS%20session%20resume&In-Reply-To=%3C5d1b3524-f558-a6c7-7c01-86acbb41e6c0%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] GnuTLS session resume">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Jun 22 04:42:45 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006023.html">[squid-dev] Dealing with RegisteredHeadersHash.gperf
</A></li>
        <LI>Next message: <A HREF="006048.html">[squid-dev] [PATCH] GnuTLS session resume
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6017">[ date ]</a>
              <a href="thread.html#6017">[ thread ]</a>
              <a href="subject.html#6017">[ subject ]</a>
              <a href="author.html#6017">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch shuffles session resume to libsecurity and implements it for
GnuTLS.

As-is it relies on the previous LockingPointer API patch redesign for a
generic reset() method.

Amos
-------------- next part --------------
=== modified file 'src/CachePeer.cc'
--- src/CachePeer.cc	2016-01-01 00:12:18 +0000
+++ src/CachePeer.cc	2016-06-21 10:06:55 +0000
@@ -25,41 +25,40 @@
     typelist(NULL),
     access(NULL),
     weight(1),
     basetime(0),
 #if USE_CACHE_DIGESTS
     digest(NULL),
     digest_url(NULL),
 #endif
     tcp_up(0),
     n_addresses(0),
     rr_count(0),
     next(NULL),
     testing_now(false),
     login(NULL),
     connect_timeout(0),
     connect_fail_limit(0),
     max_conn(0),
     domain(NULL),
 #if USE_OPENSSL
     sslContext(NULL),
-    sslSession(NULL),
 #endif
     front_end_https(0),
     connection_auth(2 /* auto */)
 {
     memset(&amp;stats, 0, sizeof(stats));
     stats.logged_state = PEER_ALIVE;
 
     memset(&amp;icp, 0, sizeof(icp));
     icp.port = CACHE_ICP_PORT;
     icp.version = ICP_VERSION_CURRENT;
 
 #if USE_HTCP
     memset(&amp;htcp, 0, sizeof(htcp));
 #endif
     memset(&amp;options, 0, sizeof(options));
     memset(&amp;mcast, 0, sizeof(mcast));
     memset(&amp;carp, 0, sizeof(carp));
 #if USE_AUTH
     memset(&amp;userhash, 0, sizeof(userhash));
 #endif
@@ -85,26 +84,23 @@
 
 #if USE_CACHE_DIGESTS
     cbdataReferenceDone(digest);
     xfree(digest_url);
 #endif
 
     delete next;
 
     xfree(login);
 
     delete standby.pool;
 
     // the mgr job will notice that its owner is gone and stop
     PeerPoolMgr::Checkpoint(standby.mgr, &quot;peer gone&quot;);
 
     xfree(domain);
 
 #if USE_OPENSSL
     if (sslContext)
         SSL_CTX_free(sslContext);
-
-    if (sslSession)
-        SSL_SESSION_free(sslSession);
 #endif
 }
 

=== modified file 'src/CachePeer.h'
--- src/CachePeer.h	2016-01-01 00:12:18 +0000
+++ src/CachePeer.h	2016-06-21 10:06:56 +0000
@@ -167,30 +167,28 @@
         unsigned int hash;
         double load_multiplier;
         double load_factor; /* normalized weight value */
     } sourcehash;
 
     char *login;        /* Proxy authorization */
     time_t connect_timeout;
     int connect_fail_limit;
     int max_conn;
     struct {
         PconnPool *pool; ///&lt; idle connection pool for this peer
         CbcPointer&lt;PeerPoolMgr&gt; mgr; ///&lt; pool manager
         int limit; ///&lt; the limit itself
         bool waitingForClose; ///&lt; a conn must close before we open a standby conn
     } standby; ///&lt; optional &quot;cache_peer standby=limit&quot; feature
     char *domain;       /* Forced domain */
 
     /// security settings for peer connection
     Security::PeerOptions secure;
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
     int front_end_https;
     int connection_auth;
 };
 
 #endif /* SQUID_CACHEPEER_H_ */
 

=== modified file 'src/adaptation/icap/ServiceRep.cc'
--- src/adaptation/icap/ServiceRep.cc	2016-01-15 06:47:59 +0000
+++ src/adaptation/icap/ServiceRep.cc	2016-06-21 10:06:56 +0000
@@ -17,43 +17,40 @@
 #include &quot;adaptation/icap/ServiceRep.h&quot;
 #include &quot;base/TextException.h&quot;
 #include &quot;comm/Connection.h&quot;
 #include &quot;ConfigParser.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;fde.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;HttpReply.h&quot;
 #include &quot;ip/tools.h&quot;
 #include &quot;SquidConfig.h&quot;
 #include &quot;SquidTime.h&quot;
 
 #define DEFAULT_ICAP_PORT   1344
 #define DEFAULT_ICAPS_PORT 11344
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &amp;svcCfg):
     AsyncJob(&quot;Adaptation::Icap::ServiceRep&quot;), Adaptation::Service(svcCfg),
     sslContext(NULL),
-#if USE_OPENSSL
-    sslSession(NULL),
-#endif
     theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
     connOverloadReported(false),
     theIdleConns(NULL),
     isSuspended(0), notifying(false),
     updateScheduled(false),
     wasAnnouncedUp(true), // do not announce an &quot;up&quot; service at startup
     isDetached(false)
 {
     setMaxConnections();
     theIdleConns = new IdleConnList(&quot;ICAP Service&quot;, NULL);
 }
 
 Adaptation::Icap::ServiceRep::~ServiceRep()
 {
     delete theIdleConns;
     Must(!theOptionsFetcher);
     delete theOptions;
 }

=== modified file 'src/adaptation/icap/ServiceRep.h'
--- src/adaptation/icap/ServiceRep.h	2016-01-01 00:12:18 +0000
+++ src/adaptation/icap/ServiceRep.h	2016-06-21 10:06:56 +0000
@@ -94,43 +94,41 @@
 
     void noteNewWaiter() {theAllWaiters++;} ///&lt; New xaction waiting for service to be up or available
     void noteGoneWaiter(); ///&lt; An xaction is not waiting any more for service to be available
     bool existWaiters() const {return (theAllWaiters &gt; 0);} ///&lt; if there are xactions waiting for the service to be available
 
     //AsyncJob virtual methods
     virtual bool doneAll() const { return Adaptation::Initiator::doneAll() &amp;&amp; false;}
     virtual void callException(const std::exception &amp;e);
 
     virtual void detach();
     virtual bool detached() const;
 
 public: // treat these as private, they are for callbacks only
     void noteTimeToUpdate();
     void noteTimeToNotify();
 
     // receive either an ICAP OPTIONS response header or an abort message
     virtual void noteAdaptationAnswer(const Answer &amp;answer);
 
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
 private:
     // stores Prepare() callback info
 
     struct Client {
         Pointer service; // one for each client to preserve service
         AsyncCall::Pointer callback;
     };
 
     typedef std::vector&lt;Client&gt; Clients;
     // TODO: rename to theUpWaiters
     Clients theClients; // all clients waiting for a call back
 
     Options *theOptions;
     CbcPointer&lt;Adaptation::Initiate&gt; theOptionsFetcher; // pending ICAP OPTIONS transaction
     time_t theLastUpdate; // time the options were last updated
 
     /// FIFO queue of xactions waiting for a connection slot and not yet notified
     /// about it; xaction is removed when notification is scheduled
     std::deque&lt;Client&gt; theNotificationWaiters;

=== modified file 'src/adaptation/icap/Xaction.cc'
--- src/adaptation/icap/Xaction.cc	2016-02-02 15:39:23 +0000
+++ src/adaptation/icap/Xaction.cc	2016-06-21 12:14:42 +0000
@@ -708,60 +708,53 @@
 {
     return false;
 }
 
 #if USE_OPENSSL
 Security::SessionPtr
 Ssl::IcapPeerConnector::initializeSsl()
 {
     auto ssl = Ssl::PeerConnector::initializeSsl();
     if (!ssl)
         return nullptr;
 
     assert(!icapService-&gt;cfg().secure.sslDomain.isEmpty());
     SBuf *host = new SBuf(icapService-&gt;cfg().secure.sslDomain);
     SSL_set_ex_data(ssl, ssl_ex_index_server, host);
 
     ACLFilledChecklist *check = (ACLFilledChecklist *)SSL_get_ex_data(ssl, ssl_ex_index_cert_error_check);
     if (check)
         check-&gt;dst_peer_name = *host;
 
-    if (icapService-&gt;sslSession)
-        SSL_set_session(ssl, icapService-&gt;sslSession);
+    Security::GetSessionResumeData(Security::SessionPointer(ssl), icapService-&gt;sslSession);
 
     return ssl;
 }
 
 void
 Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
 {
     if (error)
         return;
 
     const int fd = serverConnection()-&gt;fd;
-    auto ssl = fd_table[fd].ssl.get();
-    assert(ssl);
-    if (!SSL_session_reused(ssl)) {
-        if (icapService-&gt;sslSession)
-            SSL_SESSION_free(icapService-&gt;sslSession);
-        icapService-&gt;sslSession = SSL_get1_session(ssl);
-    }
+    Security::GetSessionResumeData(fd_table[fd].ssl, icapService-&gt;sslSession);
 }
 
 void
 Adaptation::Icap::Xaction::handleSecuredPeer(Security::EncryptorAnswer &amp;answer)
 {
     Must(securer != NULL);
     securer = NULL;
 
     if (closer != NULL) {
         if (answer.conn != NULL)
             comm_remove_close_handler(answer.conn-&gt;fd, closer);
         else
             closer-&gt;cancel(&quot;securing completed&quot;);
         closer = NULL;
     }
 
     if (answer.error.get()) {
         if (answer.conn != NULL)
             answer.conn-&gt;close();
         debugs(93, 2, typeName &lt;&lt;

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2016-05-20 13:20:27 +0000
+++ src/client_side.cc	2016-06-21 10:06:56 +0000
@@ -2640,41 +2640,41 @@
         /* NOTREACHED */
     }
     return 1;
 }
 
 /** negotiate an SSL connection */
 static void
 clientNegotiateSSL(int fd, void *data)
 {
     ConnStateData *conn = (ConnStateData *)data;
     X509 *client_cert;
     auto ssl = fd_table[fd].ssl.get();
 
     int ret;
     if ((ret = Squid_SSL_accept(conn, clientNegotiateSSL)) &lt;= 0) {
         if (ret &lt; 0) // An error
             conn-&gt;clientConnection-&gt;close();
         return;
     }
 
-    if (SSL_session_reused(ssl)) {
+    if (Security::SessionIsResumed(fd_table[fd].ssl)) {
         debugs(83, 2, &quot;clientNegotiateSSL: Session &quot; &lt;&lt; SSL_get_session(ssl) &lt;&lt;
                &quot; reused on FD &quot; &lt;&lt; fd &lt;&lt; &quot; (&quot; &lt;&lt; fd_table[fd].ipaddr &lt;&lt; &quot;:&quot; &lt;&lt; (int)fd_table[fd].remote_port &lt;&lt; &quot;)&quot;);
     } else {
         if (Debug::Enabled(83, 4)) {
             /* Write out the SSL session details.. actually the call below, but
              * OpenSSL headers do strange typecasts confusing GCC.. */
             /* PEM_write_SSL_SESSION(debug_log, SSL_get_session(ssl)); */
 #if defined(OPENSSL_VERSION_NUMBER) &amp;&amp; OPENSSL_VERSION_NUMBER &gt;= 0x00908000L
             PEM_ASN1_write((i2d_of_void *)i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, debug_log, (char *)SSL_get_session(ssl), NULL,NULL,0,NULL,NULL);
 
 #elif (ALLOW_ALWAYS_SSL_SESSION_DETAIL == 1)
 
             /* When using gcc 3.3.x and OpenSSL 0.9.7x sometimes a compile error can occur here.
             * This is caused by an unpredicatble gcc behaviour on a cast of the first argument
             * of PEM_ASN1_write(). For this reason this code section is disabled. To enable it,
             * define ALLOW_ALWAYS_SSL_SESSION_DETAIL=1.
             * Because there are two possible usable cast, if you get an error here, try the other
             * commented line. */
 
             PEM_ASN1_write((int(*)())i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, debug_log, (char *)SSL_get_session(ssl), NULL,NULL,0,NULL,NULL);
=== modified file 'src/security/Session.cc'
--- src/security/Session.cc	2016-02-17 21:03:29 +0000
+++ src/security/Session.cc	2016-06-21 15:21:41 +0000
@@ -1,38 +1,77 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;anyp/PortCfg.h&quot;
 #include &quot;base/RunnersRegistry.h&quot;
 #include &quot;ipc/MemMap.h&quot;
 #include &quot;security/Session.h&quot;
 #include &quot;SquidConfig.h&quot;
 
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
+bool
+Security::SessionIsResumed(const Security::SessionPointer &amp;s)
+{
+    return
+#if USE_OPENSSL
+        SSL_session_reused(s.get()) == 1;
+#elif USE_GNUTLS
+        gnutls_session_is_resumed(s.get()) != 0;
+#else
+        false;
+#endif
+}
+
+void
+Security::GetSessionResumeData(const Security::SessionPointer &amp;s, Security::SessionStatePointer &amp;data)
+{
+    if (!SessionIsResumed(s)) {
+#if USE_OPENSSL
+        data.reset(SSL_get1_session(s.get()));
+#elif USE_GNUTLS
+        gnutls_datum_t *tmp = nullptr;
+        (void)gnutls_session_get_data2(s.get(), tmp);
+        data.reset(tmp);
+#endif
+    }
+}
+
+void
+Security::SetSessionResumeData(const Security::SessionPtr &amp;s, const Security::SessionStatePointer &amp;data)
+{
+    if (s) {
+#if USE_OPENSSL
+        (void)SSL_set_session(s, data.get());
+#elif USE_GNUTLS
+        (void)gnutls_session_set_data(s, data-&gt;data, data-&gt;size);
+#endif
+    }
+}
+
 static bool
 isTlsServer()
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != nullptr; s = s-&gt;next) {
         if (s-&gt;secure.encryptTransport)
             return true;
         if (s-&gt;flags.tunnelSslBumping)
             return true;
     }
 
     return false;
 }
 
 void
 initializeSessionCache()
 {
 #if USE_OPENSSL
     // Check if the MemMap keys and data are enough big to hold
     // session ids and session data
     assert(SSL_SESSION_ID_SIZE &gt;= MEMMAP_SLOT_KEY_SIZE);

=== modified file 'src/security/Session.h'
--- src/security/Session.h	2016-02-13 12:12:10 +0000
+++ src/security/Session.h	2016-06-21 10:06:56 +0000
@@ -14,40 +14,59 @@
 
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 #endif
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_GNUTLS_H
 #include &lt;gnutls/gnutls.h&gt;
 #endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
 typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer&lt;SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL&gt; SessionPointer;
 
+typedef SSL_SESSION* SessionStatePtr;
+CtoCpp1(SSL_SESSION_free, SSL_SESSION *);
+typedef LockingPointer&lt;SSL_SESSION, Security::SSL_SESSION_free_cpp, CRYPTO_LOCK_SSL_SESSION&gt; SessionStatePointer;
+
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
 CtoCpp1(gnutls_deinit, gnutls_session_t);
 // TODO: Convert to Locking pointer.
 // Locks can be implemented attaching locks counter to gnutls_session_t
 // objects using the gnutls_session_set_ptr()/gnutls_session_get_ptr ()
 // library functions
 typedef TidyPointer&lt;struct gnutls_session_int, Security::gnutls_deinit_cpp&gt; SessionPointer;
 
+typedef gnutls_datum_t *SessionStatePtr;
+CtoCpp1(gnutls_free, gnutls_datum_t *);
+typedef TidyPointer&lt;gnutls_datum_t, Security::gnutls_free_cpp&gt; SessionStatePointer;
+
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
 typedef TidyPointer&lt;void, nullptr&gt; SessionPointer;
+typedef TidyPointer&lt;void, nullptr&gt; SessionStatePointer;
 
 #endif
 
+/// whether the session is a resumed one
+bool SessionIsResumed(const Security::SessionPointer &amp;);
+
+/// Retrieve the data needed to resume this session on a later connection
+void GetSessionResumeData(const Security::SessionPointer &amp;, Security::SessionStatePointer &amp;);
+
+/// Set the data for resuming a previous session.
+/// Needs to be done before using the SessionPointer for a handshake.
+void SetSessionResumeData(const Security::SessionPtr &amp;, const Security::SessionStatePointer &amp;);
+
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
 

=== modified file 'src/ssl/BlindPeerConnector.cc'
--- src/ssl/BlindPeerConnector.cc	2016-01-27 16:56:38 +0000
+++ src/ssl/BlindPeerConnector.cc	2016-06-21 10:06:56 +0000
@@ -29,54 +29,49 @@
     return ::Config.ssl_client.sslContext;
 }
 
 Security::SessionPtr
 Ssl::BlindPeerConnector::initializeSsl()
 {
     auto ssl = Ssl::PeerConnector::initializeSsl();
     if (!ssl)
         return nullptr;
 
     if (const CachePeer *peer = serverConnection()-&gt;getPeer()) {
         assert(peer);
 
         // NP: domain may be a raw-IP but it is now always set
         assert(!peer-&gt;secure.sslDomain.isEmpty());
 
         // const loss is okay here, ssl_ex_index_server is only read and not assigned a destructor
         SBuf *host = new SBuf(peer-&gt;secure.sslDomain);
         SSL_set_ex_data(ssl, ssl_ex_index_server, host);
 
-        if (peer-&gt;sslSession)
-            SSL_set_session(ssl, peer-&gt;sslSession);
+        Security::SetSessionResumeData(ssl, peer-&gt;sslSession);
     } else {
         SBuf *hostName = new SBuf(request-&gt;url.host());
         SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
     }
 
     return ssl;
 }
 
 void
 Ssl::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
 {
     if (error) {
         // XXX: forward.cc calls peerConnectSucceeded() after an OK TCP connect but
         // we call peerConnectFailed() if SSL failed afterwards. Is that OK?
         // It is not clear whether we should call peerConnectSucceeded/Failed()
         // based on TCP results, SSL results, or both. And the code is probably not
         // consistent in this aspect across tunnelling and forwarding modules.
         if (CachePeer *p = serverConnection()-&gt;getPeer())
             peerConnectFailed(p);
         return;
     }
 
-    const int fd = serverConnection()-&gt;fd;
-    Security::SessionPtr ssl = fd_table[fd].ssl.get();
-    if (serverConnection()-&gt;getPeer() &amp;&amp; !SSL_session_reused(ssl)) {
-        if (serverConnection()-&gt;getPeer()-&gt;sslSession)
-            SSL_SESSION_free(serverConnection()-&gt;getPeer()-&gt;sslSession);
-
-        serverConnection()-&gt;getPeer()-&gt;sslSession = SSL_get1_session(ssl);
+    if (auto *peer = serverConnection()-&gt;getPeer()) {
+        const int fd = serverConnection()-&gt;fd;
+        Security::GetSessionResumeData(fd_table[fd].ssl, peer-&gt;sslSession);
     }
 }
 

</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006023.html">[squid-dev] Dealing with RegisteredHeadersHash.gperf
</A></li>
	<LI>Next message: <A HREF="006048.html">[squid-dev] [PATCH] GnuTLS session resume
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6017">[ date ]</a>
              <a href="thread.html#6017">[ thread ]</a>
              <a href="subject.html#6017">[ subject ]</a>
              <a href="author.html#6017">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
