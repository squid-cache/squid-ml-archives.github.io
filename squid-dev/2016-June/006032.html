<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] LockingPointer API update
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20LockingPointer%20API%20update&In-Reply-To=%3C08196bf2-6626-79d0-7446-bb643243914b%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006031.html">
   <LINK REL="Next"  HREF="006029.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] LockingPointer API update</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20LockingPointer%20API%20update&In-Reply-To=%3C08196bf2-6626-79d0-7446-bb643243914b%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] LockingPointer API update">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Jun 23 02:13:05 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006031.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
        <LI>Next message: <A HREF="006029.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6032">[ date ]</a>
              <a href="thread.html#6032">[ thread ]</a>
              <a href="subject.html#6032">[ subject ]</a>
              <a href="author.html#6032">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 23/06/2016 4:58 a.m., Alex Rousskov wrote:
&gt;<i> On 06/22/2016 05:29 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 22/06/2016 10:42 p.m., Christos Tsantilas wrote:
</I>&gt;&gt;&gt;<i> On 06/22/2016 07:32 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> 1) PeekingPeerConnector::handleServerCertificate() doing
</I>&gt;&gt;&gt;&gt;<i> serverBump-&gt;serverCert.reset(serverCert.release())
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> On much closer inspection it appears not a bug. But is doing move
</I>&gt;&gt;&gt;&gt;<i> semantics without a move operator relying heavily on specific
</I>&gt;&gt;&gt;&gt;<i> implementation detail of TidyPointer API exposure.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> This is not bug. The call
</I>&gt;&gt;&gt;<i> newServerCertPointer.reset(oldServerCertPointer.release())
</I>&gt;&gt;&gt;<i> just moves the X509 object with the current locks to the
</I>&gt;&gt;&gt;<i> newServerCertPointer.
</I>&gt;<i> 
</I>&gt;&gt;<i> Yeah. Thats move semantics.
</I>&gt;<i> 
</I>&gt;<i> Agreed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> LockingPointer has a move assignment operator for doing that in clearer
</I>&gt;&gt;<i> way now in trunk - and 3.5 when built with C++11 compiler.
</I>&gt;<i> 
</I>&gt;<i> At the risk of sounding like a broken record, I have to note that a move
</I>&gt;<i> assignment operator is an _optimization_. It is _not_ a clearer way of
</I>&gt;<i> doing anything. It is a cheaper way. It is not triggered except in some
</I>&gt;<i> special circumstances [that are usually absent in the current
</I>&gt;<i> LockingPointer code]. A move method alone is neither necessary nor
</I>&gt;<i> usually sufficient for move semantics support.
</I>&gt;<i> 
</I>&gt;<i> Even if all non-clearing LockingPointer::reset() calls are there to
</I>&gt;<i> _move_ things, we still cannot merge reset() and resetAndLock() because
</I>&gt;<i> it would be trivial for the code to accidentally call the assignment
</I>&gt;<i> operator (that locks) instead of the move assignment operator (that does
</I>&gt;<i> not lock).
</I>
As you said the actual move is an optimization. If something breaks by
doing a copy and extra lock - then its not suitabel for using
LockingPointer in the first place.

The lines (quoted below here) which sparked this side discussion can
clearly be implemented with either assignment operator and both work
properly.

* All that happens on the copy-assign &quot;slow&quot; path is one extra
lock+unlock action.

* the use of constructor and assign [ X = construct(Y); ] is one of the
patterns the compiler deduces to be a move operator.

So the below simple logic should compile to the same thing the arcane
mix of reset+release did.

&gt;<i> 
</I>&gt;&gt;<i> The above code becomes:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   Security::CertPointer serverCert;
</I>&gt;&gt;<i>   if (...) {
</I>&gt;&gt;<i>     // We need to lock here because the destructor of
</I>&gt;&gt;<i>     // serverCert will call X509_free and decrease the lock
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     // operator =() copy-assign does the lock stuff
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     serverCert = serverBump-&gt;serverCert;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   } else {
</I>&gt;&gt;<i>     // We do not need to lock here, the SSL_get_peer_certificate
</I>&gt;&gt;<i>     // already increases the clock counter and we have to
</I>&gt;&gt;<i>     // free with X509_free.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     // CertPointer() constructor builds object without locking it
</I>&gt;&gt;<i>     // assuming SSL_get_peer_certificate() did the lock for it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     // operator =() move-assign or copy-assign does the lock stuff
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     serverCert = Security::CertPointer(SSL_get_peer_certificate(ssl)));
</I>&gt;&gt;<i>   }
</I>&gt;&gt;<i>   // serverCert::~serverCert() called on function
</I>&gt;&gt;<i>   // leave, calling X509_free.
</I>&gt;<i> 
</I>&gt;<i> As Christos has said or implied, this approach assumes that
</I>&gt;<i> Security::CertPointer is an assignable pointer (e.g., LockingPointer)
</I>&gt;<i> and not a TidyPointer that does not have an assignment operator (by
</I>&gt;<i> design). There is nothing wrong with that approach per se, but this is
</I>&gt;<i> not what your patch (and approach known as #1) was about.
</I>&gt;<i> 
</I>
Nod. I am taking advantage of the fact that currently GnuTLS does not do
bumping so this code is wrapped in USE_OPENSSL.

I dont't see that as a problem since the CertPointer type will need to
be converted to GnuTLS-enabled LockingPointer in order for GnuTLS to use
the feature this code is about.

My experimental build the past few hours has confirmed that all current
LockingPointer uses are OpenSSL-specific or already using a temporary
'-1' LockingPointer for GnuTLS.


&gt;<i> If you are switching to approach #2,
</I>
I'm currently experimenting with the ideas to see what a transition
needs to look like.

&gt;<i> then I agree with Christos that we
</I>&gt;<i> should remove TidyPointer as a LockingPointer parent.
</I>
Doing some experimental builds of that now. Not quite a full split, but
with TidyPointer as protected rather than public inheritence.

&gt;<i> LockingPointer
</I>&gt;<i> should use TidyPointer as the type of its pointer data member instead:
</I>&gt;<i> 
</I>&gt;<i>   template &lt;...&gt;
</I>&gt;<i>   class LockingPointer {
</I>&gt;<i>   ...
</I>&gt;<i>   private:
</I>&gt;<i>       TidyPointer&lt;...&gt; pointer; ///&lt; owns the object we lock
</I>&gt;<i>   };
</I>&gt;<i> 
</I>
Hmm. TidyPointer alone is essentially a std::unique_ptr with custom
delete. We can probably drop TidyPointer from trunk entirely.

&gt;<i> 
</I>&gt;&gt;<i> But, the GnuTLS builds will need an equivalent Pointer with a different
</I>&gt;&gt;<i> lock action to handle session pointers.
</I>&gt;<i> 
</I>&gt;<i> Besides the TidyPointer disassociation sketched above, I suggest
</I>&gt;<i> replacing the &quot;int lock&quot; LockingPointer template parameter with a
</I>&gt;<i> locking function parameter. With some [trivial] wrappers for OpenSSL's
</I>&gt;<i> &quot;CRYPTO_add(..., lock)&quot;, it might work well for both GnuTLS and OpenSSL
</I>&gt;<i> needs.
</I>&gt;<i> 
</I>
Was just giving that some serious consideration before your mail came
in. Its on my list of experiments to try.

Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006031.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
	<LI>Next message: <A HREF="006029.html">[squid-dev] [PATCH] LockingPointer API update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6032">[ date ]</a>
              <a href="thread.html#6032">[ thread ]</a>
              <a href="subject.html#6032">[ subject ]</a>
              <a href="author.html#6032">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
