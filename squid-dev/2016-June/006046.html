<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] TidyPointer removal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3Cfe8bb6f6-71ac-be4c-8bbd-83428bdf6140%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006045.html">
   <LINK REL="Next"  HREF="006047.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] TidyPointer removal</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20TidyPointer%20removal&In-Reply-To=%3Cfe8bb6f6-71ac-be4c-8bbd-83428bdf6140%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] TidyPointer removal">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Jun 29 11:45:12 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006045.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
        <LI>Next message: <A HREF="006047.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6046">[ date ]</a>
              <a href="thread.html#6046">[ thread ]</a>
              <a href="subject.html#6046">[ subject ]</a>
              <a href="author.html#6046">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Attached patch completes everything except the LockingPointer parts, I
think.
Can it get some testing please while I continue on with that latter ?


On 29/06/2016 1:03 p.m., Alex Rousskov wrote:
&gt;<i> On 06/28/2016 08:52 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 28/06/2016 7:36 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 06/27/2016 04:35 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> This splits TidyPointer and LockingPointer by removing the inheritence
</I>&gt;&gt;&gt;&gt;<i> and copying the needed TidyPointer code into the LockingPointer as-is.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Why start duplicating TidyPointer/unique_ptr functionality in
</I>&gt;&gt;&gt;<i> LockingPointer?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> So that LockingPointer is not affected by the unique_ptr change. 
</I>&gt;<i> 
</I>&gt;<i> That does not compute for me: Clearly, LockingPointer _is_ affected by
</I>&gt;<i> the unique_ptr change in your patch. And if you meant that
</I>&gt;<i> LockingPointer _callers_ should not be affected, then using unique_ptr
</I>&gt;<i> for LockingPointer _implementation_ will not affect LockingPointer
</I>&gt;<i> callers AFAICT.
</I>
Okay. How do we copy-construct a LockingPointer from another
LockingPointer with unique_ptr for values?
 unique_ptr requires they be unique, and states undefined behaviour if
any two are constructed from the same raw pointer value.

It only works for OpenSSL because the destructor does the unlocking.

&gt;<i> 
</I>&gt;&gt;<i> Without that LockingPointer would inherit from std::unique_ptr.
</I>&gt;<i> 
</I>&gt;<i> I hope you can avoid duplication without making unique_ptr a
</I>&gt;<i> LockingPointer parent. You can use unique_ptr for the LockingPointer
</I>&gt;<i> data member.
</I>&gt;<i> 
</I>
Can you clarify please what you are referring to exactly when you use
the word &quot;duplication&quot; ?
which piece(s) of this patches LockingPointer code is duplicated ?


&gt;<i> 
</I>&gt;&gt;&gt;<i> Can we [continue to] use unique_ptr in LockingPointer
</I>&gt;&gt;&gt;<i> instead, now as a data member?
</I>&gt;<i> 
</I>&gt;&gt;<i> I found we cannot. LockingPointer is doing too much non-unique_ptr
</I>&gt;&gt;<i> things with the locks. It is like a demented cross between unique_ptr,
</I>&gt;&gt;<i> shared_ptr and cbdata.
</I>&gt;<i> 
</I>&gt;<i> This does not compute for me: You have claimed that TidyPointer, the
</I>&gt;<i> former LockingPointer parent, is essentially a unique_ptr. I agreed with
</I>&gt;<i> that claim. Now you are claiming that you cannot use unique_ptr as a
</I>&gt;<i> private data member of LockingPointer because LockingPointer does
</I>&gt;<i> unusual things. Since you are not changing what LockingPointer does, I
</I>&gt;<i> would expect LockingPointer to [continue to] be able to use
</I>&gt;<i> TidyPointer/unique_ptr, regardless of how unusual LockingPointer is.
</I>&gt;<i> Both claims cannot be true at the same time AFAICT...
</I>
And yet they are. That is the irrational situation I'm working to fix here.
TidyPointer took a raw* and did unique_ptr things to it.
LockingPointer took a raw* and sometimes did exclusively unique_ptr
things to it and sometimes used OpenSSL locks to make it shared /
ref-count then kept doing unique_ptr things to it (arg!).

Some caller code assumes its working with a unique_ptr (that logic doing
explicit move semantics I pointed out in the other thread). And some
caller code assumes its handling a shared pointer.

Dealing with that LockingPointer situation is still away in the future
for this patch. The previous and attached versions are just about
dropping TidyPointer into the abyss.

&gt;<i> 
</I>&gt;<i> To make progress, I will rephrase the question: What unique_ptr
</I>&gt;<i> properties prevent you from using it for LockingPointer::raw?
</I>&gt;<i> 
</I>
The ability to copy-assign a unique_ptr and come out of it with two
pointers both set to the same *-pointer value and guaranteed not to
clobber each others memory.

We can get it to compile by doing raw.reset(o.raw.get()); but that is
documented as resulting in undefined behaviour for both unique_ptr. It
will likely only work for OpenSSL by way of the resulting two unique_ptr
Deleter's doing the unlock semantic instead of actual delete. We need it
to work for non-OpenSSL libraries too and situatinos like xfree() /
tidyFree() where the object deallocator knows nothing about locks.

This is next-stage discussion though. One you are okay with the rest of
the attached patch.


&gt;<i> 
</I>&gt;&gt;&gt;<i> Replacing custom TidyPointer with standard unique_ptr is a welcomed
</I>&gt;&gt;&gt;<i> improvement that can and should be accepted. Whether you commit those
</I>&gt;&gt;&gt;<i> [polished] changes before or while fixing &quot;LockingPointer issues&quot; is
</I>&gt;&gt;&gt;<i> your call. However, this reasoning alone does not make code duplication
</I>&gt;&gt;&gt;<i> necessary or acceptable.
</I>&gt;<i> 
</I>&gt;&gt;<i> Nod. Its not exactly duplication though. It was cut-n-paste, not
</I>&gt;&gt;<i> copy-n-paste. So if anything is duplicated it was beforehand too, just
</I>&gt;&gt;<i> not so obviousy so.
</I>&gt;<i> 
</I>&gt;<i> TidyPointer was certainly duplicating unique_ptr. IIRC, there was a
</I>&gt;<i> valid reason for that functionality duplication -- Squid did not have a
</I>&gt;<i> reliable access to unique_ptr when TidyPointer was written. Note that
</I>&gt;<i> there was no code duplication from Squid point of view; there was a
</I>&gt;<i> &quot;reinventing the wheel&quot; problem instead.
</I>
Yes. We agree on that.

&gt;<i> 
</I>&gt;<i> Now, when replacing TidyPointer with the now-available std::unique_ptr
</I>&gt;<i> class, you can no longer use unique_ptr unavailability as an excuse to
</I>&gt;<i> duplicate TidyPointer/unique_ptr functionality in the LockingPointer.
</I>&gt;<i> 
</I>
You seem to be saying I should have made LockingPointer inherit from
std::unique_ptr and keep touching its data member for the shared_ptr
things LockingPointer does.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> unique_ptr uses a Functor type.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> This statement is inaccurate in its context -- unique_ptr does accept
</I>&gt;&gt;&gt;<i> [lvalue references to] functions as well. I believe this is by design --
</I>&gt;&gt;&gt;<i> any good template should not care whether it was given a simple function
</I>&gt;&gt;&gt;<i> or a Functor object.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Thats how I took the documentation, in fact it says so outright in
</I>&gt;&gt;<i> place. But I was not able to easily get it to accept either a function
</I>&gt;&gt;<i> pointer, or a function type.
</I>&gt;<i> 
</I>&gt;<i> Yeah. I think there are two different problems here, and that obscures
</I>&gt;<i> the solution. I will illustrate using BIGNUM_Pointer as an example:
</I>&gt;<i> 
</I>&gt;<i> A) The Deleter template parameter must be a type, not an object. Thus,
</I>&gt;<i> declaring BIGNUM_Pointer using BN_free_cpp as Deleter does not work:
</I>&gt;<i> BN_free_cpp is not a type but an object.
</I>&gt;<i> 
</I>&gt;<i> B) We do not want to specify the Deleter object explicitly every time we
</I>&gt;<i> are defining our BIGNUM_Pointer objects. Thus, our Deleter type must
</I>&gt;<i> have a default constructor. Pointers to functions do not have default
</I>&gt;<i> constructors. Thus, the Deleter type must be a [DefaultConstructible]
</I>&gt;<i> class and not just a &quot;pointer to function X&quot; type.
</I>&gt;<i> 
</I>&gt;<i> All of the following &quot;typedef ... BIGNUM_Pointer&quot; variants compile in my
</I>&gt;<i> tests:
</I>&gt;<i> 
</I>&gt;<i>   1.  std::unique_ptr&lt;BIGNUM, std::function&lt;decltype(BN_free_cpp)&gt; &gt;
</I>&gt;<i>   2.  std::unique_ptr&lt;BIGNUM, std::function&lt;decltype(BN_free)&gt; &gt;
</I>&gt;<i>   3a. std::unique_ptr&lt;BIGNUM, decltype(&amp;BN_free_cpp) &gt;
</I>&gt;<i>   3b. std::unique_ptr&lt;BIGNUM, void(*)(BIGNUM*) &gt;
</I>&gt;<i> 
</I>&gt;<i> #3a and #3b force you to pass a specific deleter when defining
</I>&gt;<i> BIGNUM_Pointer objects, violating condition (B) above. For example:
</I>&gt;<i>   BIGNUM_Pointer bnp(..., &amp;BN_free_cpp);
</I>
That rules #3a and #3b out for me. Too much required extra code.

&gt;<i> 
</I>&gt;<i> #2 might suffer from the same problem that forced us to add the CtoCpp1
</I>&gt;<i> macro. Christos, the author of r11100 that added CtoCpp1, may be able to
</I>&gt;<i> confirm or deny this.
</I>
IIRC the issue then was linking with symbol mangling (or not). I think
the C++11 decltype() takes care of that here.

std::function creates a Functor. So as I said unique_ptr uses a Functor
type.

&gt;<i> 
</I>&gt;&gt;<i> ../../../src/ssl/gadgets.h:51:44: note:   expected a type, got
</I>&gt;&gt;<i> ‘Ssl::BN_free_cpp’
</I>&gt;<i> 
</I>&gt;<i> Yes, this is due to (A) above. Solutions #1-3 avoid that problem.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> If I give it the type instead of function pointer, like so:
</I>&gt;&gt;<i>   typedef std::unique_ptr&lt;BIGNUM, decltype(BN_free_cpp)&gt; BIGNUM_Pointer;
</I>&gt;<i> 
</I>&gt;<i> AFAICT, you want a reference to the function, not the function name
</I>&gt;<i> itself. I do not know why the usual decaying rules do not apply here,
</I>&gt;<i> but perhaps that is not important. #3a solves this but violates (B) as
</I>&gt;<i> discussed above.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Asside from that the functor keeps the code looking almost the same as
</I>&gt;&gt;<i> it did before. So a bit less pain for all of us porting things to 3.5 in
</I>&gt;&gt;<i> the next years.
</I>&gt;<i> 
</I>&gt;<i> I hope the above both explains exactly why we need a functor here and
</I>&gt;<i> offers a similar std::function-based solution that does not require
</I>&gt;<i> re-inventing UnaryFunctor.
</I>&gt;<i> 
</I>
Yes. Thank you.


Amos
-------------- next part --------------
=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2016-01-15 06:47:59 +0000
+++ src/base/Makefile.am	2016-06-29 03:56:37 +0000
@@ -21,22 +21,21 @@
 	AsyncCallQueue.h \
 	ByteCounter.h \
 	CbcPointer.h \
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
 	EnumIterator.h \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
 	LruMap.h \
 	Packable.h \
 	PackableStream.h \
 	RegexPattern.cc \
 	RegexPattern.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	TidyPointer.h \
 	YesNoNone.h

=== removed file 'src/base/TidyPointer.h'
--- src/base/TidyPointer.h	2016-03-31 23:33:45 +0000
+++ src/base/TidyPointer.h	1970-01-01 00:00:00 +0000
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_BASE_TIDYPOINTER_H
-#define SQUID_BASE_TIDYPOINTER_H
-
-/**
- * A pointer that deletes the object it points to when the pointer's owner or
- * context is gone. Similar to std::unique_ptr but without confusing assignment
- * and with a customizable cleanup method. Prevents memory leaks in
- * the presence of exceptions and processing short cuts.
-*/
-template &lt;typename T, void (*DeAllocator)(T *t)&gt; class TidyPointer
-{
-public:
-    /// Delete callback.
-    typedef void DCB (T *t);
-    TidyPointer(T *t = NULL)
-        :   raw(t) {}
-public:
-    bool operator !() const { return !raw; }
-    explicit operator bool() const { return raw; }
-    /// Returns raw and possibly NULL pointer
-    T *get() const { return raw; }
-
-    /// Reset raw pointer - delete last one and save new one.
-    void reset(T *t) {
-        deletePointer();
-        raw = t;
-    }
-
-    /// Forget the raw pointer without freeing it. Become a nil pointer.
-    T *release() {
-        T *ret = raw;
-        raw = NULL;
-        return ret;
-    }
-    /// Deallocate raw pointer.
-    ~TidyPointer() {
-        deletePointer();
-    }
-private:
-    /// Forbidden copy constructor.
-    TidyPointer(TidyPointer&lt;T, DeAllocator&gt; const &amp;);
-    /// Forbidden assigment operator.
-    TidyPointer &lt;T, DeAllocator&gt; &amp; operator = (TidyPointer&lt;T, DeAllocator&gt; const &amp;);
-    /// Deallocate raw pointer. Become a nil pointer.
-    void deletePointer() {
-        if (raw) {
-            DeAllocator(raw);
-        }
-        raw = NULL;
-    }
-    T *raw; ///&lt; pointer to T object or NULL
-};
-
-/// DeAllocator for pointers that need free(3) from the std C library
-template&lt;typename T&gt; void tidyFree(T *p)
-{
-    xfree(p);
-}
-
-#endif // SQUID_BASE_TIDYPOINTER_H
-

=== modified file 'src/security/LockingPointer.h'
--- src/security/LockingPointer.h	2016-03-31 23:33:45 +0000
+++ src/security/LockingPointer.h	2016-06-25 15:23:17 +0000
@@ -1,89 +1,125 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_LOCKINGPOINTER_H
 #define SQUID_SRC_SECURITY_LOCKINGPOINTER_H
 
-#include &quot;base/TidyPointer.h&quot;
-
 #if USE_OPENSSL
 #if HAVE_OPENSSL_CRYPTO_H
 #include &lt;openssl/crypto.h&gt;
 #endif
 
 // Macro to be used to define the C++ wrapper function of a sk_*_pop_free
 // openssl family functions. The C++ function suffixed with the _free_wrapper
 // extension
 #define sk_free_wrapper(sk_object, argument, freefunction) \
         extern &quot;C++&quot; inline void sk_object ## _free_wrapper(argument a) { \
             sk_object ## _pop_free(a, freefunction); \
         }
 
-#endif
+#endif /* USE_OPENSSL */
 
 // Macro to be used to define the C++ equivalent function of an extern &quot;C&quot;
 // function. The C++ function suffixed with the _cpp extension
 #define CtoCpp1(function, argument) \
         extern &quot;C++&quot; inline void function ## _cpp(argument a) { \
             function(a); \
         }
 
 namespace Security
 {
 
 /**
- * Add SSL locking (a.k.a. reference counting) and assignment to TidyPointer
+ * A pointer that deletes the object it points to when the pointer's owner or
+ * context is gone.
+ * Maintains locking using OpenSSL crypto API when exporting the stored value
+ * between objects.
+ * Prevents memory leaks in the presence of exceptions and processing short
+ * cuts.
  */
 template &lt;typename T, void (*DeAllocator)(T *t), int lock&gt;
-class LockingPointer: public TidyPointer&lt;T, DeAllocator&gt;
+class LockingPointer
 {
 public:
-    typedef TidyPointer&lt;T, DeAllocator&gt; Parent;
+    /// a helper label to simplify this objects API definitions below
     typedef LockingPointer&lt;T, DeAllocator, lock&gt; SelfType;
 
-    explicit LockingPointer(T *t = nullptr): Parent(t) {}
+    /**
+     * Construct directly from a raw pointer.
+     * This action requires that the producer of that pointer has already
+     * created one reference lock for the object pointed to.
+     * Our destructor will do the matching unlock/free.
+     */
+    explicit LockingPointer(T *t = nullptr): raw(t) {}
 
-    explicit LockingPointer(const SelfType &amp;o): Parent() {
-        resetAndLock(o.get());
-    }
+    /// use the custom DeAllocator to unlock and/or free any value still stored.
+    ~LockingPointer() { deletePointer(); }
 
+    // copy semantics are okay only when adding a lock reference
+    explicit LockingPointer(const SelfType &amp;o) : raw(nullptr) { resetAndLock(o.get()); }
     SelfType &amp;operator =(const SelfType &amp; o) {
         resetAndLock(o.get());
         return *this;
     }
 
-#if __cplusplus &gt;= 201103L
-    explicit LockingPointer(LockingPointer&lt;T, DeAllocator, lock&gt; &amp;&amp;o): Parent(o.release()) {
+    // move semantics are definitely okay, when possible
+    explicit LockingPointer(SelfType &amp;&amp;) = default;
+    SelfType &amp;operator =(SelfType &amp;&amp;o) {
+        if (o.get() != raw)
+            reset(o.release());
+        return *this;
     }
 
-    LockingPointer&lt;T, DeAllocator, lock&gt; &amp;operator =(LockingPointer&lt;T, DeAllocator, lock&gt; &amp;&amp;o) {
-        if (o.get() != this-&gt;get())
-            this-&gt;reset(o.release());
-        return *this;
+    bool operator !() const { return !raw; }
+    explicit operator bool() const { return raw; }
+
+    /// Returns raw and possibly nullptr pointer
+    T *get() const { return raw; }
+
+    /// Reset raw pointer - delete last one and save new one.
+    void reset(T *t) {
+        deletePointer();
+        raw = t;
     }
-#endif
 
     void resetAndLock(T *t) {
         if (t != this-&gt;get()) {
             this-&gt;reset(t);
 #if USE_OPENSSL
             if (t)
                 CRYPTO_add(&amp;t-&gt;references, 1, lock);
 #elif USE_GNUTLS
             // XXX: GnuTLS does not provide locking ?
 #else
             assert(false);
 #endif
         }
     }
+
+    /// Forget the raw pointer without freeing it. Become a nil pointer.
+    T *release() {
+        T *ret = raw;
+        raw = nullptr;
+        return ret;
+    }
+
+private:
+    /// Deallocate raw pointer. Become a nil pointer.
+    void deletePointer() {
+        if (raw)
+            DeAllocator(raw);
+        raw = nullptr;
+    }
+
+    T *raw; ///&lt; pointer to T object or nullptr
 };
 
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_LOCKINGPOINTER_H */
 

=== modified file 'src/security/Session.h'
--- src/security/Session.h	2016-02-13 12:12:10 +0000
+++ src/security/Session.h	2016-06-29 10:44:21 +0000
@@ -1,53 +1,54 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_SESSION_H
 #define SQUID_SRC_SECURITY_SESSION_H
 
-// LockingPointer.h instead of TidyPointer.h for CtoCpp1()
 #include &quot;security/LockingPointer.h&quot;
 
+#include &lt;memory&gt;
+
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include &lt;openssl/ssl.h&gt;
 #endif
 #endif
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_GNUTLS_H
 #include &lt;gnutls/gnutls.h&gt;
 #endif
 #endif
 
 namespace Security {
 
 #if USE_OPENSSL
 typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer&lt;SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL&gt; SessionPointer;
 
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
-CtoCpp1(gnutls_deinit, gnutls_session_t);
 // TODO: Convert to Locking pointer.
 // Locks can be implemented attaching locks counter to gnutls_session_t
 // objects using the gnutls_session_set_ptr()/gnutls_session_get_ptr ()
 // library functions
-typedef TidyPointer&lt;struct gnutls_session_int, Security::gnutls_deinit_cpp&gt; SessionPointer;
+typedef std::unique_ptr&lt;struct gnutls_session_int, std::function&lt;decltype(gnutls_deinit)&gt;&gt; SessionPointer;
 
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
-typedef TidyPointer&lt;void, nullptr&gt; SessionPointer;
+// use nullptr_t so default_delete works
+typedef std::unique_ptr&lt;std::nullptr_t&gt; SessionPointer;
 
 #endif
 
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
 

=== modified file 'src/security/cert_generators/file/certificate_db.cc'
--- src/security/cert_generators/file/certificate_db.cc	2016-02-13 16:10:26 +0000
+++ src/security/cert_generators/file/certificate_db.cc	2016-06-29 03:57:52 +0000
@@ -1,33 +1,34 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include &quot;squid.h&quot;
 #include &quot;security/cert_generators/file/certificate_db.h&quot;
 
 #include &lt;cerrno&gt;
 #include &lt;fstream&gt;
+#include &lt;memory&gt;
 #include &lt;stdexcept&gt;
 #if HAVE_SYS_STAT_H
 #include &lt;sys/stat.h&gt;
 #endif
 #if HAVE_SYS_FILE_H
 #include &lt;sys/file.h&gt;
 #endif
 #if HAVE_FCNTL_H
 #include &lt;fcntl.h&gt;
 #endif
 
 #define HERE &quot;(security_file_certgen) &quot; &lt;&lt; __FILE__ &lt;&lt; ':' &lt;&lt; __LINE__ &lt;&lt; &quot;: &quot;
 
 Ssl::Lock::Lock(std::string const &amp;aFilename) :
     filename(aFilename),
 #if _SQUID_WINDOWS_
     hFile(INVALID_HANDLE_VALUE)
 #else
     fd(-1)
 #endif
@@ -235,94 +236,93 @@
     return strcmp(aa, bb);
 }
 
 unsigned long Ssl::CertificateDb::index_name_hash(const char **a) {
     return(lh_strhash(a[Ssl::CertificateDb::cnlName]));
 }
 
 int Ssl::CertificateDb::index_name_cmp(const char **a, const char **b) {
     return(strcmp(a[Ssl::CertificateDb::cnlName], b[CertificateDb::cnlName]));
 }
 
 const std::string Ssl::CertificateDb::db_file(&quot;index.txt&quot;);
 const std::string Ssl::CertificateDb::cert_dir(&quot;certs&quot;);
 const std::string Ssl::CertificateDb::size_file(&quot;size&quot;);
 
 Ssl::CertificateDb::CertificateDb(std::string const &amp; aDb_path, size_t aMax_db_size, size_t aFs_block_size)
     :  db_path(aDb_path),
        db_full(aDb_path + &quot;/&quot; + db_file),
        cert_full(aDb_path + &quot;/&quot; + cert_dir),
        size_full(aDb_path + &quot;/&quot; + size_file),
-       db(NULL),
        max_db_size(aMax_db_size),
        fs_block_size((aFs_block_size ? aFs_block_size : 2048)),
        dbLock(db_full),
        enabled_disk_store(true) {
     if (db_path.empty() &amp;&amp; !max_db_size)
         enabled_disk_store = false;
     else if ((db_path.empty() &amp;&amp; max_db_size) || (!db_path.empty() &amp;&amp; !max_db_size))
         throw std::runtime_error(&quot;security_file_certgen is missing the required parameter. There should be -s and -M parameters together.&quot;);
 }
 
 bool Ssl::CertificateDb::find(std::string const &amp; host_name, Security::CertPointer &amp; cert, Ssl::EVP_PKEY_Pointer &amp; pkey) {
     const Locker locker(dbLock, Here);
     load();
     return pure_find(host_name, cert, pkey);
 }
 
 bool Ssl::CertificateDb::purgeCert(std::string const &amp; key) {
     const Locker locker(dbLock, Here);
     load();
     if (!db)
         return false;
 
     if (!deleteByHostname(key))
         return false;
 
     save();
     return true;
 }
 
 bool Ssl::CertificateDb::addCertAndPrivateKey(Security::CertPointer &amp; cert, Ssl::EVP_PKEY_Pointer &amp; pkey, std::string const &amp; useName) {
     const Locker locker(dbLock, Here);
     load();
     if (!db || !cert || !pkey)
         return false;
     Row row;
     ASN1_INTEGER * ai = X509_get_serialNumber(cert.get());
     std::string serial_string;
     Ssl::BIGNUM_Pointer serial(ASN1_INTEGER_to_BN(ai, NULL));
     {
-        TidyPointer&lt;char, tidyFree&gt; hex_bn(BN_bn2hex(serial.get()));
+        std::unique_ptr&lt;char, std::function&lt;decltype(xfree)&gt;&gt; hex_bn(BN_bn2hex(serial.get()));
         serial_string = std::string(hex_bn.get());
     }
     row.setValue(cnlSerial, serial_string.c_str());
     char ** rrow = TXT_DB_get_by_index(db.get(), cnlSerial, row.getRow());
     // We are creating certificates with unique serial numbers. If the serial
     // number is found in the database, the same certificate is already stored.
     if (rrow != NULL) {
         // TODO: check if the stored row is valid.
         return true;
     }
 
     {
-        TidyPointer&lt;char, tidyFree&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
+        std::unique_ptr&lt;char, std::function&lt;decltype(xfree)&gt;&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), nullptr, 0));
         Security::CertPointer findCert;
         Ssl::EVP_PKEY_Pointer findPkey;
         if (pure_find(useName.empty() ? subject.get() : useName, findCert, findPkey)) {
             // Replace with database certificate
             cert.reset(findCert.release());
             pkey.reset(findPkey.release());
             return true;
         }
         // pure_find may fail because the entry is expired, or because the
         // certs file is corrupted. Remove any entry with given hostname
         deleteByHostname(useName.empty() ? subject.get() : useName);
     }
 
     // check db size while trying to minimize calls to size()
     size_t dbSize = size();
     if ((dbSize == 0 &amp;&amp; hasRows()) ||
             (dbSize &gt; 0 &amp;&amp; !hasRows()) ||
             (dbSize &gt;  10 * max_db_size)) {
         // Invalid database size, rebuild
         dbSize = rebuildSize();
@@ -331,41 +331,41 @@
         dbSize = size(); // get the current database size
         // and try to find another invalid certificate if needed
     }
     // there are no more invalid ones, but there must be valid certificates
     while (dbSize &gt; max_db_size) {
         if (!deleteOldestCertificate()) {
             rebuildSize(); // No certificates in database.Update the size file.
             save(); // Some entries may have been removed. Update the index file.
             return false; // errors prevented us from freeing enough space
         }
         dbSize = size(); // get the current database size
     }
 
     row.setValue(cnlType, &quot;V&quot;);
     ASN1_UTCTIME * tm = X509_get_notAfter(cert.get());
     row.setValue(cnlExp_date, std::string(reinterpret_cast&lt;char *&gt;(tm-&gt;data), tm-&gt;length).c_str());
     row.setValue(cnlFile, &quot;unknown&quot;);
     if (!useName.empty())
         row.setValue(cnlName, useName.c_str());
     else {
-        TidyPointer&lt;char, tidyFree&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
+        std::unique_ptr&lt;char, std::function&lt;decltype(xfree)&gt;&gt; subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), nullptr, 0));
         row.setValue(cnlName, subject.get());
     }
 
     if (!TXT_DB_insert(db.get(), row.getRow())) {
         // failed to add index (???) but we may have already modified
         // the database so save before exit
         save();
         return false;
     }
     rrow = row.getRow();
     row.reset();
 
     std::string filename(cert_full + &quot;/&quot; + serial_string + &quot;.pem&quot;);
     if (!writeCertAndPrivateKeyToFile(cert, pkey, filename.c_str())) {
         //remove row from txt_db and save
         sq_TXT_DB_delete(db.get(), (const char **)rrow);
         save();
         return false;
     }
     addSize(filename);

=== modified file 'src/security/forward.h'
--- src/security/forward.h	2016-01-01 00:12:18 +0000
+++ src/security/forward.h	2016-06-24 13:09:31 +0000
@@ -2,40 +2,50 @@
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_SECURITY_FORWARD_H
 #define SQUID_SRC_SECURITY_FORWARD_H
 
 #include &quot;security/Context.h&quot;
 #include &quot;security/Session.h&quot;
 
 #if USE_GNUTLS
 #if HAVE_GNUTLS_X509_H
 #include &lt;gnutls/x509.h&gt;
 #endif
 #endif
 #include &lt;list&gt;
 
+#if USE_OPENSSL
+// Macro to be used to define the C++ wrapper functor of the sk_*_pop_free
+// OpenSSL family of functions. The C++ functor is suffixed with the _free_wrapper
+// extension
+#define sk_dtor_wrapper(sk_object, argument_type, freefunction) \
+        struct sk_object ## _free_wrapper { \
+            void operator()(argument_type a) { sk_object ## _pop_free(a, freefunction); } \
+        }
+#endif /* USE_OPENSSL */
+
 /* flags a SSL connection can be configured with */
 #define SSL_FLAG_NO_DEFAULT_CA      (1&lt;&lt;0)
 #define SSL_FLAG_DELAYED_AUTH       (1&lt;&lt;1)
 #define SSL_FLAG_DONT_VERIFY_PEER   (1&lt;&lt;2)
 #define SSL_FLAG_DONT_VERIFY_DOMAIN (1&lt;&lt;3)
 #define SSL_FLAG_NO_SESSION_REUSE   (1&lt;&lt;4)
 #define SSL_FLAG_VERIFY_CRL         (1&lt;&lt;5)
 #define SSL_FLAG_VERIFY_CRL_ALL     (1&lt;&lt;6)
 
 /// Network/connection security abstraction layer
 namespace Security
 {
 
 class EncryptorAnswer;
 class PeerOptions;
 class ServerOptions;
 
 #if USE_OPENSSL
 CtoCpp1(X509_free, X509 *)
 typedef Security::LockingPointer&lt;X509, X509_free_cpp, CRYPTO_LOCK_X509&gt; CertPointer;

=== modified file 'src/ssl/gadgets.h'
--- src/ssl/gadgets.h	2016-06-14 15:56:12 +0000
+++ src/ssl/gadgets.h	2016-06-29 03:54:45 +0000
@@ -22,87 +22,75 @@
 
 namespace Ssl
 {
 /**
  \defgroup SslCrtdSslAPI SSL certificate generator API
  These functions must not depend on Squid runtime code such as debug()
  because they are used by security_file_certgen helper.
  */
 
 #if SQUID_USE_CONST_SSL_METHOD
 typedef const SSL_METHOD * ContextMethod;
 #else
 typedef SSL_METHOD * ContextMethod;
 #endif
 
 #if !defined(SQUID_SSL_SIGN_HASH_IF_NONE)
 #define SQUID_SSL_SIGN_HASH_IF_NONE &quot;sha256&quot;
 #endif
 
 /**
- \ingroup SslCrtdSslAPI
- * TidyPointer typedefs for  common SSL objects
+ * std::unique_ptr typedefs for common SSL objects
  */
-sk_free_wrapper(sk_X509, STACK_OF(X509) *, X509_free)
-typedef TidyPointer&lt;STACK_OF(X509), sk_X509_free_wrapper&gt; X509_STACK_Pointer;
+sk_dtor_wrapper(sk_X509, STACK_OF(X509) *, X509_free);
+typedef std::unique_ptr&lt;STACK_OF(X509), sk_X509_free_wrapper&gt; X509_STACK_Pointer;
 
 CtoCpp1(EVP_PKEY_free, EVP_PKEY *)
 typedef Security::LockingPointer&lt;EVP_PKEY, EVP_PKEY_free_cpp, CRYPTO_LOCK_EVP_PKEY&gt; EVP_PKEY_Pointer;
 
-CtoCpp1(BN_free, BIGNUM *)
-typedef TidyPointer&lt;BIGNUM, BN_free_cpp&gt; BIGNUM_Pointer;
+typedef std::unique_ptr&lt;BIGNUM, std::function&lt;decltype(BN_free)&gt;&gt; BIGNUM_Pointer;
 
-CtoCpp1(BIO_free, BIO *)
-typedef TidyPointer&lt;BIO, BIO_free_cpp&gt; BIO_Pointer;
+typedef std::unique_ptr&lt;BIO, std::function&lt;decltype(BIO_free)&gt;&gt; BIO_Pointer;
 
-CtoCpp1(ASN1_INTEGER_free, ASN1_INTEGER *)
-typedef TidyPointer&lt;ASN1_INTEGER, ASN1_INTEGER_free_cpp&gt; ASN1_INT_Pointer;
+typedef std::unique_ptr&lt;ASN1_INTEGER, std::function&lt;decltype(ASN1_INTEGER_free)&gt;&gt; ASN1_INT_Pointer;
 
-CtoCpp1(ASN1_OCTET_STRING_free, ASN1_OCTET_STRING *)
-typedef TidyPointer&lt;ASN1_OCTET_STRING, ASN1_OCTET_STRING_free_cpp&gt; ASN1_OCTET_STRING_Pointer;
+typedef std::unique_ptr&lt;ASN1_OCTET_STRING, std::function&lt;decltype(ASN1_OCTET_STRING_free)&gt;&gt; ASN1_OCTET_STRING_Pointer;
 
-CtoCpp1(TXT_DB_free, TXT_DB *)
-typedef TidyPointer&lt;TXT_DB, TXT_DB_free_cpp&gt; TXT_DB_Pointer;
+typedef std::unique_ptr&lt;TXT_DB, std::function&lt;decltype(TXT_DB_free)&gt;&gt; TXT_DB_Pointer;
 
-CtoCpp1(X509_NAME_free, X509_NAME *)
-typedef TidyPointer&lt;X509_NAME, X509_NAME_free_cpp&gt; X509_NAME_Pointer;
+typedef std::unique_ptr&lt;X509_NAME, std::function&lt;decltype(X509_NAME_free)&gt;&gt; X509_NAME_Pointer;
 
-CtoCpp1(RSA_free, RSA *)
-typedef TidyPointer&lt;RSA, RSA_free_cpp&gt; RSA_Pointer;
+typedef std::unique_ptr&lt;RSA, std::function&lt;decltype(RSA_free)&gt;&gt; RSA_Pointer;
 
-CtoCpp1(X509_REQ_free, X509_REQ *)
-typedef TidyPointer&lt;X509_REQ, X509_REQ_free_cpp&gt; X509_REQ_Pointer;
+typedef std::unique_ptr&lt;X509_REQ, std::function&lt;decltype(X509_REQ_free)&gt;&gt; X509_REQ_Pointer;
 
-sk_free_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free)
-typedef TidyPointer&lt;STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper&gt; X509_NAME_STACK_Pointer;
+sk_dtor_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free);
+typedef std::unique_ptr&lt;STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper&gt; X509_NAME_STACK_Pointer;
 
-CtoCpp1(AUTHORITY_KEYID_free, AUTHORITY_KEYID *)
-typedef TidyPointer&lt;AUTHORITY_KEYID, AUTHORITY_KEYID_free_cpp&gt; AUTHORITY_KEYID_Pointer;
+typedef std::unique_ptr&lt;AUTHORITY_KEYID, std::function&lt;decltype(AUTHORITY_KEYID_free)&gt;&gt; AUTHORITY_KEYID_Pointer;
 
-sk_free_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free)
-typedef TidyPointer&lt;STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper&gt; GENERAL_NAME_STACK_Pointer;
+sk_dtor_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free);
+typedef std::unique_ptr&lt;STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper&gt; GENERAL_NAME_STACK_Pointer;
 
-CtoCpp1(GENERAL_NAME_free, GENERAL_NAME *)
-typedef TidyPointer&lt;GENERAL_NAME, GENERAL_NAME_free_cpp&gt; GENERAL_NAME_Pointer;
+typedef std::unique_ptr&lt;GENERAL_NAME, std::function&lt;decltype(GENERAL_NAME_free)&gt;&gt; GENERAL_NAME_Pointer;
 
-CtoCpp1(X509_EXTENSION_free, X509_EXTENSION *)
-typedef TidyPointer&lt;X509_EXTENSION, X509_EXTENSION_free_cpp&gt; X509_EXTENSION_Pointer;
+typedef std::unique_ptr&lt;X509_EXTENSION, std::function&lt;decltype(X509_EXTENSION_free)&gt;&gt; X509_EXTENSION_Pointer;
 
 /**
  \ingroup SslCrtdSslAPI
  * Create 1024 bits rsa key.
  */
 EVP_PKEY * createSslPrivateKey();
 
 /**
  \ingroup SslCrtdSslAPI
  * Write private key and SSL certificate to memory.
  */
 bool writeCertAndPrivateKeyToMemory(Security::CertPointer const &amp; cert, EVP_PKEY_Pointer const &amp; pkey, std::string &amp; bufferToWrite);
 
 /**
  \ingroup SslCrtdSslAPI
  * Append SSL certificate to bufferToWrite.
  */
 bool appendCertToMemory(Security::CertPointer const &amp; cert, std::string &amp; bufferToWrite);
 
 /**

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006045.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
	<LI>Next message: <A HREF="006047.html">[squid-dev] [PATCH] TidyPointer removal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6046">[ date ]</a>
              <a href="thread.html#6046">[ thread ]</a>
              <a href="subject.html#6046">[ subject ]</a>
              <a href="author.html#6046">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
