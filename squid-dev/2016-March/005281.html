<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%207%3A%20Headers%20are%20not%20updated%20on%20disk%0A%20after%20304s&In-Reply-To=%3C56E28D15.3050001%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005270.html">
   <LINK REL="Next"  HREF="005283.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%207%3A%20Headers%20are%20not%20updated%20on%20disk%0A%20after%20304s&In-Reply-To=%3C56E28D15.3050001%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Mar 11 09:17:09 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005270.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after	304s
</A></li>
        <LI>Next message: <A HREF="005283.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5281">[ date ]</a>
              <a href="thread.html#5281">[ thread ]</a>
              <a href="subject.html#5281">[ subject ]</a>
              <a href="author.html#5281">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/03/2016 2:59 p.m., Alex Rousskov wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i>     The attached compressed patch fixes a 15+ years old Bug #7 [1] for
</I>&gt;<i> the shared memory cache and rock cache_dirs. I am not aware of anybody
</I>&gt;<i> working on ufs-based cache_dirs, but this patch provides a Store API and
</I>&gt;<i> a cache_dir example on how to fix those as well.
</I>&gt;<i> 
</I>&gt;<i>   [1] <A HREF="http://bugs.squid-cache.org/show_bug.cgi?id=7">http://bugs.squid-cache.org/show_bug.cgi?id=7</A>
</I>&gt;<i> 
</I>
Ah. I'm getting deja-vu on this. Thought those two cache types were
fixed long ago and recent talk was you were working on the UFS side of it.

Sigh. Oh well.


&gt;<i> Besides unavoidable increase in rock-based caching code complexity, the
</I>&gt;<i> [known] costs of this fix are:
</I>&gt;<i> 
</I>&gt;<i> 1. 8 additional bytes per cache entry for shared memory cache and rock
</I>&gt;<i> cache_dirs. Much bigger but short-lived RAM _savings_ for rock
</I>&gt;<i> cache_dirs (due to less RAM-hungry index rebuild code) somewhat mitigate
</I>&gt;<i> this RAM usage increase.
</I>&gt;<i> 
</I>&gt;<i> 2. Increased slot fragmentation when updated headers are slightly larger
</I>&gt;<i> than old ones. This can probably be optimized away later if needed by
</I>&gt;<i> padding HTTP headers or StoreEntry metadata.
</I>&gt;<i> 
</I>&gt;<i> 3. Somewhat slower rock cache_dir index rebuild time. IMO, this should
</I>&gt;<i> eventually be dealt with by not rebuilding the index on most startups at
</I>&gt;<i> all (rather than focusing on the index rebuild optimization).
</I>
Hmm. Nod, agreed on the long-term approach.

&gt;<i> 
</I>&gt;<i> The patch preamble (also quoted below) contains more technical details,
</I>&gt;<i> including a list of side changes that, ideally, should go in as separate
</I>&gt;<i> commits. The posted patch is based on our bug7 branch on lp[2] which has
</I>&gt;<i> many intermediate commits. I am not yet sure whether it makes sense to
</I>&gt;<i> _merge_ that branch into trunk or simply commit it as a single/atomic
</I>&gt;<i> change (except for those side changes). Opinions welcomed.
</I>
Do you know how to do a merge like that with bzr properly?
 My experience has been that it only likes atomic-like merges.

&gt;<i> 
</I>&gt;<i>   [2] <A HREF="https://code.launchpad.net/~measurement-factory/squid/bug7">https://code.launchpad.net/~measurement-factory/squid/bug7</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -------
</I>&gt;<i> Bug 7: Update cached entries on 304 responses
</I>&gt;<i> 
</I>&gt;<i> New Store API to update entry metadata and headers on 304s.
</I>&gt;<i> Support entry updates in shared memory cache and rock cache_dirs.
</I>&gt;<i> 
</I>&gt;<i> * Highlights:
</I>&gt;<i> 
</I>&gt;<i> 1. Atomic StoreEntry metadata updating
</I>&gt;<i> 
</I>&gt;<i>    StoreEntry metadata (swap_file_sz, timestamps, etc.) is used
</I>&gt;<i>    throughout Squid code. Metadata cannot be updated atomically because
</I>&gt;<i>    it has many fields, but a partial update to those fields causes
</I>&gt;<i>    assertions. Still, we must update metadata when updating HTTP
</I>&gt;<i>    headers. Locking the entire entry for a rewrite does not work well
</I>&gt;<i>    because concurrent requests will attempt to download a new entry
</I>&gt;<i>    copy, defeating the very HTTP 304 optimization we want to support.
</I>&gt;<i> 
</I>&gt;<i>    Ipc::StoreMap index now uses an extra level of indirection (the
</I>&gt;<i>    StoreMap::fileNos index) which allows StoreMap control which
</I>&gt;<i>    anchor/fileno is associated with a given StoreEntry key. The entry
</I>&gt;<i>    updating code creates a disassociated (i.e., entry/key-less) anchor,
</I>&gt;<i>    writes new metadata and headers using that new anchor, and then
</I>&gt;<i>    _atomically_ switches the map to use that new anchor. This allows old
</I>&gt;<i>    readers to continue reading using the stale anchor/fileno as if
</I>&gt;<i>    nothing happened while a new reader gets the new anchor/fileno.
</I>
:<i>-)
</I>
&gt;<i> 
</I>&gt;<i>    Shared memory usage increase: 8 additional bytes per cache entry: 4
</I>&gt;<i>    for the extra level of indirection (StoreMapFileNos) plus 4 for
</I>&gt;<i>    splicing fresh chain prefix with the stale chain suffix
</I>&gt;<i>    (StoreMapAnchor::splicingPoint). However, if the updated headers are
</I>&gt;<i>    larger than the stale ones, Squid will allocate shared memory pages
</I>&gt;<i>    to accommodate for the increase, leading to shared memory
</I>&gt;<i>    fragmentation/waste for small increases.
</I>
&gt;<i> 
</I>&gt;<i> 2. Revamped rock index rebuild process
</I>&gt;<i> 
</I>&gt;<i>    The index rebuild process had to be completely revamped because
</I>&gt;<i>    splicing fresh and stale entry slot chain segments implies tolerating
</I>&gt;<i>    multiple entry versions in a single chain and the old code was based
</I>&gt;<i>    on the assumption that different slot versions are incompatible. We
</I>&gt;<i>    were also uncomfortable with the old cavalier approach to accessing
</I>&gt;<i>    two differently indexed layers of information (entry vs. slot) using
</I>&gt;<i>    the same set of class fields, making it trivial to accidentally
</I>&gt;<i>    access entry data while using slot index.
</I>&gt;<i> 
</I>&gt;<i>    During the rewrite of the index rebuilding code, we also discovered a
</I>&gt;<i>    way to significantly reduce RAM usage for the index build map (a
</I>&gt;<i>    temporary object that is allocated in the beginning and freed at the
</I>&gt;<i>    end of the index build process). The savings depend on the cache
</I>&gt;<i>    size: A small cache saves about 30% (17 vs 24 bytes per entry/slot)
</I>&gt;<i>    while a 1TB cache_dir with 32KB slots (which implies uneven
</I>&gt;<i>    entry/slot indexes) saves more than 50% (~370MB vs. ~800MB).
</I>&gt;<i> 
</I>&gt;<i>    Adjusted how invalid slots are counted. The code was sometimes
</I>&gt;<i>    counting invalid entries and sometimes invalid entry slots. We should
</I>&gt;<i>    always count _slots_ now because progress is measured in the number
</I>&gt;<i>    of slots scanned, not entries loaded. This accounting change may
</I>&gt;<i>    surprise users with much higher &quot;Invalid entries&quot; count in cache.log
</I>&gt;<i>    upon startup, but at least the new reports are meaningful.
</I>&gt;<i> 
</I>&gt;<i>    This rewrite does not attempt to solve all rock index build problems.
</I>&gt;<i>    For example, the code still assumes that StoreEntry metadata fits a
</I>&gt;<i>    single slot which is not always true for very small slots.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> * Side-changes to be committed separately, to the extent possible:
</I>&gt;<i> 
</I>&gt;<i> 1. Do not prohibit updating Last-Modified on 304 responses. RFC 7232
</I>&gt;<i>    Section 4.1 says sending Last-Modified in 304 might be useful and RFC
</I>&gt;<i>    7234 Section 4.3.3 requires updating all non-Warning headers.
</I>&gt;<i> 
</I>&gt;<i> 2. Added missing const qualifiers to HTTP message packing methods.
</I>&gt;<i> 
</I>&gt;<i> 3. Removed SWAPOUT_WRITING assertion from storeSwapMetaBuild().
</I>&gt;<i> 
</I>&gt;<i>    I do not see any strong dependency of that code on that state and we
</I>&gt;<i>    need to be able to build swap metadata when updating a stale entry
</I>&gt;<i>    (which would not normally be in the SWAPOUT_WRITING state).
</I>&gt;<i> 
</I>&gt;<i>    The biggest danger is that somebody calls storeSwapMetaBuild() when
</I>&gt;<i>    the entry metadata is not yet stable. I am not sure we have a way of
</I>&gt;<i>    detecting that without using something as overly strong as
</I>&gt;<i>    SWAPOUT_WRITING.
</I>&gt;<i> 
</I>

Okay. I'm finding it hard to see anything wrong here :-) but I probably
missed a lot in that mind boggling patch.


in src/StoreIOState.h:

* if the XXX about file_callback can the removal TODO be enacted ?
 - at least as one of the side-change patches

* the docs on touchingStoreEntry() seem to contradict your description
of how the entry chains work. Now. You said readers could read whatever
chain they were attached to after the update switch. The doc says they
only ever read the primary.


in src/fs/rock/RockHeaderUpdater.cc:

* please remove the dead include for cache_cf.h

* missing copyright blurb

* since the dtor is just {} can it go in the header ?
 - possibly using &quot;= default&quot;


in src/fs/rock/RockHeaderUpdater.h:

* '{' on the line after 'class' please.
 - there might be others.

* CBDATA_CLASS at the top of the class please.


in src/fs/rock/RockSwapDir.cc:

* 2 new HERE being added in Rock::SwapDir::createUpdateIO()


in src/ipc/ReadWriteLock.cc:

* the new Ipc::AssertFlagIsSet() would be dangerous for a reader to use
on a read flag.
 - I think the API docs need an extra warning that it sets the flag,
which may or may not need un-setting later.


in src/MemStore.cc:

* the XXX about Packable API is misplaced. If you want to add, it should
be in Packable.h

* docs on MemStore::pageForSlice() should use doxygen


in src/ipc/StoreMap.cc:

* is &quot;cannot open freshless entry&quot; a typo of &quot;keyless&quot; ?


That all seems relatively small, so +1.

** If anything turns out to be unexpectedly controversial just ignore me
and apply as-is.

Amos

</PRE>




































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005270.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after	304s
</A></li>
	<LI>Next message: <A HREF="005283.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5281">[ date ]</a>
              <a href="thread.html#5281">[ thread ]</a>
              <a href="subject.html#5281">[ subject ]</a>
              <a href="author.html#5281">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
