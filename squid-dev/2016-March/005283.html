<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%207%3A%20Headers%20are%20not%20updated%20on%20disk%0A%20after%20304s&In-Reply-To=%3C56E30B6E.9030009%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005281.html">
   <LINK REL="Next"  HREF="005293.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%207%3A%20Headers%20are%20not%20updated%20on%20disk%0A%20after%20304s&In-Reply-To=%3C56E30B6E.9030009%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s">rousskov at measurement-factory.com
       </A><BR>
    <I>Fri Mar 11 18:16:14 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005281.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
</A></li>
        <LI>Next message: <A HREF="005293.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5283">[ date ]</a>
              <a href="thread.html#5283">[ thread ]</a>
              <a href="subject.html#5283">[ subject ]</a>
              <a href="author.html#5283">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/11/2016 02:17 AM, Amos Jeffries wrote:
&gt;<i> On 11/03/2016 2:59 p.m., Alex Rousskov wrote:
</I>&gt;&gt;<i>     The attached compressed patch fixes a 15+ years old Bug #7 [1] for
</I>&gt;&gt;<i> the shared memory cache and rock cache_dirs. I am not aware of anybody
</I>&gt;&gt;<i> working on ufs-based cache_dirs, but this patch provides a Store API and
</I>&gt;&gt;<i> a cache_dir example on how to fix those as well.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   [1] <A HREF="http://bugs.squid-cache.org/show_bug.cgi?id=7">http://bugs.squid-cache.org/show_bug.cgi?id=7</A>
</I>

&gt;<i> Ah. I'm getting deja-vu on this. Thought those two cache types were
</I>&gt;<i> fixed long ago and recent talk was you were working on the UFS side of it.
</I>
There was some noise about this bug and related issues some months ago.
It was easy to get confused by all the mis[leading]information being
posted on bugzilla, including reports that &quot;the bug is fixed&quot; for some
ufs-based cache_dirs. I tried to correct those reports but failed to
convince people that they do not see what they think they see.

After this patch, the following cache stores (and only them) should
support header updates:

  * non-shared memory cache (in non-SMP Squids only)
  * shared memory cache
  * rock cache_dir

Needless to say, the posted patch does not fix all the problems with
header updates, even for the above stores. For example, the code that
decides which headers to update may still violate HTTP in some ways (I
have not checked). The patch &quot;just&quot; writes the headers computed by Squid
to shared memory cache and to rock cache_dirs.

Moreover, given the [necessary] complexity of the efficient update code
combined with the [unnecessary] complexity of some old Store APIs, I
would be surprised if there are no new bugs or problems introduced by
our changes. I am not aware of any, but we continue to test and plan to
fix the ones we find.


&gt;&gt;<i> Besides unavoidable increase in rock-based caching code complexity, the
</I>&gt;&gt;<i> [known] costs of this fix are:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. 8 additional bytes per cache entry for shared memory cache and rock
</I>&gt;&gt;<i> cache_dirs. Much bigger but short-lived RAM _savings_ for rock
</I>&gt;&gt;<i> cache_dirs (due to less RAM-hungry index rebuild code) somewhat mitigate
</I>&gt;&gt;<i> this RAM usage increase.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2. Increased slot fragmentation when updated headers are slightly larger
</I>&gt;&gt;<i> than old ones. This can probably be optimized away later if needed by
</I>&gt;&gt;<i> padding HTTP headers or StoreEntry metadata.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 3. Somewhat slower rock cache_dir index rebuild time. IMO, this should
</I>&gt;&gt;<i> eventually be dealt with by not rebuilding the index on most startups at
</I>&gt;&gt;<i> all (rather than focusing on the index rebuild optimization).
</I>&gt;<i> 
</I>&gt;<i> Hmm. Nod, agreed on the long-term approach.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The patch preamble (also quoted below) contains more technical details,
</I>&gt;&gt;<i> including a list of side changes that, ideally, should go in as separate
</I>&gt;&gt;<i> commits. The posted patch is based on our bug7 branch on lp[2] which has
</I>&gt;&gt;<i> many intermediate commits. I am not yet sure whether it makes sense to
</I>&gt;&gt;<i> _merge_ that branch into trunk or simply commit it as a single/atomic
</I>&gt;&gt;<i> change (except for those side changes). Opinions welcomed.
</I>

&gt;<i> Do you know how to do a merge like that with bzr properly?
</I>&gt;<i>  My experience has been that it only likes atomic-like merges.
</I>
I sense a terminology conflict. By &quot;merge&quot;, I meant &quot;bzr merge&quot;. Trunk
already has many merged branches, of course:

  revno: 14574 [merge]
  revno: 14573 [merge]
  revno: 14564 [merge]
  ...

By single/atomic change, I meant &quot;patch &lt; bug7.patch&quot;. Merges preserve
individual branch commits which is good when those commits are valuable
and bad when those commits are noise. In case of our bug7 branch, it is
a mixture of valuable stuff and noise. I decided to do a single/atomic
change to avoid increasing the noise level.


&gt;<i> in src/StoreIOState.h:
</I>&gt;<i> 
</I>&gt;<i> * if the XXX about file_callback can the removal TODO be enacted ?
</I>&gt;<i>  - at least as one of the side-change patches
</I>
Yes, of course, but out of this project scope. We already did the
difficult part -- detected and verified that the API is unused.
Hopefully, somebody will volunteer to do the rest (and to take the
responsibility for it).


&gt;<i> * the docs on touchingStoreEntry() seem to contradict your description
</I>&gt;<i> of how the entry chains work. Now. You said readers could read whatever
</I>&gt;<i> chain they were attached to after the update switch. The doc says they
</I>&gt;<i> only ever read the primary.
</I>
Done: Clarified that the primary chain (which the readers always start
with) may become secondary later:

&gt;<i>     // Tests whether we are working with the primary/public StoreEntry chain.
</I>&gt;<i>     // Reads start reading the primary chain, but it may become secondary.
</I>&gt;<i>     // There are two store write kinds:
</I>&gt;<i>     // * regular writes that change (usually append) the entry visible to all and
</I>&gt;<i>     // * header updates that create a fresh chain (while keeping the stale one usable).
</I>&gt;<i>     bool touchingStoreEntry() const;
</I>
The readers do not matter in the current code because reading code does
not use this method, but that may change in the future, of course.


&gt;<i> in src/fs/rock/RockHeaderUpdater.cc:
</I>&gt;<i> 
</I>&gt;<i> * please remove the dead include for cache_cf.h
</I>
Done.


&gt;<i> * missing copyright blurb
</I>
Done.


&gt;<i> * since the dtor is just {} can it go in the header ?
</I>&gt;<i>  - possibly using &quot;= default&quot;
</I>
Done.


&gt;<i> in src/fs/rock/RockHeaderUpdater.h:
</I>&gt;<i> 
</I>&gt;<i> * '{' on the line after 'class' please.
</I>
Done. I am surprised this is not handled automatically by astyle!


&gt;<i>  - there might be others.
</I>
Done? I found two more.


&gt;<i> * CBDATA_CLASS at the top of the class please.
</I>
Done.


&gt;<i> in src/fs/rock/RockSwapDir.cc:
</I>&gt;<i> 
</I>&gt;<i> * 2 new HERE being added in Rock::SwapDir::createUpdateIO()
</I>
Done.


&gt;<i> in src/ipc/ReadWriteLock.cc:
</I>&gt;<i> 
</I>&gt;<i> * the new Ipc::AssertFlagIsSet() would be dangerous for a reader to use
</I>&gt;<i> on a read flag.
</I>
Yes, as dangerous as any assert().


&gt;<i>  - I think the API docs need an extra warning that it sets the flag,
</I>&gt;<i> which may or may not need un-setting later.
</I>
There will be no &quot;later&quot;: If the flag was not set, Squid asserts (and
sets the flag as a side effect). This is a &quot;flag is set&quot; assertion, not
a function that sets the flag or retrieves the current flag value (the
latter cannot be done without side effects AFAICT).

To partially address your concern, I changed this function to return
nothing and detailed the function description:

&gt;<i> /// Same as assert(flag is set): The process assert()s if flag is not set.
</I>&gt;<i> /// Side effect: The unset flag becomes set just before we assert().
</I>&gt;<i> /// Needed because atomic_flag cannot be compared with a boolean.
</I>&gt;<i> void AssertFlagIsSet(std::atomic_flag &amp;flag);
</I>

I do not like this function at all, but AFAICT, this is the price to pay
for using std::atomic_flag optimization. If you prefer, we can delete
that C++11 optimization and use the good old atomic&lt;bool&gt; instead.


&gt;<i> in src/MemStore.cc:
</I>&gt;<i> 
</I>&gt;<i> * the XXX about Packable API is misplaced. If you want to add, it should
</I>&gt;<i> be in Packable.h
</I>
Done, with one more XXX added to Packable.h since we are changing it
anyway. I committed this Packable.h change separately.


&gt;<i> * docs on MemStore::pageForSlice() should use doxygen
</I>
Done.


&gt;<i> in src/ipc/StoreMap.cc:
</I>&gt;<i> 
</I>&gt;<i> * is &quot;cannot open freshless entry&quot; a typo of &quot;keyless&quot; ?
</I>
Changed to &quot;freshchainless&quot; to clarify. Better adjectives welcomed.

The pattern of all these failure debugging lines in openFoo() methods is
(or should be) &quot;cannot open ADJECTIVE entry&quot; where the adjective
describes the characteristic of the entry that prevents us from opening
it: &quot;busy&quot;, &quot;empty&quot;, &quot;marked[ for deletion]&quot;, etc.

In this specific case, the entry cannot be opened for updates because
Squid cannot allocate a fresh chain for it. This is why I invented the
&quot;freshless&quot; adjective to mean &quot;without a fresh chain&quot;. Note that the
&quot;bad&quot; entry in question is the old stale entry, not the fresh [keyless]
chain which we failed to create.


&gt;<i> That all seems relatively small, so +1.
</I>
Committed as trunk revisions 14580-14584. I did use &quot;--fixes squid:7&quot;
with &quot;bzr commit&quot; even though this is a partial fix. Sorry of that was
wrong.


Thank you,

Alex.

</PRE>



































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005281.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
</A></li>
	<LI>Next message: <A HREF="005293.html">[squid-dev] [PATCH] Bug 7: Headers are not updated on disk after 304s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5283">[ date ]</a>
              <a href="thread.html#5283">[ thread ]</a>
              <a href="subject.html#5283">[ subject ]</a>
              <a href="author.html#5283">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
