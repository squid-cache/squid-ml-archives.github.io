<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20assertion%20failed%3A%20Write.cc%3A41%3A%0A%20%22%21ccb-%3Eactive%28%29%22&In-Reply-To=%3C56E61436.6030104%40ngtech.co.il%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005311.html">
   <LINK REL="Next"  HREF="005312.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;</H1>
    <B>Eliezer Croitoru</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20assertion%20failed%3A%20Write.cc%3A41%3A%0A%20%22%21ccb-%3Eactive%28%29%22&In-Reply-To=%3C56E61436.6030104%40ngtech.co.il%3E"
       TITLE="[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;">eliezer at ngtech.co.il
       </A><BR>
    <I>Mon Mar 14 01:30:30 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005311.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
        <LI>Next message: <A HREF="005312.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5302">[ date ]</a>
              <a href="thread.html#5302">[ thread ]</a>
              <a href="subject.html#5302">[ subject ]</a>
              <a href="author.html#5302">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I would like to respond on some of the things in the post related to V4.

First 3.5 is very stable for a very long time now.
It have couple bugs in it and it will be good to somehow make them gone 
but I must highlight couple things which might not be clear.

Atomic patches are great and they solve things in a very good way.
But every bug has it's own &quot;life&quot; and we can understand that it would 
not be possible to write a perfect product without couple bugs\errors\typos.
I like many believe in perfection but from the last test(RAM ONLY) I 
ran, it seems that the hardware is not really ready to specific heat. 
The DDR2 ECC cards started pooping out of their socket in the middle of 
a simple test when it's pretty cold in the room...

+1 for trunk while I still have couple doubts about what I am 
understanding about take1 and take2 steps.
I will try to see how the service works after the patches will be 
applied to V4.

I have couple more build nodes and the automation learning keeps me busy.

Eliezer

On 10/03/2016 23:35, Alex Rousskov wrote:
&gt;<i> On 03/10/2016 12:14 PM, Christos Tsantilas wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>   I am attaching two patches for this bug.
</I>&gt;<i>
</I>&gt;<i> I will re-summarize the problem we are dealing with using higher-level
</I>&gt;<i> concepts so that it is easier to grok what Christos is talking about:
</I>&gt;<i>
</I>&gt;<i> 1. Ftp::Client cannot deal with more than one FTP command at a time.
</I>&gt;<i>
</I>&gt;<i> 2. Ftp::Server must _delay_ reading the next FTP command due to #1.
</I>&gt;<i>
</I>&gt;<i> 3. Delaying is complicated because Ftp::Server receives responses from
</I>&gt;<i>     &quot;Squid&quot; (ICAP, errors, caching, etc.), and not Ftp::Client itself:
</I>&gt;<i>     Ftp:Server may receive a response for the current FTP command
</I>&gt;<i>     long _before_ Ftp::Client is done dealing with that same command!
</I>&gt;<i>     Christos has highlighted a few specific cases where that happens.
</I>&gt;<i>
</I>&gt;<i>     [ In HTTP, this problem is much smaller because the two Squid HTTP
</I>&gt;<i>       sides do not share much state: New Http::Client objects are created
</I>&gt;<i>       as needed for the same ConnStateData object while the old ones
</I>&gt;<i>       are finishing their Http::Client jobs. ]
</I>&gt;<i>
</I>&gt;<i> 4. The current Squid code (v3.5 and trunk) contains a mechanism for #2,
</I>&gt;<i>     but that mechanism does not handle a now-known race condition. The
</I>&gt;<i>     bug leads to the Write.cc assertion. Our take1 patch fixes that bug.
</I>&gt;<i>
</I>&gt;<i> 5. While working on #4, we realized that the existing mechanism for #2
</I>&gt;<i>     relies on Ftp::Client existence and other conditions that may not
</I>&gt;<i>     materialize. If things go wrong, Ftp::Server may get stuck waiting
</I>&gt;<i>     for Ftp::Client that either did not exist or did not end the wait.
</I>&gt;<i>     Our take2 patch revises the mechanism for #2 to be much more robust.
</I>&gt;<i>     We do not know of any specific way to hit the bugs fixed by take2,
</I>&gt;<i>     but that does not mean it is (and will remain) impossible.
</I>&gt;<i>
</I>&gt;<i> Take2 also relays FTP origin errors to the FTP user in more cases.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> One simple for squid-3.5 (t1
</I>&gt;&gt;<i> patch) and one more complex (t2 patch). The simple patch solve the bug
</I>&gt;&gt;<i> for now, but may leave other similar bugs in squid.
</I>&gt;<i>
</I>&gt;<i> Amos, do you want us to port take2 to v3.5? The take1 patch for v3.5 is
</I>&gt;<i> enough to fix the known assertion. Take2 fixes that assertion as well,
</I>&gt;<i> but it is bigger because it also fixes design problems that may lead to
</I>&gt;<i> other bugs in v3.5. Which one do you want in v3.5?
</I>&gt;<i>
</I>&gt;<i> For trunk/v4, there is no doubt in my mind that we should use take2 (or
</I>&gt;<i> its polished variant).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The rest is my take2 review.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    bool clientSideWaitingForUs; ///&lt; whether the client is waiting for us
</I>&gt;<i>
</I>&gt;<i> Let's avoid confusing &quot;client side&quot; and &quot;client&quot; terms in new code,
</I>&gt;<i> especially when it is Ftp::Server that is waiting:
</I>&gt;<i>
</I>&gt;<i>    /// whether we are between Ftp::Server::startWaitingForOrigin() and
</I>&gt;<i>    /// Ftp::Server::stopWaitingForOrigin() calls
</I>&gt;<i>    bool originWaitInProgress;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +void
</I>&gt;&gt;<i> +Ftp::Relay::swanSong()
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    if (clientSideWaitingForUs) {
</I>&gt;&gt;<i> +        CbcPointer&lt;ConnStateData&gt; &amp;mgr = fwd-&gt;request-&gt;clientConnectionManager;
</I>&gt;&gt;<i> +        if (mgr.valid()) {
</I>&gt;&gt;<i> +            if (Ftp::Server *srv = dynamic_cast&lt;Ftp::Server*&gt;(mgr.get())) {
</I>&gt;&gt;<i> +                typedef UnaryMemFunT&lt;Ftp::Server, int&gt; CbDialer;
</I>&gt;&gt;<i> +                AsyncCall::Pointer call = asyncCall(11, 3, &quot;Ftp::Server::stopWaitingForOrigin&quot;,
</I>&gt;&gt;<i> +                                                    CbDialer(srv, &amp;Ftp::Server::stopWaitingForOrigin, 0));
</I>&gt;&gt;<i> +                ScheduleCallHere(call);
</I>&gt;<i>
</I>&gt;<i> and
</I>&gt;<i>
</I>&gt;&gt;<i>   void
</I>&gt;&gt;<i>   Ftp::Relay::serverComplete()
</I>&gt;&gt;<i>   {
</I>&gt;&gt;<i>       CbcPointer&lt;ConnStateData&gt; &amp;mgr = fwd-&gt;request-&gt;clientConnectionManager;
</I>&gt;&gt;<i>       if (mgr.valid()) {
</I>&gt;&gt;<i> +        if (clientSideWaitingForUs) {
</I>&gt;&gt;<i> +            if (Ftp::Server *srv = dynamic_cast&lt;Ftp::Server*&gt;(mgr.get())) {
</I>&gt;&gt;<i> +               typedef UnaryMemFunT&lt;Ftp::Server, int&gt; CbDialer;
</I>&gt;&gt;<i> +               AsyncCall::Pointer call = asyncCall(11, 3, &quot;Ftp::Server::stopWaitingForOrigin&quot;,
</I>&gt;&gt;<i> +                                                   CbDialer(srv, &amp;Ftp::Server::stopWaitingForOrigin, ctrl.replycode));
</I>&gt;&gt;<i> +               ScheduleCallHere(call);
</I>&gt;&gt;<i> +               clientSideWaitingForUs = false;
</I>&gt;&gt;<i> +            }
</I>&gt;&gt;<i> +        }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Let's move this nearly duplicated code into a new
</I>&gt;<i> Ftp::Relay::stopOriginWait(int code) method _and_ always clear
</I>&gt;<i> clientSideWaitingForUs/originWaitInProgress there.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>   void
</I>&gt;&gt;<i>   Ftp::Server::writeForwardedReply(const HttpReply *reply)
</I>&gt;&gt;<i>   {
</I>&gt;&gt;<i>       Must(reply);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> +    if (master-&gt;waitingForOrigin) {
</I>&gt;&gt;<i> +        delayedReply = reply;
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;<i>
</I>&gt;<i> If this method is called twice while waitingForOrigin is true, should we
</I>&gt;<i> throw an exception, honor the first reply, or honor the last one? Please
</I>&gt;<i> adjust the code as need. *If* honoring the last reply is the best
</I>&gt;<i> strategy (which is what take2 does), add a comment:
</I>&gt;<i>
</I>&gt;<i>      delayedReply = reply; // and forget any previous ones
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    debugs(33, 5, &quot;Transfering data in progress, waitting server side to finish&quot;);
</I>&gt;<i>
</I>&gt;<i> I suggest using &quot;waiting for Ftp::Client data transfer to end&quot; for
</I>&gt;<i> brevity sake. This will also fix the two spelling errors in the above text.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    // Currently only data upload and data download requests are
</I>&gt;&gt;<i> +    // waiting for the origin:
</I>&gt;&gt;<i> +    // Must(master-&gt;serverState  == fssHandleUploadRequest ||
</I>&gt;&gt;<i> +    //      master-&gt;serverState == fssHandleDataRequest);
</I>&gt;<i>
</I>&gt;<i> True, but our code does not _rely_ on that, right? I would remove that
</I>&gt;<i> comment to avoid the implication that it does rely on that and we are
</I>&gt;<i> just afraid to check.
</I>&gt;<i>
</I>&gt;<i> If you decide to keep this comment or enable these Must()s, please move
</I>&gt;<i> all that _after_ waitingForOrigin is cleared.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>      if (master-&gt;serverState == fssHandleDataRequest) {
</I>&gt;&gt;<i> +        if (!master-&gt;userDataDone) {
</I>&gt;<i> ...
</I>&gt;&gt;<i> +            originDataDownloadAbortedOnError = (originStatus &gt; 400);
</I>&gt;&gt;<i> +            return;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        completeDataExchange();
</I>&gt;&gt;<i> +    } else {
</I>&gt;&gt;<i> +        if (delayedReply != NULL) {
</I>&gt;&gt;<i> +            writeForwardedReply(delayedReply.getRaw());
</I>&gt;&gt;<i> +            delayedReply = NULL;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The above logic looks correct to me, but I feel like I am reading an
</I>&gt;<i> inside-out code. Please consider this instead:
</I>&gt;<i>
</I>&gt;<i> // HttpReply in fssHandleDataRequest lacks status code
</I>&gt;<i> if (master-&gt;serverState == fssHandleDataRequest)
</I>&gt;<i>      originDataDownloadAbortedOnError = (originStatus &gt; 400);
</I>&gt;<i>
</I>&gt;<i> if (!master-&gt;userDataDone) {
</I>&gt;<i>      ... your big comment here ...
</I>&gt;<i>      // HttpReply in fssHandleDataRequest lacks status code
</I>&gt;<i>      if (master-&gt;serverState == fssHandleDataRequest)
</I>&gt;<i>          originDataDownloadAbortedOnError = (originStatus &gt; 400);
</I>&gt;<i>
</I>&gt;<i>      debugs(33, 5 &quot;too early to write the response&quot;);
</I>&gt;<i>      return;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> if (delayedReply) {
</I>&gt;<i>      writeForwardedReply(delayedReply.getRaw());
</I>&gt;<i>      delayedReply = nullptr;
</I>&gt;<i> } else {
</I>&gt;<i>      completeDataExchange();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Please note that my &quot;HttpReply in fssHandleDataRequest lacks status
</I>&gt;<i> code&quot; is based on your IRC comments, but it does not mesh well with your
</I>&gt;<i> &quot;If the server side aborted with an error before we are done, we need to
</I>&gt;<i> record it&quot; source code comment which seems to imply that we should use
</I>&gt;<i> originStatus in all &quot;server aborted first&quot; cases and not just those
</I>&gt;<i> where serverState is fssHandleDataRequest. Please adjust the final
</I>&gt;<i> comment as needed.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +            originDataDownloadAbortedOnError = (originStatus &gt; 400);
</I>&gt;<i>
</I>&gt;<i> To minimize questions/doubts, please include 400 unless it is a
</I>&gt;<i> successful status.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    //Adjust our reply if the server responded with an error:
</I>&gt;&gt;<i> +    if (master-&gt;userDataDone == 226 &amp;&amp; originDataDownloadAbortedOnError)
</I>&gt;&gt;<i> +        master-&gt;userDataDone = 451;
</I>&gt;<i>
</I>&gt;<i> Please add a debugs() statement here so that we know why the code was
</I>&gt;<i> changed during triage.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> -    MasterState(): serverState(fssBegin), clientReadGreeting(false), userDataDone(0), waitForOriginData(false) {}
</I>&gt;&gt;<i> +MasterState(): serverState(fssBegin), clientReadGreeting(false), userDataDone(false), waitingForOrigin(false) {}
</I>&gt;<i>
</I>&gt;<i> Unnecessary and wrong initial value change for userDataDone.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    /// whether we have to wait the transfer on the Squid-origin data connection
</I>&gt;&gt;<i> +    /// to be finished
</I>&gt;<i>
</I>&gt;<i> Let's shorten that to &quot;whether we wait for the origin data transfer to end&quot;.
</I>&gt;<i>
</I>&gt;&gt;<i> +    /// whether the transfer aborted with an error on server side
</I>&gt;&gt;<i> +    bool originDataDownloadAbortedOnError;
</I>&gt;<i>
</I>&gt;<i> Avoid &quot;server side&quot; with &quot;whether the origin data transfer aborted&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +    /// Set when the HttpReply can not be forwarded right now to the client
</I>&gt;&gt;<i> +    /// and must be delayed unless the server side is done.
</I>&gt;<i>
</I>&gt;<i> Simplify and describe the member meaning, not what the code does with
</I>&gt;<i> it: &quot;a response which writing was postponed until stopWaitingForOrigin()&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> -    /// whether the transfer on the Squid-origin data connection is not over yet
</I>&gt;&gt;<i> -    bool waitForOriginData;
</I>&gt;&gt;<i> +    /// whether we have to wait the transfer on the Squid-origin data connection
</I>&gt;&gt;<i> +    /// to be finished
</I>&gt;&gt;<i> +    bool waitingForOrigin;
</I>&gt;<i>
</I>&gt;<i> To reduce &quot;global&quot; or &quot;shared&quot; state, if you can now move
</I>&gt;<i> waitingForOrigin to Ftp::Server, you should do that IMO.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> All of these are pretty much cosmetic changes that do not alter the
</I>&gt;<i> proposed patch functionality AFAICT. IMO, if there are no objections,
</I>&gt;<i> the polished patch should go into trunk (see above regarding v3.5).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i>
</I>
</PRE>





















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005311.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
	<LI>Next message: <A HREF="005312.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5302">[ date ]</a>
              <a href="thread.html#5302">[ thread ]</a>
              <a href="subject.html#5302">[ subject ]</a>
              <a href="author.html#5302">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
