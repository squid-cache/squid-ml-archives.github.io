<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20assertion%20failed%3A%20Write.cc%3A41%3A%0A%20%22%21ccb-%3Eactive%28%29%22&In-Reply-To=%3C56E7260D.2010505%40chtsanti.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005306.html">
   <LINK REL="Next"  HREF="005311.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;</H1>
    <B>Christos Tsantilas</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20assertion%20failed%3A%20Write.cc%3A41%3A%0A%20%22%21ccb-%3Eactive%28%29%22&In-Reply-To=%3C56E7260D.2010505%40chtsanti.net%3E"
       TITLE="[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;">christos at chtsanti.net
       </A><BR>
    <I>Mon Mar 14 20:58:53 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005306.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
        <LI>Next message: <A HREF="005311.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5310">[ date ]</a>
              <a href="thread.html#5310">[ thread ]</a>
              <a href="subject.html#5310">[ subject ]</a>
              <a href="author.html#5310">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/14/2016 06:33 PM, Alex Rousskov wrote:
&gt;<i> On 03/13/2016 01:57 PM, Christos Tsantilas wrote:
</I>&gt;&gt;<i> On 03/10/2016 11:35 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 03/10/2016 12:14 PM, Christos Tsantilas wrote:
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>       if (master-&gt;serverState == fssHandleDataRequest) {
</I>&gt;&gt;&gt;&gt;<i> +        if (!master-&gt;userDataDone) {
</I>&gt;&gt;&gt;<i> ...
</I>&gt;&gt;&gt;&gt;<i> +            originDataDownloadAbortedOnError = (originStatus &gt; 400);
</I>&gt;&gt;&gt;&gt;<i> +            return;
</I>&gt;&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;&gt;<i> +        completeDataExchange();
</I>&gt;&gt;&gt;&gt;<i> +    } else {
</I>&gt;&gt;&gt;&gt;<i> +        if (delayedReply != NULL) {
</I>&gt;&gt;&gt;&gt;<i> +            writeForwardedReply(delayedReply.getRaw());
</I>&gt;&gt;&gt;&gt;<i> +            delayedReply = NULL;
</I>&gt;&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;&gt;<i> +    }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> The above logic looks correct to me, but I feel like I am reading an
</I>&gt;&gt;&gt;<i> inside-out code. Please consider this instead:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I did not follow your suggestion here.
</I>&gt;&gt;<i> The completeDataExchange should be called only if we are downloading
</I>&gt;&gt;<i> data.
</I>&gt;<i>
</I>&gt;<i> I think your code is [still] correct but, thanks to your comments, I now
</I>&gt;<i> understand where [my] confusion about its meaning was coming from. I
</I>&gt;<i> suggest the following (functionally-equivalent) code:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> void
</I>&gt;&gt;<i> Ftp::Server::stopWaitingForOrigin(int originStatus)
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i>      Must(waitingForOrigin);
</I>&gt;&gt;<i>      waitingForOrigin = false;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>      // completeDataExchange() could be waitingForOrigin in fssHandleDataRequest
</I>&gt;&gt;<i>      if (master-&gt;serverState == fssHandleDataRequest) {
</I>&gt;&gt;<i>          // Depending on which side has finished downloading first, either trust
</I>&gt;&gt;<i>          // master-&gt;userDataDone status or set originDataDownloadAbortedOnError:
</I>&gt;&gt;<i>          if (master-&gt;userDataDone) {
</I>&gt;&gt;<i>              // We finished downloading before Ftp::Client. Most likely, the
</I>&gt;&gt;<i>              // adaptation shortened the origin response or we hit an error.
</I>&gt;&gt;<i>              // Our status (stored in master-&gt;userDataDone) is more informative.
</I>&gt;&gt;<i>              // Use master-&gt;userDataDone; avoid originDataDownloadAbortedOnError.
</I>&gt;&gt;<i>              completeDataExchange();
</I>&gt;&gt;<i>          } else {
</I>&gt;&gt;<i>              debugs(33, 5, &quot;too early to write the response&quot;);
</I>&gt;&gt;<i>              // Ftp::Client naturally finished downloading before us. Set
</I>&gt;&gt;<i>              // originDataDownloadAbortedOnError to overwrite future
</I>&gt;&gt;<i>              // master-&gt;userDataDone and relay Ftp::Client error, if there was
</I>&gt;&gt;<i>              // any, to the user.
</I>&gt;&gt;<i>              originDataDownloadAbortedOnError = (originStatus &gt;= 400);
</I>&gt;&gt;<i>          }
</I>&gt;&gt;<i>          return;
</I>&gt;&gt;<i>      }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>      if (delayedReply) {
</I>&gt;&gt;<i>          writeForwardedReply(delayedReply.getRaw());
</I>&gt;&gt;<i>          delayedReply = nullptr;
</I>&gt;&gt;<i>      }
</I>&gt;&gt;<i> }
</I>
It is OK, fixed locally here.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The only remaining doubt in my mind is the combination of delayedReply
</I>&gt;<i> and fssHandleDataRequest state. The above code appears to assume that,
</I>&gt;<i> in fssHandleDataRequest, delayedReply is either always nil or never
</I>&gt;<i> important. Is that really true? delayedReply is set in
</I>&gt;<i> Ftp::Server::writeForwardedReply() which is called from lots of places,
</I>&gt;<i> including Ftp::Server::handleDataReply(). May it be set in
</I>&gt;<i> fssHandleDataRequest?
</I>
Good question.

The writeForwardedReply inside Ftp::Server::handleDataReply is called 
only if the transfer of the file on server side did not started , 
because of an error. In this case the server reply forwarded as is.
In this case the waitingForOrigin is not clear that it will be always 
false or not, and it is possible that the delayedReply used here too.
(now the watingForOrigin is false because of the order the asyncCals are 
called)

The delayedReply can not be ignored because at least must be set to null.

Moreover In this case it is not bad idea to forward the server reply as 
is (eg &quot;the file does not exist on server&quot; error).

I have to admit that your proposal to forward the delayedReply if it is 
set, else use completeDataExhange is the correct solution for this.

But we must check if we are in fssHandleDataRequest state before call 
the completeDataExchange.


&gt;<i>
</I>&gt;<i> Why are we prioritizing completeDataExchange() over
</I>&gt;<i> writeForwardedReply(delayedReply)?
</I>
You are right. We must not do it.

&gt;<i>
</I>&gt;<i> And if we are doing the right thing, should we either assert that with
</I>&gt;<i> Must(!delayedReply) in the beginning of the fssHandleDataRequest clause
</I>&gt;<i> or clear the delayedReply, if any, in that clause?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +        debugs(33, 5, &quot;Transfering from FTP server is not complete&quot;);
</I>&gt;<i>
</I>&gt;&gt;<i> +        debugs(33, 5, &quot;Transfering from FTP server terminated with an error, adjust status code&quot;);
</I>&gt;<i>
</I>&gt;<i> s/FTP server/FTP origin server/ to minimize the chance of this &quot;FTP
</I>&gt;<i> server&quot; phrase being misinterpreted as Ftp::Server.
</I>
OK on this

&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Probably the completeDataExchange should be renamed to
</I>&gt;&gt;<i> completeDataDownload. It is used only while we are downloading objects
</I>&gt;&gt;<i> (not uploading).
</I>&gt;<i>
</I>&gt;<i> Agreed.
</I>
Should I do it in this patch commit?

&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> All of these are pretty much cosmetic changes that do not alter the
</I>&gt;&gt;&gt;<i> proposed patch functionality AFAICT. IMO, if there are no objections,
</I>&gt;&gt;&gt;<i> the polished patch should go into trunk (see above regarding v3.5).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am attaching a new patch here, if no objection I will apply this to
</I>&gt;&gt;<i> trunk.
</I>&gt;<i>
</I>&gt;<i> Please do, especially if my concerns regarding the combination of
</I>&gt;<i> delayedReply and fssHandleDataRequest state are easily addressed.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005306.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
	<LI>Next message: <A HREF="005311.html">[squid-dev] [PATCH] assertion failed: Write.cc:41: &quot;!ccb-&gt;active()&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5310">[ date ]</a>
              <a href="thread.html#5310">[ thread ]</a>
              <a href="subject.html#5310">[ subject ]</a>
              <a href="author.html#5310">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
