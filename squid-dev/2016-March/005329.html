<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] implement RFC3986
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3CCA%2BY8hcNN21EvNWy%3D%2Bs5D0JE%2B0uMpYDTdXgb1btpYspNrRHCcFA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005320.html">
   <LINK REL="Next"  HREF="005330.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] implement RFC3986</H1>
    <B>Kinkie</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3CCA%2BY8hcNN21EvNWy%3D%2Bs5D0JE%2B0uMpYDTdXgb1btpYspNrRHCcFA%40mail.gmail.com%3E"
       TITLE="[squid-dev] [PATCH] implement RFC3986">gkinkie at gmail.com
       </A><BR>
    <I>Wed Mar 16 17:33:03 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005320.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
        <LI>Next message: <A HREF="005330.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5329">[ date ]</a>
              <a href="thread.html#5329">[ thread ]</a>
              <a href="subject.html#5329">[ subject ]</a>
              <a href="author.html#5329">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;<i> Will it be initialized at all? I'd expect that fromHexTable, which is
</I>&gt;&gt;<i> const and POD be simply laid out in the data segment and not require
</I>&gt;&gt;<i> initialization at all.
</I>&gt;<i>
</I>&gt;<i> Are you implying that
</I>&gt;<i>
</I>&gt;<i> (a) fromHexTable is a C++11 constexpr _and_
</I>&gt;<i> (b) constexpr cannot suffer from initialization order problems?
</I>&gt;<i>
</I>&gt;<i> If yes, then you should declare fromHexTable as constexpr so that
</I>&gt;<i> somebody does not accidentally change it to be something else. This will
</I>&gt;<i> make (a) a strong explicit statement rather than an implied and fragile
</I>&gt;<i> implication.
</I>
both are list of constants. No calls to any code of any kind.
toHexTable can offer a stronger guarantee than const char *: it's a
const char * const.
It can't be declared constexpr: g++ complains that the standard
doesn't allow that for strings.
fromHexTable is constexpr.

&gt;<i> However, I cannot find any C++ rule that guarantees the behavior you
</I>&gt;<i> expect -- your fromHexTable (even if you add constexpr to it) does not
</I>&gt;<i> seem to match any of the three items at:
</I>&gt;<i>
</I>&gt;<i>   <A HREF="http://en.cppreference.com/w/cpp/language/constant_initialization">http://en.cppreference.com/w/cpp/language/constant_initialization</A>
</I>
To me they seem both cases of (quote)
3) Static or thread-local object (not necessarily of class type), that
is not initialized by a constructor call, if the object is
value-initialized or if every expression in its initializer is a
constant expression.

&gt;<i> Can you point me to some documentation that guarantees your expectation
</I>&gt;<i> will be fulfilled? To avoid misunderstanding: I am not saying your
</I>&gt;<i> expectation is wrong (it certainly sounds reasonable to me). I am only
</I>&gt;<i> saying that I cannot find any confirmation that what you expect is
</I>&gt;<i> actually guaranteed.
</I>
This stems from my understading of the meaning of the &quot;.data&quot; section
of ELF files (and similar sections of other binaries), which may be
partial or incomplete.

&gt;<i> [Please avoid &quot;no initialization&quot; terminology because it implies that
</I>&gt;<i> the object is left uninitialized -- what you probably mean is that
</I>&gt;<i> fromHexTable is initialized during C++ &quot;constant initialization&quot; phase.]
</I>
Yes.

&gt;&gt;<i> I agree however with simply moving the tables in the .cc file,
</I>&gt;&gt;<i> clearing all doubts.
</I>&gt;<i>
</I>&gt;<i> AFAIK, moving those table definitions to .cc file does not magically
</I>&gt;<i> help FromHex() callers in any way. Moreover, they were already in the
</I>&gt;<i> .cc file in the previous patch.
</I>
I suspect you are right. I was under the impression that if code in a
translation unit is called, then that translation unit has been
initialized by then. I now understand that I am wrong in assuming
that.

&gt;<i> Moving FromHex() itself to .cc file does not magically help indirect
</I>&gt;<i> FromHex() callers in any way either.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Please forgive me for whining, but it feels like you are trying various
</I>&gt;<i> random combinations and using me as a validation test: Does this work?
</I>&gt;<i> No, then how about this? Or perhaps that? This is a bad approach not
</I>&gt;<i> just because it wastes hours but because I am not a good validator and
</I>&gt;<i> will miss bugs. The correct approach would be to write code that you do
</I>&gt;<i> not just &quot;expect&quot; to work correctly (that's always implied) but can
</I>&gt;<i> _prove_ (to yourself, but using C++ rules) to work correctly as far as
</I>&gt;<i> initialization order is concerned.
</I>
Unfortunately initialization rules are quite hard for me to understand yet.

&gt;&gt;<i> +const int16_t fromHexTable[256] = {
</I>&gt;<i>
</I>&gt;<i> AFAICT, this needs to be &quot;static&quot; and should be &quot;constexpr&quot; to (a)
</I>&gt;<i> guarantee constant initialization and (b) minimize the chances of
</I>&gt;<i> somebody changing it to something that will not be initialized at
</I>&gt;<i> &quot;constant initialization&quot; time. Please correct me if I am wrong.
</I>
Aren't variables not declared extern marked static by default?
Sure can do but it should be redundant.

&gt;<i> Please check other tables/globals as well.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> One full/stand-alone declaration per line please.
</I>&gt;<i>
</I>&gt;&gt;<i> Ok
</I>&gt;<i>
</I>&gt;<i> These are still merged:
</I>
Oh, sorry. I restricted myself to declarations, not definitions.
But you are right, I had missed Rfc3986 declarations as well.
Done.

&gt;&gt;<i> +const CharacterSet
</I>&gt;&gt;<i> +Rfc1738::Unsafe(&quot;rfc1738:unsafe&quot;, &quot;&lt;&gt;\&quot;# %{}|\\^~[]`'&quot;),
</I>&gt;&gt;<i> +Rfc1738::Ctrls(&quot;rfc1738:ctrls&quot;, {{0x00, 0x1f}, {0x7f,0xff}}),
</I>&gt;&gt;<i> +Rfc1738::Reserved(&quot;rfc1738:reserved&quot;, &quot;;/?:@=&amp;&quot;),
</I>&gt;&gt;<i> +Rfc1738::UnsafeAndCtrls = Rfc1738::Unsafe + Rfc1738::Ctrls,
</I>&gt;&gt;<i> +         Rfc1738::Unescaped = (Rfc1738::UnsafeAndCtrls - CharacterSet(nullptr,&quot;%&quot;) ).rename(&quot;rfc1738:unescaped&quot;)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Please check other declarations as well.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +    // XXX: SBuf lacking reserve(N)
</I>&gt;&gt;&gt;&gt;<i> +    // rv.reserve(s.length()*2); //TODO: optimize arbitrary constant
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> AFAICT, SBuf::reserveSpace() should work fine here and in all other
</I>&gt;&gt;&gt;<i> define-SBuf-and-immediately-reserve-space contexts. Am I missing something?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> API compatiblity; std::string doesn't have reserveSpace but only reserve.
</I>&gt;<i>
</I>&gt;<i> That answer does not compute for me: Why would API compatibility with
</I>&gt;<i> std::string matter when you are not using templates anymore?
</I>
This is changed in the current version of the patch in fact.

&gt;<i> Just noticed that this was a private message. Please do not ask for free
</I>&gt;<i> private code reviews unless it is really needed. I still hope that
</I>&gt;<i> others will learn from these emails and not repeat the same problems in
</I>&gt;<i> the future...
</I>
It was my mistake in answering; of course I agree that these
discussion should be in public.

-- 
    Francesco
-------------- next part --------------
A non-text attachment was scrubbed...
Name: rfc3986-v3.patch
Type: text/x-diff
Size: 17250 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160316/fdc6f48d/attachment-0001.patch">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160316/fdc6f48d/attachment-0001.patch</A>&gt;
</PRE>

























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005320.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
	<LI>Next message: <A HREF="005330.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5329">[ date ]</a>
              <a href="thread.html#5329">[ thread ]</a>
              <a href="subject.html#5329">[ subject ]</a>
              <a href="author.html#5329">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
