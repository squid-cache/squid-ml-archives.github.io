<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] implement RFC3986
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56E9C029.5080405%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005329.html">
   <LINK REL="Next"  HREF="005318.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] implement RFC3986</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20implement%20RFC3986&In-Reply-To=%3C56E9C029.5080405%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] implement RFC3986">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Mar 16 20:20:57 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005329.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
        <LI>Next message: <A HREF="005318.html">[squid-dev] [PATCH] Better support for unknown URL schemes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5330">[ date ]</a>
              <a href="thread.html#5330">[ thread ]</a>
              <a href="subject.html#5330">[ subject ]</a>
              <a href="author.html#5330">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/16/2016 11:33 AM, Kinkie wrote:
&gt;&gt;&gt;<i> Will it be initialized at all? I'd expect that fromHexTable, which is
</I>&gt;&gt;&gt;<i> const and POD be simply laid out in the data segment and not require
</I>&gt;&gt;&gt;<i> initialization at all.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Are you implying that
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (a) fromHexTable is a C++11 constexpr _and_
</I>&gt;&gt;<i> (b) constexpr cannot suffer from initialization order problems?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If yes, then you should declare fromHexTable as constexpr so that
</I>&gt;&gt;<i> somebody does not accidentally change it to be something else. This will
</I>&gt;&gt;<i> make (a) a strong explicit statement rather than an implied and fragile
</I>&gt;&gt;<i> implication.
</I>
&gt;<i> both are list of constants. No calls to any code of any kind.
</I>
Yes, today, they are, but there is no indication that it is an important
property or invariant. Somebody can replace those initialization with a
function call tomorrow and nobody may notice that mistake until bug
reports start coming in.


&gt;<i> toHexTable can't be declared constexpr: g++ complains that the standard
</I>&gt;<i> doesn't allow that for strings.
</I>
Which, to me, is an indication that we should not _assume_ anything
about its initialization timing! We have to be careful here.

BTW, &quot;constexpr const char *toHexTable&quot; appears to compiler fine for me,
but perhaps my g++ is too old or this is the wrong way to add constexpr
to toHexTable? There is a somewhat related discussion to this at
<A HREF="http://stackoverflow.com/questions/30561104/const-constexpr-char-vs-constexpr-char">http://stackoverflow.com/questions/30561104/const-constexpr-char-vs-constexpr-char</A>


&gt;&gt;<i> However, I cannot find any C++ rule that guarantees the behavior you
</I>&gt;&gt;<i> expect -- your fromHexTable (even if you add constexpr to it) does not
</I>&gt;&gt;<i> seem to match any of the three items at:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   <A HREF="http://en.cppreference.com/w/cpp/language/constant_initialization">http://en.cppreference.com/w/cpp/language/constant_initialization</A>
</I>

&gt;<i> To me they seem both cases of (quote)
</I>&gt;<i> 3) Static or thread-local object (not necessarily of class type),
</I>
That rule did not seem to match for me because the tables in the v2
patch I was reviewing where not marked as &quot;static&quot;. You have changed
their declarations now so the above does seem to apply. Thank you.

Please note that I am _not_ saying that rule #3 did not apply before
your change. I am saying that it did not seem to apply. Writing correct
code is only a part of what we have to do; we have to make our code
appear to be correct to others.


&gt;<i> This stems from my understading of the meaning of the &quot;.data&quot; section
</I>&gt;<i> of ELF files, which may be partial or incomplete.
</I>
... and, more importantly, has nothing to do with C++. The .data section
may store all our constants, but that does not mean those constants
cannot be copied to some of our objects &quot;dynamically&quot;, at some
semi-random time after the program starts.


&gt;<i> Unfortunately initialization rules are quite hard for me to understand yet.
</I>
They are hard for everybody! I am surprised you volunteered to fix an
initialization problem, but since you have done so, it is not fair to
avoid the rules that are required to fix it (including proving that your
fix is correct).


&gt;&gt;&gt;<i> +const int16_t fromHexTable[256] = {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AFAICT, this needs to be &quot;static&quot; and should be &quot;constexpr&quot; to (a)
</I>&gt;&gt;<i> guarantee constant initialization and (b) minimize the chances of
</I>&gt;&gt;<i> somebody changing it to something that will not be initialized at
</I>&gt;&gt;<i> &quot;constant initialization&quot; time. Please correct me if I am wrong.
</I>
&gt;<i> Aren't variables not declared extern marked static by default?
</I>
Good question [that we should not be asking IMHO].

AFAICT[1], by default, variables have external linkage (although C++
complicates that further) and static storage duration. Does the &quot;Static
or thread-local object&quot; phrase in the C++ constant initialization rule
#3 at [2] talk about storage duration or linkage? I think it is about
storage duration.

[1]
<A HREF="http://stackoverflow.com/questions/3281925/what-is-default-storage-class-for-global-variables">http://stackoverflow.com/questions/3281925/what-is-default-storage-class-for-global-variables</A>

[2] <A HREF="http://en.cppreference.com/w/cpp/language/constant_initialization">http://en.cppreference.com/w/cpp/language/constant_initialization</A>


&gt;<i> Sure can do but it should be redundant.
</I>
It may be redundant for the compiler, but if you think &quot;static&quot; is
redundant for us, then either you have no respect for the hours wasted
discussing three versions of your patches or you think I was missing
something that would be obvious to everybody else.

I still do not understand why the tables should not go inside the
functions that use them, eliminating all questions. However, I think
patch v3 does not suffer from table initialization order problems.


What about CharacterSet globals like Rfc1738::Unsafe? Do you have
reasons to believe they will be initialized before any possible first
use? For example, if some Foo.cc contains the following global, will it
always be initialized correctly?

  #include &quot;anyp/Rfc3986.h&quot;
  const CharacterSet FooSet = Rfc3986::Reserved + Rfc1738::Ctrls;

I do not think so because none of the three constant initialization
rules[2] appear to apply to Rfc3986::Reserved (for example).


Thank you,

Alex.

</PRE>
























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005329.html">[squid-dev] [PATCH] implement RFC3986
</A></li>
	<LI>Next message: <A HREF="005318.html">[squid-dev] [PATCH] Better support for unknown URL schemes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5330">[ date ]</a>
              <a href="thread.html#5330">[ thread ]</a>
              <a href="subject.html#5330">[ subject ]</a>
              <a href="author.html#5330">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
