<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC][PATCH] Bug4438 second attempt: give MemBlob its own pools
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%5BPATCH%5D%20Bug4438%20second%20attempt%3A%20give%20MemBlob%0A%20its%20own%20pools&In-Reply-To=%3C56EA255F.6030009%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005328.html">
   <LINK REL="Next"  HREF="005315.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC][PATCH] Bug4438 second attempt: give MemBlob its own pools</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%5BPATCH%5D%20Bug4438%20second%20attempt%3A%20give%20MemBlob%0A%20its%20own%20pools&In-Reply-To=%3C56EA255F.6030009%40measurement-factory.com%3E"
       TITLE="[squid-dev] [RFC][PATCH] Bug4438 second attempt: give MemBlob its own pools">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Mar 17 03:32:47 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005328.html">[squid-dev] [RFC][PATCH] Bug4438 second attempt: give MemBlob its own pools
</A></li>
        <LI>Next message: <A HREF="005315.html">[squid-dev] [PATCH] Add reply_header_add
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5333">[ date ]</a>
              <a href="thread.html#5333">[ thread ]</a>
              <a href="subject.html#5333">[ subject ]</a>
              <a href="author.html#5333">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/16/2016 02:04 AM, Kinkie wrote:
&gt;<i> On Tue, Mar 15, 2016 at 9:43 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 03/14/2016 02:11 PM, Kinkie wrote:
</I>&gt;&gt;&gt;<i>   this second attempt at bug4438 tries a different approach: by giving
</I>&gt;&gt;&gt;<i> MemBlob its own pools and having a hard initialization dependency in
</I>&gt;&gt;&gt;<i> MemBlob's allocating function, instead of relying on memAllocString.
</I>
&gt;&gt;<i> Forgive me if I missed how this decision was made earlier, but I do not
</I>&gt;&gt;<i> understand why we want to duplicate the existing memAllocString()-like
</I>&gt;&gt;<i> functionality and split a single set of raw memory pools shared by all
</I>&gt;&gt;<i> callers into two isolated sets?
</I>
&gt;<i> It is an attempt to sidestep initialization issues by having pools in
</I>&gt;<i> the same translation unit as their user.
</I>

That does not compute for me, on two levels:

1. I do not see how having pools in the same translation unit as their
_direct_ user helps. It is the indirect users that create initialization
order problems and those users obviously cannot be located in the same
translation unit. For example, how would your solution help in this
situation:

MemBlobPoolsLiveHere.cc:

  ... your pools live here ...
  ... MemBlob allocating code lives here too ...

SBufUserFoo.cc

  #include &lt;MemBlobPoolsLiveHere.h&gt;
  static const SBuf Foo(&quot;foo&quot;); // needs initialized MemBlob pools

What will guarantee that MemBlob pools are initialized when Foo is created?


2. If something in your new code does guarantee that the example in #1
works, then why cannot the same guarantee be used for fixing
memAllocString() instead, without duplicating its functionality?


&gt;&gt;<i> In other words, how did we get from &quot;SIGSEGV in memFreeString&quot; (i.e.,
</I>&gt;&gt;<i> bug 4438) to this? If your working (or perhaps already proven!) theory
</I>&gt;&gt;<i> is that memAllocString() does something wrong, why not fix
</I>&gt;&gt;<i> memAllocString() instead of duplicating it? I must be missing something
</I>&gt;&gt;<i> obvious here...
</I>
&gt;<i> Unfortunately we can't prove what is doing what wrong as we (or at
</I>&gt;<i> least I) can't reproduce the bug.
</I>
That cannot be it because your are essentially rewriting
memAllocString() in a new location and, hence, effectively deciding what
it is doing wrong (so that you do not copy [what you think is] the problem).

How about the following assertion? ```memAllocString() does not call
Mem::Init() when MemIsInitialized is false but still allocates memory
(which may later be freed) using difficult-to-follow logic that leads to
known minor and suspected big problems. This is wrong.'''

If that assertion is correct, and if that is the part of
memAllocString() that you are avoiding when duplicating its overall
functionality, then I think it would be better to fix memAllocString()
instead.


&gt;&gt;&gt;<i> - as no MemBlob can be initialized before MemPools, there is no need
</I>&gt;&gt;&gt;<i> to baloon statically-initialized MemBlobs to
</I>&gt;&gt;&gt;<i> SmallestStringBeforeMemIsInitialized.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If your change guarantees that no MemBlob can be initialized before
</I>&gt;&gt;<i> MemPools, why cannot a similar change be done to the original code so
</I>&gt;&gt;<i> that no memAllocString()/etc. caller can get its result before MemPools
</I>&gt;&gt;<i> are initialized? AFAICT, you have solved the problem that you were
</I>&gt;&gt;<i> trying to solve, but I do not understand why you had to solve it in a
</I>&gt;&gt;<i> new location (leaving the old problem unsolved?).
</I>
&gt;<i> I do not yet know if I have solved the problem, unfortunately.
</I>&gt;<i> If this attempt is successful, it can be a blueprint for modernizing
</I>&gt;<i> memAllocString, or splitting other callers altogether. The file name
</I>&gt;<i> (old_api) is to me an indicator that these API are not really
</I>&gt;<i> encouraged, and on the way to deprecation if not deprecated already.
</I>
The approach of copying suspected-to-be-problematic code and then fixing
the copy does not make sense to me in this context, regardless of how
[not] confident you are that you have identified the problem correctly.

Furthermore, if the solution to the problem is placing pools in the same
translation unit as their direct user, then either I do not understand
the problem you are trying to solve, or you are not solving it (because
you have to worry about the _indirect_ users).


Alex.

</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005328.html">[squid-dev] [RFC][PATCH] Bug4438 second attempt: give MemBlob its own pools
</A></li>
	<LI>Next message: <A HREF="005315.html">[squid-dev] [PATCH] Add reply_header_add
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5333">[ date ]</a>
              <a href="thread.html#5333">[ thread ]</a>
              <a href="subject.html#5333">[ subject ]</a>
              <a href="author.html#5333">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
