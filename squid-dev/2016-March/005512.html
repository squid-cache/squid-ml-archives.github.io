<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 4438 - string pool refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FAAA1E.7010605%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005495.html">
   <LINK REL="Next"  HREF="005517.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 4438 - string pool refactoring</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FAAA1E.7010605%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Bug 4438 - string pool refactoring">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Mar 29 16:15:26 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005495.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
        <LI>Next message: <A HREF="005517.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5512">[ date ]</a>
              <a href="thread.html#5512">[ thread ]</a>
              <a href="subject.html#5512">[ subject ]</a>
              <a href="author.html#5512">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 26/03/2016 3:28 a.m., Alex Rousskov wrote:
&gt;<i> On 03/25/2016 07:08 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> This was audited off-list, and a slightly more polished version applied
</I>&gt;&gt;<i> to trunk as rev.14604
</I>&gt;<i> 
</I>&gt;<i> I have not seen the off-list audit, but the committed version is buggy IMHO:
</I>&gt;<i> 
</I>
&lt;<A HREF="http://pixy.kinkie.it/~kinkie/irc-logs/bot/index.php?d=2016-03-23">http://pixy.kinkie.it/~kinkie/irc-logs/bot/index.php?d=2016-03-23</A>&gt;

&quot;
[20:07:04]
yadi
what I mean is the pools are MemPool class instances. if they get
destructed on exit() while some other class is still not-yet destructed
and using pooled memory we have trouble.

[21:24:58]
rousskov
yadi, I know that you have meant that. What I am saying is that MemPool
cannot be destructed until there are no allocations alive.
&quot;

I may still be misunderstanding you. I took that as meaning we had it right.


&gt;<i> 
</I>&gt;&gt;<i>  MemPools &amp;
</I>&gt;&gt;<i>  MemPools::GetInstance()
</I>&gt;&gt;<i>  {
</I>&gt;&gt;<i>      /* Must use this idiom, as we can be double-initialised
</I>&gt;&gt;<i>       * if we are called during static initialisations.
</I>&gt;&gt;<i>       */
</I>&gt;&gt;<i> -    if (!Instance)
</I>&gt;&gt;<i> -        Instance = new MemPools;
</I>&gt;&gt;<i> -    return *Instance;
</I>&gt;&gt;<i> +    static MemPools Instance;
</I>&gt;&gt;<i> +    return Instance;
</I>&gt;&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This change solves the initialization order bug but introduces the
</I>&gt;<i> destruction order bug: The Instance object may be gone before its last
</I>&gt;<i> use. Please fix and check for similar bugs in the new code.
</I>&gt;<i> 
</I>
Fixed by dynamically allocating Instance and leaking it as agreed on IRC
today.

The only other object which might share this problem is GetPool(t). Its
object is POD though. The complex part of that is dynamically allocated
already.

&gt;<i> 
</I>&gt;&gt;<i> +static MemAllocator *&amp;
</I>&gt;&gt;<i> +GetPool(size_t type)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    static MemAllocator *pools[MEM_MAX];
</I>&gt;&gt;<i> +    static bool initialized = false;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!initialized) {
</I>&gt;&gt;<i> +        memset(pools, '\0', sizeof(pools));
</I>&gt;&gt;<i> +        initialized = true;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return pools[type];
</I>&gt;&gt;<i> +}
</I>&gt;<i> 
</I>&gt;&gt;<i>  /* find appropriate pool and use it (pools always init buffer with 0s) */
</I>&gt;&gt;<i>  void *
</I>&gt;&gt;<i>  memAllocate(mem_type type)
</I>&gt;&gt;<i>  {
</I>&gt;&gt;<i> -    assert(MemPools[type]);
</I>&gt;&gt;<i> -    return MemPools[type]-&gt;alloc();
</I>&gt;&gt;<i> +    assert(GetPool(type));
</I>&gt;&gt;<i> +    return GetPool(type)-&gt;alloc();
</I>&gt;&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> AFAICT, this combination will assert if memAllocate() (or any similar
</I>&gt;<i> external caller) is called &quot;too early&quot;. Since memAllocate() is not
</I>&gt;<i> static, you cannot control when it is called. Please fix so that
</I>&gt;<i> GetPool() always returns a usable pool. Returning a _reference_ to that
</I>&gt;<i> pool instead of a never-nil pointer would be appropriate.
</I>&gt;<i> 
</I>
That is intentional. This function is only used by 'old API' pools which
must not be used prior to Mem::Init() being called from mainInitialize().

I've made the situation a little bit safer by calling Mem::Init() in the
initialization branch of GetPool(). But the risk still exists for pools
which are not initialized by Mem::init(). Having an assert for that case
is still best as it highlights that the code being changed is broken
when the dev runs the change.

We can't return a reference here since the initializer functions make
use of GetPool(t) to locate the array pointer to be set.


&gt;<i> 
</I>&gt;&gt;<i> +static MemAllocator *&amp;
</I>&gt;&gt;<i> +GetStrPool(size_t type)
</I>&gt;<i> 
</I>&gt;<i> Wrong return type AFAICT: This function always returns a usable pool so
</I>&gt;<i> it should return a reference and the callers should be adjusted to avoid
</I>&gt;<i> treating non-existent nil string pools specially. The latter adjustment
</I>&gt;<i> may expose other necessary changes.
</I>
Done.


Updated patch attached.


Thanks
Amos

-------------- next part --------------
=== modified file 'src/mem/AllocatorProxy.cc'
--- src/mem/AllocatorProxy.cc	2016-01-01 00:12:18 +0000
+++ src/mem/AllocatorProxy.cc	2016-03-28 22:20:40 +0000
@@ -41,7 +41,7 @@
     if (!theAllocator)
         return 0;
     else
-        return memPoolInUseCount(theAllocator);
+        return theAllocator-&gt;inUseCount();
 }
 
 void

=== modified file 'src/mem/Pool.cc'
--- src/mem/Pool.cc	2016-03-23 11:36:59 +0000
+++ src/mem/Pool.cc	2016-03-28 22:20:29 +0000
@@ -32,8 +32,11 @@
     /* Must use this idiom, as we can be double-initialised
      * if we are called during static initialisations.
      */
-    static MemPools Instance;
-    return Instance;
+    static MemPools *Instance = nullptr;
+    if (!Instance) {
+        Instance = new MemPools;
+    }
+    return *Instance;
 }
 
 MemPoolIterator *
@@ -298,12 +301,6 @@
 }
 
 int
-memPoolInUseCount(MemAllocator * pool)
-{
-    return pool-&gt;inUseCount();
-}
-
-int
 memPoolsTotalAllocated(void)
 {
     MemPoolGlobalStats stats;

=== modified file 'src/mem/Pool.h'
--- src/mem/Pool.h	2016-03-23 16:29:47 +0000
+++ src/mem/Pool.h	2016-03-28 22:21:14 +0000
@@ -356,8 +356,6 @@
 extern int memPoolGetGlobalStats(MemPoolGlobalStats * stats);
 
 /// \ingroup MemPoolsAPI
-extern int memPoolInUseCount(MemAllocator *);
-/// \ingroup MemPoolsAPI
 extern int memPoolsTotalAllocated(void);
 
 #endif /* _MEM_POOL_H_ */

=== modified file 'src/mem/old_api.cc'
--- src/mem/old_api.cc	2016-03-25 12:55:30 +0000
+++ src/mem/old_api.cc	2016-03-29 16:11:08 +0000
@@ -69,12 +69,15 @@
     if (!initialized) {
         memset(pools, '\0', sizeof(pools));
         initialized = true;
+        // Mem::Init() makes use of GetPool(type) to initialize
+        // the actual pools. So must come after the flag is true
+        Mem::Init();
     }
 
     return pools[type];
 }
 
-static MemAllocator *&amp;
+static MemAllocator &amp;
 GetStrPool(size_t type)
 {
     static MemAllocator *strPools[mem_str_pool_count];
@@ -107,7 +110,7 @@
         initialized = true;
     }
 
-    return strPools[type];
+    return *strPools[type];
 }
 
 /* Find the best fit string pool type */
@@ -116,13 +119,11 @@
 {
     mem_type type = MEM_NONE;
     for (unsigned int i = 0; i &lt; mem_str_pool_count; ++i) {
-        auto pool = GetStrPool(i);
-        if (!pool)
-            continue;
-        if (fuzzy &amp;&amp; net_size &lt; pool-&gt;objectSize()) {
+        auto &amp;pool = GetStrPool(i);
+        if (fuzzy &amp;&amp; net_size &lt; pool.objectSize()) {
             type = static_cast&lt;mem_type&gt;(i);
             break;
-        } else if (net_size == pool-&gt;objectSize()) {
+        } else if (net_size == pool.objectSize()) {
             type = static_cast&lt;mem_type&gt;(i);
             break;
         }
@@ -142,13 +143,13 @@
     /* table body */
 
     for (i = 0; i &lt; mem_str_pool_count; ++i) {
-        const MemAllocator *pool = GetStrPool(i);
-        const auto plevel = pool-&gt;getMeter().inuse.currentLevel();
-        stream &lt;&lt; std::setw(20) &lt;&lt; std::left &lt;&lt; pool-&gt;objectType();
+        const auto &amp;pool = GetStrPool(i);
+        const auto plevel = pool.getMeter().inuse.currentLevel();
+        stream &lt;&lt; std::setw(20) &lt;&lt; std::left &lt;&lt; pool.objectType();
         stream &lt;&lt; std::right &lt;&lt; &quot;\t &quot; &lt;&lt; xpercentInt(plevel, StrCountMeter.currentLevel());
-        stream &lt;&lt; &quot;\t &quot; &lt;&lt; xpercentInt(plevel * pool-&gt;objectSize(), StrVolumeMeter.currentLevel()) &lt;&lt; &quot;\n&quot;;
+        stream &lt;&lt; &quot;\t &quot; &lt;&lt; xpercentInt(plevel * pool.objectSize(), StrVolumeMeter.currentLevel()) &lt;&lt; &quot;\n&quot;;
         pooled_count += plevel;
-        pooled_volume += plevel * pool-&gt;objectSize();
+        pooled_volume += plevel * pool.objectSize();
     }
 
     /* malloc strings */
@@ -233,18 +234,22 @@
 void *
 memAllocString(size_t net_size, size_t * gross_size)
 {
-    MemAllocator *pool = NULL;
     assert(gross_size);
 
     auto type = memFindStringSizeType(net_size, true);
-    if (type != MEM_NONE)
-        pool = GetStrPool(type);
+    if (type != MEM_NONE) {
+        auto &amp;pool = GetStrPool(type);
+        *gross_size = pool.objectSize();
+        assert(*gross_size &gt;= net_size);
+        ++StrCountMeter;
+        StrVolumeMeter += *gross_size;
+        return pool.alloc();
+    }
 
-    *gross_size = pool ? pool-&gt;objectSize() : net_size;
-    assert(*gross_size &gt;= net_size);
+    *gross_size = net_size;
     ++StrCountMeter;
     StrVolumeMeter += *gross_size;
-    return pool ? pool-&gt;alloc() : xcalloc(1, net_size);
+    return xcalloc(1, net_size);
 }
 
 size_t
@@ -253,7 +258,7 @@
     size_t result = 0;
 
     for (int counter = 0; counter &lt; mem_str_pool_count; ++counter)
-        result += memPoolInUseCount(GetStrPool(counter));
+        result += GetStrPool(counter).inUseCount();
 
     return result;
 }
@@ -262,16 +267,16 @@
 void
 memFreeString(size_t size, void *buf)
 {
-    MemAllocator *pool = NULL;
     assert(buf);
 
     auto type = memFindStringSizeType(size, false);
     if (type != MEM_NONE)
-        pool = GetStrPool(type);
+        GetStrPool(type).freeOne(buf);
+    else
+        xfree(buf);
 
     --StrCountMeter;
     StrVolumeMeter -= size;
-    pool ? pool-&gt;freeOne(buf) : xfree(buf);
 }
 
 /* Find the best fit MEM_X_BUF type */
@@ -509,7 +514,7 @@
 int
 memInUse(mem_type type)
 {
-    return memPoolInUseCount(GetPool(type));
+    return GetPool(type)-&gt;inUseCount();
 }
 
 /* ick */

=== modified file 'src/tests/stub_libmem.cc'
--- src/tests/stub_libmem.cc	2016-03-23 16:29:47 +0000
+++ src/tests/stub_libmem.cc	2016-03-28 22:21:25 +0000
@@ -105,6 +105,5 @@
 MemImplementingAllocator * memPoolIterateNext(MemPoolIterator * iter) STUB_RETVAL(NULL)
 void memPoolIterateDone(MemPoolIterator ** iter) STUB
 int memPoolGetGlobalStats(MemPoolGlobalStats * stats) STUB_RETVAL(0)
-int memPoolInUseCount(MemAllocator *) STUB_RETVAL(0)
 int memPoolsTotalAllocated(void) STUB_RETVAL(0)
 

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005495.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
	<LI>Next message: <A HREF="005517.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5512">[ date ]</a>
              <a href="thread.html#5512">[ thread ]</a>
              <a href="subject.html#5512">[ subject ]</a>
              <a href="author.html#5512">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
