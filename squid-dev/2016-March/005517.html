<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 4438 - string pool refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FAD531.3070008%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005512.html">
   <LINK REL="Next"  HREF="005524.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 4438 - string pool refactoring</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FAD531.3070008%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Bug 4438 - string pool refactoring">rousskov at measurement-factory.com
       </A><BR>
    <I>Tue Mar 29 19:19:13 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005512.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
        <LI>Next message: <A HREF="005524.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5517">[ date ]</a>
              <a href="thread.html#5517">[ thread ]</a>
              <a href="subject.html#5517">[ subject ]</a>
              <a href="author.html#5517">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/29/2016 10:15 AM, Amos Jeffries wrote:
&gt;<i> On 26/03/2016 3:28 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> the committed version is buggy IMHO
</I>

&gt;<i> &lt;<A HREF="http://pixy.kinkie.it/~kinkie/irc-logs/bot/index.php?d=2016-03-23">http://pixy.kinkie.it/~kinkie/irc-logs/bot/index.php?d=2016-03-23</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> &quot;
</I>&gt;<i> [20:07:04]
</I>&gt;<i> yadi
</I>&gt;<i> what I mean is the pools are MemPool class instances. if they get
</I>&gt;<i> destructed on exit() while some other class is still not-yet destructed
</I>&gt;<i> and using pooled memory we have trouble.
</I>&gt;<i> 
</I>&gt;<i> [21:24:58]
</I>&gt;<i> rousskov
</I>&gt;<i> yadi, I know that you have meant that. What I am saying is that MemPool
</I>&gt;<i> cannot be destructed until there are no allocations alive.
</I>&gt;<i> &quot;
</I>&gt;<i> 
</I>&gt;<i> I may still be misunderstanding you. I took that as meaning we had it right.
</I>
The committed code was wrong. My subsequent &quot;cannot be destructed&quot; IRC
comment above should be interpreted as &quot;Squid should make premature
MemPools Instance destruction impossible; it is currently possible&quot;.


&gt;<i> The only other object which might share this problem is GetPool(t). Its
</I>&gt;<i> object is POD though.
</I>
I agree that the &quot;pools&quot; variable inside GetPool() is fine as far as
initialization/destruction order is concerned.


&gt;<i> +    static MemPools *Instance = nullptr;
</I>&gt;<i> +    if (!Instance) {
</I>&gt;<i> +        Instance = new MemPools;
</I>&gt;<i> +    }
</I>

It is much easier (and faster) to just say:

  static MemPools *Instance = new MemPools;


&gt;<i>      /* Must use this idiom, as we can be double-initialised
</I>&gt;<i>       * if we are called during static initialisations.
</I>&gt;<i>       */
</I>
I recommend removing that comment. It misleads more than it helps IMO.
If you want to put a comment there, say something like

  // We must initialize on first use (which may happen during static
  // initialization) and preserve until the last user is gone (which
  // may happen long after main() exit). We currently preserve forever.
  static MemPools *Instance = new MemPools;



&gt;<i>     static bool initialized = false;
</I>&gt;<i> 
</I>&gt;<i>     if (!initialized) {
</I>&gt;<i>         memset(pools, '\0', sizeof(pools));
</I>&gt;<i>         initialized = true;
</I>&gt;<i>     }
</I>
This committed code does nothing useful: Static variables, such as
&quot;pools&quot; are zero-initialized by default and that happens at constant
initialization time.

The &quot;initialized&quot; flag is useful for the changes in your patch, but the
the comment in the patch would become misleading after the memset() call
is removed because the flag essentially applies to the Mem::Init() call
and not the &quot;pools&quot; variable. In other words, the final code should look
something like this:


static MemAllocator &amp;
GetPool(size_t type)
{
    static MemAllocator *pools[MEM_MAX];

    static bool initialized = false;
    if (!initialized) {
        Initialize(pools);
        initialized = true;
    }

    MemAllocator *pool = pools[type];
    assert(pool);
    return *pool;
}

Where the static Initialize() method initializes all pools in &quot;pools&quot;
without calling GetPool(). If you want to add another safety check, then
add an assertion (to the Initialize() function) that Initialize() is not
called twice.

The new Initialize() function is essentially a constructor for our
implicit array&lt;MemAllocator*&gt; type...


If you are sure that modern cache manager supports registrations during
static initializations, then Initialize() can be Mem::Init(). In that
case, do not make Mem::Init() public. If you are not sure, then split
memory initialization (in new private Initialize()) and cache manager
registration (still in Mem::Init()).


&gt;&gt;&gt;<i> +static MemAllocator *&amp;
</I>&gt;&gt;&gt;<i> +GetPool(size_t type)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +    static MemAllocator *pools[MEM_MAX];
</I>&gt;&gt;&gt;<i> +    static bool initialized = false;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +    if (!initialized) {
</I>&gt;&gt;&gt;<i> +        memset(pools, '\0', sizeof(pools));
</I>&gt;&gt;&gt;<i> +        initialized = true;
</I>&gt;&gt;&gt;<i> +    }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +    return pools[type];
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  /* find appropriate pool and use it (pools always init buffer with 0s) */
</I>&gt;&gt;&gt;<i>  void *
</I>&gt;&gt;&gt;<i>  memAllocate(mem_type type)
</I>&gt;&gt;&gt;<i>  {
</I>&gt;&gt;&gt;<i> -    assert(MemPools[type]);
</I>&gt;&gt;&gt;<i> -    return MemPools[type]-&gt;alloc();
</I>&gt;&gt;&gt;<i> +    assert(GetPool(type));
</I>&gt;&gt;&gt;<i> +    return GetPool(type)-&gt;alloc();
</I>&gt;&gt;&gt;<i>  }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AFAICT, this combination will assert if memAllocate() (or any similar
</I>&gt;&gt;<i> external caller) is called &quot;too early&quot;.
</I>

&gt;<i> That is intentional.
</I>
That intention is wrong IMO.

Why intentionally delay pool initialization? I see nothing related to
pools initialization that cannot be done when the pools are needed for
the first time. The Initialize() function mentioned above can do all the
initialization. The cache manager registration can wait if needed, of
course.


&gt;<i> @@ -69,12 +69,15 @@
</I>&gt;<i>      if (!initialized) {
</I>&gt;<i>          memset(pools, '\0', sizeof(pools));
</I>&gt;<i>          initialized = true;
</I>&gt;<i> +        // Mem::Init() makes use of GetPool(type) to initialize
</I>&gt;<i> +        // the actual pools. So must come after the flag is true
</I>&gt;<i> +        Mem::Init();
</I>&gt;<i>      }
</I>

&gt;<i> I've made the situation a little bit safer by calling Mem::Init() in the
</I>&gt;<i> initialization branch of GetPool(). 
</I>
This change was the right step. Please make sure cache manager
registration is safe at static initialization time OR move cache manager
registration call elsewhere (e.g., leaving registration in public
Mem::Init() while private Initialize() focuses on memory initialization
alone).


&gt;<i> But the risk still exists for pools
</I>&gt;<i> which are not initialized by Mem::init(). 
</I>
Yes, and that risk should be addressed IMO! Can we move those few
&quot;stray&quot; memDataInit() calls into Initialize()? They only need class
sizes so perhaps #including the necessary headers will not cause any new
linking problems, but I do not know that.

If &quot;place all memDataInit() calls in Initialize()&quot; strategy does create
linking problems, then each module causing these linking problems should
probably have its own dedicated memory pool object without going through
centralized initialization. That dedicated pool object must be
initialized upon first use as well, of course. This option requires more
work to avoid code duplication, but I do not think it would be very
difficult to implement if the simpler strategy fails.

Besides the two alternatives above, I cannot think of other ways to
fully solve the initialization order problem. Better suggestions are
welcomed, of course.


&gt;<i> Having an assert for that case
</I>&gt;<i> is still best as it highlights that the code being changed is broken
</I>&gt;<i> when the dev runs the change.
</I>
Why is an assert (that may or may not trigger for the developer who is
changing the code) is better than as-needed or on-first-use initialization?


&gt;<i> We can't return a reference here since the initializer functions make
</I>&gt;<i> use of GetPool(t) to locate the array pointer to be set.
</I>
In the fixed code I am talking about, the initialization happens before
GetPool() returns. Thus, GetPool() always returns a ready-to-use pool
and, hence, can return a reference to it.


HTH,

Alex.

</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005512.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
	<LI>Next message: <A HREF="005524.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5517">[ date ]</a>
              <a href="thread.html#5517">[ thread ]</a>
              <a href="subject.html#5517">[ subject ]</a>
              <a href="author.html#5517">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
