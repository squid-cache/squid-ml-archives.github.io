<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 4438 - string pool refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FC09A0.3080309%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005517.html">
   <LINK REL="Next"  HREF="005525.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 4438 - string pool refactoring</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FC09A0.3080309%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Bug 4438 - string pool refactoring">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Mar 30 17:15:12 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005517.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
        <LI>Next message: <A HREF="005525.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5524">[ date ]</a>
              <a href="thread.html#5524">[ thread ]</a>
              <a href="subject.html#5524">[ subject ]</a>
              <a href="author.html#5524">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 30/03/2016 8:19 a.m., Alex Rousskov wrote:
&gt;<i> On 03/29/2016 10:15 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 26/03/2016 3:28 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> the committed version is buggy IMHO
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> &lt;<A HREF="http://pixy.kinkie.it/~kinkie/irc-logs/bot/index.php?d=2016-03-23">http://pixy.kinkie.it/~kinkie/irc-logs/bot/index.php?d=2016-03-23</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;
</I>&gt;&gt;<i> [20:07:04]
</I>&gt;&gt;<i> yadi
</I>&gt;&gt;<i> what I mean is the pools are MemPool class instances. if they get
</I>&gt;&gt;<i> destructed on exit() while some other class is still not-yet destructed
</I>&gt;&gt;<i> and using pooled memory we have trouble.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [21:24:58]
</I>&gt;&gt;<i> rousskov
</I>&gt;&gt;<i> yadi, I know that you have meant that. What I am saying is that MemPool
</I>&gt;&gt;<i> cannot be destructed until there are no allocations alive.
</I>&gt;&gt;<i> &quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I may still be misunderstanding you. I took that as meaning we had it right.
</I>&gt;<i> 
</I>&gt;<i> The committed code was wrong. My subsequent &quot;cannot be destructed&quot; IRC
</I>&gt;<i> comment above should be interpreted as &quot;Squid should make premature
</I>&gt;<i> MemPools Instance destruction impossible; it is currently possible&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> The only other object which might share this problem is GetPool(t). Its
</I>&gt;&gt;<i> object is POD though.
</I>&gt;<i> 
</I>&gt;<i> I agree that the &quot;pools&quot; variable inside GetPool() is fine as far as
</I>&gt;<i> initialization/destruction order is concerned.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    static MemPools *Instance = nullptr;
</I>&gt;&gt;<i> +    if (!Instance) {
</I>&gt;&gt;<i> +        Instance = new MemPools;
</I>&gt;&gt;<i> +    }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It is much easier (and faster) to just say:
</I>&gt;<i> 
</I>&gt;<i>   static MemPools *Instance = new MemPools;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>      /* Must use this idiom, as we can be double-initialised
</I>&gt;&gt;<i>       * if we are called during static initialisations.
</I>&gt;&gt;<i>       */
</I>&gt;<i> 
</I>&gt;<i> I recommend removing that comment. It misleads more than it helps IMO.
</I>&gt;<i> If you want to put a comment there, say something like
</I>&gt;<i> 
</I>&gt;<i>   // We must initialize on first use (which may happen during static
</I>&gt;<i>   // initialization) and preserve until the last user is gone (which
</I>&gt;<i>   // may happen long after main() exit). We currently preserve forever.
</I>&gt;<i>   static MemPools *Instance = new MemPools;
</I>&gt;<i> 
</I>
Done.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>     static bool initialized = false;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     if (!initialized) {
</I>&gt;&gt;<i>         memset(pools, '\0', sizeof(pools));
</I>&gt;&gt;<i>         initialized = true;
</I>&gt;&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> This committed code does nothing useful: Static variables, such as
</I>&gt;<i> &quot;pools&quot; are zero-initialized by default and that happens at constant
</I>&gt;<i> initialization time.
</I>
Not necessarily. That is OS and allocator library dependent behaviour.

For exmple, my compiler disagrees with you. use-before-initialization on
the return statement for any pool pointer not initialized by Mem::Init()
when the memset() is removed.

&gt;<i> 
</I>&gt;<i> The &quot;initialized&quot; flag is useful for the changes in your patch, but the
</I>&gt;<i> the comment in the patch would become misleading after the memset() call
</I>&gt;<i> is removed because the flag essentially applies to the Mem::Init() call
</I>&gt;<i> and not the &quot;pools&quot; variable. In other words, the final code should look
</I>&gt;<i> something like this:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static MemAllocator &amp;
</I>
In order to use a reference here MemAllocator will have to forgo
constructor parameters, and move its initialization into a virtual
method. MEMPROXY_CLASS macro and MemPool::GetInstance().create method
will both have to be updated to get their object from GetPool(t) then
check if it has been initialized, then call that method on it. Which is
far more complicated than what we have now.

Note that to construct a MemAllocator child one must provide a name
label and the size of objects it will produce.

By returning a reference to pointer here (possibly a nullptr) we retain
all the existing behaviour and code throughout Squid creating pools.


&gt;<i> GetPool(size_t type)
</I>&gt;<i> {
</I>&gt;<i>     static MemAllocator *pools[MEM_MAX];
</I>&gt;<i> 
</I>&gt;<i>     static bool initialized = false;
</I>&gt;<i>     if (!initialized) {
</I>&gt;<i>         Initialize(pools);
</I>&gt;<i>         initialized = true;
</I>
That was the first thing I tried. Well, using Mem::Init() as the
Initialize() anyway. It results in recursion blowing out the stack until
SEGFAULT.

&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i>     MemAllocator *pool = pools[type];
</I>&gt;<i>     assert(pool);
</I>&gt;<i>     return *pool;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Where the static Initialize() method initializes all pools in &quot;pools&quot;
</I>&gt;<i> without calling GetPool(). If you want to add another safety check, then
</I>&gt;<i> add an assertion (to the Initialize() function) that Initialize() is not
</I>&gt;<i> called twice.
</I>
The Mem::Init() method does not use GetPool() directly, it uses
GetInstance().create which allocates a new object and self-registers the
raw-pointer using a second call to GetPool(t).

==&gt; the MemAllocator does not live inside the GetPool() array. That
array is just a global registry of pointers to which allocators are active.

==&gt; Other code outside of libmem also uses
MemPools::GetInstance().create() to initialize both their own per-type
allocator and the pools it is allocating from.

==&gt; There may be multiple types of allocator operating depending on a)
what the MEMPOOLS environment variable was set to at the time each
allocator was first created, and b) what squid.conf pools on/off setting
was at most recent reconfigure predating the classes first use.

==&gt; allocator lifetimes may need to predate or exceed libmem lifetime.
Particularly lasting until its owner class X's own .o unit destruction
during shutdown.


&gt;<i> 
</I>&gt;<i> The new Initialize() function is essentially a constructor for our
</I>&gt;<i> implicit array&lt;MemAllocator*&gt; type...
</I>
meaning the only useful thing the Initialize() function does would be
that memset().

&gt;<i> 
</I>&gt;<i> If you are sure that modern cache manager supports registrations during
</I>&gt;<i> static initializations, then Initialize() can be Mem::Init(). In that
</I>&gt;<i> case, do not make Mem::Init() public. If you are not sure, then split
</I>&gt;<i> memory initialization (in new private Initialize()) and cache manager
</I>&gt;<i> registration (still in Mem::Init()).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> +static MemAllocator *&amp;
</I>&gt;&gt;&gt;&gt;<i> +GetPool(size_t type)
</I>&gt;&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;&gt;<i> +    static MemAllocator *pools[MEM_MAX];
</I>&gt;&gt;&gt;&gt;<i> +    static bool initialized = false;
</I>&gt;&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;&gt;<i> +    if (!initialized) {
</I>&gt;&gt;&gt;&gt;<i> +        memset(pools, '\0', sizeof(pools));
</I>&gt;&gt;&gt;&gt;<i> +        initialized = true;
</I>&gt;&gt;&gt;&gt;<i> +    }
</I>&gt;&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;&gt;<i> +    return pools[type];
</I>&gt;&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  /* find appropriate pool and use it (pools always init buffer with 0s) */
</I>&gt;&gt;&gt;&gt;<i>  void *
</I>&gt;&gt;&gt;&gt;<i>  memAllocate(mem_type type)
</I>&gt;&gt;&gt;&gt;<i>  {
</I>&gt;&gt;&gt;&gt;<i> -    assert(MemPools[type]);
</I>&gt;&gt;&gt;&gt;<i> -    return MemPools[type]-&gt;alloc();
</I>&gt;&gt;&gt;&gt;<i> +    assert(GetPool(type));
</I>&gt;&gt;&gt;&gt;<i> +    return GetPool(type)-&gt;alloc();
</I>&gt;&gt;&gt;&gt;<i>  }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> AFAICT, this combination will assert if memAllocate() (or any similar
</I>&gt;&gt;&gt;<i> external caller) is called &quot;too early&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> That is intentional.
</I>&gt;<i> 
</I>&gt;<i> That intention is wrong IMO.
</I>&gt;<i> 
</I>&gt;<i> Why intentionally delay pool initialization?
</I>
Because only the caller code (same code using memAllocate BTW) knows
what the pool parameters need to be initialized to. Including what
object type the allocator pointed to will be.


&gt;<i> I see nothing related to
</I>&gt;<i> pools initialization that cannot be done when the pools are needed for
</I>&gt;<i> the first time. The Initialize() function mentioned above can do all the
</I>&gt;<i> initialization. The cache manager registration can wait if needed, of
</I>&gt;<i> course.
</I>
They are. Just not by GetPool(t). The relevant class operator new()
initializes an MemAllocator (aka pool) on first dynamic object creation
and registers it (aka. sets the GetPool(t) pointer).

Also, this way the statistics is not inadvertently initializing unused
pools when it walks the GetPool(t) 't' values.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> @@ -69,12 +69,15 @@
</I>&gt;&gt;<i>      if (!initialized) {
</I>&gt;&gt;<i>          memset(pools, '\0', sizeof(pools));
</I>&gt;&gt;<i>          initialized = true;
</I>&gt;&gt;<i> +        // Mem::Init() makes use of GetPool(type) to initialize
</I>&gt;&gt;<i> +        // the actual pools. So must come after the flag is true
</I>&gt;&gt;<i> +        Mem::Init();
</I>&gt;&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> I've made the situation a little bit safer by calling Mem::Init() in the
</I>&gt;&gt;<i> initialization branch of GetPool(). 
</I>&gt;<i> 
</I>&gt;<i> This change was the right step. Please make sure cache manager
</I>&gt;<i> registration is safe at static initialization time OR move cache manager
</I>&gt;<i> registration call elsewhere (e.g., leaving registration in public
</I>&gt;<i> Mem::Init() while private Initialize() focuses on memory initialization
</I>&gt;<i> alone).
</I>
Done. It was using a member static. I have moved that member into the
GetInstance() method, which will resolve any issues we might have had.

&gt;<i> 
</I>&gt;&gt;<i> But the risk still exists for pools
</I>&gt;&gt;<i> which are not initialized by Mem::init(). 
</I>&gt;<i> 
</I>&gt;<i> Yes, and that risk should be addressed IMO! Can we move those few
</I>&gt;<i> &quot;stray&quot; memDataInit() calls into Initialize()? They only need class
</I>&gt;<i> sizes so perhaps #including the necessary headers will not cause any new
</I>&gt;<i> linking problems, but I do not know that.
</I>&gt;<i> 
</I>&gt;<i> If &quot;place all memDataInit() calls in Initialize()&quot; strategy does create
</I>&gt;<i> linking problems, then each module causing these linking problems should
</I>&gt;<i> probably have its own dedicated memory pool object without going through
</I>&gt;<i> centralized initialization. That dedicated pool object must be
</I>&gt;<i> initialized upon first use as well, of course. This option requires more
</I>&gt;<i> work to avoid code duplication, but I do not think it would be very
</I>&gt;<i> difficult to implement if the simpler strategy fails.
</I>&gt;<i> 
</I>&gt;<i> Besides the two alternatives above, I cannot think of other ways to
</I>&gt;<i> fully solve the initialization order problem. Better suggestions are
</I>&gt;<i> welcomed, of course.
</I>&gt;<i> 
</I>
The proposed patch solves both initialization and destruction cycles fine.

The quibbling is over whether GetPools(t) should be (de-)optimized to
return a pure reference or left with the original raw-pointer based design.

Converting to a pure reference means re-architecting the whole allocator
ownership and lifetime design. Possibly for the worse as the allocators
lifetime will then match libmem instead of whatever lifetime the .o/.la
unit using it has.

&gt;<i> 
</I>&gt;&gt;<i> Having an assert for that case
</I>&gt;&gt;<i> is still best as it highlights that the code being changed is broken
</I>&gt;&gt;<i> when the dev runs the change.
</I>&gt;<i> 
</I>&gt;<i> Why is an assert (that may or may not trigger for the developer who is
</I>&gt;<i> changing the code) is better than as-needed or on-first-use initialization?
</I>&gt;<i> 
</I>
This one is better because any object type using this function needs a
redesign to use the newer on-first-use API of libmem. Not the old
after-Mem::Init() API.
This assert will only blow up in the fact of the coder trying to make a
class do something the whole class is not designed to do.

&gt;<i> 
</I>&gt;&gt;<i> We can't return a reference here since the initializer functions make
</I>&gt;&gt;<i> use of GetPool(t) to locate the array pointer to be set.
</I>&gt;<i> 
</I>&gt;<i> In the fixed code I am talking about, the initialization happens before
</I>&gt;<i> GetPool() returns. Thus, GetPool() always returns a ready-to-use pool
</I>&gt;<i> and, hence, can return a reference to it.
</I>
That means every call to GetPools() will have to be instrumented with
the text label and size of the object wanted back. Just in case this
call was the first ever use of the pool wanted. And GetPools() will have
two if-condition to check for a) pointer array initialization, and b)
individual pool initialization.

GetPool() gets called *a lot* (millions of times per minute) so doubling
the number of if-conditionals tested is not trivial. And it may not even
be possible to pass the correct parameters to all GetPool(t) uses (ie
during statistics dumping).

The current design of GetPool() has only one if-condition to check its
array exists (or not). The allocators are statically initialized pointer
in per-class new() members, such that the initialization occurs only on
first-use. Just not by GetPool() itself - which I think is fine.

Amos

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005517.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
	<LI>Next message: <A HREF="005525.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5524">[ date ]</a>
              <a href="thread.html#5524">[ thread ]</a>
              <a href="subject.html#5524">[ subject ]</a>
              <a href="author.html#5524">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
