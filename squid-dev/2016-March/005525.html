<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 4438 - string pool refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FC1B0F.3030707%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005524.html">
   <LINK REL="Next"  HREF="005528.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 4438 - string pool refactoring</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FC1B0F.3030707%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Bug 4438 - string pool refactoring">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Mar 30 18:29:35 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005524.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
        <LI>Next message: <A HREF="005528.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5525">[ date ]</a>
              <a href="thread.html#5525">[ thread ]</a>
              <a href="subject.html#5525">[ subject ]</a>
              <a href="author.html#5525">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/30/2016 11:15 AM, Amos Jeffries wrote:
&gt;<i> On 30/03/2016 8:19 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> This committed code does nothing useful: Static variables, such as
</I>&gt;&gt;<i> &quot;pools&quot; are zero-initialized by default and that happens at constant
</I>&gt;&gt;<i> initialization time.
</I>

&gt;<i> Not necessarily. That is OS and allocator library dependent behaviour.
</I>
It is guaranteed by the C++ standard. See the &quot;Static initialization&quot;
section at <A HREF="http://en.cppreference.com/w/cpp/language/initialization">http://en.cppreference.com/w/cpp/language/initialization</A>



&gt;<i> For exmple, my compiler disagrees with you. use-before-initialization on
</I>&gt;<i> the return statement for any pool pointer not initialized by Mem::Init()
</I>&gt;<i> when the memset() is removed.
</I>
AFAICT, either you are compiling some code that is different from the
one I was talking about or your compiler is buggy: Static PODs *are*
zero-initialized by default.


&gt;&gt;<i> The &quot;initialized&quot; flag is useful for the changes in your patch, but the
</I>&gt;&gt;<i> the comment in the patch would become misleading after the memset() call
</I>&gt;&gt;<i> is removed because the flag essentially applies to the Mem::Init() call
</I>&gt;&gt;<i> and not the &quot;pools&quot; variable. In other words, the final code should look
</I>&gt;&gt;<i> something like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> static MemAllocator &amp;
</I>&gt;<i> 
</I>&gt;<i> In order to use a reference here MemAllocator will have to forgo
</I>&gt;<i> constructor parameters, and move its initialization into a virtual
</I>&gt;<i> method.
</I>
Only if you leave the related bugs intact, which obviously does not make
sense. GetPool() should be returning a reference to an initialized pool
object. How that pool was initialized is a separate issue. I do not
think that individual pool initialization API needs any [drastic]
changes. What we do need to change is when that initialization happens
and, possibly, how some of the initialized pools are stored.


&gt;<i> By returning a reference to pointer here (possibly a nullptr) we retain
</I>&gt;<i> all the existing behaviour and code throughout Squid creating pools.
</I>
Yes, including the existing or future bugs where that nullptr is
dereferenced.


&gt;&gt;<i> GetPool(size_t type)
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i>     static MemAllocator *pools[MEM_MAX];
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     static bool initialized = false;
</I>&gt;&gt;<i>     if (!initialized) {
</I>&gt;&gt;<i>         Initialize(pools);
</I>&gt;&gt;<i>         initialized = true;
</I>&gt;<i> 
</I>&gt;<i> That was the first thing I tried. Well, using Mem::Init() as the
</I>&gt;<i> Initialize() anyway. It results in recursion blowing out the stack until
</I>&gt;<i> SEGFAULT.
</I>
I do not understand why you mention that. My suggestion does not imply
that you can use Mem::Init() without changes here. In fact, I have
described exactly why you cannot do that immediately below this code
snippet. And there may be other changes that you have to do to make
things work -- I am not dictating code by email.


&gt;&gt;<i>     }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     MemAllocator *pool = pools[type];
</I>&gt;&gt;<i>     assert(pool);
</I>&gt;&gt;<i>     return *pool;
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Where the static Initialize() method initializes all pools in &quot;pools&quot;
</I>&gt;&gt;<i> without calling GetPool(). If you want to add another safety check, then
</I>&gt;&gt;<i> add an assertion (to the Initialize() function) that Initialize() is not
</I>&gt;&gt;<i> called twice.
</I>

&gt;<i> The Mem::Init() method does not use GetPool() directly, it uses
</I>&gt;<i> GetInstance().create which allocates a new object and self-registers the
</I>&gt;<i> raw-pointer using a second call to GetPool(t).
</I>
To make pooling [initialization] safe, Initialize() or modified
Mem::Init(), cannot call GetPool() directly or indirectly. GetPool()
should return a ready-to-use pool object. Fixed initialization functions
should not _need_ to call GetPool() because they deal with
initialization only.


&gt;&gt;<i> The new Initialize() function is essentially a constructor for our
</I>&gt;&gt;<i> implicit array&lt;MemAllocator*&gt; type...
</I>
&gt;<i> meaning the only useful thing the Initialize() function does would be
</I>&gt;<i> that memset().
</I>
Meaning that it has to initialize all pools that we currently initialize
from Mem::Init() plus any pools that we can easily initialize from
Mem::Init() but do not (if any). All other pools should not be obtained
via the GetPool() API and, hence, should not be a part of the &quot;pools&quot;
array tied to that API.


&gt;&gt;&gt;&gt;<i> AFAICT, this combination will assert if memAllocate() (or any similar
</I>&gt;&gt;&gt;&gt;<i> external caller) is called &quot;too early&quot;.
</I>
&gt;&gt;&gt;<i> That is intentional.
</I>
&gt;&gt;<i> That intention is wrong IMO.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why intentionally delay pool initialization?
</I>

&gt;<i> Because only the caller code (same code using memAllocate BTW) knows
</I>&gt;<i> what the pool parameters need to be initialized to. Including what
</I>&gt;<i> object type the allocator pointed to will be.
</I>
Either that caller code should be inside Initialize() or it should not
use the &quot;pools&quot; array and its GetPool() API. Otherwise, we have no
guarantee that the pool initialization caller will get to that array
before a pool user will, resulting in the same kind of bugs we are
fixing now. &quot;Do not return pointers to callers that expect a valid
object&quot; is a simple/basic design principle. We should not be fighting
over it! Everything else in this discussion flows from that principle.


&gt;&gt;<i> I see nothing related to
</I>&gt;&gt;<i> pools initialization that cannot be done when the pools are needed for
</I>&gt;&gt;<i> the first time. The Initialize() function mentioned above can do all the
</I>&gt;&gt;<i> initialization. The cache manager registration can wait if needed, of
</I>&gt;&gt;<i> course.
</I>
&gt;<i> They are. Just not by GetPool(t). The relevant class operator new()
</I>&gt;<i> initializes an MemAllocator (aka pool) on first dynamic object creation
</I>&gt;<i> and registers it (aka. sets the GetPool(t) pointer).
</I>
Class-specific allocators do not need access to the &quot;pools&quot; array. They
can use their own class-specific pool.



&gt;<i> The proposed patch solves both initialization and destruction cycles fine.
</I>
It does not. It leaves some pools uninitialized and, hence, exposed to
the use-before-initialization danger in the current or future code.


&gt;<i> The quibbling is over whether GetPools(t) should be (de-)optimized to
</I>&gt;<i> return a pure reference or left with the original raw-pointer based design.
</I>
This is not about the return type as such. It is about having nil pools
and then asserting when those pools are accessed before they are
initialized. It is not quibbling. The current and proposed code is bad
and will cause problems sooner or later. You are free to ignore those
dangers if you wish, of course. I cannot force you to finish fixing what
you have started to fix.


&gt;&gt;&gt;<i> We can't return a reference here since the initializer functions make
</I>&gt;&gt;&gt;<i> use of GetPool(t) to locate the array pointer to be set.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In the fixed code I am talking about, the initialization happens before
</I>&gt;&gt;<i> GetPool() returns. Thus, GetPool() always returns a ready-to-use pool
</I>&gt;&gt;<i> and, hence, can return a reference to it.
</I>
&gt;<i> That means every call to GetPools() will have to be instrumented with
</I>&gt;<i> the text label and size of the object wanted back. Just in case this
</I>&gt;<i> call was the first ever use of the pool wanted.
</I>...

Not at all. The &quot;pools&quot; array is initialized before first use by
Initialize() code similar to the current Mem::Init(). Any pool inside
the old &quot;pools&quot; array that cannot be initialized from Initialize() is
removed from &quot;pools&quot; (because it is not safe to keep it there) and is
moved where it can be safely initialized before (or upon) the first use.


&gt;<i> The current design of GetPool() has only one if-condition to check its
</I>&gt;<i> array exists (or not).
</I>
Yes, and I do not propose to change that.


&gt;<i> The allocators are statically initialized pointer
</I>&gt;<i> in per-class new() members, such that the initialization occurs only on
</I>&gt;<i> first-use. Just not by GetPool() itself - which I think is fine.
</I>
Returning nil from GetPool() is not fine because GetPool() does not know
whether the caller is going to initialize that pool pointer or
dereference it. I do not think it is very difficult to adjust the code
so that we do not have to live with that risk, but you have the right to
refuse to do so. I am thankful that we stop now and not five iterations
earlier when the code was in a much worse shape. Somebody can always
come back to this later, when Squid starts crashing again.


Thank you,

Alex.

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005524.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
	<LI>Next message: <A HREF="005528.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5525">[ date ]</a>
              <a href="thread.html#5525">[ thread ]</a>
              <a href="subject.html#5525">[ subject ]</a>
              <a href="author.html#5525">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
