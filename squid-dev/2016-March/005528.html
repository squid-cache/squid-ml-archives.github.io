<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Bug 4438 - string pool refactoring
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FCF867.7030607%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005525.html">
   <LINK REL="Next"  HREF="005530.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Bug 4438 - string pool refactoring</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Bug%204438%20-%20string%20pool%20refactoring&In-Reply-To=%3C56FCF867.7030607%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Bug 4438 - string pool refactoring">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Mar 31 10:13:59 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005525.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
        <LI>Next message: <A HREF="005530.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5528">[ date ]</a>
              <a href="thread.html#5528">[ thread ]</a>
              <a href="subject.html#5528">[ subject ]</a>
              <a href="author.html#5528">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 31/03/2016 7:29 a.m., Alex Rousskov wrote:
&gt;<i> On 03/30/2016 11:15 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 30/03/2016 8:19 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> This committed code does nothing useful: Static variables, such as
</I>&gt;&gt;&gt;<i> &quot;pools&quot; are zero-initialized by default and that happens at constant
</I>&gt;&gt;&gt;<i> initialization time.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Not necessarily. That is OS and allocator library dependent behaviour.
</I>&gt;<i> 
</I>&gt;<i> It is guaranteed by the C++ standard. See the &quot;Static initialization&quot;
</I>&gt;<i> section at <A HREF="http://en.cppreference.com/w/cpp/language/initialization">http://en.cppreference.com/w/cpp/language/initialization</A>
</I>&gt;<i> 
</I>
Okay. But forgive me for not trusting to that. I've left the pointers
being zeroed explicitly for now.

&gt;<i> 
</I>&gt;&gt;<i> For exmple, my compiler disagrees with you. use-before-initialization on
</I>&gt;&gt;<i> the return statement for any pool pointer not initialized by Mem::Init()
</I>&gt;&gt;<i> when the memset() is removed.
</I>&gt;<i> 
</I>&gt;<i> AFAICT, either you are compiling some code that is different from the
</I>&gt;<i> one I was talking about or your compiler is buggy: Static PODs *are*
</I>&gt;<i> zero-initialized by default.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> The &quot;initialized&quot; flag is useful for the changes in your patch, but the
</I>&gt;&gt;&gt;<i> the comment in the patch would become misleading after the memset() call
</I>&gt;&gt;&gt;<i> is removed because the flag essentially applies to the Mem::Init() call
</I>&gt;&gt;&gt;<i> and not the &quot;pools&quot; variable. In other words, the final code should look
</I>&gt;&gt;&gt;<i> something like this:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> static MemAllocator &amp;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In order to use a reference here MemAllocator will have to forgo
</I>&gt;&gt;<i> constructor parameters, and move its initialization into a virtual
</I>&gt;&gt;<i> method.
</I>&gt;<i> 
</I>&gt;<i> Only if you leave the related bugs intact, which obviously does not make
</I>&gt;<i> sense. GetPool() should be returning a reference to an initialized pool
</I>&gt;<i> object. How that pool was initialized is a separate issue. I do not
</I>&gt;<i> think that individual pool initialization API needs any [drastic]
</I>&gt;<i> changes. What we do need to change is when that initialization happens
</I>&gt;<i> and, possibly, how some of the initialized pools are stored.
</I>&gt;<i> 
</I>
All the code currently using GetPool assumes its a pointer. Most of that
code is untouched by me in any of this. While I agree that using a
reference is better, doing the conversion right now is too big a task. I
have been trying various ways to do it between these mails.


&gt;<i> 
</I>&gt;&gt;<i> By returning a reference to pointer here (possibly a nullptr) we retain
</I>&gt;&gt;<i> all the existing behaviour and code throughout Squid creating pools.
</I>&gt;<i> 
</I>&gt;<i> Yes, including the existing or future bugs where that nullptr is
</I>&gt;<i> dereferenced.
</I>
Yes. There is a reason GetPool(t) is defined locally inside a file
called &quot;old_api&quot;. It and all the functions using its pointers are
deprecated. New code and updated objects should all be made into
MEMPROXY objects.

All those old functions and callers currently assume they are working
with pointers. Some of the things I have been trying to point out to you
are where they rely on that to do things that are not possible with a
reference to pre-initialized object. Such as creating a variable-type
object whose pointer gets stored in the GetPool(t) array _by the caller_.

The amount of change and testing needed to make this a reference like
you want is just too much for an already deprecated allocator design.
Far easier/better to convert to the new API - and none of this helps
with the actual destructor sequence problem in trunk. That was solved a
while back with GetStrPool(sz) fixes (which does use a reference now).


&gt;<i> 
</I>&gt;&gt;&gt;&gt;&gt;<i> AFAICT, this combination will assert if memAllocate() (or any similar
</I>&gt;&gt;&gt;&gt;&gt;<i> external caller) is called &quot;too early&quot;.
</I>&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> That is intentional.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> That intention is wrong IMO.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Why intentionally delay pool initialization?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Because only the caller code (same code using memAllocate BTW) knows
</I>&gt;&gt;<i> what the pool parameters need to be initialized to. Including what
</I>&gt;&gt;<i> object type the allocator pointed to will be.
</I>&gt;<i> 
</I>&gt;<i> Either that caller code should be inside Initialize() or it should not
</I>&gt;<i> use the &quot;pools&quot; array and its GetPool() API. Otherwise, we have no
</I>&gt;<i> guarantee that the pool initialization caller will get to that array
</I>&gt;<i> before a pool user will, resulting in the same kind of bugs we are
</I>&gt;<i> fixing now. &quot;Do not return pointers to callers that expect a valid
</I>&gt;<i> object&quot; is a simple/basic design principle. We should not be fighting
</I>&gt;<i> over it! Everything else in this discussion flows from that principle.
</I>
The old code using this API is simply that. Old. This is just one of the
ways its &quot;broken&quot; - despite that it all seems to be hanging together
pretty well these past few decades.

I would like to re-code it straight to using MEMPROXY APIs. Not to
recode it to use a &quot;perfect&quot; GetPool() design, only to throw that work
away in a few weeks/months/immediately.


&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> We can't return a reference here since the initializer functions make
</I>&gt;&gt;&gt;&gt;<i> use of GetPool(t) to locate the array pointer to be set.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In the fixed code I am talking about, the initialization happens before
</I>&gt;&gt;&gt;<i> GetPool() returns. Thus, GetPool() always returns a ready-to-use pool
</I>&gt;&gt;&gt;<i> and, hence, can return a reference to it.
</I>&gt;<i> 
</I>&gt;&gt;<i> That means every call to GetPools() will have to be instrumented with
</I>&gt;&gt;<i> the text label and size of the object wanted back. Just in case this
</I>&gt;&gt;<i> call was the first ever use of the pool wanted.
</I>&gt;<i> ...
</I>&gt;<i> 
</I>&gt;<i> Not at all. The &quot;pools&quot; array is initialized before first use by
</I>&gt;<i> Initialize() code similar to the current Mem::Init(). Any pool inside
</I>&gt;<i> the old &quot;pools&quot; array that cannot be initialized from Initialize() is
</I>&gt;<i> removed from &quot;pools&quot; (because it is not safe to keep it there) and is
</I>&gt;<i> moved where it can be safely initialized before (or upon) the first use.
</I>
What you are describing here sounds almost exactly like the tasks done
when re-factoring classes to use MEMPROXY 'new API'.

I believe we have all been in agreement on moving to that API for some
time and quite a few objects already have done the move in recent years.
Finishing off that conversion is out of scope for this particular change
though. Its looking closer than ever now so I hope to have time to
finish it soon-ish either way.


&gt;<i> 
</I>&gt;&gt;<i> The allocators are statically initialized pointer
</I>&gt;&gt;<i> in per-class new() members, such that the initialization occurs only on
</I>&gt;&gt;<i> first-use. Just not by GetPool() itself - which I think is fine.
</I>&gt;<i> 
</I>&gt;<i> Returning nil from GetPool() is not fine because GetPool() does not know
</I>&gt;<i> whether the caller is going to initialize that pool pointer or
</I>&gt;<i> dereference it. I do not think it is very difficult to adjust the code
</I>&gt;<i> so that we do not have to live with that risk, but you have the right to
</I>&gt;<i> refuse to do so. I am thankful that we stop now and not five iterations
</I>&gt;<i> earlier when the code was in a much worse shape. Somebody can always
</I>&gt;<i> come back to this later, when Squid starts crashing again.
</I>

Okay. With the understanding that a) what we have is only a stable
half-way point, and b) the old code is working well enough with pointers
that Squid should not crash for a while.  I am going to merge what has
been done provided it passes some testing and get on with the release
this weekend. Returning to the memory issues afterwards.

Amos

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005525.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
	<LI>Next message: <A HREF="005530.html">[squid-dev] [PATCH] Bug 4438 - string pool refactoring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5528">[ date ]</a>
              <a href="thread.html#5528">[ thread ]</a>
              <a href="subject.html#5528">[ subject ]</a>
              <a href="author.html#5528">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
