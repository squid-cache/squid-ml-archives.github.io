<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] mime unfolding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3Cc3fee745-1fed-64ba-e788-cc6f2e7e4ab6%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005652.html">
   <LINK REL="Next"  HREF="005656.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] mime unfolding</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3Cc3fee745-1fed-64ba-e788-cc6f2e7e4ab6%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] mime unfolding">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu May 12 11:55:49 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005652.html">[squid-dev] [PATCH] mime unfolding
</A></li>
        <LI>Next message: <A HREF="005656.html">[squid-dev] [PATCH] mime unfolding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5653">[ date ]</a>
              <a href="thread.html#5653">[ thread ]</a>
              <a href="subject.html#5653">[ subject ]</a>
              <a href="author.html#5653">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/05/2016 5:34 a.m., Alex Rousskov wrote:
&gt;<i> On 05/11/2016 05:32 AM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> +    if (mimeHeaderBlock_.length() &lt; 2) {
</I>&gt;&gt;<i> +        if (mimeHeaderBlock_[0] == '\n')
</I>&gt;&gt;<i> +            mimeHeaderBlock_ = Http1::CrLf();
</I>&gt;&gt;<i> +        else
</I>&gt;&gt;<i> +            mimeHeaderBlock_.append(Http1::CrLf());
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +    // now mimeHeaderBlock_ has 0+ fields followed by the CRLF terminator
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> mimeHeaderBlock_[0] does not exist when mimeHeaderBlock_ is empty (the
</I>&gt;<i> append statement implies that the block may be empty). The comment lies
</I>&gt;<i> about CRLF terminator because CR may be still missing in longer blocks.
</I>&gt;<i> Moreover, I suspect you do not need this code at all if the loop below
</I>&gt;<i> is fixed!
</I>&gt;<i> 
</I>
Oaky. That can be fixed with a simple isEmpty() check.

&gt;<i> 
</I>&gt;&gt;<i> +    do {
</I>&gt;&gt;<i> +        SBuf line;
</I>&gt;&gt;<i> +        if (tok.prefix(line, nonCRLF))
</I>&gt;&gt;<i> +            mimeHeaderBlock_.append(line);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        // the skipAll() might erase bare-CR not part of a CR*LF
</I>&gt;&gt;<i> +        SBuf savePoint(tok.remaining());
</I>&gt;&gt;<i> +        auto crLen = tok.skipAll(CharacterSet::CR);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        if (tok.skipOne(CharacterSet::LF)) {
</I>&gt;&gt;<i> +            if (tok.skipAll(CharacterSet::WSP))
</I>&gt;&gt;<i> +                mimeHeaderBlock_.append(' ');
</I>&gt;&gt;<i> +            else
</I>&gt;&gt;<i> +                mimeHeaderBlock_.append(Http1::CrLf());
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        } else if (crLen) {
</I>&gt;&gt;<i> +            // TODO: it might be better to replace the CR with one SP, but for now preserve
</I>&gt;&gt;<i> +            // preserve the bare-CR
</I>&gt;&gt;<i> +            tok.reset(savePoint);
</I>&gt;&gt;<i> +            if (tok.prefix(line, CharacterSet::CR))
</I>&gt;&gt;<i> +                mimeHeaderBlock_.append(line);
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    } while (!tok.atEnd());
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The above loop requires a genius to fully comprehend.
</I>
Why thank you :-) .

Though it does seem very simple, perhapse the minor crLen optimization
is confusing.

&gt;<i> I certainly cannot
</I>&gt;<i> validate it. I think the whole method ought to be much simpler/clearer.
</I>&gt;<i> Something along these lines:
</I>&gt;<i> 
</I>&gt;<i>     Tokenizer tok(mimeHeaderBlock_);
</I>&gt;<i>     mimeHeaderBlock_.clear();
</I>&gt;<i>     SBuf prefix;
</I>&gt;<i>     while (tokenBeforeObsfolds(tk, prefix)) {
</I>&gt;<i>         mimeHeaderBlock_.append(prefix);
</I>&gt;<i>         mimeHeaderBlock_.append(' ');
</I>&gt;<i>     }
</I>&gt;<i>     mimeHeaderBlock_.append(tk.remaining());
</I>&gt;<i> 
</I>&gt;<i> We already have a Tokenizer::token(prefix, delimiters) method. The
</I>&gt;<i> tokenBeforeObsfolds() call above is exactly the same except the
</I>
If you think their behaviour is exactly the same, then I think you are
misunderstanding the purposes of at least one. But I wont draw out this
thread with that.

&gt;<i> delimiters pattern is more complex. See attachment for a simple
</I>&gt;<i> implementation and review/adjust as needed, of course. I have not tested
</I>&gt;<i> my sketch.
</I>

Besides the 8 compile errors it has several behavioural bugs though I
see you did workaround one of them by adding an extra Tokenizer pass
across the data, which adds another bug.

1) not unfolding.

Consider the trivial case of:

 Foo: bar\r\n
 Folded: hello \r\n
  world\r\n
 \r\n

tokenBeforeObsfolds() will detect a prefix of &quot;Foo: bar\r&quot; and a
non-fold LF.
 causing it to return false.
 which exits the while loop in unfoldMime().
 which appends tok.remaining() to the mime block.

The common traffic case with folding will be to have some header like
Date or Host first with the fold in a later custom header.

Result: no unfolding.

Assuming you can fix that without a lot more complexity..


2) erases characters not part of any folding.
 ... worse: it erases delimiters.

the use of nonLF has consumed into prefix some characters that might
have been part of the fold sequence.
 skipAllTrailing() is used to workaround that bug.
 which consumes again, more characters than the ones that might be part
of the fold.
 resulting in a header value of &quot;helloworld&quot; which should have been
&quot;hello world&quot;.

Whether that was semantically or lexically meant to be one or two tokens
in the header we don't know. But either way it is one token now.

Lets hope that header was not using any of the common delimiter
characters ... um .. as a delimiter.

Result: HTTP semantics are potentially changed for headers both known
and unknown.


The purpose of this unfolder is to unfold. End of task. Not to cleanup
the headers. Nor to impose any &quot;garbage&quot; meaning on the non-fold
characters. That job belongs to the parser logic which does lexical
interpretation of the header field-value.

This logic *cannot* tell the meaning of non-fold characters. This was
why my single loop went out of its way to preserve discovered sequences
of bare-CR, despite how damaging we know that character can be at times.

As a side note. I'm not sure we should treat a whole sequence of folds
as a single SP. We are allowed to replace 1 fold with 1+ SP characters.
But nothing was discussed in the WG about N folds being replaced with
just 1 SP character. So we can't really assume some other
implementations wont interpret each fold as a SP with meaning. It would
be odd, but then anything playing around with sequences of folds is
already odd.


Also note there are whitespace characters which are not part of the fold
sequence. So even though we can remove CR*LF 1*(SP/HTAB) - we cant
safely remove the other 'garbage' whitespace characters as part of the
fold whitespace suffix any more than my demo above can safely remove it
before the CR.


&gt;&gt;<i> +const SBuf &amp;CrLf();
</I>&gt;<i> 
</I>&gt;<i> I suspect this should be defined inline for performance reasons.
</I>
If we do that we have again the issue you brought up earlier about
multiple globals init order, which is why it is not just a member of
Http1::Parser to begin with.

Linkers these days with -flto are smart enough to optimize it away if
the user wants to.


&gt;<i> Inlining may result in duplication of a few CRLF SBufs, but that is
</I>&gt;<i> probably better than the expense of calling a function every time we
</I>&gt;<i> need CRLF. I expect the number of use cases to grow as we polish the code.
</I>&gt;<i> 
</I>
Then we can look at that later if/when the usage grows. Right now it
doesn't really have a proper need to be outside Parser.

&gt;<i> 
</I>&gt;&gt;<i> But the savings is not enough to be bothered with AFAICS. 
</I>&gt;<i> 
</I>&gt;<i> There are no performance savings or losses here to worry about. The code
</I>&gt;<i> in question is &quot;fast enough&quot; for the non-performance-sensitive path it
</I>&gt;<i> is on because containsObsFold ought to be false in the vast majority of
</I>&gt;<i> cases. This code should be optimized for quality, not speed.
</I>
For regular traffic that is right.

But DoS attack conditions are also something we have to consider as a
high priority in these early parsing stages. So we need to consider
speed even if we technically call it a &quot;slow path&quot;.
My earlier option #2 loop was about 1% faster than the Tokenizer
do-while loop.

I was going to run your proposal through my ab tests before replying to
see what its speed was like. But bug #1 above means it short-circuits
the test cases.

Amos

</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005652.html">[squid-dev] [PATCH] mime unfolding
</A></li>
	<LI>Next message: <A HREF="005656.html">[squid-dev] [PATCH] mime unfolding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5653">[ date ]</a>
              <a href="thread.html#5653">[ thread ]</a>
              <a href="subject.html#5653">[ subject ]</a>
              <a href="author.html#5653">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
