<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] mime unfolding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3C57349E5E.6050804%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005653.html">
   <LINK REL="Next"  HREF="005661.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] mime unfolding</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3C57349E5E.6050804%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] mime unfolding">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu May 12 15:16:46 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005653.html">[squid-dev] [PATCH] mime unfolding
</A></li>
        <LI>Next message: <A HREF="005661.html">[squid-dev] [PATCH] mime unfolding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5656">[ date ]</a>
              <a href="thread.html#5656">[ thread ]</a>
              <a href="subject.html#5656">[ subject ]</a>
              <a href="author.html#5656">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/12/2016 05:55 AM, Amos Jeffries wrote:
&gt;<i> On 12/05/2016 5:34 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 05/11/2016 05:32 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> +    do {
</I>&gt;&gt;&gt;<i> +        SBuf line;
</I>&gt;&gt;&gt;<i> +        if (tok.prefix(line, nonCRLF))
</I>&gt;&gt;&gt;<i> +            mimeHeaderBlock_.append(line);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        // the skipAll() might erase bare-CR not part of a CR*LF
</I>&gt;&gt;&gt;<i> +        SBuf savePoint(tok.remaining());
</I>&gt;&gt;&gt;<i> +        auto crLen = tok.skipAll(CharacterSet::CR);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        if (tok.skipOne(CharacterSet::LF)) {
</I>&gt;&gt;&gt;<i> +            if (tok.skipAll(CharacterSet::WSP))
</I>&gt;&gt;&gt;<i> +                mimeHeaderBlock_.append(' ');
</I>&gt;&gt;&gt;<i> +            else
</I>&gt;&gt;&gt;<i> +                mimeHeaderBlock_.append(Http1::CrLf());
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        } else if (crLen) {
</I>&gt;&gt;&gt;<i> +            // TODO: it might be better to replace the CR with one SP, but for now preserve
</I>&gt;&gt;&gt;<i> +            // preserve the bare-CR
</I>&gt;&gt;&gt;<i> +            tok.reset(savePoint);
</I>&gt;&gt;&gt;<i> +            if (tok.prefix(line, CharacterSet::CR))
</I>&gt;&gt;&gt;<i> +                mimeHeaderBlock_.append(line);
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +    } while (!tok.atEnd());
</I>

&gt;&gt;<i> I certainly cannot
</I>&gt;&gt;<i> validate it. I think the whole method ought to be much simpler/clearer.
</I>&gt;&gt;<i> Something along these lines:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Tokenizer tok(mimeHeaderBlock_);
</I>&gt;&gt;<i>     mimeHeaderBlock_.clear();
</I>&gt;&gt;<i>     SBuf prefix;
</I>&gt;&gt;<i>     while (tokenBeforeObsfolds(tk, prefix)) {
</I>&gt;&gt;<i>         mimeHeaderBlock_.append(prefix);
</I>&gt;&gt;<i>         mimeHeaderBlock_.append(' ');
</I>&gt;&gt;<i>     }
</I>&gt;&gt;<i>     mimeHeaderBlock_.append(tk.remaining());
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We already have a Tokenizer::token(prefix, delimiters) method. The
</I>&gt;&gt;<i> tokenBeforeObsfolds() call above is exactly the same except the
</I>
&gt;<i> If you think their behaviour is exactly the same, 
</I>
I think the concept is exactly the same.


&gt;<i> then I think you are
</I>&gt;<i> misunderstanding the purposes of at least one. But I wont draw out this
</I>&gt;<i> thread with that.
</I>
Ditto.


&gt;<i> Besides the 8 compile errors
</I>
As I said, it is a sketch. I cannot sketch non-trivial code without
compile errors. I am surprised you are wasting your time trying to rub
this in.


&gt;<i> it has several behavioural bugs though I
</I>&gt;<i> see you did workaround one of them by adding an extra Tokenizer pass
</I>&gt;<i> across the data, which adds another bug.
</I>&gt;<i> 
</I>&gt;<i> 1) not unfolding.
</I>&gt;<i> 
</I>&gt;<i> Consider the trivial case of:
</I>&gt;<i> 
</I>&gt;<i>  Foo: bar\r\n
</I>&gt;<i>  Folded: hello \r\n
</I>&gt;<i>   world\r\n
</I>&gt;<i>  \r\n
</I>&gt;<i> 
</I>&gt;<i> tokenBeforeObsfolds() will detect a prefix of &quot;Foo: bar\r&quot; 
</I>
tokenBeforeObsfolds() should detect a prefix of &quot;Foo: bar\r\nFolded:
hello&quot;. The delimiter is obs-fold, not CRLF. That is the whole idea
behind this approach! If the sketched tokenBeforeObsfolds() does not do
it, then it needs to be adjusted so that it does. I am trying to steer
your towards a reasonable solution, not write the code for you.


&gt;<i> 2) erases characters not part of any folding.
</I>&gt;<i>  ... worse: it erases delimiters.
</I>&gt;<i> 
</I>&gt;<i> the use of nonLF has consumed into prefix some characters that might
</I>&gt;<i> have been part of the fold sequence.
</I>
The folding sequence essentially starts with LF. Thus, there cannot be
&quot;characters that might have been part of the fold sequence&quot; in nonLF.
The only exception is CR before LF, which the sketch takes care of.


&gt;<i>  skipAllTrailing() is used to workaround that bug.
</I>
It is not a workaround. skipAllTrailing() removes CR before LF (and any
other trailing whitespace after the prefix). Whether we should trim that
other trailing whitespace is debatable, I guess, but I think it makes
sense to do that (if not, RelaxedDelimiterCharacters should be replaced
with just CR).


&gt;<i>  which consumes again, more characters than the ones that might be part
</I>&gt;<i> of the fold.
</I>&gt;<i>  resulting in a header value of &quot;helloworld&quot; which should have been
</I>&gt;<i> &quot;hello world&quot;.
</I>
The space between &quot;hello&quot; and &quot;world&quot; is added in the unfoldMime() loop,
resulting in &quot;hello world&quot;. If we replace RelaxedDelimiterCharacters
with just CR, then the result will be
&quot;hello  world&quot; (two spaces), which, in the majority of folding cases is
probably not what the sender meant, but I am sure there are exceptions
either way. I do not object to limiting trimming to CRs or CR.


&gt;<i> The purpose of this unfolder is to unfold. End of task. Not to cleanup
</I>&gt;<i> the headers. Nor to impose any &quot;garbage&quot; meaning on the non-fold
</I>&gt;<i> characters. 
</I>
If you are writing a strict message validator, yes. If you are writing
an HTTP proxy that is supposed to handle real traffic, then the answer
is far less clear. At any rate, whether whitespace before obs-fold is
garbage is a separate and minor question. The sketched code accommodates
each answer trivially: all RelaxedDelimiterCharacters, all CRs, or just
one CR.


&gt;<i> That job belongs to the parser logic which does lexical
</I>&gt;<i> interpretation of the header field-value.
</I>
In general, the header field parser would not be able to do anything
about this garbage. The garbage spaces may be inside a quoted string
and/or extension header that we do not parse. We have to make a decision
here. The header field parser will make its own decisions.


&gt;<i> As a side note. I'm not sure we should treat a whole sequence of folds
</I>&gt;<i> as a single SP. We are allowed to replace 1 fold with 1+ SP characters.
</I>&gt;<i> But nothing was discussed in the WG about N folds being replaced with
</I>&gt;<i> just 1 SP character. So we can't really assume some other
</I>&gt;<i> implementations wont interpret each fold as a SP with meaning. It would
</I>&gt;<i> be odd, but then anything playing around with sequences of folds is
</I>&gt;<i> already odd.
</I>
Agreed. Another secondary decision: skipAllObsFolds() or just skipObsfold().


&gt;<i> Also note there are whitespace characters which are not part of the fold
</I>&gt;<i> sequence. So even though we can remove CR*LF 1*(SP/HTAB) - we cant
</I>&gt;<i> safely remove the other 'garbage' whitespace characters as part of the
</I>&gt;<i> fold whitespace suffix
</I>
Whether we should remove that garbage or not is debatable. My sketch
removes it and makes it pretty clear what is being removed. Your email
questioning that removal is a good proof of that -- I have no idea what
your loop removes or does not remove, and would be unable to safely
adjust it to remove less (or more).


&gt;&gt;&gt;<i> +const SBuf &amp;CrLf();
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I suspect this should be defined inline for performance reasons.
</I>&gt;<i> 
</I>&gt;<i> If we do that we have again the issue you brought up earlier about
</I>&gt;<i> multiple globals init order
</I>
Defining this function as inline (i.e. in the header) does not create
any initialization issues.


&gt;<i> Then we can look at that later if/when the usage grows. Right now it
</I>&gt;<i> doesn't really have a proper need to be outside Parser.
</I>
Oh, it has plenty of &quot;need&quot;. We just have [correctly] chosen to ignore
that need during this project.

  $ bzr grep -F '&quot;\r\n&quot;'  | wc -l
  58


&gt;&gt;&gt;<i> But the savings is not enough to be bothered with AFAICS. 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are no performance savings or losses here to worry about. The code
</I>&gt;&gt;<i> in question is &quot;fast enough&quot; for the non-performance-sensitive path it
</I>&gt;&gt;<i> is on because containsObsFold ought to be false in the vast majority of
</I>&gt;&gt;<i> cases. This code should be optimized for quality, not speed.
</I>&gt;<i> 
</I>&gt;<i> For regular traffic that is right.
</I>&gt;<i> 
</I>&gt;<i> But DoS attack conditions are also something we have to consider as a
</I>&gt;<i> high priority in these early parsing stages. So we need to consider
</I>&gt;<i> speed even if we technically call it a &quot;slow path&quot;.
</I>
We do not need to optimize exceptional path speed as long as it is
reasonable. Parsing speed does _not_ protect from DoS attacks, and we
have far bigger problems to solve before optimizing obs-fold handling
may become important.


&gt;<i> My earlier option #2 loop was about 1% faster than the Tokenizer
</I>&gt;<i> do-while loop.
</I>
In other words, there was no meaningful performance difference that you
could measure. I do not know why you keep bringing this &quot;1%&quot; up.


Alex.

</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005653.html">[squid-dev] [PATCH] mime unfolding
</A></li>
	<LI>Next message: <A HREF="005661.html">[squid-dev] [PATCH] mime unfolding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5656">[ date ]</a>
              <a href="thread.html#5656">[ thread ]</a>
              <a href="subject.html#5656">[ subject ]</a>
              <a href="author.html#5656">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
