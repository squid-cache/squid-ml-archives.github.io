<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20maybeMakeSpaceAvailable%28%29%20logic&In-Reply-To=%3C6cea9315-2c8f-404c-e3fa-70d8a05652b0%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005660.html">
   <LINK REL="Next"  HREF="005666.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20maybeMakeSpaceAvailable%28%29%20logic&In-Reply-To=%3C6cea9315-2c8f-404c-e3fa-70d8a05652b0%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun May 15 08:50:17 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005660.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
        <LI>Next message: <A HREF="005666.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5662">[ date ]</a>
              <a href="thread.html#5662">[ thread ]</a>
              <a href="subject.html#5662">[ subject ]</a>
              <a href="author.html#5662">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 14/05/2016 9:00 a.m., Alex Rousskov wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i>     This change fixes logic bugs that mostly affect performance: In
</I>&gt;<i> micro-tests, this change gives 10% performance improvement for
</I>&gt;<i> intercepted &quot;fast peek at SNI and splice&quot; SslBump configurations.
</I>&gt;<i> Similar improvement is expected for future plain HTTP/2 parsers.
</I>&gt;<i> 
</I>&gt;<i>       trunk  fsni fsni+
</I>&gt;<i>   SS1  100%  100%  100%
</I>&gt;<i>   SS2   22%   69%   77%
</I>&gt;<i>   SS3   16%   26%   26%
</I>&gt;<i> 
</I>&gt;<i> The table format was described in my follow up to Christos' &quot;Fast SNI
</I>&gt;<i> peek&quot; email a few minutes ago. The testing methodology was the same so
</I>&gt;<i> the same caveats apply. The last column contains results from the Fast
</I>&gt;<i> SNI branch code patched with the attached patch.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Server::maybeMakeSpaceAvailable() is called with an essentially random
</I>&gt;<i> inBuf. The method must prepare inBuf for the next network read. The old
</I>&gt;<i> code was not doing that [well enough], leading to performance problems.
</I>&gt;<i> 
</I>&gt;<i> In some environments, inBuf often ends up having a tiny space exceeding
</I>&gt;<i> 2 bytes (e.g., 6 bytes). This happens, for example, when Squid creates
</I>&gt;<i> and parses a fake CONNECT request. The old code often left such tiny
</I>&gt;<i> inBufs &quot;as is&quot; because we tried to ensure that we have at least 2 bytes
</I>&gt;<i> to read instead of trying to provide a reasonable number of buffer space
</I>&gt;<i> for the next network read. Tiny buffers naturally result in tiny network
</I>&gt;<i> reads, which are very inefficient, especially for non-incremental parsers.
</I>&gt;<i> 
</I>&gt;<i> I have removed the explicit &quot;2 byte&quot; space checks: Both the new and the
</I>&gt;<i> old code do not _guarantee_ that at least 2 bytes of buffer space are
</I>&gt;<i> always available, and the caller does not check that condition either.
</I>&gt;<i> If some other code relies on it, more fixes will be needed (but this
</I>&gt;<i> change is not breaking that guarantee -- either it was broken earlier or
</I>&gt;<i> was never fully enforced). In practice, only buffers approaching
</I>&gt;<i> Config.maxRequestBufferSize limit may violate this guarantee AFAICT, and
</I>&gt;<i> those buffers ought to be rare, so the bug, if any, remains unnoticed.
</I>&gt;<i> 
</I>&gt;<i> Another subtle maybeMakeSpaceAvailable() problem was that the code
</I>&gt;<i> contained its own buffer capacity increase algorithm (n^2 growth).
</I>&gt;<i> However, increasing buffer capacity exponentially does not make much
</I>&gt;<i> sense because network read sizes are not going to increase
</I>&gt;<i> exponentially. Also, memAllocStringmemAllocate() overwrites n^2 growth
</I>&gt;<i> with its own logic. Besides, it is buffer _space_, not the total
</I>&gt;<i> capacity that should be increased.
</I>
This last sentence is not right. The point of having buffer limits is
that the buffer must not grow *capacity* past those limits. Capacity can
be partially used resulting in less space available.

I think you mean MemBlob capacity is not strictly aligned with buffer
size limits. Since the MemBlob may contain data from previous reads
which has been processed and no longer considered &quot;in the buffer&quot;.

What we need is that the SBuf used as a buffer should guarantee (space +
length) &lt;= limit, regardless of the underlying MemBlob capacity. Without
that guarantee we end up with each read cycle simply growing the
buffered data towards infinity as it consumes &quot;space&quot;.


&gt;<i> More work is needed to better match
</I>&gt;<i> Squid buffer size for from-user network reads with the TCP stack buffers
</I>&gt;<i> and traffic patterns.
</I>&gt;<i> 
</I>&gt;<i> Both the old and the new code reallocate inBuf MemBlobs. However, the
</I>&gt;<i> new code leaves &quot;reallocate or memmove&quot; decision to the new
</I>&gt;<i> SBuf::reserve(), opening the possibility for future memmove
</I>&gt;<i> optimizations that SBuf/MemBlob do not currently support.
</I>&gt;<i> 
</I>&gt;<i> It is probably wrong that inBuf points to an essentially random MemBlob
</I>&gt;<i> outside Server control but this change does not attempt to fix that.
</I>&gt;<i> 
</I>&gt;<i> The patch was written and tested ~2 weeks ago so it may need some
</I>&gt;<i> polishing to apply to the current trunk.
</I>&gt;<i> 
</I>
I dont think there has been any code drift in this area of trunk. The
following updates need to be made though:


in src/sbuf/SBuf.h:

* member initializers are one of the C++11 features GCC 4.8 has trouble
with.
 - if we still want to offer GCC 4.8 support then this will have to
become a default constructor.
 - I am okay with dropping that support if you want. The release-4.sgml
notes will need to update to remove the &quot;GCC-4.8 will also build for now
...&quot; statement.


in src/sbuf/SBuf.h:

* &quot;if (!mustRealloc &amp;&amp; len_ &gt;= req.maxCapacity)&quot; looks wrong.
 - thats igoring how much empty space it currently present
 - capacity overflow for the SBuf (not MemBlob) is:
    length() + spaceSize() &gt;= req.maxCapacity


* likewise the min() calculations are wrong.
 - It will increasingly over-allocate the bigger the buffer actually
gets. For non-limited SBuf that could be very dangerous in the
int-overflow kind of way.
 - Should be:
     wantedSpace = std::min(req.idealSpace, req.maxCapacity - length());
     reserveC..(std::min(length() +wantedSpace, maxSize - length()));

* might have to redo the performance metrics after these to have
accurate numbers. But I dont expect this will be worse than the current
trunk, so up to you.


in src/servers/Server.cc:

* comment reason for &quot;allowShared = true&quot; is wrong. It is allowed
because conceptually this SBuf is the base I/O buffer the caller 'owns'
and all others sharing are just referencing sub-sections of that.
 - you might be able to phrase that better though.


* now that reserve returns spaceSize() you can simplify the pattern:
    inBuf.reserve(requirements);
    if (!inBuf.spaceSize())
 to just:
    if (!inBuf.reserve(requirements))


in src/tests/stub_SBuf.cc:

 * s/reserveCapacity/reserve/  (only for the added line.)


Amos

</PRE>




























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005660.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
	<LI>Next message: <A HREF="005666.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5662">[ date ]</a>
              <a href="thread.html#5662">[ thread ]</a>
              <a href="subject.html#5662">[ subject ]</a>
              <a href="author.html#5662">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
