<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20maybeMakeSpaceAvailable%28%29%20logic&In-Reply-To=%3C573A062C.3060007%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005662.html">
   <LINK REL="Next"  HREF="005670.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fix%20maybeMakeSpaceAvailable%28%29%20logic&In-Reply-To=%3C573A062C.3060007%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon May 16 17:41:00 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005662.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
        <LI>Next message: <A HREF="005670.html">[squid-dev] [PATCH] External ACL %&gt;eui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5666">[ date ]</a>
              <a href="thread.html#5666">[ thread ]</a>
              <a href="subject.html#5666">[ subject ]</a>
              <a href="author.html#5666">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/15/2016 02:50 AM, Amos Jeffries wrote:
&gt;<i> On 14/05/2016 9:00 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> Another subtle maybeMakeSpaceAvailable() problem was that the code
</I>&gt;&gt;<i> contained its own buffer capacity increase algorithm (n^2 growth).
</I>&gt;&gt;<i> However, increasing buffer capacity exponentially does not make much
</I>&gt;&gt;<i> sense because network read sizes are not going to increase
</I>&gt;&gt;<i> exponentially. Also, memAllocStringmemAllocate() overwrites n^2 growth
</I>&gt;&gt;<i> with its own logic. Besides, it is buffer _space_, not the total
</I>&gt;&gt;<i> capacity that should be increased.
</I>

&gt;<i> This last sentence is not right. The point of having buffer limits is
</I>&gt;<i> that the buffer must not grow *capacity* past those limits. Capacity can
</I>&gt;<i> be partially used resulting in less space available.
</I>
I do not see anything wrong with the last sentence. The method needs to
grow space -- the callers do not care about capacity. Capacity growth is
a possible (but, depending on implementation, not _required_)
side-effect of growing space. Yes, buffer capacity limits must be
observed when growing space, of course, but that is completely unrelated
to what that sentence is talking about.


&gt;<i> I think you mean MemBlob capacity is not strictly aligned with buffer
</I>&gt;<i> size limits. Since the MemBlob may contain data from previous reads
</I>&gt;<i> which has been processed and no longer considered &quot;in the buffer&quot;.
</I>
I did not mean that. I meant that a method allocating space should
allocate space. Its algorithms should focus on how much space is
allocated. Yes, there are other limits/concerns, of course, and they
should be met/addressed, but the code should focus on providing space,
not capacity.

The old code lacked that focus. In the extreme hypothetical example, one
can double buffer capacity while not increasing buffer space at all. If
the code is written to grow capacity instead of space such mistakes are
not that unlikely.


&gt;<i> What we need is that the SBuf used as a buffer should guarantee (space +
</I>&gt;<i> length) &lt;= limit, regardless of the underlying MemBlob capacity. Without
</I>&gt;<i> that guarantee we end up with each read cycle simply growing the
</I>&gt;<i> buffered data towards infinity as it consumes &quot;space&quot;.
</I>
The sentence you did not like was not about obeying limits. Obeying
limits is a separate issue. I agree that they should be obeyed, and I
believe the proposed code obeys them.


&gt;<i> in src/sbuf/SBuf.h:
</I>&gt;<i> 
</I>&gt;<i> * member initializers are one of the C++11 features GCC 4.8 has trouble
</I>&gt;<i> with.
</I>
When I wrote and tested this code, I was using GCC 4.8. GCC
documentation matches my experience:
<A HREF="https://gcc.gnu.org/gcc-4.8/cxx0x_status.html">https://gcc.gnu.org/gcc-4.8/cxx0x_status.html</A>

Why do you think that GCC 4.8 has trouble with member initializers?


&gt;<i> +    if (!mustRealloc &amp;&amp; spaceSize() &gt;= req.minSpace)
</I>&gt;<i> +        return spaceSize(); // the caller is content with what we have
</I>&gt;<i> +
</I>&gt;<i> +    /* only reallocation can make the caller happy */
</I>&gt;<i> +
</I>&gt;<i> +    if (!mustRealloc &amp;&amp; len_ &gt;= req.maxCapacity)
</I>&gt;<i> +        return spaceSize(); // but we cannot reallocate
</I>&gt;<i> +
</I>

&gt;<i> * &quot;if (!mustRealloc &amp;&amp; len_ &gt;= req.maxCapacity)&quot; looks wrong.
</I>&gt;<i>  - thats igoring how much empty space it currently present
</I>
You may have missed the if-statement above it. Here they are together:


&gt;<i> +    if (!mustRealloc &amp;&amp; spaceSize() &gt;= req.minSpace)
</I>&gt;<i> +        return spaceSize(); // the caller is content with what we have
</I>
&gt;<i> +    if (!mustRealloc &amp;&amp; len_ &gt;= req.maxCapacity)
</I>&gt;<i> +        return spaceSize();
</I>

The first if-statement checks whether the current amount of empty space
is sufficient. When the second if-statement is evaluated, we already
know that the [!mustRealloc] caller wants more space than is currently
present.

And if buffered content size is already bigger than req.maxCapacity, the
amount of empty space becomes irrelevant. We cannot satisfy caller's
requirements and must return.


&gt;<i>  - capacity overflow [...] is:
</I>&gt;<i>     length() + spaceSize() &gt;= req.maxCapacity
</I>
True but irrelevant here. [ I deleted your &quot;SBuf (not MemBlob)&quot;
qualification to avoid discussing that controversy. ]

The if-statement you dislike does not check whether we exceed
maxCapacity _now_. It checks whether we can satisfy the caller
requirements at all. If &quot;length() + spaceSize()&quot; exceeds maxCapacity, we
may still be able to satisfy caller's requirements. Note that this
if-statement is located in the area of the code marked with

  /* only reallocation can make the caller happy */

and reallocation may _decrease_ space.


&gt;<i> * likewise the min() calculations are wrong.
</I>&gt;<i>  - It will increasingly over-allocate the bigger the buffer actually
</I>&gt;<i> gets.
</I>
What makes you think that? AFAICT, my code will provide idealSpace until
it hits various limits. Where do you see over-allocation?


&gt;<i> For non-limited SBuf that could be very dangerous in the
</I>&gt;<i> int-overflow kind of way.
</I>
I do not know what you mean by &quot;non-limited SBuf&quot;, but the allocations
are limited by the minimum of req.maxCapacity and maxSize, among other
things.


&gt;<i>  - Should be:
</I>&gt;<i>      wantedSpace = std::min(req.idealSpace, req.maxCapacity - length());
</I>&gt;<i>      reserveC..(std::min(length() +wantedSpace, maxSize - length()));
</I>
If you expand everything, my code calls reserveCapacity() with a minimum of:

* len_ + req.idealSpace
* maxSize
* req.maxCapacity

Your code calls reserveCapacity() with a minimum of:

* len_ + req.idealSpace
* req.maxCapacity
* maxSize - len_

Thus, the difference is &quot;maxSize&quot; vs &quot;maxSize - len_&quot;. Your variant does
not work well. Here is one hypothetical example to illustrate the
problem with your code: If SBuf already has maxSize bytes worth of
content and mustRealloc, your code will try to reserve a zero-byte
MemBlob to hold maxSize bytes, which makes no sense. My code will
correctly ask for a maxSize buffer. SBuf::cow() will fix your mistake,
but why make ii in the first place?

Also, my bullets are very natural: What we want ideally and two limits
on our desires. Your last bullet has no meaning that I can guess.



&gt;<i> in src/servers/Server.cc:
</I>
&gt;<i> + requirements.allowShared = true; // allow because inBuf is used immediately
</I>
&gt;<i> * comment reason for &quot;allowShared = true&quot; is wrong. 
</I>
I disagree. It is actually the _only_ correct reason if there is any.


&gt;<i> It is allowed
</I>&gt;<i> because conceptually this SBuf is the base I/O buffer the caller 'owns'
</I>&gt;<i> and all others sharing are just referencing sub-sections of that.
</I>
That theoretical concept is currently _not_ supported in the code! As I
explained, inBuf is currently a random SBuf, not owned by any single
object. It may change in &quot;unpredictable&quot; ways at &quot;any&quot; time. This is
bad, but not something I am trying to change/fix with this patch.
Writing a &quot;we own inBuf so it is OK to share it&quot; would be dangerously
misleading today.


&gt;<i> * now that reserve returns spaceSize() you can simplify the pattern:
</I>&gt;<i>     inBuf.reserve(requirements);
</I>&gt;<i>     if (!inBuf.spaceSize())
</I>&gt;<i>  to just:
</I>&gt;<i>     if (!inBuf.reserve(requirements))
</I>
I know, but, IMO, the current pattern is better because it emphasizes
that we are ignoring the reserve() result [except for debugging].

Also, I am not 100% happy with the reserve() result API -- it does not
tell the caller whether the reservation criteria were satisfied. I would
prefer not to use that result for now (unless necessary) in case we
decide to change that API later as we get more use cases.


&gt;<i> in src/tests/stub_SBuf.cc:
</I>&gt;<i> 
</I>&gt;<i>  * s/reserveCapacity/reserve/  (only for the added line.)
</I>
Will fix during commit if you withdraw your other objections.


Thank you,

Alex.

</PRE>

























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005662.html">[squid-dev] [PATCH] Fix maybeMakeSpaceAvailable() logic
</A></li>
	<LI>Next message: <A HREF="005670.html">[squid-dev] [PATCH] External ACL %&gt;eui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5666">[ date ]</a>
              <a href="thread.html#5666">[ thread ]</a>
              <a href="subject.html#5666">[ subject ]</a>
              <a href="author.html#5666">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
