<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fast SNI peek
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fast%20SNI%20peek&In-Reply-To=%3C573A16EB.5010506%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005665.html">
   <LINK REL="Next"  HREF="005675.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fast SNI peek</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fast%20SNI%20peek&In-Reply-To=%3C573A16EB.5010506%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Fast SNI peek">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon May 16 18:52:27 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005665.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
        <LI>Next message: <A HREF="005675.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5667">[ date ]</a>
              <a href="thread.html#5667">[ thread ]</a>
              <a href="subject.html#5667">[ subject ]</a>
              <a href="author.html#5667">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/15/2016 07:49 AM, Amos Jeffries wrote:

&gt;<i> in src/parser/BinaryTokenizer.cc:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> * delegating constructors is a C++11 feature that will definitely fail
</I>&gt;<i> on GCC 4.8.
</I>

When I wrote and tested this part of the code, I was using GCC 4.8. GCC
documentation matches my experience:
<A HREF="https://gcc.gnu.org/gcc-4.8/cxx0x_status.html">https://gcc.gnu.org/gcc-4.8/cxx0x_status.html</A>

Why do you think that GCC 4.8 has trouble with delegating constructors?


&gt;<i> * please make BinaryTokenizer_tail a function not a macro.
</I>
It cannot be a function (with reasonable performance/style) because it
does not have access to the debugging stream and would have to
accumulate output in a temporary SBuf.

To avoid this macro, we would have add a new class with a 4-argument
constructor (or a _friend_ class with a 3-argument constructor). I
really doubt the increased complexity would be worth avoiding macro in
this particular case, but please let me know if you insist on this
change, and we will make it.


&gt;<i>  - doing that will also fix the missing (void*) before use of 'this'
</I>
I agree that we should cast, but that improvement is not related to
BinaryTokenizer_tail() being a macro.


&gt;<i> * please add to the BinaryTokenizer intN() methods that they assume
</I>&gt;<i> network-endian input.
</I>
I recommend documenting that in the BinaryTokenizer class description
instead of every intN() method because there are other existing methods
that assume big-endian/network byte order and no existing method assumes
another byte order. When/if we add methods that support alternative byte
ordering, we will decide whether to specify the byte order via the
method name, method parameter, or tokenizer object configuration.


&gt;<i> in src/parser/BinaryTokenizer.h:
</I>&gt;<i> 
</I>&gt;<i> * please move the BinaryTokenizerContext inline method definitions
</I>&gt;<i> inside the class {} block.
</I>&gt;<i>  - then you wont need to even use &quot;inline&quot;.
</I>
Besides being impossible in this case, as explained by Christos, I do
not think moving multiline methods into the class declaration is better
in general. IMHO, the class API is easier to read when multiline methods
are kept away from the class declaration.


&gt;<i> in src/security/Handshake.cc:
</I>&gt;<i> 
</I>&gt;<i> * Security::HandshakeParser::skipMessage
</I>&gt;<i>  - the comment seems to be mentioning some serious breakage of the
</I>&gt;<i> debugging output. That should probably get an XXX marker.
</I>
Or we can resolve that problem by appending &quot; [fragment]&quot; to
skipMessage() calls:

  skipMessage(&quot;unknown ContentType msg [fragment]&quot;);
  skipMessage(&quot;ChangeCipherCpec msg [fragment]&quot;);
  skipMessage(&quot;app data [fragment]&quot;);


&gt;<i>  NP: just a note on class method definitions. Try to avoid naming the
</I>&gt;<i> parameters if you can.
</I>
... but only when you are absolutely sure that the parameter type
clearly describes the parameter, which is not the case in many (most?)
cases. If we have to pick between Doxygen and STUBS convenience and code
clarity, we should pick code clarity.

Given the uncertainty regarding what is &quot;clear&quot; to whom, avoiding
parameter names would be a bad default approach/recommendation IMHO.


&gt;<i> in src/ssl/PeekingPeerConnector.cc:
</I>&gt;<i> 
</I>&gt;<i> * the debugs dropped from Ssl::PeekingPeerConnector::noteWantWrite() was
</I>&gt;<i> about the srvBio-&gt;holdWrite() in the line above which still remains
</I>&gt;<i> wasn't it?
</I>

IIRC, that debug produced one debugging line for each SSL transaction in
some tests. @Christos, if you restore this debugging, please change the
debugging level to at least 2.


&gt;<i> in src/ssl/PeerConnector.cc:
</I>&gt;<i> 
</I>&gt;<i> * &quot;Log connection details, if any&quot;
</I>&gt;<i>  - in the function above Ssl::PeerConnector::noteWantRead()
</I>&gt;<i> 
</I>&gt;<i> * change in Ssl::PeerConnector::noteWantRead() is not necessary.
</I>&gt;<i>  - we leave local variable definitions until the point they are needed.
</I>&gt;<i>  - which for that 'fd' is still where it was before.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> in src/ssl/bio.cc:
</I>&gt;<i> 
</I>&gt;<i> * you dont need to put /* Ssl:Bio */ or /* ServerBio */ markers between
</I>&gt;<i> definitions at the file global level.
</I>
Somebody added draconian &quot;no double empty lines&quot; rules to source
formatting scripts and those markers are the only thing that clearly
separates different class methods in .cc file now. FWIW, they _are_
useful to some of us browsing the code.


Thank you,

Alex.

</PRE>





















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005665.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
	<LI>Next message: <A HREF="005675.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5667">[ date ]</a>
              <a href="thread.html#5667">[ thread ]</a>
              <a href="subject.html#5667">[ subject ]</a>
              <a href="author.html#5667">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
