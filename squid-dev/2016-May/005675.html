<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Fast SNI peek
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fast%20SNI%20peek&In-Reply-To=%3C4a633d36-6f70-df03-7bda-060151cc8ab1%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005667.html">
   <LINK REL="Next"  HREF="005680.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Fast SNI peek</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Fast%20SNI%20peek&In-Reply-To=%3C4a633d36-6f70-df03-7bda-060151cc8ab1%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Fast SNI peek">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue May 17 14:39:07 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005667.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
        <LI>Next message: <A HREF="005680.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5675">[ date ]</a>
              <a href="thread.html#5675">[ thread ]</a>
              <a href="subject.html#5675">[ subject ]</a>
              <a href="author.html#5675">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 17/05/2016 6:52 a.m., Alex Rousskov wrote:
&gt;<i> On 05/15/2016 07:49 AM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> in src/parser/BinaryTokenizer.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * delegating constructors is a C++11 feature that will definitely fail
</I>&gt;&gt;<i> on GCC 4.8.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> When I wrote and tested this part of the code, I was using GCC 4.8. GCC
</I>&gt;<i> documentation matches my experience:
</I>&gt;<i> <A HREF="https://gcc.gnu.org/gcc-4.8/cxx0x_status.html">https://gcc.gnu.org/gcc-4.8/cxx0x_status.html</A>
</I>&gt;<i> 
</I>&gt;<i> Why do you think that GCC 4.8 has trouble with delegating constructors?
</I>&gt;<i> 
</I>
I had build errors when I tried to use it ~6-12 months ago. IIRC that
was GCC 4.8.2.
If its working now thats great news. Maybe we should just let this one
in and see what happens.

&gt;<i> 
</I>&gt;&gt;<i> * please make BinaryTokenizer_tail a function not a macro.
</I>&gt;<i> 
</I>&gt;<i> It cannot be a function (with reasonable performance/style) because it
</I>&gt;<i> does not have access to the debugging stream and would have to
</I>&gt;<i> accumulate output in a temporary SBuf.
</I>&gt;<i> 
</I>&gt;<i> To avoid this macro, we would have add a new class with a 4-argument
</I>&gt;<i> constructor (or a _friend_ class with a 3-argument constructor). I
</I>&gt;<i> really doubt the increased complexity would be worth avoiding macro in
</I>&gt;<i> this particular case, but please let me know if you insist on this
</I>&gt;<i> change, and we will make it.
</I>&gt;<i> 
</I>
Okay. It was just a polish request and sounds like not worth it.

&gt;<i> 
</I>&gt;&gt;<i>  - doing that will also fix the missing (void*) before use of 'this'
</I>&gt;<i> 
</I>&gt;<i> I agree that we should cast, but that improvement is not related to
</I>&gt;<i> BinaryTokenizer_tail() being a macro.
</I>&gt;<i> 
</I>
To answer Christos' question;
 For iostreams to print the pointer value in hex like seems to be wanted
here one has to make sure the pointer is a void* and not a type that can
be dereferenced. Otherwise the streams will try to display its contents
which would either break, or &quot;work&quot; with unexpected values output.
 NP: 'this' pointer always has a known type, not void*.


&gt;<i> 
</I>&gt;&gt;<i> * please add to the BinaryTokenizer intN() methods that they assume
</I>&gt;&gt;<i> network-endian input.
</I>&gt;<i> 
</I>&gt;<i> I recommend documenting that in the BinaryTokenizer class description
</I>&gt;<i> instead of every intN() method because there are other existing methods
</I>&gt;<i> that assume big-endian/network byte order and no existing method assumes
</I>&gt;<i> another byte order. When/if we add methods that support alternative byte
</I>&gt;<i> ordering, we will decide whether to specify the byte order via the
</I>&gt;<i> method name, method parameter, or tokenizer object configuration.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> in src/parser/BinaryTokenizer.h:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * please move the BinaryTokenizerContext inline method definitions
</I>&gt;&gt;<i> inside the class {} block.
</I>&gt;&gt;<i>  - then you wont need to even use &quot;inline&quot;.
</I>&gt;<i> 
</I>&gt;<i> Besides being impossible in this case, as explained by Christos, I do
</I>&gt;<i> not think moving multiline methods into the class declaration is better
</I>&gt;<i> in general. IMHO, the class API is easier to read when multiline methods
</I>&gt;<i> are kept away from the class declaration.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> in src/security/Handshake.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Security::HandshakeParser::skipMessage
</I>&gt;&gt;<i>  - the comment seems to be mentioning some serious breakage of the
</I>&gt;&gt;<i> debugging output. That should probably get an XXX marker.
</I>&gt;<i> 
</I>&gt;<i> Or we can resolve that problem by appending &quot; [fragment]&quot; to
</I>&gt;<i> skipMessage() calls:
</I>&gt;<i> 
</I>&gt;<i>   skipMessage(&quot;unknown ContentType msg [fragment]&quot;);
</I>&gt;<i>   skipMessage(&quot;ChangeCipherCpec msg [fragment]&quot;);
</I>&gt;<i>   skipMessage(&quot;app data [fragment]&quot;);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>  NP: just a note on class method definitions. Try to avoid naming the
</I>&gt;&gt;<i> parameters if you can.
</I>&gt;<i> 
</I>&gt;<i> ... but only when you are absolutely sure that the parameter type
</I>&gt;<i> clearly describes the parameter, which is not the case in many (most?)
</I>&gt;<i> cases. If we have to pick between Doxygen and STUBS convenience and code
</I>&gt;<i> clarity, we should pick code clarity.
</I>&gt;<i> 
</I>&gt;<i> Given the uncertainty regarding what is &quot;clear&quot; to whom, avoiding
</I>&gt;<i> parameter names would be a bad default approach/recommendation IMHO.
</I>&gt;<i> 
</I>
What sparked me to mention it was a ProtocolVersion called 'v' and
TlsDetails called 'details'.
Both prime examples of not being needed since the parameter name added
nothing to the understandig of what they are.

&gt;<i> 
</I>&gt;&gt;<i> in src/ssl/PeekingPeerConnector.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * the debugs dropped from Ssl::PeekingPeerConnector::noteWantWrite() was
</I>&gt;&gt;<i> about the srvBio-&gt;holdWrite() in the line above which still remains
</I>&gt;&gt;<i> wasn't it?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> IIRC, that debug produced one debugging line for each SSL transaction in
</I>&gt;<i> some tests. @Christos, if you restore this debugging, please change the
</I>&gt;<i> debugging level to at least 2.
</I>&gt;<i> 
</I>
Nod. Fine with me.

&gt;<i> 
</I>&gt;&gt;<i> in src/ssl/PeerConnector.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * &quot;Log connection details, if any&quot;
</I>&gt;&gt;<i>  - in the function above Ssl::PeerConnector::noteWantRead()
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * change in Ssl::PeerConnector::noteWantRead() is not necessary.
</I>&gt;&gt;<i>  - we leave local variable definitions until the point they are needed.
</I>&gt;&gt;<i>  - which for that 'fd' is still where it was before.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in src/ssl/bio.cc:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * you dont need to put /* Ssl:Bio */ or /* ServerBio */ markers between
</I>&gt;&gt;<i> definitions at the file global level.
</I>&gt;<i> 
</I>&gt;<i> Somebody added draconian &quot;no double empty lines&quot; rules to source
</I>&gt;<i> formatting scripts and those markers are the only thing that clearly
</I>&gt;<i> separates different class methods in .cc file now. FWIW, they _are_
</I>&gt;<i> useful to some of us browsing the code.
</I>
So one browsing the file does not pay attention to the &quot;ServerBio::&quot; or
&quot;Ssl::Bio::&quot; scope paths in every single method name?
 Past experience shows that new code just gets added in where needed and
can make them become just another bogus comment. IIRC last time we
discussed this it was me trying to add this type of marker, and Alex
arguing me out of it.

NP: It also shows how that .cc is violating the coding guideline of one
class per file. If the classes are big enough to need some separation
between them it means they probably dont meet the spirit of the
exception on that guideline.

Anyhow, now the GCC 4.8 thing seems to be out of the way...

Christos:
 +1, please apply with whatever of the polishing suggestions you accept.

Amos

</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005667.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
	<LI>Next message: <A HREF="005680.html">[squid-dev] [PATCH] Fast SNI peek
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5675">[ date ]</a>
              <a href="thread.html#5675">[ thread ]</a>
              <a href="subject.html#5675">[ subject ]</a>
              <a href="author.html#5675">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
