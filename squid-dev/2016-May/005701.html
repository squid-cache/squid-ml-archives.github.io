<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] mime unfolding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3C573DF477.8080104%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005692.html">
   <LINK REL="Next"  HREF="005712.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] mime unfolding</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3C573DF477.8080104%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] mime unfolding">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu May 19 17:14:31 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005692.html">[squid-dev] [PATCH] mime unfolding
</A></li>
        <LI>Next message: <A HREF="005712.html">[squid-dev] [PATCH] mime unfolding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5701">[ date ]</a>
              <a href="thread.html#5701">[ thread ]</a>
              <a href="subject.html#5701">[ subject ]</a>
              <a href="author.html#5701">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/19/2016 07:29 AM, Amos Jeffries wrote:
&gt;<i> On 19/05/2016 1:59 p.m., Alex Rousskov wrote:
</I>
(A)

&gt;&gt;<i>     while (!tk.atEnd()) {
</I>&gt;&gt;<i>         const SBuf all = tk.remaining();
</I>&gt;&gt;<i>         const auto crLen = tk.skipOne(CR); // may not be there
</I>&gt;&gt;<i>         const auto lfLen = tk.skipOne(LF); // may not be there
</I>&gt;&gt;<i>         if (lfLen &amp;&amp; tk.skipAll(WSP)) // obs-fold!
</I>&gt;&gt;<i>             result += ' '; // replace one obs-fold with one SP
</I>&gt;&gt;<i>         else
</I>&gt;&gt;<i>             result += all.substr(0, crLen+lfLen + tk.skipAll(notCRLF));
</I>&gt;&gt;<i>     }
</I>
- a little too complex
+ only one expensive operation (+=) per iteration
+ elegant / symmetric / succinct


(B)

&gt;<i>  while (!tk.atEnd()) {
</I>&gt;<i>    SBuf line;
</I>&gt;<i>    if (tk.prefix(line, nonCRLF))
</I>&gt;<i>         result += line;
</I>&gt;<i> 
</I>&gt;<i>    const SBuf all = tk.remaining();
</I>&gt;<i> 
</I>&gt;<i>    const auto crLen = tk.skipOne(CR); // may not be there
</I>&gt;<i>    const auto lfLen = tk.skipOne(LF); // may not be there
</I>&gt;<i>    if (lfLen &amp;&amp; tk.skipAll(WSP)) // obs-fold!
</I>&gt;<i>      result += ' '; // replace one obs-fold with one SP
</I>&gt;<i>    else // bare-CR or CRLF
</I>&gt;<i>      result += all.substr(0, crLen+lfLen);
</I>&gt;<i>  }
</I>
- a little too complex
- two expensive operations (+=) per iteration
* considered clearer by some but not others

On a performance-sensitive path, (A) would have been a clear winner.
Since we are not dealing with that path, please pick (A) or (B) given
the factors above.


FYI: The &quot;may not be there&quot; comments became a little misleading in (B)
because either CR or LF has to be there now (in LF-terminated MIME), but
I cannot suggest a better way to phrase them without making them too
long/confusing. Not important.


&gt;<i> 6) 
</I>&gt;<i> 
</I>&gt;<i>  while (!tk.atEnd()) {
</I>&gt;<i>    if (tk.prefix(line, nonCRLF))
</I>&gt;<i>         result += line;
</I>&gt;<i> 
</I>&gt;<i>    const SBuf all = tk.remaining();
</I>&gt;<i> 
</I>&gt;<i>    const auto crLen = tk.skipOne(CR); // may not be there
</I>&gt;<i>    if (tk.skipOne(LF)) {
</I>&gt;<i>      if (tk.skipAll(WSP)) // obs-fold!
</I>&gt;<i>        result += ' '; // replace one obs-fold with one SP
</I>&gt;<i>      else // CRLF
</I>&gt;<i>        result += Http1::CrLF();
</I>&gt;<i> 
</I>&gt;<i>    } else if (crLen) {
</I>&gt;<i>        result += all.substr(0, crLen);
</I>&gt;<i>    }
</I>&gt;<i>  }
</I>&gt;<i> 
</I>
- too complex
- two expensive operations (+=) per iteration
- replaces bare LF with CRLF [while lying that it does not].
* still looks very different from the initial proposal IMO.


&gt;<i> + * \param containsObsFold will be set to true if obs-fold pattern is found. Otherwise not changed.
</I>
Please fix the &quot;otherwise&quot; part: A reasonable API must always set
containsObsFold. It is trivial (and not expensive) to clear it at the
beginning of the function, of course.

Please feel free to commit when you are comfortable with the results.

Alex.

</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005692.html">[squid-dev] [PATCH] mime unfolding
</A></li>
	<LI>Next message: <A HREF="005712.html">[squid-dev] [PATCH] mime unfolding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5701">[ date ]</a>
              <a href="thread.html#5701">[ thread ]</a>
              <a href="subject.html#5701">[ subject ]</a>
              <a href="author.html#5701">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
