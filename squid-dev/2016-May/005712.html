<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] mime unfolding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3C0551e0f6-9415-557d-45c9-27eaf6a0dd81%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="005701.html">
   <LINK REL="Next"  HREF="005654.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] mime unfolding</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20mime%20unfolding&In-Reply-To=%3C0551e0f6-9415-557d-45c9-27eaf6a0dd81%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] mime unfolding">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri May 20 08:29:24 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="005701.html">[squid-dev] [PATCH] mime unfolding
</A></li>
        <LI>Next message: <A HREF="005654.html">[squid-dev] Build failed in Jenkins: trunk-matrix » gcc,d-ubuntu-trusty #642
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5712">[ date ]</a>
              <a href="thread.html#5712">[ thread ]</a>
              <a href="subject.html#5712">[ subject ]</a>
              <a href="author.html#5712">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 20/05/2016 5:14 a.m., Alex Rousskov wrote:
&gt;<i> On 05/19/2016 07:29 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 19/05/2016 1:59 p.m., Alex Rousskov wrote:
</I>&gt;<i> 
</I>&gt;<i> (A)
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i>     while (!tk.atEnd()) {
</I>&gt;&gt;&gt;<i>         const SBuf all = tk.remaining();
</I>&gt;&gt;&gt;<i>         const auto crLen = tk.skipOne(CR); // may not be there
</I>&gt;&gt;&gt;<i>         const auto lfLen = tk.skipOne(LF); // may not be there
</I>&gt;&gt;&gt;<i>         if (lfLen &amp;&amp; tk.skipAll(WSP)) // obs-fold!
</I>&gt;&gt;&gt;<i>             result += ' '; // replace one obs-fold with one SP
</I>&gt;&gt;&gt;<i>         else
</I>&gt;&gt;&gt;<i>             result += all.substr(0, crLen+lfLen + tk.skipAll(notCRLF));
</I>&gt;&gt;&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> - a little too complex
</I>&gt;<i> + only one expensive operation (+=) per iteration
</I>&gt;<i> + elegant / symmetric / succinct
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> (B)
</I>&gt;<i> 
</I>&gt;&gt;<i>  while (!tk.atEnd()) {
</I>&gt;&gt;<i>    SBuf line;
</I>&gt;&gt;<i>    if (tk.prefix(line, nonCRLF))
</I>&gt;&gt;<i>         result += line;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    const SBuf all = tk.remaining();
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    const auto crLen = tk.skipOne(CR); // may not be there
</I>&gt;&gt;<i>    const auto lfLen = tk.skipOne(LF); // may not be there
</I>&gt;&gt;<i>    if (lfLen &amp;&amp; tk.skipAll(WSP)) // obs-fold!
</I>&gt;&gt;<i>      result += ' '; // replace one obs-fold with one SP
</I>&gt;&gt;<i>    else // bare-CR or CRLF
</I>&gt;&gt;<i>      result += all.substr(0, crLen+lfLen);
</I>&gt;&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> - a little too complex
</I>&gt;<i> - two expensive operations (+=) per iteration
</I>&gt;<i> * considered clearer by some but not others
</I>&gt;<i> 
</I>&gt;<i> On a performance-sensitive path, (A) would have been a clear winner.
</I>&gt;<i> Since we are not dealing with that path, please pick (A) or (B) given
</I>&gt;<i> the factors above.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> FYI: The &quot;may not be there&quot; comments became a little misleading in (B)
</I>&gt;<i> because either CR or LF has to be there now (in LF-terminated MIME), but
</I>&gt;<i> I cannot suggest a better way to phrase them without making them too
</I>&gt;<i> long/confusing. Not important.
</I>&gt;<i> 
</I>
Perhapse, I was going to remove it on the LF. But the case you mentioned
earlier where the mime block does not end with CRLF will not have a LF
on the last cycle. It makes sense to have them all if we assume the
block being dealt with is potentially not terminated.


Just to be sure, and since I've been measuring everything about this
change I counted the loops and append()/copy too.

For my test which has 6 regular headers, one bare-CR header and one
folded 7 different ways.
* (A) cycles 24 times for its 1x copy per cycle. -&gt; 24 copies
* (B) cycles 16 times for its 2x copy per cycle. -&gt; 32 copies

So I tried handling the blob characters the same as crLen. That does
require an extra append() in the obs-fold path. So that the non-fold
cycles can be single-copy and the fold cycles can be double-copy.

That results in 16 cycles doing 20 copies. Better than both, at least in
terms of discreet copy/append operations.


I suspect it could be made to do even less by continuing to accumulate
across cycles. That would make it actually be doing your 1*(blob
obs-fold) syntax. But that is more complexity again and may not be
faster latency wise anyway, so so leaving it for a later commit if needed.
 e.g.:

  SBuf::size_type blobLen = 0;
  while (!tk.atEnd()) {
    const SBuf all = tk.remaining();
    blobLen += tk.skipAll(notCRLF);
    const auto crLen = tk.skipOne(CR); // may not be there
    const auto lfLen = tk.skipOne(LF); // may not be there
    if (lfLen &amp;&amp; tk.skipAll(WSP)) { // obs-fold!
        result += all.substr(0, blobLen);
        result += ' '; // replace one obs-fold with one SP
        blobLen = 0;
    } else
        blobLen += crLen + lfLen;
  }

It is worth keeping in mind that the amount of data copied is fixed in
all these cases anyway. All that is changing is the size of the discreet
blocks moved each iteration. So the savings is by removing each cycles
stack setup/teardown overheads.


There was still danger here that a remote endpoint can craft mime blocks
to cause a series of worst-case reallocations which slow the proxy and
lower the DoS threshold. Difficulty on that is quite low.

I've put a reserveSpace() call after the clear() to prevent that
happening. Realloc should happen exactly once now no matter what the
remote end sends.


&gt;<i> 
</I>&gt;&gt;<i> + * \param containsObsFold will be set to true if obs-fold pattern is found. Otherwise not changed.
</I>&gt;<i> 
</I>&gt;<i> Please fix the &quot;otherwise&quot; part: A reasonable API must always set
</I>&gt;<i> containsObsFold. It is trivial (and not expensive) to clear it at the
</I>&gt;<i> beginning of the function, of course.
</I>&gt;<i> 
</I>
Done.

&gt;<i> Please feel free to commit when you are comfortable with the results.
</I>&gt;<i> 
</I>&gt;<i> Alex.
</I>&gt;<i> 
</I>
Applied as trunk rev.14677.

Thank you for the time and effort put into reviewing this.

Amos

</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005701.html">[squid-dev] [PATCH] mime unfolding
</A></li>
	<LI>Next message: <A HREF="005654.html">[squid-dev] Build failed in Jenkins: trunk-matrix » gcc,d-ubuntu-trusty #642
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5712">[ date ]</a>
              <a href="thread.html#5712">[ thread ]</a>
              <a href="subject.html#5712">[ subject ]</a>
              <a href="author.html#5712">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
