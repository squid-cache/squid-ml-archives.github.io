<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3Ce0b94187-8a91-07d5-9294-cae6087212e4%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007269.html">
   <LINK REL="Next"  HREF="007272.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3Ce0b94187-8a91-07d5-9294-cae6087212e4%40treenet.co.nz%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Nov 20 02:06:13 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007269.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007272.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7270">[ date ]</a>
              <a href="thread.html#7270">[ thread ]</a>
              <a href="subject.html#7270">[ subject ]</a>
              <a href="author.html#7270">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 20/11/2016 12:08 p.m., Marcus Kool wrote:
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 11/19/2016 08:07 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> Since ssl_bump directive went in my original opinion of it as being too
</I>&gt;&gt;<i> complicated and confusing has pretty much been demonstrated as correct
</I>&gt;&gt;<i> by the vast amount of misconfigurations and failed attempts of people to
</I>&gt;&gt;<i> use it without direct assistance from those of us involved with its
</I>&gt;&gt;<i> design.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Since we are also transitioning to a world where 'SSL' does not exist
</I>&gt;&gt;<i> any longer I think v5 is a good time to rename and redesign the
</I>&gt;&gt;<i> directive a bit.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I propose going back to the older config style where each step has its
</I>&gt;&gt;<i> own directive name which self-documents what it does. That will reduce
</I>&gt;&gt;<i> the confusion about what is going on at each 'step', and allow us a
</I>&gt;&gt;<i> chance to have clearly documented default actions for each step.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For example:
</I>&gt;&gt;<i>  tls_new_connection
</I>&gt;&gt;<i>   - default: peek all
</I>&gt;&gt;<i>   - or run ssl_bump check if that directive exists
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  tls_client_hello
</I>&gt;&gt;<i>   - default: splice all
</I>&gt;&gt;<i>   - or run ssl_bump check if that directive exists
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  tls_server_hello
</I>&gt;&gt;<i>   - default: terminate all
</I>&gt;&gt;<i>   - or run ssl_bump check if that directive exists
</I>&gt;<i> 
</I>&gt;<i> I like the intent of the proposal and the new directives tls_*.
</I>&gt;<i> What currently makes configuration in Squid 3/4 difficult is
</I>&gt;<i> the logic of 'define in step x what to do in the next step' and
</I>&gt;<i> IMO this logic is the main cause of misunderstandings and
</I>&gt;<i> incorrect configurations.  Also the terms 'bump' and 'splice'
</I>&gt;<i> do not help ease of understanding.  Since Squid evolved and
</I>&gt;<i> bumping changed from 3.3 - 3.4 - 3.5 to 4.x, and likely will
</I>&gt;<i> change again in 5.x, there is an opportunity to improve
</I>&gt;<i> things more than is proposed.
</I>&gt;<i> There is also a difference in dealing with transparent intercepted
</I>&gt;<i> connections and direct connections (browsers doing a CONNECT)
</I>&gt;<i> which also causes some misunderstandings.
</I>&gt;<i> The current ssl bump steps allow problematic configs where Squid
</I>&gt;<i> bumps or stares in one step and to splice in an other step,
</I>&gt;<i> which can be resolved (made impossible) in a new configuration syntax.
</I>&gt;<i> 
</I>&gt;<i> I propose to use a new logic for the configuration directives
</I>&gt;<i> where 'define in step x what to do in the next step' is replaced
</I>&gt;<i> with a new logic 'define in step x what to do _now_'.
</I>
&gt;<i>From reading the below I think you are mistaking what &quot;now&quot; means to
</I>Squid. Input access control directives in squid.conf make a decision
about what action to do based on some state that just arrived.

For example:
 HTTP message just finished parsing -&gt; check http_access what to do with it.
 HTTP reply message just arrived -&gt; check http_reply_access what to do
with it.

Thus my proposal was along the lines of:
  client hello recieved -&gt; check tls_client_hello what to do with it.
  server hello recieved -&gt; check tls_server_hello what to do with it.


&gt;<i> 
</I>&gt;<i> Below is a new proposal to attempt to make the configuration
</I>&gt;<i> more intuitive and less prone for admin misunderstandings.
</I>&gt;<i> 
</I>&gt;<i> First the admin must define if there is any bumping at all.
</I>&gt;<i> This could be done with
</I>&gt;<i> https_decryption on|off
</I>&gt;<i> This is similar to tls_new_connection peek|splice but much
</I>&gt;<i> more intuitive.
</I>&gt;<i> 
</I>&gt;<i> Iff https_decryption is on:
</I>&gt;<i> 
</I>&gt;<i> 1) the &quot;connection&quot; step:
</I>&gt;<i> When a browser uses &quot;CONNECT &lt;FQDN&gt;&quot; Squid does not need to make
</I>&gt;<i> peek or splice decisions.
</I>&gt;<i> When Squid intercepts a connection to &quot;port 443 of &lt;IP&gt;&quot; no peek
</I>&gt;<i> or splice decision is made here any more.
</I>&gt;<i> This step becomes obsolete in the proposed configuration.
</I>
I am still hoping that will happen. But also still getting pushback that
people want to terminate or splice without even looking at the
clear-text hello details.

&gt;<i> 
</I>&gt;<i> 2) the &quot;TLS client hello&quot; step:
</I>&gt;<i> When a browser uses CONNECT, Squid has a FQDN and does not need
</I>&gt;<i> peeking a TLS client hello message. It can use the tls_client_hello
</I>&gt;<i> directives given below.
</I>
Sadly this is not correct. Squid still needs to get the client hello
details at this point. They are needed to perform bump before the server
hello is received, and to &quot;terminate with an error message&quot; without
contacting a server.


&gt;<i> When Squid intercepts a connection, Squid always peeks to retrieve
</I>&gt;<i> the SNI which is the equivalent of the FQDN used by a CONNECT.
</I>&gt;<i> In this step admins may want to define what Squid must do, e.g.
</I>&gt;<i> tls_client_hello passthrough aclfoo
</I>&gt;<i> Note that the acl 'aclfoo' can use tls::client_servername and
</I>&gt;<i> tls::client_servername should always have a FQDN if the connection
</I>&gt;<i> is https.  tls::client_servername expands to the IP address if
</I>&gt;<i> the SNI of an intercepted connection could not be retrieved.
</I>
What if the SNI contradicts the CONNECT message FQDN ?
What if a raw-IP in the CONNECT message (or TCP SYN) does not belong to
the server named in SNI ?

Squid would now be diverting the client transparently to a server other
than the one it expects and caching under that FQDN. But the server cert
would still authenticate as being the SNI host, so TLS cannot detect the
diversion.

The fake CONNECT's are a bit messy but IMHO we can only get rid of the
first one done for intercepted connections. Although that alone would
make both cases handle the same way.

&gt;<i> 
</I>&gt;<i> For https connections with a client hello without the SNI extension:
</I>&gt;<i> tls_client_hello passthrough|terminate aclbar
</I>&gt;<i> where aclbar can contain tls::client_hello_missing_sni
</I>&gt;<i> 
</I>&gt;<i> For connections that do not use TLS (i.e. not a valid
</I>&gt;<i> TLS client hello message was seen):
</I>&gt;<i> tls_client_hello passthrough|terminate aclbar2
</I>&gt;<i> where aclbar2 may contain tls::handshake_failure
</I>&gt;<i> 
</I>&gt;<i> To define that the TLS handshake continues, the config can contain
</I>&gt;<i> tls_client_hello continue
</I>&gt;<i> This is a basically a no-op and not required but enhances readability
</I>&gt;<i> of a configuration.
</I>
This is getting complicated again. Avoiding the first (TCP SYN) access
control cycles will make ssl::server_name ACL contain either FQDN/SNI or
the actual server cert name. A default &quot;none&quot; or &quot;-&quot; value when no
FQDN/SNI is available should be sufficient for matching these clients.
And we should have that already I think, if not its a missing feature bug.

Also even &quot;no-op&quot; ACLs still require CPU time to assemble data for ACL
checking. So avoiding that kind of thing in configs is good.

&gt;<i> 
</I>&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>&gt;<i> Usually no directives are needed since rarely actions are taken
</I>&gt;<i> based on the server hello message, so the default is
</I>&gt;<i> tls_server_hello continue
</I>
Once Squid gets to this stage of processing &quot;continue&quot; could mean either
splice or bump, but only one of the two is possible.

Bump is not legal in a lot of situations but splice may not be possible.
So terminate is the only realistic default we can set for general use.
As you say, its uncommon to need it, and people who do tend to know what
they want done. So will configure that.


The handshake containing error signals or other protocols are different
decisions points. Remember Squid is deciding what to do with some data
that just arrived. If its going to tunnel/splice the server hello, there
is no point even evaluating what the protocol inside is, and error
alerts get delivered to the client as-is.

So the existing on_unsupported_protocol and sslproxy_cert_error to make
those handling decisions with 'ssl_error' type ACL to match the specific
problem are fine IMO.


&gt;<i> The tls_server_hello can be used to terminate specific connections.
</I>&gt;<i> In this step many types of certificate errors can be detected
</I>&gt;<i> and in the Squid configuration there must be a way to define
</I>&gt;<i> what to do for specific errors and optionally for which FQDN.
</I>&gt;<i> E.g. allow to define that connections with self-signed certificates
</I>&gt;<i> are terminates but the self-signed cert for domain foo.example.com
</I>&gt;<i> is allowed.  See also the example config below and the use of
</I>&gt;<i> tls::server_servername.
</I>&gt;<i> 
</I>&gt;<i> What is left, is a configuration directive for connections
</I>&gt;<i> that use TLS as an encryption wrapper but do not use HTTP
</I>&gt;<i> inside the TLS wrapper:
</I>&gt;<i> tls_no_http passthrough|terminate   # similar to on_unsupported_protocol
</I>&gt;<i> 
</I>&gt;<i> An example configuration looks like this:
</I>&gt;<i> https_decryption on
</I>&gt;<i> acl banks tls::client_servername .bank1.example.org
</I>&gt;<i> acl no_sni tls::client_hello_missing_sni
</I>&gt;<i> acl no_handshake tls::handshake_failure
</I>&gt;<i> acl hacked_server tls::server_servername evil.example.com
</I>&gt;<i> tls_client_hello passthrough banks
</I>&gt;<i> tls_client_hello terminate no_sni
</I>&gt;<i> tls_client_hello passthrough no_handshake
</I>&gt;<i> tls_client_hello continue
</I>&gt;<i> tls_server_hello terminate hacked_server
</I>&gt;<i> tls_server_hello continue
</I>&gt;<i> tls_no_http passthrough
</I>&gt;<i> 
</I>&gt;<i> The configuration directives as I proposed are IMO intuitive and
</I>&gt;<i> leave very little room for misunderstandings.
</I>
Looks just like what I'm proposing except your config above lets clients
connect to servers with invalid TLS credentials (maybe not so intuitive?).

 acl banks ssl::server_name .bank1.example.org
 acl no_sni ssl::server_name &quot;-&quot;
 acl hacked_server ssl::server_name evil.example.com

 tls_client_hello splice banks
 tls_client_hello terminate no_sni
 tls_client_hello terminate hacked_server
 tls_client_hello peek all

 tls_server_hello terminate hacked_server
 tls_server_hello splice all

 # NP: &quot;sslproxy_cert_error deny all&quot; is default

 on_unsupported_protocol tunnel all


Amos

</PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007269.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007272.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7270">[ date ]</a>
              <a href="thread.html#7270">[ thread ]</a>
              <a href="subject.html#7270">[ subject ]</a>
              <a href="author.html#7270">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
