<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3Ce333c20d-986a-fe1e-7fd3-0acbebe71ba9%40urlfilterdb.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007270.html">
   <LINK REL="Next"  HREF="007279.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Marcus Kool</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3Ce333c20d-986a-fe1e-7fd3-0acbebe71ba9%40urlfilterdb.com%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">marcus.kool at urlfilterdb.com
       </A><BR>
    <I>Sun Nov 20 12:55:50 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007270.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007279.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7272">[ date ]</a>
              <a href="thread.html#7272">[ thread ]</a>
              <a href="subject.html#7272">[ subject ]</a>
              <a href="author.html#7272">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On 11/20/2016 12:06 AM, Amos Jeffries wrote:
&gt;<i> On 20/11/2016 12:08 p.m., Marcus Kool wrote:
</I>&gt;&gt;<i>
</I>[snip]

&gt;&gt;<i>
</I>&gt;&gt;<i> I like the intent of the proposal and the new directives tls_*.
</I>&gt;&gt;<i> What currently makes configuration in Squid 3/4 difficult is
</I>&gt;&gt;<i> the logic of 'define in step x what to do in the next step' and
</I>&gt;&gt;<i> IMO this logic is the main cause of misunderstandings and
</I>&gt;&gt;<i> incorrect configurations.  Also the terms 'bump' and 'splice'
</I>&gt;&gt;<i> do not help ease of understanding.  Since Squid evolved and
</I>&gt;&gt;<i> bumping changed from 3.3 - 3.4 - 3.5 to 4.x, and likely will
</I>&gt;&gt;<i> change again in 5.x, there is an opportunity to improve
</I>&gt;&gt;<i> things more than is proposed.
</I>&gt;&gt;<i> There is also a difference in dealing with transparent intercepted
</I>&gt;&gt;<i> connections and direct connections (browsers doing a CONNECT)
</I>&gt;&gt;<i> which also causes some misunderstandings.
</I>&gt;&gt;<i> The current ssl bump steps allow problematic configs where Squid
</I>&gt;&gt;<i> bumps or stares in one step and to splice in an other step,
</I>&gt;&gt;<i> which can be resolved (made impossible) in a new configuration syntax.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I propose to use a new logic for the configuration directives
</I>&gt;&gt;<i> where 'define in step x what to do in the next step' is replaced
</I>&gt;&gt;<i> with a new logic 'define in step x what to do _now_'.
</I>&gt;<i>
</I>&gt;<i> From reading the below I think you are mistaking what &quot;now&quot; means to
</I>&gt;<i> Squid. Input access control directives in squid.conf make a decision
</I>&gt;<i> about what action to do based on some state that just arrived.
</I>
Maybe it is necessary to redefine 'now' but my point remains that
'define in step x what to do in the next step' is the cause of
most misunderstandings.

&gt;<i> For example:
</I>&gt;<i>  HTTP message just finished parsing -&gt; check http_access what to do with it.
</I>&gt;<i>  HTTP reply message just arrived -&gt; check http_reply_access what to do
</I>&gt;<i> with it.
</I>&gt;<i>
</I>&gt;<i> Thus my proposal was along the lines of:
</I>&gt;<i>   client hello recieved -&gt; check tls_client_hello what to do with it.
</I>&gt;<i>   server hello recieved -&gt; check tls_server_hello what to do with it.
</I>
For both hello messages: is the decision moment the moment where it
has been peeked at?

&gt;&gt;<i>
</I>&gt;&gt;<i> Below is a new proposal to attempt to make the configuration
</I>&gt;&gt;<i> more intuitive and less prone for admin misunderstandings.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> First the admin must define if there is any bumping at all.
</I>&gt;&gt;<i> This could be done with
</I>&gt;&gt;<i> https_decryption on|off
</I>&gt;&gt;<i> This is similar to tls_new_connection peek|splice but much
</I>&gt;&gt;<i> more intuitive.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Iff https_decryption is on:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1) the &quot;connection&quot; step:
</I>&gt;&gt;<i> When a browser uses &quot;CONNECT &lt;FQDN&gt;&quot; Squid does not need to make
</I>&gt;&gt;<i> peek or splice decisions.
</I>&gt;&gt;<i> When Squid intercepts a connection to &quot;port 443 of &lt;IP&gt;&quot; no peek
</I>&gt;&gt;<i> or splice decision is made here any more.
</I>&gt;&gt;<i> This step becomes obsolete in the proposed configuration.
</I>&gt;<i>
</I>&gt;<i> I am still hoping that will happen. But also still getting pushback that
</I>&gt;<i> people want to terminate or splice without even looking at the
</I>&gt;<i> clear-text hello details.
</I>
We must know the reasons behind this pushback.  Only then sane decisions
can be made.

&gt;&gt;<i>
</I>&gt;&gt;<i> 2) the &quot;TLS client hello&quot; step:
</I>&gt;&gt;<i> When a browser uses CONNECT, Squid has a FQDN and does not need
</I>&gt;&gt;<i> peeking a TLS client hello message. It can use the tls_client_hello
</I>&gt;&gt;<i> directives given below.
</I>&gt;<i>
</I>&gt;<i> Sadly this is not correct. Squid still needs to get the client hello
</I>&gt;<i> details at this point. They are needed to perform bump before the server
</I>&gt;<i> hello is received, and to &quot;terminate with an error message&quot; without
</I>&gt;<i> contacting a server.
</I>
yes, correct.  Squid must do this.  But does it have to be configured?

&gt;&gt;<i> When Squid intercepts a connection, Squid always peeks to retrieve
</I>&gt;&gt;<i> the SNI which is the equivalent of the FQDN used by a CONNECT.
</I>&gt;&gt;<i> In this step admins may want to define what Squid must do, e.g.
</I>&gt;&gt;<i> tls_client_hello passthrough aclfoo
</I>&gt;&gt;<i> Note that the acl 'aclfoo' can use tls::client_servername and
</I>&gt;&gt;<i> tls::client_servername should always have a FQDN if the connection
</I>&gt;&gt;<i> is https.  tls::client_servername expands to the IP address if
</I>&gt;&gt;<i> the SNI of an intercepted connection could not be retrieved.
</I>&gt;<i>
</I>&gt;<i> What if the SNI contradicts the CONNECT message FQDN ?
</I>&gt;<i> What if a raw-IP in the CONNECT message (or TCP SYN) does not belong to
</I>&gt;<i> the server named in SNI ?
</I>
:<i>-)  I left this out on purpose to not make the post even larger than it was.
</I>There is of course a lot of error checking.  The question is if
we have to configure it.  If yes, can we get away with one directive based
on an acl that uses tls::handshake_failure ?

&gt;<i> Squid would now be diverting the client transparently to a server other
</I>&gt;<i> than the one it expects and caching under that FQDN. But the server cert
</I>&gt;<i> would still authenticate as being the SNI host, so TLS cannot detect the
</I>&gt;<i> diversion.
</I>&gt;<i>
</I>&gt;<i> The fake CONNECT's are a bit messy but IMHO we can only get rid of the
</I>&gt;<i> first one done for intercepted connections. Although that alone would
</I>&gt;<i> make both cases handle the same way.
</I>
I do not know anything about the code that generates the fake CONNECT
of an transparent interception connection, but logically there should
not be a fake CONNECT for true HTTPS (TLS+HTTP) since a browser does
not do a CONNECT, so why fake one?  Was the fake CONNECT introduced
to keep a state?  If yes, the state can be administered in a different way.

However, in case of other protocols on port 443 a fake CONNECT is a
must to be able to filter and log it.

&gt;&gt;<i> For https connections with a client hello without the SNI extension:
</I>&gt;&gt;<i> tls_client_hello passthrough|terminate aclbar
</I>&gt;&gt;<i> where aclbar can contain tls::client_hello_missing_sni
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For connections that do not use TLS (i.e. not a valid
</I>&gt;&gt;<i> TLS client hello message was seen):
</I>&gt;&gt;<i> tls_client_hello passthrough|terminate aclbar2
</I>&gt;&gt;<i> where aclbar2 may contain tls::handshake_failure
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To define that the TLS handshake continues, the config can contain
</I>&gt;&gt;<i> tls_client_hello continue
</I>&gt;&gt;<i> This is a basically a no-op and not required but enhances readability
</I>&gt;&gt;<i> of a configuration.
</I>&gt;<i>
</I>&gt;<i> This is getting complicated again. Avoiding the first (TCP SYN) access
</I>&gt;<i> control cycles will make ssl::server_name ACL contain either FQDN/SNI or
</I>&gt;<i> the actual server cert name. A default &quot;none&quot; or &quot;-&quot; value when no
</I>&gt;<i> FQDN/SNI is available should be sufficient for matching these clients.
</I>&gt;<i> And we should have that already I think, if not its a missing feature bug.
</I>
Maybe in some cases tls_new_connection is required to be used, but
lets start with a default of
tls_new_connection continue
Under normal circumstances there is no need to define that Squid must
peek or already define that the connection must be spliced.

In my proposal there is no ssl::server_name and I did that on purpose.
While it might seem a nice idea to evaluate it from 'none' to SNI
to server name, there is no need for it and the use of tls::client_servername
and tls::server_servername explicitly refers to which servername
Squid must look at.
And at the moment that tls_new_connection is evaluated, there
is no servername when intercepted.

&gt;<i> Also even &quot;no-op&quot; ACLs still require CPU time to assemble data for ACL
</I>&gt;<i> checking. So avoiding that kind of thing in configs is good.
</I>
Maybe not, the no-op was there for readability and at config parse time
Squid can simply skip it to not have any CPU cycles wasted on it
by acl matching logic.

I am not familiar with all steps/stages in the implementation but
one may get better performance in a simpler design if that reduces
the number of events that Squid processes for each TLS connection.

&gt;&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>&gt;&gt;<i> Usually no directives are needed since rarely actions are taken
</I>&gt;&gt;<i> based on the server hello message, so the default is
</I>&gt;&gt;<i> tls_server_hello continue
</I>&gt;<i>
</I>&gt;<i> Once Squid gets to this stage of processing &quot;continue&quot; could mean either
</I>&gt;<i> splice or bump, but only one of the two is possible.
</I>&gt;<i>
</I>&gt;<i> Bump is not legal in a lot of situations but splice may not be possible.
</I>&gt;<i> So terminate is the only realistic default we can set for general use.
</I>&gt;<i> As you say, its uncommon to need it, and people who do tend to know what
</I>&gt;<i> they want done. So will configure that.
</I>
Admin who want https decryption do not want that the connection is
terminated by default.

You are right that tls_server_hello needs a little more thought.
Somewhere must be defined if the connection will have mode passthrough
(splice) or mode decrypt (bump).
And the right place to make that decision is at tls_client_hello
(after the SNI has been peeked at).
Then for tls_server_hello remains 'continue' and 'terminate' decisions.

&gt;<i> The handshake containing error signals or other protocols are different
</I>&gt;<i> decisions points. Remember Squid is deciding what to do with some data
</I>&gt;<i> that just arrived. If its going to tunnel/splice the server hello, there
</I>&gt;<i> is no point even evaluating what the protocol inside is, and error
</I>&gt;<i> alerts get delivered to the client as-is.
</I>&gt;<i>
</I>&gt;<i> So the existing on_unsupported_protocol and sslproxy_cert_error to make
</I>&gt;<i> those handling decisions with 'ssl_error' type ACL to match the specific
</I>&gt;<i> problem are fine IMO.
</I>
yes, they look fine but may need a rename to have a tls_ prefix
but I cannot find a way to define
continue when cert-is-self-signed and server_name is '.nic.es' and
otherwise terminate when cert-is-self-signed.

&gt;&gt;<i> The tls_server_hello can be used to terminate specific connections.
</I>&gt;&gt;<i> In this step many types of certificate errors can be detected
</I>&gt;&gt;<i> and in the Squid configuration there must be a way to define
</I>&gt;&gt;<i> what to do for specific errors and optionally for which FQDN.
</I>&gt;&gt;<i> E.g. allow to define that connections with self-signed certificates
</I>&gt;&gt;<i> are terminates but the self-signed cert for domain foo.example.com
</I>&gt;&gt;<i> is allowed.  See also the example config below and the use of
</I>&gt;&gt;<i> tls::server_servername.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What is left, is a configuration directive for connections
</I>&gt;&gt;<i> that use TLS as an encryption wrapper but do not use HTTP
</I>&gt;&gt;<i> inside the TLS wrapper:
</I>&gt;&gt;<i> tls_no_http passthrough|terminate   # similar to on_unsupported_protocol
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> An example configuration looks like this:
</I>&gt;&gt;<i> https_decryption on
</I>&gt;&gt;<i> acl banks tls::client_servername .bank1.example.org
</I>&gt;&gt;<i> acl no_sni tls::client_hello_missing_sni
</I>&gt;&gt;<i> acl no_handshake tls::handshake_failure
</I>&gt;&gt;<i> acl hacked_server tls::server_servername evil.example.com
</I>&gt;&gt;<i> tls_client_hello passthrough banks
</I>&gt;&gt;<i> tls_client_hello terminate no_sni
</I>&gt;&gt;<i> tls_client_hello passthrough no_handshake
</I>&gt;&gt;<i> tls_client_hello continue
</I>&gt;&gt;<i> tls_server_hello terminate hacked_server
</I>&gt;&gt;<i> tls_server_hello continue
</I>&gt;&gt;<i> tls_no_http passthrough
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The configuration directives as I proposed are IMO intuitive and
</I>&gt;&gt;<i> leave very little room for misunderstandings.
</I>&gt;<i>
</I>&gt;<i> Looks just like what I'm proposing except your config above lets clients
</I>&gt;<i> connect to servers with invalid TLS credentials (maybe not so intuitive?).
</I>
Are you referring to 'tls_client_hello passthrough no_handshake' ?
That should be 'tls_client_hello terminate no_handshake'.

&gt;<i>  acl banks ssl::server_name .bank1.example.org
</I>&gt;<i>  acl no_sni ssl::server_name &quot;-&quot;
</I>&gt;<i>  acl hacked_server ssl::server_name evil.example.com
</I>&gt;<i>
</I>&gt;<i>  tls_client_hello splice banks
</I>&gt;<i>  tls_client_hello terminate no_sni
</I>&gt;<i>  tls_client_hello terminate hacked_server
</I>&gt;<i>  tls_client_hello peek all
</I>&gt;<i>
</I>&gt;<i>  tls_server_hello terminate hacked_server
</I>&gt;<i>  tls_server_hello splice all
</I>&gt;<i>
</I>&gt;<i>  # NP: &quot;sslproxy_cert_error deny all&quot; is default
</I>&gt;<i>
</I>&gt;<i>  on_unsupported_protocol tunnel all
</I>
In my example at the time that tls_client_hello is evaluated,
the client hello has not only arrived but has also been parsed
and the SNI is known.  You also seem to intend that given
the rule 'tls_client_hello splice banks', but then why do you
have the rule 'tls_client_hello peek all' ?  Does that mean
'peek at the received client hello and continue' ?

The 'tls_client_hello continue' was intended to mean 'decrypt
the connection' (bump) but I failed to mention that.  I think
that 'tls_client_hello continue' must be replaced with
'tls_client_hello decrypt'.

There is a distinction between tls::server_servername and
tls::client_servername on one hand and ssl:server_name on the
other hand.  I prefer tls::* since it explicitly refers to
one of the servernames while ssl::server_name refers to
a dynamic object that needs evaluation and may evaluate to
different server names at different times.

One of the rules with 'terminate hacked_server' seems
redundant.

So after corrections, my example becomes
https_decryption on
acl banks tls::client_servername .bank1.example.org
acl no_sni tls::client_hello_missing_sni
acl no_handshake tls::handshake_failure
acl hacked_server tls::server_servername evil.example.com
tls_client_hello passthrough banks
tls_client_hello terminate no_sni
# tls_client_hello terminate no_handshake  # default behavior, so no rule needed
tls_client_hello decrypt
tls_server_hello terminate hacked_server
tls_server_hello continue
tls_unsupported_protocol passthrough all

In your example the meaning is to splice all connections and
with my proposed syntax the config would look like this:

https_decryption on
acl banks tls::client_servername .bank1.example.org
acl no_sni tls::client_hello_missing_sni
acl no_handshake tls::handshake_failure
acl hacked_server tls::server_servername evil.example.com
tls_client_hello passthrough banks
tls_client_hello terminate no_sni
tls_client_hello passthrough
tls_server_hello terminate hacked_server
tls_server_hello continue
tls_unsupported_protocol passthrough all

The choice of keywords for the config may seem a matter of taste,
but I feel it is more than that and that the keyword
'decrypt' is far better than 'bump' and the keyword
'passthrough' is better than 'splice'.

Marcus

&gt;<i> Amos
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i>
</I></PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007270.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007279.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7272">[ date ]</a>
              <a href="thread.html#7272">[ thread ]</a>
              <a href="subject.html#7272">[ subject ]</a>
              <a href="author.html#7272">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
