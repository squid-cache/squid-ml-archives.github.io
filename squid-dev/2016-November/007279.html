<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C27868cb5-0dc6-4eb9-5ede-b3a936d2eef1%40urlfilterdb.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007272.html">
   <LINK REL="Next"  HREF="007283.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Marcus Kool</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C27868cb5-0dc6-4eb9-5ede-b3a936d2eef1%40urlfilterdb.com%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">marcus.kool at urlfilterdb.com
       </A><BR>
    <I>Thu Nov 24 10:57:46 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007272.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007283.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7279">[ date ]</a>
              <a href="thread.html#7279">[ thread ]</a>
              <a href="subject.html#7279">[ subject ]</a>
              <a href="author.html#7279">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Amos,

Can you share your thoughts ?

Thanks
Marcus


On 11/20/2016 10:55 AM, Marcus Kool wrote:
&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 11/20/2016 12:06 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 20/11/2016 12:08 p.m., Marcus Kool wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;<i> [snip]
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I like the intent of the proposal and the new directives tls_*.
</I>&gt;&gt;&gt;<i> What currently makes configuration in Squid 3/4 difficult is
</I>&gt;&gt;&gt;<i> the logic of 'define in step x what to do in the next step' and
</I>&gt;&gt;&gt;<i> IMO this logic is the main cause of misunderstandings and
</I>&gt;&gt;&gt;<i> incorrect configurations.  Also the terms 'bump' and 'splice'
</I>&gt;&gt;&gt;<i> do not help ease of understanding.  Since Squid evolved and
</I>&gt;&gt;&gt;<i> bumping changed from 3.3 - 3.4 - 3.5 to 4.x, and likely will
</I>&gt;&gt;&gt;<i> change again in 5.x, there is an opportunity to improve
</I>&gt;&gt;&gt;<i> things more than is proposed.
</I>&gt;&gt;&gt;<i> There is also a difference in dealing with transparent intercepted
</I>&gt;&gt;&gt;<i> connections and direct connections (browsers doing a CONNECT)
</I>&gt;&gt;&gt;<i> which also causes some misunderstandings.
</I>&gt;&gt;&gt;<i> The current ssl bump steps allow problematic configs where Squid
</I>&gt;&gt;&gt;<i> bumps or stares in one step and to splice in an other step,
</I>&gt;&gt;&gt;<i> which can be resolved (made impossible) in a new configuration syntax.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I propose to use a new logic for the configuration directives
</I>&gt;&gt;&gt;<i> where 'define in step x what to do in the next step' is replaced
</I>&gt;&gt;&gt;<i> with a new logic 'define in step x what to do _now_'.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> From reading the below I think you are mistaking what &quot;now&quot; means to
</I>&gt;&gt;<i> Squid. Input access control directives in squid.conf make a decision
</I>&gt;&gt;<i> about what action to do based on some state that just arrived.
</I>&gt;<i>
</I>&gt;<i> Maybe it is necessary to redefine 'now' but my point remains that
</I>&gt;<i> 'define in step x what to do in the next step' is the cause of
</I>&gt;<i> most misunderstandings.
</I>&gt;<i>
</I>&gt;&gt;<i> For example:
</I>&gt;&gt;<i>  HTTP message just finished parsing -&gt; check http_access what to do with it.
</I>&gt;&gt;<i>  HTTP reply message just arrived -&gt; check http_reply_access what to do
</I>&gt;&gt;<i> with it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thus my proposal was along the lines of:
</I>&gt;&gt;<i>   client hello recieved -&gt; check tls_client_hello what to do with it.
</I>&gt;&gt;<i>   server hello recieved -&gt; check tls_server_hello what to do with it.
</I>&gt;<i>
</I>&gt;<i> For both hello messages: is the decision moment the moment where it
</I>&gt;<i> has been peeked at?
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Below is a new proposal to attempt to make the configuration
</I>&gt;&gt;&gt;<i> more intuitive and less prone for admin misunderstandings.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> First the admin must define if there is any bumping at all.
</I>&gt;&gt;&gt;<i> This could be done with
</I>&gt;&gt;&gt;<i> https_decryption on|off
</I>&gt;&gt;&gt;<i> This is similar to tls_new_connection peek|splice but much
</I>&gt;&gt;&gt;<i> more intuitive.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Iff https_decryption is on:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1) the &quot;connection&quot; step:
</I>&gt;&gt;&gt;<i> When a browser uses &quot;CONNECT &lt;FQDN&gt;&quot; Squid does not need to make
</I>&gt;&gt;&gt;<i> peek or splice decisions.
</I>&gt;&gt;&gt;<i> When Squid intercepts a connection to &quot;port 443 of &lt;IP&gt;&quot; no peek
</I>&gt;&gt;&gt;<i> or splice decision is made here any more.
</I>&gt;&gt;&gt;<i> This step becomes obsolete in the proposed configuration.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am still hoping that will happen. But also still getting pushback that
</I>&gt;&gt;<i> people want to terminate or splice without even looking at the
</I>&gt;&gt;<i> clear-text hello details.
</I>&gt;<i>
</I>&gt;<i> We must know the reasons behind this pushback.  Only then sane decisions
</I>&gt;<i> can be made.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 2) the &quot;TLS client hello&quot; step:
</I>&gt;&gt;&gt;<i> When a browser uses CONNECT, Squid has a FQDN and does not need
</I>&gt;&gt;&gt;<i> peeking a TLS client hello message. It can use the tls_client_hello
</I>&gt;&gt;&gt;<i> directives given below.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sadly this is not correct. Squid still needs to get the client hello
</I>&gt;&gt;<i> details at this point. They are needed to perform bump before the server
</I>&gt;&gt;<i> hello is received, and to &quot;terminate with an error message&quot; without
</I>&gt;&gt;<i> contacting a server.
</I>&gt;<i>
</I>&gt;<i> yes, correct.  Squid must do this.  But does it have to be configured?
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> When Squid intercepts a connection, Squid always peeks to retrieve
</I>&gt;&gt;&gt;<i> the SNI which is the equivalent of the FQDN used by a CONNECT.
</I>&gt;&gt;&gt;<i> In this step admins may want to define what Squid must do, e.g.
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough aclfoo
</I>&gt;&gt;&gt;<i> Note that the acl 'aclfoo' can use tls::client_servername and
</I>&gt;&gt;&gt;<i> tls::client_servername should always have a FQDN if the connection
</I>&gt;&gt;&gt;<i> is https.  tls::client_servername expands to the IP address if
</I>&gt;&gt;&gt;<i> the SNI of an intercepted connection could not be retrieved.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What if the SNI contradicts the CONNECT message FQDN ?
</I>&gt;&gt;<i> What if a raw-IP in the CONNECT message (or TCP SYN) does not belong to
</I>&gt;&gt;<i> the server named in SNI ?
</I>&gt;<i>
</I>&gt;<i> :-)  I left this out on purpose to not make the post even larger than it was.
</I>&gt;<i> There is of course a lot of error checking.  The question is if
</I>&gt;<i> we have to configure it.  If yes, can we get away with one directive based
</I>&gt;<i> on an acl that uses tls::handshake_failure ?
</I>&gt;<i>
</I>&gt;&gt;<i> Squid would now be diverting the client transparently to a server other
</I>&gt;&gt;<i> than the one it expects and caching under that FQDN. But the server cert
</I>&gt;&gt;<i> would still authenticate as being the SNI host, so TLS cannot detect the
</I>&gt;&gt;<i> diversion.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The fake CONNECT's are a bit messy but IMHO we can only get rid of the
</I>&gt;&gt;<i> first one done for intercepted connections. Although that alone would
</I>&gt;&gt;<i> make both cases handle the same way.
</I>&gt;<i>
</I>&gt;<i> I do not know anything about the code that generates the fake CONNECT
</I>&gt;<i> of an transparent interception connection, but logically there should
</I>&gt;<i> not be a fake CONNECT for true HTTPS (TLS+HTTP) since a browser does
</I>&gt;<i> not do a CONNECT, so why fake one?  Was the fake CONNECT introduced
</I>&gt;<i> to keep a state?  If yes, the state can be administered in a different way.
</I>&gt;<i>
</I>&gt;<i> However, in case of other protocols on port 443 a fake CONNECT is a
</I>&gt;<i> must to be able to filter and log it.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> For https connections with a client hello without the SNI extension:
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough|terminate aclbar
</I>&gt;&gt;&gt;<i> where aclbar can contain tls::client_hello_missing_sni
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> For connections that do not use TLS (i.e. not a valid
</I>&gt;&gt;&gt;<i> TLS client hello message was seen):
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough|terminate aclbar2
</I>&gt;&gt;&gt;<i> where aclbar2 may contain tls::handshake_failure
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> To define that the TLS handshake continues, the config can contain
</I>&gt;&gt;&gt;<i> tls_client_hello continue
</I>&gt;&gt;&gt;<i> This is a basically a no-op and not required but enhances readability
</I>&gt;&gt;&gt;<i> of a configuration.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is getting complicated again. Avoiding the first (TCP SYN) access
</I>&gt;&gt;<i> control cycles will make ssl::server_name ACL contain either FQDN/SNI or
</I>&gt;&gt;<i> the actual server cert name. A default &quot;none&quot; or &quot;-&quot; value when no
</I>&gt;&gt;<i> FQDN/SNI is available should be sufficient for matching these clients.
</I>&gt;&gt;<i> And we should have that already I think, if not its a missing feature bug.
</I>&gt;<i>
</I>&gt;<i> Maybe in some cases tls_new_connection is required to be used, but
</I>&gt;<i> lets start with a default of
</I>&gt;<i> tls_new_connection continue
</I>&gt;<i> Under normal circumstances there is no need to define that Squid must
</I>&gt;<i> peek or already define that the connection must be spliced.
</I>&gt;<i>
</I>&gt;<i> In my proposal there is no ssl::server_name and I did that on purpose.
</I>&gt;<i> While it might seem a nice idea to evaluate it from 'none' to SNI
</I>&gt;<i> to server name, there is no need for it and the use of tls::client_servername
</I>&gt;<i> and tls::server_servername explicitly refers to which servername
</I>&gt;<i> Squid must look at.
</I>&gt;<i> And at the moment that tls_new_connection is evaluated, there
</I>&gt;<i> is no servername when intercepted.
</I>&gt;<i>
</I>&gt;&gt;<i> Also even &quot;no-op&quot; ACLs still require CPU time to assemble data for ACL
</I>&gt;&gt;<i> checking. So avoiding that kind of thing in configs is good.
</I>&gt;<i>
</I>&gt;<i> Maybe not, the no-op was there for readability and at config parse time
</I>&gt;<i> Squid can simply skip it to not have any CPU cycles wasted on it
</I>&gt;<i> by acl matching logic.
</I>&gt;<i>
</I>&gt;<i> I am not familiar with all steps/stages in the implementation but
</I>&gt;<i> one may get better performance in a simpler design if that reduces
</I>&gt;<i> the number of events that Squid processes for each TLS connection.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>&gt;&gt;&gt;<i> Usually no directives are needed since rarely actions are taken
</I>&gt;&gt;&gt;<i> based on the server hello message, so the default is
</I>&gt;&gt;&gt;<i> tls_server_hello continue
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Once Squid gets to this stage of processing &quot;continue&quot; could mean either
</I>&gt;&gt;<i> splice or bump, but only one of the two is possible.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Bump is not legal in a lot of situations but splice may not be possible.
</I>&gt;&gt;<i> So terminate is the only realistic default we can set for general use.
</I>&gt;&gt;<i> As you say, its uncommon to need it, and people who do tend to know what
</I>&gt;&gt;<i> they want done. So will configure that.
</I>&gt;<i>
</I>&gt;<i> Admin who want https decryption do not want that the connection is
</I>&gt;<i> terminated by default.
</I>&gt;<i>
</I>&gt;<i> You are right that tls_server_hello needs a little more thought.
</I>&gt;<i> Somewhere must be defined if the connection will have mode passthrough
</I>&gt;<i> (splice) or mode decrypt (bump).
</I>&gt;<i> And the right place to make that decision is at tls_client_hello
</I>&gt;<i> (after the SNI has been peeked at).
</I>&gt;<i> Then for tls_server_hello remains 'continue' and 'terminate' decisions.
</I>&gt;<i>
</I>&gt;&gt;<i> The handshake containing error signals or other protocols are different
</I>&gt;&gt;<i> decisions points. Remember Squid is deciding what to do with some data
</I>&gt;&gt;<i> that just arrived. If its going to tunnel/splice the server hello, there
</I>&gt;&gt;<i> is no point even evaluating what the protocol inside is, and error
</I>&gt;&gt;<i> alerts get delivered to the client as-is.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So the existing on_unsupported_protocol and sslproxy_cert_error to make
</I>&gt;&gt;<i> those handling decisions with 'ssl_error' type ACL to match the specific
</I>&gt;&gt;<i> problem are fine IMO.
</I>&gt;<i>
</I>&gt;<i> yes, they look fine but may need a rename to have a tls_ prefix
</I>&gt;<i> but I cannot find a way to define
</I>&gt;<i> continue when cert-is-self-signed and server_name is '.nic.es' and
</I>&gt;<i> otherwise terminate when cert-is-self-signed.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> The tls_server_hello can be used to terminate specific connections.
</I>&gt;&gt;&gt;<i> In this step many types of certificate errors can be detected
</I>&gt;&gt;&gt;<i> and in the Squid configuration there must be a way to define
</I>&gt;&gt;&gt;<i> what to do for specific errors and optionally for which FQDN.
</I>&gt;&gt;&gt;<i> E.g. allow to define that connections with self-signed certificates
</I>&gt;&gt;&gt;<i> are terminates but the self-signed cert for domain foo.example.com
</I>&gt;&gt;&gt;<i> is allowed.  See also the example config below and the use of
</I>&gt;&gt;&gt;<i> tls::server_servername.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> What is left, is a configuration directive for connections
</I>&gt;&gt;&gt;<i> that use TLS as an encryption wrapper but do not use HTTP
</I>&gt;&gt;&gt;<i> inside the TLS wrapper:
</I>&gt;&gt;&gt;<i> tls_no_http passthrough|terminate   # similar to on_unsupported_protocol
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> An example configuration looks like this:
</I>&gt;&gt;&gt;<i> https_decryption on
</I>&gt;&gt;&gt;<i> acl banks tls::client_servername .bank1.example.org
</I>&gt;&gt;&gt;<i> acl no_sni tls::client_hello_missing_sni
</I>&gt;&gt;&gt;<i> acl no_handshake tls::handshake_failure
</I>&gt;&gt;&gt;<i> acl hacked_server tls::server_servername evil.example.com
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough banks
</I>&gt;&gt;&gt;<i> tls_client_hello terminate no_sni
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough no_handshake
</I>&gt;&gt;&gt;<i> tls_client_hello continue
</I>&gt;&gt;&gt;<i> tls_server_hello terminate hacked_server
</I>&gt;&gt;&gt;<i> tls_server_hello continue
</I>&gt;&gt;&gt;<i> tls_no_http passthrough
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The configuration directives as I proposed are IMO intuitive and
</I>&gt;&gt;&gt;<i> leave very little room for misunderstandings.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Looks just like what I'm proposing except your config above lets clients
</I>&gt;&gt;<i> connect to servers with invalid TLS credentials (maybe not so intuitive?).
</I>&gt;<i>
</I>&gt;<i> Are you referring to 'tls_client_hello passthrough no_handshake' ?
</I>&gt;<i> That should be 'tls_client_hello terminate no_handshake'.
</I>&gt;<i>
</I>&gt;&gt;<i>  acl banks ssl::server_name .bank1.example.org
</I>&gt;&gt;<i>  acl no_sni ssl::server_name &quot;-&quot;
</I>&gt;&gt;<i>  acl hacked_server ssl::server_name evil.example.com
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  tls_client_hello splice banks
</I>&gt;&gt;<i>  tls_client_hello terminate no_sni
</I>&gt;&gt;<i>  tls_client_hello terminate hacked_server
</I>&gt;&gt;<i>  tls_client_hello peek all
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  tls_server_hello terminate hacked_server
</I>&gt;&gt;<i>  tls_server_hello splice all
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  # NP: &quot;sslproxy_cert_error deny all&quot; is default
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  on_unsupported_protocol tunnel all
</I>&gt;<i>
</I>&gt;<i> In my example at the time that tls_client_hello is evaluated,
</I>&gt;<i> the client hello has not only arrived but has also been parsed
</I>&gt;<i> and the SNI is known.  You also seem to intend that given
</I>&gt;<i> the rule 'tls_client_hello splice banks', but then why do you
</I>&gt;<i> have the rule 'tls_client_hello peek all' ?  Does that mean
</I>&gt;<i> 'peek at the received client hello and continue' ?
</I>&gt;<i>
</I>&gt;<i> The 'tls_client_hello continue' was intended to mean 'decrypt
</I>&gt;<i> the connection' (bump) but I failed to mention that.  I think
</I>&gt;<i> that 'tls_client_hello continue' must be replaced with
</I>&gt;<i> 'tls_client_hello decrypt'.
</I>&gt;<i>
</I>&gt;<i> There is a distinction between tls::server_servername and
</I>&gt;<i> tls::client_servername on one hand and ssl:server_name on the
</I>&gt;<i> other hand.  I prefer tls::* since it explicitly refers to
</I>&gt;<i> one of the servernames while ssl::server_name refers to
</I>&gt;<i> a dynamic object that needs evaluation and may evaluate to
</I>&gt;<i> different server names at different times.
</I>&gt;<i>
</I>&gt;<i> One of the rules with 'terminate hacked_server' seems
</I>&gt;<i> redundant.
</I>&gt;<i>
</I>&gt;<i> So after corrections, my example becomes
</I>&gt;<i> https_decryption on
</I>&gt;<i> acl banks tls::client_servername .bank1.example.org
</I>&gt;<i> acl no_sni tls::client_hello_missing_sni
</I>&gt;<i> acl no_handshake tls::handshake_failure
</I>&gt;<i> acl hacked_server tls::server_servername evil.example.com
</I>&gt;<i> tls_client_hello passthrough banks
</I>&gt;<i> tls_client_hello terminate no_sni
</I>&gt;<i> # tls_client_hello terminate no_handshake  # default behavior, so no rule needed
</I>&gt;<i> tls_client_hello decrypt
</I>&gt;<i> tls_server_hello terminate hacked_server
</I>&gt;<i> tls_server_hello continue
</I>&gt;<i> tls_unsupported_protocol passthrough all
</I>&gt;<i>
</I>&gt;<i> In your example the meaning is to splice all connections and
</I>&gt;<i> with my proposed syntax the config would look like this:
</I>&gt;<i>
</I>&gt;<i> https_decryption on
</I>&gt;<i> acl banks tls::client_servername .bank1.example.org
</I>&gt;<i> acl no_sni tls::client_hello_missing_sni
</I>&gt;<i> acl no_handshake tls::handshake_failure
</I>&gt;<i> acl hacked_server tls::server_servername evil.example.com
</I>&gt;<i> tls_client_hello passthrough banks
</I>&gt;<i> tls_client_hello terminate no_sni
</I>&gt;<i> tls_client_hello passthrough
</I>&gt;<i> tls_server_hello terminate hacked_server
</I>&gt;<i> tls_server_hello continue
</I>&gt;<i> tls_unsupported_protocol passthrough all
</I>&gt;<i>
</I>&gt;<i> The choice of keywords for the config may seem a matter of taste,
</I>&gt;<i> but I feel it is more than that and that the keyword
</I>&gt;<i> 'decrypt' is far better than 'bump' and the keyword
</I>&gt;<i> 'passthrough' is better than 'splice'.
</I>&gt;<i>
</I>&gt;<i> Marcus
</I>&gt;<i>
</I>&gt;&gt;<i> Amos
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> squid-dev mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I></PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007272.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007283.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7279">[ date ]</a>
              <a href="thread.html#7279">[ thread ]</a>
              <a href="subject.html#7279">[ subject ]</a>
              <a href="author.html#7279">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
