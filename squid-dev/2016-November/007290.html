<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C0d79f393-fb4a-6f46-14cc-0481149c505a%40urlfilterdb.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007287.html">
   <LINK REL="Next"  HREF="007291.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Marcus Kool</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C0d79f393-fb4a-6f46-14cc-0481149c505a%40urlfilterdb.com%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">marcus.kool at urlfilterdb.com
       </A><BR>
    <I>Mon Nov 28 13:30:07 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007287.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007291.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7290">[ date ]</a>
              <a href="thread.html#7290">[ thread ]</a>
              <a href="subject.html#7290">[ subject ]</a>
              <a href="author.html#7290">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On 11/27/2016 11:20 PM, Alex Rousskov wrote:
&gt;<i> On 11/19/2016 07:06 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 20/11/2016 12:08 p.m., Marcus Kool wrote:
</I>&gt;&gt;&gt;<i> The current ssl bump steps allow problematic configs where Squid
</I>&gt;&gt;&gt;<i> bumps or stares in one step and to splice in an other step,
</I>&gt;&gt;&gt;<i> which can be resolved (made impossible) in a new configuration syntax.
</I>&gt;<i>
</I>&gt;<i> It would be nice to prohibit truly impossible actions at the syntax
</I>&gt;<i> level, but I suspect that the only way to make that possible is to focus
</I>&gt;<i> on final actions [instead of steps] and require at *most* one ssl_bump
</I>&gt;<i> rule for each of the supported final actions:
</I>&gt;<i>
</I>&gt;<i>   ssl_bump splice    ...rules that define when to splice...
</I>&gt;<i>   ssl_bump bump      ...rules that define when to bump...
</I>&gt;<i>   ssl_bump terminate ...rules that define when to terminate...
</I>&gt;<i>   # no other ssl_bump lines allowed!
</I>&gt;<i>
</I>&gt;<i> The current intermediate actions (peek and stare) would have to go into
</I>&gt;<i> the ACLs. There will be no ssl_bump rules for them at all. In other
</I>&gt;<i> words, the admin would be required to _always_ write an equivalent of
</I>&gt;<i>
</I>&gt;<i>   if (a1() &amp;&amp; a2() &amp;&amp; ...)
</I>&gt;<i>   then
</I>&gt;<i>       splice
</I>&gt;<i>   elsif (b1() &amp;&amp; b2() &amp;&amp; ...)
</I>&gt;<i>   then
</I>&gt;<i>       bump
</I>&gt;<i>   elsif (c1() &amp;&amp; c2() &amp;&amp; ...)
</I>&gt;<i>   then
</I>&gt;<i>       terminate
</I>&gt;<i>   else
</I>&gt;<i>       splice or bump, depending on state
</I>&gt;<i>       (or some other default; this decision is secondary)
</I>&gt;<i>   endif
</I>&gt;<i>
</I>&gt;<i> where a1(), b2(), and other functions/ACLs may peek or stare as needed
</I>&gt;<i> to get the required information.
</I>
The above if-then-else tree is clear.
I like your suggestion to drop steps in the configuration and make
Squid more intelligent to take decisions at the appropriate
moments (steps).

You mentioned admins being surprised about Squid bumping for a
notification of an error and one way to improve that is to replace
'terminate' by 'terminate_with_error' (with bumping) and 'quick_terminate'
(no bumping, just close fd).  The quick_terminate, if used, is also
faster, which is an added benefit.


&gt;<i> I am not sure such a change is desirable, but it is worth considering, I
</I>&gt;<i> guess.
</I>&gt;<i>
</I>&gt;<i> Please note that I am ignoring the directives/actions naming issue for now.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> AFAICT, the syntax proposed by Amos (i.e., making stepN mandatory) does
</I>&gt;<i> not solve this particular problem at all:
</I>&gt;<i>
</I>&gt;<i>   # Syntactically valid nonsense:
</I>&gt;<i>   ssl_bump_step1 splice all
</I>&gt;<i>   ssl_bump_step2 bump all
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> and neither is yours:
</I>&gt;<i>
</I>&gt;<i>   # Syntactically valid nonsense?
</I>&gt;<i>   tls_server_hello passthrough all
</I>&gt;<i>   tls_client_hello terminate all
</I>&gt;<i>
</I>
Correct.  It would be nice to have a better configuration syntax
where impossible rules are easier to avoid and/or Squid has
intelligence to detect nonsense rules and produce an error.

&gt;&gt;&gt;<i> Below is a new proposal to attempt to make the configuration
</I>&gt;&gt;&gt;<i> more intuitive and less prone for admin misunderstandings.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> First the admin must define if there is any bumping at all.
</I>&gt;&gt;&gt;<i> This could be done with
</I>&gt;&gt;&gt;<i> https_decryption on|off
</I>&gt;&gt;&gt;<i> This is similar to tls_new_connection peek|splice but much
</I>&gt;&gt;&gt;<i> more intuitive.
</I>&gt;<i>
</I>&gt;<i> I do not see why
</I>&gt;<i>
</I>&gt;<i>   https_decryption off
</I>&gt;<i>
</I>&gt;<i> is more intuitive (or more precise) than
</I>&gt;<i>
</I>&gt;<i>   ssl_bump splice all
</I>
For me this is because of the used terminology and because
with 'https_decryption off' one does not write anything
that has 'bump' in it, so the admin does not even have to
read the documentation to learn that 'ssl_bump splice all'
means 'no decryption'.

&gt;<i> especially after you consider the order of directives.
</I>&gt;<i>
</I>&gt;<i> Again, I am ignoring the naming issue for now. You may assume any name
</I>&gt;<i> you want for any directive or ACL.
</I>
allright for now.
The only comment that I want to make without starting a
new thread is that I think that conceptual terms are better
than technical terms (hence my preference for 'passthrough'
instead of 'splice').  But let's save this discussion for later.

&gt;&gt;&gt;<i> Iff https_decryption is on:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1) the &quot;connection&quot; step:
</I>&gt;&gt;&gt;<i> When a browser uses &quot;CONNECT &lt;FQDN&gt;&quot; Squid does not need to make
</I>&gt;&gt;&gt;<i> peek or splice decisions.
</I>&gt;&gt;&gt;<i> When Squid intercepts a connection to &quot;port 443 of &lt;IP&gt;&quot; no peek
</I>&gt;&gt;&gt;<i> or splice decision is made here any more.
</I>&gt;&gt;&gt;<i> This step becomes obsolete in the proposed configuration.
</I>&gt;<i>
</I>&gt;&gt;<i> I am still hoping that will happen. But also still getting pushback that
</I>&gt;&gt;<i> people want to terminate or splice without even looking at the
</I>&gt;&gt;<i> clear-text hello details.
</I>&gt;<i>
</I>&gt;<i> I suspect that not looking at some SSL Hellos will always be needed
</I>&gt;<i> because some of those Hellos are not Hellos at all and it takes too much
</I>&gt;<i> time/resources for the SSL Hellos parser to detect some non-SSL Hellos.
</I>&gt;<i> Besides that, it is always nice to be able to selectively bypass the
</I>&gt;<i> complex Hello parser code in emergencies.
</I>
Perhaps less resources are used if there is a two-stage parser:
1) quick scan of input for data layout of a ClientHello without
    semantic parsing the content, e.g. look at the CipherSuite and verify
    that the whole field has legal characters without verifying
    that the ciphersuite is a valid SSL string of ciphers.
2) do the complex parsing.

Stage 1 should be fast and can separate SSL ClientHello from other
protocols.

&gt;&gt;&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>&gt;&gt;&gt;<i> Usually no directives are needed since rarely actions are taken
</I>&gt;&gt;&gt;<i> based on the server hello message, so the default is
</I>&gt;&gt;&gt;<i> tls_server_hello continue
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Once Squid gets to this stage of processing &quot;continue&quot; could mean either
</I>&gt;&gt;<i> splice or bump, but only one of the two is possible.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Bump is not legal in a lot of situations but splice may not be possible.
</I>&gt;&gt;<i> So terminate is the only realistic default we can set for general use.
</I>&gt;&gt;<i> As you say, its uncommon to need it, and people who do tend to know what
</I>&gt;&gt;<i> they want done. So will configure that.
</I>&gt;<i>
</I>&gt;<i> Just like naming, the defaults are probably not that important yet: If
</I>&gt;<i> we can agree on the new configuration approach, then we probably will be
</I>&gt;<i> able to agree on the defaults.
</I>&gt;<i>
</I>&gt;<i> However, all proposals have to decide how to distinguish stare from peek
</I>&gt;<i> during step2. Those two intermediate actions result in different bytes
</I>&gt;<i> on the wire so they cannot be mapped to a single verb like &quot;continue&quot;.
</I>
An issue that complicates things is an &quot;impossible decision&quot;,
the desire to splice when &quot;it is too late&quot;.  I suggest to
solve this issue by simply splicing a bumped connection.
On the bumped connection Squid can also splice/passthrough:
just do not interpret the data and copy it from client to server
and vice versa.
Yes I realize that the connection is bumped and that on technical
grounds one can argue that the connection is not really spliced,
but on a conceptual level the connection _is_ in a 'passthrough mode'
and that is what 'splice' means or should mean.

With the concept of splicing a bumped connection, the problem
of making which decision at step2, if not yet made by some acls,
can be solved.

And I think that we do not have to be afraid of CPU cycles spent
in TLS/SSL encryption since modern multi-core systems are fast
with encryption:
<A HREF="https://software.intel.com/en-us/articles/accelerating-ssl-load-balancers-with-intel-xeon-v3-processors">https://software.intel.com/en-us/articles/accelerating-ssl-load-balancers-with-intel-xeon-v3-processors</A>
and Intel also has the quickassist hardware accelerator to create a powerful proxy:
<A HREF="http://www.intel.com/content/www/us/en/ethernet-products/gigabit-server-adapters/quickassist-adapter-for-servers.html">http://www.intel.com/content/www/us/en/ethernet-products/gigabit-server-adapters/quickassist-adapter-for-servers.html</A>
which is supported by OpenSSL:
<A HREF="http://www.intel.com/content/dam/www/public/us/en/documents/solution-briefs/accelerating-openssl-brief.pdf">http://www.intel.com/content/dam/www/public/us/en/documents/solution-briefs/accelerating-openssl-brief.pdf</A>

&gt;&gt;&gt;<i> An example configuration looks like this:
</I>&gt;&gt;&gt;<i> https_decryption on
</I>&gt;&gt;&gt;<i> acl banks tls::client_servername .bank1.example.org
</I>&gt;&gt;&gt;<i> acl no_sni tls::client_hello_missing_sni
</I>&gt;&gt;&gt;<i> acl no_handshake tls::handshake_failure
</I>&gt;&gt;&gt;<i> acl hacked_server tls::server_servername evil.example.com
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough banks
</I>&gt;&gt;&gt;<i> tls_client_hello terminate no_sni
</I>&gt;&gt;&gt;<i> tls_client_hello passthrough no_handshake
</I>&gt;&gt;&gt;<i> tls_client_hello continue
</I>&gt;&gt;&gt;<i> tls_server_hello terminate hacked_server
</I>&gt;&gt;&gt;<i> tls_server_hello continue
</I>&gt;&gt;&gt;<i> tls_no_http passthrough
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The configuration directives as I proposed are IMO intuitive and
</I>&gt;&gt;&gt;<i> leave very little room for misunderstandings.
</I>&gt;<i>
</I>&gt;<i> ... if you use them correctly. However, the same is true for the current
</I>&gt;<i> directives so this is not really an illustration of improvement AFAICT.
</I>&gt;<i> For example, what does the following [mis]configuration do?
</I>&gt;<i>
</I>&gt;<i>   https_decryption off
</I>&gt;<i>   tls_server_hello continue
</I>&gt;<i>   tls_server_hello terminate hacked_server
</I>&gt;<i>   https_decryption on
</I>&gt;<i>   tls_client_hello continue
</I>&gt;<i>   tls_client_hello passthrough banks
</I>&gt;<i>
</I>&gt;<i> If I understand the proposals correctly, the above will probably splice
</I>&gt;<i> or perhaps bump everything but I am obviously not sure. I do not see an
</I>&gt;<i> an improvement as far as possible confusion/misunderstanding is concerned.
</I>&gt;<i>
</I>&gt;<i> Again, I am ignoring the naming issue. If, for example, there is
</I>&gt;<i> consensus that &quot;passthrough&quot; is better than &quot;splice&quot; or &quot;continue2&quot; is
</I>&gt;<i> better than &quot;stare&quot; then we can, of course, add aliases and eventually
</I>&gt;<i> completely get rid of the old names. Let's focus on the functionality first.
</I>
You are good in finding examples of nonsense configurations :-)
And I think that a syntax that does not permit nonsense configurations,
does not exist.  The question is what to do.

If a new syntax is not based on steps, the config can just have a list
of rules and instead of Squid obeying the order of the TLS rules at
all times, it can gain intelligence and at the time that Squid is done
reading the configuration, validates whatever it can validate and makes
the decisions about which acls are executed/verified at what time (and
also does some runtime checks at the appropriate times).
So the config for 'bump all except banks' could look like this:
tls decryption on
tls default bump
tls splice banks
tls terminate clients_from_subnet_x
tls terminate hacked_server
tls splice no_http_protocol_inside_tls_wrapper  # default
tls splice no_tls_protocol                      # default
tls terminate tls_without_sni

The above is elegant and I think that the required intelligence to
decide to evaluate which rule at what step is not impossible.

Squid must not allow a mix of 'tls decryption on' and
'tls decryption off'.

Simple examples like above 'work'.  The question is if it
is possible for Squid to detect most or all nonsense configurations
and generate a (fatal?) error.

Marcus

&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I></PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007287.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007291.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7290">[ date ]</a>
              <a href="thread.html#7290">[ thread ]</a>
              <a href="subject.html#7290">[ subject ]</a>
              <a href="author.html#7290">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
