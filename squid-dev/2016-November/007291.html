<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C519575ab-1317-bd07-fcb7-f2a994065ed8%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007290.html">
   <LINK REL="Next"  HREF="007294.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C519575ab-1317-bd07-fcb7-f2a994065ed8%40measurement-factory.com%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Nov 28 17:58:55 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007290.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007294.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7291">[ date ]</a>
              <a href="thread.html#7291">[ thread ]</a>
              <a href="subject.html#7291">[ subject ]</a>
              <a href="author.html#7291">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/28/2016 06:30 AM, Marcus Kool wrote:
&gt;<i> On 11/27/2016 11:20 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> It would be nice to prohibit truly impossible actions at the syntax
</I>&gt;&gt;<i> level, but I suspect that the only way to make that possible is to focus
</I>&gt;&gt;<i> on final actions [instead of steps] and require at *most* one ssl_bump
</I>&gt;&gt;<i> rule for each of the supported final actions:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   ssl_bump splice    ...rules that define when to splice...
</I>&gt;&gt;<i>   ssl_bump bump      ...rules that define when to bump...
</I>&gt;&gt;<i>   ssl_bump terminate ...rules that define when to terminate...
</I>&gt;&gt;<i>   # no other ssl_bump lines allowed!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The current intermediate actions (peek and stare) would have to go into
</I>&gt;&gt;<i> the ACLs. There will be no ssl_bump rules for them at all. In other
</I>&gt;&gt;<i> words, the admin would be required to _always_ write an equivalent of
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   if (a1() &amp;&amp; a2() &amp;&amp; ...)
</I>&gt;&gt;<i>   then
</I>&gt;&gt;<i>       splice
</I>&gt;&gt;<i>   elsif (b1() &amp;&amp; b2() &amp;&amp; ...)
</I>&gt;&gt;<i>   then
</I>&gt;&gt;<i>       bump
</I>&gt;&gt;<i>   elsif (c1() &amp;&amp; c2() &amp;&amp; ...)
</I>&gt;&gt;<i>   then
</I>&gt;&gt;<i>       terminate
</I>&gt;&gt;<i>   else
</I>&gt;&gt;<i>       splice or bump, depending on state
</I>&gt;&gt;<i>       (or some other default; this decision is secondary)
</I>&gt;&gt;<i>   endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> where a1(), b2(), and other functions/ACLs may peek or stare as needed
</I>&gt;&gt;<i> to get the required information.
</I>
&gt;<i> The above if-then-else tree is clear.
</I>
It is clear at the top level. I am not sure we can also make the
secondary level (i.e., intermediate peak/state actions) clear because
they have to be side effects in this design and side effects are rarely
clear. We can try though.


&gt;<i> I like your suggestion to drop steps in the configuration and make
</I>&gt;<i> Squid more intelligent to take decisions at the appropriate
</I>&gt;<i> moments (steps).
</I>
Please note that the current configuration does not contain implicit
steps either; in its spirit/intent, it is essentially the same as the
above three-action sketch. Needless to say, most correct configurations
do contain an explicit step ACL or two, but they are supposed to be used
to essentially implement the above three-action logic.

Also, to avoid misunderstanding, I am not (yet) advocating any specific
configuration approach, including the one I started to sketch above. I
am only documenting a possible solution to the &quot;How to make impossible
actions invalid at the syntax level&quot; problem you have raised.


&gt;<i> You mentioned admins being surprised about Squid bumping for a
</I>&gt;<i> notification of an error and one way to improve that is to replace
</I>&gt;<i> 'terminate' by 'terminate_with_error' (with bumping) and 'quick_terminate'
</I>&gt;<i> (no bumping, just close fd).  The quick_terminate, if used, is also
</I>&gt;<i> faster, which is an added benefit.
</I>
Terminate is always an instant TCP connection closure, without any
bumping and without any errors being delivered to the user.

AFAIK, admins are not surprised by bumping when a terminate rule matches
(that would be a Squid bug). Admins are surprised by bumping when a
splice, peek, or stare rule matches. That surprise is a different
problem (that we should also try to solve, of course -- see the three
&quot;core problem&quot; bullets in my original response).


&gt;<i> The only comment that I want to make without starting a
</I>&gt;<i> new thread is that I think that conceptual terms are better
</I>&gt;<i> than technical terms (hence my preference for 'passthrough'
</I>&gt;<i> instead of 'splice').  But let's save this discussion for later.
</I>
Personally, I doubt we should spend much time discussing whether
&quot;passthrough&quot; is better than &quot;splice&quot;, but I agree that nobody should be
discussing naming until the much bigger (and, hopefully, solvable)
problems are solved.


&gt;&gt;<i> I suspect that not looking at some SSL Hellos will always be needed
</I>&gt;&gt;<i> because some of those Hellos are not Hellos at all and it takes too much
</I>&gt;&gt;<i> time/resources for the SSL Hellos parser to detect some non-SSL Hellos.
</I>&gt;&gt;<i> Besides that, it is always nice to be able to selectively bypass the
</I>&gt;&gt;<i> complex Hello parser code in emergencies.
</I>

&gt;<i> Perhaps less resources are used if there is a two-stage parser:
</I>&gt;<i> 1) quick scan of input for data layout of a ClientHello
</I>&gt;<i> 2) do the complex parsing.
</I>
Squid v4 already uses a two-stage Hello parser (the first stage is built
into Squid and the second stage is provided by OpenSSL).

You are oversimplifying the general protocol recognition problem because
you are focusing of the trivial cases. For example, one of the reasons
the first-stage parser cannot be always &quot;quick&quot; is because, in some
cases, there is no data to parse -- the server has to speak before the
client will send anything. Another example is SSL-like traffic that is
not really SSL. And a third example is Squid/OpenSSL limitations in
handling advanced valid SSL traffic. In summary, there will always be a
need for bypass IMO.


&gt;&gt;&gt;&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>
&gt;&gt;<i> all proposals have to decide how to distinguish stare from peek
</I>&gt;&gt;<i> during step2. Those two intermediate actions result in different bytes
</I>&gt;&gt;<i> on the wire so they cannot be mapped to a single verb like &quot;continue&quot;.
</I>
&gt;<i> An issue that complicates things is an &quot;impossible decision&quot;,
</I>&gt;<i> the desire to splice when &quot;it is too late&quot;.  I suggest to
</I>&gt;<i> solve this issue by simply splicing a bumped connection.
</I>
We can and probably should teach Squid to bump and tunnel stared at
connections as needed (I bet this can be done within the current
configuration paradigm). However, this does not help with distinguishing
two valid &quot;continue&quot; actions (peek at the server vs. stare at the
server). The admin has to tell Squid what to do (either peek or stare).
A single &quot;continue&quot; action does not/cannot carry that information.


&gt;&gt;&gt;&gt;<i> The configuration directives as I proposed are IMO intuitive and
</I>&gt;&gt;&gt;&gt;<i> leave very little room for misunderstandings.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ... if you use them correctly. However, the same is true for the current
</I>&gt;&gt;<i> directives so this is not really an illustration of improvement AFAICT.
</I>&gt;&gt;<i> For example, what does the following [mis]configuration do?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   https_decryption off
</I>&gt;&gt;<i>   tls_server_hello continue
</I>&gt;&gt;<i>   tls_server_hello terminate hacked_server
</I>&gt;&gt;<i>   https_decryption on
</I>&gt;&gt;<i>   tls_client_hello continue
</I>&gt;&gt;<i>   tls_client_hello passthrough banks
</I>
&gt;<i> You are good in finding examples of nonsense configurations :-)
</I>
I am just thinking from a confused user point of view. All the proposals
I have seen so far do not help much (and may hurt) when the admin
already knows what she is doing. To justify a configuration change, an
example has to illustrate an important _difference_ for a [confused]
user rather than just illustrate the new configuration.


&gt;<i> the config can just have a list
</I>&gt;<i> of rules and instead of Squid obeying the order of the TLS rules at
</I>&gt;<i> all times, it can gain intelligence and at the time that Squid is done
</I>&gt;<i> reading the configuration, validates whatever it can validate and makes
</I>&gt;<i> the decisions about which acls are executed/verified at what time (and
</I>&gt;<i> also does some runtime checks at the appropriate times).
</I>
This &quot;intelligence gathering&quot; cannot gather much information because
Squid cannot evaluate most ACLs outside a specific transaction context.

Also, it might be important to emphasize the primary point of ordered
rules (in general): Squid and lots of other software use ordered rules
not because they want to force the admin to think in some specific
&quot;steps&quot; order. They use ordered rules to implement the &quot;else&quot; logic. If
rules are unordered, then to implement &quot;if A then splice else bump&quot;
logic, one has to write &quot;If A then splice. If !A then bump&quot;. This
duplication of ACLs leads to configuration bugs and performance waste
(among other bad things).

This order support is why I wrote &quot;elsif&quot; in my earlier three-action
sketch instead of just writing &quot;if&quot; three times.


&gt;<i> So the config for 'bump all except banks' could look like this:
</I>&gt;<i> tls decryption on
</I>&gt;<i> tls default bump
</I>&gt;<i> tls splice banks
</I>&gt;<i> tls terminate clients_from_subnet_x
</I>&gt;<i> tls terminate hacked_server
</I>&gt;<i> tls splice no_http_protocol_inside_tls_wrapper  # default
</I>&gt;<i> tls splice no_tls_protocol                      # default
</I>&gt;<i> tls terminate tls_without_sni
</I>&gt;<i> 
</I>&gt;<i> The above is elegant and I think that the required intelligence to
</I>&gt;<i> decide to evaluate which rule at what step is not impossible.
</I>
This is already 90% supported AFAICT:

+ Squid already skips ssl_bump directives with currently impossible
actions and does not require explicit steps. The above config can be
written almost as is using the current configuration approach and almost
everything will &quot;work&quot; as intended (see the two bullets below for
exceptions).

- One invisible part of your example is not supported: There is
currently no way for an ACL to trigger a peeking or staring action to
gather more information. Whether it is a good idea to add ACLs with such
side effects is an open question. *If* they are added, the above
configuration will work with just one last minor change:

- The &quot;tls default bump&quot; has to be listed as the last &quot;tls bump all&quot;
rule. Adding a special &quot;default&quot; rule is also possible, of course, but I
doubt that it is a good idea because admins are already used to
ACL-driven rules to end with the default action.

Your own &quot;splice ... # default&quot; rules that contradict the &quot;default bump&quot;
setting is also a good illustration why a dedicated default directive
may not be a good idea -- there are often many &quot;defaults&quot; because Squid
&quot;default&quot; action often depends on the current transaction context.



&gt;<i> Squid must not allow a mix of 'tls decryption on' and
</I>&gt;<i> 'tls decryption off'.
</I>
Mixtures can be prohibited but such prohibitions often create problems
for [partially-generated] configurations. IMO, a better approach is to
infer whether &quot;decryption&quot; (whatever it is) is needed based on the
actual rules. This is what the current implementation does.


&gt;<i> Simple examples like above 'work'.  The question is if it
</I>&gt;<i> is possible for Squid to detect most or all nonsense configurations
</I>
I know the answer to that question: &quot;No&quot;. Complex actions like bumping
traffic require human intelligence. Squid will not be able to detect
bugs in advanced human thinking (in the foreseeable future). You cannot
make complex bumping both highly configurable and fool-proof. If you
want a fool-proof solution, I know of three possible ways:

* Reduction: Drastically reduce the number of supported configurations
and uses. Support just a few simple fool-proof cases. I think this
solution is unacceptable for a product like Squid and for a complex area
such as SSL bumping.

* Wizard: Provide an intelligent configuration generator/wizard which
asks admins some questions and then generates a valid squid.conf snippet
while guiding and educating the admin. A wizard may also evaluate a
given configuration, with human assistance (a much harder but not
impossible task). No Squid changes are necessary.

* Shim: Provide a set of simple new directives that cover basic bumping
needs. Internally, these directives are mapped to the already supported
&quot;power-user&quot; configuration. Admins using the new directives will not be
allowed to add old/power-user directives into the mix (i.e., the two
sets of directives will be mutually exclusive). This is a good approach
*if* we can come up with new fool-proof directives that cover many
bumping needs well.


Currently, this thread appears to be focused on another alternative:
Replacing the current set of directives with a much simpler one while
supporting the same functionality. This is an honorable goal, but I do
not think you can sneak &quot;detection of most nonsense configurations&quot; into
that. If the latter is your goal, see the three items above.


HTH,

Alex.

</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007290.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007294.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7291">[ date ]</a>
              <a href="thread.html#7291">[ thread ]</a>
              <a href="subject.html#7291">[ subject ]</a>
              <a href="author.html#7291">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
