<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C11fb5eb2-57b9-1e2d-25eb-866b3da9e906%40urlfilterdb.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007291.html">
   <LINK REL="Next"  HREF="007303.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Marcus Kool</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C11fb5eb2-57b9-1e2d-25eb-866b3da9e906%40urlfilterdb.com%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">marcus.kool at urlfilterdb.com
       </A><BR>
    <I>Mon Nov 28 22:26:34 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007291.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007303.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7294">[ date ]</a>
              <a href="thread.html#7294">[ thread ]</a>
              <a href="subject.html#7294">[ subject ]</a>
              <a href="author.html#7294">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On 11/28/2016 03:58 PM, Alex Rousskov wrote:
&gt;<i> On 11/28/2016 06:30 AM, Marcus Kool wrote:
</I>&gt;&gt;<i> On 11/27/2016 11:20 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> It would be nice to prohibit truly impossible actions at the syntax
</I>&gt;&gt;&gt;<i> level, but I suspect that the only way to make that possible is to focus
</I>&gt;&gt;&gt;<i> on final actions [instead of steps] and require at *most* one ssl_bump
</I>&gt;&gt;&gt;<i> rule for each of the supported final actions:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   ssl_bump splice    ...rules that define when to splice...
</I>&gt;&gt;&gt;<i>   ssl_bump bump      ...rules that define when to bump...
</I>&gt;&gt;&gt;<i>   ssl_bump terminate ...rules that define when to terminate...
</I>&gt;&gt;&gt;<i>   # no other ssl_bump lines allowed!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The current intermediate actions (peek and stare) would have to go into
</I>&gt;&gt;&gt;<i> the ACLs. There will be no ssl_bump rules for them at all. In other
</I>&gt;&gt;&gt;<i> words, the admin would be required to _always_ write an equivalent of
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   if (a1() &amp;&amp; a2() &amp;&amp; ...)
</I>&gt;&gt;&gt;<i>   then
</I>&gt;&gt;&gt;<i>       splice
</I>&gt;&gt;&gt;<i>   elsif (b1() &amp;&amp; b2() &amp;&amp; ...)
</I>&gt;&gt;&gt;<i>   then
</I>&gt;&gt;&gt;<i>       bump
</I>&gt;&gt;&gt;<i>   elsif (c1() &amp;&amp; c2() &amp;&amp; ...)
</I>&gt;&gt;&gt;<i>   then
</I>&gt;&gt;&gt;<i>       terminate
</I>&gt;&gt;&gt;<i>   else
</I>&gt;&gt;&gt;<i>       splice or bump, depending on state
</I>&gt;&gt;&gt;<i>       (or some other default; this decision is secondary)
</I>&gt;&gt;&gt;<i>   endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> where a1(), b2(), and other functions/ACLs may peek or stare as needed
</I>&gt;&gt;&gt;<i> to get the required information.
</I>&gt;<i>
</I>&gt;&gt;<i> The above if-then-else tree is clear.
</I>&gt;<i>
</I>&gt;<i> It is clear at the top level. I am not sure we can also make the
</I>&gt;<i> secondary level (i.e., intermediate peak/state actions) clear because
</I>&gt;<i> they have to be side effects in this design and side effects are rarely
</I>&gt;<i> clear. We can try though.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I like your suggestion to drop steps in the configuration and make
</I>&gt;&gt;<i> Squid more intelligent to take decisions at the appropriate
</I>&gt;&gt;<i> moments (steps).
</I>&gt;<i>
</I>&gt;<i> Please note that the current configuration does not contain implicit
</I>&gt;<i> steps either; in its spirit/intent, it is essentially the same as the
</I>&gt;<i> above three-action sketch. Needless to say, most correct configurations
</I>&gt;<i> do contain an explicit step ACL or two, but they are supposed to be used
</I>&gt;<i> to essentially implement the above three-action logic.
</I>&gt;<i>
</I>&gt;<i> Also, to avoid misunderstanding, I am not (yet) advocating any specific
</I>&gt;<i> configuration approach, including the one I started to sketch above. I
</I>&gt;<i> am only documenting a possible solution to the &quot;How to make impossible
</I>&gt;<i> actions invalid at the syntax level&quot; problem you have raised.
</I>
Yeah, I used a bit optimistic wording.  It cannot be solved at the syntax
level, but should be possible at the semantic level.

&gt;&gt;<i> You mentioned admins being surprised about Squid bumping for a
</I>&gt;&gt;<i> notification of an error and one way to improve that is to replace
</I>&gt;&gt;<i> 'terminate' by 'terminate_with_error' (with bumping) and 'quick_terminate'
</I>&gt;&gt;<i> (no bumping, just close fd).  The quick_terminate, if used, is also
</I>&gt;&gt;<i> faster, which is an added benefit.
</I>
I replied to the item where admins get confused when Squid bumps
to generate an error and suggested a way to control the behavior
of Squid to terminate instead of bump and generate an error.

&gt;<i> Terminate is always an instant TCP connection closure, without any
</I>&gt;<i> bumping and without any errors being delivered to the user.
</I>&gt;<i>
</I>&gt;<i> AFAIK, admins are not surprised by bumping when a terminate rule matches
</I>&gt;<i> (that would be a Squid bug). Admins are surprised by bumping when a
</I>&gt;<i> splice, peek, or stare rule matches. That surprise is a different
</I>&gt;<i> problem (that we should also try to solve, of course -- see the three
</I>&gt;<i> &quot;core problem&quot; bullets in my original response).
</I>

&gt;<i>
</I>&gt;&gt;<i> The only comment that I want to make without starting a
</I>&gt;&gt;<i> new thread is that I think that conceptual terms are better
</I>&gt;&gt;<i> than technical terms (hence my preference for 'passthrough'
</I>&gt;&gt;<i> instead of 'splice').  But let's save this discussion for later.
</I>&gt;<i>
</I>&gt;<i> Personally, I doubt we should spend much time discussing whether
</I>&gt;<i> &quot;passthrough&quot; is better than &quot;splice&quot;, but I agree that nobody should be
</I>&gt;<i> discussing naming until the much bigger (and, hopefully, solvable)
</I>&gt;<i> problems are solved.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> I suspect that not looking at some SSL Hellos will always be needed
</I>&gt;&gt;&gt;<i> because some of those Hellos are not Hellos at all and it takes too much
</I>&gt;&gt;&gt;<i> time/resources for the SSL Hellos parser to detect some non-SSL Hellos.
</I>&gt;&gt;&gt;<i> Besides that, it is always nice to be able to selectively bypass the
</I>&gt;&gt;&gt;<i> complex Hello parser code in emergencies.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Perhaps less resources are used if there is a two-stage parser:
</I>&gt;&gt;<i> 1) quick scan of input for data layout of a ClientHello
</I>&gt;&gt;<i> 2) do the complex parsing.
</I>&gt;<i>
</I>&gt;<i> Squid v4 already uses a two-stage Hello parser (the first stage is built
</I>&gt;<i> into Squid and the second stage is provided by OpenSSL).
</I>&gt;<i>
</I>&gt;<i> You are oversimplifying the general protocol recognition problem because
</I>&gt;<i> you are focusing of the trivial cases. For example, one of the reasons
</I>&gt;<i> the first-stage parser cannot be always &quot;quick&quot; is because, in some
</I>&gt;<i> cases, there is no data to parse -- the server has to speak before the
</I>&gt;<i> client will send anything. Another example is SSL-like traffic that is
</I>&gt;<i> not really SSL. And a third example is Squid/OpenSSL limitations in
</I>&gt;<i> handling advanced valid SSL traffic. In summary, there will always be a
</I>&gt;<i> need for bypass IMO.
</I>
I am not suggesting to drop a bypass.
The comment was about the fact that determination if data from a client
is a syntactically valid ClientHello message should be quick and without
use of OpenSSL functions.  Since I do not know all SSL-like traffic of
all applications it is open for debate if it is possible, but I remain
optimistic that it can be done.

When a server sends data first, it is not a TLS handshake.
So when a server sends data first, Squid knows quickly (if the server
is quick) that the connection is not a TLS connection, right?

&gt;&gt;&gt;&gt;&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> all proposals have to decide how to distinguish stare from peek
</I>&gt;&gt;&gt;<i> during step2. Those two intermediate actions result in different bytes
</I>&gt;&gt;&gt;<i> on the wire so they cannot be mapped to a single verb like &quot;continue&quot;.
</I>&gt;<i>
</I>&gt;&gt;<i> An issue that complicates things is an &quot;impossible decision&quot;,
</I>&gt;&gt;<i> the desire to splice when &quot;it is too late&quot;.  I suggest to
</I>&gt;&gt;<i> solve this issue by simply splicing a bumped connection.
</I>&gt;<i>
</I>&gt;<i> We can and probably should teach Squid to bump and tunnel stared at
</I>&gt;<i> connections as needed (I bet this can be done within the current
</I>&gt;<i> configuration paradigm). However, this does not help with distinguishing
</I>&gt;<i> two valid &quot;continue&quot; actions (peek at the server vs. stare at the
</I>&gt;<i> server). The admin has to tell Squid what to do (either peek or stare).
</I>&gt;<i> A single &quot;continue&quot; action does not/cannot carry that information.
</I>
It can help.  Suppose one want to make a decision based on the server
certificate, then currently one must use stare at step2 and currently
this has a limitation that it cannot be spliced at step3.
With a splice-bumped-connections feature this issue is resolved by
staring at step2 and make a splice-or-bump decision at step3.
So the decision that currently is enforced at step2 can be postponed
by doing a 'continue' and decide at step3.

&gt;&gt;&gt;&gt;&gt;<i> The configuration directives as I proposed are IMO intuitive and
</I>&gt;&gt;&gt;&gt;&gt;<i> leave very little room for misunderstandings.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ... if you use them correctly. However, the same is true for the current
</I>&gt;&gt;&gt;<i> directives so this is not really an illustration of improvement AFAICT.
</I>&gt;&gt;&gt;<i> For example, what does the following [mis]configuration do?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   https_decryption off
</I>&gt;&gt;&gt;<i>   tls_server_hello continue
</I>&gt;&gt;&gt;<i>   tls_server_hello terminate hacked_server
</I>&gt;&gt;&gt;<i>   https_decryption on
</I>&gt;&gt;&gt;<i>   tls_client_hello continue
</I>&gt;&gt;&gt;<i>   tls_client_hello passthrough banks
</I>&gt;<i>
</I>&gt;&gt;<i> You are good in finding examples of nonsense configurations :-)
</I>&gt;<i>
</I>&gt;<i> I am just thinking from a confused user point of view. All the proposals
</I>&gt;<i> I have seen so far do not help much (and may hurt) when the admin
</I>&gt;<i> already knows what she is doing. To justify a configuration change, an
</I>&gt;<i> example has to illustrate an important _difference_ for a [confused]
</I>&gt;<i> user rather than just illustrate the new configuration.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> the config can just have a list
</I>&gt;&gt;<i> of rules and instead of Squid obeying the order of the TLS rules at
</I>&gt;&gt;<i> all times, it can gain intelligence and at the time that Squid is done
</I>&gt;&gt;<i> reading the configuration, validates whatever it can validate and makes
</I>&gt;&gt;<i> the decisions about which acls are executed/verified at what time (and
</I>&gt;&gt;<i> also does some runtime checks at the appropriate times).
</I>&gt;<i>
</I>&gt;<i> This &quot;intelligence gathering&quot; cannot gather much information because
</I>&gt;<i> Squid cannot evaluate most ACLs outside a specific transaction context.
</I>&gt;<i>
</I>&gt;<i> Also, it might be important to emphasize the primary point of ordered
</I>&gt;<i> rules (in general): Squid and lots of other software use ordered rules
</I>&gt;<i> not because they want to force the admin to think in some specific
</I>&gt;<i> &quot;steps&quot; order. They use ordered rules to implement the &quot;else&quot; logic. If
</I>&gt;<i> rules are unordered, then to implement &quot;if A then splice else bump&quot;
</I>&gt;<i> logic, one has to write &quot;If A then splice. If !A then bump&quot;. This
</I>&gt;<i> duplication of ACLs leads to configuration bugs and performance waste
</I>&gt;<i> (among other bad things).
</I>&gt;<i>
</I>&gt;<i> This order support is why I wrote &quot;elsif&quot; in my earlier three-action
</I>&gt;<i> sketch instead of just writing &quot;if&quot; three times.
</I>
Order is often important, but Squid can gain more
intelligence by upfront making decisions about which rules
get evaluated when.  For example, 'splice banks' can only be
done when the server_name is known so after a peek and can be skipped
when the server_name is not yet known.

&gt;&gt;<i> So the config for 'bump all except banks' could look like this:
</I>&gt;&gt;<i> tls decryption on
</I>&gt;&gt;<i> tls default bump
</I>&gt;&gt;<i> tls splice banks
</I>&gt;&gt;<i> tls terminate clients_from_subnet_x
</I>&gt;&gt;<i> tls terminate hacked_server
</I>&gt;&gt;<i> tls splice no_http_protocol_inside_tls_wrapper  # default
</I>&gt;&gt;<i> tls splice no_tls_protocol                      # default
</I>&gt;&gt;<i> tls terminate tls_without_sni
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The above is elegant and I think that the required intelligence to
</I>&gt;&gt;<i> decide to evaluate which rule at what step is not impossible.
</I>&gt;<i>
</I>&gt;<i> This is already 90% supported AFAICT:
</I>&gt;<i>
</I>&gt;<i> + Squid already skips ssl_bump directives with currently impossible
</I>&gt;<i> actions and does not require explicit steps. The above config can be
</I>&gt;<i> written almost as is using the current configuration approach and almost
</I>&gt;<i> everything will &quot;work&quot; as intended (see the two bullets below for
</I>&gt;<i> exceptions).
</I>&gt;<i>
</I>&gt;<i> - One invisible part of your example is not supported: There is
</I>&gt;<i> currently no way for an ACL to trigger a peeking or staring action to
</I>&gt;<i> gather more information. Whether it is a good idea to add ACLs with such
</I>&gt;<i> side effects is an open question. *If* they are added, the above
</I>&gt;<i> configuration will work with just one last minor change:
</I>&gt;<i>
</I>&gt;<i> - The &quot;tls default bump&quot; has to be listed as the last &quot;tls bump all&quot;
</I>&gt;<i> rule. Adding a special &quot;default&quot; rule is also possible, of course, but I
</I>&gt;<i> doubt that it is a good idea because admins are already used to
</I>&gt;<i> ACL-driven rules to end with the default action.
</I>&gt;<i>
</I>&gt;<i> Your own &quot;splice ... # default&quot; rules that contradict the &quot;default bump&quot;
</I>&gt;<i> setting is also a good illustration why a dedicated default directive
</I>&gt;<i> may not be a good idea -- there are often many &quot;defaults&quot; because Squid
</I>&gt;<i> &quot;default&quot; action often depends on the current transaction context.
</I>
If you interpret 'tls default bump' as 'the objective is to bump'
and 'splice banks' as an exception to the default behavior, they do
not contradict.

IMO your 3-bullet list misses these:
* improve the syntax/rules since currently it confuses too many admins
* make the configuration simpler where an admin does not have
   to know many details of the TLS protocol.

The first bullet is why Amos and I tried to improve the
situation by syntactical changes.

The last bullet may also be interpreted as: make the config
rules simple for 95% of all sites and support optional complex rules
for the rest.

&gt;&gt;<i> Squid must not allow a mix of 'tls decryption on' and
</I>&gt;&gt;<i> 'tls decryption off'.
</I>&gt;<i>
</I>&gt;<i> Mixtures can be prohibited but such prohibitions often create problems
</I>&gt;<i> for [partially-generated] configurations. IMO, a better approach is to
</I>&gt;<i> infer whether &quot;decryption&quot; (whatever it is) is needed based on the
</I>&gt;<i> actual rules. This is what the current implementation does.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Simple examples like above 'work'.  The question is if it
</I>&gt;&gt;<i> is possible for Squid to detect most or all nonsense configurations
</I>&gt;<i>
</I>&gt;<i> I know the answer to that question: &quot;No&quot;. Complex actions like bumping
</I>&gt;<i> traffic require human intelligence. Squid will not be able to detect
</I>&gt;<i> bugs in advanced human thinking (in the foreseeable future). You cannot
</I>&gt;<i> make complex bumping both highly configurable and fool-proof. If you
</I>&gt;<i> want a fool-proof solution, I know of three possible ways:
</I>&gt;<i>
</I>&gt;<i> * Reduction: Drastically reduce the number of supported configurations
</I>&gt;<i> and uses. Support just a few simple fool-proof cases. I think this
</I>&gt;<i> solution is unacceptable for a product like Squid and for a complex area
</I>&gt;<i> such as SSL bumping.
</I>
An alternative for Reduction is a list of good examples (better than
wiki has).

&gt;<i> * Wizard: Provide an intelligent configuration generator/wizard which
</I>&gt;<i> asks admins some questions and then generates a valid squid.conf snippet
</I>&gt;<i> while guiding and educating the admin. A wizard may also evaluate a
</I>&gt;<i> given configuration, with human assistance (a much harder but not
</I>&gt;<i> impossible task). No Squid changes are necessary.
</I>
Would like to see that :-)

&gt;<i> * Shim: Provide a set of simple new directives that cover basic bumping
</I>&gt;<i> needs. Internally, these directives are mapped to the already supported
</I>&gt;<i> &quot;power-user&quot; configuration. Admins using the new directives will not be
</I>&gt;<i> allowed to add old/power-user directives into the mix (i.e., the two
</I>&gt;<i> sets of directives will be mutually exclusive). This is a good approach
</I>&gt;<i> *if* we can come up with new fool-proof directives that cover many
</I>&gt;<i> bumping needs well.
</I>
Shim is nice, but does not change the current situation for power-users.

&gt;<i> Currently, this thread appears to be focused on another alternative:
</I>&gt;<i> Replacing the current set of directives with a much simpler one while
</I>&gt;<i> supporting the same functionality. This is an honorable goal, but I do
</I>&gt;<i> not think you can sneak &quot;detection of most nonsense configurations&quot; into
</I>&gt;<i> that. If the latter is your goal, see the three items above.
</I>
Going back to your 3 bullets,
* Can you give an example of more dynamic ACLs?
   I am surprised that admins are surprised that Squid does server
   certificate validation.  Maybe document it better?
* the issue with price becomes less if splice-a-bumped-connection
   is implemented and also solves the problem of precluding future
   decisions.
* I suggest to document that Squid bumps a connection to send
   an error message.  Maybe error handling can be separated from
   the other ssl bump rules and have a list of acls on how to act
   (terminate or bump+error) in case there is an error.

Marcus

&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I></PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007291.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007303.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7294">[ date ]</a>
              <a href="thread.html#7294">[ thread ]</a>
              <a href="subject.html#7294">[ subject ]</a>
              <a href="author.html#7294">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
