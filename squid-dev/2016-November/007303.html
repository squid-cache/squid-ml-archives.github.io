<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] simplifying ssl_bump complexity
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C2fb5800f-ee1b-3162-623f-a7d28669ca8a%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007294.html">
   <LINK REL="Next"  HREF="007286.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] simplifying ssl_bump complexity</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20simplifying%20ssl_bump%20complexity&In-Reply-To=%3C2fb5800f-ee1b-3162-623f-a7d28669ca8a%40measurement-factory.com%3E"
       TITLE="[squid-dev] [RFC] simplifying ssl_bump complexity">rousskov at measurement-factory.com
       </A><BR>
    <I>Tue Nov 29 19:19:10 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007294.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
        <LI>Next message: <A HREF="007286.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7303">[ date ]</a>
              <a href="thread.html#7303">[ thread ]</a>
              <a href="subject.html#7303">[ subject ]</a>
              <a href="author.html#7303">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/28/2016 03:26 PM, Marcus Kool wrote:

&gt;<i> The comment was about the fact that determination if data from a client
</I>&gt;<i> is a syntactically valid ClientHello message should be quick
</I>
Unfortunately, it is not a fact. In simple cases, you are right (which
is why Squid v4 already uses a two-stage parser). In other cases, it may
cost time or even require taking some risks to make the &quot;client speaks
TLS&quot; determination. This is why bypass support is required _before_ any
TLS parsing starts.


&gt;<i> When a server sends data first, it is not a TLS handshake.
</I>
I am not sure that is 100% accurate because there could be TLS servers
that send the first byte(s) early (for some stupid reason), but even if
we are sure that such servers do not exist, Squid cannot know whether
the server is going to speak first unless Squid has _connected_ to the
server already (and waited for some time). In some cases, the admin does
not want Squid to contact the server (even at TCP level) until Squid is
sure that the connection is carrying TLS with validated SNI.


&gt;<i> So when a server sends data first, Squid knows quickly (if the server
</I>&gt;<i> is quick) that the connection is not a TLS connection, right?
</I>
No quite, unfortunately. See my previous message and the above example
for the cases where nothing is quick or simple at the expected-TLS level.



&gt;&gt;&gt;&gt;&gt;&gt;<i> 3) the &quot;TLS server hello&quot; step:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> all proposals have to decide how to distinguish stare from peek
</I>&gt;&gt;&gt;&gt;<i> during step2. Those two intermediate actions result in different bytes
</I>&gt;&gt;&gt;&gt;<i> on the wire so they cannot be mapped to a single verb like &quot;continue&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> An issue that complicates things is an &quot;impossible decision&quot;,
</I>&gt;&gt;&gt;<i> the desire to splice when &quot;it is too late&quot;.  I suggest to
</I>&gt;&gt;&gt;<i> solve this issue by simply splicing a bumped connection.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We can and probably should teach Squid to bump and tunnel stared at
</I>&gt;&gt;<i> connections as needed (I bet this can be done within the current
</I>&gt;&gt;<i> configuration paradigm). However, this does not help with distinguishing
</I>&gt;&gt;<i> two valid &quot;continue&quot; actions (peek at the server vs. stare at the
</I>&gt;&gt;<i> server). The admin has to tell Squid what to do (either peek or stare).
</I>&gt;&gt;<i> A single &quot;continue&quot; action does not/cannot carry that information.
</I>
&gt;<i> Suppose one want to make a decision based on the server
</I>&gt;<i> certificate, then currently one must use stare at step2 and currently
</I>&gt;<i> this has a limitation that it cannot be spliced at step3.
</I>&gt;<i> With a splice-bumped-connections feature this issue is resolved by
</I>&gt;<i> staring at step2 and make a splice-or-bump decision at step3.
</I>
Yes, tunneling of bumped connections is useful in _some_ cases and
should be supported, but it does not eliminate the a peek-vs-stare
decision at step2. If you assume that it does eliminate that decision,
then you have to assume that bumping always works, which is obviously
not true.

* If Squid is talking to a server that cannot be successfully bumped,
the [future] support for tunneling of bumped connections does not help,
and the admin has to tell Squid to peek rather than stare.

* If Squid is talking to a server that can and should be successfully
bumped, the [future] support for tunneling of bumped connections helps,
but the admin has to tell Squid to stare rather than peek.

Thus, a single &quot;continue&quot; action does not work -- it will not
accommodate one of the two bullets above.

[ FWIW, I strongly discourage you from applying the term &quot;splice&quot; to
bumped connections -- it is easy to deceive oneself that staring is not
needed because all connections end up &quot;spliced&quot;. I recommend saying
&quot;tunneled&quot; when talking about bumped connections passed through Squid
(as opposed to spliced connections passed through Squid). ]


&gt;<i> So the decision that currently is enforced at step2 can be postponed
</I>&gt;<i> by doing a 'continue' and decide at step3.
</I>
AFAICT, your logic is missing the fact that, if step2 is not final, then
Squid has to do one of two actions during step2: stare or peek. Those
are different actions, resulting in different bytes on the wire. You
cannot postpone that peek-vs-stare decision until the final step3. Thus,
one &quot;continue&quot; action does not work.

Again, the requirement for two &quot;continue&quot; actions does not imply that
tunneling of bumped connections is not helpful in some cases!


&gt;<i> Squid can gain more
</I>&gt;<i> intelligence by upfront making decisions about which rules
</I>&gt;<i> get evaluated when.  For example, 'splice banks' can only be
</I>&gt;<i> done when the server_name is known so after a peek and can be skipped
</I>&gt;<i> when the server_name is not yet known.
</I>
That example does not compute for me: To know whether the server_name is
known, Squid has to evaluate the server_name ACL. If that evaluation is
possible, Squid should just use its result (and skip or honor the
&quot;splice banks&quot; rule) instead of speculating that the rule can be safely
skipped during step1.

In real configurations, most rules cannot be correctly evaluated outside
transaction context because they contain ACLs, such as the
ssl::server_name ACL, that are context-dependent.


&gt;&gt;&gt;<i> So the config for 'bump all except banks' could look like this:
</I>&gt;&gt;&gt;<i> tls decryption on
</I>&gt;&gt;&gt;<i> tls default bump
</I>&gt;&gt;&gt;<i> tls splice banks
</I>&gt;&gt;&gt;<i> tls terminate clients_from_subnet_x
</I>&gt;&gt;&gt;<i> tls terminate hacked_server
</I>&gt;&gt;&gt;<i> tls splice no_http_protocol_inside_tls_wrapper  # default
</I>&gt;&gt;&gt;<i> tls splice no_tls_protocol                      # default
</I>&gt;&gt;&gt;<i> tls terminate tls_without_sni
</I>
&gt;&gt;<i> Your own &quot;splice ... # default&quot; rules that contradict the &quot;default bump&quot;
</I>&gt;&gt;<i> setting is also a good illustration why a dedicated default directive
</I>&gt;&gt;<i> may not be a good idea -- there are often many &quot;defaults&quot; because Squid
</I>&gt;&gt;<i> &quot;default&quot; action often depends on the current transaction context.
</I>
&gt;<i> If you interpret 'tls default bump' as 'the objective is to bump'
</I>&gt;<i> and 'splice banks' as an exception to the default behavior, they do
</I>&gt;<i> not contradict.
</I>
I do not think many reasonable people can interpret &quot;... # default&quot; as
&quot;an exception to the default behavior&quot; but YMMV.


&gt;&gt;&gt;<i> The question is if it
</I>&gt;&gt;&gt;<i> is possible for Squid to detect most or all nonsense configurations
</I>
&gt;&gt;<i> I know the answer to that question: &quot;No&quot;. Complex actions like bumping
</I>&gt;&gt;<i> traffic require human intelligence. Squid will not be able to detect
</I>&gt;&gt;<i> bugs in advanced human thinking (in the foreseeable future). You cannot
</I>&gt;&gt;<i> make complex bumping both highly configurable and fool-proof. If you
</I>&gt;&gt;<i> want a fool-proof solution, I know of three possible ways:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * Reduction: Drastically reduce the number of supported configurations
</I>&gt;&gt;<i> and uses. Support just a few simple fool-proof cases. I think this
</I>&gt;&gt;<i> solution is unacceptable for a product like Squid and for a complex area
</I>&gt;&gt;<i> such as SSL bumping.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * Wizard: Provide an intelligent configuration generator/wizard which
</I>&gt;&gt;<i> asks admins some questions and then generates a valid squid.conf snippet
</I>&gt;&gt;<i> while guiding and educating the admin. A wizard may also evaluate a
</I>&gt;&gt;<i> given configuration, with human assistance (a much harder but not
</I>&gt;&gt;<i> impossible task). No Squid changes are necessary.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> * Shim: Provide a set of simple new directives that cover basic bumping
</I>&gt;&gt;<i> needs. Internally, these directives are mapped to the already supported
</I>&gt;&gt;<i> &quot;power-user&quot; configuration. Admins using the new directives will not be
</I>&gt;&gt;<i> allowed to add old/power-user directives into the mix (i.e., the two
</I>&gt;&gt;<i> sets of directives will be mutually exclusive). This is a good approach
</I>&gt;&gt;<i> *if* we can come up with new fool-proof directives that cover many
</I>&gt;&gt;<i> bumping needs well.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Currently, this thread appears to be focused on another alternative:
</I>&gt;&gt;<i> Replacing the current set of directives with a much simpler one while
</I>&gt;&gt;<i> supporting the same functionality. This is an honorable goal, but I do
</I>&gt;&gt;<i> not think you can sneak &quot;detection of most nonsense configurations&quot; into
</I>&gt;&gt;<i> that. If the latter is your goal, see the three items above.
</I>

&gt;<i> IMO your 3-bullet list misses these:
</I>&gt;<i> * improve the syntax/rules since currently it confuses too many admins
</I>&gt;<i> * make the configuration simpler where an admin does not have
</I>&gt;<i>   to know many details of the TLS protocol.
</I>
Please do not forget that the Reduction/Wizard/Shim bullets only apply
to your &quot;detect most or all nonsense configurations&quot; goal. What you are
probably implying above is covered by the &quot;Replacing the current set of
directives with a much simpler one while supporting the same
functionality&quot; paragraph after those bullets.


&gt;<i> The first bullet is why Amos and I tried to improve the
</I>&gt;<i> situation by syntactical changes.
</I>
Not sure what you mean, but if &quot;Reduction&quot; (the first bullet) is your
preferred approach, then we are stuck because I find that approach
unacceptable for obvious (IMO) reasons.


&gt;<i> The last bullet may also be interpreted as: make the config
</I>&gt;<i> rules simple for 95% of all sites and support optional complex rules
</I>&gt;<i> for the rest.
</I>
I would not recommend that way of thinking/phrasing because it may imply
that an average admin will use a _mixture_ of directives from simple and
complex sets. If that is the result, you have accomplished nothing
because the current problems will continue to exist for that average
admin using complex directives (that he should avoid).

For the &quot;Shim&quot; approach to work, the set of simple directives should
satisfy 100% of an average admin needs so that an average admin does not
have to switch to (or, worse, mix in!) directives from the complex set.
A significant barrier should prevent an average admin from considering
using complex rules. The requirement to use complex rules for either
nothing or everything could be such a barrier.


&gt;&gt;&gt;<i> Simple examples like above 'work'.  The question is if it
</I>&gt;&gt;&gt;<i> is possible for Squid to detect most or all nonsense configurations
</I>
&gt;&gt;<i> I know the answer to that question: &quot;No&quot;. Complex actions like bumping
</I>&gt;&gt;<i> traffic require human intelligence. Squid will not be able to detect
</I>&gt;&gt;<i> bugs in advanced human thinking (in the foreseeable future). You cannot
</I>&gt;&gt;<i> make complex bumping both highly configurable and fool-proof. If you
</I>&gt;&gt;<i> want a fool-proof solution, I know of three possible ways:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Reduction: Drastically reduce the number of supported configurations
</I>&gt;&gt;<i> and uses. Support just a few simple fool-proof cases. I think this
</I>&gt;&gt;<i> solution is unacceptable for a product like Squid and for a complex area
</I>&gt;&gt;<i> such as SSL bumping.
</I>
&gt;<i> An alternative for Reduction is a list of good examples (better than
</I>&gt;<i> wiki has).
</I>
You may have missed the context of this Reduction bullet: A list of good
examples does not allow Squid to detect most or all nonsense configurations.


&gt;&gt;<i> * Wizard: Provide an intelligent configuration generator/wizard which
</I>&gt;&gt;<i> asks admins some questions and then generates a valid squid.conf snippet
</I>&gt;&gt;<i> while guiding and educating the admin. A wizard may also evaluate a
</I>&gt;&gt;<i> given configuration, with human assistance (a much harder but not
</I>&gt;&gt;<i> impossible task). No Squid changes are necessary.
</I>
&gt;<i> Would like to see that :-)
</I>
Me too! FWIW, we have developed a somewhat similar configuration wizard
for Web Polygraph, and I am pretty sure it is possible to create one for
SslBump. The standard FAQ applies even though this project may not
require any Squid modifications:
<A HREF="http://wiki.squid-cache.org/SquidFaq/AboutSquid#How_to_add_a_new_Squid_feature.2C_enhance.2C_of_fix_something.3F">http://wiki.squid-cache.org/SquidFaq/AboutSquid#How_to_add_a_new_Squid_feature.2C_enhance.2C_of_fix_something.3F</A>


&gt;&gt;<i> * Shim: Provide a set of simple new directives that cover basic bumping
</I>&gt;&gt;<i> needs. Internally, these directives are mapped to the already supported
</I>&gt;&gt;<i> &quot;power-user&quot; configuration. Admins using the new directives will not be
</I>&gt;&gt;<i> allowed to add old/power-user directives into the mix (i.e., the two
</I>&gt;&gt;<i> sets of directives will be mutually exclusive). This is a good approach
</I>&gt;&gt;<i> *if* we can come up with new fool-proof directives that cover many
</I>&gt;&gt;<i> bumping needs well.
</I>
&gt;<i> Shim is nice, but does not change the current situation for power-users.
</I>
True (but missing the context of these bullets again).


&gt;&gt;<i> Currently, this thread appears to be focused on another alternative:
</I>&gt;&gt;<i> Replacing the current set of directives with a much simpler one while
</I>&gt;&gt;<i> supporting the same functionality. This is an honorable goal, but I do
</I>&gt;&gt;<i> not think you can sneak &quot;detection of most nonsense configurations&quot; into
</I>&gt;&gt;<i> that. If the latter is your goal, see the three items above.
</I>&gt;<i> 
</I>&gt;<i> Going back to your 3 bullets,
</I>
Your questions do not seem to be related to the bullets. I will answer
them in a general context:


&gt;<i> * Can you give an example of more dynamic ACLs?
</I>
For example, we can add a get_client_hello and get_server_hello ACLs
that will trigger a peeking or staring actions as necessary. They will
either always match or will match if the action was successful. The
get_server_hello ACL will need options to distinguish peeking from staring.

  acl got_client_hello get_client_hello
  acl client_goes_to_bank server_name ...

  ssl_bump splice got_client_hello client_goes_to_bank
  ssl_bump bump all

Needless to say, peeking/staring ACLs do not solve the &quot;too late to
splice!&quot; problem. For example, neither of the following examples
magically start to work:

  # XXX: One cannot tunnel after staring at the server:
  acl got_server_hello get_server_hello --stare
  acl server_uses_pinning server_name ...
  ssl_bump tunnel got_server_hello server_uses_pinning # XXX
  ssl_bump bump all

or

  # XXX: One cannot bump after peeking at the server:
  acl got_server_hello get_server_hello --peek
  acl server_uses_pinning server_name ...
  ssl_bump splice got_server_hello server_uses_pinning
  ssl_bump bump all # XXX


&gt;<i>   I am surprised that admins are surprised that Squid does server
</I>&gt;<i>   certificate validation.  Maybe document it better?
</I>
Better documentation would not hurt but I do not know whether it will
help. Please note that it is not just validation that some admins find
surprising, it is bumping that follows unsuccessful validation. For
example, many think that this configuration will never bump, but IIRC,
it may if validation fails:

  ssl_bump peek all
  ssl_bump splice all


&gt;<i> * the issue with price becomes less if splice-a-bumped-connection
</I>&gt;<i>   is implemented
</I>
Yes, but ...

&gt;<i>   and also solves the problem of precluding future decisions.
</I>
It does not fully solve that problem as discussed above (one &quot;continue&quot;
does not work).


&gt;<i> * I suggest to document that Squid bumps a connection to send
</I>&gt;<i>   an error message.  Maybe error handling can be separated from
</I>&gt;<i>   the other ssl bump rules and have a list of acls on how to act
</I>&gt;<i>   (terminate or bump+error) in case there is an error.
</I>
The error handling is separated (took another fight or two IIRC).
However, there is currently no [convenient] way to terminate the
connection on errors. I agree that such a way should be added, but it is
tricky to do that well because Squid already has a similar TCP_RESET
knob tied to deny_info. A good solution would generalize that existing
functionality instead of creating a parallel control structure with
overlapping/conflicting scope.

Alex.

</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007294.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
	<LI>Next message: <A HREF="007286.html">[squid-dev] [RFC] simplifying ssl_bump complexity
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7303">[ date ]</a>
              <a href="thread.html#7303">[ thread ]</a>
              <a href="subject.html#7303">[ subject ]</a>
              <a href="author.html#7303">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
