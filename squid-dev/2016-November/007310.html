<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] auth_schemes directive
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20auth_schemes%20directive&In-Reply-To=%3C0abe1174-5046-3d92-fddb-57a9531b877f%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007309.html">
   <LINK REL="Next"  HREF="007311.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] auth_schemes directive</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20auth_schemes%20directive&In-Reply-To=%3C0abe1174-5046-3d92-fddb-57a9531b877f%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] auth_schemes directive">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Nov 30 01:11:55 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007309.html">[squid-dev] [PATCH] auth_schemes directive
</A></li>
        <LI>Next message: <A HREF="007311.html">[squid-dev] [PATCH] auth_schemes directive
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7310">[ date ]</a>
              <a href="thread.html#7310">[ thread ]</a>
              <a href="subject.html#7310">[ subject ]</a>
              <a href="author.html#7310">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/29/2016 03:50 PM, Amos Jeffries wrote:
&gt;<i> On 28/11/2016 3:34 p.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> Or being able to control the order of schemes presented to the user.
</I>
&gt;<i> Any HTTP client implementation which was coded to be properly compliant
</I>&gt;<i> with RFC 2616 and 2617 *will not* obey any ordering presented by Squid.
</I>&gt;<i> (Yes that was relaxed in RFC723x, but only to &quot;ought to&quot; and most
</I>&gt;<i> clients still obey the older MUST requirement).
</I>
&gt;<i> IE6 was a notable exception that did follow the ordering when Basic was
</I>&gt;<i> first and why that ordering of auth_param was made significant back in
</I>&gt;<i> the early Squid-2.x sometime. It is now almost completely dead/absent as
</I>&gt;<i> a client though.
</I>&gt;<i> 
</I>&gt;<i> The current worst problem is Safari - for exactly the opposite reason.
</I>&gt;<i> It demonstrably ignores the list of schemes and uses only (and forever
</I>&gt;<i> looping) its first choice of &quot;best&quot; scheme. No others are considered nor
</I>&gt;<i> attempted.
</I>&gt;<i> 
</I>&gt;<i> I'm also aware of Firefix NTLM issues and Java, but those are not order
</I>&gt;<i> related. Are there any other client software with scheme ordering issues
</I>&gt;<i> I should be aware of?
</I>
I find it ironic that you need to ask for more issues after listing a
well known issue and indicating that the protocol requirements have been
relaxed. For me, your own response is a good illustration that ordering
control is [at least marginally] useful!


&gt;<i> We *already* have ordering ability in squid.conf. 
</I>
The existing ability is severely limited because it can accommodate at
most one unusual client. It is also rather awkward to configure.


&gt;<i> Many users have tried
</I>&gt;<i> to make use of it. The fact that it is not solving their issues is a
</I>&gt;<i> good demonstration about why/how the above RFC requirement is a killer
</I>&gt;<i> for any attempt to use ordering to control the clients behaviour.
</I>
I am not sure how you reach that conclusion given the available
evidence. Yes, ordering alone cannot solve all the issues, but that does
not mean that properly supporting ACL-driven order is useless.

Said that, better ordering support is just one of several useful
properties of the proposed approach. Even if we are 100% positive that
nobody will ever need to control the order of schemes, the ability to
specify a list of schemes to use is still a nice/useful feature, and
will remain a nice/useful feature even after somebody adds support for
multiple configurations of the same scheme.


&gt;&gt;&gt;<i> To resolve (1) fully we will need to have multiple Config objects with
</I>&gt;&gt;&gt;<i> the same scheme name and different config details.
</I>
&gt;&gt;<i> The proposed changes do not preclude
</I>&gt;&gt;<i> such future support. Moreover, such future support will not address some
</I>&gt;&gt;<i> of the use cases covered by the proposed patch. In other words, what has
</I>&gt;&gt;<i> been implemented and your suggestion are complementary, not mutually
</I>&gt;&gt;<i> exclusive.
</I>
&gt;<i> For the use cases this patch resolves, that is true. 
</I>
IMO, my statement is true for all use cases, both use cases covered by
the patch and use cases not covered by the patch: The two areas are
complementary, not mutually exclusive, regardless of the use cases.


&gt;<i> For the other cases
</I>&gt;<i> my per-scheme ACLs proposal seeks to resolve as well, it is not.
</I>
Which part of my statement is not true for those other cases?


&gt;<i> We could add both ways. But that I expect will just lead to more
</I>&gt;<i> confusion. So lets try to avoid that.
</I>
I agree that supporting two partially overlapping ways to configure used
authentication schemes will cause some confusion in some cases, but I
disagree that it will be the only outcome. The positive outcomes of
supporting both explicit scheme lists and multiple scheme configurations
outweigh the negatives IMO.

However, we can and should also prevent any overlaps in coverage! The
already implemented code can be used to control scheme presence [and
order] while the proposed future code will control which configuration
is used for each used scheme. That divide-and-concur is the right/best
approach here. I should have thought of that earlier, but, fortunately,
this realization does not affect auth_schemes.


&gt;<i> My proposal uses that existing logic instead of adding a second config
</I>&gt;<i> setting that can contradict it and cause confusion.
</I>
If your proposal implementation is limited to scheme configuration
selection (among multiple configurations for the same scheme), then
there will be no contradiction and confusion. Each feature will control
its own area.

* Want to control which schemes are used for transaction X?
  Use the implemented auth_schemes.

* Want to control which scheme configuration is used for used scheme S?
  Use [future feature].


&gt;<i> For the uncommon case of needing different order of the same schemes for
</I>&gt;<i> different clients, multiple auth_param sections with different ACL lists
</I>&gt;<i> can be used. It is a little verbose, yes, but not a common need so as
</I>&gt;<i> you have argued in the past: we should not be optimizing for that type
</I>&gt;<i> of case at expense of the more common ones.
</I>
The implemented auth_schemes optimize a common case AFAICT. The future
scheme configuration selection code can also optimize its common case.
The features do not need to overlap, and each can focus on optimizing
its area.


&gt;&gt;<i> Also, while working on the proposed feature, we have discovered why
</I>&gt;&gt;<i> adding per-scheme ACLs (or a special NONE value to auth_schemes) will
</I>&gt;&gt;<i> create a negative side effect that the posted implementation avoids: The
</I>&gt;&gt;<i> implemented code does not change authentication decision; auth_schemes
</I>&gt;&gt;<i> cannot accidentally create a situation where no schemes exist for a
</I>&gt;&gt;<i> transaction.
</I>
&gt;<i> That is exactly the case in HTTP Authentication where 403 status code is
</I>&gt;<i> supposed to be used. It is explicitly one of the permitted auth states.
</I>
Explicitly forbidding access and wanting to authenticate but implicitly
running out of authentication schemes are very different cases. We
should not duplicate http_access functionality in auth_schemes or the
future scheme configuration selection code IMO. If an admin wants to
forbid access, they should use appropriate tools without worrying that
their complex scheme configuration ACLs may also accidentally select no
usable schemes and stub them in the back.



&gt;&gt;<i>  The
</I>&gt;&gt;<i> &quot;Should I use this configuration for scheme X?&quot; and &quot;What schemes should
</I>&gt;&gt;<i> I use for this transaction?&quot; are two different questions, each deserving
</I>&gt;&gt;<i> an answer in various real-world situations.
</I>
The above is still a good summary of why you should not block
auth_schemes because you want Squid to support multiple scheme
configurations in the future. Prior to this email, I thought that what
you are proposing and what we have implemented can overlap. Now I am
fairly certain that they should not overlap but should complement each
other. In other words, they should be orthogonal questions/answers/features.


&gt;&gt;<i> Please reconsider your initial evaluation.
</I>&gt;<i> 
</I>&gt;<i> I have and still do not want to see this go in as one change.
</I>&gt;<i> 
</I>&gt;<i> I'm happy with the structural/internal part making non-allow/deny
</I>&gt;<i> actions possible anywhere. If that were split from the auth_schemes
</I>&gt;<i> directive part it could go in immediately without another review IMO.
</I>
Sure it can, but the deadlock is not in those code polishing changes. Do
you still block auth_schemes, even if it is committed separately from
those polishing changes? Or does your &quot;as one change&quot; imply that you are
removing your objection to auth_schems as such if it is committed
separately from the polishing changes?


Thank you,

Alex.

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007309.html">[squid-dev] [PATCH] auth_schemes directive
</A></li>
	<LI>Next message: <A HREF="007311.html">[squid-dev] [PATCH] auth_schemes directive
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7310">[ date ]</a>
              <a href="thread.html#7310">[ thread ]</a>
              <a href="subject.html#7310">[ subject ]</a>
              <a href="author.html#7310">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
