<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] Support concurrent SBuf::c_str() calls
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Support%20concurrent%20SBuf%3A%3Ac_str%28%29%20calls&In-Reply-To=%3C73cef7b3-cac9-f405-5c9f-377922ccbbdf%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006914.html">
   <LINK REL="Next"  HREF="006918.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] Support concurrent SBuf::c_str() calls</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Support%20concurrent%20SBuf%3A%3Ac_str%28%29%20calls&In-Reply-To=%3C73cef7b3-cac9-f405-5c9f-377922ccbbdf%40measurement-factory.com%3E"
       TITLE="[squid-dev] [RFC] Support concurrent SBuf::c_str() calls">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Oct  3 00:03:49 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006914.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
        <LI>Next message: <A HREF="006918.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6915">[ date ]</a>
              <a href="thread.html#6915">[ thread ]</a>
              <a href="subject.html#6915">[ subject ]</a>
              <a href="author.html#6915">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/02/2016 03:25 PM, Kinkie wrote:
&gt;<i> On Fri, Sep 30, 2016 at 6:03 PM, Alex Rousskov
</I>&gt;<i> &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;&gt;<i> On 09/29/2016 09:19 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 30/09/2016 5:03 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> Should we remove the increment to make concurrent c_str() calls safe?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The reason it exists remember is to prevent other SBuf sharing that
</I>&gt;&gt;&gt;<i> storage MemBuf from thinking they can append to the storage oer top of
</I>&gt;&gt;&gt;<i> the terminator.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, I know, but that increment not only prevents problems but _causes_
</I>&gt;&gt;<i> them as well: The increment may force the SBuf to realloc, which may
</I>&gt;&gt;<i> result in deallocation of the original storage still pointed to by the
</I>&gt;&gt;<i> earlier c_str() result.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Given that we have no easy knowledge of how the c_str()
</I>&gt;&gt;&gt;<i> is going to be used by the recipient code we cannot guarantee lack of
</I>&gt;&gt;&gt;<i> terminator is safe.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, with or without the increment, Squid may crash or misbehave when
</I>&gt;&gt;<i> buggy code appends to SBuf while a previous c_str() result is still in
</I>&gt;&gt;<i> use. The lack of increment is not safe. The presence of the increment is
</I>&gt;&gt;<i> not safe. The problems are different, but they exist with or without the
</I>&gt;&gt;<i> increment.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Time to push SBuf usage forward and aggressively remove the need for
</I>&gt;&gt;&gt;<i> c_str()?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The need for c_str() will never go away because libraries outside of
</I>&gt;&gt;<i> Squid control need c-strings. And, due to the lack of proper QA, any
</I>&gt;&gt;<i> &quot;aggressive push&quot; affecting lots of Squid code is a recipe for a
</I>&gt;&gt;<i> disaster IMO.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The question is which c_str() implementation is safer? The one that may
</I>&gt;&gt;<i> crash Squid when called twice for the same SBuf in the same expression
</I>&gt;&gt;<i> or the one that may crash Squid when appending to the same SBuf in the
</I>&gt;&gt;<i> same expression? There are already two known cases of the former. There
</I>&gt;&gt;<i> are currently no known cases of the latter.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Overall, I know of three primary ways to implement c_str():
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. Always 0-terminate SBuf-used storage. Safest implementation possible,
</I>&gt;&gt;<i> but has serious negative performance overheads, especially for tokenizing.
</I>&gt;<i> 
</I>&gt;<i> If this is the decision, might as well drop sbuf altogether in favor
</I>&gt;<i> of std::string (or possibly std::string + custom mempools-friendly
</I>&gt;<i> Allocator).
</I>
You are probably right, although std::string may have other funny things
going that we might want to avoid/control.


&gt;&gt;<i> 2. Terminate the used storage at the time of c_str().
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     2a. Increment the used storage size. Current implementation.
</I>&gt;&gt;<i>         Leads to problems discussed in this thread.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     2b. Do not increment the used storage size.
</I>&gt;&gt;<i>         Leads to other problems discussed in this thread.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 3. Allocate and store a new c-string as needed, copying from the
</I>&gt;&gt;<i> storage. Safest implementation possible but has serious negative
</I>&gt;&gt;<i> performance overheads. These overheads affect different use cases than
</I>&gt;&gt;<i> those of #1.
</I>
&gt;<i> If we are aware of the underlying issue, there's no reason not to save
</I>&gt;<i> the temporary to a naked char* and use that, as long as the SBuf is
</I>&gt;<i> not touched it'll work fine.
</I>
Save to a temporary variable outside SBuf? That is not a solution
because we are trying to address the cases where the developer forgot to
do that or could not really tell that doing that is necessary. Anything
from trivial/direct

  foo(buf.c_str(), buf.c_str());

to complex/hidden

  foo(buf, buf.c_str()) which calls bar(buf1.c_str(), cstr2);



&gt;&gt;<i> Needless to say, we can add clever code to reduce risks associated with
</I>&gt;&gt;<i> some implementations. For example (these are just rough sketches/ideas):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> a) Appending code in #2b can check whether it is about to overwrite the
</I>&gt;&gt;<i> 0-terminator added by a previous c_str() call and, if yes, preserve the
</I>&gt;&gt;<i> old storage (we can preserve one such storage or maintain a global FIFO
</I>&gt;&gt;<i> queue).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> b) C-string allocating code in #4 can maintain a global FIFO queue of
</I>&gt;&gt;<i> previously allocated but now supposedly unused c-strings to minimize the
</I>&gt;&gt;<i> risk of de-allocating a still used c-string.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> c) C-string allocating code in #4 can delay allocation until it might be
</I>&gt;&gt;<i> needed, similar to how (a) decides that the 0-terminator is in danger.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Going forward, do you think we should:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> i. Keep using #2a and rewrite the known double-c_str() code.
</I>&gt;&gt;<i> ii. Make double-c_str() code safe (i.e., switch to #2b).
</I>&gt;&gt;<i> iii. Add code to make the existing #2 implementation safer.
</I>&gt;&gt;<i> iiii. Switch to a completely different implementation like #1 or #4.
</I>
&gt;<i> v. push SBuf as suggested by Amos and document this specific corner
</I>&gt;<i> case so to avoid it
</I>
I do not think &quot;push SBuf&quot; is a comparable alternative. &quot;Pushing SBuf&quot;
is not something we can safely do in a reasonable time. It is and
remains a long-term goal, but we need to address the problem &quot;now&quot;. The
offered alternatives can be implemented in a matter of hours or weeks.
&quot;Pushing SBuf&quot; safely will probably take a year and will not eliminate
all c_str() calls anyway so the same problems/alternatives will remain
even after the &quot;push&quot; is over.

And the problematic cases are already documented -- documentation does
not help much when the API itself invites errors like concurrent c_str()
calls. Developers will continue to misuse c_str() and reviewers will
continue to miss those bugs.

Alex.

</PRE>
































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006914.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
	<LI>Next message: <A HREF="006918.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6915">[ date ]</a>
              <a href="thread.html#6915">[ thread ]</a>
              <a href="subject.html#6915">[ subject ]</a>
              <a href="author.html#6915">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
