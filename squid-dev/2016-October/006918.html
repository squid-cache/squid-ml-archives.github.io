<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] Support concurrent SBuf::c_str() calls
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Support%20concurrent%20SBuf%3A%3Ac_str%28%29%20calls&In-Reply-To=%3C9e61afb0-3862-a9f9-3e91-2e24ed72c6be%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006915.html">
   <LINK REL="Next"  HREF="006920.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] Support concurrent SBuf::c_str() calls</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20Support%20concurrent%20SBuf%3A%3Ac_str%28%29%20calls&In-Reply-To=%3C9e61afb0-3862-a9f9-3e91-2e24ed72c6be%40treenet.co.nz%3E"
       TITLE="[squid-dev] [RFC] Support concurrent SBuf::c_str() calls">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Oct  3 05:51:14 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006915.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
        <LI>Next message: <A HREF="006920.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6918">[ date ]</a>
              <a href="thread.html#6918">[ thread ]</a>
              <a href="subject.html#6918">[ subject ]</a>
              <a href="author.html#6918">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 3/10/2016 1:03 p.m., Alex Rousskov wrote:
&gt;<i> On 10/02/2016 03:25 PM, Kinkie wrote:
</I>&gt;&gt;<i> On Fri, Sep 30, 2016 at 6:03 PM, Alex Rousskov
</I>&gt;&gt;<i> &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> On 09/29/2016 09:19 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;&gt;<i> On 30/09/2016 5:03 a.m., Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> Should we remove the increment to make concurrent c_str() calls safe?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The reason it exists remember is to prevent other SBuf sharing that
</I>&gt;&gt;&gt;&gt;<i> storage MemBuf from thinking they can append to the storage oer top of
</I>&gt;&gt;&gt;&gt;<i> the terminator.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yes, I know, but that increment not only prevents problems but _causes_
</I>&gt;&gt;&gt;<i> them as well: The increment may force the SBuf to realloc, which may
</I>&gt;&gt;&gt;<i> result in deallocation of the original storage still pointed to by the
</I>&gt;&gt;&gt;<i> earlier c_str() result.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Given that we have no easy knowledge of how the c_str()
</I>&gt;&gt;&gt;&gt;<i> is going to be used by the recipient code we cannot guarantee lack of
</I>&gt;&gt;&gt;&gt;<i> terminator is safe.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yes, with or without the increment, Squid may crash or misbehave when
</I>&gt;&gt;&gt;<i> buggy code appends to SBuf while a previous c_str() result is still in
</I>&gt;&gt;&gt;<i> use. The lack of increment is not safe. The presence of the increment is
</I>&gt;&gt;&gt;<i> not safe. The problems are different, but they exist with or without the
</I>&gt;&gt;&gt;<i> increment.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Time to push SBuf usage forward and aggressively remove the need for
</I>&gt;&gt;&gt;&gt;<i> c_str()?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The need for c_str() will never go away because libraries outside of
</I>&gt;&gt;&gt;<i> Squid control need c-strings. And, due to the lack of proper QA, any
</I>&gt;&gt;&gt;<i> &quot;aggressive push&quot; affecting lots of Squid code is a recipe for a
</I>&gt;&gt;&gt;<i> disaster IMO.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The question is which c_str() implementation is safer? The one that may
</I>&gt;&gt;&gt;<i> crash Squid when called twice for the same SBuf in the same expression
</I>&gt;&gt;&gt;<i> or the one that may crash Squid when appending to the same SBuf in the
</I>&gt;&gt;&gt;<i> same expression? There are already two known cases of the former. There
</I>&gt;&gt;&gt;<i> are currently no known cases of the latter.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Overall, I know of three primary ways to implement c_str():
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1. Always 0-terminate SBuf-used storage. Safest implementation possible,
</I>&gt;&gt;&gt;<i> but has serious negative performance overheads, especially for tokenizing.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If this is the decision, might as well drop sbuf altogether in favor
</I>&gt;&gt;<i> of std::string (or possibly std::string + custom mempools-friendly
</I>&gt;&gt;<i> Allocator).
</I>&gt;<i> 
</I>&gt;<i> You are probably right, although std::string may have other funny things
</I>&gt;<i> going that we might want to avoid/control.
</I>
Yes. SBuf is pointless without the 0-copy property which is its primary
use-case.

If every use of c_str() is going to cow() and write a terminator, then
the performance takes a huge hit until such time as we have rolled SBuf
out widely. If you want to improve performance, we have to make a call
on dropping the 0-copy goal or pushing forward with it ASAP.

The argument that library APIs etc need c_str() is bogus. We can
implement a different safer c-string conversion or for the nicer
libraries (like most of libc or STL) pass them unterminated (char*,
size) tuplets.

&gt;<i> 
</I>&gt;&gt;&gt;<i> 2. Terminate the used storage at the time of c_str().
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     2a. Increment the used storage size. Current implementation.
</I>&gt;&gt;&gt;<i>         Leads to problems discussed in this thread.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     2b. Do not increment the used storage size.
</I>&gt;&gt;&gt;<i>         Leads to other problems discussed in this thread.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 3. Allocate and store a new c-string as needed, copying from the
</I>&gt;&gt;&gt;<i> storage. Safest implementation possible but has serious negative
</I>&gt;&gt;&gt;<i> performance overheads. These overheads affect different use cases than
</I>&gt;&gt;&gt;<i> those of #1.
</I>&gt;<i> 
</I>&gt;&gt;<i> If we are aware of the underlying issue, there's no reason not to save
</I>&gt;&gt;<i> the temporary to a naked char* and use that, as long as the SBuf is
</I>&gt;&gt;<i> not touched it'll work fine.
</I>&gt;<i> 
</I>&gt;<i> Save to a temporary variable outside SBuf? That is not a solution
</I>&gt;<i> because we are trying to address the cases where the developer forgot to
</I>&gt;<i> do that or could not really tell that doing that is necessary. Anything
</I>&gt;<i> from trivial/direct
</I>&gt;<i> 
</I>&gt;<i>   foo(buf.c_str(), buf.c_str());
</I>&gt;<i> 
</I>&gt;<i> to complex/hidden
</I>&gt;<i> 
</I>&gt;<i>   foo(buf, buf.c_str()) which calls bar(buf1.c_str(), cstr2);
</I>&gt;<i> 
</I>
Thats not what comes to mind for me with kinkies description.

I imagined a cached const char* pointer inside SBuf that c_str()
produces if it is unset. The cow() operations freeing that cached pointer.

Anyhow, see new option (vi) proposal at the end.


&gt;<i> 
</I>&gt;&gt;&gt;<i> Needless to say, we can add clever code to reduce risks associated with
</I>&gt;&gt;&gt;<i> some implementations. For example (these are just rough sketches/ideas):
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> a) Appending code in #2b can check whether it is about to overwrite the
</I>&gt;&gt;&gt;<i> 0-terminator added by a previous c_str() call and, if yes, preserve the
</I>&gt;&gt;&gt;<i> old storage (we can preserve one such storage or maintain a global FIFO
</I>&gt;&gt;&gt;<i> queue).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> b) C-string allocating code in #4 can maintain a global FIFO queue of
</I>&gt;&gt;&gt;<i> previously allocated but now supposedly unused c-strings to minimize the
</I>&gt;&gt;&gt;<i> risk of de-allocating a still used c-string.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> c) C-string allocating code in #4 can delay allocation until it might be
</I>&gt;&gt;&gt;<i> needed, similar to how (a) decides that the 0-terminator is in danger.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Going forward, do you think we should:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> i. Keep using #2a and rewrite the known double-c_str() code.
</I>
That is two options. I think we should fix the double-c_str() code
regardless of any other changes. These are definitely performance bugs
with the 2nd call triggeringd reallocate regardless of other bad side
effects.


&gt;&gt;&gt;<i> ii. Make double-c_str() code safe (i.e., switch to #2b).
</I>&gt;&gt;&gt;<i> iii. Add code to make the existing #2 implementation safer.
</I>&gt;&gt;&gt;<i> iiii. Switch to a completely different implementation like #1 or #4.
</I>&gt;<i> 
</I>&gt;&gt;<i> v. push SBuf as suggested by Amos and document this specific corner
</I>&gt;&gt;<i> case so to avoid it
</I>&gt;<i> 
</I>&gt;<i> I do not think &quot;push SBuf&quot; is a comparable alternative. &quot;Pushing SBuf&quot;
</I>&gt;<i> is not something we can safely do in a reasonable time. It is and
</I>&gt;<i> remains a long-term goal, but we need to address the problem &quot;now&quot;. The
</I>&gt;<i> offered alternatives can be implemented in a matter of hours or weeks.
</I>&gt;<i> &quot;Pushing SBuf&quot; safely will probably take a year and will not eliminate
</I>&gt;<i> all c_str() calls anyway so the same problems/alternatives will remain
</I>&gt;<i> even after the &quot;push&quot; is over.
</I>

There are very few things we can do will resolve this in such a short
timeframe. That is a natural result of the code being so large and
complex. Any choice we make to alter the design will take a long time to
check every single code path works okay.


Another option is:

vi. drop c_str() completely and use SBufToCstring() or SBufToString() as
ways to obtain char*.

Adjusting callers as necessary for those not to leak memory or be too
bad for performance will be easier than a full code audit.

Just looking at it there are 56 callers documented by doxygen in the
layer-02-maximus build for 4.x. I'd estimate perhapse a dozen that are not.

Amos

</PRE>































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006915.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
	<LI>Next message: <A HREF="006920.html">[squid-dev] [RFC] Support concurrent SBuf::c_str() calls
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6918">[ date ]</a>
              <a href="thread.html#6918">[ thread ]</a>
              <a href="subject.html#6918">[ subject ]</a>
              <a href="author.html#6918">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
