<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] dns_wait_for_all
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20dns_wait_for_all&In-Reply-To=%3Caf13cd8c-adb9-89ad-04ca-50688879ed85%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006831.html">
   <LINK REL="Next"  HREF="006833.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] dns_wait_for_all</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20dns_wait_for_all&In-Reply-To=%3Caf13cd8c-adb9-89ad-04ca-50688879ed85%40treenet.co.nz%3E"
       TITLE="[squid-dev] [RFC] dns_wait_for_all">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Sep 15 01:25:22 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006831.html">[squid-dev] [RFC] dns_wait_for_all
</A></li>
        <LI>Next message: <A HREF="006833.html">[squid-dev] [RFC] dns_wait_for_all
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6832">[ date ]</a>
              <a href="thread.html#6832">[ thread ]</a>
              <a href="subject.html#6832">[ subject ]</a>
              <a href="author.html#6832">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 15/09/2016 8:15 a.m., Alex Rousskov wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i>     Currently, when connecting to an origin server, Squid sends
</I>&gt;<i> concurrent DNS A and AAAA queries and waits for both answers before
</I>&gt;<i> proceeding with the HTTP transaction. If the authoritative DNS server
</I>&gt;<i> (or something on its path) breaks or significantly delays IPv6 (AAAA)
</I>&gt;<i> transactions, then Squid waits until timeout, even if Squid already has
</I>&gt;<i> a usable IPv4 address from a successful A query. This naturally leads to
</I>&gt;<i> admins disabling IPv6, willingly or under external pressure.
</I>&gt;<i> 
</I>&gt;<i> As Happy Eyeballs algorithms and related discussions/measurements have
</I>&gt;<i> established, the best migration path to IPv6 requires making sure that
</I>&gt;<i> enabling IPv6 does not create [user-visible] problems. Once that is
</I>&gt;<i> accomplished, software can and should prefer IPv6 over IPv4 by default.
</I>&gt;<i> I hope that we do not need to revisit those discussions to accept that
</I>&gt;<i> principle.
</I>&gt;<i> 
</I>&gt;<i> Currently, Squid violates that principle -- enabling IPv6 leads to
</I>&gt;<i> user-visible problems, and those problems lead to IPv6 being disabled.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This will not fix all IPv6 problems, but I propose to modify Squid so
</I>&gt;<i> that it starts connecting after receiving the first usable DNS response:
</I>&gt;<i> 
</I>&gt;&gt;<i> dns_wait_for_all &lt;on|off&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Determines whether Squid resolves domain names of all possible
</I>&gt;&gt;<i> destinations in all supported address families before deciding which
</I>&gt;&gt;<i> IP address to try first when contacting an origin server or cache_peer.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Before Squid can connect to a peer, it needs an IP address. Obtaining an
</I>&gt;&gt;<i> IP address often requires a DNS lookup. Squid often makes two concurrent
</I>&gt;&gt;<i> DNS lookups: An &quot;A&quot; query for an IPv4 address and an &quot;AAAA&quot; query for an
</I>&gt;&gt;<i> IPv6 address. This directive does not affect the number of DNS queries
</I>&gt;&gt;<i> sent or the side-effects of those queries (e.g., IP cache updates), but
</I>&gt;&gt;<i> if two concurrent lookups are initiated, and this directive is off, then
</I>&gt;&gt;<i> Squid proceeds immediately after receiving the first usable DNS answer.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This directive does not affect forwarding retries. For example, if
</I>&gt;&gt;<i> dns_wait_for_all is off, and Squid gets an IPv4 address first, but the
</I>&gt;&gt;<i> TCP connection to that IPv4 address fails, Squid will wait for the IPv6
</I>&gt;&gt;<i> address resolution to complete (if it has not yet) and will then connect
</I>&gt;&gt;<i> to an IPv6 address (if possible).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Furthermore, this directive does not affect the number of peer domain
</I>&gt;&gt;<i> names that Squid will attempt to resolve or peer addresses that Squid
</I>&gt;&gt;<i> may connect to. If Squid is allowed to forward a transaction to two
</I>&gt;&gt;<i> peers, then Squid will resolve both peer names and, if failures make it
</I>&gt;&gt;<i> necessary, will connect to all IP addresses of both peers (subject to
</I>&gt;&gt;<i> other restrictions such as connect_retries).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> See also: dns_v4_first
</I>&gt;<i> 
</I>&gt;<i> I suggest to enable this option by default because it will help with
</I>&gt;<i> IPv6 adoption, but I certainly do not insist on that default.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> While we call both queries &quot;concurrent&quot;, Squid sends the AAAA query just
</I>&gt;<i> before sending the A query. All other factors being equal, IPv6 will
</I>&gt;<i> usually win the DNS race. However, even if AAAA loses, Squid will use
</I>&gt;<i> IPv6 the next time it needs to connect to the same server.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> From development point of view, support this feature properly means
</I>&gt;<i> creating an AsyncJob that will initiate DNS queries and update the
</I>&gt;<i> destinations list as the answers come in while informing the caller (if
</I>&gt;<i> it is still alive) of any new answers. Today, FwdState does
</I>&gt;<i> approximately this:
</I>&gt;<i> 
</I>&gt;<i>   1. Call peerSelect(&amp;serverDestinations, fwdPeerSelectionComplete)
</I>&gt;<i>      and wait for the fwdPeerSelectionComplete callback.
</I>&gt;<i> 
</I>&gt;<i>   2. When fwdPeerSelectionComplete is called,
</I>&gt;<i>      start iterating over pre-filled serverDestinations.
</I>&gt;<i> 
</I>&gt;<i> To support, dns_wait_for_all, FwdState will do _approximately_ this:
</I>&gt;<i> 
</I>&gt;<i>   1. Call peerSelect(serverDestinations, fwdPeerSelected)
</I>&gt;<i>      and wait for the first fwdPeerSelected subscription callback.
</I>&gt;<i> 
</I>&gt;<i>   2. Every time fwdPeerSelected is called,
</I>&gt;<i>      start or resume iterating still-unused serverDestinations
</I>&gt;<i>      if we were actually waiting for the next destination to try.
</I>&gt;<i> 
</I>&gt;<i> The DNS code dealing with concurrent A and AAAA queries will need to be
</I>&gt;<i> adjusted to report the first answer while waiting for the second one.
</I>&gt;<i> 
</I>&gt;<i> It is questionable whether the new AsyncJob should continue running
</I>&gt;<i> (i.e., resolving more peer names) after FwdState is gone (or no more
</I>&gt;<i> retries are needed). However, I do not want to complicate this
</I>&gt;<i> discussion by introducing that side effect. We can decide to optimize
</I>&gt;<i> that later, with or without another configuration option to control the
</I>&gt;<i> behavior.
</I>&gt;<i> 
</I>&gt;<i> Once this new infrastructure is in place, we can accommodate IPv6
</I>&gt;<i> further by experimenting with limited semi-concurrent TCP connections
</I>&gt;<i> and other Happy Eyeballs-inspired tricks (with proxy specifics in mind).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Any better ideas or objections to adding dns_wait_for_all?
</I>&gt;<i> 
</I>
In principle okay. However, I was intending to redesign the object we
store DNS RR results in to achieve this is a more useful way. Such that
instead of returning an array of IP addresses it returned an object
storing the Query label, then a chain of RR objects for that label.

That would give several other useful benefits beyond that speedup:

* slow DNS responses could add to the chain while earlier results are
still in Async queue pending delivery to a caller.
 - this would obsolete the need for dns_wait_for_all to be configurable.
Always respond on first result and append data if it comes in early enough.

* ip/fqdn caches can store older data up to some timeout in TTL / LRU
sequence.
 - resolving many DNS rotation issues, including certain type of Host
verify failures.
 - merging the IP and FQDN caches ??

* extensibility of RR type the DNS could lookup and present the callers.
 - needed by DANE and SRV lookups.

* one less memcpy cycle per IP address returned by DNS.
 - paid for by more chain dereferencing overheads.

Amos

</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006831.html">[squid-dev] [RFC] dns_wait_for_all
</A></li>
	<LI>Next message: <A HREF="006833.html">[squid-dev] [RFC] dns_wait_for_all
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6832">[ date ]</a>
              <a href="thread.html#6832">[ thread ]</a>
              <a href="subject.html#6832">[ subject ]</a>
              <a href="author.html#6832">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
