<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] OSX transparent-proxy using pfctl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3Cb6541d96-b8fd-fe32-2305-a61b506633d8%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006883.html">
   <LINK REL="Next"  HREF="006886.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] OSX transparent-proxy using pfctl</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3Cb6541d96-b8fd-fe32-2305-a61b506633d8%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] OSX transparent-proxy using pfctl">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Sep 26 20:07:17 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006883.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
        <LI>Next message: <A HREF="006886.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6884">[ date ]</a>
              <a href="thread.html#6884">[ thread ]</a>
              <a href="subject.html#6884">[ subject ]</a>
              <a href="author.html#6884">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/26/2016 12:59 PM, Shively, Gregory wrote:

&gt;<i> The patch calls /sbin/pfctl to get the
</I>&gt;<i> redirect state information
</I>
For every intercepted connection, this patch forks Squid to start a
shell (which then starts pfctl and awk) and then blocks Squid on that
shell output, right? That feels very expensive performance-wise. I
wonder whether Squid should emit a corresponding one-time warning, to
minimize the number of folks who are going to assume that this works
well under load and then complain that their Squid is &quot;slow&quot;.

The awk part can be eliminated by parsing in Squid, but I am not sure
that optimization is worth it when there is so much overhead in this
code besides awk.


&gt;<i> Let me know if I should continue down the road on getting test-builds.sh
</I>&gt;<i> running on OSX.
</I>
IMO, you should not be responsible for fixing any old test-builds.sh
bugs, only for the problems your changes add or cause.


&gt;<i> +    char *cmd = (char *)malloc(sizeof(char) * cmdLen);
</I>&gt;<i> +    snprintf(cmd, cmdLen, cmdFormat, daddr, saddr, established);
</I>
Please rewrite using SBuf. AFAICT, what you want can be written without
all those unsafe C things like malloc() and snprintf() -- you are simply
concatenating a few strings to form a command.


&gt;<i> +        execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, &quot;-c&quot;, cmd, NULL);
</I>
Please propagate or otherwise handle execl() errors.


&gt;<i> +    FILE *fp = fdopen(pipefd[0], &quot;r&quot;);
</I>&gt;<i> +    while (!feof(fp)) {
</I>
Please handle fdopen() errors instead of ignoring them and feeding a nil
pointer to feof().


&gt;<i> +    FILE *fp = fdopen(pipefd[0], &quot;r&quot;);
</I>...
&gt;<i> +            close(pipefd[0]);
</I>&gt;<i> +            return true;
</I>...
&gt;<i> +    close(pipefd[0]);
</I>&gt;<i> +    return false;
</I>
Leaking &quot;fp&quot;? AFAICT, you are supposed to close &quot;fp&quot; instead of
pipefd[0] after fdopen() but I am not sure.


&gt;<i> +                debugs(89, DBG_IMPORTANT, HERE &lt;&lt; &quot;PFCTL failed to find state&quot;);
</I>&gt;<i> +                return false;
</I>
Leaking both &quot;fp&quot; and pipefd[0]?


&gt;<i> +    char rdaddr[MAX_IPSTRLEN + 6];
</I>
AFAICT, the input line may have more characters than that because &quot;:&quot;,
&quot;\n&quot;, and &quot;\0&quot; all consume space (I assume 6 is for the &quot;:port&quot;).

Also, this declaration is not needed outside the while loop.


&gt;<i> +            char *portPtr = strchr(rdaddr, '\n');
</I>&gt;<i> +            if (portPtr) *portPtr = '\0';
</I>
Should not we reject truncated lines (without '\n') instead of hoping
that the port number or the address itself was not truncated?


&gt;<i> +        if (errno == EINTR || errno == EAGAIN) {
</I>&gt;<i> +            continue;
</I>&gt;<i> +        }
</I>
This code has no effect AFAICT -- the loop will continue with or without
that if statement. Did you mean to break the loop on all other errors
instead?


I recommend removing &quot;fp&quot; and reading from pipefd[0] directly instead.
You can use Tokenizer to safely parse what you read without these
error-prone C tricks.

&gt;<i> +		CPPFLAGS=\&quot;-D_SQUID_APPLE -Wno-error=deprecated-declarations\&quot; LDFLAGS=-lresolv \
</I>...
&gt;<i> -DISTCHECK_CONFIGURE_FLAGS=&quot;&quot;
</I>&gt;<i> +DISTCHECK_CONFIGURE_FLAGS=&quot;CPPFLAGS=\&quot;-D_SQUID_APPLE -Wno-error=deprecated-declarations\&quot; LDFLAGS=-lresolv&quot;
</I>
These temporary for-testing changes should not be a part of the patch.


HTH,

Alex.

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006883.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
	<LI>Next message: <A HREF="006886.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6884">[ date ]</a>
              <a href="thread.html#6884">[ thread ]</a>
              <a href="subject.html#6884">[ subject ]</a>
              <a href="author.html#6884">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
