<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] OSX transparent-proxy using pfctl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3Cda513caa-2973-3c23-700d-7942867fc7bc%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006886.html">
   <LINK REL="Next"  HREF="006889.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] OSX transparent-proxy using pfctl</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3Cda513caa-2973-3c23-700d-7942867fc7bc%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] OSX transparent-proxy using pfctl">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Sep 28 22:04:48 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006886.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
        <LI>Next message: <A HREF="006889.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6887">[ date ]</a>
              <a href="thread.html#6887">[ thread ]</a>
              <a href="subject.html#6887">[ subject ]</a>
              <a href="author.html#6887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/28/2016 12:18 PM, Shively, Gregory wrote:
&gt;<i> The one-time warning sounds like a good idea. Is there a place that
</I>&gt;<i> you have to add the one-time message, or should I just add a static variable 
</I>&gt;<i> to determine if the warning has been displayed the first time down this code
</I>&gt;<i> path?
</I>
If nobody recommends a better place, then place the warning in your
code. &quot;bzr grep WARNING src&quot; for examples.


&gt;&gt;<i> IMO, you should not be responsible for fixing any old test-builds.sh bugs,
</I>&gt;&gt;<i> only for the problems your changes add or cause.
</I>
&gt;<i> Thanks - I was mistaken and thought from the merge document you sent that
</I>&gt;<i> I should have run the test-builds.sh. 
</I>
I did not send a merge document. You should run the test-builds.sh. I do
not know whether running test-builds.sh will expose any bugs you are
responsible for. If running test-builds.sh does not expose any bugs you
are responsible for [because of all the other bugs that you are not
responsible for], then simply say so.


&gt;&gt;&gt;<i> +    char *cmd = (char *)malloc(sizeof(char) * cmdLen);
</I>&gt;&gt;&gt;<i> +    snprintf(cmd, cmdLen, cmdFormat, daddr, saddr, established);
</I>
&gt;&gt;<i> Please rewrite using SBuf. AFAICT, what you want can be written without all
</I>&gt;&gt;<i> those unsafe C things like malloc() and snprintf() -- you are simply
</I>&gt;&gt;<i> concatenating a few strings to form a command.
</I>
&gt;<i> Does just using the appendf() method sound alright? 
</I>
Sounds bad to me. Just use SBuf::append() to concatenate strings and
characters instead of turning off many C++ protections by using printf()
or equivalent.


&gt;<i> And am I
</I>&gt;<i> correct that the method with throw an exception that should just rollup the stack?
</I>
Yes, SBuf methods should throw on overflows and similar non-logic
errors. Whether your code can handle those exceptions correctly, I have
not checked.


&gt;&gt;&gt;<i> +    FILE *fp = fdopen(pipefd[0], &quot;r&quot;);
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +            close(pipefd[0]);
</I>&gt;&gt;&gt;<i> +            return true;
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +    close(pipefd[0]);
</I>&gt;&gt;&gt;<i> +    return false;
</I>
&gt;&gt;<i> Leaking &quot;fp&quot;? AFAICT, you are supposed to close &quot;fp&quot; instead of pipefd[0]
</I>&gt;&gt;<i> after fdopen() but I am not sure.
</I>

&gt;&gt;&gt;<i> +                debugs(89, DBG_IMPORTANT, HERE &lt;&lt; &quot;PFCTL failed to find state&quot;);
</I>&gt;&gt;&gt;<i> +                return false;
</I>
&gt;&gt;<i> Leaking both &quot;fp&quot; and pipefd[0]?
</I>

&gt;<i> If my memory serves, I think the FILE * returned from fdopen() is just a pointer to the 
</I>&gt;<i> same datastructure in the kernel that fd would be associated to.
</I>
It is not just a pointer -- there would be no reason to add all those
f*() functions if it were! FILE is a libc object with buffers. It also
includes a pointer to the kernel structures, of course.


&gt;<i> I'll go ahead and change it to a fclose()
</I>
Yes, that is the right solution if you insist on using FILE.


&gt;&gt;<i> I recommend removing &quot;fp&quot; and reading from pipefd[0] directly instead.
</I>&gt;&gt;<i> You can use Tokenizer to safely parse what you read without these error-
</I>&gt;&gt;<i> prone C tricks.
</I>

&gt;<i> The reason that I used fgets() instead of read() on the pipefd[0] is that I'm 
</I>&gt;<i> reading either the  length of rdaddr or until I read a newline, which ever 
</I>&gt;<i> comes first.
</I>
My recommendation was given with the above assumption in mind.


&gt;<i> If I used read(), if the length of the line was less than rdaddr len
</I>&gt;<i> (and there was more than one line), it could read the beginning of the next
</I>&gt;<i> Line. 
</I>
Yes, but it is not a problem if you parse correctly. Currently, you are
combining partial parsing with partial reading. Splitting them often
avoids nasty bugs that result from such combination.


&gt;<i> I could use Tokenizer or it looks like Just SBuf
</I>
You should use Tokenizer instead of manually parsing what looks like
trivial syntax. Parsing problems in the first patch version imply that
it is not as trivial as it may seem (or, to be more precise, parsing
trivial syntax by hand is still error-prone!).


&gt;<i> if I was to use just read(), I'd have to read a character at a time from the fd
</I>
Why not read, say, 4096 characters at a time?


&gt;<i> .... or if you want me to throw the input stream into a SBuf or
</I>&gt;<i> Tokenizer instead of just using some C calls.
</I>
I do, but I cannot insist on that. You can stop polishing the patch as
soon as it has no known bugs. Others will decide whether to accept it.


Please note that you have not shared updated changes AFAICT. The
squid-3.5.20-osx-devpf-transparent.patch you attached looked old to me.


Thank you,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006886.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
	<LI>Next message: <A HREF="006889.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6887">[ date ]</a>
              <a href="thread.html#6887">[ thread ]</a>
              <a href="subject.html#6887">[ subject ]</a>
              <a href="author.html#6887">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
