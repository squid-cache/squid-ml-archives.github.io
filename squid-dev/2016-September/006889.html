<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] OSX transparent-proxy using pfctl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3CF25802A5228F1345B9BD8093E210C3B90258350E38%40EXWCMS01.fanniemae.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006887.html">
   <LINK REL="Next"  HREF="006890.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] OSX transparent-proxy using pfctl</H1>
    <B>Shively, Gregory</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3CF25802A5228F1345B9BD8093E210C3B90258350E38%40EXWCMS01.fanniemae.com%3E"
       TITLE="[squid-dev] [PATCH] OSX transparent-proxy using pfctl">gregory_shively at fanniemae.com
       </A><BR>
    <I>Thu Sep 29 19:12:29 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006887.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
        <LI>Next message: <A HREF="006890.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6889">[ date ]</a>
              <a href="thread.html#6889">[ thread ]</a>
              <a href="subject.html#6889">[ subject ]</a>
              <a href="author.html#6889">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Alex Rousskov [mailto:<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>]
</I>&gt;<i> Sent: Wednesday, September 28, 2016 6:05 PM
</I>&gt;<i> To: <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> Cc: Shively, Gregory &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">gregory_shively at fanniemae.com</A>&gt;
</I>&gt;<i> Subject: [EXTERNAL] Re: [squid-dev] [PATCH] OSX transparent-proxy using
</I>&gt;<i> pfctl
</I>&gt;<i> 
</I>&gt;<i> On 09/28/2016 12:18 PM, Shively, Gregory wrote:
</I>&gt;<i> &gt; The one-time warning sounds like a good idea. Is there a place that
</I>&gt;<i> &gt; you have to add the one-time message, or should I just add a static
</I>&gt;<i> &gt; variable to determine if the warning has been displayed the first time
</I>&gt;<i> &gt; down this code path?
</I>&gt;<i> 
</I>&gt;<i> If nobody recommends a better place, then place the warning in your code.
</I>&gt;<i> &quot;bzr grep WARNING src&quot; for examples.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
Will put it into the code for now.

&gt;<i> &gt;&gt; IMO, you should not be responsible for fixing any old test-builds.sh
</I>&gt;<i> &gt;&gt; bugs, only for the problems your changes add or cause.
</I>&gt;<i> 
</I>&gt;<i> &gt; Thanks - I was mistaken and thought from the merge document you sent
</I>&gt;<i> &gt; that I should have run the test-builds.sh.
</I>&gt;<i> 
</I>&gt;<i> I did not send a merge document. You should run the test-builds.sh. I do not
</I>&gt;<i> know whether running test-builds.sh will expose any bugs you are
</I>&gt;<i> responsible for. If running test-builds.sh does not expose any bugs you are
</I>&gt;<i> responsible for [because of all the other bugs that you are not responsible
</I>&gt;<i> for], then simply say so.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
Sorry - I think it was Amos instead. Sometimes these mailing lists make me think like I'm talking to one person :-). But that is the problem that I'm having - I can't even run the test suite on a OSX machine prior to making any changed. Running the test suite ends in the btlayer-00-default with an error that stops the build during dist-clean due to:

ERROR: files left in build directory after distclean:
./src/cf_gen.dSYM/Contents/Info.plist
./src/cf_gen.dSYM/Contents/Resources/DWARF/cf_gen

Based on the names, my guess is that the Xcode compiler is generating some artifacts that dist-clean isn't expecting. I did find that I can run with the &quot;--keep-going&quot; flag, but that ends with a the equivalent error in btlayer-05-no-deps-esi. Do I run it this way and just grep the logs for FAIL or something?


&gt;<i> &gt;&gt;&gt; +    char *cmd = (char *)malloc(sizeof(char) * cmdLen);
</I>&gt;<i> &gt;&gt;&gt; +    snprintf(cmd, cmdLen, cmdFormat, daddr, saddr, established);
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt; Please rewrite using SBuf. AFAICT, what you want can be written
</I>&gt;<i> &gt;&gt; without all those unsafe C things like malloc() and snprintf() -- you
</I>&gt;<i> &gt;&gt; are simply concatenating a few strings to form a command.
</I>&gt;<i> 
</I>&gt;<i> &gt; Does just using the appendf() method sound alright?
</I>&gt;<i> 
</I>&gt;<i> Sounds bad to me. Just use SBuf::append() to concatenate strings and
</I>&gt;<i> characters instead of turning off many C++ protections by using printf() or
</I>&gt;<i> equivalent.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
Understood - I will use SBuf::append, for some reason I was thinking that I had the port as a numeric - does seem better to use append.

&gt;<i> &gt; And am I
</I>&gt;<i> &gt; correct that the method with throw an exception that should just rollup the
</I>&gt;<i> stack?
</I>&gt;<i> 
</I>&gt;<i> Yes, SBuf methods should throw on overflows and similar non-logic errors.
</I>&gt;<i> Whether your code can handle those exceptions correctly, I have not
</I>&gt;<i> checked.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
I wasn't sure if I should handle it or let it flow up, since if it was in an overflow state I would doubt I could handle this packet, but maybe the next connection would be successful.

&gt;<i> &gt;&gt;&gt; +    FILE *fp = fdopen(pipefd[0], &quot;r&quot;);
</I>&gt;<i> &gt;&gt; ...
</I>&gt;<i> &gt;&gt;&gt; +            close(pipefd[0]);
</I>&gt;<i> &gt;&gt;&gt; +            return true;
</I>&gt;<i> &gt;&gt; ...
</I>&gt;<i> &gt;&gt;&gt; +    close(pipefd[0]);
</I>&gt;<i> &gt;&gt;&gt; +    return false;
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt; Leaking &quot;fp&quot;? AFAICT, you are supposed to close &quot;fp&quot; instead of
</I>&gt;<i> &gt;&gt; pipefd[0] after fdopen() but I am not sure.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt;&gt; +                debugs(89, DBG_IMPORTANT, HERE &lt;&lt; &quot;PFCTL failed to find
</I>&gt;<i> state&quot;);
</I>&gt;<i> &gt;&gt;&gt; +                return false;
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt; Leaking both &quot;fp&quot; and pipefd[0]?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; If my memory serves, I think the FILE * returned from fdopen() is just
</I>&gt;<i> &gt; a pointer to the same datastructure in the kernel that fd would be
</I>&gt;<i> associated to.
</I>&gt;<i> 
</I>&gt;<i> It is not just a pointer -- there would be no reason to add all those
</I>&gt;<i> f*() functions if it were! FILE is a libc object with buffers. It also includes a
</I>&gt;<i> pointer to the kernel structures, of course.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; I'll go ahead and change it to a fclose()
</I>&gt;<i> 
</I>&gt;<i> Yes, that is the right solution if you insist on using FILE.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt; I recommend removing &quot;fp&quot; and reading from pipefd[0] directly instead.
</I>&gt;<i> &gt;&gt; You can use Tokenizer to safely parse what you read without these
</I>&gt;<i> &gt;&gt; error- prone C tricks.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; The reason that I used fgets() instead of read() on the pipefd[0] is
</I>&gt;<i> &gt; that I'm reading either the  length of rdaddr or until I read a
</I>&gt;<i> &gt; newline, which ever comes first.
</I>&gt;<i> 
</I>&gt;<i> My recommendation was given with the above assumption in mind.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; If I used read(), if the length of the line was less than rdaddr len
</I>&gt;<i> &gt; (and there was more than one line), it could read the beginning of the
</I>&gt;<i> &gt; next Line.
</I>&gt;<i> 
</I>&gt;<i> Yes, but it is not a problem if you parse correctly. Currently, you are
</I>&gt;<i> combining partial parsing with partial reading. Splitting them often avoids
</I>&gt;<i> nasty bugs that result from such combination.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; I could use Tokenizer or it looks like Just SBuf
</I>&gt;<i> 
</I>&gt;<i> You should use Tokenizer instead of manually parsing what looks like trivial
</I>&gt;<i> syntax. Parsing problems in the first patch version imply that it is not as trivial
</I>&gt;<i> as it may seem (or, to be more precise, parsing trivial syntax by hand is still
</I>&gt;<i> error-prone!).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; if I was to use just read(), I'd have to read a character at a time
</I>&gt;<i> &gt; from the fd
</I>&gt;<i> 
</I>&gt;<i> Why not read, say, 4096 characters at a time?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; .... or if you want me to throw the input stream into a SBuf or
</I>&gt;<i> &gt; Tokenizer instead of just using some C calls.
</I>&gt;<i> 
</I>&gt;<i> I do, but I cannot insist on that. You can stop polishing the patch as soon as it
</I>&gt;<i> has no known bugs. Others will decide whether to accept it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
I appreciate the suggestions, both from a standpoint of not having been writing C/C++ code for a long time and I'd rather have the code be more &quot;consistent&quot; with the rest of the application. That's why using some of the classes that is already in the app that I had no idea was even there I think is a good idea. The reading a char at a time - I was thinking about parsing as reading. Anyway, I had already started it prior to reading the &quot;stop polishing&quot;.

&gt;<i> Please note that you have not shared updated changes AFAICT. The squid-
</I>&gt;<i> 3.5.20-osx-devpf-transparent.patch you attached looked old to me.
</I>&gt;<i> 
</I>&gt;<i> 
</I>
You are right - such a pain in the environment that I'm developing in. Mac off in a segmented network, which doesn’t have access to where I'm emailing from. Let alone having to change proxy settings. So have to dump the patch on a jump host, which I forgot to update with the new and copied the old file down to my email host. This one should be updated.

&gt;<i> Thank you,
</I>&gt;<i> 
</I>&gt;<i> Alex.
</I>
Thank you for the time.
Greg

-------------- next part --------------
A non-text attachment was scrubbed...
Name: squid-3.5.20-osx-devpf-transparent.patch
Type: application/octet-stream
Size: 3618 bytes
Desc: squid-3.5.20-osx-devpf-transparent.patch
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160929/9cc7ef8f/attachment.obj">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20160929/9cc7ef8f/attachment.obj</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006887.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
	<LI>Next message: <A HREF="006890.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6889">[ date ]</a>
              <a href="thread.html#6889">[ thread ]</a>
              <a href="subject.html#6889">[ subject ]</a>
              <a href="author.html#6889">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
