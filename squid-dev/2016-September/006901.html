<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] OSX transparent-proxy using pfctl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3C65f45144-e676-7847-d566-2d181170e52c%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="006899.html">
   <LINK REL="Next"  HREF="006905.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] OSX transparent-proxy using pfctl</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20OSX%20transparent-proxy%20using%20pfctl&In-Reply-To=%3C65f45144-e676-7847-d566-2d181170e52c%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] OSX transparent-proxy using pfctl">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Sep 30 16:37:08 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006899.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
        <LI>Next message: <A HREF="006905.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6901">[ date ]</a>
              <a href="thread.html#6901">[ thread ]</a>
              <a href="subject.html#6901">[ subject ]</a>
              <a href="author.html#6901">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 1/10/2016 4:04 a.m., Shively, Gregory wrote:
&gt;&gt;<i> Must(false) just throws an exception. Where that exception will be
</I>&gt;&gt;<i> caught before main() when thrown from your code, I do not know
</I>&gt;&gt;<i> (perhaps you already do). Must(false) is just a trick to check
</I>&gt;&gt;<i> whether all exceptions in your code will be caught/handled the way
</I>&gt;&gt;<i> you want. The alternative is to trigger real exceptions, but that
</I>&gt;&gt;<i> is often a lot harder.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> In general, we should be using as few try/catch as possible to
</I>&gt;&gt;<i> accomplish the desirable outcome. Thus, always adding try/catch
</I>&gt;&gt;<i> &quot;just in case&quot; is the wrong approach (I am _not_ saying you are
</I>&gt;&gt;<i> doing that!). Until Squid exception handling is improved, testing
</I>&gt;&gt;<i> is often the best way to find the right place.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> If you decide that a try/catch is necessary, place it as high as
</I>&gt;&gt;<i> possible and please do not forget to print the caught exception.
</I>&gt;&gt;<i> There are examples in the code.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Please note that you do not have to catch exceptions even if they
</I>&gt;&gt;<i> kill Squid. The current lack of try/catchers around critical
</I>&gt;&gt;<i> contexts is not your problem. Add try/catch only if you think
</I>&gt;&gt;<i> catching close to your new code is necessary for your code to work
</I>&gt;&gt;<i> well under more-or-less &quot;normal&quot; conditions. I doubt it is
</I>&gt;&gt;<i> currently necessary because you are not using exceptions for benign
</I>&gt;&gt;<i> errors.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I think I'll just leave the exception handling for the caller then.
</I>&gt;<i> There really isn't anything that can be done to resolve the exception
</I>&gt;<i> in the callee.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +    if (n == -1) { +        int xerrno = errno; +
</I>&gt;&gt;&gt;<i> debugs(89, DBG_IMPORTANT, HERE &lt;&lt; &quot;Reading from PFCTL failed: &quot;
</I>
NP: please drop the HERE macro in new code. It is deprecated now and not
needed.

&gt;&gt;<i> &lt;&lt; xstrerr(xerrno));
</I>&gt;&gt;&gt;<i> +        return false; +    } + +    close(pipefd[0]);
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Now leaking pipefd[0] on errors. Someday, Squid will have a
</I>&gt;&gt;<i> auto-close descriptor wrapper...
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Thanks - I felt list I was missing something there :-).
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +        SBuf host; +        int64_t port; + +        if
</I>&gt;&gt;&gt;<i> (tk.token(host, bracket) || tk.token(host, colon)) {
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Nice rewrite! You can move the port declaration lower, and you
</I>&gt;&gt;<i> should. And no empty lines between the declaration and the
</I>&gt;&gt;<i> single-statement code that uses that declaration exclusively:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> SBuf host; if (...) { int64_t port = 0; if (...) ... }
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> +    while (!tk.atEnd()) { +        if (tk.token(host, bracket)
</I>&gt;&gt;&gt;<i> || tk.token(host, colon)) {
</I>&gt;&gt;<i> ...
</I>&gt;&gt;&gt;<i> +        } + +        tk.skip('\n'); +    }
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> An infinite loop if the actual input contains, say, a single space
</I>&gt;&gt;<i> and nothing else? Or a token without brackets and colons? That is
</I>&gt;&gt;<i> unlikely, of course, but perhaps not completely impossible. I am
</I>&gt;&gt;<i> not dictating code, but to skip an arbitrary bad line you might
</I>&gt;&gt;<i> need something like this at the end of an iteration:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> // the combination covers all characters so we will make progress 
</I>&gt;&gt;<i> (void)tk.skipAll(anythingButLf); // silently skip any garbage 
</I>&gt;&gt;<i> (void)tk.skipAll(lf)) // either at the beginning of the next line
</I>&gt;&gt;<i> or eof
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> BTW, I believe the previous version of your patch had a similar
</I>&gt;&gt;<i> infinite loop problem, but now it became obvious, thanks to your
</I>&gt;&gt;<i> nice refactoring.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> You are right - there is an infinite loop. I started to play with the
</I>&gt;<i> tokenizing after I sent the patch and didn't see the infinite loop,
</I>&gt;<i> but I don't think it is doing what I was attempting in the loop
</I>&gt;<i> anyway. How about I get rid of the loop all together - I should be
</I>&gt;<i> only getting one line from pfctl, and if the parsing fails -I should
</I>&gt;<i> probably just be returning false anyway instead of attempting to find
</I>&gt;<i> what I expect later in the buffer. I was trying to be safe from the
</I>&gt;<i> parsing, but I'm starting to think I should just fail out of the
</I>&gt;<i> parsing if the buffer doesn't have what I expect.
</I>
Provided one line is always sufficient to get the NAT'ed address or to
detect a problem. Then yes returning false/fail is the right thing to do
there.

The one thing to be very careful of here is that results for different
IP addresses cannot get mixed up. The entire purpose of this lookup is
to guarantee reliability of the information being used. If it fails
people face real costs and painful trouble.

Please make sure that your code debugs() dumps the full pfctl line(s)
received at level DBG_DATA, and (only) on errors the relevant bit at a
higher level like 2 or 3 - the other functions debug output can give


Some other things about the current patch:

* for the address string buffers SQUIDHOSTNAMELEN is guaranteed to be
long enough to store a URL-format IP address with port information.
MAX_IPSTRLEN is only guaranteed to be able to hold one IP by itself (the
'extra' space is for some weird formats that can be found in the more
unusual corners of networking).


&gt;<i> 
</I>&gt;<i> A different question - I'm wondering if I should move where this
</I>&gt;<i> conditional compilation is being placed with regard to the other
</I>&gt;<i> conditional compilation. I had put it in based on what the last
</I>&gt;<i> compilation options I had used when attempting to get this working
</I>&gt;<i> before looking in the code. I didn't know if this would be enabled by
</I>&gt;<i> configure or some other macro that might be defined on OSX. But it
</I>&gt;<i> looks like I have it inside the conditional compilation for
</I>&gt;<i> !USE_NAT_DEVPF. Do you think it should be moved?
</I>
It might be best if the conditionals were re-arranged like so:

#if USE_NAT_DEVPF
... the /dev/pf stuff

#elif _SQUID_APPLE_
... this new pfctl stuff

#else /* !USE_NATDEVPF */
... the getsockname stuff ...

#endif

Since they are a inside the --enable-pf-transparent conditional
PF_TRANSPARENT wrapper, that should be all that is needed to enable it
on MacOSX.


&gt;<i> 
</I>&gt;<i> Regarding the test_builds.sh - got it to run with the --keep-going
</I>&gt;<i> and grepped out of the logs - only PASS in the summary section. This
</I>&gt;<i> was with the current patch. I'll run it again, but at least know that
</I>&gt;<i> it is working.
</I>
Not something to worry about with this patch. That testing is more for
changes where behaviour with and without the feature being enabled gets
affected and needs to be tested.

This change is pretty isolated and you are not changing any of the
behaviour when its disabled. So you only need to test the build using
this new code works as expected.

The fact that it is failing might be a sign of other MacOS issues that
need attention unrelated to this patching. But may also be just missing
commonly used dependencies on your machine.


Amos
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006899.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
	<LI>Next message: <A HREF="006905.html">[squid-dev] [PATCH] OSX transparent-proxy using pfctl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6901">[ date ]</a>
              <a href="thread.html#6901">[ thread ]</a>
              <a href="subject.html#6901">[ subject ]</a>
              <a href="author.html#6901">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
