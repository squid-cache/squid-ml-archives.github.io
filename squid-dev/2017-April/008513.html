<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] CRUSH peer selection method
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20CRUSH%20peer%20selection%20method&In-Reply-To=%3Ce7278443-cd62-c3cd-61ab-1a0e824d9a22%40dachary.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008511.html">
   <LINK REL="Next"  HREF="008523.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] CRUSH peer selection method</H1>
    <B>Loic Dachary</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20CRUSH%20peer%20selection%20method&In-Reply-To=%3Ce7278443-cd62-c3cd-61ab-1a0e824d9a22%40dachary.org%3E"
       TITLE="[squid-dev] [RFC] CRUSH peer selection method">loic at dachary.org
       </A><BR>
    <I>Mon Apr 17 23:00:57 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008511.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
        <LI>Next message: <A HREF="008523.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8513">[ date ]</a>
              <a href="thread.html#8513">[ thread ]</a>
              <a href="subject.html#8513">[ subject ]</a>
              <a href="author.html#8513">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On 04/17/2017 09:10 PM, Loic Dachary wrote:
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 04/17/2017 08:34 PM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 04/17/2017 10:53 AM, Loic Dachary wrote:
</I>&gt;&gt;&gt;<i> On 04/17/2017 06:28 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> On 04/17/2017 09:08 AM, Loic Dachary wrote:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>   peer 1 targeted by a set of requests (X1)
</I>&gt;&gt;&gt;&gt;&gt;<i>   peer 2 targeted by a set of requests (X2)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> and we add a new peer, CRUSH makes it so 1/3 of the requests from peer 1 and 2 move to peer 3
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>   peer 1 targeted by a set of requests (2/3 of X1)
</I>&gt;&gt;&gt;&gt;&gt;<i>   peer 2 targeted by a set of requests (2/3 of X2)
</I>&gt;&gt;&gt;&gt;&gt;<i>   peer 3 targeted by a set of requests (1/3 of X1 + 1/3 of X2)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> How would the last three lines look for CARP and sourcehash?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'm not sure :-) But I could write a simulation to figure it out.
</I>&gt;&gt;&gt;<i> Unless I missed a part of src/carp.cc that mitigates the problem, the
</I>&gt;&gt;&gt;<i> situation should not be very different from what is described at
</I>&gt;&gt;&gt;<i> <A HREF="https://docs.openstack.org/developer/swift/ring_background.html#part-2">https://docs.openstack.org/developer/swift/ring_background.html#part-2</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is totally up to you whether to do anything else. FWIW, AFAICT:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * only math (not simulation) is needed to show that any &quot;peer =
</I>&gt;&gt;<i> request_hash % n&quot; mapping algorithm (where &quot;n&quot; is the number of peers)
</I>&gt;&gt;<i> may result in a lot of &quot;moved&quot; request:peer assignments;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * many folks do not know whether CRUSH, CARP and sourcehash use a &quot;peer
</I>&gt;&gt;<i> = request_hash % n&quot; mapping algorithm (you should say that explicitly);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * it would be both interesting and useful to know how the amount of
</I>&gt;&gt;<i> &quot;movement&quot; changes with &quot;n&quot; in all compared algorithms (e.g., should I
</I>&gt;&gt;<i> bother with CRUSH if I have 10 peers?);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * do not assume that we know that a 1/3 movement shown by CRUSH (for
</I>&gt;&gt;<i> n=2) is a lot less than some X shown by CARP (for the same &quot;n&quot;);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * disclose the price of the reduction of movement (e.g., &quot;a few RAM
</I>&gt;&gt;<i> bytes per peer to store the more complex mapping and a few CPU cycles to
</I>&gt;&gt;<i> find the right peer for each request&quot;).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Perhaps your article already addresses all these concerns, but if you
</I>&gt;&gt;<i> want others to be enthusiastic about CRUSH, it may help to distill its
</I>&gt;&gt;<i> advantages and costs to something one can grasp by reading a
</I>&gt;&gt;<i> two-paragraph email with an easy-to-grok table.
</I>&gt;<i> 
</I>&gt;<i> That's what I should have done to begin with. Explaining with maths would be complicated, I'll write some code and run a simulation, it will be easier to understand.
</I>
It turns out I misunderstood how CARP works ( <A HREF="https://tools.ietf.org/html/draft-vinod-carp-v1-03">https://tools.ietf.org/html/draft-vinod-carp-v1-03</A> ) and it performs as well as CRUSH. 

After implementing something reasonably similar at <A HREF="http://libcrush.org/dachary/python-crush/commit/fced5135562da09eaf597ac7de74712022d48136">http://libcrush.org/dachary/python-crush/commit/fced5135562da09eaf597ac7de74712022d48136</A> and running a simulation adding two new peers, here is what I get.

The rows below show the number of requests moved from the given peer to each peer named in the columns. The requests% at the end of the rows shows shows the percentage of the total number of requests that is moved away from this particular peer. The last row shows the percentage of the total number of requests that is moved to the peer named in the column.

With CRUSH:

crush compare --rule data --replication-count 1 --origin tests/peers-crushmap-before.json --destination tests/peers-crushmap-after.json

          peer9  peera requests%
peer0       970   1090    2.06%
peer1      1012    997    2.01%
peer2      1025   1012    2.04%
peer3      1004   1071    2.08%
peer4       983   1025    2.01%
peer5      1008   1033    2.04%
peer6       951    965    1.92%
peer7      1006   1052    2.06%
peer8      1001    994    1.99%
request%  8.96%  9.24%   18.20%

With CARP:

crush compare --carp --origin tests/peers-crushmap-before.json --destination tests/peers-crushmap-after.json

          peer9   peera requests%
peer4      6311       0    6.31%
peer8         0   12340   12.34%
request%  6.31%  12.34%   18.65%


-- 
Lo√Øc Dachary, Artisan Logiciel Libre
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008511.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
	<LI>Next message: <A HREF="008523.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8513">[ date ]</a>
              <a href="thread.html#8513">[ thread ]</a>
              <a href="subject.html#8513">[ subject ]</a>
              <a href="author.html#8513">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
