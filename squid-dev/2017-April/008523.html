<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [RFC] CRUSH peer selection method
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20CRUSH%20peer%20selection%20method&In-Reply-To=%3C7b8a2366-136a-1ac3-4c16-7d3428baa637%40dachary.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008513.html">
   <LINK REL="Next"  HREF="008524.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [RFC] CRUSH peer selection method</H1>
    <B>Loic Dachary</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BRFC%5D%20CRUSH%20peer%20selection%20method&In-Reply-To=%3C7b8a2366-136a-1ac3-4c16-7d3428baa637%40dachary.org%3E"
       TITLE="[squid-dev] [RFC] CRUSH peer selection method">loic at dachary.org
       </A><BR>
    <I>Wed Apr 19 12:51:40 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008513.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
        <LI>Next message: <A HREF="008524.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8523">[ date ]</a>
              <a href="thread.html#8523">[ thread ]</a>
              <a href="subject.html#8523">[ subject ]</a>
              <a href="author.html#8523">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

On 04/18/2017 01:00 AM, Loic Dachary wrote:
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 04/17/2017 09:10 PM, Loic Dachary wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 04/17/2017 08:34 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 04/17/2017 10:53 AM, Loic Dachary wrote:
</I>&gt;&gt;&gt;&gt;<i> On 04/17/2017 06:28 PM, Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> On 04/17/2017 09:08 AM, Loic Dachary wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>   peer 1 targeted by a set of requests (X1)
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>   peer 2 targeted by a set of requests (X2)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> and we add a new peer, CRUSH makes it so 1/3 of the requests from peer 1 and 2 move to peer 3
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>   peer 1 targeted by a set of requests (2/3 of X1)
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>   peer 2 targeted by a set of requests (2/3 of X2)
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>   peer 3 targeted by a set of requests (1/3 of X1 + 1/3 of X2)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> How would the last three lines look for CARP and sourcehash?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I'm not sure :-) But I could write a simulation to figure it out.
</I>&gt;&gt;&gt;&gt;<i> Unless I missed a part of src/carp.cc that mitigates the problem, the
</I>&gt;&gt;&gt;&gt;<i> situation should not be very different from what is described at
</I>&gt;&gt;&gt;&gt;<i> <A HREF="https://docs.openstack.org/developer/swift/ring_background.html#part-2">https://docs.openstack.org/developer/swift/ring_background.html#part-2</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It is totally up to you whether to do anything else. FWIW, AFAICT:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * only math (not simulation) is needed to show that any &quot;peer =
</I>&gt;&gt;&gt;<i> request_hash % n&quot; mapping algorithm (where &quot;n&quot; is the number of peers)
</I>&gt;&gt;&gt;<i> may result in a lot of &quot;moved&quot; request:peer assignments;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * many folks do not know whether CRUSH, CARP and sourcehash use a &quot;peer
</I>&gt;&gt;&gt;<i> = request_hash % n&quot; mapping algorithm (you should say that explicitly);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * it would be both interesting and useful to know how the amount of
</I>&gt;&gt;&gt;<i> &quot;movement&quot; changes with &quot;n&quot; in all compared algorithms (e.g., should I
</I>&gt;&gt;&gt;<i> bother with CRUSH if I have 10 peers?);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * do not assume that we know that a 1/3 movement shown by CRUSH (for
</I>&gt;&gt;&gt;<i> n=2) is a lot less than some X shown by CARP (for the same &quot;n&quot;);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * disclose the price of the reduction of movement (e.g., &quot;a few RAM
</I>&gt;&gt;&gt;<i> bytes per peer to store the more complex mapping and a few CPU cycles to
</I>&gt;&gt;&gt;<i> find the right peer for each request&quot;).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Perhaps your article already addresses all these concerns, but if you
</I>&gt;&gt;&gt;<i> want others to be enthusiastic about CRUSH, it may help to distill its
</I>&gt;&gt;&gt;<i> advantages and costs to something one can grasp by reading a
</I>&gt;&gt;&gt;<i> two-paragraph email with an easy-to-grok table.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That's what I should have done to begin with. Explaining with maths would be complicated, I'll write some code and run a simulation, it will be easier to understand.
</I>&gt;<i> 
</I>&gt;<i> It turns out I misunderstood how CARP works ( <A HREF="https://tools.ietf.org/html/draft-vinod-carp-v1-03">https://tools.ietf.org/html/draft-vinod-carp-v1-03</A> ) and it performs as well as CRUSH. 
</I>&gt;<i> 
</I>&gt;<i> After implementing something reasonably similar at <A HREF="http://libcrush.org/dachary/python-crush/commit/fced5135562da09eaf597ac7de74712022d48136">http://libcrush.org/dachary/python-crush/commit/fced5135562da09eaf597ac7de74712022d48136</A> and running a simulation adding two new peers, here is what I get.
</I>&gt;<i> 
</I>&gt;<i> The rows below show the number of requests moved from the given peer to each peer named in the columns. The requests% at the end of the rows shows shows the percentage of the total number of requests that is moved away from this particular peer. The last row shows the percentage of the total number of requests that is moved to the peer named in the column.
</I>&gt;<i> 
</I>&gt;<i> With CRUSH:
</I>&gt;<i> 
</I>&gt;<i> crush compare --rule data --replication-count 1 --origin tests/peers-crushmap-before.json --destination tests/peers-crushmap-after.json
</I>&gt;<i> 
</I>&gt;<i>           peer9  peera requests%
</I>&gt;<i> peer0       970   1090    2.06%
</I>&gt;<i> peer1      1012    997    2.01%
</I>&gt;<i> peer2      1025   1012    2.04%
</I>&gt;<i> peer3      1004   1071    2.08%
</I>&gt;<i> peer4       983   1025    2.01%
</I>&gt;<i> peer5      1008   1033    2.04%
</I>&gt;<i> peer6       951    965    1.92%
</I>&gt;<i> peer7      1006   1052    2.06%
</I>&gt;<i> peer8      1001    994    1.99%
</I>&gt;<i> request%  8.96%  9.24%   18.20%
</I>&gt;<i> 
</I>&gt;<i> With CARP:
</I>&gt;<i> 
</I>&gt;<i> crush compare --carp --origin tests/peers-crushmap-before.json --destination tests/peers-crushmap-after.json
</I>&gt;<i> 
</I>&gt;<i>           peer9   peera requests%
</I>&gt;<i> peer4      6311       0    6.31%
</I>&gt;<i> peer8         0   12340   12.34%
</I>&gt;<i> request%  6.31%  12.34%   18.65%
</I>&gt;<i> 
</I>
After taking a closer look, I found one use case where CRUSH behaves significantly better than CARP. When you have 10 peers (peer0 to peer9), each with weight 1 and you want to increase the weight of one peer (say peer4) to 2. With CARP ~69% of the requests will move from one peer to another (because changing the weight of one peer changes the load_multiplier of all peers). With CRUSH ~8% of the requests will move.

When increasing the weight of peer4 from 1 to 2:

With CRUSH[1]

moved 8.11% of the requests

          peer4 objects%
peer0       896    0.90%
peer1       858    0.86%
peer2       978    0.98%
peer3       913    0.91%
peer5       911    0.91%
peer6       897    0.90%
peer7       910    0.91%
peer8       898    0.90%
peer9       846    0.85%
objects%  8.11%    8.11%

With CARP[2]

moved 69% of the requests

        peer0   peer1   peer2   peer3   peer4   peer5   peer6   peer7   peer8   peer9 
peer0       0       0       0       0    1424     562     643     594     629     571 
peer1       0       0       0       0    1504     592     548     605     574     584 
peer2       0       0       0       0    1449     558     590     663     637     563 
peer3       0       0       0       0    1418     607     604     610     591     606 
peer4     634     616     566     596       0     773    1178    1202    1179    1182 
peer5     619     609     556     586    1956       0     992    1213    1063    1193 
peer6     672     637     641     592    2031    1241       0     538    1224    1299 
peer7     542     589     603     586    1938    1095    1111       0     938    1182 
peer8     595     634     611     592    1999    1222    1173    1210       0     780 
peer9     510     496     526     528    2515    1103    1001    1086    1032       0 

I think CRUSH and CARP have similar CPU / RAM requirements. CRUSH needs a copy of the peers in a map, in an array of int and a temporary space that is roughly the same size. For N peers this would be in the range of 2KB + N * 4 * 2. It also needs a ~4KB static table to calculate an approximation of log2 without using floating point. For each request hashed, CRUSH will calculate the score based on the weight of the peer. This requires more CPU than a single multiplication which is what CARP does. CRUSH does not do any floating point calculation which saves CPU.

Cheers

[1] CRUSH simulation <A HREF="http://libcrush.org/dachary/python-crush/commits/wip-squid">http://libcrush.org/dachary/python-crush/commits/wip-squid</A>
[2] CARP simulation <A HREF="http://libcrush.org/dachary/python-crush/blob/e7579b28f4288525750e94fe9bdc4bf985cb5d1f/carp.cc#L371">http://libcrush.org/dachary/python-crush/blob/e7579b28f4288525750e94fe9bdc4bf985cb5d1f/carp.cc#L371</A>
-- 
Loïc Dachary, Artisan Logiciel Libre
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008513.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
	<LI>Next message: <A HREF="008524.html">[squid-dev] [RFC] CRUSH peer selection method
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8523">[ date ]</a>
              <a href="thread.html#8523">[ thread ]</a>
              <a href="subject.html#8523">[ subject ]</a>
              <a href="author.html#8523">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
