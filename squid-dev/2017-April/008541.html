<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Refactor TLS session extra data management
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Refactor%20TLS%20session%20extra%20data%20management&In-Reply-To=%3C5184b96d-8622-dcfa-c9ff-1ce39cd9181c%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008539.html">
   <LINK REL="Next"  HREF="008540.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Refactor TLS session extra data management</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Refactor%20TLS%20session%20extra%20data%20management&In-Reply-To=%3C5184b96d-8622-dcfa-c9ff-1ce39cd9181c%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Refactor TLS session extra data management">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Apr 23 23:00:48 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008539.html">[squid-dev] [PATCH] Refactor TLS session extra data management
</A></li>
        <LI>Next message: <A HREF="008540.html">[squid-dev] [PATCH] SBuf header names
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8541">[ date ]</a>
              <a href="thread.html#8541">[ thread ]</a>
              <a href="subject.html#8541">[ subject ]</a>
              <a href="author.html#8541">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 04/22/2017 06:52 AM, Amos Jeffries wrote:
&gt;<i> On 21/04/17 15:58, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 04/20/2017 04:50 PM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> These two patches begin the refactoring work to replace OpenSSL
</I>&gt;&gt;&gt;<i> SSL_set/get_ex_data() API with a generic libsecurity API. 
</I>&gt;&gt;<i> Thank you for working on this. I think the patch is on the right track
</I>&gt;&gt;<i> overall, but I found one bug, and I believe the proposed GetFrom() API
</I>&gt;&gt;<i> needs to be revised. I also object to adding any code that calls TLS
</I>&gt;&gt;<i> connections &quot;sessions&quot;, especially when we already have code that
</I>&gt;&gt;<i> calls TLS sessions &quot;sessions&quot;. If at all possible, please fix the
</I>&gt;&gt;<i> naming in the existing code (as already discussed elsewhere) before
</I>&gt;&gt;<i> adding any new stuff that makes the problem worse. 
</I>
&gt;<i> Lets not get bogged down in that again.
</I>
Let's not, but I do not understand what you are suggesting we do
instead. The problem exists, and your patch makes it worse. It is a
serious problem. I have made specific solution suggestions (and welcome
any better alternatives).

AFAICT, the previous patch with these problems was committed despite my
objections (v5 r15032). To avoid further misunderstanding, I have to
register my vote for this new set of patches as -1. Please do not commit
them until that vote changes.


&gt;&gt;&gt;<i> +/// extra data which we attach to a TLS session 
</I>&gt;&gt;<i> s/session/connection/ 
</I>
&gt;<i> No this data is explicitly not part of the &quot;TLS connection&quot;. It persists
</I>&gt;<i> long after the &quot;TLS connection&quot; is ended and may be shared across
</I>&gt;<i> multiple if and when the &quot;TLS session&quot; does so.
</I>
We attach these extras to a TLS connection, not session (the OpenSSL SSL
object, not the OpenSSL SSL_SESSION object).

I agree that some future code might share some extras across multiple
TLS connections, but since most of the current extras deal specifically
with the first connection in a session, and since sessions have their
own metadata, it is not unlikely that the shared/session information
will be different. We will add session extras as needed.

Your patch is about moving individual connection extras into a single
ConnectionExtras object. Please do not enlarge the patch scope to
sharing extras among connections!


&gt;&gt;&gt;<i> +/// class ExtraData 
</I>
&gt;&gt;<i> Please avoid names that end with State, Data, Info, Object, Status,
</I>&gt;&gt;<i> and similar noise/placeholder words without any specific meaning. In
</I>&gt;&gt;<i> this particular case, the class should be named ConnectionExtras and
</I>&gt;&gt;<i> described as &quot;Squid-specific TLS connection details&quot; or something like
</I>&gt;&gt;<i> that. The variables holding class objects should then become &quot;extras&quot;
</I>&gt;&gt;<i> instead of &quot;data&quot;. 
</I>
&gt;<i> OpenSSL calls this &quot;ex_data&quot; and GnuTLS calls it a &quot;datum pointer&quot;, 
</I>
Yes, for both libraries, our extras are just opaque &quot;data&quot;, but it is
not opaque data to us! Besides, IMHO, the libraries should not have used
&quot;data&quot; for these APIs either, but that is their problem, not ours.


&gt;<i> in both cases it is documented as being attached to a session. 
</I>
OpenSSL attaches relevant extras to the SSL object. The SSL object
represents a connection, not session. The session is represented by
OpenSSL SSL_SESSION. We have discussed this before, including
<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/2017-February/007959.html">http://lists.squid-cache.org/pipermail/squid-dev/2017-February/007959.html</A>


&gt;<i> They are definitely NOT destructed when the connection is ended.
</I>
The extras are destructed when the SSL object is freed (i.e, when the
TLS connection has ended).


&gt;&gt;&gt;<i> + /// \retval nullptr only if session is nullptr + static
</I>&gt;&gt;&gt;<i> Security::ExtraData *GetFrom(const SessionPointer &amp;); 
</I>&gt;&gt;<i> The patch contains: * code that asserts if GetFrom() returns nil *
</I>&gt;&gt;<i> code that crashes if GetFrom() returns nil * code that pointlessly
</I>&gt;&gt;<i> checks whether GetFrom() returns nil I did not see any code that
</I>&gt;&gt;<i> actually expects a nil connection pointer and can handle it correctly.
</I>
&gt;<i> Specific alternatives would be useful.
</I>
Already provided: &quot;change the method to accept a reference to the
connection (instead of a pointer) and return a reference to
ConnectionExtras (instead of a pointer).&quot; In OpenSSL terminology, that
would be:

    ConnectionExtras &amp;Of(SSL &amp;connection);


&gt;&gt;<i> The method itself does not store the TLS connection so it should not
</I>&gt;&gt;<i> need a pointer to one.
</I>
&gt;<i> Since when was it a requirement that all function parameters were
</I>&gt;<i> stored? 
</I>
There is no such dubious requirement, of course (and using a clearly
unreasonable interpretation of a suggestion is a waste of time).

In general, when dealing with an object that cannot be simply copied,
there are three relevant cases:

1. optional info: the function can do its primary job w/o the object
2. stored info: the function needs to store the object somewhere
3. used info: the function uses the object without storing it

Cases #1 and #2 should use pointers. Case #3 -- a reference.
ConnectionExtras::Of() is case #3.

We violate that general principle in many cases, and sometimes for a
good reason, but there is no good reason to violate it in this case
AFAICT (and, as I have documented, there are good reasons not to violate
it).


&gt;&gt;<i> To avoid multiplying these problems beyond the patch, please change
</I>&gt;&gt;<i> the method to accept a reference to the connection (instead of a
</I>&gt;&gt;<i> pointer) and return a reference to ConnectionExtras (instead of a
</I>&gt;&gt;<i> pointer).
</I>
&gt;<i> Er, did you read the pt1 code?
</I>
I did.


&gt;<i> The pointer received is passed on to the
</I>&gt;<i> underlying library API. Using a reference to an object instance of
</I>&gt;<i> unknown type is not doable. And we also agreed that mixing smart and raw
</I>&gt;<i> pointers in our API was a bad idea.
</I>
The method code will still pass a raw SSL object pointer to the
underlying OpenSSL APIs, of course. There is no problem with doing that.
(I bet those APIs themselves would have used a connection reference
instead of a pointer if C had that mechanism).


&gt;<i> The connection is not accessible in most places this function is called.
</I>
In your current patch terminology (AFAICT), the connection is the object
returned by the &quot;*session&quot; expression, where &quot;session&quot; is the
Security::Extras::From() parameter. In OpenSSL terminology, the
connection is the SSL object used by that method.


&gt;<i> That code path is untested by me, yes. I cannot test the OpenSSL code
</I>&gt;<i> changes, and thought I'd stated that enough by now. 
</I>
Please do identify any significant untested areas in every patch. It is
a fair request because it is much easier for you to disclose the problem
in every patch then for a reviewer to remember what you currently can or
cannot do, and then identify which areas have been tested and which have
not been, especially when you are changing general security code (that
just happens to lack GnuTLS support but is not otherwise specific to
OpenSSL). Knowing what has been tested also helps with future triage,
when it would be especially difficult to reconstruct what you could or
could not test at the time of the commit!

And, IMHO, you should not make TLS-related changes if you refuse to
properly test most of them.


&gt;&gt;&gt;<i> + Security::SessionPointer session(ssl, [](SSL *){/* do not destroy
</I>&gt;&gt;&gt;<i> */}); 
</I>&gt;&gt;<i> This ugly hack will no longer be needed after the above changes AFAICT. 
</I>
&gt;<i> No such luck. At least it is part of the callback state preparation.
</I>
AFAICT, if you implement the changes I suggested, the hack should go
away because there will be no reason to create an SessionPointer object.
You will simply use &quot;*ssl&quot; expression to get access to the extras:

    /* const */ auto extras = ConnectionExtras::Of(*ssl);

&gt;&gt;&gt;<i> +class ExtraData +{ +public: + SBuf sni; 
</I>&gt;&gt;<i> This member may not actually contain an SNI extension value (neither
</I>&gt;&gt;<i> sent nor received). Let's not lie to ourselves and call it serverName.
</I>&gt;&gt;<i> Please document new data members. Consider: /// suspected or actual
</I>&gt;&gt;<i> connection destination (from various sources) SBuf serverName; 
</I>
&gt;<i> Sigh. Ironicly it started as that. Then realized the value being stored
</I>&gt;<i> there was SNI or an SNI-to-be value.
</I>
The last part seems wrong to me: As I said, AFAICT, there are cases
where serverName was not SNI and does not become SNI.


Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008539.html">[squid-dev] [PATCH] Refactor TLS session extra data management
</A></li>
	<LI>Next message: <A HREF="008540.html">[squid-dev] [PATCH] SBuf header names
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8541">[ date ]</a>
              <a href="thread.html#8541">[ thread ]</a>
              <a href="subject.html#8541">[ subject ]</a>
              <a href="author.html#8541">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
