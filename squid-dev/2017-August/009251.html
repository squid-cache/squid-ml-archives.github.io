<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Purge cache entries in SMP-aware caches
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Purge%20cache%20entries%20in%20SMP-aware%20caches&In-Reply-To=%3C1c344e68-49d5-accd-0201-524939c7ec63%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009250.html">
   <LINK REL="Next"  HREF="009252.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Purge cache entries in SMP-aware caches</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Purge%20cache%20entries%20in%20SMP-aware%20caches&In-Reply-To=%3C1c344e68-49d5-accd-0201-524939c7ec63%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Purge cache entries in SMP-aware caches">rousskov at measurement-factory.com
       </A><BR>
    <I>Sat Aug  5 06:09:24 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009250.html">[squid-dev] [PATCH] Purge cache entries in SMP-aware caches
</A></li>
        <LI>Next message: <A HREF="009252.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9251">[ date ]</a>
              <a href="thread.html#9251">[ thread ]</a>
              <a href="subject.html#9251">[ subject ]</a>
              <a href="author.html#9251">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/04/2017 01:52 PM, Eduard Bagdasaryan wrote:
&gt;<i> To avoid this 'going around releaseRequest() API' I would like
</I>&gt;<i> to suggest renaming 'RELEASE_REQUEST' flag to something
</I>&gt;<i> more suitable, e.g., 'ENTRY_REUSABLE' and adding a helper
</I>&gt;<i> API avoiding direct flag manipulation. This would not contradict
</I>&gt;<i> with the existing setReleaseFlag() meaning (i.e., &quot;marking the
</I>&gt;<i> corresponding entry for eventual removal&quot;), adding an additional
</I>&gt;<i> meaning (i.e., since then, the entry is not suggested to be re-used
</I>&gt;<i> by others).
</I>
Let's focus on the flag meaning. We can always rename it later (or even
in this project). It is the flag meaning that should drive our primary
decisions, not the letters spelling flag's name.

My response has three parts. Most readers may want to skip the first two
parts. I left them to document my thought process in case I missed
something important in my reasoning; the surprising (to me) final
conclusion ended up being rather far from where I started!


== Part I. Simplify by replacing &quot;A or B&quot; with &quot;B&quot; ==

I like the overall direction of your proposal, but I wonder whether we
really have to _add_ the new/proposed &quot;not reusable&quot; meaning to the
old/implied &quot;marked for removal&quot; meaning. Can we just define the flag to
mean &quot;not usable for new Store clients&quot;?

1. The old code that removes idle RELEASE_REQUEST entries from Store
would still work fine: It will be removing idle entries that cannot be
used by anybody. Clearly, removing such entries is logical/natural.

2. Old StoreEntry::release() would still work fine: If it cannot remove
the entry immediately, it will mark it unusable for new clients, knowing
very well that code in #1 will remove such entries (when they become
idle), eventually achieving the result desired by the release() caller.

3. The old StoreEntry::releaseRequest() hack continues to be nothing
more than a temporary hack for callers that are (possibly justifiably!)
afraid of calling release(). No need to discuss it at this high level.

4. The old storeCreatePureEntry() would be able to use the new
StoreEntry::banFutureReuse() or a similar treat-as-private flag-setting
method without raising the same red flag I raised in my review (I will
still argue for moving/changing that code for other reasons, but at
least that it would not look so out of place anymore).

Is there any code that really needs to interpret the RELEASE_REQUEST
flag itself as something other than &quot;unusable for new Store clients&quot;?

If there is no such code, then I have another question: Why do we need
this flag at all? It is answered in Part II.


== Part II. Simplify further by replacing big &quot;B&quot; with small &quot;b&quot; ==

We already have private keys that mean almost the same thing. You have
touched upon this conflict in your email (thank you for carefully
thinking about this!):

&gt;<i> This intersects a little with the existing 'private entries'
</I>&gt;<i> definition. However, private entries may eventually become public,
</I>&gt;<i> while an entry with ENTRY_REUSABLE unset, would stay 'private'
</I>&gt;<i> until it is removed.
</I>
I would replace &quot;a little&quot; with something like &quot;98%&quot;, but we are
otherwise in agreement :-).

AFAICT, the only difference between a private key and an &quot;unusable for
new Store clients&quot; flag is reversibility of the former. Moreover, IIRC,
all current code paths that set the flag also make (or should make) the
key private (which was a part of my original concern that started this
discussion), tying the two concepts together (naturally).

If this reasoning is correct, then we do not need a &quot;unusable for new
Store clients&quot; flag. We just need a &quot;cannot become public&quot; flag! The
rest of the required functionality/meaning is already covered by the
private key.


== Part III. The new &quot;b&quot; is the old &quot;A&quot;! ==

Part II concluded that we do not need a &quot;unusable for new Store clients&quot;
flag because private keys already address that need. We just need a
&quot;cannot become public&quot; flag. Which reminds me of this old code:

&gt;<i> void
</I>&gt;<i> StoreEntry::makePublic(const KeyScope scope)
</I>&gt;<i> {
</I>&gt;<i>     if (!EBIT_TEST(flags, RELEASE_REQUEST))
</I>&gt;<i>         setPublicKey(scope);
</I>&gt;<i> }
</I>
The above code suggests that we may already have that &quot;cannot become
public&quot; flag. It is named differently, it may be set in slightly the
wrong place (separated from the corresponding makePrivate() call), and
some of its tests might need to be adjusted to look for the key status,
but ultimately it can be used correctly as the minimal flag we need to
make a private key permanent!

If you agree with the above reasoning, then it should be easy to adjust
the code to match the newly developed understanding of the
true/desirable RELEASE_REQUEST flag meaning as the &quot;making private keys
permanent&quot; marker. I can suggest specific changes if you prefer, but you
should probably be the one driving this. To reduce noise, I suggest
keeping RELEASE_REQUEST name (at least for now) unless we already have
to change most RELEASE_REQUEST lines for other reasons.


HTH,

Alex.


&gt;<i> On 24.07.2017 02:00, Eduard Bagdasaryan wrote:
</I>&gt;&gt;<i> On 23.07.2017 02:04, Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> +    if (!flags.cachable)
</I>&gt;&gt;&gt;&gt;<i> +        EBIT_SET(e-&gt;flags, RELEASE_REQUEST);
</I>&gt;&gt;&gt;<i> This release request feels out of place and direct flags setting goes
</I>&gt;&gt;&gt;<i> around the existing releaseRequest() API. Please check all callers --
</I>&gt;&gt;&gt;<i> perhaps we do not need the above because all callers already do an
</I>&gt;&gt;&gt;<i> equivalent action (e.g., makePrivate()) for &quot;uncachable&quot; requests?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't think this lines are 'out of place': storeCreatePureEntry() just
</I>&gt;&gt;<i> initializes the just created StoreEntry fields (including
</I>&gt;&gt;<i> StoreEntry::flags) with correct values.  If we definitely know a
</I>&gt;&gt;<i> this moment that 'flags' should have RELEASE_REQUEST set, why do we need
</I>&gt;&gt;<i> to postpone this to many callers, hoping that all of them will do that
</I>&gt;&gt;<i> work correctly?  There are lots of storeCreateEntry() calls and it is
</I>&gt;&gt;<i> hardly possible to track that all of them end up with
</I>&gt;&gt;<i> 'releaseRequest()', when flags.cachable is false.  BTW, at the time of
</I>&gt;&gt;<i> StoreEntry initialization we do not need to do most of the work
</I>&gt;&gt;<i> releaseRequest() does. E.g., there are no connected storages to
</I>&gt;&gt;<i> disconnect from, no public keys to make them private, etc. The only
</I>&gt;&gt;<i> thing to do is RELEASE_REQUEST flag setting.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;<i> 
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009250.html">[squid-dev] [PATCH] Purge cache entries in SMP-aware caches
</A></li>
	<LI>Next message: <A HREF="009252.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9251">[ date ]</a>
              <a href="thread.html#9251">[ thread ]</a>
              <a href="subject.html#9251">[ subject ]</a>
              <a href="author.html#9251">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
