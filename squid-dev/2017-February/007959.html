<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20initial%20GnuTLS%20support%20for%20encrypted%20server%0A%20connections&In-Reply-To=%3Cb70694cb-1515-af71-3750-f907e78d4931%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007958.html">
   <LINK REL="Next"  HREF="007952.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20initial%20GnuTLS%20support%20for%20encrypted%20server%0A%20connections&In-Reply-To=%3Cb70694cb-1515-af71-3750-f907e78d4931%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Feb  5 02:20:55 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="007958.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
        <LI>Next message: <A HREF="007952.html">[squid-dev] [PATCH] VIA creation code duplication
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7959">[ date ]</a>
              <a href="thread.html#7959">[ thread ]</a>
              <a href="subject.html#7959">[ subject ]</a>
              <a href="author.html#7959">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/04/2017 12:31 PM, Amos Jeffries wrote:
&gt;<i> On 3/02/2017 4:05 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 02/01/2017 11:51 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Can we agree on this being a fundamental design in Squid:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  * all connections have an associated socket ID.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That assumption would be too limiting (and, AFAICT, unnecessary). For
</I>&gt;&gt;<i> example, SSL connections inside SSL connections (HTTPS proxy) do not
</I>&gt;&gt;<i> have a socket. The same will apply to SSL connections inside HTTP/2
</I>&gt;&gt;<i> sessions. And eventually QUIC.
</I>
&gt;<i> I know. However the curent Squid code does not support such things.
</I>&gt;<i> Probably _because_ it was designed with the above as one of the assumptions.
</I>
You seem to be moving goalposts. There is no fundamental Squid design
principle that requires everything called &quot;connection&quot; (in some context)
to have an associated socket. Do socketless connections exist in the
code today? I am not sure, but there is nothing at the fundamental
design level that would prevent them from being supported.

Moreover, if it does not exist already, there are real and significant
pressures to add such support (various features associated with HTTPS
proxies, not to mention HTTP/2 and QUIC) _and_ existing code that can be
reused to add such support (e.g., BIO-centric code).


&gt;&gt;&gt;<i>  * all _open_ connections are stored in fd_table. Indexed by the
</I>&gt;&gt;&gt;<i> connections socket ID. If not that is a bug.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Again, this is oversimplifying too much: fd_table is for sockets, not
</I>&gt;&gt;<i> connections.
</I>
&gt;<i> This is why I emphasized _open_ connections. The connections without
</I>&gt;<i> socket ID (FD number) are represented by Comm::Connection in 'closed'
</I>&gt;<i> state (fd == -1).
</I>&gt;<i> 
</I>&gt;<i> If there are other types of connection in the current codebase please
</I>&gt;<i> point me at them.
</I>
When talking about &quot;fundamental Squid design&quot;, we should not really care
about the &quot;current code base&quot; much. Compared to changing the fundamental
design, changing code base is easy and not worth worrying about at this
level.


&gt;&gt;&gt;<i> Now a Question, and please answer carefully:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Does the PeerConnector or the new() operator 'connect' the &quot;SSL
</I>&gt;&gt;&gt;<i> connection&quot; ?
</I>
&gt;&gt;<i> Which new() operator?
</I>
&gt;<i> SSL_new() - the one being called by Ssl::CreateClient() to produce its
</I>&gt;<i> return object.
</I>
SSL_new() does not connect an SSL connection. It creates it.


&gt;&gt;<i> To connect an SSL connection one has to call
</I>&gt;&gt;<i> SSL_connect() or equivalent.
</I>
&gt;<i> Um, the SSL_connect() function performs the TLS/SSL handshake protocol.
</I>
Successfully performing a handshake is what moves an SSL connection into
the &quot;connected&quot; state. As you know, lot's of things can happen to that
SSL connection during a handshake (and some even _before_ the handshake,
like deciding which ciphers to offer or which session to resume, if any).


&gt;<i> Note sentence 2 of the formal definition:
</I>&gt;<i> &quot;
</I>&gt;<i>    session
</I>&gt;<i>       A TLS session is an association between a client and a server.
</I>&gt;<i> ==&gt;   Sessions are created by the handshake protocol.  Sessions define a
</I>&gt;<i>       set of cryptographic security parameters that can be shared among
</I>&gt;<i>       multiple connections.  Sessions are used to avoid the expensive
</I>&gt;<i>       negotiation of new security parameters for each connection.
</I>&gt;<i> &quot;
</I>
I do not know why I should note that sentence or why we are now talking
about sessions. That sentence certainly does not contradict what I have
been saying all along. As the above paragraph explains, some SSL
connections participate in new session creation. Some SSL connections
reuse old sessions (that were created by/during other SSL connections).


&gt;&gt;<i> If PeerConnector or your new() operator
</I>&gt;&gt;<i> call SSL_connect() (directly or indirectly) then they are trying to
</I>&gt;&gt;<i> change the state of an SSL connection to &quot;connected&quot;.
</I>&gt;<i> 
</I>&gt;<i> This again diverges from the RFC 5246 definition:
</I>&gt;<i> &quot;
</I>&gt;<i>    connection
</I>&gt;<i>       A connection is a transport (in the OSI layering model definition)
</I>&gt;<i>       that provides a suitable type of service.  For TLS, such
</I>&gt;<i>       connections are peer-to-peer relationships.  The connections are
</I>&gt;<i>       transient.  Every connection is associated with one session.
</I>&gt;<i> &quot;
</I>
Where do you see the divergence? The above definition is talking about
the transport connection to carry TLS connection information. When I am
talking about Security::Connection, I am talking about the TLS
connection, not the underlying transport connection (which may take many
forms).


&gt;<i> The section 6.1 which introduces the phrase &quot;TLS connection&quot; as a
</I>&gt;<i> concept is documenting the &quot;TLS Record Protocol&quot;. It is very clear that
</I>&gt;<i> abstract &quot;TLS connection&quot; does not exist until the TLS records are
</I>&gt;<i> flowing.
</I>
That &quot;does not exist&quot; assertion does not make sense to me. As an
abstract thing, it can be defined to start to exist when the first
record starts &quot;flowing&quot; to the other TLS agent, or when the first record
starts being constructed in the agent memory, or when the memory for
that first record is first allocated, or etc., etc.

The exact moment of TLS connection birth would depend on the discussion
level. Are we talking TLS specs? Abstract TLS algorithms? A
general-purpose TLS library? Squid code? Something else?

And, more importantly, why are we even trying to determine the exact
moment when an _abstraction_ such as a TLS connection starts to exist?!


&gt;<i> At which point it refers the transport protocol stack
</I>
This is incorrect. The TLS connection has TLS-specific states/properties
(defined by the TLS protocol) and knows almost nothing about the
underlying transport (which the TLS protocol lives largely out of scope).


&gt;<i> The session is different:
</I>
Agreed. TLS session is not a TLS connection. Those are different
concepts. The third concept is the transport connection that a TLS
connection uses to exchange TLS session information (among other things).


&gt;&gt;<i> Does that answer your question?
</I>&gt;<i> 
</I>&gt;<i> Sadly no, but in a way yes. Earlier you grumbled about conflating &quot;SSL
</I>&gt;<i> session&quot; with &quot;SSL connection&quot;.
</I>&gt;<i> 
</I>&gt;<i> The only conflation I am seeing is in the OpenSSL documentation. The
</I>&gt;<i> spec does not define the term at all, and the closest equivalent is a
</I>&gt;<i> phrase used to abbreviate the transport description - not anyting crypto
</I>&gt;<i> related.
</I>
Sorry, you lost me here. Surely, RFC 5246 defines all three things: SSL
connection, SSL session, and transport connection. Or, if you think the
exact protocol letters are somehow important in this context, TLS
connection, TLS session, and transport connection.



&gt;<i> So far as I can tell both the existing v5/v4 code and my patches do
</I>&gt;<i> match the definitions in the RFC 5246 for &quot;session&quot;, &quot;connection&quot;, and
</I>&gt;<i> the fuzzy &quot;TLS connection&quot;.
</I>
Sorry, but they do not. I am not sure _why_ you are trying so hard to
inject a TLS session where the standard terminology uses TLS connection
so it is difficult for me to keep finding new arguments, but here is one
more mapping that might help (or hurt, I do not really know):

* The C type which OpenSSL calls &quot;SSL&quot;, together with various operations
on that type represents a TLS connection. We should call its
wrappers/manipulators/derivatives using Security::Connection root.

* The type which OpenSSL calls SSL_SESSION is a TLS session. We should
call its wrappers/manipulators/derivatives using Security::Session root.

* Transport issues are largely outside Security:: realm, but we should
continue to use the global ::Connection and other existing
socket-related names/terminology for transport connections. OpenSSL does
not have a specific transport connection type because OpenSSL supports
several different transport abstractions, from can-be-anything BIO to
good-old-socket integer descriptors.

And, as I have begged many times before, let's not add &quot;State&quot;, &quot;Data&quot;,
&quot;Info&quot; and similar suffixes to names. In the vast majority of cases,
they only confuse developers (aha, this is not a class but some kind of
C structure to store &quot;state&quot; or &quot;data&quot;!) and make names longer. The
state of object Foo is the object itself, not some other FooState object.


Thank you,

Alex.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007958.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
	<LI>Next message: <A HREF="007952.html">[squid-dev] [PATCH] VIA creation code duplication
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7959">[ date ]</a>
              <a href="thread.html#7959">[ thread ]</a>
              <a href="subject.html#7959">[ subject ]</a>
              <a href="author.html#7959">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
