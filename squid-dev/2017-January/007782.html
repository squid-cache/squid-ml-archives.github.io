<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SSLv2%20records%20force%20SslBump%20bumping%20despite%0A%20a%20matching%20step2%20peek%20rule.&In-Reply-To=%3Ccf7efa1e-8928-1898-ce13-0ad1759c31e7%40chtsanti.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007781.html">
   <LINK REL="Next"  HREF="007786.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.</H1>
    <B>Christos Tsantilas</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SSLv2%20records%20force%20SslBump%20bumping%20despite%0A%20a%20matching%20step2%20peek%20rule.&In-Reply-To=%3Ccf7efa1e-8928-1898-ce13-0ad1759c31e7%40chtsanti.net%3E"
       TITLE="[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.">christos at chtsanti.net
       </A><BR>
    <I>Thu Jan 12 21:28:39 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="007781.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
        <LI>Next message: <A HREF="007786.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7782">[ date ]</a>
              <a href="thread.html#7782">[ thread ]</a>
              <a href="subject.html#7782">[ subject ]</a>
              <a href="author.html#7782">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/01/2017 06:48 μμ, Alex Rousskov wrote:
&gt;<i> On 01/12/2017 08:35 AM, Christos Tsantilas wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> The patch fixes Squid to peeks (or stares) at the origin server as
</I>&gt;&gt;<i> configured, even if it does not recognize the client TLS
</I>&gt;&gt;<i> record/message.
</I>&gt;<i>
</I>&gt;<i> s/to peeks (or stares)/to peek (or stare)/
</I>&gt;<i>
</I>&gt;<i> I agree that this is the right thing to do, but I have some concerns
</I>&gt;<i> regarding _how_ we are doing that peeking or staring during step3 when
</I>&gt;<i> we essentially failed to get ClientHello during step2. Specifics are below.
</I>
The documentation of the patch is confusing, sorry.

If parsing ClientHello failed, and we are not able to recognize a 
TLS/SSL hello message , we are not bumping.
The on_unsupported_protocol is used to decide how squid will handle this 
request.

I need to recheck how squid-3.5 handle these cases.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>      if (!helloBuild &amp;&amp; (bumpMode_ == Ssl::bumpPeek || bumpMode_ == Ssl::bumpStare)) {
</I>&gt;&gt;<i> +        // it is an SSL Version3 message and it is a Handshake/Hello message
</I>&gt;&gt;<i> +        Must (buf[1] &gt;= 3 &amp;&amp; buf[0] == 0x16);
</I>&gt;<i>
</I>&gt;<i> If this is a Must() now, then we should not combine the two conditions
</I>&gt;<i> so that we know which of them has failed if one of them does. Also, we
</I>&gt;<i> should check the size of the buffer before accessing its contents!
</I>&gt;<i> Finally, it would be good to explain the odd (but correct) order of
</I>&gt;<i> checks. Here is a sketch:
</I>
ok

&gt;<i>
</I>&gt;<i>   /* check that we have a v3+ record containing ClientHello */
</I>&gt;<i>   Must(size &gt;= 2); // enough for version and content_type checks below
</I>&gt;<i>   Must(buf[1] &gt;= 3); // record's version.major
</I>&gt;<i>   // only now we know that we are dealing with supported record format
</I>&gt;<i>   Must(buf[0] == 22); // TLSPlaintext.content_type == handshake in v3+
</I>&gt;<i>
</I>&gt;<i> It is not 100% clear to me why we expect these checks to pass now. It
</I>&gt;<i> probably has something to do with the fact that we are inside BIO (and
</I>&gt;<i> so we expect to deal with SSL traffic) but what if this is an
</I>&gt;<i> unsupported SSL version, session resumption, or some other situation
</I>&gt;<i> where there is no ClientHello? Why do we demand a ClientHello presence
</I>&gt;<i> here? But only in peek or stare modes? I think we need to add a comment
</I>&gt;<i> to clarify all that.
</I>

Actually these checks are not really needed. To fail here it must be 
something very wrong.

The buf  buffer actually holds the TLS Hello message built by OpenSSL 
subsystem. The Must here actually checks if this is really a  TLS/Hello 
message.
The OpenSSL generated message may replaced by the client hello message 
for stare mode, or leave it as is for peek mode.

&gt;<i>
</I>&gt;<i> On a related note, did not we just try to parse the same information
</I>&gt;<i> already when looking at ClientHello? Why not use that parsed info
</I>&gt;<i> instead of re-parsing the same bytes? And if we did not try to parse
</I>&gt;<i> these bytes earlier (for one reason or another; e.g., server-first
</I>&gt;<i> bumping?), perhaps we should not try parsing it here either??
</I>
We are not actually parsing anything. It is just a check, but not on the 
already parsed client hello.


&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> +        auto ssl = fd_table[fd_].ssl.get();
</I>&gt;&gt;<i> +        if (ssl) {
</I>&gt;<i>
</I>&gt;<i> If possible, merge into one statement to avoid leaking the ssl pointer
</I>&gt;<i> name outside the if-statement that ensures it is not nil.
</I>
ok

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>  static bool
</I>&gt;&gt;<i>  adjustSSL(SSL *ssl, Security::TlsDetails::Pointer const &amp;details, SBuf &amp;helloMessage)
</I>&gt;&gt;<i>  {
</I>&gt;&gt;<i> +    if (!details)
</I>&gt;&gt;<i> +        return false;
</I>&gt;<i> ...
</I>&gt;&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> ... but then ...
</I>&gt;<i>
</I>&gt;&gt;<i> +                helloMsg.append(clientHelloMessage);
</I>&gt;<i>
</I>&gt;<i> If details (i.e., clientTlsDetails) are missing, then
</I>&gt;<i> setClientFeatures() was not called. If setClientFeatures() was not
</I>&gt;<i> called, then clientHelloMessage would be missing as well, but we are
</I>&gt;<i> using it unconditionally above, even when adjustSSL() returns false.
</I>&gt;<i> This does not add up IMO. Perhaps we have to require that
</I>&gt;<i> clientTlsDetails are set before we use it?
</I>

The adjustSSL is always return false as is now unless the
SQUID_USE_OPENSSL_HELLO_OVERWRITE_HACK is set.
The  &quot;if(!details) return false;&quot; should moved inside 
SQUID_USE_OPENSSL_HELLO_OVERWRITE_HACK #ifdef.

The setClientFeatures is always called on peek and stare modes.

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>          // If we do not build any hello message, copy the current
</I>&gt;&gt;<i>          if (helloMsg.isEmpty())
</I>&gt;&gt;<i>              helloMsg.append(buf, size);
</I>&gt;<i>
</I>&gt;<i> And if we did build a helloMsg ourselves, then what happens to the buf
</I>&gt;<i> contents (that may not match our clientHelloMessage boundary)? For
</I>&gt;<i> example, how do we know that buf does not contain just 50% of the client
</I>&gt;<i> handshake and that the other 50% would not be later sent after our
</I>
We know this because we prevent actually writing data unless openSSL 
subsystem generates full hello message. The openSSL buffers the output 
and try to write it in one write. If this is change in the future, yes 
we may have problem.

&gt;<i> handshake, corrupting the stream? I think we know this because our
</I>&gt;<i> handshake parser waits until the end of the client handshake, but is it
</I>&gt;<i> possible that we are building helloMsg even though our parser has failed
</I>&gt;<i> (or was not engaged at all)?
</I>
We are talking about Ssl::ServerBio::write. The ServerBio  is used in 
Squid-to-Server communications (still we are confused from server-side 
and client-side names!).
We are not running our parser on Hello messages written to the SSL 
server. The client handshake parser is not involved here.

Did I understand your question?

&gt;<i>
</I>&gt;<i> Perhaps (bumpMode_ == Ssl::bumpPeek || bumpMode_ == Ssl::bumpStare)
</I>&gt;<i> implies that our parser has succeeded?? If yes, then we need a comment
</I>&gt;<i> here to clarify these hidden/assumed dependencies (at least).
</I>
Yes actually this is happens. We are here because our parser 
succeeds.But I do not think a comment required here. It should not exist 
any dependency here.
We need to now the bumping mode, because we have to send OpenSSL 
generated client Hello message to SSL server for stare mode, or replace 
with client hello message for peek mode. Only this.

We need the clientDetails, because we are trying to emulate the major 
TLS settings of the squid client.



&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007781.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
	<LI>Next message: <A HREF="007786.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7782">[ date ]</a>
              <a href="thread.html#7782">[ thread ]</a>
              <a href="subject.html#7782">[ subject ]</a>
              <a href="author.html#7782">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
