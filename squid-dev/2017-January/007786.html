<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SSLv2%20records%20force%20SslBump%20bumping%20despite%0A%20a%20matching%20step2%20peek%20rule.&In-Reply-To=%3Cf2ea3400-6391-bab6-83b4-41a821ad625f%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007782.html">
   <LINK REL="Next"  HREF="007792.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SSLv2%20records%20force%20SslBump%20bumping%20despite%0A%20a%20matching%20step2%20peek%20rule.&In-Reply-To=%3Cf2ea3400-6391-bab6-83b4-41a821ad625f%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.">rousskov at measurement-factory.com
       </A><BR>
    <I>Fri Jan 13 17:04:36 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="007782.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
        <LI>Next message: <A HREF="007792.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7786">[ date ]</a>
              <a href="thread.html#7786">[ thread ]</a>
              <a href="subject.html#7786">[ subject ]</a>
              <a href="author.html#7786">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/12/2017 02:28 PM, Christos Tsantilas wrote:
&gt;<i> On 12/01/2017 06:48 μμ, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 01/12/2017 08:35 AM, Christos Tsantilas wrote:
</I>
&gt;&gt;&gt;<i> The patch fixes Squid to peeks (or stares) at the origin server as
</I>&gt;&gt;&gt;<i> configured, even if it does not recognize the client TLS record/message.
</I>
&gt;&gt;<i> I agree that this is the right thing to do, but I have some concerns
</I>&gt;&gt;<i> regarding _how_ we are doing that peeking or staring during step3 when
</I>&gt;&gt;<i> we essentially failed to get ClientHello during step2.
</I>
&gt;<i> If parsing ClientHello failed, and we are not able to recognize a
</I>&gt;<i> TLS/SSL hello message [then]
</I>&gt;<i> The on_unsupported_protocol is used to decide how squid will handle this
</I>&gt;<i> request.
</I>
I understand what you are saying, and agree with you in principle, but
the code does not express [y]our intentions/understanding well IMO. The
code is currently written as if we may not have a parsed ClientHello but
are still looking at the server and as if we are doubting OpenSSL
abilities to generate ClientHello. The later part I learned/realized
from your email response, which was very helpful, thank you!

Moreover, the very bug you are fixing and the patch preamble clearly
indicate that there are situations where we did not parse the
client-sent ClientHello but still want to look at the server. If we are
actually able to pull that combination off, then our code needs to be
careful not to assume that we always have the parsed client-sent
ClientHello when we are looking at the server.


&gt;&gt;<i>   /* check that we have a v3+ record containing ClientHello */
</I>&gt;&gt;<i>   Must(size &gt;= 2); // enough for version and content_type checks below
</I>&gt;&gt;<i>   Must(buf[1] &gt;= 3); // record's version.major
</I>&gt;&gt;<i>   // only now we know that we are dealing with supported record format
</I>&gt;&gt;<i>   Must(buf[0] == 22); // TLSPlaintext.content_type == handshake in v3+
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is not 100% clear to me why we expect these checks to pass now. It
</I>&gt;&gt;<i> probably has something to do with the fact that we are inside BIO (and
</I>&gt;&gt;<i> so we expect to deal with SSL traffic) but what if this is an
</I>&gt;&gt;<i> unsupported SSL version, session resumption, or some other situation
</I>&gt;&gt;<i> where there is no ClientHello? Why do we demand a ClientHello presence
</I>&gt;&gt;<i> here? But only in peek or stare modes? I think we need to add a comment
</I>&gt;&gt;<i> to clarify all that.
</I>

&gt;<i> The buf  buffer actually holds the TLS Hello message built by OpenSSL
</I>&gt;<i> subsystem. The Must here actually checks if this is really a  TLS/Hello
</I>&gt;<i> message.
</I>
Aha, I was missing this critical piece of information. It still leaves
questions about session resumption and other esoteric scenarios but it
would be easier to address them now.


&gt;<i> The OpenSSL generated message may replaced by the client hello message
</I>&gt;<i> for stare mode, or leave it as is for peek mode.
</I>
I think you meant it the other way around (replace for peeking and leave
for staring). If so, then yes, this is understood. It is the fact that
the message was generated by OpenSSL itself that I was missing in this
context.


&gt;&gt;&gt;<i> +                helloMsg.append(clientHelloMessage);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If details (i.e., clientTlsDetails) are missing, then
</I>&gt;&gt;<i> setClientFeatures() was not called. If setClientFeatures() was not
</I>&gt;&gt;<i> called, then clientHelloMessage would be missing as well, but we are
</I>&gt;&gt;<i> using it unconditionally above, even when adjustSSL() returns false.
</I>&gt;&gt;<i> This does not add up IMO. Perhaps we have to require that
</I>&gt;&gt;<i> clientTlsDetails are set before we use it?
</I>

&gt;<i> The setClientFeatures is always called on peek and stare modes.
</I>
AFAICT, setClientFeatures() was not called in peek and stare modes if we
failed to parse client-sent ClientHello. In the patched code,
setClientFeatures() is always called in those modes, but possibly with
nil/missing details and perhaps even with a partial or empty client-sent
ClientHello buffer (that becomes clientHelloMessage).

If we failed to parse the client-sent ClientHello, we cannot be sure
that cltBio-&gt;rBufData() contains some ClientHello bytes, contains the
entire client-sent ClientHello, and nothing else, right?

For example, we _cannot_ add the following check to
Ssl::ServerBio::write() because it will fail in some peeking/staring
cases, right?

  // client-sent ClientHello must be successfully parsed for peek/stare
  Must(!clientHelloMessage.isEmpty());


If my understanding is correct, then the code in Ssl::ServerBio::write()
has to check clientHelloMessage before using it. I do not see those
checks in the patched code.


I also suggest renaming clientHelloMessage to clientSentHelloMessage or
just clientSentHello to remove the current clash between two &quot;clients&quot;
(one agent as in &quot;client-sent&quot; and one the type of the Hello message as
in &quot;ClientHello&quot;.


&gt;&gt;&gt;<i>          // If we do not build any hello message, copy the current
</I>&gt;&gt;&gt;<i>          if (helloMsg.isEmpty())
</I>&gt;&gt;&gt;<i>              helloMsg.append(buf, size);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> And if we did build a helloMsg ourselves, then what happens to the buf
</I>&gt;&gt;<i> contents (that may not match our clientHelloMessage boundary)? For
</I>&gt;&gt;<i> example, how do we know that buf does not contain just 50% of the client
</I>&gt;&gt;<i> handshake and that the other 50% would not be later sent after our
</I>
&gt;<i> We know this because we prevent actually writing data unless openSSL
</I>&gt;<i> subsystem generates full hello message. The openSSL buffers the output
</I>&gt;<i> and try to write it in one write. If this is change in the future, yes
</I>&gt;<i> we may have problem.
</I>
I would document that. For example:

  // buf contains OpenSSL-generated ClientHello. We assume it has a
  // complete ClientHello and nothing else, but cannot fully verify
  // that quickly. We only verify that buf starts with a v3+ record
  // containing ClientHello.
  Must(size &gt;= 2); // enough for version and content_type checks below
  Must(buf[1] &gt;= 3); // record's version.major; determines buf[0] meaning
  Must(buf[0] == 22); // TLSPlaintext.content_type == handshake in v3+


&gt;<i> It should not exist any dependency here.
</I>
The dependency here is that clientHelloMessage comes from our parser. We
can substitute OpenSSL-generated ClientHello with client-sent
ClientHello because/if we successfully parsed and stored the latter. I
think we should validate clientHelloMessage/parsing state before using
clientHelloMessage. For example, we should do either something like this

  // Replace OpenSSL-generated ClientHello with client-sent one.
  // It must be available for peek and stare modes.
  // XXX: Staring does not really require the client-sent ClientHello.
  Must(!clientHelloMessage.isEmpty());
  helloMsg.append(clientHelloMessage);

or something like that

  if (clientHelloMessage.isEmpty()) {
      /* failed to parse client-sent ClientHello */
      if (bumpMode_ == Ssl::bumpPeek)
          ... cannot peek at the server (should not even get here??) ...
      else /* stare */
          ... can stare, but with OpenSSL-generated ClientHello only ...
  } else { /* have parsed client-sent ClientHello */
      if (bumpMode_ == Ssl::bumpPeek) {
          allowBump = adjustSsl();
          helloMsg.append(clientHelloMessage);
      } else /* stare */
      if (adjustSSL) {
          allowSplice = true
          helloMsg.append(clientHelloMessage);
      } else
          ... can stare, but with OpenSSL-generated ClientHello only ...
  }

As you can see, I am still struggling with the desire to peek at the
server even if we failed to peek at the client (the core issue you are
trying to address). Peeking essentially requires forwarding client-sent
data, right? Can we forward the bytes that we failed to parse? How would
we know how many bytes to send (i.e., when to stop accumulating
client-sent bytes that we cannot parse)?! I have a feeling that
something is still missing in this area. Perhaps &quot;failure to parse&quot; is
not a yes/no binary state but has some shades like &quot;failed to parse the
details but know where the ClientHello record ends&quot;?


Finally, if we are not replacing and/or adjusting buf (for any reason),
then we should probably _not_ check buf contents and clientHelloMessage
presence. The lack of unnecessary checks will make the code more robust.


&gt;<i> debugs(83, 7,  &quot;SSL HELLO message for FD &quot; &lt;&lt; fd_ &lt;&lt; &quot;: Random number is adjusted for ... mode&quot;);
</I>
I would replace the old &quot;Random number...&quot; text with &quot;Using client-sent
ClientHello for ... mode&quot; text. We are replacing the whole ClientHello
here, and not just adjusting the random number. There are two such
debugging lines, one for each mode.


&gt;<i>          // If we do not build any hello message, copy the current
</I>
Similarly, I would say &quot;if we did not use the client-sent ClientHello,
then use the OpenSSL-generated one&quot; here to clarify.



&gt;<i> The  &quot;if(!details) return false;&quot; should moved inside
</I>&gt;<i> SQUID_USE_OPENSSL_HELLO_OVERWRITE_HACK #ifdef.
</I>
Yes, please.


Thank you,

Alex.

</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007782.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
	<LI>Next message: <A HREF="007792.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7786">[ date ]</a>
              <a href="thread.html#7786">[ thread ]</a>
              <a href="subject.html#7786">[ subject ]</a>
              <a href="author.html#7786">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
