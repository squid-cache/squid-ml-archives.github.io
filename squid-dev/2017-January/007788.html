<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20initial%20GnuTLS%20support%20for%20encrypted%20server%0A%20connections&In-Reply-To=%3Cea7be114-5a6f-6e24-8741-500b8bbc375a%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007787.html">
   <LINK REL="Next"  HREF="007795.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20initial%20GnuTLS%20support%20for%20encrypted%20server%0A%20connections&In-Reply-To=%3Cea7be114-5a6f-6e24-8741-500b8bbc375a%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections">rousskov at measurement-factory.com
       </A><BR>
    <I>Sun Jan 15 07:09:06 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="007787.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server	connections
</A></li>
        <LI>Next message: <A HREF="007795.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7788">[ date ]</a>
              <a href="thread.html#7788">[ thread ]</a>
              <a href="subject.html#7788">[ subject ]</a>
              <a href="author.html#7788">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/14/2017 10:16 AM, Amos Jeffries wrote:

&gt;<i> The Security::SessionPointer is converted to std::shared_ptr. This is
</I>&gt;<i> required because GnuTLS does not expose the locking like OpenSSL. Since
</I>&gt;<i> we store the SessionPointer to fd_table[].ssl we can always access it
</I>&gt;<i> from there one way or another and there is actually no need for OpenSSL
</I>&gt;<i> locking sessions now.
</I>
&gt;<i> -typedef Security::LockingPointer&lt;SSL, Security::SSL_free_cpp, HardFun&lt;int, SSL *, SSL_up_ref&gt; &gt; SessionPointer;
</I>&gt;<i> +typedef std::shared_ptr&lt;SSL&gt; SessionPointer;
</I>
I am trying to understand how a standard std::shared_ptr can co-exist
with OpenSSL locking. Even if Squid does not lock the SSL object,
OpenSSL would still lock and unlock it, destroying the SSL object when
its OpenSSL lock counter reaches zero, regardless of our
std::shared_ptr&lt;SSL&gt; state. What am I missing?

Also, if OpenSSL requires that the SSL object is freed using an
SSL_free() function, how can std::shared_ptr&lt;SSL&gt; be compatible with
OpenSSL without that knowledge?

Does the patched code continue to work well with OpenSSL?


&gt;<i>      // Our job is done. The callabck recepient will probably close the failed
</I>&gt;<i>      // peer connection and try another peer or go direct (if possible). We
</I>&gt;<i>      // can close the connection ourselves (our error notification would reach
</I>&gt;<i>      // the recepient before the fd-closure notification), but we would rather
</I>&gt;<i>      // minimize the number of fd-closure notifications and let the recepient
</I>&gt;<i>      // manage the TCP state of the connection.
</I>&gt;<i> +
</I>&gt;<i> +#if USE_GNUTLS
</I>&gt;<i> +    // but we do need to release the bad TLS related details in fd_table
</I>&gt;<i> +    // ... or GnuTLS will SEGFAULT.
</I>&gt;<i> +    const int fd = serverConnection()-&gt;fd;
</I>&gt;<i> +    Security::SessionClose(fd_table[fd].ssl, fd);
</I>&gt;<i> +#endif
</I>

The &quot;or GnuTLS will SEGFAULT&quot; part is a red flag for me. Squid may close
the connection without or before reaching this particular method (for a
variety of reasons). A connection closure should always be safe. Please
explain why the usual connection closing steps cannot &quot;release the bad
TLS related details in fd_table&quot; [but the above code can].

And why should GnuTLS be treated as a special case here compared to OpenSSL?


&gt;<i> +#if !USE_OPENSSL &amp;&amp; USE_GNUTLS
</I>&gt;<i> +typedef std::unique_ptr&lt;struct gnutls_priority_st, HardFun&lt;void, gnutls_priority_t, &amp;gnutls_priority_deinit&gt;&gt; ParsedOptionsPointer;
</I>&gt;<i> +#else
</I>&gt;<i> +typedef std::unique_ptr&lt;long&gt; ParsedOptionsPointer;
</I>&gt;<i> +#endif
</I>
It looks strange that GnuTLS is OK with std::unique_ptr&lt;long&gt; as a
ParsedOptionsPointer when built together with OpenSSL but not when built
alone. I doubt that is what you meant, but that is how this #if
statement reads.


&gt;<i> +    // 'options=' value being set to session is a GnuTLS specific thing.
</I>&gt;<i> +#if !USE_OPENSSL &amp;&amp; USE_GNUTLS
</I>
A similar concern here: If options value being set to session is a
GnuTLS-specific thing, why is the code not executed for GnuTLS when it
is built together with OpenSSL? In other words, why mention OpenSSL in a
GnuTLS-specific code?

I suspect that we can never build with both OpenSSL and GnuTLS enabled
at the same time. If that assumption is correct, then please remove the
!USE_OPENSSL part from these (and any similar) conditions. They only
create unnecessary doubts. And add an OpenSSL-specific conditions
elsewhere as/if needed, of course.


&gt;<i> +#if !USE_OPENSSL &amp;&amp; USE_GNUTLS
</I>&gt;<i> +typedef std::unique_ptr&lt;struct gnutls_priority_st, HardFun&lt;void, gnutls_priority_t, &amp;gnutls_priority_deinit&gt;&gt; ParsedOptionsPointer;
</I>&gt;<i> +#else
</I>&gt;<i> +typedef std::unique_ptr&lt;long&gt; ParsedOptionsPointer;
</I>&gt;<i> +#endif
</I>
Why does OpenSSL need a pointer here? Can we do something like the
following instead?

#if USE_GNUTLS
    typedef std::unique_ptr&lt;...&gt; ParsedOptions;
#elsif USE_OPENSSL
    typedef long ParsedOptions;
#endif


&gt;<i> -                parsedOptions |= SSL_OP_NO_TLSv1;
</I>&gt;<i> +                *parsedOptions |= SSL_OP_NO_TLSv1;
</I>
and

&gt;<i> +        SSL_CTX_set_options(t.get(), (setOptions ? *parsedOptions : 0));
</I>
and

&gt;<i> +    SSL_CTX_set_options(ctx.get(), *port.secure.parsedOptions);
</I>
...


What if parsedOptions is nil here? parseOptions() are not called if
sslOptions are empty and if there are no options=... in configuration so
parsedOptions might be nil in some cases. I do not know whether we are
lucky that they are never nil in these particular cases.

Moreover, should not the options always be initialized, even when
sslOptions are empty, so that we do not need to worry about their
pointer being nil? For OpenSSL where there is no
gnutls_set_default_priority(), but even that code can use empty
sslOptions string to detect that defaults are in use. After all, OpenSSL
was fine with non-pointer options before these changes...


&gt;<i> +    const char *priorities = (sslOptions.isEmpty() ? nullptr : sslOptions.c_str());
</I>&gt;<i> +    int x = gnutls_priority_init(&amp;op, priorities, &amp;err);
</I>
Are you sure gnutls_priority_init() can handle nil priorities c-string?
Just checking -- the manual page does not say...

BTW, you can make &quot;x&quot; constant here. Giving it a more telling name like
&quot;result&quot; here and in similar code would be nice too.


&gt;<i> +        fatalf(&quot;Unknown TLS option '%s'&quot;, err);
</I>
s/option/option near/ -- the err does not isolate the unknown option name.


&gt;<i> +        debugs(83, 1, &quot;Failed to set TLS options. error: &quot; &lt;&lt; Security::ErrorString(x));
</I>
Use DBG_IMPORTANT instead of 1?

It would be nice to print sslOptions that we failed to set (in case of
non-nil parsedOptions) or mention that they were &quot;default&quot; (otherwise).



&gt;<i>  {
</I>&gt;<i> +    if (!sslOptions.isEmpty())
</I>&gt;<i> +        parseOptions(parsedOptions); // re-parse after sslOptions copied.
</I>&gt;<i>      memcpy(&amp;flags, &amp;p.flags, sizeof(flags));
</I>&gt;<i>  }
</I>
Have you considered using a shared_ptr for GnuTLS so that we do not have
to reparse when copying? Doing so might also eliminate the need to
change the parseOptions() API and write confusing phrases like

   parseOptions(parsedOptions)

Since OpenSSL and GnuTLS use these options very differently, I doubt
both have to be pointers, but you know better.


&gt;<i> +Security::PeerOptions::operator =(const Security::PeerOptions &amp;p)
</I>&gt;<i> +{
</I>&gt;<i> +    sslOptions = p.sslOptions;
</I>&gt;<i> +    if (!sslOptions.isEmpty())
</I>&gt;<i> +        parseOptions(parsedOptions); // re-parse after sslOptions copied.
</I>
Missing parseOptions reset when p.sslOptions are empty but
this-&gt;sslOptions where not.


&gt;<i>  #if USE_OPENSSL
</I>&gt;<i> +        // NP: GnuTLS uses 'priorities' which are set per-session instead.
</I>&gt;<i> +        SSL_CTX_set_options(t.get(), (setOptions ? *parsedOptions : 0));
</I>&gt;<i> +
</I>&gt;<i>          // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
</I>&gt;<i> -        Ssl::InitClientContext(t, *this, (setOptions ? parsedOptions : 0), parsedFlags);
</I>&gt;<i> +        Ssl::InitClientContext(t, *this, parsedFlags);
</I>&gt;<i>  #endif
</I>

It feels like the SSL_CTX_set_options() call belongs to the
InitClientContext() function. I can easily imagine somebody moving the
InitClientContext() call while forgetting to move the
SSL_CTX_set_options() call with it. InitClientContext() is supposed to
initialize the context and setting options is one of the initialization
steps...

BTW, is that XXX comment about c_str() stale? I do not see a c_str in
this code...


&gt;<i> +        BIO_TO_CLIENT = GNUTLS_SERVER,
</I>&gt;<i> +        BIO_TO_SERVER = GNUTLS_CLIENT
</I>
BIO_WITH_CLIENT and BIO_WITH_SERVER may be better names for
_bidirectional_ I/O. Might as well fix this if you have to touch all the
code using these names anyway.


&gt;<i> +Security::PeerOptions::parseOptions(Security::ParsedOptionsPointer &amp;theOut)
</I>
Please do not use the prefix &quot;the&quot; for parameter names. The prefix is
used for [older] class data member names so naming method parameters
with that prefix confuses the reader of the method who keeps looking for
a data member named theOut.

Moreover, if the parseOptions() method is always called with the
parsedOptions argument that is a data member of the same PeerOptions
class, then why do you need to pass parsedOptions as a parameter at all?
The method can just reset parsedOptions directly.


&gt;<i> +/// close an active TLS session.
</I>&gt;<i> +/// set fdOnError to the connection FD when the session is being closed
</I>&gt;<i> +/// due to an encryption error, otherwise omit.
</I>&gt;<i> +void SessionClose(const Security::SessionPointer &amp;, int fdOnError = -1);
</I>
Please split SessionClose() into two different functions, one for each
use case (initiating proper SSL connection closure vs. immediate SSL
connection state destruction). Mixing the two actions results in
confusing API instructions and dangerous usage/implementation IMO.

I suggest StartSessionClosing() and DestroySession() names (while going
along with the current terrible choice of calling both SSL connections
and SSL sessions &quot;sessions&quot; which leads to code that close an SSL
&quot;session&quot; while reusing the associated SSL session!).


Thank you,

Alex.

</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007787.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server	connections
</A></li>
	<LI>Next message: <A HREF="007795.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7788">[ date ]</a>
              <a href="thread.html#7788">[ thread ]</a>
              <a href="subject.html#7788">[ subject ]</a>
              <a href="author.html#7788">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
