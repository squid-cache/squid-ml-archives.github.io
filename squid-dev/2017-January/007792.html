<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SSLv2%20records%20force%20SslBump%20bumping%20despite%0A%20a%20matching%20step2%20peek%20rule.&In-Reply-To=%3C6565a792-bf7f-00e5-0b2d-d9c6aaa4981c%40chtsanti.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007786.html">
   <LINK REL="Next"  HREF="007864.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.</H1>
    <B>Christos Tsantilas</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20SSLv2%20records%20force%20SslBump%20bumping%20despite%0A%20a%20matching%20step2%20peek%20rule.&In-Reply-To=%3C6565a792-bf7f-00e5-0b2d-d9c6aaa4981c%40chtsanti.net%3E"
       TITLE="[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.">christos at chtsanti.net
       </A><BR>
    <I>Mon Jan 16 11:38:17 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="007786.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
        <LI>Next message: <A HREF="007864.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7792">[ date ]</a>
              <a href="thread.html#7792">[ thread ]</a>
              <a href="subject.html#7792">[ subject ]</a>
              <a href="author.html#7792">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I am attaching a new patch based on Alex comments.
I also changed the patch preamble a little to much better what squid does.

Please see my comments bellow.

On 13/01/2017 07:04 μμ, Alex Rousskov wrote:
&gt;<i> On 01/12/2017 02:28 PM, Christos Tsantilas wrote:
</I>&gt;&gt;<i> On 12/01/2017 06:48 μμ, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> On 01/12/2017 08:35 AM, Christos Tsantilas wrote:
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The patch fixes Squid to peeks (or stares) at the origin server as
</I>&gt;&gt;&gt;&gt;<i> configured, even if it does not recognize the client TLS record/message.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> I agree that this is the right thing to do, but I have some concerns
</I>&gt;&gt;&gt;<i> regarding _how_ we are doing that peeking or staring during step3 when
</I>&gt;&gt;&gt;<i> we essentially failed to get ClientHello during step2.
</I>&gt;<i>
</I>&gt;&gt;<i> If parsing ClientHello failed, and we are not able to recognize a
</I>&gt;&gt;<i> TLS/SSL hello message [then]
</I>&gt;&gt;<i> The on_unsupported_protocol is used to decide how squid will handle this
</I>&gt;&gt;<i> request.
</I>&gt;<i>
</I>&gt;<i> I understand what you are saying, and agree with you in principle, but
</I>&gt;<i> the code does not express [y]our intentions/understanding well IMO. The
</I>&gt;<i> code is currently written as if we may not have a parsed ClientHello but
</I>&gt;<i> are still looking at the server and as if we are doubting OpenSSL
</I>&gt;<i> abilities to generate ClientHello. The later part I learned/realized
</I>&gt;<i> from your email response, which was very helpful, thank you!
</I>&gt;<i>
</I>&gt;<i> Moreover, the very bug you are fixing and the patch preamble clearly
</I>&gt;<i> indicate that there are situations where we did not parse the
</I>&gt;<i> client-sent ClientHello but still want to look at the server. If we are
</I>
Yep this is true.
Currently the code considers unknown protocol if we failed to parse 
Hello message. But I hope we are able to parse (all of? / most of?) 
SSLv2 and SSLv3/TLS  messages.


&gt;<i> actually able to pull that combination off, then our code needs to be
</I>&gt;<i> careful not to assume that we always have the parsed client-sent
</I>&gt;<i> ClientHello when we are looking at the server.
</I>
Yes, I agree.
The Ssl::PeekingPeerConnector class and Ssl::ServerBio is better to 
assume that it may receive requests initiated from unsupported TLS messages.


&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +                helloMsg.append(clientHelloMessage);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If details (i.e., clientTlsDetails) are missing, then
</I>&gt;&gt;&gt;<i> setClientFeatures() was not called. If setClientFeatures() was not
</I>&gt;&gt;&gt;<i> called, then clientHelloMessage would be missing as well, but we are
</I>&gt;&gt;&gt;<i> using it unconditionally above, even when adjustSSL() returns false.
</I>&gt;&gt;&gt;<i> This does not add up IMO. Perhaps we have to require that
</I>&gt;&gt;&gt;<i> clientTlsDetails are set before we use it?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> The setClientFeatures is always called on peek and stare modes.
</I>&gt;<i>
</I>&gt;<i> AFAICT, setClientFeatures() was not called in peek and stare modes if we
</I>&gt;<i> failed to parse client-sent ClientHello. In the patched code,
</I>
Currently if we fail to parse client-sent clientHello message we are not 
going to proceed with peek/stare modes. It will be considered as foreign 
protocol.

But as you said, we must not assume we have parsed client-sent hello. 
At least for PeekingPeerConnector and ServerBio code.

&gt;<i> setClientFeatures() is always called in those modes, but possibly with
</I>&gt;<i> nil/missing details and perhaps even with a partial or empty client-sent
</I>&gt;<i> ClientHello buffer (that becomes clientHelloMessage).
</I>
yep.

&gt;<i>
</I>&gt;<i> If we failed to parse the client-sent ClientHello, we cannot be sure
</I>&gt;<i> that cltBio-&gt;rBufData() contains some ClientHello bytes, contains the
</I>&gt;<i> entire client-sent ClientHello, and nothing else, right?
</I>
True.

&gt;<i>
</I>&gt;<i> For example, we _cannot_ add the following check to
</I>&gt;<i> Ssl::ServerBio::write() because it will fail in some peeking/staring
</I>&gt;<i> cases, right?
</I>&gt;<i>
</I>&gt;<i>   // client-sent ClientHello must be successfully parsed for peek/stare
</I>&gt;<i>   Must(!clientHelloMessage.isEmpty());
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If my understanding is correct, then the code in Ssl::ServerBio::write()
</I>&gt;<i> has to check clientHelloMessage before using it. I do not see those
</I>&gt;<i> checks in the patched code.
</I>
Yes we must add such checks.


&gt;<i> I also suggest renaming clientHelloMessage to clientSentHelloMessage or
</I>&gt;<i> just clientSentHello to remove the current clash between two &quot;clients&quot;
</I>&gt;<i> (one agent as in &quot;client-sent&quot; and one the type of the Hello message as
</I>&gt;<i> in &quot;ClientHello&quot;.
</I>
I rename it to clientSentHello


&gt;&gt;&gt;&gt;<i>          // If we do not build any hello message, copy the current
</I>&gt;&gt;&gt;&gt;<i>          if (helloMsg.isEmpty())
</I>&gt;&gt;&gt;&gt;<i>              helloMsg.append(buf, size);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> And if we did build a helloMsg ourselves, then what happens to the buf
</I>&gt;&gt;&gt;<i> contents (that may not match our clientHelloMessage boundary)? For
</I>&gt;&gt;&gt;<i> example, how do we know that buf does not contain just 50% of the client
</I>&gt;&gt;&gt;<i> handshake and that the other 50% would not be later sent after our
</I>&gt;<i>
</I>&gt;&gt;<i> We know this because we prevent actually writing data unless openSSL
</I>&gt;&gt;<i> subsystem generates full hello message. The openSSL buffers the output
</I>&gt;&gt;<i> and try to write it in one write. If this is change in the future, yes
</I>&gt;&gt;<i> we may have problem.
</I>&gt;<i>
</I>&gt;<i> I would document that. For example:
</I>&gt;<i>
</I>&gt;<i>   // buf contains OpenSSL-generated ClientHello. We assume it has a
</I>&gt;<i>   // complete ClientHello and nothing else, but cannot fully verify
</I>&gt;<i>   // that quickly. We only verify that buf starts with a v3+ record
</I>&gt;<i>   // containing ClientHello.
</I>&gt;<i>   Must(size &gt;= 2); // enough for version and content_type checks below
</I>&gt;<i>   Must(buf[1] &gt;= 3); // record's version.major; determines buf[0] meaning
</I>&gt;<i>   Must(buf[0] == 22); // TLSPlaintext.content_type == handshake in v3+
</I>
OK

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> It should not exist any dependency here.
</I>&gt;<i>
</I>&gt;<i> The dependency here is that clientHelloMessage comes from our parser. We
</I>&gt;<i> can substitute OpenSSL-generated ClientHello with client-sent
</I>&gt;<i> ClientHello because/if we successfully parsed and stored the latter. I
</I>&gt;<i> think we should validate clientHelloMessage/parsing state before using
</I>&gt;<i> clientHelloMessage. For example, we should do either something like this
</I>&gt;<i>
</I>&gt;<i>   // Replace OpenSSL-generated ClientHello with client-sent one.
</I>&gt;<i>   // It must be available for peek and stare modes.
</I>&gt;<i>   // XXX: Staring does not really require the client-sent ClientHello.
</I>&gt;<i>   Must(!clientHelloMessage.isEmpty());
</I>&gt;<i>   helloMsg.append(clientHelloMessage);
</I>&gt;<i>
</I>&gt;<i> or something like that
</I>&gt;<i>
</I>&gt;<i>   if (clientHelloMessage.isEmpty()) {
</I>&gt;<i>       /* failed to parse client-sent ClientHello */
</I>&gt;<i>       if (bumpMode_ == Ssl::bumpPeek)
</I>&gt;<i>           ... cannot peek at the server (should not even get here??) ...
</I>&gt;<i>       else /* stare */
</I>&gt;<i>           ... can stare, but with OpenSSL-generated ClientHello only ...
</I>&gt;<i>   } else { /* have parsed client-sent ClientHello */
</I>&gt;<i>       if (bumpMode_ == Ssl::bumpPeek) {
</I>&gt;<i>           allowBump = adjustSsl();
</I>&gt;<i>           helloMsg.append(clientHelloMessage);
</I>&gt;<i>       } else /* stare */
</I>&gt;<i>       if (adjustSSL) {
</I>&gt;<i>           allowSplice = true
</I>&gt;<i>           helloMsg.append(clientHelloMessage);
</I>&gt;<i>       } else
</I>&gt;<i>           ... can stare, but with OpenSSL-generated ClientHello only ...
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i> As you can see, I am still struggling with the desire to peek at the
</I>&gt;<i> server even if we failed to peek at the client (the core issue you are
</I>&gt;<i> trying to address). Peeking essentially requires forwarding client-sent
</I>&gt;<i> data, right? Can we forward the bytes that we failed to parse? How would
</I>&gt;<i> we know how many bytes to send (i.e., when to stop accumulating
</I>&gt;<i> client-sent bytes that we cannot parse)?! I have a feeling that
</I>&gt;<i> something is still missing in this area. Perhaps &quot;failure to parse&quot; is
</I>&gt;<i> not a yes/no binary state but has some shades like &quot;failed to parse the
</I>&gt;<i> details but know where the ClientHello record ends&quot;?
</I>
I select a little different form.
a Must(clientSentHello) for peek mode and for stare mode allow adjustSSL 
only if clientSentHello is not null.

Actually the clientSentHello required only for peek mode.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Finally, if we are not replacing and/or adjusting buf (for any reason),
</I>&gt;<i> then we should probably _not_ check buf contents and clientHelloMessage
</I>&gt;<i> presence. The lack of unnecessary checks will make the code more robust.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> debugs(83, 7,  &quot;SSL HELLO message for FD &quot; &lt;&lt; fd_ &lt;&lt; &quot;: Random number is adjusted for ... mode&quot;);
</I>&gt;<i>
</I>&gt;<i> I would replace the old &quot;Random number...&quot; text with &quot;Using client-sent
</I>&gt;<i> ClientHello for ... mode&quot; text. We are replacing the whole ClientHello
</I>&gt;<i> here, and not just adjusting the random number. There are two such
</I>&gt;<i> debugging lines, one for each mode.
</I>
fixed

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>          // If we do not build any hello message, copy the current
</I>&gt;<i>
</I>&gt;<i> Similarly, I would say &quot;if we did not use the client-sent ClientHello,
</I>&gt;<i> then use the OpenSSL-generated one&quot; here to clarify.
</I>&gt;<i>
</I>
fixed

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> The  &quot;if(!details) return false;&quot; should moved inside
</I>&gt;&gt;<i> SQUID_USE_OPENSSL_HELLO_OVERWRITE_HACK #ifdef.
</I>
fixed.

&gt;<i>
</I>&gt;<i> Yes, please.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>

-- 
Tsantilas Christos
Network and Systems Engineer
email:<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">christos at chtsanti.net</A>
   web:<A HREF="http://www.chtsanti.net">http://www.chtsanti.net</A>
Phone:+30 6977678842
-------------- next part --------------
A non-text attachment was scrubbed...
Name: SQUID-241-SSL-v2-records-force-step2-bumping-t3.patch
Type: text/x-patch
Size: 12952 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20170116/20a165fd/attachment-0001.bin">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20170116/20a165fd/attachment-0001.bin</A>&gt;
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007786.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
	<LI>Next message: <A HREF="007864.html">[squid-dev] [PATCH] SSLv2 records force SslBump bumping despite a matching step2 peek rule.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7792">[ date ]</a>
              <a href="thread.html#7792">[ thread ]</a>
              <a href="subject.html#7792">[ subject ]</a>
              <a href="author.html#7792">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
