<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20initial%20GnuTLS%20support%20for%20encrypted%20server%0A%20connections&In-Reply-To=%3C3db2b662-4014-4c14-4c53-a8fdafd2fb12%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="007796.html">
   <LINK REL="Next"  HREF="007806.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20initial%20GnuTLS%20support%20for%20encrypted%20server%0A%20connections&In-Reply-To=%3C3db2b662-4014-4c14-4c53-a8fdafd2fb12%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Jan 19 19:11:41 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="007796.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
        <LI>Next message: <A HREF="007806.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7797">[ date ]</a>
              <a href="thread.html#7797">[ thread ]</a>
              <a href="subject.html#7797">[ subject ]</a>
              <a href="author.html#7797">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/19/2017 12:16 AM, Amos Jeffries wrote:
&gt;<i> On 15/01/2017 8:09 p.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> I am trying to understand how a standard std::shared_ptr can co-exist
</I>&gt;&gt;<i> with OpenSSL locking.
</I>
&gt;<i> whenever the shared_ptr has a non-nil value the library lock count is &gt;= 1.
</I>
Understood, thank you. This looks safe indeed. I do not like that we
make it possible, even trivial, to create a bogus OpenSSL SessionPointer
object that does not call SSL_free() but it may be difficult to fully
address that.


&gt;<i> +    Security::SessionPointer session(SSL_new(ctx.get()), [](SSL *p) {
</I>&gt;<i> +            debugs(83, 5, &quot;SSL_free session=&quot; &lt;&lt; (void*)p);
</I>&gt;<i> +            SSL_free(p);
</I>&gt;<i> +        });
</I>&gt;<i> +    debugs(83, 5, &quot;SSL_new session=&quot; &lt;&lt; (void*)session.get());
</I>
and

&gt;<i> +    Security::SessionPointer ssl(SSL_new(ctx.get()), [](SSL *p) {
</I>&gt;<i> +            debugs(83, 5, &quot;SSL_free session=&quot; &lt;&lt; (void*)p);
</I>&gt;<i> +            SSL_free(p);
</I>&gt;<i> +        });
</I>&gt;<i> +    debugs(83, 5, &quot;SSL_new session=&quot; &lt;&lt; (void*)ssl.get());
</I>

To avoid code duplication and to reduce the chances of bogus
SessionPointer creation, please add an Security::MakeConnection()
function that does the above and returns Security::SessionPointer.
Please double check that all SSL_new() calls in the code happen inside
the new wrapper after your changes.



&gt;&gt;<i> Does the patched code continue to work well with OpenSSL?
</I>
You have not answered this question. Please do not commit these changes
until the OpenSSL build is tested.


&gt;&gt;&gt;<i> +#if !USE_OPENSSL &amp;&amp; USE_GNUTLS
</I>&gt;&gt;&gt;<i> +typedef std::unique_ptr&lt;struct gnutls_priority_st, HardFun&lt;void, gnutls_priority_t, &amp;gnutls_priority_deinit&gt;&gt; ParsedOptionsPointer;
</I>&gt;&gt;&gt;<i> +#else
</I>&gt;&gt;&gt;<i> +typedef std::unique_ptr&lt;long&gt; ParsedOptionsPointer;
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It looks strange that GnuTLS is OK with std::unique_ptr&lt;long&gt; as a
</I>&gt;&gt;<i> ParsedOptionsPointer when built together with OpenSSL but not when built
</I>&gt;&gt;<i> alone. I doubt that is what you meant, but that is how this #if
</I>&gt;&gt;<i> statement reads.
</I>&gt;<i> 
</I>&gt;<i> That is exactly what I meant there and elsewhere with the same.
</I>
Your explanation shows that this is not quite what you meant here. You
meant that GnuTLS is not used [as far as ParsedOptions are concerned]
when OpenSSL is available. This code does not reflect that intent well.
Please rewrite along these lines:

#if USE_OPENSSL
    typedef long ParsedOptions;
#elsif USE_GNUTLS
    typedef std::shared_ptr&lt;...&gt; ParsedOptions;
#else
    // we never parse/use TLS options in this case
    class ParsedOptions {};
#endif

Replacing the empty class with &quot;long&quot; is OK if really necessary, but
please do use three separate clauses for the three separate cases.

Any #if !USE_OPENSSL &amp;&amp; USE_GNUTLS statements without the #else part can
stay the same because they are clear enough. However, please consider
clarifying them and avoiding future code repetition by adding a
USING_GNUTLS_ALONE macro.


[ BTW, please do not misinterpret my comments as being content with
supporting builds using both SSL libraries at the same time. Allowing
that complexity was wrong IMO, but it is probably too late to revert
that, and this thread is probably not the right place to discuss that
decision anyway. ]


&gt;<i> Double-checking that I've found a few that were not. They are now also
</I>&gt;<i> fixed in this updated patch.
</I>
I found one more case where USE_GNUTLS overwrites USE_OPENSSL: The
BIO_TO_* declarations in src/security/forward.h.

I only checked the patch, not the rest of the code though.


&gt;&gt;&gt;<i> +        fatalf(&quot;Unknown TLS option '%s'&quot;, err);
</I>
&gt;&gt;<i> s/option/option near/ -- the err does not isolate the unknown option name.
</I>
&gt;<i> The err is pointed to the start of the option(s) which is unknown.
</I>
I know. From the error message reader point of view, it may not print
the unknown TLS option though. It may print more than that. For example,
the following would be misleading for an admin that knows that both
SECURE256 and EXPORT are valid/known TLS options:

    FATAL: Unknown TLS option 'SECURE256,EXPORT'

The &quot;near&quot; or &quot;starting at&quot; would improve this:

    FATAL: Unknown TLS option near 'SECURE256,EXPORT'

In fact, I would probably relax it even further by saying

    FATAL: Unable to parse GnuTLS options near 'SECURE256,EXPORT'

Not a big deal, of course.


&gt;<i> The equivalent OpenSSL logic does the same output, but for each
</I>&gt;<i> individual broken option as an ERROR message. And does not exit with
</I>&gt;<i> fatal. Which is unfortunately not [yet] possible for GnuTLS.
</I>
AFAICT, it is possible but you decided not to implement it that way. I
think your decision was the right one: Relying on the built-in GnuTLS
options parser is probably better than adding our own parsing bugs.

BTW, squid.conf.documented is missing a reference to GnuTLS options
AFAICT. I doubt we should document each supported option, but we should
tell the reader that GnuTLS options are not OpenSSL options, give an
example, and point to the right external GnuTLS/OpenSSL documentation
for details.


&gt;&gt;&gt;<i> +Security::PeerOptions::operator =(const Security::PeerOptions &amp;p)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +    sslOptions = p.sslOptions;
</I>&gt;&gt;&gt;<i> +    if (!sslOptions.isEmpty())
</I>&gt;&gt;&gt;<i> +        parseOptions(parsedOptions); // re-parse after sslOptions copied.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Missing parseOptions reset when p.sslOptions are empty but
</I>&gt;&gt;<i> this-&gt;sslOptions where not.
</I>&gt;<i> 
</I>&gt;<i> Done by removing the if and using shared_ptr. Same in copy-constructor.
</I>
How about defaulting both the custom assignment operator and the custom
copy-constructor instead? If their current implementation is correct,
then I do not see why those two methods need a hand-written
implementation, and I see that their current implementation is badly
violating flags_[::YesNoNone] boundaries.


&gt;&gt;&gt;<i> +/// close an active TLS session.
</I>&gt;&gt;&gt;<i> +/// set fdOnError to the connection FD when the session is being closed
</I>&gt;&gt;&gt;<i> +/// due to an encryption error, otherwise omit.
</I>&gt;&gt;&gt;<i> +void SessionClose(const Security::SessionPointer &amp;, int fdOnError = -1);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please split SessionClose() into two different functions, one for each
</I>&gt;&gt;<i> use case (initiating proper SSL connection closure vs. immediate SSL
</I>&gt;&gt;<i> connection state destruction). Mixing the two actions results in
</I>&gt;&gt;<i> confusing API instructions and dangerous usage/implementation IMO.
</I>

&gt;<i> Well, there is no such thing as a &quot;SSL connection&quot; - it is security
</I>&gt;<i> added onto some *other* Transport Protocol's layer.
</I>
There is. The &quot;security added onto some other Transport Protocol's
layer&quot; is called SSL connection. It is not a TCP connection, of course.
It is an SSL connection. See RFC 5246 for numerous examples of this
usage. Calling that connection a &quot;session&quot; in Squid sources is abomination.


&gt;<i> I agree 'close' is a bad word there, but doing what you suggest assumes
</I>&gt;<i> there is a connection to close and/or data is being destroyed.
</I>&gt;<i> Neither of those is actually happening.
</I>
On the contrary, that is exactly what is happening. The SSL connection
is being closed and the associated state will be destroyed (which may
have nothing to do with the underlying TCP connection). Using the wrong
terminology makes things a lot more difficult than they really are.


&gt;&gt;<i> I suggest StartSessionClosing() and DestroySession() names (while going
</I>&gt;&gt;<i> along with the current terrible choice of calling both SSL connections
</I>&gt;&gt;<i> and SSL sessions &quot;sessions&quot; which leads to code that close an SSL
</I>&gt;&gt;<i> &quot;session&quot; while reusing the associated SSL session!).
</I>
&gt;<i> There is no explicit destroy for SSL sessions. 
</I>
I think you are talking about SSL sessions while the corresponding code
and I are talking about SSL connections [that Squid calls SSL &quot;sessions&quot;].


If the fixes mentioned in this email are implemented without surprises,
then I do not think this patch warrants another review cycle.


Thank you,

Alex.

</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007796.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
	<LI>Next message: <A HREF="007806.html">[squid-dev] [PATCH] initial GnuTLS support for encrypted server connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7797">[ date ]</a>
              <a href="thread.html#7797">[ thread ]</a>
              <a href="subject.html#7797">[ subject ]</a>
              <a href="author.html#7797">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
