<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] switch session/connection for OpenSSL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20switch%20session/connection%20for%20OpenSSL&In-Reply-To=%3Cb100092b-04c4-8977-3bdb-18dd8c26b7ce%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009112.html">
   <LINK REL="Next"  HREF="009120.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] switch session/connection for OpenSSL</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20switch%20session/connection%20for%20OpenSSL&In-Reply-To=%3Cb100092b-04c4-8977-3bdb-18dd8c26b7ce%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] switch session/connection for OpenSSL">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Jul  9 10:30:35 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009112.html">[squid-dev] [PATCH] switch session/connection for OpenSSL
</A></li>
        <LI>Next message: <A HREF="009120.html">[squid-dev] [PATCH] switch session/connection for OpenSSL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9116">[ date ]</a>
              <a href="thread.html#9116">[ thread ]</a>
              <a href="subject.html#9116">[ subject ]</a>
              <a href="author.html#9116">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/07/17 15:28, Alex Rousskov wrote:
&gt;<i> On 06/10/2017 06:27 AM, Amos Jeffries wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Yes this is far from complete, and intentionally much smaller that
</I>&gt;&gt;<i> the previous patch.
</I>&gt;<i> 
</I>&gt;<i> I believe this patch is a huge step in the right direction. It has one
</I>&gt;<i> serious flaw (namespace misuse), but I hope that can be addressed
</I>&gt;<i> without too much controversy. The details are further below.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> On 27/04/17 05:24, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> Needless to say, I would be happy if we can come up with better
</I>&gt;&gt;&gt;<i> definitions or even better concepts. The above is a starting point.
</I>&gt;<i> 
</I>&gt;&gt;<i> I do not think it is up to us to define these things. So I have taken a
</I>&gt;&gt;<i> much longer reading of all the RFCs since SSLv3.0 through to current
</I>&gt;&gt;<i> TLS/1.3 and isolated what are the authoritative definitions AFAICT.
</I>&gt;<i> 
</I>&gt;<i> For the record, I am happy to adopt any &quot;authoritative&quot; definitions that
</I>&gt;<i> suite Squid specifics well, but, IMO, it is up to _us_ to decide
</I>&gt;<i> suitability and, if necessary, to define and/or clarify things within
</I>&gt;<i> Squid context. Quoting RFCs is often useful, but it is not a panacea for
</I>&gt;<i> any problem, including the terminology problem.
</I>&gt;<i> 
</I>&gt;<i> For example, a TLS Connection exists, as a concept, whether any RFC
</I>&gt;<i> defines or not. An RFC may not need that definition, may assume that
</I>&gt;<i> every reader already understands that concept, or may just be sloppy. We
</I>&gt;<i> should reuse what we can and fill the gaps with our own definitions as
</I>&gt;<i> needed.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> * moves the pieces that are doing what is defined as solely TLS
</I>&gt;&gt;<i> Connection things to security/TlsConnection.* files.
</I>&gt;<i> 
</I>&gt;<i> Please do not misinterpret the namespace comments below as a
</I>&gt;<i> disagreement with the above change. Moving TLS Connection code to
</I>&gt;<i> security/TlsConnection.* files is fine with me.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> * adds a Security::TlsConnection::Pointer type for use by code dealing
</I>&gt;&gt;<i> with TLS Connection logic.
</I>&gt;<i> 
</I>&gt;<i> This is also great.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>   - SessionPointer still exists for code performing TLS Session logic.
</I>&gt;&gt;<i> see PeerConnector description for the distinction.
</I>&gt;<i> 
</I>&gt;<i> Sure, this is fine. TLS Session is a perfectly valid concept as well.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>   - I have not gone through and renamed uses of SessionPointer beyond
</I>&gt;&gt;<i> those directly involved with the above code shuffle.
</I>&gt;<i> 
</I>&gt;<i> Can you give an example or two of old uses that should be fixed? Do you
</I>&gt;<i> plan on doing this renaming as a part of this series of patches? It
</I>&gt;<i> would be nice to get rid of the inconsistencies in one sweep or, if
</I>&gt;<i> necessary, several close-in-time changes...
</I>&gt;<i> 
</I>
class fde &quot;ssl&quot; member. This is a pointer to the TLS session state for 
the TCP connection whose FD the fd_table entry is storing.



&gt;<i> 
</I>&gt;&gt;<i> +namespace TlsConnection {
</I>&gt;<i> 
</I>&gt;<i> We should not use namespaces for what is a class. Very roughly speaking:
</I>&gt;<i> If you can create multiple instances of X, then X is (or can be) a
</I>&gt;<i> class. It is not a namespace. In this context:
</I>&gt;<i> 
</I>&gt;<i> * I can have five &quot;TLS connections&quot;. A &quot;TLS connection&quot; is (or can be) a
</I>&gt;<i> class.
</I>&gt;<i> 
</I>&gt;<i> * All TLS-related functions, classes, constants, and other interfaces
</I>&gt;<i> can be grouped under a single &quot;Tls&quot; namespace. I cannot have five TLSs.
</I>&gt;<i> &quot;Tls&quot; is (or can be) a namespace.
</I>
They might be one day. That is out of scope of this patch which 
concentrates solely on documenting the border between TLS connection and 
TLS session.

&gt;<i> 
</I>&gt;<i> N.B. I do not suggest adding a TLS connection class now (and we already
</I>&gt;<i> have library-specific types that currently fulfill that role,
</I>&gt;<i> essentially). Using Security::ConnectionPointer is enough.
</I>
The classes in Squid which most accurately match the &quot;TLS connection&quot; 
definition are actually class fde and class Comm::Connection. Since fde 
stores the FD value, I/O handlers and pointer to an active SSL session 
(indirectly via the SSL* pointer), and Comm::Connection stores the FD 
and related state/session data.


&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +    if (Security::TlsConnection::CreateServer(ctx, conn, &quot;client https start&quot;)) {
</I>&gt;<i> 
</I>&gt;<i> I would replace TlsConnection::CreateServer, which reads like nonsense
</I>

Take a look at the naming of this code in Squid-3. These are the names 
you have spent most of a year trying to get me to undo. Now you are 
saying they were nonsense.

&quot;
SSL *
Ssl::CreateClient(SSL_CTX *sslContext, const int fd, const char *squidCtx)
{
     return SslCreate(sslContext, fd, Ssl::Bio::BIO_TO_SERVER, squidCtx);
}

SSL *
Ssl::CreateServer(SSL_CTX *sslContext, const int fd, const char *squidCtx)
{
     return SslCreate(sslContext, fd, Ssl::Bio::BIO_TO_CLIENT, squidCtx);
}
&quot;



&gt;<i> IMHO, with something like:
</I>&gt;<i> 
</I>&gt;<i> * Accept
</I>&gt;<i> * AcceptConnection
</I>&gt;<i> * PrepareToAccept
</I>&gt;<i> * CreateConnection(ToSquid)
</I>&gt;<i> 
</I>&gt;<i> And the corresponding names for the Squid-to-peer TLS connections:
</I>&gt;<i> 
</I>&gt;<i> * Connect
</I>&gt;<i> * InitiateConnection
</I>&gt;<i> * PrepareToConnect
</I>&gt;<i> * CreateConnection(FromSquid)
</I>&gt;<i> 
</I>&gt;<i> &quot;Accept&quot; and &quot;connect&quot; are common networking terms that can be applied
</I>&gt;<i> to TLS connections well. The last two versions in each group are more
</I>&gt;<i> precise because these functions only _prepare_ the TLS connection for
</I>&gt;<i> future negotiations; they do not actually start those negotiations.
</I>

The CreateX() functions are the constructors of the _data structure_ for 
storing TLS context data. They have zero properties and similarity with 
accept(2) or connect(2) in TCP connections.

*IF* these functions actually did connection semantics then all of the 
logic in the class PeerConnector hierarchy is completely wrong.
  (you may recall that one of the major mistakes I made very early on 
which led down this whole muckup was thinking that these did the 
'connect' and PeerConnector did the encryption).

This distinction is supported directly by the fact that this logic in 
these functions is identical for clients and servers.

** In no way does a TLS client code in PeerConnector accept(2) a 
connection. Therefore this logic is not doing accept(2).

b) Likewise, it is also not performing connect(2) equivalent semantics.

This is where your insistence that TLS connection and TCP connection are 
equivalent falls down completely. Because a TLS connection _exists_ as a 
result of these functions, but cannot be used for I/O.
  In order to use as a transport channel a session must also be 
negotiated. That session negotiation is the equivalent of connect(2) - 
yet it does *not* create a &quot;TLS connection&quot; - it creates a &quot;TLS session&quot;.


In fact the more I think about it now, these functions are somewhat a 
TLS equivalent of socket(2). Since a socket/FD has to be allocated 
before a connection can begin to be actively started, and lots of 
behaviour flags etc get applied to the socket/FD after creation and 
before first use to manage the connections eventual behaviour.

For lack of anything actually suitable I bowed to your request to retain 
the Squid-3 terminology here. That being the words Create and 
Client/Server rather than connect/accept/listen/prepare etc.



&gt;<i> 
</I>&gt;<i> All these functions should be inside the existing Security namespace. If
</I>&gt;<i> you think we will have non-SSL/TLS things inside Security, then we can
</I>&gt;<i> also add a Tls namespace, but I do not see the need for that right now.
</I>&gt;<i> 
</I>
Er, they are in Security::

Lets talks a short side-step here and consider the Comm::Connection 
object design. It is supposed to be a generic abstraction for *any* 
transport (including TLS encrypted ones) such that the code using it 
does not need to be aware of whether it was TCP, UDP, SCTP, TLS, DTLS or 
whatever - just pass the Conn object to read/write API with a buffer and 
get that buffer filled or emptied.

With &quot;TLS connection&quot; being defined as being a pair [transport 
connection, TLS session]. The TLS connection &quot;object&quot; is most correctly 
typed as either std::pair&lt;Comm::Connection, Security::SessionPointer&gt;, 
OR adding a Comm::Connection with member pointing to the TLS session.

(ignoring for now that SessionPointer is currently borked).

Right now there is also a fuzzy line in the comm code between 
Comm::Connection and class fde, so IMO fde holding the SessionPointer is 
wrong, but that is where it currently has to be placed due to the CommIO 
handling logics. I'm intentionally leaving that tangled web out of scope 
for this patch.


I did consider making these functions methods of a class TlsConnection, 
but that would easily lead to confusion of thinking that class *was* 
representing a TLS connection and get in the way of future cleanup of 
the above tangle.

So for this patch I am simply adding a namespace placeholder for 
whatever the class will be and ensuring the static functions are in 
there. In the long term end product they may stay as statics like this 
in a class, or be renamed to non-static methods.

&quot;Tls&quot; is being used here to distinguish from Ssl:: things, but as you 
point out we have not gone far enough to warrant a Tls:: namespace yet. 
I do fully expect that there will be other security types before too 
much longer. Specifically some Security::SslFoo things. Then there is 
SCTP etc.

So making the name fully descriptive and avoiding even more renames 
seems to be a good choice. There should be no harm in documenting that 
these were created to be TLS specific things.


&gt;<i> 
</I>&gt;&gt;<i> +/// Create TLS state objects and associate with a TLS connection to form a TLS connection.
</I>&gt;&gt;<i> +/// Client connection structures and TLS/SSL I/O (Comm and BIO) are initialized.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> +/// Create TLS state objects and associate with a TLS connection to form a TLS connection.
</I>&gt;&gt;<i> +/// Server connection structures and TLS/SSL I/O (Comm and BIO) are initialized.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I am guessing something went wrong in the first sentences during
</I>&gt;<i> find-and-replace (&quot;TLS connection to form a TLS connection&quot;). See below
</I>&gt;<i> for a specific fix suggestion.
</I>
Oops. Yes. That first should be &quot;TCP&quot;. Though using &quot;transport&quot; now as 
per below change.

&gt;<i> 
</I>&gt;<i> Also, please avoid the &quot;client connection&quot; and &quot;server connection&quot;
</I>&gt;<i> terminology, especially in high-level little-context descriptions like
</I>&gt;<i> these, because such terms are very confusing in Squid context. As you
</I>&gt;<i> know, we already have &quot;client side&quot; that has &quot;server agents&quot;, and
</I>&gt;<i> &quot;server side&quot; that has &quot;client agents&quot;. To reduce confusion, use
</I>&gt;<i> &quot;from-client connection&quot; and &quot;to-server connection&quot; phrasing instead
</I>&gt;<i> (or, if you prefer, the verbose &quot;client-to-Squid connection&quot; and
</I>&gt;<i> &quot;Squid-to-server connection&quot; variants.
</I>&gt;<i> 
</I>
The Client/Server words are following our current Squid-oriented 
(Squid-as-Client and Squid-as-Server) terminology.

ie. &quot;Client connection structures&quot; refers to TLS connection structures 
where Squid is the client.

The TLS terminology, Squid terminology, library APIs seem to align. Only 
the BIO enum naming uses server/client the other way around, and those 
explicitly state &quot;_TO_&quot; for clarity. So I don't seen much in the way of 
confusion here.



&gt;<i> Please consider using these replacements:
</I>&gt;<i> 
</I>&gt;<i> /// Creates a TLS Connection and
</I>&gt;<i> /// associates it with the given from-client transport connection.
</I>&gt;<i> /// \returns false on errors (and logs details using DBG_IMPORTANT)
</I>&gt;<i> 
</I>&gt;<i> /// Creates a TLS Connection and
</I>&gt;<i> /// associates it with the given to-server transport connection.
</I>&gt;<i> /// \returns false on errors (and logs details using DBG_IMPORTANT)
</I>&gt;<i> 
</I>
Done the \return change. The other doc changes are wrong because the 
CreateClient uses a to-server transport connection to generate a 
to-server / from-Squid TLS connection.


&gt;<i> 
</I>&gt;<i> The other comments are about relatively minor problems:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> + * Initializes TLS data structures and associates with a TCP Connection
</I>&gt;&gt;<i> + * to form a Client or Server TLS Connection.
</I>&gt;<i> 
</I>&gt;&gt;<i> + * Initiates encryption on a TCP Connection to peers or servers.
</I>&gt;<i> 
</I>&gt;&gt;<i> + * The caller must monitor the connection for TCP closure because this job will
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> s/TCP Connection/transport connection/g
</I>&gt;<i> 
</I>&gt;<i> s/the connection for TCP/the transport connection for/
</I>&gt;<i> 
</I>&gt;<i> because when we start supporting SslBump for HTTPS proxies and/or HTTP/2
</I>&gt;<i> for HTTPS proxies, that transport will not be TCP. There is nothing
</I>&gt;<i> specific to TCP in that code IIRC.
</I>
Done.


&gt;<i> 
</I>&gt;<i> Please apply similar adjustments to other &quot;TCP&quot; phrase added by the patch.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> + * Initializes TLS data structures and associates with a TCP Connection
</I>&gt;&gt;<i> + * to form a Client or Server TLS Connection.
</I>&gt;<i> 
</I>&gt;<i> s/associates with/associates them with/
</I>
Done.


&gt;&gt;<i> + * Initializes TLS data structures and associates with a TCP Connection
</I>&gt;&gt;<i> + * to form a Client or Server TLS Connection.
</I>&gt;<i> 
</I>&gt;<i> I would replace &quot;to form a Client or Server TLS Connection&quot; with &quot;to a
</I>&gt;<i> TLS Connection with a Client or Server&quot;.
</I>&gt;<i> 
</I>
Nouns. The TLS data structures are not being associated with a TLS 
connection, they *are* the &quot;Client TLS&quot; or &quot;Server TLS&quot; part that makes 
the transport turn into a &quot;Client or Server TLS connection&quot; 
collective/aggregate thing.


&gt;<i> 
</I>&gt;&gt;<i> ... The primary operational
</I>&gt;&gt;<i> + * difference between the server and client is that the server is
</I>&gt;&gt;<i> + * generally authenticated, while the client is only optionally
</I>&gt;&gt;<i> + * authenticated.&quot;
</I>&gt;<i> 
</I>&gt;<i> I recommend removing that text -- that &quot;primary operational difference&quot;
</I>&gt;<i> has little to do with the CreateTlsConnection code.
</I>&gt;<i> 
</I>&gt;<i> Overall, quoting fairly generic &quot;client&quot; and &quot;server&quot; definitions feels
</I>&gt;<i> like noise to me, but I am not going to fight you about that.
</I>&gt;<i> 
</I>
That is the distinguishing factor for client vs server at this level of 
TLS. It relates directly to what is correct handling of the BIO 
TO_SERVER/TO_CLIENT parameter sent to this function.


Sadly that is as detailed as they are. Quoting in full in part documents 
where the line is between the fuzzy formal definitions and anything we 
tack on to, as you said earlier, 'fill the gaps'.


&gt;<i> 
</I>&gt;&gt;<i> -    // Temporary ssl for getting X509 certificate from SSL_CTX.
</I>&gt;&gt;<i> -    Security::SessionPointer ssl(Security::NewSessionObject(ctx));
</I>&gt;&gt;<i> +    // Temporary Pointer&lt;SSL&gt; for getting X509 certificate from SSL_CTX.
</I>&gt;&gt;<i> +    Security::TlsConnection::Pointer ssl(Security::TlsConnection::NewSslObject(ctx));
</I>&gt;<i> 
</I>&gt;<i> s/Pointer&lt;SSL&gt;/SSL object/
</I>&gt;<i> 
</I>&gt;<i> ... because the comment is about the temporary OpenSSL SSL object, not
</I>&gt;<i> the pointer to it (the local pointer variable is also temporary, but
</I>&gt;<i> that is not the point here -- it is the temporary nature of the
</I>&gt;<i> underlying SSL object that is rather unusual and worth commenting on).
</I>
Okay, done.


&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> PS: Applying the definitions to PeerConnector, it has become clear that
</I>&gt;&gt;<i> it (and children) not following a MUST requirement about the underlying
</I>&gt;&gt;<i> TCP transport connection being terminated in the case where Handshake
</I>&gt;&gt;<i> negotiation failed due to a Record protocol violation. They are leaving
</I>&gt;&gt;<i> this closure to the caller which is a layering violation
</I>&gt;<i> 
</I>&gt;<i> There is no layering violation in letting the transport-aware caller to
</I>&gt;<i> do transport-specific things. I seriously doubt separating handshake
</I>&gt;<i> failure detection code from the code reacting to that failure violates
</I>&gt;<i> any RFC MUSTs! There are certainly interface problems between
</I>&gt;<i> PeerConnector and its users, but they are mostly software problems
</I>&gt;<i> unrelated to RFCs/terminology and are outside this thread scope AFAICT.
</I>&gt;<i> 
</I>
Maybe I was not clear enough.

* The layering violation is in requiring the caller / semantics layer to 
be aware of TLS syntax and how issues there need to be handled.

* The RFC violation is that the caller does *not* perform the close due 
to the protocol syntax errors. It seems to instead die on semantic 
interpretations of the bad syntax, which might be leaving nasty security 
holes on some garbage.

The TLS layer already is aware that there is a transport (relatively 
opaque in type though). So it is already in a position to close() that 
transport as required in the spec and let the caller do whatever its 
handler was for that.

The caller already has a close handler in place to do its own &quot;stuff&quot; 
when TLS layer aborts with the close().


Thank you
Amos
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009112.html">[squid-dev] [PATCH] switch session/connection for OpenSSL
</A></li>
	<LI>Next message: <A HREF="009120.html">[squid-dev] [PATCH] switch session/connection for OpenSSL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9116">[ date ]</a>
              <a href="thread.html#9116">[ thread ]</a>
              <a href="subject.html#9116">[ subject ]</a>
              <a href="author.html#9116">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
