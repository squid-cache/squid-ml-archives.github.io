<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] switch session/connection for OpenSSL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20switch%20session/connection%20for%20OpenSSL&In-Reply-To=%3Cdc26fbb6-6523-7786-660b-d8ed823d07a8%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009116.html">
   <LINK REL="Next"  HREF="009113.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] switch session/connection for OpenSSL</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20switch%20session/connection%20for%20OpenSSL&In-Reply-To=%3Cdc26fbb6-6523-7786-660b-d8ed823d07a8%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] switch session/connection for OpenSSL">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Jul 10 18:31:25 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009116.html">[squid-dev] [PATCH] switch session/connection for OpenSSL
</A></li>
        <LI>Next message: <A HREF="009113.html">[squid-dev] ISO 17025 - Οργάνωση Εργαστηρίων
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9120">[ date ]</a>
              <a href="thread.html#9120">[ thread ]</a>
              <a href="subject.html#9120">[ subject ]</a>
              <a href="author.html#9120">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/09/2017 04:30 AM, Amos Jeffries wrote:
&gt;<i> On 09/07/17 15:28, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 06/10/2017 06:27 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i>   - I have not gone through and renamed uses of SessionPointer beyond
</I>&gt;&gt;&gt;<i> those directly involved with the above code shuffle.
</I>
&gt;&gt;<i> Can you give an example or two of old uses that should be fixed? Do you
</I>&gt;&gt;<i> plan on doing this renaming as a part of this series of patches? It
</I>&gt;&gt;<i> would be nice to get rid of the inconsistencies in one sweep or, if
</I>&gt;&gt;<i> necessary, several close-in-time changes...
</I>
&gt;<i> class fde &quot;ssl&quot; member. This is a pointer to the TLS session state for
</I>&gt;<i> the TCP connection whose FD the fd_table entry is storing.
</I>
fde::ssl is an std::shared_ptr&lt;SSL&gt;. It is trivial to fix the name of
this field type to use the new TLS Connection pointer type. That name
change itself will not require any other other code changes AFAICT. I do
not understand why you place that change outside this patch scope, but I
do not insist on making this change now. Said that, the sooner we fix
the remaining Security::SessionPointer occurrences the better.


&gt;<i> SessionPointer still exists for code performing TLS Session logic
</I>
Perhaps I misinterpreted what you meant by the above. To avoid
misunderstanding:

* Security::SessionPointer should be std::*_ptr&lt;SSL_SESSION,...&gt;,
* Security::ConnectionPointer should be std::shared_ptr&lt;SSL&gt;,
* Security::SessionStatePointer should be removed.

(I am omitting the known GnuTLS equivalents for clarity sake.)

In 99+% of cases, there is no ambiguity or complex decision making
involved in deciding which existing code should use which pointer type.
The existing code either works with SSL_SESSION or with SSL, telling us
which pointer type it wants to use. For example, fde::ssl wants the new
Security::ConnectionPointer (or whatever its name will be).

Once we resolve the namespace/naming problem, the remaining part of the
fix is simple, mechanical renaming. If you insist on doing renaming
separately from the primary naming patch, I cannot object to that, but
combining the two seems natural to me.


&gt;&gt;&gt;<i> +namespace TlsConnection {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We should not use namespaces for what is a class. Very roughly speaking:
</I>&gt;&gt;<i> If you can create multiple instances of X, then X is (or can be) a
</I>&gt;&gt;<i> class. It is not a namespace. In this context:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * I can have five &quot;TLS connections&quot;. A &quot;TLS connection&quot; is (or can be) a
</I>&gt;&gt;<i> class.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * All TLS-related functions, classes, constants, and other interfaces
</I>&gt;&gt;<i> can be grouped under a single &quot;Tls&quot; namespace. I cannot have five TLSs.
</I>&gt;&gt;<i> &quot;Tls&quot; is (or can be) a namespace.
</I>
&gt;<i> They might be one day.
</I>
The above are facts that should guide our decisions today, not
predictions for future code changes.


&gt;<i> That is out of scope of this patch which
</I>&gt;<i> concentrates solely on documenting the border between TLS connection and
</I>&gt;<i> TLS session.
</I>
You patch introduces a new namespace that cannot exist in a sanely
organized code. Not today, not tomorrow. I am _not_ arguing for adding a
TLS Connection type. I only object to adding a TLS Connection namespace.
My objection is in scope.


&gt;&gt;&gt;<i> +    if (Security::TlsConnection::CreateServer(ctx, conn, &quot;client
</I>&gt;&gt;&gt;<i> https start&quot;)) {
</I>
&gt;&gt;<i> I would replace TlsConnection::CreateServer, which reads like nonsense
</I>

&gt;<i> Take a look at the naming of this code in Squid-3. These are the names
</I>&gt;<i> you have spent most of a year trying to get me to undo. Now you are
</I>&gt;<i> saying they were nonsense.
</I>
I think you are misinterpreting what I am saying.
&quot;TlsConnection::CreateServer&quot; is nonsense. &quot;Ssl::CreateServer&quot; is far
from ideal but does make some sense.


&gt;&gt;<i> IMHO, with something like:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Accept
</I>&gt;&gt;<i> * AcceptConnection
</I>&gt;&gt;<i> * PrepareToAccept
</I>&gt;&gt;<i> * CreateConnection(ToSquid)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> And the corresponding names for the Squid-to-peer TLS connections:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Connect
</I>&gt;&gt;<i> * InitiateConnection
</I>&gt;&gt;<i> * PrepareToConnect
</I>&gt;&gt;<i> * CreateConnection(FromSquid)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;Accept&quot; and &quot;connect&quot; are common networking terms that can be applied
</I>&gt;&gt;<i> to TLS connections well. The last two versions in each group are more
</I>&gt;&gt;<i> precise because these functions only _prepare_ the TLS connection for
</I>&gt;&gt;<i> future negotiations; they do not actually start those negotiations.
</I>

&gt;<i> The CreateX() functions are the constructors of the _data structure_ for
</I>&gt;<i> storing TLS context data. 
</I>
Yes, that and more.


&gt;<i> They have zero properties and similarity with
</I>&gt;<i> accept(2) or connect(2) in TCP connections.
</I>
I disagree. These functions can be viewed as performing some of the very
first steps of standard TLS connecting or accepting sequences. They do
not accept or connect, but they are a part of accepting or connecting
procedure:

N+1. Setup BIO for connecting or accepting.
N+2. Configure TLS connection with the right BIO.
N+3. Call SSL_connect() or SSL_accept() on that TLS connection.

If we were dealing with TCP at the same low level, we would also have
constructors that prepare the TCP connection object for the next steps
in the standard TCP handshake sequence.

The PrepareToAccept() and PrepareToConnect() variants reflect the above
better than &quot;pure&quot; Accept() and Connect(). Just pick what you think
works best or suggest a better alternative.


&gt;<i> ** In no way does a TLS client code in PeerConnector accept(2) a
</I>&gt;<i> connection. Therefore this logic is not doing accept(2).
</I>
You lost me here. PeerConnector is not a part of the accepting sequence.
It is a part of the connecting sequence, which works in the opposite
direction. So, yes, PeerConnector is not doing accept(2) or equivalent,
but I do not think anybody has argued that it does.


&gt;<i> b) Likewise, it is also not performing connect(2) equivalent semantics.
</I>
If &quot;it&quot; is still PeerConnector then it actually does call SSL_connect()
which has connect(2)-equivalent semantics.


&gt;<i> This is where your insistence that TLS connection and TCP connection are
</I>&gt;<i> equivalent falls down completely.
</I>
I have never insisted on such nonsense. The two connections surely have
many similarities, but they are obviously not equivalent.


&gt;<i> Because a TLS connection _exists_ as a
</I>&gt;<i> result of these functions, but cannot be used for I/O.
</I>
It _is_ used for I/O. The TLS handshake does not happen magically; it
requires sending and receiving bytes (i.e., I/O). Once a TLS connection
is constructed, it can be used for that handshake I/O.

If your argument is that the handshake must happen _before_ any useful
payload is transmitted, then the same argument applies to a TCP
connection. TCP has a handshake sequence as well, of course.

If you merely state that there are certain stages of a (TLS or TCP)
connection where payload cannot be sent or received immediately, then I
certainly agree but do not see the problem/relevance.


&gt;<i> In order to use as a transport channel a session must also be
</I>&gt;<i> negotiated. That session negotiation is the equivalent of connect(2) -
</I>&gt;<i> yet it does *not* create a &quot;TLS connection&quot; - it creates a &quot;TLS session&quot;.
</I>
Session negotiation is rather similar to a TCP handshake. TLS session
negotiation happens inside an existing TLS connection. It is a required
step in any connecting or accepting sequence.



&gt;<i> In fact the more I think about it now, these functions are somewhat a
</I>&gt;<i> TLS equivalent of socket(2).
</I>
Yes, they are. socket(2) is direction-agnostic so they are even more
like a socket(2)+bind(2) pair: They create a TLS connection and bind it
to the right BIO structure.


BTW, if you have spent all this time to simply illustrate that pure
&quot;Accept&quot; and &quot;Connect&quot; names are far from ideal, then I am sorry we have
wasted so much time. I know those names are far from ideal. I offered
several options for you to pick from (and am open to alternatives).
There is no need to re-highlight the problems with each name (and they
all have some problems).


&gt;<i> For lack of anything actually suitable I bowed to your request to retain
</I>&gt;<i> the Squid-3 terminology here.
</I>
I do not recall requesting that. New better names are welcomed. And you
did not retain v3 naming because you introduced a new namespace.


&gt;&gt;<i> All these functions should be inside the existing Security namespace. If
</I>&gt;&gt;<i> you think we will have non-SSL/TLS things inside Security, then we can
</I>&gt;&gt;<i> also add a Tls namespace, but I do not see the need for that right now.
</I>
&gt;<i> Er, they are in Security::
</I>
In your patch, they were not. They were inside Security::TlsConnection.
It is the TlsConnection part that I am strongly against. I added the
above paragraph just because I did not want you to misinterpret my
arguments as if I am against the Security part as well.


&gt;<i> Lets talks a short side-step here and consider the Comm::Connection
</I>&gt;<i> object design.
</I>
That would be dangerous because we probably disagree what
Comm::Connection should be. For example, your code is abusing that class
to store connection-related info way before the connection exists and
even before we have plans to open the corresponding connection. I have
tried to object to that but failed to convince you that it is wrong.


&gt;<i> It is supposed to be a generic abstraction for *any*
</I>&gt;<i> transport (including TLS encrypted ones) such that the code using it
</I>&gt;<i> does not need to be aware of whether it was TCP, UDP, SCTP, TLS, DTLS or
</I>&gt;<i> whatever - just pass the Conn object to read/write API with a buffer and
</I>&gt;<i> get that buffer filled or emptied.
</I>
I am not sure Comm::Connection is supposed to be that. It certainly is
not today because some code using Comm::Connection knows what kind of
connection it is and cannot use any other kind. For example, giving a
PeerConnector object a TLS connection (instead of a raw TCP connection)
would not magically allow us to support TLS inside TLS.


&gt;<i> With &quot;TLS connection&quot; being defined as being a pair [transport
</I>&gt;<i> connection, TLS session].
</I>
That is a usable abstraction in some contexts and an oversimplification
in others. For example, during a TLS handshake, there is no TLS session
(yet), but there is certainly TLS state that cannot be stored in the
transport connection object, whatever that object is.

Fortunately, we do not need to define the type of TLS Connection objects
because the libraries have done that for us. In OpenSSL, that object is
called &quot;SSL&quot;.


&gt;<i> The TLS connection &quot;object&quot; is most correctly
</I>&gt;<i> typed as either std::pair&lt;Comm::Connection, Security::SessionPointer&gt;,
</I>
That does not work for the TLS connection stages where there is no TLS
session (see above).


&gt;<i> OR adding a Comm::Connection with member pointing to the TLS session.
</I>
Same problem (and many more).


&gt;<i> Right now there is also a fuzzy line in the comm code between
</I>&gt;<i> Comm::Connection and class fde, so IMO fde holding the SessionPointer is
</I>&gt;<i> wrong, but that is where it currently has to be placed due to the CommIO
</I>&gt;<i> handling logics. I'm intentionally leaving that tangled web out of scope
</I>&gt;<i> for this patch.
</I>
Yes, untangling fde/Connection/TLS I/O is out of scope. Fixing the name
of the fde::ssl member type to become Security::Connection (or
equivalent) is perfectly in scope and requires no untangling at all!


&gt;<i> I did consider making these functions methods of a class TlsConnection,
</I>&gt;<i> but that would easily lead to confusion of thinking that class *was*
</I>&gt;<i> representing a TLS connection and get in the way of future cleanup of
</I>&gt;<i> the above tangle.
</I>
A type named TlsConnection has to represent a TLS connection. Today,
that type is provided to us by the libraries. If we need a Squid-native
TlsConnection wrapper tomorrow, we will discuss it tomorrow. Today, such
discussions are probably out of scope.


&gt;<i> So for this patch I am simply adding a namespace placeholder for
</I>&gt;<i> whatever the class will be and ensuring the static functions are in
</I>&gt;<i> there.
</I>
I am strongly against adding namespaces as class placeholders. The two
concepts operate on very different layers/levels. One cannot be a
placeholder for another. This is like using Squid software as a
placeholder for a future car because both are going to be purple. It
just does not make any sense!

If you want a placeholder for the future TLS Connection class, you can
add a Security::TlsConnection class that has no non-static members but
has (naturally static) creation methods. Needless to say, to play that
game, you have to treat that placeholder class as a class (and those
creation methods as creation methods) when it comes to their naming and
interfaces. For example, you may have something like this:

class TlsConnection
{
public:
    typedef TlsConnectionPointer Pointer;

    static Pointer ToServer(...);
    static Pointer FromClient(...);

#if USE_OPENSSL
    static Pointer New(...);
#endif
};


Such static-only classes are naturally frowned upon, but if that is the
best we can agree on, I can live with that.


&gt;&gt;<i> Also, please avoid the &quot;client connection&quot; and &quot;server connection&quot;
</I>&gt;&gt;<i> terminology, especially in high-level little-context descriptions like
</I>&gt;&gt;<i> these, because such terms are very confusing in Squid context. As you
</I>&gt;&gt;<i> know, we already have &quot;client side&quot; that has &quot;server agents&quot;, and
</I>&gt;&gt;<i> &quot;server side&quot; that has &quot;client agents&quot;. To reduce confusion, use
</I>&gt;&gt;<i> &quot;from-client connection&quot; and &quot;to-server connection&quot; phrasing instead
</I>&gt;&gt;<i> (or, if you prefer, the verbose &quot;client-to-Squid connection&quot; and
</I>&gt;&gt;<i> &quot;Squid-to-server connection&quot; variants.
</I>
&gt;<i> The Client/Server words are following our current Squid-oriented
</I>&gt;<i> (Squid-as-Client and Squid-as-Server) terminology.
</I>
Please avoid the &quot;client connection&quot; and &quot;server connection&quot;
terminology, especially in high-level little-context descriptions like
these, regardless of what the Client and Server words mean to you or
should mean to everybody. There is just too many &quot;clients&quot; and &quot;servers&quot;
that mean different things -- we should use qualifiers to be clear,
especially where there is little context to guide us (e.g., we are not
inside some Client class already). Some day, those qualifiers may become
unnecessary.


&gt;<i> ie. &quot;Client connection structures&quot; refers to TLS connection structures
</I>&gt;<i> where Squid is the client.
</I>
I understand the terminology, but we should not use it for the reasons
stated above. We should use to-server, squid-server, or from-squid IMO.


&gt;&gt;<i> Please consider using these replacements:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> /// Creates a TLS Connection and
</I>&gt;&gt;<i> /// associates it with the given from-client transport connection.
</I>&gt;&gt;<i> /// \returns false on errors (and logs details using DBG_IMPORTANT)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> /// Creates a TLS Connection and
</I>&gt;&gt;<i> /// associates it with the given to-server transport connection.
</I>&gt;&gt;<i> /// \returns false on errors (and logs details using DBG_IMPORTANT)
</I>

&gt;<i> Done the \return change. The other doc changes are wrong because the
</I>&gt;<i> CreateClient uses a to-server transport connection to generate a
</I>&gt;<i> to-server / from-Squid TLS connection.
</I>
I am sure you can swap the &quot;wrong&quot; descriptions around to match the
&quot;right&quot; names. Hopefully, by the time your patch is applied, the names
will be less confusing.


&gt;&gt;&gt;<i> PS: Applying the definitions to PeerConnector, it has become clear that
</I>&gt;&gt;&gt;<i> it (and children) not following a MUST requirement about the underlying
</I>&gt;&gt;&gt;<i> TCP transport connection being terminated in the case where Handshake
</I>&gt;&gt;&gt;<i> negotiation failed due to a Record protocol violation. They are leaving
</I>&gt;&gt;&gt;<i> this closure to the caller which is a layering violation
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There is no layering violation in letting the transport-aware caller to
</I>&gt;&gt;<i> do transport-specific things. I seriously doubt separating handshake
</I>&gt;&gt;<i> failure detection code from the code reacting to that failure violates
</I>&gt;&gt;<i> any RFC MUSTs! There are certainly interface problems between
</I>&gt;&gt;<i> PeerConnector and its users, but they are mostly software problems
</I>&gt;&gt;<i> unrelated to RFCs/terminology and are outside this thread scope AFAICT.
</I>
&gt;<i> Maybe I was not clear enough.
</I>
I continue to believe that discussing alleged MUST and layering
violations by PeerConnector is outside this thread scope. I see serious
flaws in some of your logic, and I know there are problems with
PeerConnector code, but I refuse to discuss any of that here. If you
would like to continue this part of the discussion, please start a new
thread and, if possible, accompany your claims with specific code quotes
or references, to avoid misunderstanding while trying to interpret vague
terms such as &quot;layering violations&quot; and syntax awareness.



Thank you,

Alex.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009116.html">[squid-dev] [PATCH] switch session/connection for OpenSSL
</A></li>
	<LI>Next message: <A HREF="009113.html">[squid-dev] ISO 17025 - Οργάνωση Εργαστηρίων
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9120">[ date ]</a>
              <a href="thread.html#9120">[ thread ]</a>
              <a href="subject.html#9120">[ subject ]</a>
              <a href="author.html#9120">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
