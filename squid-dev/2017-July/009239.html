<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Reuse%20reserved%20Negotiate%20and%20NTLM%20helpers%0A%20after%20an%20idle%20timeout.&In-Reply-To=%3Cf9c36804-a281-a924-b281-1bcf0ec5773f%40chtsanti.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009236.html">
   <LINK REL="Next"  HREF="009240.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.</H1>
    <B>Christos Tsantilas</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Reuse%20reserved%20Negotiate%20and%20NTLM%20helpers%0A%20after%20an%20idle%20timeout.&In-Reply-To=%3Cf9c36804-a281-a924-b281-1bcf0ec5773f%40chtsanti.net%3E"
       TITLE="[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.">christos at chtsanti.net
       </A><BR>
    <I>Mon Jul 31 10:24:16 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009236.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
        <LI>Next message: <A HREF="009240.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9239">[ date ]</a>
              <a href="thread.html#9239">[ thread ]</a>
              <a href="subject.html#9239">[ subject ]</a>
              <a href="author.html#9239">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Στις 30/07/2017 06:48 πμ, ο Amos Jeffries έγραψε:
&gt;<i> On 27/07/17 18:52, Christos Tsantilas wrote:
</I>&gt;&gt;<i> The patch.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Στις 26/07/2017 12:37 μμ, ο Christos Tsantilas έγραψε:
</I>&gt;&gt;&gt;<i> Squid can be killed or maimed by enough clients that start multi-step 
</I>&gt;&gt;&gt;<i> connection authentication but never follow up with the second HTTP 
</I>&gt;&gt;&gt;<i> request while keeping their HTTP connection open. Affected helpers 
</I>&gt;&gt;&gt;<i> remain in the &quot;reserved&quot; state and cannot be reused for other 
</I>&gt;&gt;&gt;<i> clients. Observed helper exhaustion has happened without any 
</I>&gt;&gt;&gt;<i> malicious intent.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> To address the problem, we add a helper reservation timeout. Timed 
</I>&gt;&gt;&gt;<i> out reserved helpers may be reused by new clients/connections. To 
</I>&gt;&gt;&gt;<i> minimize problems with slow-to-resume-authentication clients, timed 
</I>&gt;&gt;&gt;<i> out reserved helpers are not reused until there are no unreserved 
</I>&gt;&gt;&gt;<i> running helpers left. The reservations are tracked using unique 
</I>&gt;&gt;&gt;<i> integer IDs.
</I>&gt;&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Since NTLM and Negotiate are both very stateful security protocols this 
</I>&gt;<i> re-use is only possible if the helper is using concurrency in its 
</I>&gt;<i> communications with Squid. To do so otherwise would randomly allow 
</I>&gt;<i> replay attacks to succeed - in a way that would be extremely nasty to 
</I>&gt;<i> troubleshoot. Attackers are fully able to flood an auth backend with 
</I>&gt;<i> traffic outside of Squid and slow it down sufficiently for this attack 
</I>&gt;<i> to become a problem.
</I>&gt;<i>   Note that the type-1 tokens where the TCP connection can be closed 
</I>&gt;<i> also should not reserve a helper - if that is happening it is a bug 
</I>&gt;<i> regardless of this patch.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> To reach the desired behaviour it would be better to actually implement 
</I>&gt;<i> concurrency support for the stateful helpers interfaces. So we can 
</I>&gt;<i> ensure the helper is fully aware of the separation between clients auth 
</I>&gt;<i> sessions regardless of whether any given token gets replayed.
</I>&gt;<i> 
</I>&gt;<i> It should not be much of a step to use the concurrency channel-ID as 
</I>&gt;<i> part of the reservationId. Helpers that support concurrency should not 
</I>&gt;<i> have trouble servicing auth on other channel-ID until the total number 
</I>&gt;<i> of reserved channels gets extremely high. At that point restarting the 
</I>&gt;<i> helper is sane and the existing on-persistent-overload logics can be 
</I>&gt;<i> applied to whether Squid dies or simply kills the blocked helper (ERR).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This patch is going most of the way towards that already by using 
</I>&gt;<i> reservation-ID to replace hardcoded class dependencies, and moving a lot 
</I>&gt;<i> of code to the Base class. But it does not go far enough to make the 
</I>&gt;<i> change safe to add to Squid IMO.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> NP: I have only briefly checked the code to be sure this was not 
</I>&gt;<i> actually doing the concurrency change yet without mentioning it. 
</I>&gt;<i> However, one other major issue stands out;
</I>&gt;<i> 
</I>&gt;<i> StatefulGetFirstAvailable() is a C-style accessor method for the 
</I>&gt;<i> stateful_helper, we simply have not managed to make it one properly yet. 
</I>&gt;<i> The value it is given is the context within/for which the caller needs 
</I>&gt;<i> it to find a usable *_server. Changing that context in order to find a 
</I>&gt;<i> different server result (for some other context) is not an appropriate 
</I>&gt;<i> thing to be doing.
</I>&gt;<i> 
</I>&gt;<i> The only thing in the new code for StatefulGetFirstAvailable() which 
</I>&gt;<i> might lead to it needing non-const is the HelperServerBase::reserved() 
</I>&gt;<i> method being indirectly called. That method should be &quot;virtual bool 
</I>&gt;<i> reserved() const = 0&quot;. Fixing that should make the 
</I>
Yes this method can be const.

&gt;<i> StatefulGetFirstAvailable() API const'ness change unnecessary.
</I>
This change was not required in any case. Sorry.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -1 for now, and please do not apply this until the replay attack problem 
</I>&gt;<i> is fully resolved.
</I>
My sense is that the attack problem can never be &quot;fully&quot; resolved.
But the patch does not try to solve any attack problem. It try to solve 
problems on normal squid operation.

This patch plus the client_ip_max_connections option, and a small 
reservation-timeout value should be enough for most cases.

Using concurrency for stateful helpers require changes in existing 
stateful helpers distributed with squid and other custom helpers used by 
many users. The changes investigated by this patch required even if we 
are going to support concurrency to allow users using their existing 
helpers.

As you said &quot;this patch is going most of the way towards&quot;.
I do not think it is good idea to reject this patch only because it 
&quot;does not go far enough&quot;. In a second step and if required, we can 
implement concurrency on stateful helpers.


&gt;<i> 
</I>&gt;<i> Amos
</I>
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009236.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
	<LI>Next message: <A HREF="009240.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9239">[ date ]</a>
              <a href="thread.html#9239">[ thread ]</a>
              <a href="subject.html#9239">[ subject ]</a>
              <a href="author.html#9239">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
