<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Reuse%20reserved%20Negotiate%20and%20NTLM%20helpers%0A%20after%20an%20idle%20timeout.&In-Reply-To=%3C850deed3-72be-92de-9eed-c8763584697a%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009239.html">
   <LINK REL="Next"  HREF="009241.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Reuse%20reserved%20Negotiate%20and%20NTLM%20helpers%0A%20after%20an%20idle%20timeout.&In-Reply-To=%3C850deed3-72be-92de-9eed-c8763584697a%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Jul 31 15:24:54 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009239.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
        <LI>Next message: <A HREF="009241.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9240">[ date ]</a>
              <a href="thread.html#9240">[ thread ]</a>
              <a href="subject.html#9240">[ subject ]</a>
              <a href="author.html#9240">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 31/07/17 22:24, Christos Tsantilas wrote:
&gt;<i> Στις 30/07/2017 06:48 πμ, ο Amos Jeffries έγραψε:
</I>&gt;&gt;<i> On 27/07/17 18:52, Christos Tsantilas wrote:
</I>&gt;&gt;&gt;<i> The patch.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Στις 26/07/2017 12:37 μμ, ο Christos Tsantilas έγραψε:
</I>&gt;&gt;&gt;&gt;<i> Squid can be killed or maimed by enough clients that start 
</I>&gt;&gt;&gt;&gt;<i> multi-step connection authentication but never follow up with the 
</I>&gt;&gt;&gt;&gt;<i> second HTTP request while keeping their HTTP connection open. 
</I>&gt;&gt;&gt;&gt;<i> Affected helpers remain in the &quot;reserved&quot; state and cannot be reused 
</I>&gt;&gt;&gt;&gt;<i> for other clients. Observed helper exhaustion has happened without 
</I>&gt;&gt;&gt;&gt;<i> any malicious intent.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> To address the problem, we add a helper reservation timeout. Timed 
</I>&gt;&gt;&gt;&gt;<i> out reserved helpers may be reused by new clients/connections. To 
</I>&gt;&gt;&gt;&gt;<i> minimize problems with slow-to-resume-authentication clients, timed 
</I>&gt;&gt;&gt;&gt;<i> out reserved helpers are not reused until there are no unreserved 
</I>&gt;&gt;&gt;&gt;<i> running helpers left. The reservations are tracked using unique 
</I>&gt;&gt;&gt;&gt;<i> integer IDs.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Since NTLM and Negotiate are both very stateful security protocols 
</I>&gt;&gt;<i> this re-use is only possible if the helper is using concurrency in its 
</I>&gt;&gt;<i> communications with Squid. To do so otherwise would randomly allow 
</I>&gt;&gt;<i> replay attacks to succeed - in a way that would be extremely nasty to 
</I>&gt;&gt;<i> troubleshoot. Attackers are fully able to flood an auth backend with 
</I>&gt;&gt;<i> traffic outside of Squid and slow it down sufficiently for this attack 
</I>&gt;&gt;<i> to become a problem.
</I>&gt;&gt;<i>   Note that the type-1 tokens where the TCP connection can be closed 
</I>&gt;&gt;<i> also should not reserve a helper - if that is happening it is a bug 
</I>&gt;&gt;<i> regardless of this patch.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To reach the desired behaviour it would be better to actually 
</I>&gt;&gt;<i> implement concurrency support for the stateful helpers interfaces. So 
</I>&gt;&gt;<i> we can ensure the helper is fully aware of the separation between 
</I>&gt;&gt;<i> clients auth sessions regardless of whether any given token gets 
</I>&gt;&gt;<i> replayed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It should not be much of a step to use the concurrency channel-ID as 
</I>&gt;&gt;<i> part of the reservationId. Helpers that support concurrency should not 
</I>&gt;&gt;<i> have trouble servicing auth on other channel-ID until the total number 
</I>&gt;&gt;<i> of reserved channels gets extremely high. At that point restarting the 
</I>&gt;&gt;<i> helper is sane and the existing on-persistent-overload logics can be 
</I>&gt;&gt;<i> applied to whether Squid dies or simply kills the blocked helper (ERR).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This patch is going most of the way towards that already by using 
</I>&gt;&gt;<i> reservation-ID to replace hardcoded class dependencies, and moving a 
</I>&gt;&gt;<i> lot of code to the Base class. But it does not go far enough to make 
</I>&gt;&gt;<i> the change safe to add to Squid IMO.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> NP: I have only briefly checked the code to be sure this was not 
</I>&gt;&gt;<i> actually doing the concurrency change yet without mentioning it. 
</I>&gt;&gt;<i> However, one other major issue stands out;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> StatefulGetFirstAvailable() is a C-style accessor method for the 
</I>&gt;&gt;<i> stateful_helper, we simply have not managed to make it one properly 
</I>&gt;&gt;<i> yet. The value it is given is the context within/for which the caller 
</I>&gt;&gt;<i> needs it to find a usable *_server. Changing that context in order to 
</I>&gt;&gt;<i> find a different server result (for some other context) is not an 
</I>&gt;&gt;<i> appropriate thing to be doing.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The only thing in the new code for StatefulGetFirstAvailable() which 
</I>&gt;&gt;<i> might lead to it needing non-const is the HelperServerBase::reserved() 
</I>&gt;&gt;<i> method being indirectly called. That method should be &quot;virtual bool 
</I>&gt;&gt;<i> reserved() const = 0&quot;. Fixing that should make the 
</I>&gt;<i> 
</I>&gt;<i> Yes this method can be const.
</I>&gt;<i> 
</I>&gt;&gt;<i> StatefulGetFirstAvailable() API const'ness change unnecessary.
</I>&gt;<i> 
</I>&gt;<i> This change was not required in any case. Sorry.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -1 for now, and please do not apply this until the replay attack 
</I>&gt;&gt;<i> problem is fully resolved.
</I>&gt;<i> 
</I>&gt;<i> My sense is that the attack problem can never be &quot;fully&quot; resolved.
</I>&gt;<i> But the patch does not try to solve any attack problem. It try to solve 
</I>&gt;<i> problems on normal squid operation.
</I>
The problem you described of helpers being hung in reserved state cannot 
happen during *normal* NTLM/Negotiate operations. Normal clients a) 
complete the auth sequence, or b) terminate the connection quickly and 
thus trigger cleanups to happen in Squid, or c) are actually still going 
to produce the token this helper is reserved and waiting for. None of 
the _normal_ traffic cases are served well by this change.

So either there is a bug in Squid client-connection cleanup (case 'b') 
which you are not addressing at all. Or, the use-case you are solving 
for here are ones where clients are performing a DoS attack against the 
proxy, whether you understood that or not.


What your patch does is changing a basic DoS vulnerability to an account 
hijacking / replay vulnerability. Even though the replay may be much 
more difficult to achieve than the original DoS the damage and severity 
when it happens is far, far worse. Sufficiently so that the original DoS 
is preferable to have happening.

At the very least the DoS situation is easy to see and remedy. Probably 
that visibility is why it gets so much complaining and the other 
(several!) common problems with these helpers get hardly a mention.


&gt;<i> 
</I>&gt;<i> This patch plus the client_ip_max_connections option, and a small 
</I>&gt;<i> reservation-timeout value should be enough for most cases.
</I>&gt;<i> 
</I>&gt;<i> Using concurrency for stateful helpers require changes in existing 
</I>&gt;<i> stateful helpers distributed with squid and other custom helpers used by 
</I>&gt;<i> many users. The changes investigated by this patch required even if we 
</I>&gt;<i> are going to support concurrency to allow users using their existing 
</I>&gt;<i> helpers.
</I>
I'm not proposing that we change the interface to concurrency always-on. 
It should be consistent with the concurrency on the other helper 
interfaces, which is default-off but available for those who need and 
can use it. For all those same reasons you mention.

For NTLM the common (only?) helper is the Samba one. That apparently 
already supports concurrency. So if that works with our latest type of 
concurrency numbering, then the change should not be a huge problem for 
NTLM users.

For Kerberos the common helpers are Marcus ones which we ship with 
Squid. Some coordination will be needed there to keep his separately 
distributed copy in sync, but relatively easy.



&gt;<i> 
</I>&gt;<i> As you said &quot;this patch is going most of the way towards&quot;.
</I>&gt;<i> I do not think it is good idea to reject this patch only because it 
</I>&gt;<i> &quot;does not go far enough&quot;. In a second step and if required, we can 
</I>&gt;<i> implement concurrency on stateful helpers.
</I>
In this case not going far enough leaves open a far worse vulnerability 
than the one being resolved. I'm rejecting it primarily because of the 
replay/hijack addition being worse than the DoS.

If you can come up with some other way to avoid the DoS pains without 
getting into worse problems I am open to temporary measures. But given 
the direction this code has gone it seems to me that going for the 
concurrency support is less additional work than the analysis required 
to find+code good alternatives would take.


FWIW; I am tempted by the old idea of just letting Squid abort the 
helpers that are hung and starting new ones afresh. But experiences 
coming back from people using the dynamic-helpers feature show that even 
that does not help much. Instead of Squid aborting with the FATAL 
message it continues until the kernel oom-killer aborts it instead 
anyway, or for some very high-performance proxies the TCP stack can 
still run out of sockets in the half second or so before the new helpers 
have started producing responses.
  Up to you whether you think implementing that as a quick-fix is worth it.


Amos
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009239.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
	<LI>Next message: <A HREF="009241.html">[squid-dev] [PATCH] Reuse reserved Negotiate and NTLM helpers after an idle timeout.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9240">[ date ]</a>
              <a href="thread.html#9240">[ thread ]</a>
              <a href="subject.html#9240">[ subject ]</a>
              <a href="author.html#9240">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
