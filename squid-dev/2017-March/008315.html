<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] VIA creation code duplication
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20VIA%20creation%20code%20duplication&In-Reply-To=%3C4642e8d0-482a-df2e-c795-646c69a66422%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008314.html">
   <LINK REL="Next"  HREF="008326.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] VIA creation code duplication</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20VIA%20creation%20code%20duplication&In-Reply-To=%3C4642e8d0-482a-df2e-c795-646c69a66422%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] VIA creation code duplication">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Mar 22 15:08:10 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008314.html">[squid-dev] [PATCH] VIA creation code duplication
</A></li>
        <LI>Next message: <A HREF="008326.html">[squid-dev] [PATCH] VIA creation code duplication
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8315">[ date ]</a>
              <a href="thread.html#8315">[ thread ]</a>
              <a href="subject.html#8315">[ subject ]</a>
              <a href="author.html#8315">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/22/2017 07:20 AM, Amos Jeffries wrote:
&gt;<i> On 17/03/2017 6:17 a.m., Alex Rousskov wrote:
</I>&gt;&gt;<i> On 03/16/2017 05:15 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Any objections to applying this with this added:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   // XXX: putStr() still has String 64KB limits
</I>&gt;&gt;&gt;<i>   Must(strVia.length() &lt; 64*1024);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No objections from me if you replace the magic constant with a new
</I>&gt;&gt;<i> inlined String::MaxSizeXXX() method. The slightly misleading source code
</I>&gt;&gt;<i> comment above becomes unnecessary after that. Why XXX()? Because no
</I>&gt;&gt;<i> correct caller code should know about internal String limits (but it may
</I>&gt;&gt;<i> catch exceptions, including exceptions due to those limits).
</I>

&gt;<i> it seems reasonable for a caller to expect there to be _a_ limit.
</I>
Yes, although it is easy to misinterpret &quot;expect&quot; in this context. Any
concatenation or append operation may fail because it hits some kind of
a limit. We should go even further: Almost any operation may fail. This
is a fact. This fact should be common knowledge, and the code should
&quot;expect&quot; such failures. However, &quot;expect&quot; here usually does not imply
&quot;prevent&quot;. It usually means &quot;handle&quot;. The critical difference becomes
important in the second part of my answer to your question(**).

Moreover, since almost everything can fail, good programs written in
modern languages do not handle failures the same way programs written in
C do. The old (and failed)

C: &quot;check each return value for being invalid and immediately treat an
invalid value as an error&quot;

approach becomes

C++: &quot;only return valid values but anticipate exceptions and catch them
where it is convenient&quot;

or

Rust: &quot;do not return raw values and unwrap either-value-or-error bundles
(and handle errors) where it is necessary to access the raw value&quot; (AFAIK)


&gt;<i> It is also reasonable for the caller to be aware of some API way
</I>&gt;<i> to find it out.
</I>
It is certainly tempting but usually wrong. The exact limit, which
operations it applies to, and how exactly it is applied is an internal
implementation detail. In the case of a SomeString class, for example,
the fact that some String classes always append the null terminator,
some never do, and some append under certain conditions may affect how
the limit is applied. Burdening the caller with all that internal String
knowledge is clearly wrong.

As mentioned earlier(**), the correct approach is to handle the
situation where the caller has hit some limit and the called operation
has thrown an exception. Since we do not want to (and often cannot
reliably) prevent our actions from hitting limits, exposing some limit
is unnecessary, and the code using such an exposed limit is likely to be
or become buggy. This is why we should add and XXX suffix to the
limit-returning method that encourages writing such code.

Various buggy versions of the patch in question (and earlier Squid code
suffering from similar crashes) illustrate the advantages of the &quot;do not
try to prevent errors because you will fail; throw and handle exceptions
instead&quot; approach well.

There are certainly exceptional situations where these general
approaches either do not apply at all or cannot be applied until the
code is restructured/fixed. In the latter cases, we add XXXs in attempt
to mark bad code (even if that code is currently necessary) and slow
down the propagation of that bad code or its bad idea.


&gt;&gt;&gt;<i> (I kind of hate those low-level operations with Must() and assert() like
</I>&gt;&gt;&gt;<i> the former - far too little context to be useful debugging with such big
</I>&gt;&gt;&gt;<i> impact when they are triggered.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> While it is indeed tempting to hate those Must(), we must keep in mind
</I>&gt;&gt;<i> that low-level assert-replacing Must()s are not meant for debugging or
</I>&gt;&gt;<i> even traditional error handling. Their purpose is to (hopefully) prevent
</I>&gt;&gt;<i> Squid death.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> When the crash avoidance project completes, we will have a way to dump
</I>&gt;&gt;<i> stack traces for specific Must()s, which will provide the same level of
</I>&gt;&gt;<i> triage info as an assert() would, but (hopefully) without killing Squid
</I>&gt;&gt;<i> in environments where such functionality is supported.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Any kind of estimate on that?
</I>
2017 or so. No sponsor gives this work high priority so it is currently
a barely moving background project.


Cheers,

Alex.

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008314.html">[squid-dev] [PATCH] VIA creation code duplication
</A></li>
	<LI>Next message: <A HREF="008326.html">[squid-dev] [PATCH] VIA creation code duplication
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8315">[ date ]</a>
              <a href="thread.html#8315">[ thread ]</a>
              <a href="subject.html#8315">[ subject ]</a>
              <a href="author.html#8315">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
