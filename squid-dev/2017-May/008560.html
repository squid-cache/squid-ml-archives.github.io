<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] xstrndup has to go
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20xstrndup%20has%20to%20go&In-Reply-To=%3C0f7b32d4-57a5-9d48-32a2-2ea8c375cdcb%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008567.html">
   <LINK REL="Next"  HREF="008563.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] xstrndup has to go</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20xstrndup%20has%20to%20go&In-Reply-To=%3C0f7b32d4-57a5-9d48-32a2-2ea8c375cdcb%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] xstrndup has to go">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon May  1 05:26:14 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008567.html">[squid-dev] A new 'has' ACL
</A></li>
        <LI>Next message: <A HREF="008563.html">[squid-dev] [PATCH] xstrndup has to go
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8560">[ date ]</a>
              <a href="thread.html#8560">[ thread ]</a>
              <a href="subject.html#8560">[ subject ]</a>
              <a href="author.html#8560">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 30/04/17 04:17, Alex Rousskov wrote:
&gt;<i> On 04/29/2017 02:33 AM, Amos Jeffries wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> If that is too hard, making callers do the allocate bit themselves and
</I>&gt;&gt;<i> xstrncpy() instead should be a good medium-term workaround.
</I>&gt;<i> In general, it is impossible to correctly replace strndup() with a
</I>&gt;<i> simple allocate and strncpy() pair. I bet this impossibility is why
</I>&gt;<i> strndup() exists! strndup() is not a convenience function, but an
</I>&gt;<i> irreplaceable tool in a performance toolbox.
</I>&gt;<i>
</I>&gt;<i> Why is it impossible in general? Because you do not know how many bytes
</I>&gt;<i> to allocate (that number may be much smaller than n) and you cannot use
</I>&gt;<i> strlen() to find out because the array may not be 0-terminated. You need
</I>&gt;<i> strnlen(), which is usually not available where strndup() is not.
</I>
We don't need to solve the general case. We need to solve the handful of 
actual uses in Squid code, then add the risky function to the forbidden 
list which is enforced by sourcemaintenance.sh.


&gt;<i>
</I>&gt;&gt;&gt;<i> P.S. The OutOfBoundsException use case code fixed by this patch needs a
</I>&gt;&gt;&gt;<i> different fix (the one that does not allocate memory twice):
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     xstrndup(explanatoryText.rawContent(), explanatoryText.length());
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> but we cannot do the above until xstrndup() implementation is fixed.
</I>&gt;&gt;<i> Not even by moving that caller to xmalloc() for itself and use xstrncpy() ?
</I>&gt;<i> xmalloc()+xstrncpy() is not &quot;doing the above&quot; it is doing something
</I>&gt;<i> else. I only claimed that we &quot;cannot do the above&quot; (literally). There
</I>&gt;<i> are other ways to achieve the same result, of course. None of those
</I>&gt;<i> other ways that I can think of (in the current code context) are better
</I>&gt;<i> than the proposed double-copy IMO.
</I>&gt;<i>
</I>&gt;<i> Sure, it is possible to do xmalloc()+memcpy() in this context instead of
</I>&gt;<i> xstrndup(), but, in this context, that would be arguably worse than
</I>&gt;<i> copying twice because it would replace a clear high-level code with
</I>&gt;<i> risky low-level manipulations on an error handling path.
</I>&gt;<i>
</I>&gt;<i> If strdup(buf.c_str()) pattern appears often, we should add
</I>&gt;<i> SBuf::c_str_dup() that does xmalloc()+memcpy().
</I>
strdup != strndup.

For strdup() replacement we absolutely can do strlen(). It requires 
nul-termination explicitly.

The xstrndup(F.c_str(), ...) pattern appears exactly once. In this 
exception handler under discussion.

My question was about that one use-case you highlighted as example, not 
the general solution. It appears to me that while there is some 
variation caused by the message contents being filename and line numbers 
- they are still short enough that over-allocation is not a huge problem 
and whatever exception handler catches this will end with deallocation 
quite quickly.

The relevant lines being these:
  src/sbuf/Exceptions.cc:    SBuf explanatoryText(&quot;OutOfBoundsException&quot;);
  src/sbuf/Exceptions.cc:        explanatoryText.appendf(&quot; at line %d&quot;, 
aLineNo);
  src/sbuf/Exceptions.cc:        explanatoryText.appendf(&quot; in file %s&quot;, 
aFileName);
  src/sbuf/Exceptions.cc:    explanatoryText.appendf(&quot; while accessing 
position %d in a SBuf long %d&quot;,
  src/sbuf/Exceptions.cc:    message = 
xstrndup(explanatoryText.c_str(),explanatoryText.length());

Over-allocation appears to only be possible if/when the aFileName 
contains null characters internally. Then rawContent() instead of 
c_str() drops the extra allocation.

xstrncpy() still halts on the input \0 character if it happens early 
regardless of whether c_str() or rawContent() is used to supply the 
input. And passing it length()+1 safely handles non-terminated input 
without an length()+1 byte allocated because xstrncpy ends on the n'th 
byte for terminating *dst instead of copying it from input.


PS. appendf() is probably causing a re-allocation as well to grow the 
MemBlob. So we are looking at probably three allocations here. If this 
exception handler is stable enough now to be worth optimizing we should 
probably also look at ways to reserve enough memory for explanatoryText 
before putting anything into it.

&gt;&gt;<i> +1 if you update the patch to do the above. +0 otherwise  - ie. go ahead
</I>&gt;&gt;<i> with commit if you want, but I'd rather see the fixed caller(s) fixed to
</I>&gt;&gt;<i> use a more long-ish term fix.
</I>&gt;<i> Understood. We disagree regarding the &quot;more long-ish&quot; fix desirability.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thank you,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-dev mailing list
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008567.html">[squid-dev] A new 'has' ACL
</A></li>
	<LI>Next message: <A HREF="008563.html">[squid-dev] [PATCH] xstrndup has to go
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8560">[ date ]</a>
              <a href="thread.html#8560">[ thread ]</a>
              <a href="subject.html#8560">[ subject ]</a>
              <a href="author.html#8560">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
