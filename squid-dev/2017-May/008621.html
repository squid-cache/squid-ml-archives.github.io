<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Happy%20Eyeballs%3A%20Use%20each%20fully%20resolved%0A%20destination%20ASAP&In-Reply-To=%3C36eb0977-61ca-01e1-43c4-f01797eceafd%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008612.html">
   <LINK REL="Next"  HREF="008671.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Happy%20Eyeballs%3A%20Use%20each%20fully%20resolved%0A%20destination%20ASAP&In-Reply-To=%3C36eb0977-61ca-01e1-43c4-f01797eceafd%40measurement-factory.com%3E"
       TITLE="[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP">rousskov at measurement-factory.com
       </A><BR>
    <I>Tue May 16 17:41:14 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008612.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
        <LI>Next message: <A HREF="008671.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8621">[ date ]</a>
              <a href="thread.html#8621">[ thread ]</a>
              <a href="subject.html#8621">[ subject ]</a>
              <a href="author.html#8621">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 05/16/2017 03:31 AM, Amos Jeffries wrote:
&gt;<i> On 16/05/17 16:33, Alex Rousskov wrote:
</I>&gt;&gt;<i>      The attached patch is the first in a short series of patches that
</I>&gt;&gt;<i> improve Squid support for the Happy Eyeballs principle. The motivation
</I>&gt;&gt;<i> for these patches has been discussed on the dns_wait_for_all thread:
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/pipermail/squid-dev/2016-September/006831.html">http://lists.squid-cache.org/pipermail/squid-dev/2016-September/006831.html</A>
</I>
&gt;<i> NP: This is not implementing the Happy Eyeballs *algorithm*
</I>
The proposed patch contains changes necessary (but not sufficient!) to
implement a Happy Eyeballs algorithm.


&gt;<i> (it is an explicitly standardized algorithm name, not a principle). 
</I>
It is both (and more!). The term &quot;Happy Eyeballs&quot; and RFC 6555 cover:

* a set of algorithm requirements (i.e., &quot;principles&quot; or &quot;goals&quot;)
* an abstract algorithm that satisfies those requirements
* an example implementation of the algorithm in Chrome


&gt;<i> &quot;Happy Eyeballs&quot; algorithm is specifically a DNS feature.
</I>
The Happy Eyeballs algorithm is a combination of DNS and TCP (or other
transport-layer) actions. You might want to reread RFC 6555 if you think
that Happy Eyeballs is only (or even primarily) about DNS!


&gt;&gt;<i> With this change, Squid no longer waits for all request forwarding
</I>&gt;&gt;<i> destinations to be resolved. Instead, it uses each fully resolved
</I>&gt;&gt;<i> destination as soon as it is needed. More info is in the patch preamble.
</I>
&gt;<i> More correctly this code does not even begin to resolve some
</I>&gt;<i> destinations until others are already started being connected to.
</I>
I do not think this is a &quot;more correct&quot; statement. I find it distracting
and misleading because the &quot;started being connected to&quot; is too vague to
be reliably interpreted in this context and, to be &quot;correct&quot;, it has too
be interpreted at a such a low/literal level that it looses its relevance.

In hope to avoid wasting timing on perfecting vague terminology, here is
a realistic example with two destination domain names (A and B), each
having two IP addresses (v4 and v6), with IPv6 preferred. To illustrate
all possible steps, we consider the case where all HTTP transactions
fail. The patch essentially changes these sequential steps:

  1. Resolve A (getting A4 and A6 IPs).
  2. Resolve B (getting B4 and B6 IPs).
  3. Execute HTTP transaction with A6.
  4. Execute HTTP transaction with A4.
  5. Execute HTTP transaction with B6.
  6. Execute HTTP transaction with B4.

to these three groups of partially parallelized steps:

  1. Resolve A (getting A4 and A6 IPs).

  2. Resolve B (getting B4 and B6 IPs).
  3. Execute HTTP transaction with A6.

  4. Execute HTTP transaction with A4.
  5. Execute HTTP transaction with B6.
  6. Execute HTTP transaction with B4.

where steps 2 and 3 now run in parallel. In extreme cases where B
resolution is slower than HTTP transaction with A6, step 2 and step 4
now run in parallel as well!

Whether the first DNS byte resolving B will be written to the network
before or after the first TCP byte for A6 depends on many factors such
as HTTP persistent connection availability, slow ACLs, and I/O socket
readiness. Both step 2 and step 3 are not instantaneous actions but
relatively long activities with several asynchronous subtasks so it is
pointless to argue how to exactly define their &quot;start&quot; (or &quot;finish&quot;)
time and whether step 2 will always &quot;start&quot; before 3. It is sufficient
to say that both will start shortly after step 1 and run in parallel.

Finally, we should eventually use asynchronous calls among the peer
selection code, the FwdState/tunnel jobs, and the DNS resolution code.
Some of those calls are already asynchronous, but I did not add more of
them in this patch, primarily because FwdState and TunnelStateData are
not AsyncJobs (and converting them to become AsyncJobs or equivalent is
a large out of scope project). When those asynchronous calls are in
place, even the first code statements of steps 2 and 3 will be
parallelized (to the extend such parallelization is possible in Squid).


&gt;<i> It is a step back to non-deterministic forwarding timeouts.
</I>
How do you define &quot;non-deterministic forwarding timeouts&quot;?

I do not think the patch increases the number of timed out transactions
in any significant or important way, but if it does, I would like to
learn about it and either fix the code or disclose the problem. I hope
the above specific example helps you withdraw this accusation.


&gt;&gt;<i> The next planned step is to deliver A and AAAA answers to the peer
</I>&gt;&gt;<i> selection code independently and ASAP. When both changes are combined,
</I>&gt;&gt;<i> the FwdState/tunneling code will receive IPvX addresses without waiting
</I>&gt;&gt;<i> for IPvY addresses (and/or other destination names) to be resolved,
</I>&gt;&gt;<i> making user eyeballs happier and, hence, facilitating IPv6 deployments.
</I>
&gt;<i> *That* is the missing part of Happy Eyeballs.
</I>
Yes, that too, and there is one more part not discussed in the preamble
because it is currently not planned as a part of this patch series. From
Squid point of view, Happy Eyeballs implementation needs at least four
distinct parts:

1. Squid currently implements: Use parallel A and AAAA queries.
2. This patch: ASAP delivery of IPs from peer selection to FwdState.
3. The next step: ASAP delivery of IPs from DNS to peer selection.
4. A separate project should add: Use parallel TCP connections.

(The above are very rough gists that identify critical Happy Eyeballs
features, not precise definitions of algorithms.)


&gt;<i> * s/Will aborting forwarding/Will abort forwarding/
</I>
Fixed.


&gt;<i> * psstate-&gt;lastError = NULL; // initiator owns the ErrorState object now
</I>&gt;<i>  - please use nullptr on moved or new lines
</I>
Fixed.

The attached patch contains the above two fixes. No other changes.


&gt;<i> * The call to noteDestinationsEnd() with an error from
</I>&gt;<i> peerSelectDnsResults() appears to abort *all* path connection attempts
</I>&gt;<i> by the initiator
</I>
When peerSelectDnsResults() is called with a non-nil error, there could
have been no connection attempts at all because a non-nil error means
that no paths have been found (i.e., psstate-&gt;foundPaths is zero). Here
is the corresponding calling code, with irrelevant lines removed:

    if (psstate-&gt;lastError &amp;&amp; psstate-&gt;foundPaths)
        psstate-&gt;lastError = nullptr;

    initiator-&gt;noteDestinationsEnd(psstate-&gt;lastError);


Please correct me if I am wrong.


Thank you,

Alex.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: SQUID69-use-destination-asap-t3.patch
Type: text/x-diff
Size: 78543 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20170516/3658fe13/attachment-0001.patch">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20170516/3658fe13/attachment-0001.patch</A>&gt;
</PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008612.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
	<LI>Next message: <A HREF="008671.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8621">[ date ]</a>
              <a href="thread.html#8621">[ thread ]</a>
              <a href="subject.html#8621">[ subject ]</a>
              <a href="author.html#8621">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
