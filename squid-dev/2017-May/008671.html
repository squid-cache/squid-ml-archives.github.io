<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Happy%20Eyeballs%3A%20Use%20each%20fully%20resolved%0A%20destination%20ASAP&In-Reply-To=%3C2630676d-2e22-c309-6897-558c9dc22b17%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="008621.html">
   <LINK REL="Next"  HREF="008675.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20%5BPATCH%5D%20Happy%20Eyeballs%3A%20Use%20each%20fully%20resolved%0A%20destination%20ASAP&In-Reply-To=%3C2630676d-2e22-c309-6897-558c9dc22b17%40treenet.co.nz%3E"
       TITLE="[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed May 24 15:04:19 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="008621.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
        <LI>Next message: <A HREF="008675.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8671">[ date ]</a>
              <a href="thread.html#8671">[ thread ]</a>
              <a href="subject.html#8671">[ subject ]</a>
              <a href="author.html#8671">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 17/05/17 05:41, Alex Rousskov wrote:
&gt;<i> On 05/16/2017 03:31 AM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 16/05/17 16:33, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i>       The attached patch is the first in a short series of patches that
</I>&gt;&gt;&gt;<i> improve Squid support for the Happy Eyeballs principle. The motivation
</I>&gt;&gt;&gt;<i> for these patches has been discussed on the dns_wait_for_all thread:
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/pipermail/squid-dev/2016-September/006831.html">http://lists.squid-cache.org/pipermail/squid-dev/2016-September/006831.html</A>
</I>&gt;&gt;<i> NP: This is not implementing the Happy Eyeballs *algorithm*
</I>&gt;<i> The proposed patch contains changes necessary (but not sufficient!) to
</I>&gt;<i> implement a Happy Eyeballs algorithm.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> (it is an explicitly standardized algorithm name, not a principle).
</I>&gt;<i> It is both (and more!). The term &quot;Happy Eyeballs&quot; and RFC 6555 cover:
</I>&gt;<i>
</I>&gt;<i> * a set of algorithm requirements (i.e., &quot;principles&quot; or &quot;goals&quot;)
</I>&gt;<i> * an abstract algorithm that satisfies those requirements
</I>&gt;<i> * an example implementation of the algorithm in Chrome
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> &quot;Happy Eyeballs&quot; algorithm is specifically a DNS feature.
</I>&gt;<i> The Happy Eyeballs algorithm is a combination of DNS and TCP (or other
</I>&gt;<i> transport-layer) actions. You might want to reread RFC 6555 if you think
</I>&gt;<i> that Happy Eyeballs is only (or even primarily) about DNS!
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> With this change, Squid no longer waits for all request forwarding
</I>&gt;&gt;&gt;<i> destinations to be resolved. Instead, it uses each fully resolved
</I>&gt;&gt;&gt;<i> destination as soon as it is needed. More info is in the patch preamble.
</I>&gt;&gt;<i> More correctly this code does not even begin to resolve some
</I>&gt;&gt;<i> destinations until others are already started being connected to.
</I>&gt;<i> I do not think this is a &quot;more correct&quot; statement. I find it distracting
</I>&gt;<i> and misleading because the &quot;started being connected to&quot; is too vague to
</I>&gt;<i> be reliably interpreted in this context and, to be &quot;correct&quot;, it has too
</I>&gt;<i> be interpreted at a such a low/literal level that it looses its relevance.
</I>
Okay to be more accurate:

  For the 1st destination ps_state::handlePath() calls noteDestination() 
which results in the entire TunnelState::startConnecting() / 
FwdState::startConnectionOrFail() sequence happening synchronously 
before returning to ps_state::handlePaths() and peerSelectDnsResults() 
for the 2nd path.

Also the same sequence happens for every Nth destination with 
unpredictable values of N.

... There do not seem to be any performance gains from this redesign for 
transactions where there are less than 3 upstream servers. Which is the 
common case. The synchronous processing may make the one transaction 
reach connection faster, but that is just taking CPU cycles from / 
slowing other transactions.


It might be worth initiating that noteDestination() sub-path as async 
step to avoid the remaining delay. (not asking for it to happen now, 
maybe a TODO note).


&gt;<i> In hope to avoid wasting timing on perfecting vague terminology, here is
</I>&gt;<i> a realistic example with two destination domain names (A and B), each
</I>&gt;<i> having two IP addresses (v4 and v6), with IPv6 preferred. To illustrate
</I>&gt;<i> all possible steps, we consider the case where all HTTP transactions
</I>&gt;<i> fail. The patch essentially changes these sequential steps:
</I>&gt;<i>
</I>&gt;<i>    1. Resolve A (getting A4 and A6 IPs).
</I>&gt;<i>    2. Resolve B (getting B4 and B6 IPs).
</I>&gt;<i>    3. Execute HTTP transaction with A6.
</I>&gt;<i>    4. Execute HTTP transaction with A4.
</I>&gt;<i>    5. Execute HTTP transaction with B6.
</I>&gt;<i>    6. Execute HTTP transaction with B4.
</I>&gt;<i>
</I>&gt;<i> to these three groups of partially parallelized steps:
</I>&gt;<i>
</I>&gt;<i>    1. Resolve A (getting A4 and A6 IPs).
</I>&gt;<i>
</I>&gt;<i>    2. Resolve B (getting B4 and B6 IPs).
</I>&gt;<i>    3. Execute HTTP transaction with A6.
</I>&gt;<i>
</I>&gt;<i>    4. Execute HTTP transaction with A4.
</I>&gt;<i>    5. Execute HTTP transaction with B6.
</I>&gt;<i>    6. Execute HTTP transaction with B4.
</I>&gt;<i>
</I>&gt;<i> where steps 2 and 3 now run in parallel. In extreme cases where B
</I>&gt;<i> resolution is slower than HTTP transaction with A6, step 2 and step 4
</I>&gt;<i> now run in parallel as well!
</I>&gt;<i>
</I>&gt;<i> Whether the first DNS byte resolving B will be written to the network
</I>&gt;<i> before or after the first TCP byte for A6 depends on many factors such
</I>&gt;<i> as HTTP persistent connection availability, slow ACLs, and I/O socket
</I>&gt;<i> readiness. Both step 2 and step 3 are not instantaneous actions but
</I>&gt;<i> relatively long activities with several asynchronous subtasks so it is
</I>&gt;<i> pointless to argue how to exactly define their &quot;start&quot; (or &quot;finish&quot;)
</I>&gt;<i> time and whether step 2 will always &quot;start&quot; before 3. It is sufficient
</I>&gt;<i> to say that both will start shortly after step 1 and run in parallel.
</I>&gt;<i>
</I>&gt;<i> Finally, we should eventually use asynchronous calls among the peer
</I>&gt;<i> selection code, the FwdState/tunnel jobs, and the DNS resolution code.
</I>&gt;<i> Some of those calls are already asynchronous, but I did not add more of
</I>&gt;<i> them in this patch, primarily because FwdState and TunnelStateData are
</I>&gt;<i> not AsyncJobs (and converting them to become AsyncJobs or equivalent is
</I>&gt;<i> a large out of scope project). When those asynchronous calls are in
</I>&gt;<i> place, even the first code statements of steps 2 and 3 will be
</I>&gt;<i> parallelized (to the extend such parallelization is possible in Squid).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> It is a step back to non-deterministic forwarding timeouts.
</I>&gt;<i> How do you define &quot;non-deterministic forwarding timeouts&quot;?
</I>&gt;<i>
</I>&gt;<i> I do not think the patch increases the number of timed out transactions
</I>&gt;<i> in any significant or important way, but if it does, I would like to
</I>&gt;<i> learn about it and either fix the code or disclose the problem. I hope
</I>&gt;<i> the above specific example helps you withdraw this accusation.
</I>
I mean the forwarding timeout on &quot;Squid hangs for X&quot; complaints I deal 
with in squid-users. The X is no longer determined by which component is 
being problematic. It was nice being able to point squid-users questions 
in roughly the right direction without resorting to logs very often.

&gt;<i>
</I>&gt;&gt;&gt;<i> The next planned step is to deliver A and AAAA answers to the peer
</I>&gt;&gt;&gt;<i> selection code independently and ASAP. When both changes are combined,
</I>&gt;&gt;&gt;<i> the FwdState/tunneling code will receive IPvX addresses without waiting
</I>&gt;&gt;&gt;<i> for IPvY addresses (and/or other destination names) to be resolved,
</I>&gt;&gt;&gt;<i> making user eyeballs happier and, hence, facilitating IPv6 deployments.
</I>&gt;&gt;<i> *That* is the missing part of Happy Eyeballs.
</I>&gt;<i> Yes, that too, and there is one more part not discussed in the preamble
</I>&gt;<i> because it is currently not planned as a part of this patch series. From
</I>&gt;<i> Squid point of view, Happy Eyeballs implementation needs at least four
</I>&gt;<i> distinct parts:
</I>&gt;<i>
</I>&gt;<i> 1. Squid currently implements: Use parallel A and AAAA queries.
</I>&gt;<i> 2. This patch: ASAP delivery of IPs from peer selection to FwdState.
</I>&gt;<i> 3. The next step: ASAP delivery of IPs from DNS to peer selection.
</I>&gt;<i> 4. A separate project should add: Use parallel TCP connections.
</I>&gt;<i>
</I>&gt;<i> (The above are very rough gists that identify critical Happy Eyeballs
</I>&gt;<i> features, not precise definitions of algorithms.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * s/Will aborting forwarding/Will abort forwarding/
</I>&gt;<i> Fixed.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * psstate-&gt;lastError = NULL; // initiator owns the ErrorState object now
</I>&gt;&gt;<i>   - please use nullptr on moved or new lines
</I>&gt;<i> Fixed.
</I>&gt;<i>
</I>&gt;<i> The attached patch contains the above two fixes. No other changes.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * The call to noteDestinationsEnd() with an error from
</I>&gt;&gt;<i> peerSelectDnsResults() appears to abort *all* path connection attempts
</I>&gt;&gt;<i> by the initiator
</I>&gt;<i> When peerSelectDnsResults() is called with a non-nil error, there could
</I>&gt;<i> have been no connection attempts at all because a non-nil error means
</I>&gt;<i> that no paths have been found (i.e., psstate-&gt;foundPaths is zero). Here
</I>&gt;<i> is the corresponding calling code, with irrelevant lines removed:
</I>&gt;<i>
</I>&gt;<i>      if (psstate-&gt;lastError &amp;&amp; psstate-&gt;foundPaths)
</I>&gt;<i>          psstate-&gt;lastError = nullptr;
</I>&gt;<i>
</I>&gt;<i>      initiator-&gt;noteDestinationsEnd(psstate-&gt;lastError);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Please correct me if I am wrong.
</I>
Ah, you are right. I was mistaking the peerSelectDns*() function.



Something is still bothering me about the call sequence when M of N 
destinations are passed to FwdState and the Mth one goes through the 
FwdState::complete(){ if (reforward()) ... } path due to explicit 
upstream 4xx/5xx response. It seems that will end with a forwarding 
error if the remaining peers do not yet have DNS results available in 
serverDestinations.


eg. the sequence for 3 possible destinations:

1) destination A gets found and noteDestination(A) called
  1a) this triggers the async startConnectionOrFail()
  1b) A gets connected and request sent ...

2) destination B hit a DNS timeout issue
   - so B never gets passed to FwdState and there is long enough delay 
for (1c) to happen.

1c) server 5xx response arrives for A,
   - the 5xx triggers the FwdState::connect() { if(reforward()) { ... } 
} path
   - which erases (1) from serverDestinations and calls 
startConnectionOrFail()
   - startConnectionOrFail() now has serverDestinations.empty() and an 
error to deliver

3) destination C gets abandoned because FwdState is now gone


Amos
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008621.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
	<LI>Next message: <A HREF="008675.html">[squid-dev] [PATCH] Happy Eyeballs: Use each fully resolved destination ASAP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8671">[ date ]</a>
              <a href="thread.html#8671">[ thread ]</a>
              <a href="subject.html#8671">[ subject ]</a>
              <a href="author.html#8671">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
