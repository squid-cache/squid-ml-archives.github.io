<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Squid 3.5 with nonblocking ecap adapter
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%203.5%20with%20nonblocking%20ecap%20adapter&In-Reply-To=%3C8b20a9f5-09a4-425d-892b-05cbc5a331c6%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009311.html">
   <LINK REL="Next"  HREF="009337.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Squid 3.5 with nonblocking ecap adapter</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%203.5%20with%20nonblocking%20ecap%20adapter&In-Reply-To=%3C8b20a9f5-09a4-425d-892b-05cbc5a331c6%40measurement-factory.com%3E"
       TITLE="[squid-dev] Squid 3.5 with nonblocking ecap adapter">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Nov  2 15:47:41 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009311.html">[squid-dev] Perl script help needed
</A></li>
        <LI>Next message: <A HREF="009337.html">[squid-dev] Squid 3.5 with nonblocking ecap adapter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9312">[ date ]</a>
              <a href="thread.html#9312">[ thread ]</a>
              <a href="subject.html#9312">[ subject ]</a>
              <a href="author.html#9312">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/02/2017 03:49 AM, Christof Gerber wrote:

&gt;<i> One thing I still don't fully understand is if the asynchronous way to
</I>&gt;<i> program and operate Squid with an eCAP adapter necessarily relies on
</I>&gt;<i> threads?
</I>
No, threads are just one popular way to achieve asynchrony. One may also
use multiple processes or (for some definition of asynchrony) event loops.


&gt;<i> Are A) and B) alternatives or the only options?
</I>
If you replace B's &quot;threads&quot; with &quot;threads or other asynchrony
mechanisms&quot;, then yes, IMO. Threads are probably the most popular way to
achieve asynchrony in new code.


&gt;<i> I've seen that both the
</I>&gt;<i> ClamAV and sample async adapter use pthreads. In my use case I need to
</I>&gt;<i> do a simple hash lookup to a file socket somewhen during the eCAP
</I>&gt;<i> interaction. As it will take some milliseconds until the response will
</I>&gt;<i> be available on the socket I don't want to block Squid during this
</I>&gt;<i> time. 
</I>
Yes, this is a common problem.


&gt;<i> But the eCAP adapter won't need to process/compute anything else
</I>&gt;<i> during this time. So why would I bother to use threads? 
</I>
... because without threads (or processes or event loops) your adapter
lookup will block the whole Squid worker while waiting for socket I/O.

If you do not want to use threads or processes in your adapter, then you
can try to use an event loop model. That is what Squid uses internally
(each Squid worker does not have threads to process thousands of
transactions &quot;concurrently&quot;).

To use an event loop model, your adapter will need to use non-blocking
socket I/O and schedule _one_ I/O loop iteration every ~X milliseconds,
when Squid calls your Service::resume(). Try googling &quot;I/O loop&quot; or
&quot;select loop&quot; for starting points if you are not familiar with that
design pattern. The overall host-adapter interaction would be very
similar to what you find in the sample and ClamAV adapters.

Disclaimer: I have not seen anybody using event loops with eCAP. I think
it is possible to implement that model, but there may be important
caveats that I am not aware of.


HTH,

Alex.


&gt;<i> On 1 November 2017 at 16:23, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 11/01/2017 03:20 AM, Christof Gerber wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> [Will Squid] be blocked until the eCAP API call returns?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To answer the exact question above: Yes, the Squid worker making an eCAP
</I>&gt;&gt;<i> API call will block until that call returns. The same is true for all
</I>&gt;&gt;<i> other API calls, all system calls, and all internal calls. This is how
</I>&gt;&gt;<i> C/C++ works. I am stating the obvious for the record, in case somebody
</I>&gt;&gt;<i> with a different (or insufficient) programming languages background
</I>&gt;&gt;<i> stumbles upon this thread.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What you are really asking, I suspect, is whether Squid or the eCAP
</I>&gt;&gt;<i> library uses threads to automatically make eCAP adapter operations
</I>&gt;&gt;<i> asynchronous to the primary Squid operations. The answer to that
</I>&gt;&gt;<i> question is &quot;no&quot;: The relevant Squid code does not use threads, and
</I>&gt;&gt;<i> there are no threads in the eCAP library code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Also, there is no magical layer between Squid and 99% of eCAP calls --
</I>&gt;&gt;<i> Squid calls go directly to your eCAP adapter code and vice versa. IIRC,
</I>&gt;&gt;<i> the only (unimportant) exception to that &quot;direct calls&quot; observation is
</I>&gt;&gt;<i> the eCAP service registry API, where there is a thin eCAP layer
</I>&gt;&gt;<i> insulating the adapter from the host application. That layer is also
</I>&gt;&gt;<i> synchronous though.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Is there a way other than
</I>&gt;&gt;&gt;<i> programming the eCAP adapter in asynchronous mode?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I do not think there is a better alternative. AFAICT, you only have two
</I>&gt;&gt;<i> options:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   A) Change Squid to move eCAP calls to thread(s).
</I>&gt;&gt;<i>   B) Use threads inside the adapter to make its operations asynchronous.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As you know, the sample async adapter and the ClamAV adapter use (B).
</I>&gt;&gt;<i> That approach has its problems (because it currently does not require
</I>&gt;&gt;<i> the host application to be threads-aware), but it works reasonably well
</I>&gt;&gt;<i> for many use cases.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cheers,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Alex.
</I>
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009311.html">[squid-dev] Perl script help needed
</A></li>
	<LI>Next message: <A HREF="009337.html">[squid-dev] Squid 3.5 with nonblocking ecap adapter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9312">[ date ]</a>
              <a href="thread.html#9312">[ thread ]</a>
              <a href="subject.html#9312">[ subject ]</a>
              <a href="author.html#9312">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
