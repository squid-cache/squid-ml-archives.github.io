<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Squid 3.5 with nonblocking ecap adapter
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%203.5%20with%20nonblocking%20ecap%20adapter&In-Reply-To=%3C80552023-59cd-978f-509b-15fe37d5e0ef%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009312.html">
   <LINK REL="Next"  HREF="009313.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Squid 3.5 with nonblocking ecap adapter</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%203.5%20with%20nonblocking%20ecap%20adapter&In-Reply-To=%3C80552023-59cd-978f-509b-15fe37d5e0ef%40measurement-factory.com%3E"
       TITLE="[squid-dev] Squid 3.5 with nonblocking ecap adapter">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Nov 30 17:54:47 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="009312.html">[squid-dev] Squid 3.5 with nonblocking ecap adapter
</A></li>
        <LI>Next message: <A HREF="009313.html">[squid-dev] How does Squid blocks HTTP request
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9337">[ date ]</a>
              <a href="thread.html#9337">[ thread ]</a>
              <a href="subject.html#9337">[ subject ]</a>
              <a href="author.html#9337">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/30/2017 09:39 AM, Christof Gerber wrote:

&gt;<i> First tests with my eCAP adapter in asynchronous mode which performs
</I>&gt;<i> lookups to non-blocking unix sockets seem promising.  I use std::queue
</I>&gt;<i> to implement a FIFO queue in the adapter which tracks pointers to the
</I>&gt;<i> file-descriptor (non-blocking unix socket) of pending lookups as well
</I>&gt;<i> as a link (shared pointer) to the corresponding Xaction. Similiar as
</I>&gt;<i> it is solved in ClamAV adapter.
</I>
Glad you are making progress!


&gt;<i> The difference though is that I do not use any threads for the actual
</I>&gt;<i> asynchronous action. This of course is only possible for applications
</I>&gt;<i> in which a second process on the other side of the socket is doing
</I>&gt;<i> the work (processing the lookup) for which to finish one can poll
</I>&gt;<i> within resume().
</I>
Correct. In the ClamAV adapter case, the primary ClamAV library call is
blocking so we used threads to make that asynchronous.


&gt;<i> One thing I noticed which I am concerned about:
</I>&gt;<i> 
</I>&gt;<i> Squid with one async ecap adapter attached decreases the content
</I>&gt;<i> sending speed (squid -&gt; ecap only) significantly (from ~64kB before to
</I>&gt;<i> ~16kB per vbContent cycle). I wonder if this is due to the additional
</I>&gt;<i> polling of (resume() and suspend()) that happens also every time
</I>&gt;<i> before noteVbContentAvailable()? 
</I>
I think it might be, provided your adapter forces Squid to use a shorter
polling timeout:

* In (simplified) theory, polling should stop as soon as the first data
packet arrives, and so Squid should receive the same amount of data
regardless of the polling timeout.

* In practice, I would not be surprised if less frequent (higher
timeout) polling may result in larger data chunks accumulated by the TCP
stack. The theoretical &quot;as soon as&quot; principles are trumped by interrupt
granularity and kernel implementation assumptions/simplifications. In
other words, if we let the kernel poll longer, the kernel might poll
longer, even if there is some data available already. Since Squid reads
after polling, the longer we poll, the more data may arrive by the time
Squid reads.


&gt;<i> Is Squid reducing the file chunk size
</I>&gt;<i> from 64kB to 16kB to meet the polling timeout time (polling interval)?
</I>
I do not think so. Squid should be using the same network buffer size
regardless of the polling timeout (unless there is some
hidden/unintended dependency that I do not know about). The amount of
data in that Squid buffer depends on network traffic, polling frequency,
and other external factors.


&gt;<i> As speed is only slow in the squid-&gt;ecap virgin body transaction and
</I>&gt;<i> it stays the same as in non-async mode for the adapted body
</I>&gt;<i> transaction (ecap -&gt; squid), I wonder why Squid behaves like that and
</I>&gt;<i> how I can change or influence that?
</I>
I would start by validating the working theory that the polling timeout
affects available virgin data sizes. Do larger adapter-set resume()
timeouts increase available virgin data sizes?

Alex.


&gt;<i> On 2 November 2017 at 16:47, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 11/02/2017 03:49 AM, Christof Gerber wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> One thing I still don't fully understand is if the asynchronous way to
</I>&gt;&gt;&gt;<i> program and operate Squid with an eCAP adapter necessarily relies on
</I>&gt;&gt;&gt;<i> threads?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No, threads are just one popular way to achieve asynchrony. One may also
</I>&gt;&gt;<i> use multiple processes or (for some definition of asynchrony) event loops.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are A) and B) alternatives or the only options?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you replace B's &quot;threads&quot; with &quot;threads or other asynchrony
</I>&gt;&gt;<i> mechanisms&quot;, then yes, IMO. Threads are probably the most popular way to
</I>&gt;&gt;<i> achieve asynchrony in new code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I've seen that both the
</I>&gt;&gt;&gt;<i> ClamAV and sample async adapter use pthreads. In my use case I need to
</I>&gt;&gt;&gt;<i> do a simple hash lookup to a file socket somewhen during the eCAP
</I>&gt;&gt;&gt;<i> interaction. As it will take some milliseconds until the response will
</I>&gt;&gt;&gt;<i> be available on the socket I don't want to block Squid during this
</I>&gt;&gt;&gt;<i> time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, this is a common problem.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But the eCAP adapter won't need to process/compute anything else
</I>&gt;&gt;&gt;<i> during this time. So why would I bother to use threads?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ... because without threads (or processes or event loops) your adapter
</I>&gt;&gt;<i> lookup will block the whole Squid worker while waiting for socket I/O.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you do not want to use threads or processes in your adapter, then you
</I>&gt;&gt;<i> can try to use an event loop model. That is what Squid uses internally
</I>&gt;&gt;<i> (each Squid worker does not have threads to process thousands of
</I>&gt;&gt;<i> transactions &quot;concurrently&quot;).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To use an event loop model, your adapter will need to use non-blocking
</I>&gt;&gt;<i> socket I/O and schedule _one_ I/O loop iteration every ~X milliseconds,
</I>&gt;&gt;<i> when Squid calls your Service::resume(). Try googling &quot;I/O loop&quot; or
</I>&gt;&gt;<i> &quot;select loop&quot; for starting points if you are not familiar with that
</I>&gt;&gt;<i> design pattern. The overall host-adapter interaction would be very
</I>&gt;&gt;<i> similar to what you find in the sample and ClamAV adapters.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Disclaimer: I have not seen anybody using event loops with eCAP. I think
</I>&gt;&gt;<i> it is possible to implement that model, but there may be important
</I>&gt;&gt;<i> caveats that I am not aware of.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> HTH,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Alex.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On 1 November 2017 at 16:23, Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> On 11/01/2017 03:20 AM, Christof Gerber wrote:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> [Will Squid] be blocked until the eCAP API call returns?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> To answer the exact question above: Yes, the Squid worker making an eCAP
</I>&gt;&gt;&gt;&gt;<i> API call will block until that call returns. The same is true for all
</I>&gt;&gt;&gt;&gt;<i> other API calls, all system calls, and all internal calls. This is how
</I>&gt;&gt;&gt;&gt;<i> C/C++ works. I am stating the obvious for the record, in case somebody
</I>&gt;&gt;&gt;&gt;<i> with a different (or insufficient) programming languages background
</I>&gt;&gt;&gt;&gt;<i> stumbles upon this thread.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> What you are really asking, I suspect, is whether Squid or the eCAP
</I>&gt;&gt;&gt;&gt;<i> library uses threads to automatically make eCAP adapter operations
</I>&gt;&gt;&gt;&gt;<i> asynchronous to the primary Squid operations. The answer to that
</I>&gt;&gt;&gt;&gt;<i> question is &quot;no&quot;: The relevant Squid code does not use threads, and
</I>&gt;&gt;&gt;&gt;<i> there are no threads in the eCAP library code.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Also, there is no magical layer between Squid and 99% of eCAP calls --
</I>&gt;&gt;&gt;&gt;<i> Squid calls go directly to your eCAP adapter code and vice versa. IIRC,
</I>&gt;&gt;&gt;&gt;<i> the only (unimportant) exception to that &quot;direct calls&quot; observation is
</I>&gt;&gt;&gt;&gt;<i> the eCAP service registry API, where there is a thin eCAP layer
</I>&gt;&gt;&gt;&gt;<i> insulating the adapter from the host application. That layer is also
</I>&gt;&gt;&gt;&gt;<i> synchronous though.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Is there a way other than
</I>&gt;&gt;&gt;&gt;&gt;<i> programming the eCAP adapter in asynchronous mode?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I do not think there is a better alternative. AFAICT, you only have two
</I>&gt;&gt;&gt;&gt;<i> options:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>   A) Change Squid to move eCAP calls to thread(s).
</I>&gt;&gt;&gt;&gt;<i>   B) Use threads inside the adapter to make its operations asynchronous.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> As you know, the sample async adapter and the ClamAV adapter use (B).
</I>&gt;&gt;&gt;&gt;<i> That approach has its problems (because it currently does not require
</I>&gt;&gt;&gt;&gt;<i> the host application to be threads-aware), but it works reasonably well
</I>&gt;&gt;&gt;&gt;<i> for many use cases.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Cheers,
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Alex.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009312.html">[squid-dev] Squid 3.5 with nonblocking ecap adapter
</A></li>
	<LI>Next message: <A HREF="009313.html">[squid-dev] How does Squid blocks HTTP request
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9337">[ date ]</a>
              <a href="thread.html#9337">[ thread ]</a>
              <a href="subject.html#9337">[ subject ]</a>
              <a href="author.html#9337">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
