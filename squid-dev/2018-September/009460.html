<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] 206 Partial Content Caching
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20206%20Partial%20Content%20Caching&In-Reply-To=%3C9783a0de-f754-09b4-ae8b-58e6a06a7fec%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009459.html">
   <LINK REL="Next"  HREF="009461.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] 206 Partial Content Caching</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20206%20Partial%20Content%20Caching&In-Reply-To=%3C9783a0de-f754-09b4-ae8b-58e6a06a7fec%40measurement-factory.com%3E"
       TITLE="[squid-dev] 206 Partial Content Caching">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Sep 13 16:14:58 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="009459.html">[squid-dev] 206 Partial Content Caching
</A></li>
        <LI>Next message: <A HREF="009461.html">[squid-dev] 206 Partial Content Caching
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9460">[ date ]</a>
              <a href="thread.html#9460">[ thread ]</a>
              <a href="subject.html#9460">[ subject ]</a>
              <a href="author.html#9460">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/13/2018 05:23 AM, Benson Kwok wrote:

&gt;<i> I have successfully implemented caching of 206 Partial Content as a
</I>&gt;<i> project at my job and want to know if you guys are interested in pulling
</I>&gt;<i> it into main branch.
</I>
Yes, of course! If you are willing to make the changes necessary for the
official inclusion, please submit an official pull request:
<A HREF="https://wiki.squid-cache.org/MergeProcedure">https://wiki.squid-cache.org/MergeProcedure</A>

I did not review your changes, but here are a few high-level problems
that jumped at me:

1. The changes add support for single-range caching without merging, not
general 206 caching. The added feature alone _is_ useful, but its
scope/limits need to be clearly specified in the PR description.

2. The changes add new data fields to the StoreEntry class. If possible,
those fields should be moved to MemObject. The former class exists for
all UFS-cached entries (and more). There can be billions of them! The
latter class is primarily for the entries currently in use. We should
not waste memory on the former if we can use the memory of the latter.

3a. With the proposed range-in-key approach, cached range objects cannot
be removed when such removal is required by URL-based HTTP rules (e.g.,
an HTTP DELETE request). Squid will simply not know what ranges to use
to find the objects for a given URL. IIRC, Squid has a similar problem
for request methods, but there Squid can enumerate all currently
cachable methods because that list is hard-coded (GET and HEAD).

3b. The proposed range-in-key approach probably clashes with the
ultimate goal of supporting caching (and merging/fetching) of arbitrary
range sets.

3c. With the proposed range-in-key approach, ten requests fetching ten
different ranges will create ten cache objects. IIRC, it is common for
applications such as PDF readers to request several ranges for a single
document. The current approach could result in lots of objects being
cached instead of one. Is that a good idea, especially as the default
behavior?


Looking at items 3x combined, we need to discuss whether that
range-in-key design is the right approach. Right now, I do not think it
is. It certainly makes things simpler short-term, but it immediately
leads to  dangerous HTTP violations and probably contradicts long-term
goals. This discussion should probably happen here on the mailing list.


Thanks a lot,

Alex.



&gt;<i> - adding range_offset and range_length to StoreEntry
</I>&gt;<i> - caching single ranged requests by adding the range offset and length
</I>&gt;<i> to store key hash function so they can be lookup by another request with
</I>&gt;<i> the same range offset and length
</I>&gt;<i> - offset and length are also added to StoreMeta so after a restart, the
</I>&gt;<i> offset and range can be restored
</I>&gt;<i> - enhancing HTCP so the range header from a peer is parsed and the
</I>&gt;<i> offset and length are used during HIT/MISS lookup
</I>&gt;<i> - skip ICP for range request since ICP cannot include range header
</I>&gt;<i> - adjust store_client.cc copyInfo.offset by range_offset
</I>&gt;<i> - adjust store_swapout.cc mem-&gt;swapout.queue_offset by range_offset
</I>&gt;<i> - adjust trimSwappable() new_mem_lo by range_offset
</I>
&gt;<i> <A HREF="https://github.com/squid-cache/squid/compare/master...bkwzwz:206_partial_content_caching">https://github.com/squid-cache/squid/compare/master...bkwzwz:206_partial_content_caching</A>
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009459.html">[squid-dev] 206 Partial Content Caching
</A></li>
	<LI>Next message: <A HREF="009461.html">[squid-dev] 206 Partial Content Caching
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9460">[ date ]</a>
              <a href="thread.html#9460">[ thread ]</a>
              <a href="subject.html#9460">[ subject ]</a>
              <a href="author.html#9460">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
