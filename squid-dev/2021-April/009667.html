<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Strategy about build farm nodes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Strategy%20about%20build%20farm%20nodes&In-Reply-To=%3C4ad7be77-2903-61b5-f9da-1e35528f48eb%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009666.html">
   <LINK REL="Next"  HREF="009668.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Strategy about build farm nodes</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Strategy%20about%20build%20farm%20nodes&In-Reply-To=%3C4ad7be77-2903-61b5-f9da-1e35528f48eb%40measurement-factory.com%3E"
       TITLE="[squid-dev] Strategy about build farm nodes">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Apr 28 15:47:41 UTC 2021</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="009666.html">[squid-dev] Strategy about build farm nodes
</A></li>
        <LI>Next message (by thread): <A HREF="009668.html">[squid-dev] Strategy about build farm nodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9667">[ date ]</a>
              <a href="thread.html#9667">[ thread ]</a>
              <a href="subject.html#9667">[ subject ]</a>
              <a href="author.html#9667">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 4/28/21 1:45 AM, Francesco Chemolli wrote:

&gt;<i>   I'm moving here the discussion from PR #806 about what strategy to
</I>&gt;<i> have for CI tests, looking for an agreement.
</I>
&gt;<i> We have 3 classes of tests ni our CI farm
</I>&gt;<i> (<A HREF="https://build.squid-cache.org/">https://build.squid-cache.org/</A>)
</I>
&gt;<i> - PR staging tests, triggered by commit hooks on GitHub (possibly with
</I>&gt;<i> human approval)
</I>
&gt;<i>    the job is 5-pr-auto (misnamed, it tests trunk with the PR applied).
</I>
FYI: The &quot;auto&quot; branch is &quot;master branch + PR&quot;. When PR is merged,
master becomes identical to the auto branch. The name &quot;auto&quot; is fairly
common in CI AFAICT. In Anubis (and relatively widespread/common)
terminology[1], the words &quot;staged&quot; and &quot;staging&quot; mean what you describe
as &quot;trunk with the PR applied&quot; below.

[1]
<A HREF="https://github.com/measurement-factory/anubis/blob/master/README.md#pull-request-merging-algorithm">https://github.com/measurement-factory/anubis/blob/master/README.md#pull-request-merging-algorithm</A>

AFAICT, this class should _follow_ the 5-pr-test class (described below)
because a PR is not staged until it is approved and passes 5-pr-test checks.


&gt;<i>    To be successful, it needs to successfully compile and unit-test all
</I>&gt;<i> combinations of clang and gcc on the latest stable version of the most
</I>&gt;<i> popular linux distros, at this time centos-8, debian-testing,
</I>&gt;<i> fedora-33, opensuse-leap, ubuntu-focal
</I>

&gt;<i> - PR build tests run , after a PR is approved, also triggered by GitHub
</I>&gt;<i>   the job is 5-pr-test
</I>
AFAICT, this job tests the &quot;GitHub-generated merge commit for the PR
branch&quot;. That commit may become stale if master advances while there
were no PR branch commits. Unlike the GitHub-generated merge commit, the
&quot;auto&quot; branch (mentioned above) is kept in sync with master by Anubis.

We do not merge the GitHub-generated merge commit into master.

If 5-pr-test requires a PR approval, then something probably went wrong
somewhere. Testing PR branch or the GitHub-generated merge commit should
not require a PR approval. Perhaps you meant the &quot;OK to test&quot; _testing_
approval. That testing approval is indeed required and expected for
testing GitHub-generated merge commits on vulnerable Jenkins.


&gt;<i>   To be successful, it needs to compile and unit-test all combinations
</I>&gt;<i> of clang and gcc on LTS and most recent versions of most popular linux
</I>&gt;<i> distros, at this time: centos-7,
</I>&gt;<i> debian-stable, debian-unstable, fedora-32, fedora-34, ubuntu-bionic, ubuntu-hirsute
</I>
&gt;<i> - full-scale build tests (jobs: trunk-matrix, trunk-arm32-matrix,
</I>&gt;<i> trunk-arm64-matrix, trunk-freebsd13-clang-matrix, trunk-openbsd-matrix)
</I>&gt;<i>   these test everything we can test, including bleeding edge distros
</I>&gt;<i> such as getntoo, rawhide, tumbleweed, and the latest compilers. 
</I>
Please clarify what branches/commits these &quot;full-scale build tests&quot; test.

Ideally, all this should be documented somewhere on Squid wiki!


&gt;<i> Failing
</I>&gt;<i> these will not block a PR from mergeing, but there is an expectation
</I>&gt;<i> that build regressions will be fixed
</I>
If we expect a fix, then the failure has to block something important,
like the responsible PR (ideally), the next numbered release, or all
PRs. What does this failure block today, if anything?


&gt;<i> The change in policy since last week
</I>
There was no change in any Project policies AFAIK. You have changed
Jenkins setup, but that is not a change in policy. It is likely that
there is no policy at all right now -- just ad hoc decisions by
sysadmins. It would be a stretch to call that current approach a
&quot;policy&quot;, but even if we do call it that, then that &quot;policy&quot; has not
&quot;changed&quot; :-).

Alternatively, Jenkins configuration changes have violated a Project
policy (one cannot _change_ a Project policy unilaterally; one can only
violate it). I prefer the &quot;no policy&quot; version above though :-).


&gt;<i> is that the PR-blocking builds used
</I>&gt;<i> to depend on unstabledistros (fedora-rawhide and opensuse-tumbleweed),
</I>&gt;<i> I've removed that today as part of the discussion on PR #806
</I>&gt;<i> This policy would allow keeping stable distros uptodate and matching
</I>&gt;<i> expected user experience, while not introducing instability that would
</I>&gt;<i> come in from the unstable distros
</I>&gt;<i> One distro that's notably missing is centos-stream, this is due to
</I>&gt;<i> technical issues with getting a good docker image for it, when available
</I>&gt;<i> I'll add it
</I>
&gt;<i> Would this work as a general policy?
</I>
I am not sure what exact general policy you are proposing -- please
extract it from the lengthy prose above (removing the ever-changing
low-level specifics to the extent possible, to arrive at something truly
&quot;general&quot;). FWIW, if the fleshed out proposal violates the existing &quot;do
not break master&quot; principle below, then I do not think it will work
well. I suspect that a focus on vague optimization targets like
&quot;expected user experience&quot; will not allow us to formulate a usable
policy we can all agree on, but I would be happy to be proven wrong.


I can propose the following. Perhaps knowing my state of mind will help
you finalize your proposal.

We already have a &quot;do not break master&quot; principle:

* Master always passes all current development-related tests.


I propose to add the following principle:

* A test failure blocks the change responsible for that failure.


Direct consequences of that principle are:

* If the breaking change is a CI change (e.g., an OS upgrade on a
Jenkins test node), then the change must be reverted (until it becomes
non-blocking).

* If the breaking change is a code change, then the corresponding pull
request must be fixed before it is merged. We already apply this
principle (or are very close to faithfully applying it).


The above applies to what I called, for the lack of a better term,
&quot;development-related&quot; tests. These are the tests applied to staged
commits[1] today. Until Squid releases are automated and &quot;always ready&quot;,
we should have &quot;release-related&quot; tests as well. It is not clear to me
whether such automated release-related tests exist today in our CI, but,
if they do exist, then the same principles can be applied to releases:

* A new release passes all contemporary release-related tests.
* A test failure blocks the change responsible for that failure.

Just like for development-related tests, a release-related test failure
would imply that either the tests have to be fixed or the release
candidate has to be rejected.

N.B. I am talking about releases separately from PRs primarily because I
suspect that some of the Jenkins tests may not be applicable to PRs but
are currently considered applicable to releases. For example, we are OK
with master build failures on OS Foo, but we still want all official
releases to build on that OS. If that is not the case today, then we do
not have to complicate things by separating development concerns from
release concerns!


HTH,

Alex.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="009666.html">[squid-dev] Strategy about build farm nodes
</A></li>
	<LI>Next message (by thread): <A HREF="009668.html">[squid-dev] Strategy about build farm nodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9667">[ date ]</a>
              <a href="thread.html#9667">[ thread ]</a>
              <a href="subject.html#9667">[ subject ]</a>
              <a href="author.html#9667">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
