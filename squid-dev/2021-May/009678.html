<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Strategy about build farm nodes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Strategy%20about%20build%20farm%20nodes&In-Reply-To=%3Cd0f53cf9-4a4d-4543-ee7d-2cf15270dd95%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="009676.html">
   <LINK REL="Next"  HREF="009677.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Strategy about build farm nodes</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Strategy%20about%20build%20farm%20nodes&In-Reply-To=%3Cd0f53cf9-4a4d-4543-ee7d-2cf15270dd95%40measurement-factory.com%3E"
       TITLE="[squid-dev] Strategy about build farm nodes">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon May 17 15:03:23 UTC 2021</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="009676.html">[squid-dev] Strategy about build farm nodes
</A></li>
        <LI>Next message (by thread): <A HREF="009677.html">[squid-dev] Strategy about build farm nodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9678">[ date ]</a>
              <a href="thread.html#9678">[ thread ]</a>
              <a href="subject.html#9678">[ subject ]</a>
              <a href="author.html#9678">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 5/16/21 10:19 PM, <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid3 at treenet.co.nz</A> wrote:
&gt;<i> On 2021-05-17 11:56, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 5/16/21 3:31 AM, Amos Jeffries wrote:
</I>&gt;&gt;&gt;<i> On 4/05/21 2:29 am, Alex Rousskov wrote:
</I>&gt;&gt;&gt;&gt;<i> The principles I have proposed allow upgrades that do not violate key
</I>&gt;&gt;&gt;&gt;<i> invariants. For example, if a proposed upgrade would break master, then
</I>&gt;&gt;&gt;&gt;<i> master has to be changed _before_ that upgrade actually happens, not
</I>&gt;&gt;&gt;&gt;<i> after. Upgrades must not break master.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So ... a node is added/upgraded. It runs and builds master fine. Then
</I>&gt;&gt;&gt;<i> added to the matrices some of the PRs start failing.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is easy to misunderstand what is going on because there is no good
</I>&gt;&gt;<i> visualization of complex PR-master-Jenkins_nodes-Jenkins_failures
</I>&gt;&gt;<i> relationships. Several kinds of PR test failures are possible. I will
</I>&gt;&gt;<i> describe the two most relevant to your email:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * PR test failures due to problems introduced by PRs should be welcomed
</I>&gt;&gt;<i> at any time.
</I>&gt;<i> 
</I>&gt;<i> Strawman here. This is both general statement and not relevant to CI
</I>&gt;<i> changes or design(s) we are discussing.
</I>
The first bullet (out of the two bullets that are meant to be
interpreted together, in their context) is not even close to being a
strawman argument by any definition I can find. Neither is the
combination of those two bullets.


&gt;&gt;<i> CI improvements are allowed to find new bugs in open PRs.
</I>
&gt;<i> IMO the crux is that word &quot;new&quot;. CI improvements very rarely find new
</I>&gt;<i> bugs. What it actually finds and intentionally so is *existing bugs* the
</I>&gt;<i> old CI config wrongly ignored.
</I>
Here, I used &quot;new&quot; to mean bugs that had not been found by the previous
CI version (i.e. &quot;newly discovered&quot; or &quot;new to us&quot;). These bugs existed
before and after CI improvements, of course -- neither master nor the PR
has changed -- but we did not know about them.


&gt;&gt;<i> * PR test failures due to the existing master code are not welcomed.
</I>
&gt;<i> That is not as black/white as the statement above implies. There are
</I>&gt;<i> some master branch bugs we don't want to block PRs merging, and there
</I>&gt;<i> are some (rarely) we absolutely do not want any PRs to change master
</I>&gt;<i> until fixed.
</I>
Yes, master bugs should not affect PR merging in the vast majority of
cases, but that is not what this bullet is about at all!

This bullet is about (a certain kind of) PR test failures. Hopefully, we
do not need to revisit the debate whether PRs with failed tests should
be merged. They should not be merged, which is exactly why PR test
failures caused by the combination of CI changes and the existing master
code are not welcomed -- they block progress of an innocent PR.


&gt;&gt;<i> They represent a CI failure.
</I>&gt;<i> 
</I>&gt;<i> IMO this is absolutely false. The whole point of improving CI is to find
</I>&gt;<i> those &quot;existing&quot; bugs which the previous CI config wrong missed.
</I>
Your second sentence is correct, but it does not make my statement
false. CI should achieve several goals. Finding bugs (i.e. blocking
buggy PRs) is one of them. Merging (i.e. not blocking) PRs that should
be merged is another. And there are a few more goals, of course. The
problem described in my second bullet represents a CI failure to reach
one of the key CI goals or a failure to maintain a critical CI
invariant. It is a CI failure rather than a PR failure (the latter is
covered by the first bullet).


&gt;<i> e.g. v4+ currently do not build on Windows. We know this, but the
</I>&gt;<i> current CI testing does not show it. Upgrading the CI to include a test
</I>&gt;<i> for Windows is not a &quot;CI failure&quot;.
</I>
If such an upgrade would result in blocking PRs that do not touch
Windows code, then that upgrade would be a CI failure. Or a failure to
properly upgrade CI.


&gt;&gt;<i> In these cases, if the latest master code
</I>&gt;&gt;<i> is tested with the same test after the problematic CI change, then that
</I>&gt;&gt;<i> master test will fail. Nothing a PR can do in this situation can fix
</I>&gt;&gt;<i> this kind of failure because it is not PR changes that are causing the
</I>&gt;&gt;<i> failure -- CI changes broke the master branch,
</I>&gt;<i> 
</I>&gt;<i> Ah. &quot;broke the master branch&quot; is a bit excessive. master is not broken
</I>&gt;<i> any more or less than it already was.
</I>
If you can suggest a better short phrase to describe the problem, please
do so! Until then, I will have to continue to use &quot;breaking master&quot; (in
this context) simply for the lack of a better phrase. I tried to explain
what that phrase means to avoid misunderstanding. I cannot find a better
way to compress that explanation into a single phrase.


&gt;<i> What is *actually* broken is the CI test results.
</I>
One can easily argue that CI test results are actually &quot;correct&quot; in this
case -- they correctly discover a bug in the code that wants to become
the next master. The problem is in the assignment of responsibility: The
PR did not introduce that bug, so the PR should not be punished for that
bug. The only way to avoid such punishment (given the natural automated
CI limitations) is to avoid breaking master tests, as previously defined.


&gt;<i> Otherwise, short periods between sysadmin thinking it was a safe change
</I>&gt;<i> and reverting as breakage appeared is to be expected.
</I>
Well, it is debatable whether frequent breakages should be _expected_ --
there are certainly ways to avoid the vast majority of them, but I have
already agreed that we can survive breaking upgrade attempts, even
relatively frequent ones, provided the admin doing the upgrade monitors
CI and can quickly undo the attempts that break master, as previously
defined.


&gt;<i> I see here two distros which have &quot;rolling release&quot; being updated by
</I>&gt;<i> sysadmin from producing outdated and wrong test results, to producing
</I>&gt;<i> correct test results. This is a correct change in line with the goal of
</I>&gt;<i> our nodes representing what a user running that OS would see building
</I>&gt;<i> Squid master or PRs.
</I>
In general, the CI change is incorrect if it results in breaking master,
as previously defined. This particular correctness aspect does not
depend on what tests the CI change was meant to fix.


&gt;<i> IMO we can expect to occur on a regular basis
</I>
I hope that Francesco will find a way to avoid creating this persistent
expectation of these CI-caused problems!


&gt;<i> We can resolve it by having those OS only
</I>&gt;<i> build in the N-matrix applied before releases, instead of the matrix
</I>&gt;<i> blocking PR tests or merging.
</I>
AFAICT, that would not really _resolve_ the problem, only delay its
manifestation until release time (when the stress related to fixing it
will be extreme, and the maintainer will be tempted to abuse the
pressure to release to push low-quality changes through the review process).


&gt;<i> If we are all agreed, kinkie or I can implement ASAP.
</I>
I would not strongly object to delaying N-matrix tests (whatever they
will be) until release time, but delaying the pain until the release
time sounds like a poor solution to me.

I think the best solution here would heavily depend on who is
responsible for adjusting the official code (to allow the anticipated CI
upgrade). Their resources/preferences/capabilities/etc. may determine
the best solution, the set of the required tests, and the corresponding
rules. Today, nobody specific is responsible and many volunteer
developers are often unaware of the failures or cannot quickly address
them. With some luck, the changes that Francesco has started to propose
will improve this situation.

One solution that would be better, IMO, than delaying N-matrix tests
would be to make tests on &quot;rolling&quot; OSes optional instead of required
(but still test all PRs). Splitting merge tests into optional and
required would attract developer attention without blocking innocent PRs.


&gt;&gt;&gt;<i> B. PR submission testing
</I>&gt;&gt;&gt;<i>    - which OS for master (5-pr-test) ?
</I>&gt;&gt;&gt;<i>    - which OS for beta (5-pr-test) ?
</I>&gt;&gt;&gt;<i>    - which OS for stable (5-pr-test) ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are all of those sets the same identical OS+compilers? no.
</I>&gt;&gt;&gt;<i> Why are they forced to be the same matrix test?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I do not understand the question. Are you asking why Jenkins uses the
</I>&gt;&gt;<i> same 5-pr-test configuration for all three branches (master, beta, _and_
</I>&gt;&gt;<i> stable)? I do not know the answer.
</I>
&gt;<i> So can we agree that they should be different tests?
</I>
I, personally, cannot answer that specific question in a meaningful way,
but I doubt I would strongly object to virtually any Jenkins changes
related to stable and beta test sets. I continue to view those branches
(but not their branching points!) as primarily maintainer's
responsibility. If others do not object, you should feel free to make
them different IMO. Just keep GitHub/Jenkins/Anubis integration in mind
when you do so (e.g., by keeping the _number_ of GitHub-visible tests or
&quot;status checks&quot; the same across all branches).


&gt;&gt;&gt;<i> C. merge testing
</I>&gt;&gt;&gt;<i>    - which OS for master (5-pr-auto) ?
</I>&gt;&gt;&gt;<i>    - which OS for beta (5-pr-auto) ?
</I>&gt;&gt;&gt;<i>    - which OS for stable (5-pr-auto) ?
</I>&gt;&gt;&gt;<i>      NP: maintainer does manual override on beta/stable merges.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are all of those sets the same identical OS+compilers? no.
</I>&gt;&gt;&gt;<i>   Why are they forced to be the same matrix test? Anubis
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is too cryptic for me to understand, but Anubis does not force any
</I>&gt;&gt;<i> tests on anybody -- it simply checks that the required tests have
</I>&gt;&gt;<i> passed. I am not aware of any Anubis bugs in this area, but please
</I>&gt;&gt;<i> correct me if I am wrong.
</I>

&gt;<i> My understanding was that Anubis only has ability to check PRs against
</I>&gt;<i> its auto branch which tracks master.
</I>
Anubis documentation[1] defines staging_branch (i.e. our &quot;auto&quot;) as a
branch for testing PR changes as if they were merged into the PR target
branch. The target branch is defined by each GitHub PR. AFAICT, Anubis
does not really have a high-level concept of a &quot;master&quot; branch. The auto
branch should contain whatever target branch the PR is using.

[1] <A HREF="https://github.com/measurement-factory/anubis/blob/master/README.md">https://github.com/measurement-factory/anubis/blob/master/README.md</A>


&gt;<i> Ability to have it track other
</I>&gt;<i> non-master branches and merge there is not available for use.
</I>
AFAICT, Anubis is tracking v4 PRs but you are ignoring it. For example,
merged PR #815 has a &quot;waiting for more votes&quot; status check added by
Anubis to the last commit (f6828ed):
<A HREF="https://github.com/squid-cache/squid/pull/815">https://github.com/squid-cache/squid/pull/815</A>

There may be some integration problems that I am not aware of, but I
think everything should work in principle. AFAICT, you are forcing
manual v4/v5 commits instead of following the procedure we use for
master, but that is your decision. Please note that I am not saying that
your decision is right or wrong, just documenting my understanding and
observations.


&gt;<i> IMO we should look into this. But it is a technical project for sysadmin
</I>&gt;<i> + Eduard to coordinate. Not a policy thing.
</I>
What tests are blocking and what are optional is a policy thing. Whether
it is OK to break master, as previously defined, is a policy thing. How
to implement those and other policies is usually a technicality indeed.


&gt;&gt;<i> AFAICT, Francesco and I are on the same page regarding not breaking
</I>&gt;&gt;<i> master anymore -- he graciously agreed to prevent such breakages in the
</I>&gt;&gt;<i> future, and I am very thankful that he did. Based on your comments
</I>&gt;&gt;<i> discussing several cases where such master breakage is, in your opinion,
</I>&gt;&gt;<i> OK, you currently disagree with that principle. I do not know why.
</I>
&gt;<i> I think we differ in our definitions of &quot;breaking master&quot;. You seem to
</I>&gt;<i> be including breakage of things in the CI system itself which I consider
</I>&gt;<i> outside of &quot;master&quot;, or expected results of normal sysadmin activity.
</I>
I hope my definition of &quot;breaking master&quot; in this CI change context is
clear by now. I still do not know why you oppose to prohibiting doing
that, under any name.


&gt;<i> I hope my response to the two use-cases you present at the top of this
</I>&gt;<i> email clarify.
</I>
Unfortunately, those attacks on my choice of words did not help me
understand why you are opposed to the principles those words describe.
You are welcome to propose better phrasing, of course, but that would
not change what actually happened and my desire to prohibit those kinds
of events in the future.

Alex.
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="009676.html">[squid-dev] Strategy about build farm nodes
</A></li>
	<LI>Next message (by thread): <A HREF="009677.html">[squid-dev] Strategy about build farm nodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9678">[ date ]</a>
              <a href="thread.html#9678">[ thread ]</a>
              <a href="subject.html#9678">[ subject ]</a>
              <a href="author.html#9678">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
