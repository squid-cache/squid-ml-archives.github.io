<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] RFC: Adding a new line to a regex
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20RFC%3A%20Adding%20a%20new%20line%20to%20a%20regex&In-Reply-To=%3C84eb237e-2b30-dd62-0b52-d931feb3d24c%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009758.html">
   <LINK REL="Next"  HREF="009760.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] RFC: Adding a new line to a regex</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20RFC%3A%20Adding%20a%20new%20line%20to%20a%20regex&In-Reply-To=%3C84eb237e-2b30-dd62-0b52-d931feb3d24c%40treenet.co.nz%3E"
       TITLE="[squid-dev] RFC: Adding a new line to a regex">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Jan 22 01:59:34 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="009758.html">[squid-dev] RFC: Adding a new line to a regex
</A></li>
        <LI>Next message (by thread): <A HREF="009760.html">[squid-dev] RFC: Adding a new line to a regex
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9759">[ date ]</a>
              <a href="thread.html#9759">[ thread ]</a>
              <a href="subject.html#9759">[ subject ]</a>
              <a href="author.html#9759">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 22/01/22 08:36, Alex Rousskov wrote:
&gt;<i> TLDR: I am adding solution #6 into the mix based on Amos email (#5 was
</I>&gt;<i> taken by Eduard). Amos needs to clarify why he thinks that Squid master
</I>&gt;<i> branch cannot accept STL-based regexes &quot;now&quot;. After that, we can decide
</I>&gt;<i> whether #6 remains a viable candidate. Details below.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 1/21/22 12:42 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 20/01/22 10:32, Alex Rousskov wrote:
</I>&gt;&gt;&gt;<i> We have a use case where a regex in squid.conf should contain/match
</I>&gt;&gt;&gt;<i> a new line [...] This email discusses the problem and proposes how
</I>&gt;&gt;&gt;<i> to add a new line (and other special characters) to regexes found
</I>&gt;&gt;&gt;<i> in squid.conf and such.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> With the current mix of squid.conf parsers this RFC seems irrelevant to me.
</I>&gt;<i> 
</I>&gt;<i> I do not understand the relationship between &quot;the current mix of
</I>&gt;<i> squid.conf parsers&quot; and this RFC relevance. This RFC is relevant because
</I>&gt;<i> it is about a practical solution to a real problem facing real Squid admins.
</I>&gt;<i> 
</I>
Sentence #2 of the RFC explicitly states that admin needs are not 
relevant &quot;I do not know whether there are similar use
cases with the existing squid.conf regex directives&quot;

The same sentence delimits RFC scope as: &quot;adding a _new_ directive that 
will need such support.&quot;

That means the syntax defining how the regex pattern is configured does 
not yet exist. It is not necessary for the developer to design their 
_new_ UI syntax in a way that exposes admin to this problem in the first 
place. Simply design the



&gt;<i> Whether Squid has one parser or ten, good ones or bad ones, is relevant
</I>&gt;<i> to how the solution is implemented/integrated with Squid, of course, but
</I>&gt;<i> that is already a part of the analysis on this thread.
</I>&gt;<i> 
</I>
Very relevant. RFC cites &quot;squid.conf preprocessor and parameter parser 
use/strip all new lines&quot; as a problem.

I point out that this behaviour depends on *which* config parser is 
chosen to be used by the (again _new_) directive. It should be an 
implementation detail for the dev, not design consideration for this RFC.


&gt;<i> 
</I>&gt;&gt;<i> The developer designing a new directive also writes the parse_*()
</I>&gt;&gt;<i> function that processes the config file line. All they have to do is
</I>&gt;&gt;<i> avoid using the parser functions which implicitly do the problematic
</I>&gt;&gt;<i> behaviour.
</I>&gt;<i> 
</I>&gt;<i> Concerns regarding the overall quality of Squid configuration syntax and
</I>&gt;<i> upgrade paths expand the reach of this problem far beyond a single new
</I>&gt;<i> directive, but let's assume, for the sake of the argument, that all we
</I>&gt;<i> care about is a new parsing function. Now we need to decide what syntax
</I>&gt;<i> that parsing function will use. This RFC is about that decision.
</I>&gt;<i> 
</I>
Nod.

I must state that I do not see much in the say of squid.conf syntax 
discussion in the RFC text. It seems to focus a lot on syntax inside the 
regex pattern.

IMO regex is such a complicated situation that we should avoid having 
special things inside or on top of its syntax. That is a recipe for 
admin pain.


...
&gt;&gt;<i> There was a plan from 2014 (re-attempted by Christos 2016) to migrate
</I>&gt;&gt;<i> Squid from the GNURegex dependency to more flexible C++11 regex library
</I>&gt;&gt;<i> which supports many regex languages. With that plan the UI would only
</I>&gt;&gt;<i> need an option flag or pattern prefix to specify which language a
</I>&gt;&gt;<i> pattern uses.
</I>&gt;<i> 
</I>&gt;<i> I agree that one of the solutions worth considering is to use a regex
</I>&gt;<i> library that supports different regex syntax. So here is the
</I>&gt;<i> corresponding entry for solution based on C++ STL regex:
</I>&gt;<i> 
</I>&gt;<i> 6. Use STL regex features that support \n and similar escape sequences
</I>&gt;<i> Pros: Supports much more than just advanced escape sequences!
</I>&gt;<i> Pros: The new syntax is easy to document by referencing library docs.
</I>
Pro: we do not have to write any part of pattern matching ourselves. 
Simpler config parser.

Pro: we do not have to maintain custom code supporting special 
behaviours in regex pattern configuration.

Pro: we do not have to provide additional user support for non-standard 
squid.conf patterns.

Pro: we do not have to waste brain cycles designing how to integrate 
syntax into regex patterns cleanly.


&gt;<i> Cons: Requires serious changes to the internal regex support in Squid.
</I>
IIRC, the changes are not as serious as it may seem. The largest part is 
squid.conf parser alteration to accept the proposals flag/prefix and 
patterns cleanly. Beyond that is just a switch of container which is 
easy (not trivial, just easy).


&gt;<i> Cons: Miserable STL regex performance in some environments[1,2]?
</I>
IMO this is balanced by Squid existing regex being well known to have 
similar performance issues.


&gt;<i> Cons: Converting old regexes requires (complex) automation.
</I>
Disagree this is problem.

GNU regex is predecessor syntax behind all modern regex variants. We can 
retain GNUregex as the default pattern and require language flag/prefix 
for patterns needing modern features.


&gt;<i> Cons: Requires dropping GCC v4.8 support.
</I>&gt;<i> Cons: Amos thinks Squid cannot support STL regex until 2024.
</I>
I am honoured that you consider my opinion to be of such importance.

But, seriously, the technical part of my earlier statement is already 
covered by the GCC 4.8 line.


&gt;<i> [2] STL does not allow us to define a custom allocator for its regexes.
</I>&gt;<i> Various STL implementations have various hidden workarounds, but we will
</I>&gt;<i> be at their (varying) mercy.
</I>&gt;<i> 
</I>
That is an interesting point. And probably should be a Con in its own right.


&gt;<i> 
</I>&gt;&gt;<i> That plan was put on hold due to feature-incomplete GCC 4.8 versions
</I>&gt;&gt;<i> being distributed by CentOS 7 and RHEL needing to build Squid.
</I>&gt;<i> 
</I>&gt;<i> ... and serious/substantiated performance concerns[1]. They may have
</I>&gt;<i> been addressed by STL implementations since then, but my quick check and
</I>&gt;<i> the impossibility of solving [2] without breaking ABI suggest that at
</I>&gt;<i> least some of these issues still remain.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> One Core Developer (you Alex) has repeatedly expressed a strong opinion
</I>&gt;&gt;<i> veto'ing the addition/removal of features to Squid-6 while they are
</I>&gt;&gt;<i> still officially supported by a small set of &quot;officially supported&quot;
</I>&gt;&gt;<i> Vendors. RHEL and CentOS being in that set.
</I>&gt;<i> 
</I>&gt;<i> Sorry, I have no idea what you are talking about.
</I>&gt;<i> 
</I>
Your latest voicing of it was in 
&lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/2021-December/009743.html">http://lists.squid-cache.org/pipermail/squid-dev/2021-December/009743.html</A>&gt;

 &gt; &quot;
 &gt; Any
 &gt; known Squid regression affecting the &quot;main&quot; environment should block the
 &gt; PR introducing that regression IMO. I see no need to limit this to
 &gt; &quot;build and unit tests&quot; regressions
 &gt; &quot;

The definition of &quot;main&quot; under discussion in that thread never reached 
consensus to change away from the existing OS represented by the Jenkins 
5-pr-test nodes. So (for now) it still includes LTS versions of RHEL / 
CentOS 7 shipping the broken GCC 4.8.x std::regex.



Amos
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="009758.html">[squid-dev] RFC: Adding a new line to a regex
</A></li>
	<LI>Next message (by thread): <A HREF="009760.html">[squid-dev] RFC: Adding a new line to a regex
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9759">[ date ]</a>
              <a href="thread.html#9759">[ thread ]</a>
              <a href="subject.html#9759">[ subject ]</a>
              <a href="author.html#9759">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
