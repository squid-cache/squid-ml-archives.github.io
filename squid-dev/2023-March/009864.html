<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-dev] Squid 5.6 leaking memory when peeking for an origin with an invalid certificate
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%205.6%20leaking%20memory%20when%20peeking%20for%20an%20origin%0A%20with%20an%20invalid%20certificate&In-Reply-To=%3CCAL34ibnCwGD7ZXHQ2EitHkHQbegvsaJDQf5kzk8mNmWGTb8-UQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009862.html">
   <LINK REL="Next"  HREF="009863.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-dev] Squid 5.6 leaking memory when peeking for an origin with an invalid certificate</H1>
    <B>Hamilton Coutinho</B> 
    <A HREF="mailto:squid-dev%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-dev%5D%20Squid%205.6%20leaking%20memory%20when%20peeking%20for%20an%20origin%0A%20with%20an%20invalid%20certificate&In-Reply-To=%3CCAL34ibnCwGD7ZXHQ2EitHkHQbegvsaJDQf5kzk8mNmWGTb8-UQ%40mail.gmail.com%3E"
       TITLE="[squid-dev] Squid 5.6 leaking memory when peeking for an origin with an invalid certificate">hamilton.coutinho at gmail.com
       </A><BR>
    <I>Mon Mar 27 19:47:31 UTC 2023</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="009862.html">[squid-dev] Squid 5.6 leaking memory when peeking for an origin with an invalid certificate
</A></li>
        <LI>Next message (by thread): <A HREF="009863.html">[squid-dev] 6.0.2 release update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9864">[ date ]</a>
              <a href="thread.html#9864">[ thread ]</a>
              <a href="subject.html#9864">[ subject ]</a>
              <a href="author.html#9864">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello all,

We moved one step closer to the root cause. We bisected the code and found
out that the commit that introduced the leak is:

$ git show --stat  800967afde7921eb22a2711c5a75b5cd9c9d7178
commit 800967afde7921eb22a2711c5a75b5cd9c9d7178 (HEAD)
Author: Christos Tsantilas &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">christos at chtsanti.net</A>&gt;
Date:   Mon Feb 22 21:15:32 2021 +0000

    Handling missing issuer certificates for TLSv1.3 (#766)

    Prior to TLS v1.3 Squid could detect and fetch missing intermediate
    server certificates by parsing TLS ServerHello. TLS v1.3 encrypts the
    relevant part of the handshake, making such &quot;prefetch&quot; impossible.

    Instead of looking for certificates in TLS ServerHello, Squid now waits
    for the OpenSSL built-in certificate validation to fail with an
    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY error. Squid-supplied
    verify_callback function tells OpenSSL to ignore that error. Squid
    SSL_connect()-calling code detects that the error was ignored and, if
    possible, fetches the missing certificates and orchestrates certificate
    chain validation outside the SSL_connect() sequence. If that validation
    is successful, Squid continues with SSL_connect(). See comments inside
    Security::PeerConnector::negotiate() for low-level details.

    In some cases, OpenSSL is able to complete SSL_connect() with an ignored
    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY error. If Squid validation
    fails afterwards, the TLS connection is closed (before any payload is
    exchanged). Ideally, the negotiation with an untrusted server should not
    complete, but complexity BIO changes required to prevent such premature
    completion is probably not worth reaching that ideal, especially since
    all of this is just a workaround.

    The long-term solution is adding SSL_ERROR_WANT_RETRY_VERIFY to OpenSSL,
    giving an application a chance to download the missing certificates
    during SSL_connect() negotiations. We assist OpenSSL team with that
    change, but it will not be available at least until OpenSSL v3.0.

    This description and changes are not specific to SslBump code paths.

    This is a Measurement Factory project.

 acinclude/lib-checks.m4       |   6 ++
 compat/openssl.h              |  30 +++++++++
 src/security/Handshake.cc     |  46 --------------
 src/security/Handshake.h      |   5 +-
 src/security/Io.cc            |  27 ++++++++
 src/security/Io.h             |  14 +++-
 src/security/PeerConnector.cc | 211
++++++++++++++++++++++++++++++++++++++++++++-----------------
 src/security/PeerConnector.h  |  46 ++++++++++----
 src/security/Session.h        |   4 ++
 src/ssl/bio.cc                |   7 --
 src/ssl/bio.h                 |   8 ---
 src/ssl/gadgets.h             |   1 +
 src/ssl/support.cc            | 355
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------
 src/ssl/support.h             |  57 +++++++++++++++--
 src/tests/stub_libsecurity.cc |   4 +-
 15 files changed, 582 insertions(+), 239 deletions(-)

On Thu, Mar 23, 2023 at 4:56&#8239;PM Hamilton Coutinho &lt;
<A HREF="http://lists.squid-cache.org/listinfo/squid-dev">hamilton.coutinho at gmail.com</A>&gt; wrote:

&gt;<i> Hi all,
</I>&gt;<i>
</I>&gt;<i> We found a way to reproduce the leak: set up squid to run in intercept
</I>&gt;<i> mode + SSL description + memory pools off (to ease identifying the leak)
</I>&gt;<i> and then generate requests to sites with invalid certs (eg, CA not
</I>&gt;<i> installed), for instance: curl -k <A HREF="https://slscr.update.microsoft.com.">https://slscr.update.microsoft.com.</A>
</I>&gt;<i> squidclient mgr:mem should show ever increasing HttpRequest instances.
</I>&gt;<i>
</I>&gt;<i> As far as I can tell, the HttpRequest object created
</I>&gt;<i> in ConnStateData::buildFakeRequest() is never freed because its refcount &gt;
</I>&gt;<i> 0.
</I>&gt;<i>
</I>&gt;<i> Any ideas where an HTTPMSGUNLOCK() might be missing?
</I>&gt;<i>
</I>&gt;<i> Thanks!
</I>&gt;<i>
</I>&gt;<i> On Wed, Jan 18, 2023 at 11:28&#8239;AM Hamilton Coutinho &lt;
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">hamilton.coutinho at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Hi Alex,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks for the prompt reply! Thanks also for the clarifications.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Agreed, I just realized the requests seem to be failing
</I>&gt;&gt;<i> with Http::scServiceUnavailable, so my focus turned
</I>&gt;&gt;<i> to Security::PeerConnector::sslCrtvdHandleReply() and friends.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Best.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Wed, Jan 18, 2023 at 11:11 AM Alex Rousskov &lt;
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On 1/18/23 13:46, Hamilton Coutinho wrote:
</I>&gt;&gt;&gt;<i> &gt; Hi all,
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; We are observing what seems to be several objects leaking in the
</I>&gt;&gt;&gt;<i> output
</I>&gt;&gt;&gt;<i> &gt; mgr:mem, to the tune of 10s of 1000s
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> of HttpRequest, HttpHeaderEntry, Comm::Connection, Security::ErrorDetail, cbdata
</I>&gt;&gt;&gt;<i> PeekingPeerConnector (31), etc.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; We dumped a core and managed to find some HttpRequest objects and they
</I>&gt;&gt;&gt;<i> &gt; all seem to have failed in the same way, with an
</I>&gt;&gt;&gt;<i> ERR_SECURE_CONNECT_FAIL
</I>&gt;&gt;&gt;<i> &gt; category, for a site that has a certificate signed by a CA authority
</I>&gt;&gt;&gt;<i> not
</I>&gt;&gt;&gt;<i> &gt; available to squid.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; If I would guess, the origin of the problem might be in
</I>&gt;&gt;&gt;<i> &gt; Ssl::PeekingPeerConnector::checkForPeekAndSpliceMatched():
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;      if (finalAction == Ssl::bumpTerminate) {
</I>&gt;&gt;&gt;<i> &gt;          bail(new ErrorState(ERR_SECURE_CONNECT_FAIL,
</I>&gt;&gt;&gt;<i> Http::scForbidden,
</I>&gt;&gt;&gt;<i> &gt; request.getRaw(), al));
</I>&gt;&gt;&gt;<i> &gt;          clientConn-&gt;close();
</I>&gt;&gt;&gt;<i> &gt;          clientConn = nullptr;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Wondering if assigning null to clientConn there would be premature.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> FWIW, that connection pointer reset itself looks OK to me. ConnStateData
</I>&gt;&gt;&gt;<i> and/or others should have a connection closure handler attached to the
</I>&gt;&gt;&gt;<i> clientConn descriptor. That handler should be notified by Comm and
</I>&gt;&gt;&gt;<i> initiate cleanup of the objects responsible for client-Squid
</I>&gt;&gt;&gt;<i> communication.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The bail() call above should inform the requestor about the
</I>&gt;&gt;&gt;<i> error/termination and terminate this AsyncJob. That requestor should
</I>&gt;&gt;&gt;<i> then close the Squid-server connection and clean up associated state.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> While there may be bugs in those &quot;should...&quot; sequences, please note that
</I>&gt;&gt;&gt;<i> the pasted code is not related to handling of untrusted origin servers
</I>&gt;&gt;&gt;<i> (unless your ssl_bump rules specifically activate the terminate action
</I>&gt;&gt;&gt;<i> upon discovering such an origin server). The pasted code is reacting to
</I>&gt;&gt;&gt;<i> an &quot;ssl_bump terminate&quot; rule matching.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Cheers,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Alex.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;<i> squid-dev mailing list
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">squid-dev at lists.squid-cache.org</A>
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-dev">http://lists.squid-cache.org/listinfo/squid-dev</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i> Hamilton
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Hamilton
</I>&gt;<i>
</I>

-- 
Hamilton
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-dev/attachments/20230327/bab43fe4/attachment.htm">http://lists.squid-cache.org/pipermail/squid-dev/attachments/20230327/bab43fe4/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="009862.html">[squid-dev] Squid 5.6 leaking memory when peeking for an origin with an invalid certificate
</A></li>
	<LI>Next message (by thread): <A HREF="009863.html">[squid-dev] 6.0.2 release update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9864">[ date ]</a>
              <a href="thread.html#9864">[ thread ]</a>
              <a href="subject.html#9864">[ subject ]</a>
              <a href="author.html#9864">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.squid-cache.org/listinfo/squid-dev">More information about the squid-dev
mailing list</a><br>
</body></html>
