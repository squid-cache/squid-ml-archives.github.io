sslproxy_cert_sign_hash configuration option

Browser vendors will get rid of SSL certificates that use SHA-1 to generate
the hash that is then signed by the CA. For example, Google Chrome will start
to show an "insecure" sign for certificates that are valid after 1.1.2016 and
will generate a warning page for certificates that are valid after 1.1.2017 [1],
[2],[4]. Microsoft will block certificates with SHA-1 after 1.1.2017 [3].

This patch:
  1) Add a new configuration option to select the signing hash for
     generated certificates: sslproxy_cert_sign_hash.

  2) If sslproxy_cert_sign_hash is not set, then use the sha256 hash.

[1] https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/2-R4XziFc7A/YO0ZSrX_X4wJ
[2] https://code.google.com/p/chromium/issues/detail?id=401365
[3] http://blogs.technet.com/b/pki/archive/2013/11/12/sha1-deprecation-policy.aspx
[4] http://googleonlinesecurity.blogspot.ch/2014/09/gradually-sunsetting-sha-1.html 

This is a Measurement Factory project
=== modified file 'src/SquidConfig.h'
--- src/SquidConfig.h	2014-09-25 06:50:32 +0000
+++ src/SquidConfig.h	2014-10-01 16:27:41 +0000
@@ -459,40 +459,41 @@
     Notes notes;
     char *coredump_dir;
     char *chroot_dir;
 #if USE_CACHE_DIGESTS
 
     struct {
         int bits_per_entry;
         time_t rebuild_period;
         time_t rewrite_period;
         size_t swapout_chunk_size;
         int rebuild_chunk_percentage;
     } digest;
 #endif
 #if USE_OPENSSL
 
     struct {
         int unclean_shutdown;
         char *ssl_engine;
         int session_ttl;
         size_t sessionCacheSize;
+        char *certSignHash;
     } SSL;
 #endif
 
     wordlist *ext_methods;
 
     struct {
         int high_rptm;
         int high_pf;
         size_t high_memory;
     } warnings;
     char *store_dir_select_algorithm;
     int sleep_after_fork;   /* microseconds */
     time_t minimum_expiry_time; /* seconds */
     external_acl *externalAclHelperList;
 
 #if USE_OPENSSL
 
     struct {
         char *cert;
         char *key;

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2014-09-22 19:06:19 +0000
+++ src/cf.data.pre	2014-10-01 16:27:41 +0000
@@ -2488,40 +2488,58 @@
 DOC_END
 
 NAME: sslproxy_session_ttl
 IFDEF: USE_OPENSSL
 DEFAULT: 300
 LOC: Config.SSL.session_ttl
 TYPE: int
 DOC_START
 	Sets the timeout value for SSL sessions
 DOC_END
 
 NAME: sslproxy_session_cache_size
 IFDEF: USE_OPENSSL
 DEFAULT: 2 MB
 LOC: Config.SSL.sessionCacheSize
 TYPE: b_size_t
 DOC_START
         Sets the cache size to use for ssl session
 DOC_END
 
+NAME: sslproxy_cert_sign_hash
+IFDEF: USE_OPENSSL
+DEFAULT: none
+LOC: Config.SSL.certSignHash
+TYPE: string
+DOC_START
+	Sets the hashing algorithm to use when signing generated certificates.
+	Valid algorithm names depend on the OpenSSL library used. The following
+	names are usually available: sha1, sha256, sha512, and md5. Please see
+	your OpenSSL library manual for the available hashes. By default, Squids
+	that support this option use sha256 hashes.
+
+	Squid does not forcefully purge cached certificates that were generated
+	with an algorithm other than the currently configured one. They remain
+	in the cache, subject to the regular cache eviction policy, and become
+	useful if the algorithm changes again.
+DOC_END
+
 NAME: ssl_bump
 IFDEF: USE_OPENSSL
 TYPE: sslproxy_ssl_bump
 LOC: Config.accessList.ssl_bump
 DEFAULT_DOC: Become a TCP tunnel without decrypting proxied traffic.
 DEFAULT: none
 DOC_START
 	This option is consulted when a CONNECT request is received on
 	an http_port (or a new connection is intercepted at an
 	https_port), provided that port was configured with an ssl-bump
 	flag. The subsequent data on the connection is either treated as
 	HTTPS and decrypted OR tunneled at TCP level without decryption,
 	depending on the first matching bumping "action".
 
 	ssl_bump <action> [!]acl ...
 
 	The following bumping actions are currently supported:
 
 	    splice
 		Become a TCP tunnel without decrypting proxied traffic.

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2014-10-01 12:31:58 +0000
+++ src/client_side.cc	2014-10-01 16:27:41 +0000
@@ -4038,40 +4038,42 @@
         // or the user would have to add a security exception
         // just to see the error page. We will close the connection
         // so that the trust is not extended to non-Squid content.
         certProperties.signAlgorithm = Ssl::algSignTrusted;
     }
 
     assert(certProperties.signAlgorithm != Ssl::algSignEnd);
 
     if (certProperties.signAlgorithm == Ssl::algSignUntrusted) {
         assert(port->untrustedSigningCert.get());
         certProperties.signWithX509.resetAndLock(port->untrustedSigningCert.get());
         certProperties.signWithPkey.resetAndLock(port->untrustedSignPkey.get());
     } else {
         assert(port->signingCert.get());
         certProperties.signWithX509.resetAndLock(port->signingCert.get());
 
         if (port->signPkey.get())
             certProperties.signWithPkey.resetAndLock(port->signPkey.get());
     }
     signAlgorithm = certProperties.signAlgorithm;
+
+    certProperties.signHash = Ssl::DefaultSignHash;
 }
 
 void
 ConnStateData::getSslContextStart()
 {
     assert(areAllContextsForThisConnection());
     freeAllContexts();
     /* careful: freeAllContexts() above frees request, host, etc. */
 
     if (port->generateHostCertificates) {
         Ssl::CertificateProperties certProperties;
         buildSslCertGenerationParams(certProperties);
         sslBumpCertKey = certProperties.dbKey().c_str();
         assert(sslBumpCertKey.size() > 0 && sslBumpCertKey[0] != '\0');
 
         // Disable caching for bumpPeekAndSplice mode
         if (!(sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare))) {
             debugs(33, 5, "Finding SSL certificate for " << sslBumpCertKey << " in cache");
             Ssl::LocalContextStorage * ssl_ctx_cache = Ssl::TheGlobalContextStorage.getLocalStorage(port->s);
             SSL_CTX * dynCtx = NULL;

=== modified file 'src/ssl/crtd_message.cc'
--- src/ssl/crtd_message.cc	2014-09-13 13:59:43 +0000
+++ src/ssl/crtd_message.cc	2014-10-01 16:40:53 +0000
@@ -189,70 +189,82 @@
 
     i = map.find(Ssl::CrtdMessage::param_SetValidAfter);
     if (i != map.end() && strcasecmp(i->second.c_str(), "on") == 0)
         certProperties.setValidAfter = true;
 
     i = map.find(Ssl::CrtdMessage::param_SetValidBefore);
     if (i != map.end() && strcasecmp(i->second.c_str(), "on") == 0)
         certProperties.setValidBefore = true;
 
     i = map.find(Ssl::CrtdMessage::param_SetCommonName);
     if (i != map.end()) {
         // use this as Common Name  instead of the hostname
         // defined with host or Common Name from mimic cert
         certProperties.commonName = i->second;
         certProperties.setCommonName = true;
     }
 
     i = map.find(Ssl::CrtdMessage::param_Sign);
     if (i != map.end()) {
         if ((certProperties.signAlgorithm = Ssl::certSignAlgorithmId(i->second.c_str())) == Ssl::algSignEnd) {
-            error = "Wrong signing algoritm: " + i->second;
+            error = "Wrong signing algoritm: ";
+            error += i->second;
             return false;
         }
     } else
         certProperties.signAlgorithm = Ssl::algSignTrusted;
 
+    i = map.find(Ssl::CrtdMessage::param_SignHash);
+    const char *signHashName = i != map.end() ? i->second.c_str() : SQUID_SSL_SIGN_HASH_IF_NONE;
+    if (!(certProperties.signHash = EVP_get_digestbyname(signHashName))) {
+        error = "Wrong signing hash: ";
+        error += signHashName;
+        return false;
+    }
+
     if (!Ssl::readCertAndPrivateKeyFromMemory(certProperties.signWithX509, certProperties.signWithPkey, certs_part.c_str())) {
         error = "Broken signing certificate!";
         return false;
     }
 
     static const std::string CERT_BEGIN_STR("-----BEGIN CERTIFICATE");
     size_t pos;
     if ((pos = certs_part.find(CERT_BEGIN_STR)) != std::string::npos) {
         pos += CERT_BEGIN_STR.length();
         if ((pos= certs_part.find(CERT_BEGIN_STR, pos)) != std::string::npos)
             Ssl::readCertFromMemory(certProperties.mimicCert, certs_part.c_str() + pos);
     }
     return true;
 }
 
 void Ssl::CrtdMessage::composeRequest(Ssl::CertificateProperties const &certProperties)
 {
     body.clear();
     body = Ssl::CrtdMessage::param_host + "=" + certProperties.commonName;
     if (certProperties.setCommonName)
         body +=  "\n" + Ssl::CrtdMessage::param_SetCommonName + "=" + certProperties.commonName;
     if (certProperties.setValidAfter)
         body +=  "\n" + Ssl::CrtdMessage::param_SetValidAfter + "=on";
     if (certProperties.setValidBefore)
         body +=  "\n" + Ssl::CrtdMessage::param_SetValidBefore + "=on";
     if (certProperties.signAlgorithm != Ssl::algSignEnd)
         body +=  "\n" +  Ssl::CrtdMessage::param_Sign + "=" +  certSignAlgorithm(certProperties.signAlgorithm);
+    if (certProperties.signHash)
+        body +=  "\n" + Ssl::CrtdMessage::param_SignHash + "=" + EVP_MD_name(certProperties.signHash);
 
     std::string certsPart;
     if (!Ssl::writeCertAndPrivateKeyToMemory(certProperties.signWithX509, certProperties.signWithPkey, certsPart))
         throw std::runtime_error("Ssl::writeCertAndPrivateKeyToMemory()");
     if (certProperties.mimicCert.get()) {
         if (!Ssl::appendCertToMemory(certProperties.mimicCert, certsPart))
             throw std::runtime_error("Ssl::appendCertToMemory()");
     }
     body += "\n" + certsPart;
 }
 
 const std::string Ssl::CrtdMessage::code_new_certificate("new_certificate");
 const std::string Ssl::CrtdMessage::param_host("host");
 const std::string Ssl::CrtdMessage::param_SetValidAfter(Ssl::CertAdaptAlgorithmStr[algSetValidAfter]);
 const std::string Ssl::CrtdMessage::param_SetValidBefore(Ssl::CertAdaptAlgorithmStr[algSetValidBefore]);
 const std::string Ssl::CrtdMessage::param_SetCommonName(Ssl::CertAdaptAlgorithmStr[algSetCommonName]);
 const std::string Ssl::CrtdMessage::param_Sign("Sign");
+const std::string Ssl::CrtdMessage::param_SignHash("SignHash");

=== modified file 'src/ssl/crtd_message.h'
--- src/ssl/crtd_message.h	2014-09-13 13:59:43 +0000
+++ src/ssl/crtd_message.h	2014-10-01 16:27:41 +0000
@@ -67,40 +67,42 @@
          The other multistring part of body.  \endverbatim
     */
     void composeBody(BodyParams const & map, std::string const & other_part);
 
     /// orchestrates entire request parsing
     bool parseRequest(Ssl::CertificateProperties &, std::string &error);
     void composeRequest(Ssl::CertificateProperties const &); // throws
 
     /// String code for "new_certificate" messages
     static const std::string code_new_certificate;
     /// Parameter name for passing hostname
     static const std::string param_host;
     /// Parameter name for passing SetValidAfter cert adaptation variable
     static const std::string param_SetValidAfter;
     /// Parameter name for passing SetValidBefore cert adaptation variable
     static const std::string param_SetValidBefore;
     /// Parameter name for passing SetCommonName cert adaptation variable
     static const std::string param_SetCommonName;
     /// Parameter name for passing signing algorithm
     static const std::string param_Sign;
+    /// The signing hash to use
+    static const std::string param_SignHash;
 protected:
     enum ParseState {
         BEFORE_CODE,
         CODE,
         BEFORE_LENGTH,
         LENGTH,
         BEFORE_BODY,
         BODY,
         END
     };
     size_t body_size; ///< The body size if exist or 0.
     ParseState state; ///< Parsing state.
     std::string body; ///< Current body.
     std::string code; ///< Current response/request code.
     std::string current_block; ///< Current block buffer.
 };
 
 } //namespace Ssl
 
 #endif // SQUID_SSL_CRTD_MESSAGE_H

=== modified file 'src/ssl/gadgets.cc'
--- src/ssl/gadgets.cc	2014-09-13 13:59:43 +0000
+++ src/ssl/gadgets.cc	2014-10-01 16:27:41 +0000
@@ -204,74 +204,80 @@
 }
 
 const char *Ssl::CertSignAlgorithmStr[] = {
     "signTrusted",
     "signUntrusted",
     "signSelf",
     NULL
 };
 
 const char *Ssl::CertAdaptAlgorithmStr[] = {
     "setValidAfter",
     "setValidBefore",
     "setCommonName",
     NULL
 };
 
 Ssl::CertificateProperties::CertificateProperties():
         setValidAfter(false),
         setValidBefore(false),
         setCommonName(false),
-        signAlgorithm(Ssl::algSignEnd)
+        signAlgorithm(Ssl::algSignEnd),
+        signHash(NULL)
 {}
 
 std::string & Ssl::CertificateProperties::dbKey() const
 {
     static std::string certKey;
     certKey.clear();
     certKey.reserve(4096);
     if (mimicCert.get()) {
         char buf[1024];
         certKey.append(X509_NAME_oneline(X509_get_subject_name(mimicCert.get()), buf, sizeof(buf)));
     }
 
     if (certKey.empty()) {
         certKey.append("/CN=", 4);
         certKey.append(commonName);
     }
 
     if (setValidAfter)
         certKey.append("+SetValidAfter=on", 17);
 
     if (setValidBefore)
         certKey.append("+SetValidBefore=on", 18);
 
     if (setCommonName) {
         certKey.append("+SetCommonName=", 15);
         certKey.append(commonName);
     }
 
     if (signAlgorithm != Ssl::algSignEnd) {
         certKey.append("+Sign=", 6);
         certKey.append(certSignAlgorithm(signAlgorithm));
     }
 
+    if (signHash != NULL) {
+        certKey.append("+SignHash=", 10);
+        certKey.append(EVP_MD_name(signHash));
+    }
+
     return certKey;
 }
 
 /// Copy certificate extensions from cert to mimicCert.
 /// Returns the number of extensions copied.
 // Currently only extensions which are reported by the users that required are
 // mimicked. More safe to mimic extensions would be added here if users request
 // them.
 static int
 mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
 {
     static int extensions[]= {
         NID_key_usage,
         NID_ext_key_usage,
         NID_basic_constraints,
         0
     };
 
     // key usage bit names
     enum {
@@ -417,45 +423,47 @@
 
     // Set pub key and serial given by the caller
     if (!X509_set_pubkey(cert.get(), pkey.get()))
         return false;
     if (!setSerialNumber(X509_get_serialNumber(cert.get()), serial.get()))
         return false;
 
     // Fill the certificate with the required properties
     if (!buildCertificate(cert, properties))
         return false;
 
     int ret = 0;
     // Set issuer name, from CA or our subject name for self signed cert
     if (properties.signAlgorithm != Ssl::algSignSelf && properties.signWithX509.get())
         ret = X509_set_issuer_name(cert.get(), X509_get_subject_name(properties.signWithX509.get()));
     else // Self signed certificate, set issuer to self
         ret = X509_set_issuer_name(cert.get(), X509_get_subject_name(cert.get()));
     if (!ret)
         return false;
 
+    const  EVP_MD *hash = properties.signHash ? properties.signHash : EVP_get_digestbyname(SQUID_SSL_SIGN_HASH_IF_NONE);
+    assert(hash);
     /*Now sign the request */
     if (properties.signAlgorithm != Ssl::algSignSelf && properties.signWithPkey.get())
-        ret = X509_sign(cert.get(), properties.signWithPkey.get(), EVP_sha1());
+        ret = X509_sign(cert.get(), properties.signWithPkey.get(), hash);
     else //else sign with self key (self signed request)
-        ret = X509_sign(cert.get(), pkey.get(), EVP_sha1());
+        ret = X509_sign(cert.get(), pkey.get(), hash);
 
     if (!ret)
         return false;
 
     certToStore.reset(cert.release());
     pkeyToStore.reset(pkey.release());
     return true;
 }
 
 static  BIGNUM *createCertSerial(unsigned char *md, unsigned int n)
 {
 
     assert(n == 20); //for sha1 n is 20 (for md5 n is 16)
 
     BIGNUM *serial = NULL;
     serial = BN_bin2bn(md, n, NULL);
 
     // if the serial is "0" set it to '1'
     if (BN_is_zero(serial) == true)
         BN_one(serial);

=== modified file 'src/ssl/gadgets.h'
--- src/ssl/gadgets.h	2014-09-13 13:59:43 +0000
+++ src/ssl/gadgets.h	2014-10-01 16:27:41 +0000
@@ -17,40 +17,44 @@
 #endif
 #if HAVE_OPENSSL_TXT_DB_H
 #include <openssl/txt_db.h>
 #endif
 #include <string>
 
 namespace Ssl
 {
 /**
  \defgroup SslCrtdSslAPI ssl_crtd SSL api.
  These functions must not depend on Squid runtime code such as debug()
  because they are used by ssl_crtd.
  */
 
 #if SQUID_USE_CONST_SSL_METHOD
 typedef const SSL_METHOD * ContextMethod;
 #else
 typedef SSL_METHOD * ContextMethod;
 #endif
 
+#ifndef SQUID_SSL_SIGN_HASH_IF_NONE
+#define SQUID_SSL_SIGN_HASH_IF_NONE "sha256"
+#endif
+
 /**
    \ingroup SslCrtdSslAPI
   * Add SSL locking (a.k.a. reference counting) to TidyPointer
   */
 template <typename T, void (*DeAllocator)(T *t), int lock>
 class LockingPointer: public TidyPointer<T, DeAllocator>
 {
 public:
     typedef TidyPointer<T, DeAllocator> Parent;
 
     LockingPointer(T *t = NULL): Parent(t) {
     }
 
     void resetAndLock(T *t) {
         if (t != this->get()) {
             this->reset(t);
             if (t)
                 CRYPTO_add(&t->references, 1, lock);
         }
     }
@@ -217,40 +221,41 @@
 
     return NULL;
 }
 
 /**
  \ingroup SslCrtdSslAPI
  * Simple struct to pass certificate generation parameters to generateSslCertificate function.
  */
 class CertificateProperties
 {
 public:
     CertificateProperties();
     X509_Pointer mimicCert; ///< Certificate to mimic
     X509_Pointer signWithX509; ///< Certificate to sign the generated request
     EVP_PKEY_Pointer signWithPkey; ///< The key of the signing certificate
     bool setValidAfter; ///< Do not mimic "Not Valid After" field
     bool setValidBefore; ///< Do not mimic "Not Valid Before" field
     bool setCommonName; ///< Replace the CN field of the mimicing subject with the given
     std::string commonName; ///< A CN to use for the generated certificate
     CertSignAlgorithm signAlgorithm; ///< The signing algorithm to use
+    const EVP_MD *signHash; ///< The signing hash to use
     /// Returns certificate database primary key. New fake certificates
     /// purge old fake certificates with the same key.
     std::string & dbKey() const;
 private:
     CertificateProperties(CertificateProperties &);
     CertificateProperties &operator =(CertificateProperties const &);
 };
 
 /**
  \ingroup SslCrtdSslAPI
  * Decide on the kind of certificate and generate a CA- or self-signed one.
  * The  generated certificate will inherite properties from certToMimic
  * Return generated certificate and private key in resultX509 and resultPkey
  * variables.
  */
 bool generateSslCertificate(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, CertificateProperties const &properties);
 
 /**
  \ingroup SslCrtdSslAPI
  * Read private key from file. Make sure that this is not encrypted file.

=== modified file 'src/ssl/ssl_crtd.cc'
--- src/ssl/ssl_crtd.cc	2014-09-13 13:59:43 +0000
+++ src/ssl/ssl_crtd.cc	2014-10-01 16:27:41 +0000
@@ -278,40 +278,43 @@
                 create_new_db = true;
                 break;
             case 'h':
                 usage();
                 exit(0);
             default:
                 exit(0);
             }
         }
 
         if (create_new_db) {
             std::cout << "Initialization SSL db..." << std::endl;
             Ssl::CertificateDb::create(db_path);
             std::cout << "Done" << std::endl;
             exit(0);
         }
 
         {
             Ssl::CertificateDb::check(db_path, max_db_size);
         }
+        // Initialize SSL subsystem
+        SSL_load_error_strings();
+        SSLeay_add_ssl_algorithms();
         // proccess request.
         for (;;) {
             char request[HELPER_INPUT_BUFFER];
             Ssl::CrtdMessage request_message(Ssl::CrtdMessage::REQUEST);
             Ssl::CrtdMessage::ParseResult parse_result = Ssl::CrtdMessage::INCOMPLETE;
 
             while (parse_result == Ssl::CrtdMessage::INCOMPLETE) {
                 if (fgets(request, HELPER_INPUT_BUFFER, stdin) == NULL)
                     return 1;
                 size_t gcount = strlen(request);
                 parse_result = request_message.parse(request, gcount);
             }
 
             if (parse_result == Ssl::CrtdMessage::ERROR) {
                 throw std::runtime_error("Cannot parse request message.");
             } else if (request_message.getCode() == Ssl::CrtdMessage::code_new_certificate) {
                 proccessNewRequest(request_message, db_path, max_db_size, fs_block_size);
             } else {
                 throw std::runtime_error("Unknown request code: \"" + request_message.getCode() + "\".");
             }

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2014-09-13 13:59:43 +0000
+++ src/ssl/support.cc	2014-10-01 16:27:41 +0000
@@ -19,40 +19,42 @@
 #include "anyp/PortCfg.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "ipc/MemMap.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "ssl/bio.h"
 #include "ssl/Config.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/gadgets.h"
 #include "ssl/support.h"
 #include "URL.h"
 
 #include <cerrno>
 
 static void setSessionCallbacks(SSL_CTX *ctx);
 Ipc::MemMap *SslSessionCache = NULL;
 const char *SslSessionCacheName = "ssl_session_cache";
 
+const EVP_MD *Ssl::DefaultSignHash = NULL;
+
 const char *Ssl::BumpModeStr[] = {
     "none",
     "client-first",
     "server-first",
     "peek",
     "stare",
     "bump",
     "splice",
     "terminate",
     /*"err",*/
     NULL
 };
 
 /**
  \defgroup ServerProtocolSSLInternal Server-Side SSL Internals
  \ingroup ServerProtocolSSLAPI
  */
 
 /// \ingroup ServerProtocolSSLInternal
 static int
@@ -701,40 +703,45 @@
 
     SSL_load_error_strings();
     SSLeay_add_ssl_algorithms();
 
 #if HAVE_OPENSSL_ENGINE_H
     if (Config.SSL.ssl_engine) {
         ENGINE *e;
         if (!(e = ENGINE_by_id(Config.SSL.ssl_engine)))
             fatalf("Unable to find SSL engine '%s'\n", Config.SSL.ssl_engine);
 
         if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
             int ssl_error = ERR_get_error();
             fatalf("Failed to initialise SSL engine: %s\n", ERR_error_string(ssl_error, NULL));
         }
     }
 #else
     if (Config.SSL.ssl_engine)
         fatalf("Your OpenSSL has no SSL engine support\n");
 #endif
 
+    const char *defName = Config.SSL.certSignHash ? Config.SSL.certSignHash : SQUID_SSL_SIGN_HASH_IF_NONE;
+    Ssl::DefaultSignHash = EVP_get_digestbyname(defName);
+    if (!Ssl::DefaultSignHash)
+        fatalf("Sign hash '%s' is not supported\n", defName);
+
     ssl_ex_index_server = SSL_get_ex_new_index(0, (void *) "server", NULL, NULL, NULL);
     ssl_ctx_ex_index_dont_verify_domain = SSL_CTX_get_ex_new_index(0, (void *) "dont_verify_domain", NULL, NULL, NULL);
     ssl_ex_index_cert_error_check = SSL_get_ex_new_index(0, (void *) "cert_error_check", NULL, &ssl_dupAclChecklist, &ssl_freeAclChecklist);
     ssl_ex_index_ssl_error_detail = SSL_get_ex_new_index(0, (void *) "ssl_error_detail", NULL, NULL, &ssl_free_ErrorDetail);
     ssl_ex_index_ssl_peeked_cert  = SSL_get_ex_new_index(0, (void *) "ssl_peeked_cert", NULL, NULL, &ssl_free_X509);
     ssl_ex_index_ssl_errors =  SSL_get_ex_new_index(0, (void *) "ssl_errors", NULL, NULL, &ssl_free_SslErrors);
     ssl_ex_index_ssl_cert_chain = SSL_get_ex_new_index(0, (void *) "ssl_cert_chain", NULL, NULL, &ssl_free_CertChain);
     ssl_ex_index_ssl_validation_counter = SSL_get_ex_new_index(0, (void *) "ssl_validation_counter", NULL, NULL, &ssl_free_int);
 }
 
 /// \ingroup ServerProtocolSSLInternal
 static int
 ssl_load_crl(SSL_CTX *sslContext, const char *CRLfile)
 {
     X509_STORE *st = SSL_CTX_get_cert_store(sslContext);
     X509_CRL *crl;
     BIO *in = BIO_new_file(CRLfile, "r");
     int count = 0;
 
     if (!in) {

=== modified file 'src/ssl/support.h'
--- src/ssl/support.h	2014-09-13 13:59:43 +0000
+++ src/ssl/support.h	2014-10-01 16:27:41 +0000
@@ -115,40 +115,42 @@
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserCertificatePEM(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserCertificateChainPEM(SSL *ssl);
 
 namespace Ssl
 {
 /// \ingroup ServerProtocolSSLAPI
 typedef char const *GETX509ATTRIBUTE(X509 *, const char *);
 
 /// \ingroup ServerProtocolSSLAPI
 GETX509ATTRIBUTE GetX509UserAttribute;
 
 /// \ingroup ServerProtocolSSLAPI
 GETX509ATTRIBUTE GetX509CAAttribute;
 
 /// \ingroup ServerProtocolSSLAPI
 GETX509ATTRIBUTE GetX509Fingerprint;
 
+extern const EVP_MD *DefaultSignHash;
+
 /**
   \ingroup ServerProtocolSSLAPI
  * Supported ssl-bump modes
  */
 enum BumpMode {bumpNone = 0, bumpClientFirst, bumpServerFirst, bumpPeek, bumpStare, bumpBump, bumpSplice, bumpTerminate, /*bumpErr,*/ bumpEnd};
 
 enum BumpStep {bumpStep1, bumpStep2, bumpStep3};
 
 /**
  \ingroup  ServerProtocolSSLAPI
  * Short names for ssl-bump modes
  */
 extern const char *BumpModeStr[];
 
 /**
  \ingroup ServerProtocolSSLAPI
  * Return the short name of the ssl-bump mode "bm"
  */
 inline const char *bumpMode(int bm)
 {

