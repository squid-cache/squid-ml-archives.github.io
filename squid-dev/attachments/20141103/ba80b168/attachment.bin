Make helper queue size configurable, with consistent defaults and better overflow handling.

This patch adds a queue-size=N option to helpers configuration. This
option allows users to configure the maximum number of queued requests
to busy helpers. We also adjusted the default queue size limits to be
more consistent across all helpers and made Squid more robust on some
queue overflows:

- external_acl helpers
    Make the maximum queue size configurable via queue-size.
    Default to 2*maximum-number-of-children.
    If the queue overflows, then the ACL returns ACCESS_DUNNO.

    Unpatched code uses the number of running children as the maximum
    queue size. If the queue is overloaded, then the ACL returns ACCESS_DUNNO.

-redirector/storeID helpers
    Make the maximum queue size configurable via queue-size.
    Default to 2*maximum-number-of-children.
    If the queue overflows and redirector_bypass configuration option
    is set, then redirector is bypassed. Otherwise, if overloading
    persists for more than 3 minutes squid quits with a FATAL message.

    Unpatched code uses 2*number-of-running-children as the maximum queue size.
    If the queue is overloaded, and redirector_bypass/storeID_bypass is not set
    then squid quits with a FATAL message.

- ssl_crtd/ssl_crtd_validator helpers.
    Make the maximum queue size configurable via queue-size.
    Default to 2*maximum-number-of-children.
    If the queue overflows, then helpers are bypassed. If overloading persists
    for more than 3 minutes squid quits with a FATAL message.

    The default size limit and overflow behavior has not changed.

- Authentication helpers
    Make the maximum queue size configurable via queue-size.
    Default to 2*maximum-number-of-children.
    If the queue overflows and overloading persists for more than 3 minutes,
    then squid quits with a FATAL message.

    The default size limit and overflow behavior has not changed.


This is a Measurement Factory project

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2014-10-17 00:35:19 +0000
+++ src/cf.data.pre	2014-11-03 15:04:00 +0000
@@ -411,65 +411,70 @@
 		when user authentication depends on http_port).
 
 		Avoid adding frequently changing information to key_extras. For
 		example, if you add user source IP, and it changes frequently
 		in your environment, then max_user_ip ACL is going to treat
 		every user+IP combination as a unique "user", breaking the ACL
 		and wasting a lot of memory on those user records. It will also
 		force users to authenticate from scratch whenever their IP
 		changes.
 
 	"realm" string
 		Specifies the protection scope (aka realm name) which is to be
 		reported to the client for the authentication scheme. It is
 		commonly part of the text the user will see when prompted for
 		their username and password.
 
 		For Basic the default is "Squid proxy-caching web server".
 		For Digest there is no default, this parameter is mandatory.
 		For NTLM and Negotiate this parameter is ignored.
 
-	"children" numberofchildren [startup=N] [idle=N] [concurrency=N]
+	"children" numberofchildren [startup=N] [idle=N] [concurrency=N] [queue-size=N]
 
 		The maximum number of authenticator processes to spawn. If
 		you start too few Squid will have to wait for them to process
 		a backlog of credential verifications, slowing it down. When
 		password verifications are done via a (slow) network you are
 		likely to need lots of authenticator processes.
 
 		The startup= and idle= options permit some skew in the exact
 		amount run. A minimum of startup=N will begin during startup
 		and reconfigure. Squid will start more in groups of up to
 		idle=N in an attempt to meet traffic needs and to keep idle=N
 		free above those traffic needs up to the maximum.
 
 		The concurrency= option sets the number of concurrent requests
 		the helper can process.  The default of 0 is used for helpers
 		who only supports one request at a time. Setting this to a
 		number greater than 0 changes the protocol used to include a
 		channel ID field first on the request/response line, allowing
 		multiple requests to be sent to the same helper in parallel
 		without waiting for the response.
 
 		Concurrency must not be set unless it's known the helper
 		supports the input format with channel-ID fields.
 
+		The queue-size= option sets the maximum number of queued
+		requests. If the queued requests exceed queue size for more
+		than 3 minutes then squid aborts its operation.
+		The default value is set to 2*numberofchildren/
+
 		NOTE: NTLM and Negotiate schemes do not support concurrency
 			in the Squid code module even though some helpers can.
 
 
 IF HAVE_AUTH_MODULE_BASIC
 	=== Basic authentication parameters ===
 
 	"utf8" on|off
 		HTTP uses iso-latin-1 as character set, while some
 		authentication backends such as LDAP expects UTF-8. If this is
 		set to on Squid will translate the HTTP iso-latin-1 charset to
 		UTF-8 before sending the username and password to the helper.
 
 	"credentialsttl" timetolive
 		Specifies how long squid assumes an externally validated
 		username:password pair is valid for - in other words how
 		often the helper program is called for that user. Set this
 		low to force revalidation with short lived passwords.
 
 		NOTE: setting this high does not impact your susceptibility
@@ -629,40 +634,44 @@
 
 	  ttl=n		TTL in seconds for cached results (defaults to 3600
 	  		for 1 hour)
 	  negative_ttl=n
 	  		TTL for cached negative lookups (default same
 	  		as ttl)
 	  children-max=n
 			Maximum number of acl helper processes spawned to service
 			external acl lookups of this type. (default 20)
 	  children-startup=n
 			Minimum number of acl helper processes to spawn during
 			startup and reconfigure to service external acl lookups
 			of this type. (default 0)
 	  children-idle=n
 			Number of acl helper processes to keep ahead of traffic
 			loads. Squid will spawn this many at once whenever load
 			rises above the capabilities of existing processes.
 			Up to the value of children-max. (default 1)
 	  concurrency=n	concurrency level per process. Only used with helpers
 			capable of processing more than one query at a time.
+	  queue-size=N  The queue-size= option sets the maximum number of queued
+			requests. If the queued requests exceed queue size 
+			the acl ignored.
+			The default value is set to 2*children-max.
 	  cache=n	limit the result cache size, default is 262144.
 	  grace=n	Percentage remaining of TTL where a refresh of a
 			cached entry should be initiated without needing to
 			wait for a new reply. (default is for no grace period)
 	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers
 	  ipv4 / ipv6	IP protocol used to communicate with this helper.
 			The default is to auto-detect IPv6 and use it when available.
 
 	FORMAT specifications
 
 	  %LOGIN	Authenticated user login name
 	  %EXT_USER	Username from previous external acl
 	  %EXT_LOG	Log details from previous external acl
 	  %EXT_TAG	Tag from previous external acl
 	  %IDENT	Ident user name
 	  %SRC		Client IP
 	  %SRCPORT	Client source port
 	  %URI		Requested URI
 	  %DST		Requested host
 	  %PROTO	Requested URL scheme
@@ -2788,40 +2797,47 @@
 	The maximum this may be safely set to is 32.
 	
 	The startup= and idle= options allow some measure of skew in your
 	tuning.
 	
 		startup=N
 	
 	Sets the minimum number of processes to spawn when Squid
 	starts or reconfigures. When set to zero the first request will
 	cause spawning of the first child process to handle it.
 	
 	Starting too few children temporary slows Squid under load while it
 	tries to spawn enough additional processes to cope with traffic.
 	
 		idle=N
 	
 	Sets a minimum of how many processes Squid is to try and keep available
 	at all times. When traffic begins to rise above what the existing
 	processes can handle this many more will be spawned up to the maximum
 	configured. A minimum setting of 1 is required.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size for more than 3 minutes
+	squid aborts its operation.
+	The default value is set to 2*numberofchildren.
 	
 	You must have at least one ssl_crtd process.
 DOC_END
 
 NAME: sslcrtvalidator_program
 TYPE: eol
 IFDEF: USE_OPENSSL
 DEFAULT: none
 LOC: Ssl::TheConfig.ssl_crt_validator
 DOC_START
 	Specify the location and options of the executable for ssl_crt_validator
 	process.
 
 	Usage:  sslcrtvalidator_program [ttl=n] [cache=n] path ...
 
 	Options:
 	  ttl=n         TTL in seconds for cached results. The default is 60 secs
 	  cache=n       limit the result cache size. The default value is 2048
 DOC_END
 
@@ -2847,40 +2863,47 @@
 	tries to spawn enough additional processes to cope with traffic.
 	
 		idle=N
 	
 	Sets a minimum of how many processes Squid is to try and keep available
 	at all times. When traffic begins to rise above what the existing
 	processes can handle this many more will be spawned up to the maximum
 	configured. A minimum setting of 1 is required.
 
 		concurrency=
 	
 	The number of requests each certificate validator helper can handle in
 	parallel. A value of 0 indicates the certficate validator does not
 	support concurrency. Defaults to 1.
 	
 	When this directive is set to a value >= 1 then the protocol
 	used to communicate with the helper is modified to include
 	a request ID in front of the request/response. The request
 	ID from the request must be echoed back with the response
 	to that request.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size for more than 3 minutes
+	squid aborts its operation.
+	The default value is set to 2*numberofchildren.
 	
 	You must have at least one ssl_crt_validator process.
 DOC_END
 
 COMMENT_START
  OPTIONS WHICH AFFECT THE NEIGHBOR SELECTION ALGORITHM
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: cache_peer
 TYPE: peer
 DEFAULT: none
 LOC: Config.peers
 DOC_START
 	To specify other caches in a hierarchy, use the format:
 	
 		cache_peer hostname type http-port icp-port [options]
 	
 	For example,
 	
@@ -4852,40 +4875,48 @@
 	Starting too few will cause an initial slowdown in traffic as Squid
 	attempts to simultaneously spawn enough processes to cope.
 	
 		idle=
 	
 	Sets a minimum of how many processes Squid is to try and keep available
 	at all times. When traffic begins to rise above what the existing
 	processes can handle this many more will be spawned up to the maximum
 	configured. A minimum setting of 1 is required.
 
 		concurrency=
 
 	The number of requests each redirector helper can handle in
 	parallel. Defaults to 0 which indicates the redirector
 	is a old-style single threaded redirector.
 
 	When this directive is set to a value >= 1 then the protocol
 	used to communicate with the helper is modified to include
 	an ID in front of the request/response. The ID from the request
 	must be echoed back with the response to that request.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size and redirector_bypass
+	configuration option is set, then redirector is bypassed. Otherwise, if
+	overloading persist squid may abort its operation.
+	The default value is set to 2*numberofchildren.
 DOC_END
 
 NAME: url_rewrite_host_header redirect_rewrites_host_header
 TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.redir_rewrites_host
 DOC_START
 	To preserve same-origin security policies in browsers and
 	prevent Host: header forgery by redirectors Squid rewrites
 	any Host: header in redirected requests.
 	
 	If you are running an accelerator this may not be a wanted
 	effect of a redirector. This directive enables you disable
 	Host: alteration in reverse-proxy traffic.
 	
 	WARNING: Entries are cached on the result of the URL rewriting
 	process, so be careful if you have domain-virtual hosts.
 	
 	WARNING: Squid and other software verifies the URL and Host
 	are matching, so be careful not to relay through other proxies
@@ -5026,40 +5057,48 @@
 	Starting too few will cause an initial slowdown in traffic as Squid
 	attempts to simultaneously spawn enough processes to cope.
 	
 		idle=
 	
 	Sets a minimum of how many processes Squid is to try and keep available
 	at all times. When traffic begins to rise above what the existing
 	processes can handle this many more will be spawned up to the maximum
 	configured. A minimum setting of 1 is required.
 
 		concurrency=
 
 	The number of requests each storeID helper can handle in
 	parallel. Defaults to 0 which indicates the helper
 	is a old-style single threaded program.
 
 	When this directive is set to a value >= 1 then the protocol
 	used to communicate with the helper is modified to include
 	an ID in front of the request/response. The ID from the request
 	must be echoed back with the response to that request.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size and store_id_bypass
+	configuration option is set, then storeID helper bypassed. Otherwise,
+	if overloading persist squid may abort its operation.
+	The default value is set to 2*numberofchildren.
 DOC_END
 
 NAME: store_id_access storeurl_rewrite_access
 TYPE: acl_access
 DEFAULT: none
 DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 LOC: Config.accessList.store_id
 DOC_START
 	If defined, this access list specifies which requests are
 	sent to the StoreID processes.  By default all requests
 	are sent.
 
 	This clause supports both fast and slow acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
 DOC_END
 
 NAME: store_id_bypass storeurl_rewrite_bypass
 TYPE: onoff
 LOC: Config.onoff.store_id_bypass
 DEFAULT: on

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2014-10-20 06:58:59 +0000
+++ src/external_acl.cc	2014-11-01 10:07:25 +0000
@@ -234,57 +234,60 @@
     a->ttl = DEFAULT_EXTERNAL_ACL_TTL;
     a->negative_ttl = -1;
     a->cache_size = 256*1024;
     a->children.n_max = DEFAULT_EXTERNAL_ACL_CHILDREN;
     a->children.n_startup = a->children.n_max;
     a->children.n_idle = 1;
     a->local_addr.setLocalhost();
     a->quote = external_acl::QUOTE_METHOD_URL;
 
     token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
 
     a->name = xstrdup(token);
 
     // Allow supported %macros inside quoted tokens
     ConfigParser::EnableMacros();
     token = ConfigParser::NextToken();
 
+    int queue_size = -1;
     /* Parse options */
     while (token) {
         if (strncmp(token, "ttl=", 4) == 0) {
             a->ttl = atoi(token + 4);
         } else if (strncmp(token, "negative_ttl=", 13) == 0) {
             a->negative_ttl = atoi(token + 13);
         } else if (strncmp(token, "children=", 9) == 0) {
             a->children.n_max = atoi(token + 9);
             debugs(0, DBG_CRITICAL, "WARNING: external_acl_type option children=N has been deprecated in favor of children-max=N and children-startup=N");
         } else if (strncmp(token, "children-max=", 13) == 0) {
             a->children.n_max = atoi(token + 13);
         } else if (strncmp(token, "children-startup=", 17) == 0) {
             a->children.n_startup = atoi(token + 17);
         } else if (strncmp(token, "children-idle=", 14) == 0) {
             a->children.n_idle = atoi(token + 14);
         } else if (strncmp(token, "concurrency=", 12) == 0) {
             a->children.concurrency = atoi(token + 12);
+        } else if (strncmp(token, "queue-size=", 11) == 0) {
+            queue_size = atoi(token + 11);
         } else if (strncmp(token, "cache=", 6) == 0) {
             a->cache_size = atoi(token + 6);
         } else if (strncmp(token, "grace=", 6) == 0) {
             a->grace = atoi(token + 6);
         } else if (strcmp(token, "protocol=2.5") == 0) {
             a->quote = external_acl::QUOTE_METHOD_SHELL;
         } else if (strcmp(token, "protocol=3.0") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option protocol=3.0 is deprecated. Remove this from your config.");
             a->quote = external_acl::QUOTE_METHOD_URL;
         } else if (strcmp(token, "quote=url") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=url is deprecated. Remove this from your config.");
             a->quote = external_acl::QUOTE_METHOD_URL;
         } else if (strcmp(token, "quote=shell") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=shell is deprecated. Use protocol=2.5 if still needed.");
             a->quote = external_acl::QUOTE_METHOD_SHELL;
 
             /* INET6: allow admin to configure some helpers explicitly to
                       bind to IPv4/v6 localhost port. */
         } else if (strcmp(token, "ipv4") == 0) {
             if ( !a->local_addr.setIPv4() ) {
@@ -298,40 +301,42 @@
             break;
         }
 
         token = ConfigParser::NextToken();
     }
     ConfigParser::DisableMacros();
 
     /* check that child startup value is sane. */
     if (a->children.n_startup > a->children.n_max)
         a->children.n_startup = a->children.n_max;
 
     /* check that child idle value is sane. */
     if (a->children.n_idle > a->children.n_max)
         a->children.n_idle = a->children.n_max;
     if (a->children.n_idle < 1)
         a->children.n_idle = 1;
 
     if (a->negative_ttl == -1)
         a->negative_ttl = a->ttl;
 
+    a->children.queue_size = queue_size < 0 ? (2 * a->children.n_max) : queue_size;
+
     /* Parse format */
     external_acl_format::Pointer *p = &a->format;
 
     while (token) {
         /* stop on first non-format token found */
 
         if (*token != '%')
             break;
 
         external_acl_format::Pointer format = new external_acl_format;
 
         if (strncmp(token, "%{", 2) == 0) {
             // deprecated. but assume the old configs all referred to request headers.
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
             parse_header_token(format, (token+2), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%>{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
             parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%>ha{", 5) == 0) {
             parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
@@ -759,41 +764,41 @@
             /* Not sufficient data to process */
             return ACCESS_DUNNO;
         }
 
         entry = static_cast<ExternalACLEntry *>(hash_lookup(acl->def->cache, key));
 
         const ExternalACLEntryPointer staleEntry = entry;
         if (entry != NULL && external_acl_entry_expired(acl->def, entry))
             entry = NULL;
 
         if (entry != NULL && external_acl_grace_expired(acl->def, entry)) {
             // refresh in the background
             ExternalACLLookup::Start(ch, acl, true);
             debugs(82, 4, HERE << "no need to wait for the refresh of '" <<
                    key << "' in '" << acl->def->name << "' (ch=" << ch << ").");
         }
 
         if (!entry) {
             debugs(82, 2, HERE << acl->def->name << "(\"" << key << "\") = lookup needed");
 
-            if (acl->def->theHelper->stats.queue_size < (int)acl->def->theHelper->childs.n_active) {
+            if (!acl->def->theHelper->queueFull()) {
                 debugs(82, 2, HERE << "\"" << key << "\": queueing a call.");
                 if (!ch->goAsync(ExternalACLLookup::Instance()))
                     debugs(82, 2, "\"" << key << "\": no async support!");
                 debugs(82, 2, HERE << "\"" << key << "\": return -1.");
                 return ACCESS_DUNNO; // expired cached or simply absent entry
             } else {
                 if (!staleEntry) {
                     debugs(82, DBG_IMPORTANT, "WARNING: external ACL '" << acl->def->name <<
                            "' queue overload. Request rejected '" << key << "'.");
                     external_acl_message = "SYSTEM TOO BUSY, TRY AGAIN LATER";
                     return ACCESS_DUNNO;
                 } else {
                     debugs(82, DBG_IMPORTANT, "WARNING: external ACL '" << acl->def->name <<
                            "' queue overload. Using stale result. '" << key << "'.");
                     entry = staleEntry;
                     /* Fall thru to processing below */
                 }
             }
         }
     }
@@ -1398,58 +1403,53 @@
         return;
     }
 
     externalAclState *state = cbdataAlloc(externalAclState);
     state->def = cbdataReference(def);
 
     state->key = xstrdup(key);
 
     if (!inBackground) {
         state->callback = &ExternalACLLookup::LookupDone;
         state->callback_data = cbdataReference(checklist);
     }
 
     if (oldstate) {
         /* Hook into pending lookup */
         state->queue = oldstate->queue;
         oldstate->queue = state;
     } else {
         /* No pending lookup found. Sumbit to helper */
 
-        /* Check for queue overload */
-
-        if (def->theHelper->stats.queue_size >= (int)def->theHelper->childs.n_running) {
-            debugs(82, 7, HERE << "'" << def->name << "' queue is too long");
-            assert(inBackground); // or the caller should have checked
-            cbdataFree(state);
-            return;
-        }
-
-        /* Send it off to the helper */
         MemBuf buf;
         buf.init();
 
         buf.Printf("%s\n", key);
 
         debugs(82, 4, "externalAclLookup: looking up for '" << key << "' in '" << def->name << "'.");
 
-        helperSubmit(def->theHelper, buf.buf, externalAclHandleReply, state);
+        if (!def->theHelper->trySubmit(buf.buf, externalAclHandleReply, state)) {
+            debugs(82, 7, HERE << "'" << def->name << "' queue is too long");
+            assert(inBackground); // or the caller should have checked
+            cbdataFree(state);
+            return;
+        }
 
         dlinkAdd(state, &state->list, &def->queue);
 
         buf.clean();
     }
 
     debugs(82, 4, "externalAclLookup: will wait for the result of '" << key <<
            "' in '" << def->name << "' (ch=" << ch << ").");
 }
 
 static void
 externalAclStats(StoreEntry * sentry)
 {
     external_acl *p;
 
     for (p = Config.externalAclHelperList; p; p = p->next) {
         storeAppendPrintf(sentry, "External ACL Statistics: %s\n", p->name);
         storeAppendPrintf(sentry, "Cache size: %d\n", p->cache->count);
         helperStats(sentry, p->theHelper);
         storeAppendPrintf(sentry, "\n");

=== modified file 'src/helper.cc'
--- src/helper.cc	2014-09-28 18:35:47 +0000
+++ src/helper.cc	2014-11-03 17:35:45 +0000
@@ -357,82 +357,140 @@
         AsyncCall::Pointer call = commCbCall(5,4, "helperStatefulHandleRead",
                                              CommIoCbPtrFun(helperStatefulHandleRead, srv));
         comm_read(srv->readPipe, srv->rbuf, srv->rbuf_sz - 1, call);
     }
 
     hlp->last_restart = squid_curtime;
     safe_free(shortname);
     safe_free(procname);
     helperStatefulKickQueue(hlp);
 }
 
 void
 helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperSubmit: hlp == NULL");
         Helper::Reply nilReply;
         callback(data, nilReply);
         return;
     }
+    hlp->prepSubmit();
+    hlp->submit(buf, callback, data);
+}
+
+bool
+helper::queueFull() const {
+    return stats.queue_size > static_cast<int>(childs.queue_size);
+}
+
+/// prepares the helper for request submission via trySubmit() or helperSubmit()
+/// currently maintains full_time and kills Squid if the helper remains full for too long
+void
+helper::prepSubmit()
+{
+    if (!queueFull())
+        full_time = 0;
+    else if (!full_time) // may happen here if reconfigure decreases capacity
+        full_time = squid_curtime;
+    else if (squid_curtime - full_time > 180)
+        fatalf("Too many queued %s requests", id_name);
+}
+
+bool
+helper::trySubmit(const char *buf, HLPCB * callback, void *data)
+{
+    prepSubmit();
 
+    if (queueFull()) {
+        debugs(84, DBG_IMPORTANT, id_name << " drops request due to a full queue");
+        return false; // request was ignored
+    }
+
+    submit(buf, callback, data); // will send or queue
+    return true; // request submitted or queued
+}
+
+/// dispatches or enqueues a helper requests; does not enforce queue limits
+void
+helper::submit(const char *buf, HLPCB * callback, void *data)
+{
     Helper::Request *r = new Helper::Request(callback, data, buf);
     helper_server *srv;
 
-    if ((srv = GetFirstAvailable(hlp)))
+    if ((srv = GetFirstAvailable(this)))
         helperDispatch(srv, r);
     else
-        Enqueue(hlp, r);
+        Enqueue(this, r);
 
     debugs(84, DBG_DATA, Raw("buf", buf, strlen(buf)));
+
+    if (!queueFull()) {
+        full_time = 0;
+    } else if (!full_time) {
+        debugs(84, 3, id_name << " queue became full");
+        full_time = squid_curtime;
+    }
 }
 
 /// lastserver = "server last used as part of a reserved request sequence"
 void
 helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperStatefulSubmit: hlp == NULL");
         Helper::Reply nilReply;
         callback(data, nilReply);
         return;
     }
+    hlp->prepSubmit();
+    hlp->submit(buf, callback, data, lastserver);
+}
 
+void statefulhelper::submit(const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver)
+{
     Helper::Request *r = new Helper::Request(callback, data, buf);
 
     if ((buf != NULL) && lastserver) {
         debugs(84, 5, "StatefulSubmit with lastserver " << lastserver);
         assert(lastserver->flags.reserved);
         assert(!(lastserver->request));
 
         debugs(84, 5, "StatefulSubmit dispatching");
         helperStatefulDispatch(lastserver, r);
     } else {
         helper_stateful_server *srv;
-        if ((srv = StatefulGetFirstAvailable(hlp))) {
+        if ((srv = StatefulGetFirstAvailable(this))) {
             helperStatefulDispatch(srv, r);
         } else
-            StatefulEnqueue(hlp, r);
+            StatefulEnqueue(this, r);
     }
 
     debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
            "', " << Raw("buf", buf, (!buf?0:strlen(buf))));
+
+    if (!queueFull()) {
+        full_time = 0;
+    } else if (!full_time) {
+        debugs(84, 3, id_name << " queue became full");
+        full_time = squid_curtime;
+    }
 }
 
 /**
  * DPW 2007-05-08
  *
  * helperStatefulReleaseServer tells the helper that whoever was
  * using it no longer needs its services.
  */
 void
 helperStatefulReleaseServer(helper_stateful_server * srv)
 {
     debugs(84, 3, HERE << "srv-" << srv->index << " flags.reserved = " << srv->flags.reserved);
     if (!srv->flags.reserved)
         return;
 
     ++ srv->stats.releases;
 
     srv->flags.reserved = false;
     if (srv->parent->OnEmptyQueue != NULL && srv->data)
         srv->parent->OnEmptyQueue(srv->data);
@@ -1043,93 +1101,88 @@
             debugs(84, 3, HERE << "Grew read buffer to " << srv->rbuf_sz);
             spaceSize = srv->rbuf_sz - srv->roffset - 1;
             assert(spaceSize >= 0);
         }
 
         // quit reading if there is no space left
         if (!spaceSize) {
             debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
                    "helper that overflowed " << srv->rbuf_sz << "-byte " <<
                    "Squid input buffer: " << hlp->id_name << " #" << srv->index);
             srv->closePipesSafely(hlp->id_name);
             return;
         }
 
         AsyncCall::Pointer call = commCbCall(5,4, "helperStatefulHandleRead",
                                              CommIoCbPtrFun(helperStatefulHandleRead, srv));
         comm_read(srv->readPipe, srv->rbuf + srv->roffset, spaceSize, call);
     }
 }
 
+/// Handles a request when all running helpers, if any, are busy.
 static void
 Enqueue(helper * hlp, Helper::Request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
     ++ hlp->stats.queue_size;
 
     /* do this first so idle=N has a chance to grow the child pool before it hits critical. */
     if (hlp->childs.needNew() > 0) {
         debugs(84, DBG_CRITICAL, "Starting new " << hlp->id_name << " helpers...");
         helperOpenServers(hlp);
         return;
     }
 
-    if (hlp->stats.queue_size < (int)hlp->childs.n_running)
+    if (hlp->stats.queue_size < (int)hlp->childs.queue_size)
         return;
 
     if (squid_curtime - hlp->last_queue_warn < 600)
         return;
 
     if (shutting_down || reconfiguring)
         return;
 
     hlp->last_queue_warn = squid_curtime;
 
     debugs(84, DBG_CRITICAL, "WARNING: All " << hlp->childs.n_active << "/" << hlp->childs.n_max << " " << hlp->id_name << " processes are busy.");
     debugs(84, DBG_CRITICAL, "WARNING: " << hlp->stats.queue_size << " pending requests queued");
     debugs(84, DBG_CRITICAL, "WARNING: Consider increasing the number of " << hlp->id_name << " processes in your config file.");
-
-    if (hlp->stats.queue_size > (int)hlp->childs.n_running * 2)
-        fatalf("Too many queued %s requests", hlp->id_name);
 }
 
 static void
 StatefulEnqueue(statefulhelper * hlp, Helper::Request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
     ++ hlp->stats.queue_size;
 
     /* do this first so idle=N has a chance to grow the child pool before it hits critical. */
     if (hlp->childs.needNew() > 0) {
         debugs(84, DBG_CRITICAL, "Starting new " << hlp->id_name << " helpers...");
         helperStatefulOpenServers(hlp);
         return;
     }
 
-    if (hlp->stats.queue_size < (int)hlp->childs.n_running)
+    if (hlp->stats.queue_size < (int)hlp->childs.queue_size)
         return;
 
-    if (hlp->stats.queue_size > (int)hlp->childs.n_running * 2)
-        fatalf("Too many queued %s requests", hlp->id_name);
-
     if (squid_curtime - hlp->last_queue_warn < 600)
         return;
 
     if (shutting_down || reconfiguring)
         return;
 
     hlp->last_queue_warn = squid_curtime;
 
     debugs(84, DBG_CRITICAL, "WARNING: All " << hlp->childs.n_active << "/" << hlp->childs.n_max << " " << hlp->id_name << " processes are busy.");
     debugs(84, DBG_CRITICAL, "WARNING: " << hlp->stats.queue_size << " pending requests queued");
     debugs(84, DBG_CRITICAL, "WARNING: Consider increasing the number of " << hlp->id_name << " processes in your config file.");
 }
 
 static Helper::Request *
 Dequeue(helper * hlp)
 {
     dlink_node *link;
     Helper::Request *r = NULL;
 
     if ((link = hlp->queue.head)) {

=== modified file 'src/helper.h'
--- src/helper.h	2014-09-25 06:50:32 +0000
+++ src/helper.h	2014-10-31 17:11:42 +0000
@@ -3,89 +3,121 @@
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 84    Helper process maintenance */
 
 #ifndef SQUID_HELPER_H
 #define SQUID_HELPER_H
 
 #include "base/AsyncCall.h"
 #include "base/InstanceId.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "dlink.h"
 #include "helper/ChildConfig.h"
 #include "helper/forward.h"
 #include "ip/Address.h"
 
+/**
+ * Managers a set of individual helper processes with a common queue of requests.
+ *
+ * With respect to load, a helper goes through these states (roughly):
+ *   idle:   no processes are working on requests (and no requests are queued);
+ *   normal: some, but not all processes are working (and no requests are queued);
+ *   busy:   all processes are working (and some requests are possibly queued);
+ *   full:   all processes are working and at least 2*#processes requests are queued.
+ *
+ * A "busy" helper queues new requests and issues a WARNING every 10 minutes or so.
+ * A "full" helper either drops new requests or keeps queuing them, depending on
+ *   whether the caller can handle dropped requests (trySubmit vs helperSubmit APIs).
+ * An attempt to use a "full" helper that has been "full" for 3+ minutes kills worker.
+ *   Given enough load, all helpers except for external ACL will make such attempts.
+ */
 class helper
 {
 public:
     inline helper(const char *name) :
             cmdline(NULL),
             id_name(name),
             ipc_type(0),
+            full_time(0),
             last_queue_warn(0),
             last_restart(0),
             eom('\n') {
         memset(&stats, 0, sizeof(stats));
     }
     ~helper();
 
+    ///< whether at least one more request can be successfully submitted
+    bool queueFull() const;
+
+    ///< If not full, submit request. Otherwise, either kill Squid or return false.
+    bool trySubmit(const char *buf, HLPCB * callback, void *data);
+
 public:
     wordlist *cmdline;
     dlink_list servers;
     dlink_list queue;
     const char *id_name;
     Helper::ChildConfig childs;    ///< Configuration settings for number running.
     int ipc_type;
     Ip::Address addr;
+    time_t full_time; ///< when a full helper became full (zero for non-full helpers)
     time_t last_queue_warn;
     time_t last_restart;
     char eom;   ///< The char which marks the end of (response) message, normally '\n'
 
     struct _stats {
         int requests;
         int replies;
         int queue_size;
         int avg_svc_time;
     } stats;
 
+protected:
+    friend void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data);
+    void prepSubmit();
+    void submit(const char *buf, HLPCB * callback, void *data);
+
 private:
+
     CBDATA_CLASS2(helper);
 };
 
 class statefulhelper : public helper
 {
 public:
     inline statefulhelper(const char *name) : helper(name), datapool(NULL), IsAvailable(NULL), OnEmptyQueue(NULL) {};
     inline ~statefulhelper() {};
 
 public:
     MemAllocator *datapool;
     HLPSAVAIL *IsAvailable;
     HLPSONEQ *OnEmptyQueue;
 
 private:
+    friend void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver);
+    void submit(const char *buf, HLPCB * callback, void *data, helper_stateful_server *lastserver);
+
     CBDATA_CLASS2(statefulhelper);
 };
 
 /**
  * Fields shared between stateless and stateful helper servers.
  */
 class HelperServerBase
 {
 public:
     /** Closes pipes to the helper safely.
      * Handles the case where the read and write pipes are the same FD.
      *
      * \param name displayed for the helper being shutdown if logging an error
      */
     void closePipesSafely(const char *name);
 
     /** Closes the reading pipe.
      * If the read and write sockets are the same the write pipe will
      * also be closed. Otherwise its left open for later handling.
      *

=== modified file 'src/helper/ChildConfig.cc'
--- src/helper/ChildConfig.cc	2014-10-05 09:59:47 +0000
+++ src/helper/ChildConfig.cc	2014-10-31 15:46:43 +0000
@@ -5,103 +5,113 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "globals.h"
 #include "helper/ChildConfig.h"
 #include "Parsing.h"
 
 #include <cstring>
 
 Helper::ChildConfig::ChildConfig():
         n_max(0),
         n_startup(0),
         n_idle(1),
         concurrency(0),
         n_running(0),
-        n_active(0)
+        n_active(0),
+        queue_size(0)
 {}
 
 Helper::ChildConfig::ChildConfig(const unsigned int m):
         n_max(m),
         n_startup(0),
         n_idle(1),
         concurrency(0),
         n_running(0),
-        n_active(0)
+        n_active(0),
+        queue_size(0)
 {}
 
 Helper::ChildConfig &
 Helper::ChildConfig::updateLimits(const Helper::ChildConfig &rhs)
 {
     // Copy the limits only.
     // Preserve the local state values (n_running and n_active)
     n_max = rhs.n_max;
     n_startup = rhs.n_startup;
     n_idle = rhs.n_idle;
     concurrency = rhs.concurrency;
+    queue_size = rhs.queue_size;
     return *this;
 }
 
 int
 Helper::ChildConfig::needNew() const
 {
     /* during the startup and reconfigure use our special amount... */
     if (starting_up || reconfiguring) return n_startup;
 
     /* keep a minimum of n_idle helpers free... */
     if ( (n_active + n_idle) < n_max) return n_idle;
 
     /* dont ever start more than n_max processes. */
     return (n_max - n_active);
 }
 
 void
 Helper::ChildConfig::parseConfig()
 {
     char const *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
 
     /* starts with a bare number for the max... back-compatible */
     n_max = xatoui(token);
 
     if (n_max < 1) {
         debugs(0, DBG_CRITICAL, "ERROR: The maximum number of processes cannot be less than 1.");
         self_destruct();
     }
 
+    bool useDefaultQueueSize = true;
     /* Parse extension options */
     for (; (token = ConfigParser::NextToken()) ;) {
         if (strncmp(token, "startup=", 8) == 0) {
             n_startup = xatoui(token + 8);
         } else if (strncmp(token, "idle=", 5) == 0) {
             n_idle = xatoui(token + 5);
             if (n_idle < 1) {
                 debugs(0, DBG_CRITICAL, "WARNING OVERIDE: Using idle=0 for helpers causes request failures. Overiding to use idle=1 instead.");
                 n_idle = 1;
             }
         } else if (strncmp(token, "concurrency=", 12) == 0) {
             concurrency = xatoui(token + 12);
+        } else if (strncmp(token, "queue-size=", 11) == 0) {
+            queue_size = xatoui(token + 11);
+            useDefaultQueueSize = false;
         } else {
             debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Undefined option: " << token << ".");
             self_destruct();
         }
     }
 
     /* simple sanity. */
 
     if (n_startup > n_max) {
         debugs(0, DBG_CRITICAL, "WARNING OVERIDE: Capping startup=" << n_startup << " to the defined maximum (" << n_max <<")");
         n_startup = n_max;
     }
 
     if (n_idle > n_max) {
         debugs(0, DBG_CRITICAL, "WARNING OVERIDE: Capping idle=" << n_idle << " to the defined maximum (" << n_max <<")");
         n_idle = n_max;
     }
+    
+    if (useDefaultQueueSize)
+        queue_size = 2 * n_max;
 }

=== modified file 'src/helper/ChildConfig.h'
--- src/helper/ChildConfig.h	2014-10-05 09:59:47 +0000
+++ src/helper/ChildConfig.h	2014-10-31 15:06:44 +0000
@@ -67,30 +67,35 @@
 
     /**
      * How many concurrent requests each child helper may be capable of handling.
      * Default: 0  - no concurrency possible.
      */
     unsigned int concurrency;
 
     /* derived from active operations */
 
     /**
      * Total helper children objects currently existing.
      * Produced as a side effect of starting children or their stopping.
      */
     unsigned int n_running;
 
     /**
      * Count of helper children active (not shutting down).
      * This includes both idle and in-use children.
      */
     unsigned int n_active;
+
+    /**
+     * The requests queue size. By default it is of size 2*n_max
+     */
+    unsigned int queue_size;
 };
 
 } // namespace Helper
 
 /* Legacy parser interface */
 #define parse_HelperChildConfig(c)     (c)->parseConfig()
 #define dump_HelperChildConfig(e,n,c)  storeAppendPrintf((e), "\n%s %d startup=%d idle=%d concurrency=%d\n", (n), (c).n_max, (c).n_startup, (c).n_idle, (c).concurrency)
 #define free_HelperChildConfig(dummy)  // NO.
 
 #endif /* _SQUID_SRC_HELPER_CHILDCONFIG_H */

=== modified file 'src/redirect.cc'
--- src/redirect.cc	2014-09-25 10:34:22 +0000
+++ src/redirect.cc	2014-10-31 15:50:23 +0000
@@ -274,66 +274,66 @@
 #endif
 
         node = (clientStreamNode *)http->client_stream.tail->data;
         clientStreamRead(node, http, node->readBuffer);
         return;
     }
 
     debugs(61,6, HERE << "sending '" << buf << "' to the " << name << " helper");
     helperSubmit(hlp, buf, replyHandler, r);
 }
 
 /**** PUBLIC FUNCTIONS ****/
 
 void
 redirectStart(ClientHttpRequest * http, HLPCB * handler, void *data)
 {
     assert(http);
     assert(handler);
     debugs(61, 5, "redirectStart: '" << http->uri << "'");
 
-    if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
-        /* Skip redirector if there is one request queued */
+    if (Config.onoff.redirector_bypass && redirectors->queueFull()) {
+        /* Skip redirector if the queue is full */
         ++redirectorBypassed;
         Helper::Reply bypassReply;
         bypassReply.result = Helper::Okay;
         bypassReply.notes.add("message","URL rewrite/redirect queue too long. Bypassed.");
         handler(data, bypassReply);
         return;
     }
 
     constructHelperQuery("redirector", redirectors, redirectHandleReply, http, handler, data, redirectorExtrasFmt);
 }
 
 /**
  * Handles the StoreID feature helper starting.
  * For now it cannot be done using the redirectStart method.
  */
 void
 storeIdStart(ClientHttpRequest * http, HLPCB * handler, void *data)
 {
     assert(http);
     assert(handler);
     debugs(61, 5, "storeIdStart: '" << http->uri << "'");
 
-    if (Config.onoff.store_id_bypass && storeIds->stats.queue_size) {
-        /* Skip StoreID Helper if there is one request queued */
+    if (Config.onoff.store_id_bypass && storeIds->queueFull()) {
+        /* Skip StoreID Helper if the queue is full */
         ++storeIdBypassed;
         Helper::Reply bypassReply;
 
         bypassReply.result = Helper::Okay;
 
         bypassReply.notes.add("message","StoreId helper queue too long. Bypassed.");
         handler(data, bypassReply);
         return;
     }
 
     constructHelperQuery("storeId helper", storeIds, storeIdHandleReply, http, handler, data, storeIdExtrasFmt);
 }
 
 void
 redirectInit(void)
 {
     static bool init = false;
 
     if (!init) {
         Mgr::RegisterAction("redirector", "URL Redirector Stats", redirectStats, 0, 1);

=== modified file 'src/ssl/helper.cc'
--- src/ssl/helper.cc	2014-10-08 15:31:21 +0000
+++ src/ssl/helper.cc	2014-10-30 15:52:14 +0000
@@ -81,60 +81,51 @@
             wordlistAdd(&ssl_crtd->cmdline, "-b");
             wordlistAdd(&ssl_crtd->cmdline, buffer);
         }
         safe_free(tmp_begin);
     }
     helperOpenServers(ssl_crtd);
 }
 
 void Ssl::Helper::Shutdown()
 {
     if (!ssl_crtd)
         return;
     helperShutdown(ssl_crtd);
     wordlistDestroy(&ssl_crtd->cmdline);
     delete ssl_crtd;
     ssl_crtd = NULL;
 }
 
 void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void * data)
 {
-    static time_t first_warn = 0;
     assert(ssl_crtd);
 
-    if (ssl_crtd->stats.queue_size >= (int)(ssl_crtd->childs.n_running * 2)) {
-        if (first_warn == 0)
-            first_warn = squid_curtime;
-        if (squid_curtime - first_warn > 3 * 60)
-            fatal("SSL servers not responding for 3 minutes");
-        debugs(34, DBG_IMPORTANT, HERE << "Queue overload, rejecting");
+    std::string msg = message.compose();
+    msg += '\n';
+    if (!ssl_crtd->trySubmit(msg.c_str(), callback, data)) {
         ::Helper::Reply failReply;
         failReply.result = ::Helper::BrokenHelper;
         failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
         callback(data, failReply);
         return;
     }
-
-    first_warn = 0;
-    std::string msg = message.compose();
-    msg += '\n';
-    helperSubmit(ssl_crtd, msg.c_str(), callback, data);
 }
 #endif //USE_SSL_CRTD
 
 Ssl::CertValidationHelper * Ssl::CertValidationHelper::GetInstance()
 {
     static Ssl::CertValidationHelper sslHelper;
     if (!Ssl::TheConfig.ssl_crt_validator)
         return NULL;
     return &sslHelper;
 }
 
 Ssl::CertValidationHelper::CertValidationHelper() : ssl_crt_validator(NULL)
 {
 }
 
 Ssl::CertValidationHelper::~CertValidationHelper()
 {
     Shutdown();
 }
 
@@ -231,60 +222,56 @@
         debugs(83, DBG_IMPORTANT, "Certificate cannot be validated. ssl_crtvd response: " << replyMsg.getBody());
         validationResponse->resultCode = ::Helper::BrokenHelper;
     } else
         validationResponse->resultCode = reply.result;
 
     crtdvdData->callback(crtdvdData->data, *validationResponse);
 
     if (Ssl::CertValidationHelper::HelperCache &&
             (validationResponse->resultCode == ::Helper::Okay || validationResponse->resultCode == ::Helper::Error)) {
         Ssl::CertValidationHelper::HelperCache->add(crtdvdData->query.c_str(), validationResponse);
     } else
         delete validationResponse;
 
     cbdataReferenceDone(crtdvdData->data);
     SSL_free(crtdvdData->ssl);
     delete crtdvdData;
 }
 
 void Ssl::CertValidationHelper::sslSubmit(Ssl::CertValidationRequest const &request, Ssl::CertValidationHelper::CVHCB * callback, void * data)
 {
-    static time_t first_warn = 0;
     assert(ssl_crt_validator);
 
-    if (ssl_crt_validator->stats.queue_size >= (int)(ssl_crt_validator->childs.n_running * 2)) {
-        if (first_warn == 0)
-            first_warn = squid_curtime;
-        if (squid_curtime - first_warn > 3 * 60)
-            fatal("ssl_crtvd queue being overloaded for long time");
-        debugs(83, DBG_IMPORTANT, "WARNING: ssl_crtvd queue overload, rejecting");
-        Ssl::CertValidationResponse resp;
-        resp.resultCode = ::Helper::BrokenHelper;
-        callback(data, resp);
-        return;
-    }
-    first_warn = 0;
-
     Ssl::CertValidationMsg message(Ssl::CrtdMessage::REQUEST);
     message.setCode(Ssl::CertValidationMsg::code_cert_validate);
     message.composeRequest(request);
     debugs(83, 5, "SSL crtvd request: " << message.compose().c_str());
 
     submitData *crtdvdData = new submitData;
     crtdvdData->query = message.compose();
     crtdvdData->query += '\n';
     crtdvdData->callback = callback;
     crtdvdData->data = cbdataReference(data);
     crtdvdData->ssl = request.ssl;
     CRYPTO_add(&crtdvdData->ssl->references,1,CRYPTO_LOCK_SSL);
     Ssl::CertValidationResponse const*validationResponse;
 
     if (CertValidationHelper::HelperCache &&
             (validationResponse = CertValidationHelper::HelperCache->get(crtdvdData->query.c_str()))) {
         callback(data, *validationResponse);
         cbdataReferenceDone(crtdvdData->data);
         SSL_free(crtdvdData->ssl);
         delete crtdvdData;
         return;
     }
-    helperSubmit(ssl_crt_validator, crtdvdData->query.c_str(), sslCrtvdHandleReplyWrapper, crtdvdData);
+
+    if (!ssl_crt_validator->trySubmit(crtdvdData->query.c_str(), sslCrtvdHandleReplyWrapper, crtdvdData)) {
+        Ssl::CertValidationResponse resp;
+        resp.resultCode = ::Helper::BrokenHelper;
+        callback(data, resp);
+
+        cbdataReferenceDone(crtdvdData->data);
+        SSL_free(crtdvdData->ssl);
+        delete crtdvdData;
+        return;
+    }
 }

