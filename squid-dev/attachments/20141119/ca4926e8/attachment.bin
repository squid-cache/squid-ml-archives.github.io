Logging fast things

In many cases HITs logged with zero response times. The logging entries are
correct, those transaction took less than a millisecond. However, to better
monitor Squid performance and to optimize things further, a user may want to
see more precise response time measurements logged.

Squid already computes response times with microsecond resolution 
(timeval::tv_usec), which would be enough for any modern measurement, but
Squid loses that precision due to tvSubMs conversion.

This patch add configurable "precision" for time-related fields such as %tr,
using a .n syntax similar to the syntax used by the well-known printf(3) API
to mean "maximum field width".

Examples:
  %tr   -- 0 -- millisecond precision (no change compared to today)
  %.3tr -- 0.123 -- microsecond precision (after this project)
  %.6tr -- 0.123456 -- nanosecond precision (year 2050 trading platform??)

This is a Measurement Factory project


=== modified file 'src/AccessLogEntry.h'
--- src/AccessLogEntry.h	2014-11-07 12:11:21 +0000
+++ src/AccessLogEntry.h	2014-11-19 15:51:09 +0000
@@ -124,58 +124,58 @@
         SslDetails();
 
         const char *user; ///< emailAddress from the SSL client certificate
         int bumpMode; ///< whether and how the request was SslBumped
     } ssl;
 #endif
 
     /** \brief This subclass holds log info for Squid internal stats
      * \todo Inner class declarations should be moved outside
      * \todo some details relevant to particular protocols need shuffling to other sub-classes
      * \todo this object field need renaming to 'squid' or something.
      */
     class CacheDetails
     {
 
     public:
         CacheDetails() : caddr(),
                 highOffset(0),
                 objectSize(0),
                 code (LOG_TAG_NONE),
-                msec(0),
                 rfc931 (NULL),
                 extuser(NULL),
 #if USE_OPENSSL
                 ssluser(NULL),
 #endif
                 port(NULL)
         {
             caddr.setNoAddr();
             memset(&start_time, 0, sizeof(start_time));
+            memset(&trTime, 0, sizeof(start_time));
         }
 
         Ip::Address caddr;
         int64_t highOffset;
         int64_t objectSize;
         LogTags code;
         struct timeval start_time; ///< The time the master transaction started
-        int msec;
+        struct timeval trTime;
         const char *rfc931;
         const char *extuser;
 #if USE_OPENSSL
 
         const char *ssluser;
         Ssl::X509_Pointer sslClientCert; ///< cert received from the client
 #endif
         AnyP::PortCfgPointer port;
 
     } cache;
 
     /** \brief This subclass holds log info for various headers in raw format
      * \todo shuffle this to the relevant protocol section.
      */
     class Headers
     {
 
     public:
         Headers() : request(NULL),
                 adapted_request(NULL),
@@ -214,68 +214,72 @@
         const char *method_str;
     } _private;
     HierarchyLogEntry hier;
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
     /// key:value pairs set by squid.conf note directive and
     /// key=value pairs returned from URL rewrite/redirect helper
     NotePairs::Pointer notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
      *  \todo Inner class declarations should be moved outside
      */
     class IcapLogEntry
     {
     public:
         IcapLogEntry() : reqMethod(Adaptation::methodNone), bytesSent(0), bytesRead(0),
                 bodyBytesRead(-1), request(NULL), reply(NULL),
-                outcome(Adaptation::Icap::xoUnknown), trTime(0),
-                ioTime(0), resStatus(Http::scNone), processingTime(0) {}
+                outcome(Adaptation::Icap::xoUnknown), resStatus(Http::scNone)
+        {
+            memset(&trTime, 0, sizeof(trTime));
+            memset(&ioTime, 0, sizeof(ioTime));
+            memset(&processingTime, 0, sizeof(processingTime));
+        }
 
         Ip::Address hostAddr; ///< ICAP server IP address
         String serviceName;        ///< ICAP service name
         String reqUri;             ///< ICAP Request-URI
         Adaptation::Icap::ICAP::Method reqMethod; ///< ICAP request method
         int64_t bytesSent;       ///< number of bytes sent to ICAP server so far
         int64_t bytesRead;       ///< number of bytes read from ICAP server so far
         /**
          * number of ICAP body bytes read from ICAP server or -1 for no encapsulated
          * message data in ICAP reply (eg 204 responses)
          */
         int64_t bodyBytesRead;
         HttpRequest* request;    ///< ICAP request
         HttpReply* reply;        ///< ICAP reply
 
         Adaptation::Icap::XactOutcome outcome; ///< final transaction status
         /** \brief Transaction response time.
          * The timer starts when the ICAP transaction
          *  is created and stops when the result of the transaction is logged
          */
-        int trTime;
+        timeval trTime;
         /** \brief Transaction I/O time.
          * The timer starts when the first ICAP request
          * byte is scheduled for sending and stops when the lastbyte of the
          * ICAP response is received.
          */
-        int ioTime;
+        timeval ioTime;
         Http::StatusCode resStatus;   ///< ICAP response status code
-        int processingTime;      ///< total ICAP processing time in milliseconds
+        timeval processingTime;      ///< total ICAP processing time
     }
     icap;
 #endif
 };
 
 class ACLChecklist;
 class StoreEntry;
 
 /* Should be in 'AccessLog.h' as the driver */
 void accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
 void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
 void accessLogRotate(void);
 void accessLogClose(void);
 void accessLogInit(void);
 const char *accessLogTime(time_t);
 
 #endif /* SQUID_HTTPACCESSLOGENTRY_H */

=== modified file 'src/HierarchyLogEntry.h'
--- src/HierarchyLogEntry.h	2014-09-22 19:06:19 +0000
+++ src/HierarchyLogEntry.h	2014-11-19 14:39:29 +0000
@@ -20,47 +20,47 @@
 class HierarchyLogEntry
 {
 
 public:
     HierarchyLogEntry();
     ~HierarchyLogEntry() { tcpServer = NULL; };
 
     /// Record details from a new server connection.
     /// call this whenever the destination server changes.
     void note(const Comm::ConnectionPointer &server, const char *requestedHost);
 
     /// Start recording total time spent communicating with peers
     void startPeerClock();
     /**
      * Record total time spent communicating with peers
      * \param force whether to overwrite old recorded value if any
      */
     void stopPeerClock(const bool force);
 
     /// Return the total time spent communicating with peers
-    int64_t totalResponseTime();
+    void totalResponseTime(timeval &responseTime);
 
 public:
     hier_code code;
     char host[SQUIDHOSTNAMELEN];
     ping_data ping;
     char cd_host[SQUIDHOSTNAMELEN];	/* the host of selected by cd peer */
     lookup_t cd_lookup;		/* cd prediction: none, miss, hit */
     int n_choices;		/* #peers we selected from (cd only) */
     int n_ichoices;		/* #peers with known rtt we selected from (cd only) */
 
     struct timeval peer_select_start;
 
     struct timeval store_complete_stop;
 
     Http::StatusCode peer_reply_status; ///< last HTTP status code received
     timeval peer_http_request_sent; ///< last peer finished writing req
-    int64_t peer_response_time; ///< last peer response delay
+    timeval peer_response_time; ///< last peer response delay
     Comm::ConnectionPointer tcpServer; ///< TCP/IP level details of the last peer/server connection
     int64_t bodyBytesRead;  ///< number of body bytes received from the next hop or -1
 
 private:
     timeval firstConnStart_; ///< first connection use among all peers
-    int64_t totalResponseTime_; ///< cumulative for all peers
+    timeval totalResponseTime_; ///< cumulative for all peers
 };
 
 #endif /* SQUID_HTTPHIERARCHYLOGENTRY_H */

=== modified file 'src/SquidTime.h'
--- src/SquidTime.h	2014-09-13 13:59:43 +0000
+++ src/SquidTime.h	2014-11-19 16:18:12 +0000
@@ -6,40 +6,52 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 21    Time Functions */
 
 #ifndef   SQUID_TIME_H
 #define   SQUID_TIME_H
 
 #include "rfc1123.h"
 
 #include <ctime>
 /* NP: sys/time.h is provided by libcompat */
 
 /* globals for accessing time */
 extern struct timeval current_time;
 extern double current_dtime;
 extern time_t squid_curtime;
 
 time_t getCurrentTime(void);
 int tvSubMsec(struct timeval, struct timeval);
+///timeval substraction operation (res = t2 - t1)
+void tvSub(struct timeval const &t1, struct timeval const &t2, struct timeval &res);
+///timeval addition operation (res = t1 + t2)
+void tvAdd(struct timeval const &t1, struct timeval const &t2, struct timeval &res);
+/// timeval addition assignment operation (t += add;)
+void tvAssignAdd(struct timeval &t, struct timeval const &add);
+
+/// Convert timeval to miliseconds
+inline long int tvToMsec(struct timeval &t)
+{
+    return t.tv_sec * 1000 + t.tv_usec / 1000;
+}
 
 /** event class for doing synthetic time etc */
 class TimeEngine
 {
 
 public:
     virtual ~TimeEngine();
 
     /** tick the clock - update from the OS or other time source, */
     virtual void tick();
 };
 
 namespace Time
 {
 
 /** Display time as a formatted human-readable string.
  * Time syntax is
  * "YYYY/MM/DD hh:mm:ss"
  *
  * Output is only valid until next call to this function.

=== modified file 'src/adaptation/icap/History.cc'
--- src/adaptation/icap/History.cc	2014-09-29 07:18:13 +0000
+++ src/adaptation/icap/History.cc	2014-11-19 16:14:03 +0000
@@ -1,59 +1,66 @@
 /*
  * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "adaptation/icap/History.h"
 #include "Debug.h"
 #include "globals.h"
 #include "SquidTime.h"
 
 Adaptation::Icap::History::History():
         logType(LOG_TAG_NONE),
         req_sz(0),
-        pastTime(0),
         concurrencyLevel(0)
 {
     memset(&currentStart, 0, sizeof(currentStart));
+    memset(&pastTime, 0, sizeof(pastTime));
 }
 
 void Adaptation::Icap::History::start(const char *context)
 {
     if (!concurrencyLevel++)
         currentStart = current_time;
 
     debugs(93,4, HERE << "start " << context << " level=" << concurrencyLevel
-           << " time=" << pastTime << ' ' << this);
+           << " time=" << tvToMsec(pastTime) << ' ' << this);
 }
 
 void Adaptation::Icap::History::stop(const char *context)
 {
     if (!concurrencyLevel) {
         debugs(93, DBG_IMPORTANT, HERE << "Internal error: poor history accounting " << this);
         return;
     }
 
-    const int current = currentTime();
+    timeval current;
+    currentTime(current);
     debugs(93,4, HERE << "stop " << context << " level=" << concurrencyLevel <<
-           " time=" << pastTime << '+' << current << ' ' << this);
+           " time=" << tvToMsec(pastTime) << '+' << tvToMsec(current) << ' ' << this);
 
     if (!--concurrencyLevel)
-        pastTime += current;
+        tvAssignAdd(pastTime, current);
 }
 
-int Adaptation::Icap::History::processingTime() const
+void
+Adaptation::Icap::History::processingTime(timeval &total) const
 {
-    const int total = pastTime + currentTime();
-    debugs(93,7, HERE << " current total: " << total << ' ' << this);
-    return total;
+    currentTime(total);
+    tvAssignAdd(total, pastTime);
+    debugs(93,7, HERE << " current total: " << (total.tv_sec * 1000 + total.tv_usec / 1000) << ' ' << this);
 }
 
-int Adaptation::Icap::History::currentTime() const
+void
+Adaptation::Icap::History::currentTime(timeval &current) const
 {
-    return concurrencyLevel > 0 ?
-           max(0, tvSubMsec(currentStart, current_time)) : 0;
+    if (concurrencyLevel > 0)
+        tvSub(currentStart, current_time, current);
+    else {
+        current.tv_sec = 0;
+        current.tv_usec = 0;
+    }
 }

=== modified file 'src/adaptation/icap/History.h'
--- src/adaptation/icap/History.h	2014-09-13 13:59:43 +0000
+++ src/adaptation/icap/History.h	2014-11-19 15:11:29 +0000
@@ -16,43 +16,43 @@
 
 namespace Adaptation
 {
 namespace Icap
 {
 
 /// collects information about ICAP processing related to an HTTP transaction
 class History: public RefCountable
 {
 public:
     typedef RefCount<History> Pointer;
 
     History();
 
     /// record the start of an ICAP processing interval
     void start(const char *context);
     /// note the end of an ICAP processing interval
     void stop(const char *context);
 
     /// returns the total time of all ICAP processing intervals
-    int processingTime() const;
+    void processingTime(timeval &) const;
 
     String rfc931; ///< the username from ident
 #if USE_OPENSSL
     String ssluser; ///< the username from SSL
 #endif
     LogTags logType; ///< the squid request status (TCP_MISS etc)
 
     String log_uri; ///< the request uri
     size_t req_sz; ///< the request size
 
 private:
-    int currentTime() const; ///< time since current start or zero
+    void currentTime(timeval &) const; ///< time since current start or zero
 
     timeval currentStart; ///< when the current processing interval started
-    int pastTime;         ///< sum of closed processing interval durations
+    timeval pastTime;         ///< sum of closed processing interval durations
     int concurrencyLevel; ///< number of concurrent processing threads
 };
 
 } // namespace Icap
 } // namespace Adaptation
 
 #endif /*SQUID_HISTORY_H*/

=== modified file 'src/adaptation/icap/Xaction.cc'
--- src/adaptation/icap/Xaction.cc	2014-10-05 10:46:34 +0000
+++ src/adaptation/icap/Xaction.cc	2014-11-19 16:12:33 +0000
@@ -558,42 +558,42 @@
 }
 
 void Adaptation::Icap::Xaction::maybeLog()
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
         finalizeLogInfo();
         icapLogLog(alep);
     }
 }
 
 void Adaptation::Icap::Xaction::finalizeLogInfo()
 {
     //prepare log data
     al.icp.opcode = ICP_INVALID;
 
     const Adaptation::Icap::ServiceRep &s = service();
     al.icap.hostAddr = s.cfg().host.termedBuf();
     al.icap.serviceName = s.cfg().key;
     al.icap.reqUri = s.cfg().uri;
 
-    al.icap.ioTime = tvSubMsec(icap_tio_start, icap_tio_finish);
-    al.icap.trTime = tvSubMsec(icap_tr_start, current_time);
+    tvSub(icap_tio_start, icap_tio_finish, al.icap.ioTime);
+    tvSub(icap_tr_start, current_time, al.icap.trTime);
 
     al.icap.request = icapRequest;
     HTTPMSGLOCK(al.icap.request);
     if (icapReply != NULL) {
         al.icap.reply = icapReply.getRaw();
         HTTPMSGLOCK(al.icap.reply);
         al.icap.resStatus = icapReply->sline.status();
     }
 }
 
 // returns a temporary string depicting transaction status, for debugging
 const char *Adaptation::Icap::Xaction::status() const
 {
     static MemBuf buf;
     buf.reset();
 
     buf.append(" [", 2);
 
     fillPendingStatus(buf);
     buf.append("/", 1);

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2014-11-10 11:45:36 +0000
+++ src/client_side.cc	2014-11-19 15:38:30 +0000
@@ -534,41 +534,41 @@
         }
 
 #if USE_ADAPTATION
         const Adaptation::History::Pointer ah = request->adaptLogHistory();
         if (ah != NULL) {
             packerClean(&p);
             mb.reset();
             packerToMemInit(&p, &mb);
             ah->lastMeta.packInto(&p);
             aLogEntry->adapt.last_meta = xstrdup(mb.buf);
         }
 #endif
 
         packerClean(&p);
         mb.clean();
     }
 
 #if ICAP_CLIENT
     const Adaptation::Icap::History::Pointer ih = request->icapHistory();
     if (ih != NULL)
-        aLogEntry->icap.processingTime = ih->processingTime();
+        ih->processingTime(aLogEntry->icap.processingTime);
 #endif
 
     aLogEntry->http.method = request->method;
     aLogEntry->http.version = request->http_ver;
     aLogEntry->hier = request->hier;
     if (request->content_length > 0) // negative when no body or unknown length
         aLogEntry->http.clientRequestSz.payloadData += request->content_length; // XXX: actually adaptedRequest payload size ??
     aLogEntry->cache.extuser = request->extacl_user.termedBuf();
 
     // Adapted request, if any, inherits and then collects all the stats, but
     // the virgin request gets logged instead; copy the stats to log them.
     // TODO: avoid losses by keeping these stats in a shared history object?
     if (aLogEntry->request) {
         aLogEntry->request->dnsWait = request->dnsWait;
         aLogEntry->request->errType = request->errType;
         aLogEntry->request->errDetail = request->errDetail;
     }
 }
 
 void
@@ -586,41 +586,41 @@
         al->http.content_type = al->reply->content_type.termedBuf();
     } else if (loggingEntry() && loggingEntry()->mem_obj) {
         al->http.code = loggingEntry()->mem_obj->getReply()->sline.status();
         al->http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
     }
 
     debugs(33, 9, "clientLogRequest: http.code='" << al->http.code << "'");
 
     if (loggingEntry() && loggingEntry()->mem_obj && loggingEntry()->objectLen() >= 0)
         al->cache.objectSize = loggingEntry()->contentLen(); // payload duplicate ?? with or without TE ?
 
     al->http.clientRequestSz.header = req_sz;
     al->http.clientReplySz.header = out.headers_sz;
     // XXX: calculate without payload encoding or headers !!
     al->http.clientReplySz.payloadData = out.size - out.headers_sz; // pretend its all un-encoded data for now.
 
     al->cache.highOffset = out.offset;
 
     al->cache.code = logType;
 
-    al->cache.msec = tvSubMsec(al->cache.start_time, current_time);
+    tvSub(al->cache.start_time, current_time, al->cache.trTime);
 
     if (request)
         prepareLogWithRequestDetails(request, al);
 
     if (getConn() != NULL && getConn()->clientConnection != NULL && getConn()->clientConnection->rfc931[0])
         al->cache.rfc931 = getConn()->clientConnection->rfc931;
 
 #if USE_OPENSSL && 0
 
     /* This is broken. Fails if the connection has been closed. Needs
      * to snarf the ssl details some place earlier..
      */
     if (getConn() != NULL)
         al->cache.ssluser = sslGetUserEmail(fd_table[getConn()->fd].ssl);
 
 #endif
 
     /*Add notes*/
     // The al->notes and request->notes must point to the same object.
     (void)SyncNotes(*al, *request);

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2014-09-13 13:59:43 +0000
+++ src/format/Format.cc	2014-11-19 17:57:34 +0000
@@ -306,40 +306,43 @@
         }
     }
 
     *p = '\0';
 }
 
 void
 Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logSequenceNumber) const
 {
     char tmp[1024];
     String sb;
 
     for (Token *fmt = format; fmt != NULL; fmt = fmt->next) {	/* for each token */
         const char *out = NULL;
         int quote = 0;
         long int outint = 0;
         int doint = 0;
         int dofree = 0;
         int64_t outoff = 0;
         int dooff = 0;
+        struct timeval outtv = {0, 0};
+        int doMsec = 0;
+        int doSec = 0;
 
         switch (fmt->type) {
 
         case LFT_NONE:
             out = "";
             break;
 
         case LFT_STRING:
             out = fmt->data.string;
             break;
 
         case LFT_CLIENT_IP_ADDRESS:
             al->getLogClientIp(tmp, sizeof(tmp));
             out = tmp;
             break;
 
         case LFT_CLIENT_FQDN:
             if (al->cache.caddr.isAnyAddr()) // e.g., ICAP OPTIONS lack client
                 out = "-";
             else
@@ -487,76 +490,78 @@
             spec = fmt->data.string;
 
             if (fmt->type == LFT_TIME_LOCALTIME) {
                 if (!spec)
                     spec = "%d/%b/%Y:%H:%M:%S %z";
                 t = localtime(&squid_curtime);
             } else {
                 if (!spec)
                     spec = "%d/%b/%Y:%H:%M:%S";
 
                 t = gmtime(&squid_curtime);
             }
 
             strftime(tmp, sizeof(tmp), spec, t);
 
             out = tmp;
         }
 
         break;
 
-        case LFT_TIME_START: {
-            int precision = fmt->widthMax >=0 ? fmt->widthMax :3;
-            snprintf(tmp, sizeof(tmp), "%0*" PRId64 ".%0*d", fmt->zero && (fmt->widthMin - precision - 1 >= 0) ? fmt->widthMin - precision - 1 : 0, static_cast<int64_t>(al->cache.start_time.tv_sec), precision, (int)(al->cache.start_time.tv_usec / fmt->divisor));
-            out = tmp;
-        }
+        case LFT_TIME_START:
+            outtv = al->cache.start_time;
+            doSec = 1;
         break;
 
         case LFT_TIME_TO_HANDLE_REQUEST:
-            outint = al->cache.msec;
-            doint = 1;
+            outtv = al->cache.trTime;
+            doMsec = 1;
             break;
 
         case LFT_PEER_RESPONSE_TIME:
-            if (al->hier.peer_response_time < 0) {
+            if (al->hier.peer_response_time.tv_sec ==  -1) {
                 out = "-";
             } else {
-                outoff = al->hier.peer_response_time;
-                dooff = 1;
+                outtv = al->hier.peer_response_time;
+                doMsec = 1;
             }
             break;
 
         case LFT_TOTAL_SERVER_SIDE_RESPONSE_TIME: {
-            const int64_t total_response_time = al->hier.totalResponseTime();
-            if (total_response_time < 0) {
+            timeval total_response_time;
+            al->hier.totalResponseTime(total_response_time);
+            if (total_response_time.tv_sec == -1) {
                 out = "-";
             } else {
-                outoff = total_response_time;
-                dooff = 1;
+                outtv = total_response_time;
+                doMsec = 1;
             }
         }
         break;
 
         case LFT_DNS_WAIT_TIME:
             if (al->request && al->request->dnsWait >= 0) {
-                outint = al->request->dnsWait;
-                doint = 1;
+                // TODO: microsecond precision for dns wait time.
+                // Convert miliseconds to timeval struct:
+                outtv.tv_sec = al->request->dnsWait / 1000;
+                outtv.tv_usec = (al->request->dnsWait % 1000) * 1000;
+                doMsec = 1;
             }
             break;
 
         case LFT_REQUEST_HEADER:
 
             if (al->request)
                 sb = al->request->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_ADAPTED_REQUEST_HEADER:
 
             if (al->adapted_request)
                 sb = al->adapted_request->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
@@ -714,61 +719,61 @@
 
             quote = 1;
 
             break;
 
         case LFT_ICAP_REP_ALL_HEADERS:
             if (al->icap.reply) {
                 HttpHeaderPos pos = HttpHeaderInitPos;
                 while (const HttpHeaderEntry *e = al->icap.reply->header.getEntry(&pos)) {
                     sb.append(e->name);
                     sb.append(": ");
                     sb.append(e->value);
                     sb.append("\r\n");
                 }
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_ICAP_TR_RESPONSE_TIME:
-            outint = al->icap.trTime;
-            doint = 1;
+            outtv = al->icap.trTime;
+            doMsec = 1;
             break;
 
         case LFT_ICAP_IO_TIME:
-            outint = al->icap.ioTime;
-            doint = 1;
+            outtv = al->icap.ioTime;
+            doMsec = 1;
             break;
 
         case LFT_ICAP_STATUS_CODE:
             outint = al->icap.resStatus;
             doint  = 1;
             break;
 
         case LFT_ICAP_OUTCOME:
             out = al->icap.outcome;
             break;
 
         case LFT_ICAP_TOTAL_TIME:
-            outint = al->icap.processingTime;
-            doint = 1;
+            outtv = al->icap.processingTime;
+            doMsec = 1;
             break;
 #endif
         case LFT_REQUEST_HEADER_ELEM:
             if (al->request)
                 sb = al->request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_ADAPTED_REQUEST_HEADER_ELEM:
             if (al->adapted_request)
                 sb = al->adapted_request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
 
@@ -1217,40 +1222,52 @@
             // every ByteCode_t to be explicitly enumerated.
             // But do not output due to lack of access to the values.
         case LFT_EXT_ACL_USER_CERT_RAW:
         case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
         case LFT_EXT_ACL_USER_CERT:
         case LFT_EXT_ACL_USER_CA_CERT:
         case LFT_EXT_ACL_CLIENT_EUI48:
         case LFT_EXT_ACL_CLIENT_EUI64:
         case LFT_EXT_ACL_NAME:
         case LFT_EXT_ACL_DATA:
             break;
         }
 
         if (dooff) {
             snprintf(tmp, sizeof(tmp), "%0*" PRId64, fmt->zero && fmt->widthMin >= 0 ? fmt->widthMin : 0, outoff);
             out = tmp;
 
         } else if (doint) {
             snprintf(tmp, sizeof(tmp), "%0*ld", fmt->zero && fmt->widthMin >= 0 ? fmt->widthMin : 0, outint);
             out = tmp;
+        } else if (doMsec) {
+            if (fmt->widthMax < 0) {
+                snprintf(tmp, sizeof(tmp), "%0*ld", fmt->widthMin , tvToMsec(outtv));
+            } else {
+                int precision = fmt->widthMax;
+                snprintf(tmp, sizeof(tmp), "%0*" PRId64 ".%0*" PRId64 "", fmt->zero && (fmt->widthMin - precision - 1 >= 0) ? fmt->widthMin - precision - 1 : 0, static_cast<int64_t>(outtv.tv_sec * 1000 + outtv.tv_usec / 1000), precision, static_cast<int64_t>((outtv.tv_usec % 1000 )* (1000 / fmt->divisor)));
+            }
+            out = tmp;
+        } else if (doSec) {
+            int precision = fmt->widthMax >=0 ? fmt->widthMax :3;
+            snprintf(tmp, sizeof(tmp), "%0*" PRId64 ".%0*d", fmt->zero && (fmt->widthMin - precision - 1 >= 0) ? fmt->widthMin - precision - 1 : 0, static_cast<int64_t>(outtv.tv_sec), precision, (int)(outtv.tv_usec / fmt->divisor));
+            out = tmp;
         }
 
         if (out && *out) {
             if (quote || fmt->quote != LOG_QUOTE_NONE) {
                 char *newout = NULL;
                 int newfree = 0;
 
                 switch (fmt->quote) {
 
                 case LOG_QUOTE_NONE:
                     newout = rfc1738_escape_unescaped(out);
                     break;
 
                 case LOG_QUOTE_QUOTES: {
                     size_t out_len = static_cast<size_t>(strlen(out)) * 2 + 1;
                     if (out_len >= sizeof(tmp)) {
                         newout = (char *)xmalloc(out_len);
                         newfree = 1;
                     } else
                         newout = tmp;
@@ -1265,41 +1282,41 @@
 
                 case LOG_QUOTE_URL:
                     newout = rfc1738_escape(out);
                     break;
 
                 case LOG_QUOTE_RAW:
                     break;
                 }
 
                 if (newout) {
                     if (dofree)
                         safe_free(out);
 
                     out = newout;
 
                     dofree = newfree;
                 }
             }
 
             // enforce width limits if configured
-            const bool haveMaxWidth = fmt->widthMax >=0 && !doint && !dooff && !fmt->divisor;
+            const bool haveMaxWidth = fmt->widthMax >=0 && !doint && !dooff && !doMsec && !doSec;
             if (haveMaxWidth || fmt->widthMin) {
                 const int minWidth = fmt->widthMin >= 0 ?
                                      fmt->widthMin :0;
                 const int maxWidth = haveMaxWidth ?
                                      fmt->widthMax : strlen(out);
 
                 if (fmt->left)
                     mb.Printf("%-*.*s", minWidth, maxWidth, out);
                 else
                     mb.Printf("%*.*s", minWidth, maxWidth, out);
             } else
                 mb.append(out, strlen(out));
         } else {
             mb.append("-", 1);
         }
 
         if (fmt->space)
             mb.append(" ", 1);
 
         sb.clean();

=== modified file 'src/format/Token.cc'
--- src/format/Token.cc	2014-09-13 13:59:43 +0000
+++ src/format/Token.cc	2014-11-19 16:47:41 +0000
@@ -490,40 +490,47 @@
 #if ICAP_CLIENT
             case LFT_ICAP_REQ_HEADER:
                 type = LFT_ICAP_REQ_ALL_HEADERS;
                 break;
             case LFT_ICAP_REP_HEADER:
                 type = LFT_ICAP_REP_ALL_HEADERS;
                 break;
 #endif
             default:
                 break;
             }
             Config.onoff.log_mime_hdrs = 1;
         }
 
         break;
 
     case LFT_CLIENT_FQDN:
         Config.onoff.log_fqdn = 1;
         break;
 
+    case LFT_TIME_TO_HANDLE_REQUEST:
+    case LFT_PEER_RESPONSE_TIME:
+    case LFT_TOTAL_SERVER_SIDE_RESPONSE_TIME:
+    case LFT_DNS_WAIT_TIME:
+    case LFT_ICAP_TR_RESPONSE_TIME:
+    case LFT_ICAP_IO_TIME:
+    case LFT_ICAP_TOTAL_TIME:
     case LFT_TIME_START:
     case LFT_TIME_SUBSECOND:
         divisor = 1000;
 
         if (widthMax > 0) {
             divisor = 1000000;
 
             for (int i = widthMax; i > 0; --i)
                 divisor /= 10;
 
             if (!divisor)
                 divisor = 1;
         }
         break;
 
     case LFT_HTTP_SENT_STATUS_CODE_OLD_30:
         debugs(46, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: The \"Hs\" formatting code is deprecated. Use the \">Hs\" instead.");
         type = LFT_HTTP_SENT_STATUS_CODE;
         break;
 

=== modified file 'src/htcp.cc'
--- src/htcp.cc	2014-11-05 10:18:15 +0000
+++ src/htcp.cc	2014-11-19 12:15:16 +0000
@@ -1691,23 +1691,24 @@
     htcpSocketShutdown();
 
     if (htcpOutgoingConn != NULL) {
         debugs(12, DBG_IMPORTANT, "Stop sending HTCP from " << htcpOutgoingConn->local);
         htcpOutgoingConn = NULL;
     }
 }
 
 static void
 htcpLogHtcp(Ip::Address &caddr, int opcode, LogTags logcode, const char *url)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry;
     if (LOG_TAG_NONE == logcode)
         return;
     if (!Config.onoff.log_udp)
         return;
     al->htcp.opcode = htcpOpcodeStr[opcode];
     al->url = url;
     al->cache.caddr = caddr;
     al->cache.code = logcode;
-    al->cache.msec = 0;
+    al->cache.trTime.tv_sec = 0;
+    al->cache.trTime.tv_usec = 0;
     accessLogLog(al, NULL);
 }

=== modified file 'src/http.cc'
--- src/http.cc	2014-11-10 11:45:36 +0000
+++ src/http.cc	2014-11-19 11:54:41 +0000
@@ -1143,42 +1143,44 @@
     // update I/O stats
     if (len > 0) {
         readBuf->appended(len);
         reply_bytes_read += len;
 #if USE_DELAY_POOLS
         DelayId delayId = entry->mem_obj->mostBytesAllowed();
         delayId.bytesIn(len);
 #endif
 
         kb_incr(&(statCounter.server.all.kbytes_in), len);
         kb_incr(&(statCounter.server.http.kbytes_in), len);
         ++ IOStats.Http.reads;
 
         for (clen = len - 1, bin = 0; clen; ++bin)
             clen >>= 1;
 
         ++ IOStats.Http.read_hist[bin];
 
         // update peer response time stats (%<pt)
         const timeval &sent = request->hier.peer_http_request_sent;
-        request->hier.peer_response_time =
-            sent.tv_sec ? tvSubMsec(sent, current_time) : -1;
+        if (sent.tv_sec)
+            tvSub(sent, current_time, request->hier.peer_response_time);
+        else
+            request->hier.peer_response_time.tv_sec = -1;
     }
 
     /** \par
      * Here the RFC says we should ignore whitespace between replies, but we can't as
      * doing so breaks HTTP/0.9 replies beginning with witespace, and in addition
      * the response splitting countermeasures is extremely likely to trigger on this,
      * not allowing connection reuse in the first place.
      *
      * 2012-02-10: which RFC? not 2068 or 2616,
      *     tolerance there is all about whitespace between requests and header tokens.
      */
 
     if (len == 0) { // reached EOF?
         eof = 1;
         flags.do_next_read = false;
 
         /* Bug 2879: Replies may terminate with \r\n then EOF instead of \r\n\r\n
          * Ensure here that we have at minimum two \r\n when EOF is seen.
          * TODO: Add eof parameter to headersEnd() and move this hack there.
          */

=== modified file 'src/icp_v2.cc'
--- src/icp_v2.cc	2014-09-13 13:59:43 +0000
+++ src/icp_v2.cc	2014-11-19 10:27:56 +0000
@@ -186,41 +186,41 @@
 
     if (LOG_ICP_QUERY == logcode)
         return;
 
     clientdbUpdate(caddr, logcode, AnyP::PROTO_ICP, len);
 
     if (!Config.onoff.log_udp)
         return;
 
     al->icp.opcode = ICP_QUERY;
 
     al->url = url;
 
     al->cache.caddr = caddr;
 
     // XXX: move to use icp.clientReply instead
     al->http.clientReplySz.payloadData = len;
 
     al->cache.code = logcode;
 
-    al->cache.msec = delay;
+    al->cache.trTime.tv_sec = delay;
 
     accessLogLog(al, NULL);
 }
 
 /// \ingroup ServerProtocolICPInternal2
 void
 icpUdpSendQueue(int fd, void *unused)
 {
     icpUdpData *q;
 
     while ((q = IcpQueueHead) != NULL) {
         int delay = tvSubUsec(q->queue_time, current_time);
         /* increment delay to prevent looping */
         const int x = icpUdpSend(fd, q->address, (icp_common_t *) q->msg, q->logcode, ++delay);
         IcpQueueHead = q->next;
         xfree(q);
 
         if (x < 0)
             break;
     }

=== modified file 'src/log/FormatSquidIcap.cc'
--- src/log/FormatSquidIcap.cc	2014-09-13 13:59:43 +0000
+++ src/log/FormatSquidIcap.cc	2014-11-19 16:21:41 +0000
@@ -39,35 +39,35 @@
 
 #if USE_AUTH
     if (al->request != NULL && al->request->auth_user_request != NULL)
         user = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
 #endif
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.extuser);
 
 #if USE_OPENSSL
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.ssluser);
 #endif
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
 
     if (user && !*user)
         safe_free(user);
 
-    logfilePrintf(logfile, "%9ld.%03d %6d %s %s/%03d %" PRId64 " %s %s %s -/%s -\n",
+    logfilePrintf(logfile, "%9ld.%03d %6ld %s %s/%03d %" PRId64 " %s %s %s -/%s -\n",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
-                  al->icap.trTime,
+                  tvToMsec(al->icap.trTime),
                   client,
                   al->icap.outcome,
                   al->icap.resStatus,
                   al->icap.bytesRead,
                   Adaptation::Icap::ICAP::methodStr(al->icap.reqMethod),
                   al->icap.reqUri.termedBuf(),
                   user ? user : "-",
                   al->icap.hostAddr.toStr(tmp, MAX_IPSTRLEN));
     safe_free(user);
 }
 #endif

=== modified file 'src/log/FormatSquidNative.cc'
--- src/log/FormatSquidNative.cc	2014-09-13 13:59:43 +0000
+++ src/log/FormatSquidNative.cc	2014-11-19 16:25:41 +0000
@@ -37,44 +37,44 @@
 #if USE_OPENSSL
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.ssluser);
 #endif
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
 
     if (user && !*user)
         safe_free(user);
 
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
     static SBuf method;
     if (al->_private.method_str)
         method.assign(al->_private.method_str);
     else
         method = al->http.method.image();
 
-    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " " SQUIDSBUFPH " %s %s %s%s/%s %s%s",
+    logfilePrintf(logfile, "%9ld.%03d %6ld %s %s%s/%03d %" PRId64 " " SQUIDSBUFPH " %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
-                  al->cache.msec,
+                  tvToMsec(al->cache.trTime),
                   clientip,
                   LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   al->http.code,
                   al->http.clientReplySz.messageTotal(),
                   SQUIDSBUFPRINT(method),
                   al->url,
                   user ? user : dash_str,
                   al->hier.ping.timedout ? "TIMEOUT_" : "",
                   hier_code_str[al->hier.code],
                   al->hier.tcpServer != NULL ? al->hier.tcpServer->remote.toStr(hierHost, sizeof(hierHost)) : "-",
                   al->http.content_type,
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
     safe_free(user);
 
     if (Config.onoff.log_mime_hdrs) {
         char *ereq = ::Format::QuoteMimeBlob(al->headers.request);
         char *erep = ::Format::QuoteMimeBlob(al->headers.reply);
         logfilePrintf(logfile, " [%s] [%s]\n", ereq, erep);

=== modified file 'src/log/access_log.cc'
--- src/log/access_log.cc	2014-09-13 13:59:43 +0000
+++ src/log/access_log.cc	2014-11-19 15:42:52 +0000
@@ -215,110 +215,115 @@
             logfileClose(log->logfile);
             log->logfile = NULL;
         }
     }
 
 #if HEADERS_LOG
 
     logfileClose(headerslog);
 
     headerslog = NULL;
 
 #endif
 }
 
 HierarchyLogEntry::HierarchyLogEntry() :
         code(HIER_NONE),
         cd_lookup(LOOKUP_NONE),
         n_choices(0),
         n_ichoices(0),
         peer_reply_status(Http::scNone),
-        peer_response_time(-1),
         tcpServer(NULL),
-        bodyBytesRead(-1),
-        totalResponseTime_(-1)
+        bodyBytesRead(-1)
 {
     memset(host, '\0', SQUIDHOSTNAMELEN);
     memset(cd_host, '\0', SQUIDHOSTNAMELEN);
 
     peer_select_start.tv_sec =0;
     peer_select_start.tv_usec =0;
 
     store_complete_stop.tv_sec =0;
     store_complete_stop.tv_usec =0;
 
     peer_http_request_sent.tv_sec = 0;
     peer_http_request_sent.tv_usec = 0;
 
+    peer_response_time.tv_sec = -1;
+    peer_response_time.tv_usec = 0;
+
+    totalResponseTime_.tv_sec = -1;
+    totalResponseTime_.tv_usec = 0;
+
     firstConnStart_.tv_sec = 0;
     firstConnStart_.tv_usec = 0;
 }
 
 void
 HierarchyLogEntry::note(const Comm::ConnectionPointer &server, const char *requestedHost)
 {
     tcpServer = server;
     if (tcpServer == NULL) {
         code = HIER_NONE;
         xstrncpy(host, requestedHost, sizeof(host));
     } else {
         code = tcpServer->peerType;
 
         if (tcpServer->getPeer()) {
             // went to peer, log peer host name
             xstrncpy(host, tcpServer->getPeer()->name, sizeof(host));
         } else {
             xstrncpy(host, requestedHost, sizeof(host));
         }
     }
 }
 
 void
 HierarchyLogEntry::startPeerClock()
 {
     if (!firstConnStart_.tv_sec)
         firstConnStart_ = current_time;
 }
 
 void
 HierarchyLogEntry::stopPeerClock(const bool force)
 {
     debugs(46, 5, "First connection started: " << firstConnStart_.tv_sec << "." <<
            std::setfill('0') << std::setw(6) << firstConnStart_.tv_usec <<
-           ", current total response time value: " << totalResponseTime_ <<
+           ", current total response time value: " << (totalResponseTime_.tv_sec * 1000 +  totalResponseTime_.tv_usec/1000) <<
            (force ? ", force fixing" : ""));
-    if (!force && totalResponseTime_ >= 0)
+    if (!force && totalResponseTime_.tv_sec != -1)
         return;
 
-    totalResponseTime_ = firstConnStart_.tv_sec ? tvSubMsec(firstConnStart_, current_time) : -1;
+    if (firstConnStart_.tv_sec)
+        tvSub(firstConnStart_, current_time, totalResponseTime_);
 }
 
-int64_t
-HierarchyLogEntry::totalResponseTime()
+void
+HierarchyLogEntry::totalResponseTime(timeval &responseTime)
 {
     // This should not really happen, but there may be rare code
     // paths that lead to FwdState discarded (or transaction logged)
     // without (or before) a stopPeerClock() call.
-    if (firstConnStart_.tv_sec && totalResponseTime_ < 0)
+    if (firstConnStart_.tv_sec && totalResponseTime_.tv_sec == -1)
         stopPeerClock(false);
 
-    return totalResponseTime_;
+    responseTime = totalResponseTime_;
 }
 
 static void
 accessLogRegisterWithCacheManager(void)
 {
 #if USE_FORW_VIA_DB
     fvdbRegisterWithCacheManager();
 #endif
 }
 
 void
 accessLogInit(void)
 {
     CustomLog *log;
 
     accessLogRegisterWithCacheManager();
 
 #if USE_ADAPTATION
     Log::TheConfig.hasAdaptToken = false;
 #endif

=== modified file 'src/neighbors.cc'
--- src/neighbors.cc	2014-09-13 13:59:43 +0000
+++ src/neighbors.cc	2014-11-19 16:26:34 +0000
@@ -653,41 +653,41 @@
                 debugs(15, DBG_CRITICAL, "ICP is disabled! Cannot send ICP request to peer.");
                 continue;
             } else {
 
                 if (p->type == PEER_MULTICAST)
                     mcastSetTtl(icpOutgoingConn->fd, p->mcast.ttl);
 
                 if (p->icp.port == echo_port) {
                     debugs(15, 4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping");
                     query = _icp_common_t::createMessage(ICP_DECHO, 0, url, reqnum, 0);
                     icpUdpSend(icpOutgoingConn->fd, p->in_addr, query, LOG_ICP_QUERY, 0);
                 } else {
                     flags = 0;
 
                     if (Config.onoff.query_icmp)
                         if (p->icp.version == ICP_VERSION_2)
                             flags |= ICP_FLAG_SRC_RTT;
 
                     query = _icp_common_t::createMessage(ICP_QUERY, flags, url, reqnum, 0);
 
-                    icpUdpSend(icpOutgoingConn->fd, p->in_addr, query, LOG_ICP_QUERY, 0);
+                    icpUdpSend(icpOutgoingConn->fd, p->in_addr, query, LOG_ICP_QUERY, 0.0);
                 }
             }
         }
 
         ++queries_sent;
 
         ++ p->stats.pings_sent;
 
         if (p->type == PEER_MULTICAST) {
             mcast_exprep += p->mcast.n_replies_expected;
             mcast_timeout += (p->stats.rtt * p->mcast.n_replies_expected);
         } else if (neighborUp(p)) {
             /* its alive, expect a reply from it */
 
             if (neighborType(p, request) == PEER_PARENT) {
                 ++parent_exprep;
                 parent_timeout += p->stats.rtt;
             } else {
                 ++sibling_exprep;
                 sibling_timeout += p->stats.rtt;

=== modified file 'src/time.cc'
--- src/time.cc	2014-09-13 13:59:43 +0000
+++ src/time.cc	2014-11-19 15:23:20 +0000
@@ -20,40 +20,72 @@
 {
 #if GETTIMEOFDAY_NO_TZP
     gettimeofday(&current_time);
 #else
 
     gettimeofday(&current_time, NULL);
 #endif
 
     current_dtime = (double) current_time.tv_sec +
                     (double) current_time.tv_usec / 1000000.0;
     return squid_curtime = current_time.tv_sec;
 }
 
 int
 tvSubMsec(struct timeval t1, struct timeval t2)
 {
     return (t2.tv_sec - t1.tv_sec) * 1000 +
            (t2.tv_usec - t1.tv_usec) / 1000;
 }
 
+void
+tvSub(struct timeval const &t1, struct timeval const &t2, struct timeval &res)
+{
+    res.tv_sec = t2.tv_sec - t1.tv_sec;
+    if (t2.tv_usec >= t1.tv_usec)
+        res.tv_usec = t2.tv_usec - t1.tv_usec;
+    else {
+        res.tv_sec -= 1;
+        res.tv_usec = t2.tv_usec + 1000000 - t1.tv_usec;
+    }
+}
+
+void tvAdd(struct timeval const &t1, struct timeval const &t2, struct timeval &res)
+{
+    res.tv_sec = t1.tv_sec + t2.tv_sec;
+    res.tv_usec = t1.tv_usec + t2.tv_usec;
+    if (res.tv_usec >= 1000000) {
+        ++res.tv_sec;
+        res.tv_usec -= 1000000;
+    }
+}
+
+void tvAssignAdd(struct timeval &t, struct timeval const &add)
+{
+    t.tv_sec += add.tv_sec;
+    t.tv_usec += add.tv_usec;
+    if (t.tv_usec >= 1000000) {
+        ++t.tv_sec;
+        t.tv_usec -= 1000000;
+    }
+}
+
 TimeEngine::~TimeEngine()
 {}
 
 void
 TimeEngine::tick()
 {
     getCurrentTime();
 }
 
 const char *
 Time::FormatStrf(time_t t)
 {
     struct tm *tm;
     static char buf[128];
     static time_t last_t = 0;
 
     if (t != last_t) {
         tm = localtime(&t);
         strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
         last_t = t;

