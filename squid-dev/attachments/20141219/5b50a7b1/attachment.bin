=== modified file 'src/ssl/PeerConnector.cc'
--- src/ssl/PeerConnector.cc	2014-12-19 17:54:32 +0000
+++ src/ssl/PeerConnector.cc	2014-12-19 18:06:18 +0000
@@ -524,42 +524,48 @@
         return;
 
     case SSL_ERROR_WANT_WRITE:
         if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
             debugs(81, DBG_IMPORTANT, "hold write on SSL connection on FD " << fd);
             checkForPeekAndSplice();
             return;
         }
         Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
         return;
 
     case SSL_ERROR_SSL:
     case SSL_ERROR_SYSCALL:
         ssl_lib_error = ERR_get_error();
 
         // If we are in peek-and-splice mode and still we did not write to
         // server yet, try to see if we should splice.
         // In this case the connection can be saved.
         // If the checklist decision is do not splice a new error will
         // occure in the next SSL_connect call, and we will fail again.
+        // Abort on certificate validation errors to avoid splicing and
+        // thus hiding them.
+        // Abort if no certificate found probably because of malformed or
+        // unsupported server Hello message (TODO: make configurable).
 #if 1
-        if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
+        if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) &&
+            SSL_get_peer_certificate(ssl) &&
+            (request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
             debugs(81, 3, "Error ("  << ERR_error_string(ssl_lib_error, NULL) <<  ") but, hold write on SSL connection on FD " << fd);
             checkForPeekAndSplice();
             return;
         }
 #endif
 
         // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
         if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
             sysErrNo = errno;
 
         debugs(83, DBG_IMPORTANT, "Error negotiating SSL on FD " << fd <<
                ": " << ERR_error_string(ssl_lib_error, NULL) << " (" <<
                ssl_error << "/" << ret << "/" << errno << ")");
 
         break; // proceed to the general error handling code
 
     default:
         break; // no special error handling for all other errors
     }
 

