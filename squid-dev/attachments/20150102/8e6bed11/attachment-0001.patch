# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20150102100820-l6yces6mxkfziuge
# target_branch: file:///home/kinkie/squid/workspace/trunk/
# testament_sha1: f965cabac98083ebf3b7830322685d08ae20c2be
# timestamp: 2015-01-02 11:21:21 +0100
# base_revision_id: squidadm@squid-cache.org-20150102061206-\
#   7e9auwijezfkedc5
# 
# Begin patch
=== modified file 'include/splay.h'
--- include/splay.h	2014-12-20 12:12:02 +0000
+++ include/splay.h	2015-01-02 10:08:20 +0000
@@ -15,6 +15,8 @@
 
 #include <stack>
 
+
+// private class of Splay. Do not use directly
 template <class V>
 class SplayNode
 {
@@ -30,9 +32,8 @@
     Value data;
     mutable SplayNode<V> *left;
     mutable SplayNode<V> *right;
-    void destroy(SPLAYFREE *);
+    void destroy(SPLAYFREE * = DefaultFree);
     void walk(SPLAYWALKEE *, void *callerState);
-    bool empty() const { return this == NULL; }
     SplayNode<V> const * start() const;
     SplayNode<V> const * finish() const;
 
@@ -40,6 +41,8 @@
 
     SplayNode<V> * insert(Value data, SPLAYCMP * compare);
 
+    /// look in the splay for data for where compare(data,candidate) == true.
+    /// return NULL if not found, a pointer to the sought data if found.
     template <class FindValue> SplayNode<V> * splay(const FindValue &data, int( * compare)(FindValue const &a, Value const &b)) const;
 
     /// recursively visit left nodes, this node, and then right nodes
@@ -68,11 +71,12 @@
 
     mutable SplayNode<V> * head;
     template <class FindValue> Value const *find (FindValue const &, int( * compare)(FindValue const &a, Value const &b)) const;
+
     void insert(Value const &, SPLAYCMP *compare);
 
     void remove(Value const &, SPLAYCMP *compare);
 
-    void destroy(SPLAYFREE *);
+    void destroy(SPLAYFREE * = SplayNode<V>::DefaultFree);
 
     SplayNode<V> const * start() const;
 
@@ -80,6 +84,8 @@
 
     size_t size() const;
 
+    bool empty() const { return size() == 0; }
+
     const_iterator begin() const;
 
     const_iterator end() const;
@@ -92,17 +98,6 @@
 
 SQUIDCEXTERN int splayLastResult;
 
-SQUIDCEXTERN splayNode *splay_insert(void *, splayNode *, splayNode::SPLAYCMP *);
-
-SQUIDCEXTERN splayNode *splay_delete(const void *, splayNode *, splayNode::SPLAYCMP *);
-
-SQUIDCEXTERN splayNode *splay_splay(const void **, splayNode *, splayNode::SPLAYCMP *);
-
-SQUIDCEXTERN void splay_destroy(splayNode *, splayNode::SPLAYFREE *);
-
-SQUIDCEXTERN void splay_walk(splayNode *, splayNode::SPLAYWALKEE *, void *callerState);
-
-/* inline methods */
 template<class V>
 SplayNode<V>::SplayNode (Value const &someData) : data(someData), left(NULL), right (NULL) {}
 
@@ -110,9 +105,6 @@
 void
 SplayNode<V>::walk(SPLAYWALKEE * walkee, void *state)
 {
-    if (this == NULL)
-        return;
-
     if (left)
         left->walk(walkee, state);
 
@@ -126,7 +118,7 @@
 SplayNode<V> const *
 SplayNode<V>::start() const
 {
-    if (this && left)
+    if (left)
         return left->start();
 
     return this;
@@ -136,7 +128,7 @@
 SplayNode<V> const *
 SplayNode<V>::finish() const
 {
-    if (this && right)
+    if (right)
         return right->finish();
 
     return this;
@@ -146,9 +138,6 @@
 void
 SplayNode<V>::destroy(SPLAYFREE * free_func)
 {
-    if (!this)
-        return;
-
     if (left)
         left->destroy(free_func);
 
@@ -164,9 +153,6 @@
 SplayNode<V> *
 SplayNode<V>::remove(Value const dataToRemove, SPLAYCMP * compare)
 {
-    if (this == NULL)
-        return NULL;
-
     SplayNode<V> *result = splay(dataToRemove, compare);
 
     if (splayLastResult == 0) { /* found it */
@@ -194,13 +180,6 @@
 {
     /* create node to insert */
     SplayNode<V> *newNode = new SplayNode<V>(dataToInsert);
-
-    if (this == NULL) {
-        splayLastResult = -1;
-        newNode->left = newNode->right = NULL;
-        return newNode;
-    }
-
     SplayNode<V> *newTop = splay(dataToInsert, compare);
 
     if (splayLastResult < 0) {
@@ -225,12 +204,6 @@
 SplayNode<V> *
 SplayNode<V>::splay(FindValue const &dataToFind, int( * compare)(FindValue const &a, Value const &b)) const
 {
-    if (this == NULL) {
-        /* can't have compared successfully :} */
-        splayLastResult = -1;
-        return NULL;
-    }
-
     Value temp = Value();
     SplayNode<V> N(temp);
     SplayNode<V> *l;
@@ -316,6 +289,9 @@
 typename Splay<V>::Value const *
 Splay<V>::find (FindValue const &value, int( * compare)(FindValue const &a, Value const &b)) const
 {
+    if (head == NULL)
+        return NULL;
+
     head = head->splay(value, compare);
 
     if (splayLastResult != 0)
@@ -329,7 +305,10 @@
 Splay<V>::insert(Value const &value, SPLAYCMP *compare)
 {
     assert (!find (value, compare));
-    head = head->insert(value, compare);
+    if (head == NULL)
+        head = new SplayNode<V>(value);
+    else
+        head = head->insert(value, compare);
     ++elements;
 }
 

=== modified file 'src/DelayTagged.cc'
--- src/DelayTagged.cc	2014-12-20 12:12:02 +0000
+++ src/DelayTagged.cc	2014-12-31 08:48:55 +0000
@@ -35,7 +35,7 @@
     DelayPools::registerForUpdates (this);
 }
 
-static SplayNode<DelayTaggedBucket::Pointer>::SPLAYFREE DelayTaggedFree;
+static Splay<DelayTaggedBucket::Pointer>::SPLAYFREE DelayTaggedFree;
 
 DelayTagged::~DelayTagged()
 {
@@ -43,7 +43,7 @@
     buckets.head->destroy (DelayTaggedFree);
 }
 
-static SplayNode<DelayTaggedBucket::Pointer>::SPLAYCMP DelayTaggedCmp;
+static Splay<DelayTaggedBucket::Pointer>::SPLAYCMP DelayTaggedCmp;
 
 int
 DelayTaggedCmp(DelayTaggedBucket::Pointer const &left, DelayTaggedBucket::Pointer const &right)

=== modified file 'src/DelayUser.cc'
--- src/DelayUser.cc	2014-12-20 12:12:02 +0000
+++ src/DelayUser.cc	2014-12-31 08:51:04 +0000
@@ -37,7 +37,7 @@
     DelayPools::registerForUpdates (this);
 }
 
-static SplayNode<DelayUserBucket::Pointer>::SPLAYFREE DelayUserFree;
+static Splay<DelayUserBucket::Pointer>::SPLAYFREE DelayUserFree;
 
 DelayUser::~DelayUser()
 {
@@ -45,7 +45,7 @@
     buckets.head->destroy (DelayUserFree);
 }
 
-static SplayNode<DelayUserBucket::Pointer>::SPLAYCMP DelayUserCmp;
+static Splay<DelayUserBucket::Pointer>::SPLAYCMP DelayUserCmp;
 
 int
 DelayUserCmp(DelayUserBucket::Pointer const &left, DelayUserBucket::Pointer const &right)

=== modified file 'src/acl/Arp.cc'
--- src/acl/Arp.cc	2014-12-20 12:12:02 +0000
+++ src/acl/Arp.cc	2014-12-30 16:52:25 +0000
@@ -20,10 +20,9 @@
 #include "globals.h"
 #include "ip/Address.h"
 
-static void aclParseArpList(SplayNode<Eui::Eui48 *> **curlist);
-static int aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, Ip::Address &c);
-static SplayNode<Eui::Eui48 *>::SPLAYCMP aclArpCompare;
-static SplayNode<Eui::Eui48 *>::SPLAYWALKEE aclDumpArpListWalkee;
+static void aclParseArpList(Splay<Eui::Eui48 *> **curlist);
+static int aclMatchArp(Splay<Eui::Eui48 *> **dataptr, Ip::Address &c);
+static Splay<Eui::Eui48 *>::SPLAYCMP aclArpCompare;
 
 ACL *
 ACLARP::clone() const
@@ -43,7 +42,7 @@
 ACLARP::~ACLARP()
 {
     if (data)
-        data->destroy(SplayNode<Eui::Eui48*>::DefaultFree);
+        data->destroy();
 }
 
 char const *
@@ -117,17 +116,16 @@
 }
 
 void
-aclParseArpList(SplayNode<Eui::Eui48 *> **curlist)
+aclParseArpList(Splay<Eui::Eui48 *> **curlist)
 {
     char *t = NULL;
-    SplayNode<Eui::Eui48*> **Top = curlist;
     Eui::Eui48 *q = NULL;
 
     while ((t = strtokFile())) {
         if ((q = aclParseArpData(t)) == NULL)
             continue;
 
-        *Top = (*Top)->insert(q, aclArpCompare);
+        (*curlist)->insert(q, aclArpCompare);
     }
 }
 
@@ -149,21 +147,14 @@
 /* aclMatchArp */
 /***************/
 int
-aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, Ip::Address &c)
+aclMatchArp(Splay<Eui::Eui48 *> **dataptr, Ip::Address &c)
 {
-    Eui::Eui48 result;
-    SplayNode<Eui::Eui48 *> **Top = dataptr;
-
-    if (result.lookup(c)) {
-        /* Do ACL match lookup */
-        *Top = (*Top)->splay(&result, aclArpCompare);
-        debugs(28, 3, "aclMatchArp: '" << c << "' " << (splayLastResult ? "NOT found" : "found"));
-        return (0 == splayLastResult);
+    Eui::Eui48 lookingFor;
+    if (lookingFor.lookup(c)) {
+        Eui::Eui48 * const* lookupResult = (*dataptr)->find(&lookingFor,aclArpCompare);
+        debugs(28, 3, "aclMatchArp: '" << c << "' " << (lookupResult ? "found" : "NOT found"));
+        return (lookupResult != NULL);
     }
-
-    /*
-     * Address was not found on any interface
-     */
     debugs(28, 3, "aclMatchArp: " << c << " NOT found");
     return 0;
 }
@@ -174,20 +165,22 @@
     return memcmp(a, b, sizeof(Eui::Eui48));
 }
 
-static void
-aclDumpArpListWalkee(Eui::Eui48 * const &node, void *state)
-{
-    static char buf[48];
-    node->encode(buf, 48);
-    static_cast<SBufList *>(state)->push_back(SBuf(buf));
-}
+// visitor functor to collect the contents of the Arp Acl
+struct ArpAclDumpVisitor {
+    SBufList contents;
+    void operator() (const Eui::Eui48 * v) {
+        static char buf[48];
+        v->encode(buf,48);
+        contents.push_back(SBuf(buf));
+    }
+};
 
 SBufList
 ACLARP::dump() const
 {
-    SBufList sl;
-    data->walk(aclDumpArpListWalkee, &sl);
-    return sl;
+    ArpAclDumpVisitor visitor;
+    data->visit(visitor);
+    return visitor.contents;
 }
 
 /* ==== END ARP ACL SUPPORT =============================================== */

=== modified file 'src/acl/Arp.h'
--- src/acl/Arp.h	2014-12-20 12:12:02 +0000
+++ src/acl/Arp.h	2014-12-30 14:59:16 +0000
@@ -39,7 +39,7 @@
 protected:
     static Prototype RegistryProtoype;
     static ACLARP RegistryEntry_;
-    SplayNode<Eui::Eui48 *> *data;
+    Splay<Eui::Eui48 *> *data;
     char const *class_;
 };
 

=== modified file 'src/acl/CertificateData.cc'
--- src/acl/CertificateData.cc	2014-12-20 12:12:02 +0000
+++ src/acl/CertificateData.cc	2014-12-31 07:50:14 +0000
@@ -71,12 +71,12 @@
     return values.match(value);
 }
 
-static void
-aclDumpAttributeListWalkee(char * const & node_data, void *outlist)
-{
-    /* outlist is really a SBufList * */
-    static_cast<SBufList *>(outlist)->push_back(SBuf(node_data));
-}
+struct CertificateDataAclDumpVisitor {
+    SBufList contents;
+    void operator() (char * const & node_data) {
+        contents.push_back(SBuf(node_data));
+    }
+};
 
 SBufList
 ACLCertificateData::dump() const
@@ -84,12 +84,10 @@
     SBufList sl;
     if (validAttributesStr)
         sl.push_back(SBuf(attribute));
-    /* damn this is VERY inefficient for long ACL lists... filling
-     * a wordlist this way costs Sum(1,N) iterations. For instance
-     * a 1000-elements list will be filled in 499500 iterations.
-     */
-    /* XXX FIXME: don't break abstraction */
-    values.values->walk(aclDumpAttributeListWalkee, &sl);
+
+    CertificateDataAclDumpVisitor visitor;
+    values.values->visit(visitor);
+    sl.splice(sl.end(),visitor.contents);
     return sl;
 }
 

=== modified file 'src/acl/DomainData.cc'
--- src/acl/DomainData.cc	2014-12-20 12:12:02 +0000
+++ src/acl/DomainData.cc	2014-12-30 16:05:48 +0000
@@ -106,30 +106,27 @@
 
     debugs(28, 3, "aclMatchDomainList: checking '" << host << "'");
 
-    domains = domains->splay((char *)host, aclHostDomainCompare);
-
-    debugs(28, 3, "aclMatchDomainList: '" << host << "' " << (splayLastResult ? "NOT found" : "found"));
-
-    return !splayLastResult;
-}
-
-static void
-aclDumpDomainListWalkee(char * const & node_data, void *outlist)
-{
-    /* outlist is really a SBufList ** */
-    static_cast<SBufList *>(outlist)->push_back(SBuf(node_data));
-}
+    char *h = const_cast<char *>(host);
+    char const * const * result = domains->find(h, aclHostDomainCompare);
+
+    debugs(28, 3, "aclMatchDomainList: '" << host << "' " << (result ? "found" : "NOT found"));
+
+    return (result != NULL);
+}
+
+struct AclDomainDataDumpVisitor {
+    SBufList contents;
+    void operator() (char * const & node_data) {
+        contents.push_back(SBuf(node_data));
+    }
+};
 
 SBufList
 ACLDomainData::dump() const
 {
-    SBufList sl;
-    /* damn this is VERY inefficient for long ACL lists... filling
-     * a wordlist this way costs Sum(1,N) iterations. For instance
-     * a 1000-elements list will be filled in 499500 iterations.
-     */
-    domains->walk(aclDumpDomainListWalkee, &sl);
-    return sl;
+    AclDomainDataDumpVisitor visitor;
+    domains->visit(visitor);
+    return visitor.contents;
 }
 
 void
@@ -137,9 +134,12 @@
 {
     char *t = NULL;
 
+    if (!domains)
+        domains = new Splay<char *>();
+
     while ((t = strtokFile())) {
         Tolower(t);
-        domains = domains->insert(xstrdup(t), aclDomainCompare);
+        domains->insert(xstrdup(t), aclDomainCompare);
     }
 }
 

=== modified file 'src/acl/DomainData.h'
--- src/acl/DomainData.h	2014-12-20 12:12:02 +0000
+++ src/acl/DomainData.h	2014-12-30 16:05:48 +0000
@@ -25,7 +25,7 @@
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
 
-    SplayNode<char *> *domains;
+    Splay<char *> *domains;
 };
 
 #endif /* SQUID_ACLDOMAINDATA_H */

=== modified file 'src/acl/Eui64.cc'
--- src/acl/Eui64.cc	2014-12-20 12:12:02 +0000
+++ src/acl/Eui64.cc	2014-12-31 08:48:55 +0000
@@ -20,10 +20,9 @@
 #include "globals.h"
 #include "ip/Address.h"
 
-static void aclParseEuiList(SplayNode<Eui::Eui64 *> **curlist);
-static int aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, Ip::Address &c);
-static SplayNode<Eui::Eui64 *>::SPLAYCMP aclEui64Compare;
-static SplayNode<Eui::Eui64 *>::SPLAYWALKEE aclDumpEuiListWalkee;
+static void aclParseEuiList(Splay<Eui::Eui64 *> **curlist);
+static int aclMatchEui(Splay<Eui::Eui64 *> **dataptr, Ip::Address &c);
+static Splay<Eui::Eui64 *>::SPLAYCMP aclEui64Compare;
 
 ACL *
 ACLEui64::clone() const
@@ -43,7 +42,7 @@
 ACLEui64::~ACLEui64()
 {
     if (data)
-        data->destroy(SplayNode<Eui::Eui64*>::DefaultFree);
+        data->destroy();
 }
 
 char const *
@@ -91,17 +90,16 @@
 }
 
 void
-aclParseEuiList(SplayNode<Eui::Eui64 *> **curlist)
+aclParseEuiList(Splay<Eui::Eui64 *> **curlist)
 {
     char *t = NULL;
-    SplayNode<Eui::Eui64*> **Top = curlist;
     Eui::Eui64 *q = NULL;
 
     while ((t = strtokFile())) {
         if ((q = aclParseEuiData(t)) == NULL)
             continue;
 
-        *Top = (*Top)->insert(q, aclEui64Compare);
+        (*curlist)->insert(q, aclEui64Compare);
     }
 }
 
@@ -123,16 +121,14 @@
 /* aclMatchEui */
 /***************/
 int
-aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, Ip::Address &c)
+aclMatchEui(Splay<Eui::Eui64 *> **dataptr, Ip::Address &c)
 {
-    Eui::Eui64 result;
-    SplayNode<Eui::Eui64 *> **Top = dataptr;
+    Eui::Eui64 lookingFor;
 
-    if (result.lookup(c)) {
-        /* Do ACL match lookup */
-        *Top = (*Top)->splay(&result, aclEui64Compare);
-        debugs(28, 3, "aclMatchEui: '" << c << "' " << (splayLastResult ? "NOT found" : "found"));
-        return (0 == splayLastResult);
+    if (lookingFor.lookup(c)) {
+        Eui::Eui64 * const * lookupResult = (*dataptr)->find(&lookingFor, aclEui64Compare);
+        debugs(28, 3, "aclMatchEui: '" << c << "' " << (lookupResult ? "found" : "NOT found"));
+        return (lookupResult != NULL);
     }
 
     /*
@@ -148,20 +144,21 @@
     return memcmp(a, b, sizeof(Eui::Eui64));
 }
 
-static void
-aclDumpEuiListWalkee(Eui::Eui64 * const &node, void *state)
-{
-    static char buf[48];
-    node->encode(buf, 48);
-    static_cast<SBufList *>(state)->push_back(SBuf(buf));
-}
+struct AclEui64DumpVisitor {
+    SBufList contents;
+    void operator() ( const Eui::Eui64 * v) {
+        static char buf[48];
+        v->encode(buf, 48);
+        contents.push_back(SBuf(buf));
+    }
+};
 
 SBufList
 ACLEui64::dump() const
 {
-    SBufList w;
-    data->walk(aclDumpEuiListWalkee, &w);
-    return w;
+    AclEui64DumpVisitor visitor;
+    data->visit(visitor);
+    return visitor.contents;
 }
 
 #endif /* USE_SQUID_EUI */

=== modified file 'src/acl/Eui64.h'
--- src/acl/Eui64.h	2014-12-20 12:12:02 +0000
+++ src/acl/Eui64.h	2014-12-30 16:52:25 +0000
@@ -38,7 +38,7 @@
 protected:
     static Prototype RegistryProtoype;
     static ACLEui64 RegistryEntry_;
-    SplayNode<Eui::Eui64 *> *data;
+    Splay<Eui::Eui64 *> *data;
     char const *class_;
 };
 

=== modified file 'src/acl/HttpStatus.cc'
--- src/acl/HttpStatus.cc	2014-09-13 13:59:43 +0000
+++ src/acl/HttpStatus.cc	2014-12-30 21:58:43 +0000
@@ -17,9 +17,9 @@
 
 #include <climits>
 
-static void aclParseHTTPStatusList(SplayNode<acl_httpstatus_data *> **curlist);
+static void aclParseHTTPStatusList(Splay<acl_httpstatus_data *> **curlist);
 static int aclHTTPStatusCompare(acl_httpstatus_data * const &a, acl_httpstatus_data * const &b);
-static int aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, Http::StatusCode status);
+static int aclMatchHTTPStatus(Splay<acl_httpstatus_data*> **dataptr, Http::StatusCode status);
 
 acl_httpstatus_data::acl_httpstatus_data(int x) : status1(x), status2(x) { ; }
 
@@ -75,7 +75,7 @@
 ACLHTTPStatus::~ACLHTTPStatus()
 {
     if (data)
-        data->destroy(SplayNode<acl_httpstatus_data*>::DefaultFree);
+        data->destroy();
 }
 
 char const *
@@ -113,17 +113,16 @@
 }
 
 void
-aclParseHTTPStatusList(SplayNode<acl_httpstatus_data *> **curlist)
+aclParseHTTPStatusList(Splay<acl_httpstatus_data *> **curlist)
 {
     char *t = NULL;
-    SplayNode<acl_httpstatus_data*> **Top = curlist;
     acl_httpstatus_data *q = NULL;
 
     while ((t = strtokFile())) {
         if ((q = aclParseHTTPStatusData(t)) == NULL)
             continue;
 
-        *Top = (*Top)->insert(q, acl_httpstatus_data::compare);
+        (*curlist)->insert(q, acl_httpstatus_data::compare);
     }
 }
 
@@ -134,15 +133,13 @@
 }
 
 int
-aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, const Http::StatusCode status)
+aclMatchHTTPStatus(Splay<acl_httpstatus_data*> **dataptr, const Http::StatusCode status)
 {
-
     acl_httpstatus_data X(status);
-    SplayNode<acl_httpstatus_data*> **Top = dataptr;
-    *Top = Top[0]->splay(&X, aclHTTPStatusCompare);
+    const acl_httpstatus_data * const * result = (*dataptr)->find(&X, aclHTTPStatusCompare);
 
-    debugs(28, 3, "aclMatchHTTPStatus: '" << status << "' " << (splayLastResult ? "NOT found" : "found"));
-    return (0 == splayLastResult);
+    debugs(28, 3, "aclMatchHTTPStatus: '" << status << "' " << (result ? "found" : "NOT found"));
+    return (result != NULL);
 }
 
 static int
@@ -157,18 +154,18 @@
     return 0;
 }
 
-static void
-aclDumpHTTPStatusListWalkee(acl_httpstatus_data * const &node, void *state)
-{
-    // state is a SBufList*
-    static_cast<SBufList *>(state)->push_back(node->toStr());
-}
+struct HttpStatusAclDumpVisitor {
+    SBufList contents;
+    void operator() (const acl_httpstatus_data * node) {
+        contents.push_back(node->toStr());
+    }
+};
 
 SBufList
 ACLHTTPStatus::dump() const
 {
-    SBufList w;
-    data->walk(aclDumpHTTPStatusListWalkee, &w);
-    return w;
+    HttpStatusAclDumpVisitor visitor;
+    data->visit(visitor);
+    return visitor.contents;
 }
 

=== modified file 'src/acl/HttpStatus.h'
--- src/acl/HttpStatus.h	2014-12-20 12:12:02 +0000
+++ src/acl/HttpStatus.h	2014-12-30 21:58:43 +0000
@@ -45,7 +45,7 @@
 protected:
     static Prototype RegistryProtoype;
     static ACLHTTPStatus RegistryEntry_;
-    SplayNode<acl_httpstatus_data*> *data;
+    Splay<acl_httpstatus_data*> *data;
     char const *class_;
 };
 

=== modified file 'src/acl/Ip.cc'
--- src/acl/Ip.cc	2015-01-01 08:57:18 +0000
+++ src/acl/Ip.cc	2015-01-02 09:07:07 +0000
@@ -31,18 +31,6 @@
 }
 
 /**
- * Writes an IP ACL data into a buffer, then copies the buffer into the wordlist given
- *
- \param ip  ACL data structure to display
- \param state   wordlist structure which is being generated
- */
-void
-ACLIP::DumpIpListWalkee(acl_ip_data * const & ip, void *state)
-{
-    static_cast<SBufList *>(state)->push_back(ip->toSBuf());
-}
-
-/**
  * print/format an acl_ip_data structure for debugging output.
  *
  \param buf string buffer to write to
@@ -485,6 +473,9 @@
 void
 ACLIP::parse()
 {
+    if (data == NULL)
+        data = new IPSplay();
+
     flags.parseFlags();
 
     while (char *t = strtokFile()) {
@@ -494,7 +485,7 @@
             /* pop each result off the list and add it to the data tree individually */
             acl_ip_data *next_node = q->next;
             q->next = NULL;
-            data = data->insert(q, acl_ip_data::NetworkCompare);
+            data->insert(q, acl_ip_data::NetworkCompare);
             q = next_node;
         }
     }
@@ -503,15 +494,22 @@
 ACLIP::~ACLIP()
 {
     if (data)
-        data->destroy(IPSplay::DefaultFree);
+        data->destroy();
 }
 
+struct IpAclDumpVisitor {
+    SBufList contents;
+    void operator() (acl_ip_data * const & ip) {
+        contents.push_back(ip->toSBuf());
+    }
+};
+
 SBufList
 ACLIP::dump() const
 {
-    SBufList sl;
-    data->walk(DumpIpListWalkee, &sl);
-    return sl;
+    IpAclDumpVisitor visitor;
+    data->visit(visitor);
+    return visitor.contents;
 }
 
 bool
@@ -534,9 +532,9 @@
     ClientAddress.addr2.setEmpty();
     ClientAddress.mask.setEmpty();
 
-    data = data->splay(&ClientAddress, aclIpAddrNetworkCompare);
-    debugs(28, 3, "aclIpMatchIp: '" << clientip << "' " << (splayLastResult ? "NOT found" : "found"));
-    return !splayLastResult;
+    const acl_ip_data * const * result =  data->find(&ClientAddress, aclIpAddrNetworkCompare);
+    debugs(28, 3, "aclIpMatchIp: '" << clientip << "' " << (result ? "found" : "NOT found"));
+    return (result != NULL);
 }
 
 acl_ip_data::acl_ip_data() :addr1(), addr2(), mask(), next (NULL) {}

=== modified file 'src/acl/Ip.h'
--- src/acl/Ip.h	2014-12-20 12:12:02 +0000
+++ src/acl/Ip.h	2014-12-30 22:13:01 +0000
@@ -52,7 +52,7 @@
 
     ~ACLIP();
 
-    typedef SplayNode<acl_ip_data *> IPSplay;
+    typedef Splay<acl_ip_data *> IPSplay;
 
     virtual char const *typeString() const = 0;
     virtual void parse();
@@ -66,8 +66,6 @@
     int match(Ip::Address &);
     IPSplay *data;
 
-private:
-    static void DumpIpListWalkee(acl_ip_data * const & ip, void *state);
 };
 
 #endif /* SQUID_ACLIP_H */

=== modified file 'src/acl/StringData.cc'
--- src/acl/StringData.cc	2014-12-20 12:12:02 +0000
+++ src/acl/StringData.cc	2014-12-30 22:27:34 +0000
@@ -44,7 +44,7 @@
 void
 ACLStringData::insert(const char *value)
 {
-    values = values->insert(xstrdup(value), splaystrcmp);
+    values->insert(xstrdup(value), splaystrcmp);
 }
 
 bool
@@ -55,30 +55,27 @@
 
     debugs(28, 3, "aclMatchStringList: checking '" << toFind << "'");
 
-    values = values->splay((char *)toFind, splaystrcmp);
-
-    debugs(28, 3, "aclMatchStringList: '" << toFind << "' " << (splayLastResult ? "NOT found" : "found"));
-
-    return !splayLastResult;
-}
-
-static void
-aclDumpStringWalkee(char * const & node_data, void *outlist)
-{
-    /* outlist is really a SBufList* */
-    static_cast<SBufList*>(outlist)->push_back(SBuf(node_data));
-}
+    char * const * result = values->find(const_cast<char *>(toFind), splaystrcmp);
+
+    debugs(28, 3, "aclMatchStringList: '" << toFind << "' " << (result ? "found" : "NOT found"));
+
+    return (result != NULL);
+}
+
+// visitor functor to collect the contents of the Arp Acl
+struct StringDataAclDumpVisitor {
+    SBufList contents;
+    void operator() (char * const& node_data) {
+        contents.push_back(SBuf(node_data));
+    }
+};
 
 SBufList
 ACLStringData::dump() const
 {
-    SBufList sl;
-    /* damn this is VERY inefficient for long ACL lists... filling
-     * a SBufList this way costs Sum(1,N) iterations. For instance
-     * a 1000-elements list will be filled in 499500 iterations.
-     */
-    values->walk(aclDumpStringWalkee, &sl);
-    return sl;
+    StringDataAclDumpVisitor visitor;
+    values->visit(visitor);
+    return visitor.contents;
 }
 
 void
@@ -87,7 +84,7 @@
     char *t;
 
     while ((t = strtokFile()))
-        values = values->insert(xstrdup(t), splaystrcmp);
+        values->insert(xstrdup(t), splaystrcmp);
 }
 
 bool

=== modified file 'src/acl/StringData.h'
--- src/acl/StringData.h	2014-12-20 12:12:02 +0000
+++ src/acl/StringData.h	2014-12-30 22:27:34 +0000
@@ -30,7 +30,7 @@
     /// Insert a string data value
     void insert(const char *);
 
-    SplayNode<char *> *values;
+    Splay<char *> *values;
 };
 
 #endif /* SQUID_ACLSTRINGDATA_H */

=== modified file 'src/acl/UserData.cc'
--- src/acl/UserData.cc	2014-12-20 12:12:02 +0000
+++ src/acl/UserData.cc	2014-12-30 22:52:53 +0000
@@ -43,10 +43,7 @@
 bool
 ACLUserData::match(char const *user)
 {
-    SplayNode<char *> *Top = names;
-
     debugs(28, 7, "aclMatchUser: user is " << user << ", case_insensitive is " << flags.case_insensitive);
-    debugs(28, 8, "Top is " << Top << ", Top->data is " << ((char *) (Top != NULL ? (Top)->data : "Unavailable")));
 
     if (user == NULL || strcmp(user, "-") == 0)
         return 0;
@@ -56,26 +53,25 @@
         return 1;
     }
 
+    char * const *result;
+
     if (flags.case_insensitive)
-        Top = Top->splay((char *)user, splaystrcasecmp);
+        result = names->find(const_cast<char *>(user), splaystrcasecmp);
     else
-        Top = Top->splay((char *)user, splaystrcmp);
+        result = names->find(const_cast<char *>(user), splaystrcmp);
 
     /* Top=splay_splay(user,Top,(splayNode::SPLAYCMP *)dumping_strcmp); */
-    debugs(28, 7, "aclMatchUser: returning " << !splayLastResult << ",Top is " <<
-           Top << ", Top->data is " << ((char *) (Top ? Top->data : "Unavailable")));
-
-    names = Top;
-
-    return !splayLastResult;
-}
-
-static void
-aclDumpUserListWalkee(char * const & node_data, void *outlist)
-{
-    /* outlist is really a SBufList* */
-    static_cast<SBufList *>(outlist)->push_back(SBuf(node_data));
-}
+    debugs(28, 7, "aclMatchUser: returning " << (result != NULL));
+
+    return (result != NULL);
+}
+
+struct UserDataAclDumpVisitor {
+    SBufList contents;
+    void operator() (char * const & node_data) {
+       contents.push_back(SBuf(node_data));
+    }
+};
 
 SBufList
 ACLUserData::dump() const
@@ -89,10 +85,13 @@
      * a SBufList this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
-    if (flags.required)
+    if (flags.required) {
         sl.push_back(SBuf("REQUIRED"));
-    else if (names)
-        names->walk(aclDumpUserListWalkee, &sl);
+    } else if (names) {
+        UserDataAclDumpVisitor visitor;
+        names->visit(visitor);
+        sl.splice(sl.end(),visitor.contents);
+    }
 
     return sl;
 }
@@ -116,7 +115,7 @@
             if (flags.case_insensitive)
                 Tolower(t);
 
-            names = names->insert(xstrdup(t), splaystrcmp);
+            names->insert(xstrdup(t), splaystrcmp);
         }
     }
 
@@ -131,7 +130,7 @@
         if (flags.case_insensitive)
             Tolower(t);
 
-        names = names->insert(xstrdup(t), splaystrcmp);
+        names->insert(xstrdup(t), splaystrcmp);
     }
 }
 

=== modified file 'src/acl/UserData.h'
--- src/acl/UserData.h	2014-12-20 12:12:02 +0000
+++ src/acl/UserData.h	2014-12-30 22:52:53 +0000
@@ -25,7 +25,7 @@
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
 
-    SplayNode<char *> *names;
+    Splay<char *> *names;
 
     struct {
         bool case_insensitive;

=== modified file 'src/eui/Eui48.cc'
--- src/eui/Eui48.cc	2014-12-20 12:12:02 +0000
+++ src/eui/Eui48.cc	2014-12-30 14:59:16 +0000
@@ -116,7 +116,7 @@
 }
 
 bool
-Eui::Eui48::encode(char *buf, const int len)
+Eui::Eui48::encode(char *buf, const int len) const
 {
     if (len < SZ_EUI48_BUF)
         return false;

=== modified file 'src/eui/Eui48.h'
--- src/eui/Eui48.h	2014-12-20 12:12:02 +0000
+++ src/eui/Eui48.h	2014-12-30 14:59:16 +0000
@@ -62,7 +62,7 @@
      * \retval false        Conversion to ASCII failed.
      * \retval true         Conversion completed successfully.
      */
-    bool encode(char *buf, const int len);
+    bool encode(char *buf, const int len) const;
 
     // lookup an EUI-48 / MAC address via ARP
     bool lookup(const Ip::Address &c);

=== modified file 'src/eui/Eui64.cc'
--- src/eui/Eui64.cc	2015-01-01 08:57:18 +0000
+++ src/eui/Eui64.cc	2015-01-02 09:07:07 +0000
@@ -31,7 +31,7 @@
 }
 
 bool
-Eui::Eui64::encode(char *buf, const int len)
+Eui::Eui64::encode(char *buf, const int len) const
 {
     if (len < SZ_EUI64_BUF) return false;
 

=== modified file 'src/eui/Eui64.h'
--- src/eui/Eui64.h	2014-12-20 12:12:02 +0000
+++ src/eui/Eui64.h	2014-12-30 16:52:25 +0000
@@ -69,7 +69,7 @@
      * \retval false        Conversion to ASCII failed.
      * \retval true         Conversion completed successfully.
      */
-    bool encode(char *buf, const int len);
+    bool encode(char *buf, const int len) const;
 
     // lookup an EUI-64 address via IPv6 SLAAC or NDP
     bool lookup(const Ip::Address &c);

=== modified file 'src/stmem.cc'
--- src/stmem.cc	2014-12-20 12:12:02 +0000
+++ src/stmem.cc	2014-12-30 22:39:43 +0000
@@ -58,7 +58,7 @@
 void
 mem_hdr::freeContent()
 {
-    nodes.destroy(SplayNode<mem_node *>::DefaultFree);
+    nodes.destroy();
     inmem_hi = 0;
     debugs(19, 9, HERE << this << " hi: " << inmem_hi);
 }

=== modified file 'src/stmem.h'
--- src/stmem.h	2014-12-20 12:12:02 +0000
+++ src/stmem.h	2014-12-30 22:39:43 +0000
@@ -44,7 +44,7 @@
     /* Only for use of MemObject */
     void internalAppend(const char *data, int len);
 
-    static SplayNode<mem_node *>::SPLAYCMP NodeCompare;
+    static Splay<mem_node *>::SPLAYCMP NodeCompare;
 
 private:
     void debugDump() const;

=== modified file 'src/tests/stub_libeui.cc'
--- src/tests/stub_libeui.cc	2014-12-20 12:12:02 +0000
+++ src/tests/stub_libeui.cc	2014-12-30 21:47:57 +0000
@@ -18,7 +18,7 @@
 #if USE_SQUID_EUI
 const unsigned char *Eui::Eui48::get(void) STUB_RETVAL(NULL)
 bool Eui::Eui48::decode(const char *asc) STUB_RETVAL(false)
-bool Eui::Eui48::encode(char *buf, const int len) STUB_RETVAL(false)
+bool Eui::Eui48::encode(char *buf, const int len) const STUB_RETVAL(false)
 bool Eui::Eui48::lookup(const Ip::Address &c) STUB_RETVAL(false)
 #endif
 
@@ -26,7 +26,7 @@
 #if USE_SQUID_EUI
 const unsigned char *Eui::Eui64::get(void) STUB_RETVAL(NULL)
 bool Eui::Eui64::decode(const char *asc) STUB_RETVAL(false)
-bool Eui::Eui64::encode(char *buf, const int len) STUB_RETVAL(false)
+bool Eui::Eui64::encode(char *buf, const int len) const STUB_RETVAL(false)
 bool Eui::Eui64::lookup(const Ip::Address &c) STUB_RETVAL(false)
 bool Eui::Eui64::lookupNdp(const Ip::Address &c) STUB_RETVAL(false)
 bool Eui::Eui64::lookupSlaac(const Ip::Address &c) STUB_RETVAL(false)

=== modified file 'test-suite/mem_hdr_test.cc'
--- test-suite/mem_hdr_test.cc	2014-12-20 12:12:02 +0000
+++ test-suite/mem_hdr_test.cc	2014-12-30 22:55:20 +0000
@@ -75,7 +75,7 @@
     assert (!aSplay.find(&ref13,mem_hdr::NodeCompare));
     ref13.nodeBuffer.length = 1;
     assert (aSplay.find(&ref13,mem_hdr::NodeCompare));
-    aSplay.destroy(SplayNode<mem_node *>::DefaultFree);
+    aSplay.destroy();
 }
 
 void

=== modified file 'test-suite/splay.cc'
--- test-suite/splay.cc	2014-12-20 12:12:02 +0000
+++ test-suite/splay.cc	2015-01-02 10:02:05 +0000
@@ -18,14 +18,7 @@
 #include <unistd.h>
 #endif
 
-#if 0
-#define assert(X) {if (!(X)) exit (1);}
-#include "splay.h"
-#undef assert
-#else
-#include "splay.h"
-#endif
-
+#include "splay.h"
 #include "util.h"
 
 class intnode
@@ -146,7 +139,10 @@
         for (i = 0; i < 100; ++i) {
             I = (intnode *)xcalloc(sizeof(intnode), 1);
             I->i = squid_random();
-            top = top->insert(I, compareintvoid);
+            if (top)
+                top = top->insert(I, compareintvoid);
+            else
+                top = new splayNode(static_cast<void*>(new intnode(101)));
         }
 
         SplayCheck::BeginWalk();
@@ -155,15 +151,12 @@
         SplayCheck::BeginWalk();
         top->walk(SplayCheck::WalkVoid, NULL);
         top->destroy(destintvoid);
-        /* check we don't segfault on NULL splay calls */
-        top = NULL;
-        top->splay((void *)NULL, compareintvoid);
     }
 
     /* test typesafe splay containers */
     {
         /* intnode* */
-        SplayNode<intnode *> *safeTop = NULL;
+        SplayNode<intnode *> *safeTop = new SplayNode<intnode *>(new intnode(101));
 
         for ( int i = 0; i < 100; ++i) {
             intnode *I;
@@ -176,13 +169,10 @@
         safeTop->walk(SplayCheck::WalkNode, NULL);
 
         safeTop->destroy(destint);
-        /* check we don't segfault on NULL splay calls */
-        safeTop = NULL;
-        safeTop->splay((intnode *)NULL, compareint);
     }
     {
         /* intnode */
-        SplayNode<intnode> *safeTop = NULL;
+        SplayNode<intnode> *safeTop = new SplayNode<intnode>(101);
 
         for (int i = 0; i < 100; ++i) {
             intnode I;
@@ -194,11 +184,6 @@
         safeTop->walk(SplayCheck::WalkNodeRef, NULL);
 
         safeTop->destroy(destintref);
-        /* check we don't segfault on NULL splay calls */
-        safeTop = NULL;
-        safeTop->splay(intnode(), compareintref);
-        SplayCheck::BeginWalk();
-        safeTop->walk(SplayCheck::WalkNodeRef, NULL);
     }
 
     /* check the check routine */
@@ -215,7 +200,7 @@
 
     {
         /* check for begin() */
-        SplayNode<intnode> *safeTop = NULL;
+        Splay<intnode> *safeTop = new Splay<intnode>();
 
         if (safeTop->start() != NULL)
             exit (1);
@@ -228,15 +213,15 @@
             I.i = squid_random();
 
             if (I.i > 50 && I.i < 10000000)
-                safeTop = safeTop->insert(I, compareintref);
+                safeTop->insert(I, compareintref);
         }
 
         {
             intnode I;
             I.i = 50;
-            safeTop = safeTop->insert (I, compareintref);
+            safeTop->insert (I, compareintref);
             I.i = 10000000;
-            safeTop = safeTop->insert (I, compareintref);
+            safeTop->insert (I, compareintref);
         }
 
         if (!safeTop->start())
@@ -280,6 +265,8 @@
             exit (1);
     }
 
+    /* TODO: also test the oher Splay API */
+
     return 0;
 }
 

# Begin bundle
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
