=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-01-01 08:57:18 +0000
+++ src/client_side.cc	2015-01-07 11:28:41 +0000
@@ -2605,23 +2605,6 @@
         return;
     }
 
-    if (request->header.has(HDR_EXPECT)) {
-        const String expect = request->header.getList(HDR_EXPECT);
-        const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
-        if (!supportedExpect) {
-            clientStreamNode *node = context->getClientReplyContext();
-            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-            assert (repContext);
-            conn->quitAfterError(request.getRaw());
-            repContext->setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request->method, http->uri,
-                                        conn->clientConnection->remote, request.getRaw(), NULL, NULL);
-            assert(context->http->out.offset == 0);
-            context->pullData();
-            clientProcessRequestFinished(conn, request);
-            return;
-        }
-    }
-
     clientSetKeepaliveFlag(http);
     // Let tunneling code be fully responsible for CONNECT requests
     if (http->request->method == Http::METHOD_CONNECT) {

=== modified file 'src/servers/HttpServer.cc'
--- src/servers/HttpServer.cc	2014-12-20 12:12:02 +0000
+++ src/servers/HttpServer.cc	2015-01-07 11:18:41 +0000
@@ -248,10 +248,29 @@
     if (!buildHttpRequest(context))
         return;
 
-    if (Config.accessList.forceRequestBodyContinuation) {
         ClientHttpRequest *http = context->http;
-        HttpRequest *request = http->request;
-        ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request, NULL);
+    HttpRequest::Pointer request = http->request;
+
+    if (request->header.has(HDR_EXPECT)) {
+        const String expect = request->header.getList(HDR_EXPECT);
+        const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
+        if (!supportedExpect) {
+            clientStreamNode *node = context->getClientReplyContext();
+            quitAfterError(request.getRaw());
+            // setLogUri should called before repContext->setReplyToError
+            setLogUri(http, urlCanonicalClean(request.getRaw()));
+            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+            assert (repContext);
+            repContext->setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request->method, http->uri,
+                                        clientConnection->remote, request.getRaw(), NULL, NULL);
+            assert(context->http->out.offset == 0);
+            context->pullData();
+            clientProcessRequestFinished(this, request);
+            return;
+        }
+
+        if (Config.accessList.forceRequestBodyContinuation) {
+            ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request.getRaw(), NULL);
         if (bodyContinuationCheck.fastCheck() == ACCESS_ALLOWED) {
             debugs(33, 5, "Body Continuation forced");
             request->forcedBodyContinuation = true;
@@ -265,6 +284,7 @@
             return;
         }
     }
+    }
     clientProcessRequest(this, parser_, context);
 }
 

