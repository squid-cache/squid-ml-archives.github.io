# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20150131194100-ny3oz1eharvjzj4z
# target_branch: ../trunk
# testament_sha1: fa3fc9174bac2cf5065a449651e2d8648a846954
# timestamp: 2015-01-31 20:41:30 +0100
# base_revision_id: squid3@treenet.co.nz-20150129190524-\
#   j2zkmeqa6kwb7mo5
# 
# Begin patch
=== modified file 'src/SBuf.cc'
--- src/SBuf.cc	2015-01-13 07:25:36 +0000
+++ src/SBuf.cc	2015-01-31 19:41:00 +0000
@@ -630,17 +630,17 @@
 
     ++stats.find;
 
-    char *begin = buf()+startPos;
+    char *start = buf()+startPos;
     char *lastPossible = buf()+length()-needle.length()+1;
     char needleBegin = needle[0];
 
     debugs(24, 7, "looking for " << needle << "starting at " << startPos <<
            " in id " << id);
-    while (begin < lastPossible) {
+    while (start < lastPossible) {
         char *tmp;
-        debugs(24, 8, " begin=" << (void *) begin <<
+        debugs(24, 8, " begin=" << (void *) start <<
                ", lastPossible=" << (void*) lastPossible );
-        tmp = static_cast<char *>(memchr(begin, needleBegin, lastPossible-begin));
+        tmp = static_cast<char *>(memchr(start, needleBegin, lastPossible-start));
         if (tmp == NULL) {
             debugs(24, 8 , "First byte not found");
             return npos;
@@ -650,7 +650,7 @@
             debugs(24, 8, "Found at " << (tmp-buf()));
             return (tmp-buf());
         }
-        begin = tmp+1;
+        start = tmp+1;
     }
     debugs(24, 8, "not found");
     return npos;
@@ -736,8 +736,8 @@
 
     debugs(24, 7, "first of characterset " << set.name << " in id " << id);
     char *cur = buf()+startPos;
-    const char *end = bufEnd();
-    while (cur < end) {
+    const char *bufend = bufEnd();
+    while (cur < bufend) {
         if (set[*cur])
             return cur-buf();
         ++cur;
@@ -759,8 +759,8 @@
 
     debugs(24, 7, "first not of characterset " << set.name << " in id " << id);
     char *cur = buf()+startPos;
-    const char *end = bufEnd();
-    while (cur < end) {
+    const char *bufend = bufEnd();
+    while (cur < bufend) {
         if (!set[*cur])
             return cur-buf();
         ++cur;

=== modified file 'src/SBuf.h'
--- src/SBuf.h	2015-01-13 07:25:36 +0000
+++ src/SBuf.h	2015-01-31 19:41:00 +0000
@@ -17,6 +17,7 @@
 #include <climits>
 #include <cstdarg>
 #include <iosfwd>
+#include <iterator>
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -75,6 +76,35 @@
 };
 
 class CharacterSet;
+class SBuf;
+
+class SBufIterator : public std::iterator<std::input_iterator_tag, char>
+{
+public:
+    friend class SBuf;
+    typedef MemBlob::size_type size_type;
+    bool operator==(const SBufIterator &s) const;
+    bool operator!=(const SBufIterator &s) const;
+
+    char operator*() const { return *iter; }
+    SBufIterator& operator++() { ++iter; return *this; }
+
+protected:
+    SBufIterator(const SBuf &, size_type);
+
+    const SBuf &sbuf;
+    const char *iter;
+};
+
+class SBufReverseIterator : public SBufIterator
+{
+    friend class SBuf;
+public:
+    SBufReverseIterator& operator++() { --iter; return *this;}
+    char operator*() const { return *(iter-1); }
+protected:
+    SBufReverseIterator(const SBuf &s, size_type sz) : SBufIterator(s,sz) {}
+};
 
 /**
  * A String or Buffer.
@@ -86,6 +116,8 @@
 {
 public:
     typedef MemBlob::size_type size_type;
+    typedef SBufIterator iterator;
+    typedef SBufReverseIterator reverse_iterator;
     static const size_type npos = 0xffffffff; // max(uint32_t)
 
     /// Maximum size of a SBuf. By design it MUST be < MAX(size_type)/2. Currently 256Mb.
@@ -541,6 +573,22 @@
     /// std::string export function
     std::string toStdString() const { return std::string(buf(),length()); }
 
+    iterator begin() {
+        return iterator(*this, 0);
+    }
+
+    iterator end() {
+        return iterator(*this, length());
+    }
+
+    reverse_iterator rbegin() {
+        return reverse_iterator(*this, length());
+    }
+
+    reverse_iterator rend() {
+        return reverse_iterator(*this, 0);
+    }
+
     // TODO: possibly implement erase() similar to std::string's erase
     // TODO: possibly implement a replace() call
 private:
@@ -619,5 +667,24 @@
     return buf;
 }
 
+inline
+SBufIterator::SBufIterator(const SBuf &s, size_type pos)
+    : sbuf(s), iter(s.rawContent()+pos)
+{}
+
+inline bool
+SBufIterator::operator==(const SBufIterator &s) const
+{
+    // note: maybe the sbuf comparison is unnecessary?
+    return iter == s.iter && sbuf == s.sbuf;
+}
+
+inline bool
+SBufIterator::operator!=(const SBufIterator &s) const
+{
+    // note: maybe the sbuf comparison is unnecessary?
+    return iter != s.iter || sbuf != s.sbuf;
+}
+
 #endif /* SQUID_SBUF_H */
 

=== modified file 'src/tests/testSBuf.cc'
--- src/tests/testSBuf.cc	2015-01-13 07:25:36 +0000
+++ src/tests/testSBuf.cc	2015-01-31 19:41:00 +0000
@@ -915,3 +915,39 @@
     CPPUNIT_ASSERT_EQUAL(astr,sb.toStdString());
 }
 
+void
+testSBuf::testIterators()
+{
+    SBuf text("foo"), text2("foo");
+    CPPUNIT_ASSERT(text.begin() == text.begin());
+    CPPUNIT_ASSERT(text.begin() != text.end());
+    CPPUNIT_ASSERT(text.begin() != text2.begin());
+    {
+        auto i = text.begin();
+        auto e = text.end()
+        CPPUNIT_ASSERT_EQUAL('f', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT(i == e);
+    }
+    {
+        auto i = text.rbegin();
+        auto e = text.rend();
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('f', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT(i == e);
+    }
+}

=== modified file 'src/tests/testSBuf.h'
--- src/tests/testSBuf.h	2015-01-13 07:25:36 +0000
+++ src/tests/testSBuf.h	2015-01-31 19:41:00 +0000
@@ -52,6 +52,7 @@
     CPPUNIT_TEST( testSBufStream );
     CPPUNIT_TEST( testAutoFind );
     CPPUNIT_TEST( testStdStringOps );
+    CPPUNIT_TEST( testIterators );
 //    CPPUNIT_TEST( testDumpStats ); //fake test, to print alloc stats
     CPPUNIT_TEST_SUITE_END();
 protected:
@@ -91,6 +92,7 @@
     void testFindFirstNotOf();
     void testAutoFind();
     void testStdStringOps();
+    void testIterators();
 };
 
 #endif

# Begin bundle
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
83MtM8ZPGkOaH/i7kinChIKoPMCI
