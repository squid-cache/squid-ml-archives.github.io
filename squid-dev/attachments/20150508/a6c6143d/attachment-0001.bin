comm_connect_addr on failures return Comm:OK

The comm_connect_addr on connect failures set the errno to 0 and return
Comm::OK. This is causes problems on ConnOpener class users which believes the
connection is established and it is ready for use.

This is a Measurement Factory project

=== modified file 'src/comm.cc'
--- src/comm.cc	2015-04-26 16:48:02 +0000
+++ src/comm.cc	2015-05-08 15:51:02 +0000
@@ -623,40 +623,41 @@
         return Comm::ERR_PROTOCOL;
     }
 
     address.getAddrInfo(AI, F->sock_family);
 
     /* Establish connection. */
     int xerrno = 0;
 
     if (!F->flags.called_connect) {
         F->flags.called_connect = true;
         ++ statCounter.syscalls.sock.connects;
 
         x = connect(sock, AI->ai_addr, AI->ai_addrlen);
 
         // XXX: ICAP code refuses callbacks during a pending comm_ call
         // Async calls development will fix this.
         if (x == 0) {
             x = -1;
             xerrno = EINPROGRESS;
         } else if (x < 0) {
+            xerrno = errno;
             debugs(5,5, "comm_connect_addr: sock=" << sock << ", addrinfo( " <<
                    " flags=" << AI->ai_flags <<
                    ", family=" << AI->ai_family <<
                    ", socktype=" << AI->ai_socktype <<
                    ", protocol=" << AI->ai_protocol <<
                    ", &addr=" << AI->ai_addr <<
                    ", addrlen=" << AI->ai_addrlen <<
                    " )" );
             debugs(5, 9, "connect FD " << sock << ": (" << x << ") " << xstrerr(xerrno));
             debugs(14,9, "connecting to: " << address );
         }
 
     } else {
         errno = 0;
 #if _SQUID_NEWSOS6_
         /* Makoto MATSUSHITA <matusita@ics.es.osaka-u.ac.jp> */
         if (connect(sock, AI->ai_addr, AI->ai_addrlen) < 0)
             xerrno = errno;
 
         if (xerrno == EINVAL) {

