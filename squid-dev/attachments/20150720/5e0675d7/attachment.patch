Support %un (any available user name) format code for external ACLs.

The same %un code, with the same meaning is already supported in access.log.
In an external ACL request, it expands to the first available user name
from the following list of information sources:

  - authenticated user name, like %ul or %LOGIN
  - user name supplied by an external ACL to Squid via the "user=..."
    key=value pair, like %ue or %EXT_USER
  - SSL client name, like %us
  - ident user name, like %ui

Based on Amos Jeffries 2011 patch and "arronax28" design:
http://www.squid-cache.org/mail-archive/squid-dev/201112/0080.html

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2015-07-10 12:59:48 +0000
+++ src/cf.data.pre	2015-07-20 08:32:52 +0000
@@ -737,60 +737,66 @@
 			external acl lookups of this type. (default 20)
 
 	  children-startup=n
 			Minimum number of acl helper processes to spawn during
 			startup and reconfigure to service external acl lookups
 			of this type. (default 0)
 
 	  children-idle=n
 			Number of acl helper processes to keep ahead of traffic
 			loads. Squid will spawn this many at once whenever load
 			rises above the capabilities of existing processes.
 			Up to the value of children-max. (default 1)
 
 	  concurrency=n	concurrency level per process. Only used with helpers
 			capable of processing more than one query at a time.
 
 	  queue-size=N  The queue-size= option sets the maximum number of queued
 			requests. If the queued requests exceed queue size 
 			the acl is ignored.
 			The default value is set to 2*children-max.
 
 	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers.
 
 	  ipv4 / ipv6	IP protocol used to communicate with this helper.
 			The default is to auto-detect IPv6 and use it when available.
 
 
 	FORMAT specifications
 
 	  %LOGIN	Authenticated user login name
+	  %un		A user name. Expands to the first available name
+	  		from the following list of information sources:
+			- authenticated user name, like %ul or %LOGIN
+			- user name sent by an external ACL, like %EXT_USER
+			- SSL client name, like %us in logformat
+			- ident user name, like %ui in logformat
 	  %EXT_USER	Username from previous external acl
 	  %EXT_LOG	Log details from previous external acl
 	  %EXT_TAG	Tag from previous external acl
 	  %IDENT	Ident user name
 	  %SRC		Client IP
 	  %SRCPORT	Client source port
 	  %URI		Requested URI
 	  %DST		Requested host
 	  %PROTO	Requested URL scheme
 	  %PORT		Requested port
 	  %PATH		Requested URL path
 	  %METHOD	Request method
 	  %MYADDR	Squid interface address
 	  %MYPORT	Squid http_port number
 	  %PATH		Requested URL-path (including query-string if any)
 	  %USER_CERT	SSL User certificate in PEM format
 	  %USER_CERTCHAIN SSL User certificate chain in PEM format
 	  %USER_CERT_xx	SSL User certificate subject attribute xx
 	  %USER_CA_CERT_xx SSL User certificate issuer attribute xx
 	  %ssl::>sni	SSL client SNI sent to Squid
 	  %ssl::<cert_subject SSL server certificate DN
 	  %ssl::<cert_issuer SSL server certificate issuer DN
 
 	  %>{Header}	HTTP request header "Header"
 	  %>{Hdr:member}
 	  		HTTP request header "Hdr" list member "member"
 	  %>{Hdr:;member}
 	  		HTTP request header list member using ; as
 	  		list separator. ; can be any non-alphanumeric
 			character.
@@ -4122,60 +4128,66 @@
 	Time related format codes:
 
 		ts	Seconds since epoch
 		tu	subsecond time (milliseconds)
 		tl	Local time. Optional strftime format argument
 				default %d/%b/%Y:%H:%M:%S %z
 		tg	GMT time. Optional strftime format argument
 				default %d/%b/%Y:%H:%M:%S %z
 		tr	Response time (milliseconds)
 		dt	Total time spent making DNS lookups (milliseconds)
 		tS	Approximate master transaction start time in 
 			<full seconds since epoch>.<fractional seconds> format.
 			Currently, Squid considers the master transaction
 			started when a complete HTTP request header initiating
 			the transaction is received from the client. This is
 			the same value that Squid uses to calculate transaction
 			response time when logging %tr to access.log. Currently,
 			Squid uses millisecond resolution for %tS values,
 			similar to the default access.log "current time" field
 			(%ts.%03tu).
 
 	Access Control related format codes:
 
 		et	Tag returned by external acl
 		ea	Log string returned by external acl
 		un	User name (any available)
 		ul	User name from authentication
 		ue	User name from external acl helper
 		ui	User name from ident
 		us	User name from SSL
+		un	A user name. Expands to the first available name
+			from the following list of information sources:
+			- authenticated user name, like %ul
+			- user name supplied by an external ACL, like %ue
+			- SSL client name, like %us
+			- ident user name, like %ui
 		credentials Client credentials. The exact meaning depends on
 			the authentication scheme: For Basic authentication,
 			it is the password; for Digest, the realm sent by the
 			client; for NTLM and Negotiate, the client challenge
 			or client credentials prefixed with "YR " or "KK ".
 
 	HTTP related format codes:
 
 	    REQUEST
 
 		[http::]rm	Request method (GET/POST etc)
 		[http::]>rm	Request method from client
 		[http::]<rm	Request method sent to server or peer
 		[http::]ru	Request URL from client (historic, filtered for logging)
 		[http::]>ru	Request URL from client
 		[http::]<ru	Request URL sent to server or peer
 		[http::]>rs	Request URL scheme from client
 		[http::]<rs	Request URL scheme sent to server or peer
 		[http::]>rd	Request URL domain from client
 		[http::]<rd	Request URL domain sent to server or peer
 		[http::]>rP	Request URL port from client
 		[http::]<rP	Request URL port sent to server or peer
 		[http::]rp	Request URL path excluding hostname
 		[http::]>rp	Request URL path excluding hostname from client
 		[http::]<rp	Request URL path excluding hostname sent to server or peer
 		[http::]rv	Request protocol version
 		[http::]>rv	Request protocol version from client
 		[http::]<rv	Request protocol version sent to server or peer
 
 		[http::]>h	Original received request header.

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-07-19 13:23:01 +0000
+++ src/external_acl.cc	2015-07-20 08:44:31 +0000
@@ -392,60 +392,64 @@
         else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
             format->type = Format::LFT_CLIENT_REQ_URLPATH;
         else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
             format->type = Format::LFT_CLIENT_REQ_METHOD;
 #if USE_OPENSSL
         else if (strcmp(token, "%USER_CERT") == 0)
             format->type = Format::LFT_EXT_ACL_USER_CERT_RAW;
         else if (strcmp(token, "%USER_CERTCHAIN") == 0)
             format->type = Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW;
         else if (strncmp(token, "%USER_CERT_", 11) == 0) {
             format->type = Format::LFT_EXT_ACL_USER_CERT;
             format->header = xstrdup(token + 11);
         } else if (strncmp(token, "%USER_CA_CERT_", 14) == 0) {
             format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 14);
         } else if (strncmp(token, "%CA_CERT_", 9) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
             format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 9);
         } else if (strcmp(token, "%ssl::>sni") == 0)
             format->type = Format::LFT_SSL_CLIENT_SNI;
         else if (strcmp(token, "%ssl::<cert_subject") == 0)
             format->type = Format::LFT_SSL_SERVER_CERT_SUBJECT;
         else if (strcmp(token, "%ssl::<cert_issuer") == 0)
             format->type = Format::LFT_SSL_SERVER_CERT_ISSUER;
 #endif
 #if USE_AUTH
         else if (strcmp(token, "%EXT_USER") == 0 || strcmp(token, "%ue") == 0)
             format->type = Format::LFT_USER_EXTERNAL;
 #endif
+#if USE_AUTH || defined(USE_OPENSSL) || defined(USE_IDENT)
+        else if (strcmp(token, "%un") == 0)
+            format->type = Format::LFT_USER_NAME;
+#endif
         else if (strcmp(token, "%EXT_LOG") == 0 || strcmp(token, "%ea") == 0)
             format->type = Format::LFT_EXT_LOG;
         else if (strcmp(token, "%TAG") == 0  || strcmp(token, "%et") == 0)
             format->type = Format::LFT_TAG;
         else if (strcmp(token, "%ACL") == 0)
             format->type = Format::LFT_EXT_ACL_NAME;
         else if (strcmp(token, "%DATA") == 0)
             format->type = Format::LFT_EXT_ACL_DATA;
         else if (strcmp(token, "%%") == 0)
             format->type = Format::LFT_PERCENT;
         else {
             debugs(0, DBG_CRITICAL, "ERROR: Unknown Format token " << token);
             self_destruct();
         }
 
         *p = format;
         p = &format->next;
         token = ConfigParser::NextToken();
     }
 
     /* There must be at least one format token */
     if (!a->format)
         self_destruct();
 
     /* helper */
     if (!token)
         self_destruct();
 
     wordlistAdd(&a->cmdline, token);
 
@@ -497,60 +501,61 @@
             storeAppendPrintf(sentry, " cache=%d", node->cache_size);
 
         if (node->quote == external_acl::QUOTE_METHOD_SHELL)
             storeAppendPrintf(sentry, " protocol=2.5");
 
         for (external_acl_format::Pointer format = node->format; format!= NULL; format = format->next) {
             switch (format->type) {
 
             case Format::LFT_ADAPTED_REQUEST_HEADER:
                 storeAppendPrintf(sentry, " %%>ha{%s}", format->header);
                 break;
 
             case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
                 storeAppendPrintf(sentry, " %%>ha{%s:%s}", format->header, format->member);
                 break;
 
             case Format::LFT_REPLY_HEADER:
                 storeAppendPrintf(sentry, " %%<h{%s}", format->header);
                 break;
 
             case Format::LFT_REPLY_HEADER_ELEM:
                 storeAppendPrintf(sentry, " %%<h{%s:%s}", format->header, format->member);
                 break;
 
 #define DUMP_EXT_ACL_TYPE_FMT(a, fmt, ...) \
             case Format::LFT_##a: \
                 storeAppendPrintf(sentry, fmt, ##__VA_ARGS__); \
                 break
 #if USE_AUTH
                 DUMP_EXT_ACL_TYPE_FMT(USER_LOGIN," %%ul");
+                DUMP_EXT_ACL_TYPE_FMT(USER_NAME," %%un");
 #endif
 #if USE_IDENT
 
                 DUMP_EXT_ACL_TYPE_FMT(USER_IDENT," %%ui");
 #endif
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_IP_ADDRESS," %%>a");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_PORT," %%>p");
 #if USE_SQUID_EUI
                 DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI48," %%SRCEUI48");
                 DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI64," %%SRCEUI64");
 #endif
                 DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_IP," %%>la");
                 DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_PORT," %%>lp");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URI," %%>ru");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLDOMAIN," %%>rd");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLSCHEME," %%>rs");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPORT," %%>rP");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPATH," %%>rp");
                 DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_METHOD," %%>rm");
 #if USE_OPENSSL
                 DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT_RAW, " %%USER_CERT_RAW");
                 DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
                 DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT, " %%USER_CERT_%s", format->header);
                 DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
                 DUMP_EXT_ACL_TYPE_FMT(SSL_CLIENT_SNI, "%%ssl::>sni");
                 DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_SUBJECT, "%%ssl::<cert_subject");
                 DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_ISSUER, "%%ssl::<cert_issuer");
 #endif
 #if USE_AUTH
                 DUMP_EXT_ACL_TYPE_FMT(USER_EXTERNAL," %%ue");
@@ -860,60 +865,72 @@
 {
     external_acl_data const *acl = data;
     SBufList rv;
     rv.push_back(SBuf(acl->def->name));
 
     for (wordlist *arg = acl->arguments; arg; arg = arg->next) {
         SBuf s;
         s.Printf(" %s", arg->key);
         rv.push_back(s);
     }
 
     return rv;
 }
 
 /******************************************************************
  * external_acl cache
  */
 
 static void
 external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     // this must not be done when nothing is being cached.
     if (def->cache_size <= 0 || (def->ttl <= 0 && entry->result == 1) || (def->negative_ttl <= 0 && entry->result != 1))
         return;
 
     dlinkDelete(&entry->lru, &def->lru_list);
     ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
     dlinkAdd(e, &entry->lru, &def->lru_list);
 }
 
+#if USE_OPENSSL
+static const char *
+external_acl_ssl_get_user_attribute(const ACLFilledChecklist &ch, const char *attr)
+{
+    if (ch.conn() != NULL && Comm::IsConnOpen(ch.conn()->clientConnection)) {
+        if (SSL *ssl = fd_table[ch.conn()->clientConnection->fd].ssl)
+            return sslGetUserAttribute(ssl, attr);
+    }
+    return NULL;
+}
+#endif
+
 static char *
 makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 {
     static MemBuf mb;
     char buf[256];
     int first = 1;
     wordlist *arg;
     HttpRequest *request = ch->request;
     HttpReply *reply = ch->reply;
     mb.reset();
     bool data_used = false;
 
     for (external_acl_format::Pointer format = acl_data->def->format; format != NULL; format = format->next) {
         const char *str = NULL;
         String sb;
 
         switch (format->type) {
 #if USE_AUTH
         case Format::LFT_USER_LOGIN:
             // if this ACL line was the cause of credentials fetch
             // they may not already be in the checklist
             if (ch->auth_user_request == NULL && ch->request)
                 ch->auth_user_request = ch->request->auth_user_request;
 
             if (ch->auth_user_request != NULL)
                 str = ch->auth_user_request->username();
             break;
 #endif
 #if USE_IDENT
         case Format::LFT_USER_IDENT:
@@ -1023,108 +1040,122 @@
                 if (format->header_id == -1)
                     sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
                 else
                     sb = reply->header.getListMember(format->header_id, format->member, format->separator);
                 str = sb.termedBuf();
             }
             break;
 
 #if USE_OPENSSL
 
         case Format::LFT_EXT_ACL_USER_CERT_RAW:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
                     str = sslGetUserCertificatePEM(ssl);
             }
 
             break;
 
         case Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
                     str = sslGetUserCertificateChainPEM(ssl);
             }
 
             break;
 
         case Format::LFT_EXT_ACL_USER_CERT:
 
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserAttribute(ssl, format->header);
-            }
-
+            str = external_acl_ssl_get_user_attribute(*ch, format->header);
             break;
 
         case Format::LFT_EXT_ACL_USER_CA_CERT:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
                     str = sslGetCAAttribute(ssl, format->header);
             }
 
             break;
 
         case Format::LFT_SSL_CLIENT_SNI:
             if (ch->conn() != NULL) {
                 if (Ssl::ServerBump * srvBump = ch->conn()->serverBump()) {
                     if (!srvBump->clientSni.isEmpty())
                         str = srvBump->clientSni.c_str();
                 }
             }
             break;
 
         case Format::LFT_SSL_SERVER_CERT_SUBJECT:
         case Format::LFT_SSL_SERVER_CERT_ISSUER: {
             X509 *serverCert = NULL;
             if (ch->serverCert.get())
                 serverCert = ch->serverCert.get();
             else if (ch->conn() && ch->conn()->serverBump())
                 serverCert = ch->conn()->serverBump()->serverCert.get();
 
             if (serverCert) {
                 if (format->type == Format::LFT_SSL_SERVER_CERT_SUBJECT)
                     str = Ssl::GetX509UserAttribute(serverCert, "DN");
                 else
                     str = Ssl::GetX509CAAttribute(serverCert, "DN");
             }
             break;
         }
 
 #endif
 #if USE_AUTH
         case Format::LFT_USER_EXTERNAL:
             str = request->extacl_user.termedBuf();
             break;
 #endif
+        case Format::LFT_USER_NAME:
+            /* find the first available name from various sources */
+#if USE_AUTH
+            if (ch->auth_user_request != NULL)
+                str = ch->auth_user_request->username();
+            if ((!str || !*str) &&
+                (request->extacl_user.size() > 0 && request->extacl_user[0] != '-'))
+                str = request->extacl_user.termedBuf();
+#endif
+#if USE_OPENSSL
+            if (!str || !*str)
+                str = external_acl_ssl_get_user_attribute(*ch, "CN");
+#endif
+#if USE_IDENT
+            if (!str || !*str)
+                str = ch->rfc931;
+#endif
+            break;
         case Format::LFT_EXT_LOG:
             str = request->extacl_log.termedBuf();
             break;
         case Format::LFT_TAG:
             str = request->tag.termedBuf();
             break;
         case Format::LFT_EXT_ACL_NAME:
             str = acl_data->name;
             break;
         case Format::LFT_EXT_ACL_DATA:
             data_used = true;
             for (arg = acl_data->arguments; arg; arg = arg->next) {
                 if (!first)
                     sb.append(" ", 1);
 
                 if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
                     const char *quoted = rfc1738_escape(arg->key);
                     sb.append(quoted, strlen(quoted));
                 } else {
                     static MemBuf mb2;
                     mb2.init();
                     strwordquote(&mb2, arg->key);
                     sb.append(mb2.buf, mb2.size);
                     mb2.clean();
                 }
 
                 first = 0;
             }
             break;
         case Format::LFT_PERCENT:

