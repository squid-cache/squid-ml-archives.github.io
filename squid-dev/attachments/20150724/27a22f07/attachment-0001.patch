When SBuf chop()s away everything, always clear the buffer.

The old code was trying to make the clearance decision without
normalizing parameters first and missed most cases as the result.

=== modified file 'src/SBuf.cc'
--- src/SBuf.cc	2015-03-17 02:51:04 +0000
+++ src/SBuf.cc	2015-07-24 21:33:45 +0000
@@ -548,46 +548,52 @@ SBuf::forceSize(size_type newSize)
     store_->size = newSize;
 }
 
 const char*
 SBuf::c_str()
 {
     ++stats.rawAccess;
     /* null-terminate the current buffer, by hand-appending a \0 at its tail but
      * without increasing its length. May COW, the side-effect is to guarantee that
      * the MemBlob's tail is availabe for us to use */
     *rawSpace(1) = '\0';
     ++store_->size;
     ++stats.setChar;
     ++stats.nulTerminate;
     return buf();
 }
 
 SBuf&
 SBuf::chop(size_type pos, size_type n)
 {
-    if (pos == npos || pos > length() || n == 0) {
+    if (pos == npos || pos > length())
+        pos = length();
+
+    if (n == npos || (pos+n) > length())
+        n = length() - pos;
+
+    // if there will be nothing left, reset the buffer while we can
+    if (pos == length() || n == 0) {
         clear();
         return *this;
     }
-    if (n == npos || (pos+n) > length())
-        n = length()-pos;
+
     ++stats.chop;
     off_ += pos;
     len_ = n;
     return *this;
 }
 
 SBuf&
 SBuf::trim(const SBuf &toRemove, bool atBeginning, bool atEnd)
 {
     ++stats.trim;
     if (atEnd) {
         const char *p = bufEnd()-1;
         while (!isEmpty() && memchr(toRemove.buf(), *p, toRemove.length()) != NULL) {
             //current end-of-buf is in the searched set
             --len_;
             --p;
         }
     }
     if (atBeginning) {
         const char *p = buf();
