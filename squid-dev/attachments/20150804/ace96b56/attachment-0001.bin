# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20150804210409-cnicdl1nrgnsbtd5
# target_branch: ../trunk
# testament_sha1: 2247f879109fac52bee41b42de4c7dc67d37aee6
# timestamp: 2015-08-04 23:06:16 +0200
# base_revision_id: squid3@treenet.co.nz-20150804053235-\
#   t8mam58ktdj02b2b
# 
# Begin patch
=== modified file 'src/AclRegs.cc'
--- src/AclRegs.cc	2015-07-27 12:51:43 +0000
+++ src/AclRegs.cc	2015-08-04 19:57:07 +0000
@@ -102,7 +102,7 @@
 #endif
 
 ACL::Prototype ACLBrowser::RegistryProtoype(&ACLBrowser::RegistryEntry_, "browser");
-ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_USER_AGENT>::Instance(), "browser");
+ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>::Instance(), "browser");
 ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
 ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&ACLDestinationDomain::LiteralRegistryEntry_, "dstdomain");
 ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain", DestinationDomainFlags);
@@ -144,11 +144,11 @@
 ACL::Prototype ACLRandom::RegistryProtoype(&ACLRandom::RegistryEntry_, "random");
 ACLRandom ACLRandom::RegistryEntry_("random");
 ACL::Prototype ACLReferer::RegistryProtoype(&ACLReferer::RegistryEntry_, "referer_regex");
-ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_REFERER>::Instance(), "referer_regex");
+ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::REFERER>::Instance(), "referer_regex");
 ACL::Prototype ACLReplyMIMEType::RegistryProtoype(&ACLReplyMIMEType::RegistryEntry_, "rep_mime_type");
-ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::Instance(), "rep_mime_type");
+ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "rep_mime_type");
 ACL::Prototype ACLRequestMIMEType::RegistryProtoype(&ACLRequestMIMEType::RegistryEntry_, "req_mime_type");
-ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::Instance(), "req_mime_type");
+ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "req_mime_type");
 ACL::Prototype ACLSourceDomain::LiteralRegistryProtoype(&ACLSourceDomain::LiteralRegistryEntry_, "srcdomain");
 ACLStrategised<char const *> ACLSourceDomain::LiteralRegistryEntry_(new ACLDomainData, ACLSourceDomainStrategy::Instance(), "srcdomain");
 ACL::Prototype ACLSourceDomain::RegexRegistryProtoype(&ACLSourceDomain::RegexRegistryEntry_, "srcdom_regex");

=== modified file 'src/HttpHdrCc.cc'
--- src/HttpHdrCc.cc	2015-03-05 06:44:43 +0000
+++ src/HttpHdrCc.cc	2015-08-03 13:56:30 +0000
@@ -9,6 +9,7 @@
 /* DEBUG: section 65    HTTP Cache Control Header */
 
 #include "squid.h"
+#include "base/LookupTable.h"
 #include "HttpHdrCc.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldStat.h"
@@ -21,46 +22,28 @@
 #include "util.h"
 
 #include <map>
-
-/* a row in the table used for parsing cache control header and statistics */
-class HttpHeaderCcFields
-{
-public:
-    HttpHeaderCcFields() : name(NULL), id(CC_BADHDR), stat() {}
-    HttpHeaderCcFields(const char *aName, http_hdr_cc_type aTypeId) : name(aName), id(aTypeId) {}
-    HttpHeaderCcFields(const HttpHeaderCcFields &f) : name(f.name), id(f.id) {}
-    // nothing to do as name is a pointer to global static string
-    ~HttpHeaderCcFields() {}
-
-    const char *name;
-    http_hdr_cc_type id;
-    HttpHeaderFieldStat stat;
-
-private:
-    HttpHeaderCcFields &operator =(const HttpHeaderCcFields &); // not implemented
-};
-
-/* order must match that of enum http_hdr_cc_type. The constraint is verified at initialization time */
-static HttpHeaderCcFields CcAttrs[CC_ENUM_END] = {
-    HttpHeaderCcFields("public", CC_PUBLIC),
-    HttpHeaderCcFields("private", CC_PRIVATE),
-    HttpHeaderCcFields("no-cache", CC_NO_CACHE),
-    HttpHeaderCcFields("no-store", CC_NO_STORE),
-    HttpHeaderCcFields("no-transform", CC_NO_TRANSFORM),
-    HttpHeaderCcFields("must-revalidate", CC_MUST_REVALIDATE),
-    HttpHeaderCcFields("proxy-revalidate", CC_PROXY_REVALIDATE),
-    HttpHeaderCcFields("max-age", CC_MAX_AGE),
-    HttpHeaderCcFields("s-maxage", CC_S_MAXAGE),
-    HttpHeaderCcFields("max-stale", CC_MAX_STALE),
-    HttpHeaderCcFields("min-fresh", CC_MIN_FRESH),
-    HttpHeaderCcFields("only-if-cached", CC_ONLY_IF_CACHED),
-    HttpHeaderCcFields("stale-if-error", CC_STALE_IF_ERROR),
-    HttpHeaderCcFields("Other,", CC_OTHER) /* ',' will protect from matches */
-};
-
-/// Map an header name to its type, to expedite parsing
-typedef std::map<const SBuf,http_hdr_cc_type> CcNameToIdMap_t;
-static CcNameToIdMap_t CcNameToIdMap;
+#include <vector>
+
+// invariant: row[j].id == j
+static LookupTable<http_hdr_cc_type>::Record CcAttrs[] = {
+    {"public", CC_PUBLIC},
+    {"private", CC_PRIVATE},
+    {"no-cache", CC_NO_CACHE},
+    {"no-store", CC_NO_STORE},
+    {"no-transform", CC_NO_TRANSFORM},
+    {"must-revalidate", CC_MUST_REVALIDATE},
+    {"proxy-revalidate", CC_PROXY_REVALIDATE},
+    {"max-age", CC_MAX_AGE},
+    {"s-maxage", CC_S_MAXAGE},
+    {"max-stale", CC_MAX_STALE},
+    {"min-fresh", CC_MIN_FRESH},
+    {"only-if-cached", CC_ONLY_IF_CACHED},
+    {"stale-if-error", CC_STALE_IF_ERROR},
+    {"Other,", CC_OTHER}, /* ',' will protect from matches */
+    {nullptr, CC_ENUM_END}
+};
+LookupTable<http_hdr_cc_type> ccLookupTable(CC_OTHER,CcAttrs);
+std::vector<HttpHeaderFieldStat> ccHeaderStats(CC_ENUM_END);
 
 /// used to walk a table of http_header_cc_type structs
 http_hdr_cc_type &operator++ (http_hdr_cc_type &aHeader)
@@ -74,12 +57,9 @@
 void
 httpHdrCcInitModule(void)
 {
-    /* build lookup and accounting structures */
-    for (int32_t i = 0; i < CC_ENUM_END; ++i) {
-        const HttpHeaderCcFields &f=CcAttrs[i];
-        assert(i == f.id); /* verify assumption: the id is the key into the array */
-        const SBuf k(f.name);
-        CcNameToIdMap[k]=f.id;
+    // check invariant on initialization table
+    for (int j = 0; CcAttrs[j].name != nullptr; ++j) {
+        assert (CcAttrs[j].id == j);
     }
 }
 
@@ -87,7 +67,6 @@
 void
 httpHdrCcCleanModule(void)
 {
-    // HdrCcNameToIdMap is self-cleaning
 }
 
 void
@@ -102,7 +81,6 @@
     const char *item;
     const char *p;      /* '=' parameter */
     const char *pos = NULL;
-    http_hdr_cc_type type;
     int ilen;
     int nlen;
 
@@ -119,17 +97,13 @@
         }
 
         /* find type */
-        const CcNameToIdMap_t::const_iterator i=CcNameToIdMap.find(SBuf(item,nlen));
-        if (i==CcNameToIdMap.end())
-            type=CC_OTHER;
-        else
-            type=i->second;
+        const http_hdr_cc_type type = ccLookupTable.lookup(SBuf(item,nlen));
 
         // ignore known duplicate directives
         if (isSet(type)) {
             if (type != CC_OTHER) {
                 debugs(65, 2, "hdr cc: ignoring duplicate cache-directive: near '" << item << "' in '" << str << "'");
-                ++CcAttrs[type].stat.repCount;
+                ++ ccHeaderStats[type].repCount;
                 continue;
             }
         }
@@ -300,10 +274,9 @@
 void
 httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist)
 {
-    http_hdr_cc_type c;
     assert(cc);
 
-    for (c = CC_PUBLIC; c < CC_ENUM_END; ++c)
+    for (http_hdr_cc_type c = CC_PUBLIC; c < CC_ENUM_END; ++c)
         if (cc->isSet(c))
             hist->count(c);
 }
@@ -312,8 +285,8 @@
 httpHdrCcStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     extern const HttpHeaderStat *dump_stat; /* argh! */
-    const int id = (int) val;
-    const int valid_id = id >= 0 && id < CC_ENUM_END;
+    const int id = static_cast<int>(val);
+    const int valid_id = id < CC_ENUM_END;
     const char *name = valid_id ? CcAttrs[id].name : "INVALID";
 
     if (count || valid_id)

=== modified file 'src/HttpHdrCc.h'
--- src/HttpHdrCc.h	2015-03-03 11:43:26 +0000
+++ src/HttpHdrCc.h	2015-08-04 14:32:37 +0000
@@ -9,12 +9,31 @@
 #ifndef SQUID_HTTPHDRCC_H
 #define SQUID_HTTPHDRCC_H
 
+#include "dlink.h"
 #include "enums.h"
 #include "mem/forward.h"
 #include "SquidString.h"
 
 class Packable;
 
+typedef enum {
+    CC_PUBLIC = 0,
+    CC_PRIVATE,
+    CC_NO_CACHE,
+    CC_NO_STORE,
+    CC_NO_TRANSFORM,
+    CC_MUST_REVALIDATE,
+    CC_PROXY_REVALIDATE,
+    CC_MAX_AGE,
+    CC_S_MAXAGE,
+    CC_MAX_STALE,
+    CC_MIN_FRESH,
+    CC_ONLY_IF_CACHED,
+    CC_STALE_IF_ERROR,
+    CC_OTHER,
+    CC_ENUM_END /* also used to mean "invalid" */
+} http_hdr_cc_type;
+
 /** Http Cache-Control header representation
  *
  * Store and parse the Cache-Control HTTP header.

=== modified file 'src/HttpHdrSc.cc'
--- src/HttpHdrSc.cc	2015-05-26 18:12:08 +0000
+++ src/HttpHdrSc.cc	2015-08-04 14:32:37 +0000
@@ -9,63 +9,54 @@
 /* DEBUG: section 90    HTTP Cache Control Header */
 
 #include "squid.h"
+#include "base/LookupTable.h"
+#include "dlink.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
-#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
+#include "HttpHdrScTarget.h"
 #include "Store.h"
 #include "StrList.h"
 #include "util.h"
 
 #include <map>
-
-/* a row in the table used for parsing surrogate-control header and statistics */
-typedef struct {
-    const char *name;
-    http_hdr_sc_type id;
-    HttpHeaderFieldStat stat;
-} HttpHeaderScFields;
+#include <vector>
 
 /* this table is used for parsing surrogate control header */
 /* order must match that of enum http_hdr_sc_type. The constraint is verified at initialization time */
 //todo: implement constraint
-static const HttpHeaderFieldAttrs ScAttrs[SC_ENUM_END] = {
-    HttpHeaderFieldAttrs("no-store", (http_hdr_type)SC_NO_STORE),
-    HttpHeaderFieldAttrs("no-store-remote", (http_hdr_type)SC_NO_STORE_REMOTE),
-    HttpHeaderFieldAttrs("max-age", (http_hdr_type)SC_MAX_AGE),
-    HttpHeaderFieldAttrs("content", (http_hdr_type)SC_CONTENT),
-    HttpHeaderFieldAttrs("Other,", (http_hdr_type)SC_OTHER) /* ',' will protect from matches */
+static const LookupTable<http_hdr_sc_type>::Record ScAttrs[] {
+    {"no-store", SC_NO_STORE},
+    {"no-store-remote", SC_NO_STORE_REMOTE},
+    {"max-age", SC_MAX_AGE},
+    {"content", SC_CONTENT},
+    {"Other,", SC_OTHER}, /* ',' will protect from matches */
+    {nullptr, SC_ENUM_END} /* SC_ENUM_END taken as invalid value */
 };
-
-HttpHeaderFieldInfo *ScFieldsInfo = NULL;
-
+LookupTable<http_hdr_sc_type> scLookupTable(SC_ENUM_END, ScAttrs);
+std::vector<HttpHeaderFieldStat> scHeaderStats(SC_ENUM_END);
+
+// used when iterating over flags
 http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader)
 {
-    int tmp = (int)aHeader;
-    aHeader = (http_hdr_sc_type)(++tmp);
+    int tmp = static_cast<int>(aHeader);
+    aHeader = static_cast<http_hdr_sc_type>(++tmp);
     return aHeader;
 }
 
-int operator - (http_hdr_sc_type const &anSc, http_hdr_sc_type const &anSc2)
-{
-    return (int)anSc - (int)anSc2;
-}
-
-/* module initialization */
-
 void
 httpHdrScInitModule(void)
 {
-    ScFieldsInfo = httpHeaderBuildFieldsInfo(ScAttrs, SC_ENUM_END);
+    // check invariant on ScAttrs
+    for (int i = 0; ScAttrs[i].name != nullptr; ++i)
+        assert(i == ScAttrs[i].id);
 }
 
 void
 httpHdrScCleanModule(void)
 {
-    httpHeaderDestroyFieldsInfo(ScFieldsInfo, SC_ENUM_END);
-    ScFieldsInfo = NULL;
 }
 
 /* implementation */
@@ -94,7 +85,7 @@
     const char *pos = NULL;
     const char *target = NULL; /* ;foo */
     const char *temp = NULL; /* temp buffer */
-    int type;
+    http_hdr_sc_type type;
     int ilen, vlen;
     int initiallen;
     HttpHdrScTarget *sct;
@@ -120,11 +111,9 @@
         }
 
         /* find type */
-        /* TODO: use a type-safe map-based lookup */
-        type = httpHeaderIdByName(item, ilen,
-                                  ScFieldsInfo, SC_ENUM_END);
+        type = scLookupTable.lookup(SBuf(item,ilen));
 
-        if (type < 0) {
+        if (type == SC_ENUM_END) {
             debugs(90, 2, "hdr sc: unknown control-directive: near '" << item << "' in '" << str << "'");
             type = SC_OTHER;
         }
@@ -147,11 +136,11 @@
 
         safe_free (temp);
 
-        if (sct->isSet(static_cast<http_hdr_sc_type>(type))) {
+        if (sct->isSet(type)) {
             if (type != SC_OTHER)
                 debugs(90, 2, "hdr sc: ignoring duplicate control-directive: near '" << item << "' in '" << str << "'");
 
-            ++ ScFieldsInfo[type].stat.repCount;
+            ++ scHeaderStats[type].repCount;
 
             continue;
         }
@@ -245,8 +234,7 @@
         if (isSet(flag) && flag != SC_OTHER) {
 
             /* print option name */
-            p->appendf((pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                       SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
+            p->appendf((pcount ? ", %s" : "%s"), ScAttrs[flag].name);
 
             /* handle options with values */
 
@@ -307,8 +295,8 @@
 {
     extern const HttpHeaderStat *dump_stat;     /* argh! */
     const int id = (int) val;
-    const int valid_id = id >= 0 && id < SC_ENUM_END;
-    const char *name = valid_id ? ScFieldsInfo[id].name.termedBuf() : "INVALID";
+    const bool valid_id = id >= 0 && id < SC_ENUM_END;
+    const char *name = valid_id ? ScAttrs[id].name : "INVALID";
 
     if (count || valid_id)
         storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
@@ -320,8 +308,8 @@
 {
     extern const HttpHeaderStat *dump_stat; /* argh! */
     const int id = (int) val;
-    const int valid_id = id >= 0 && id < SC_ENUM_END;
-    const char *name = valid_id ? ScFieldsInfo[id].name.termedBuf() : "INVALID";
+    const bool valid_id = id >= 0 && id < SC_ENUM_END;
+    const char *name = valid_id ? ScAttrs[id].name : "INVALID";
 
     if (count || valid_id)
         storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
@@ -369,3 +357,12 @@
     return NULL;
 }
 
+void
+HttpHdrSc::addTarget(HttpHdrScTarget *t) {
+    dlinkAdd(t, &t->node, &targets);
+}
+
+void
+HttpHdrSc::addTargetAtTail(HttpHdrScTarget *t) {
+    dlinkAddTail (t, &t->node, &targets);
+}

=== modified file 'src/HttpHdrSc.h'
--- src/HttpHdrSc.h	2015-03-03 11:43:26 +0000
+++ src/HttpHdrSc.h	2015-08-04 14:32:37 +0000
@@ -9,12 +9,25 @@
 #ifndef SQUID_HTTPHDRSURROGATECONTROL_H
 #define SQUID_HTTPHDRSURROGATECONTROL_H
 
-#include "HttpHdrScTarget.h"
+#include "dlink.h"
+#include "mem/AllocatorProxy.h"
+#include "SquidString.h"
 
+class HttpHdrScTarget;
 class StatHist;
+class Packable;
+class StoreEntry;
+
+typedef enum {
+    SC_NO_STORE,
+    SC_NO_STORE_REMOTE,
+    SC_MAX_AGE,
+    SC_CONTENT,
+    SC_OTHER,
+    SC_ENUM_END /* also used to mean "invalid" */
+} http_hdr_sc_type;
 
 /* http surogate control header field */
-
 class HttpHdrSc
 {
     MEMPROXY_CLASS(HttpHdrSc);
@@ -29,12 +42,8 @@
     void updateStats(StatHist *) const;
     HttpHdrScTarget * getMergedTarget (const char *ourtarget); //todo: make const?
     void setMaxAge(char const *target, int max_age);
-    void addTarget(HttpHdrScTarget *t) {
-        dlinkAdd(t, &t->node, &targets);
-    }
-    void addTargetAtTail(HttpHdrScTarget *t) {
-        dlinkAddTail (t, &t->node, &targets);
-    }
+    void addTarget(HttpHdrScTarget *t);
+    void addTargetAtTail(HttpHdrScTarget *t);
 
     dlink_list targets;
 private:

=== modified file 'src/HttpHdrScTarget.cc'
--- src/HttpHdrScTarget.cc	2015-01-13 07:25:36 +0000
+++ src/HttpHdrScTarget.cc	2015-08-04 14:32:37 +0000
@@ -10,6 +10,7 @@
 
 #include "squid.h"
 #include "HttpHdrSc.h"
+#include "HttpHdrScTarget.h"
 #include "StatHist.h"
 
 http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader);

=== modified file 'src/HttpHdrScTarget.h'
--- src/HttpHdrScTarget.h	2015-03-03 11:43:26 +0000
+++ src/HttpHdrScTarget.h	2015-08-04 14:32:37 +0000
@@ -11,6 +11,7 @@
 
 #include "defines.h"
 #include "dlink.h"
+#include "HttpHdrSc.h"
 #include "mem/forward.h"
 #include "SquidString.h"
 #include "typedefs.h"

=== modified file 'src/HttpHeader.cc'
--- src/HttpHeader.cc	2015-03-04 16:02:53 +0000
+++ src/HttpHeader.cc	2015-08-04 21:04:09 +0000
@@ -9,6 +9,7 @@
 /* DEBUG: section 55    HTTP Header */
 
 #include "squid.h"
+#include "base/LookupTable.h"
 #include "base64.h"
 #include "globals.h"
 #include "HttpHdrCc.h"
@@ -59,266 +60,160 @@
  * local constants and vars
  */
 
-/*
- * A table with major attributes for every known field.
- * We calculate name lengths and reorganize this array on start up.
- * After reorganization, field id can be used as an index to the table.
- */
-static const HttpHeaderFieldAttrs HeadersAttrs[] = {
-    HttpHeaderFieldAttrs("Accept", HDR_ACCEPT, ftStr),
-
-    HttpHeaderFieldAttrs("Accept-Charset", HDR_ACCEPT_CHARSET, ftStr),
-    HttpHeaderFieldAttrs("Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr),
-    HttpHeaderFieldAttrs("Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr),
-    HttpHeaderFieldAttrs("Accept-Ranges", HDR_ACCEPT_RANGES, ftStr),
-    HttpHeaderFieldAttrs("Age", HDR_AGE, ftInt),
-    HttpHeaderFieldAttrs("Allow", HDR_ALLOW, ftStr),
-    HttpHeaderFieldAttrs("Alternate-Protocol", HDR_ALTERNATE_PROTOCOL, ftStr),
-    HttpHeaderFieldAttrs("Authorization", HDR_AUTHORIZATION, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("Cache-Control", HDR_CACHE_CONTROL, ftPCc),
-    HttpHeaderFieldAttrs("Connection", HDR_CONNECTION, ftStr),
-    HttpHeaderFieldAttrs("Content-Base", HDR_CONTENT_BASE, ftStr),
-    HttpHeaderFieldAttrs("Content-Disposition", HDR_CONTENT_DISPOSITION, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("Content-Encoding", HDR_CONTENT_ENCODING, ftStr),
-    HttpHeaderFieldAttrs("Content-Language", HDR_CONTENT_LANGUAGE, ftStr),
-    HttpHeaderFieldAttrs("Content-Length", HDR_CONTENT_LENGTH, ftInt64),
-    HttpHeaderFieldAttrs("Content-Location", HDR_CONTENT_LOCATION, ftStr),
-    HttpHeaderFieldAttrs("Content-MD5", HDR_CONTENT_MD5, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("Content-Range", HDR_CONTENT_RANGE, ftPContRange),
-    HttpHeaderFieldAttrs("Content-Type", HDR_CONTENT_TYPE, ftStr),
-    HttpHeaderFieldAttrs("Cookie", HDR_COOKIE, ftStr),
-    HttpHeaderFieldAttrs("Cookie2", HDR_COOKIE2, ftStr),
-    HttpHeaderFieldAttrs("Date", HDR_DATE, ftDate_1123),
-    HttpHeaderFieldAttrs("ETag", HDR_ETAG, ftETag),
-    HttpHeaderFieldAttrs("Expect", HDR_EXPECT, ftStr),
-    HttpHeaderFieldAttrs("Expires", HDR_EXPIRES, ftDate_1123),
-    HttpHeaderFieldAttrs("Forwarded", HDR_FORWARDED, ftStr),
-    HttpHeaderFieldAttrs("From", HDR_FROM, ftStr),
-    HttpHeaderFieldAttrs("Host", HDR_HOST, ftStr),
-    HttpHeaderFieldAttrs("HTTP2-Settings", HDR_HTTP2_SETTINGS, ftStr), /* for now */
-    HttpHeaderFieldAttrs("If-Match", HDR_IF_MATCH, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123),
-    HttpHeaderFieldAttrs("If-None-Match", HDR_IF_NONE_MATCH, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag),
-    HttpHeaderFieldAttrs("If-Unmodified-Since", HDR_IF_UNMODIFIED_SINCE, ftDate_1123),
-    HttpHeaderFieldAttrs("Keep-Alive", HDR_KEEP_ALIVE, ftStr),
-    HttpHeaderFieldAttrs("Key", HDR_KEY, ftStr),
-    HttpHeaderFieldAttrs("Last-Modified", HDR_LAST_MODIFIED, ftDate_1123),
-    HttpHeaderFieldAttrs("Link", HDR_LINK, ftStr),
-    HttpHeaderFieldAttrs("Location", HDR_LOCATION, ftStr),
-    HttpHeaderFieldAttrs("Max-Forwards", HDR_MAX_FORWARDS, ftInt64),
-    HttpHeaderFieldAttrs("Mime-Version", HDR_MIME_VERSION, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("Negotiate", HDR_NEGOTIATE, ftStr),
-    HttpHeaderFieldAttrs("Origin", HDR_ORIGIN, ftStr),
-    HttpHeaderFieldAttrs("Pragma", HDR_PRAGMA, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Authorization", HDR_PROXY_AUTHORIZATION, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Connection", HDR_PROXY_CONNECTION, ftStr),
-    HttpHeaderFieldAttrs("Proxy-support", HDR_PROXY_SUPPORT, ftStr),
-    HttpHeaderFieldAttrs("Public", HDR_PUBLIC, ftStr),
-    HttpHeaderFieldAttrs("Range", HDR_RANGE, ftPRange),
-    HttpHeaderFieldAttrs("Referer", HDR_REFERER, ftStr),
-    HttpHeaderFieldAttrs("Request-Range", HDR_REQUEST_RANGE, ftPRange), /* usually matches HDR_RANGE */
-    HttpHeaderFieldAttrs("Retry-After", HDR_RETRY_AFTER, ftStr),    /* for now (ftDate_1123 or ftInt!) */
-    HttpHeaderFieldAttrs("Server", HDR_SERVER, ftStr),
-    HttpHeaderFieldAttrs("Set-Cookie", HDR_SET_COOKIE, ftStr),
-    HttpHeaderFieldAttrs("Set-Cookie2", HDR_SET_COOKIE2, ftStr),
-    HttpHeaderFieldAttrs("TE", HDR_TE, ftStr),
-    HttpHeaderFieldAttrs("Title", HDR_TITLE, ftStr),
-    HttpHeaderFieldAttrs("Trailer", HDR_TRAILER, ftStr),
-    HttpHeaderFieldAttrs("Transfer-Encoding", HDR_TRANSFER_ENCODING, ftStr),
-    HttpHeaderFieldAttrs("Translate", HDR_TRANSLATE, ftStr),    /* for now. may need to crop */
-    HttpHeaderFieldAttrs("Unless-Modified-Since", HDR_UNLESS_MODIFIED_SINCE, ftStr),  /* for now ignore. may need to crop */
-    HttpHeaderFieldAttrs("Upgrade", HDR_UPGRADE, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("User-Agent", HDR_USER_AGENT, ftStr),
-    HttpHeaderFieldAttrs("Vary", HDR_VARY, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("Via", HDR_VIA, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("Warning", HDR_WARNING, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftStr),
-    HttpHeaderFieldAttrs("Authentication-Info", HDR_AUTHENTICATION_INFO, ftStr),
-    HttpHeaderFieldAttrs("X-Cache", HDR_X_CACHE, ftStr),
-    HttpHeaderFieldAttrs("X-Cache-Lookup", HDR_X_CACHE_LOOKUP, ftStr),
-    HttpHeaderFieldAttrs("X-Forwarded-For", HDR_X_FORWARDED_FOR, ftStr),
-    HttpHeaderFieldAttrs("X-Request-URI", HDR_X_REQUEST_URI, ftStr),
-    HttpHeaderFieldAttrs("X-Squid-Error", HDR_X_SQUID_ERROR, ftStr),
-#if X_ACCELERATOR_VARY
-    HttpHeaderFieldAttrs("X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, ftStr),
-#endif
-#if USE_ADAPTATION
-    HttpHeaderFieldAttrs("X-Next-Services", HDR_X_NEXT_SERVICES, ftStr),
-#endif
-    HttpHeaderFieldAttrs("Surrogate-Capability", HDR_SURROGATE_CAPABILITY, ftStr),
-    HttpHeaderFieldAttrs("Surrogate-Control", HDR_SURROGATE_CONTROL, ftPSc),
-    HttpHeaderFieldAttrs("Front-End-Https", HDR_FRONT_END_HTTPS, ftStr),
-    HttpHeaderFieldAttrs("FTP-Command", HDR_FTP_COMMAND, ftStr),
-    HttpHeaderFieldAttrs("FTP-Arguments", HDR_FTP_ARGUMENTS, ftStr),
-    HttpHeaderFieldAttrs("FTP-Pre", HDR_FTP_PRE, ftStr),
-    HttpHeaderFieldAttrs("FTP-Status", HDR_FTP_STATUS, ftInt),
-    HttpHeaderFieldAttrs("FTP-Reason", HDR_FTP_REASON, ftStr),
-    HttpHeaderFieldAttrs("Other:", HDR_OTHER, ftStr)    /* ':' will not allow matches */
-};
-
-static HttpHeaderFieldInfo *Headers = NULL;
-
-http_hdr_type &operator++ (http_hdr_type &aHeader)
-{
-    int tmp = (int)aHeader;
-    aHeader = (http_hdr_type)(++tmp);
-    return aHeader;
-}
+// statistics counters for headers. clients must not allow Http::HdrType::BAD_HDR to be counted
+std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::ENUM_END);
 
 /*
  * headers with field values defined as #(values) in HTTP/1.1
  * Headers that are currently not recognized, are commented out.
  */
 static HttpHeaderMask ListHeadersMask;  /* set run-time using  ListHeadersArr */
-static http_hdr_type ListHeadersArr[] = {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET,
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES,
-    HDR_ALLOW,
-    HDR_CACHE_CONTROL,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONNECTION,
-    HDR_EXPECT,
-    HDR_IF_MATCH,
-    HDR_IF_NONE_MATCH,
-    HDR_KEY,
-    HDR_LINK,
-    HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_PROXY_SUPPORT,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_VARY,
-    HDR_VIA,
-    HDR_WARNING,
-    HDR_WWW_AUTHENTICATE,
-    HDR_AUTHENTICATION_INFO,
-    HDR_PROXY_AUTHENTICATION_INFO,
-    /* HDR_TE, HDR_TRAILER */
+static Http::HdrType ListHeadersArr[] = {
+    Http::HdrType::ACCEPT,
+    Http::HdrType::ACCEPT_CHARSET,
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_LANGUAGE,
+    Http::HdrType::ACCEPT_RANGES,
+    Http::HdrType::ALLOW,
+    Http::HdrType::CACHE_CONTROL,
+    Http::HdrType::CONTENT_ENCODING,
+    Http::HdrType::CONTENT_LANGUAGE,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::EXPECT,
+    Http::HdrType::IF_MATCH,
+    Http::HdrType::IF_NONE_MATCH,
+    Http::HdrType::KEY,
+    Http::HdrType::LINK,
+    Http::HdrType::PRAGMA,
+    Http::HdrType::PROXY_CONNECTION,
+    Http::HdrType::PROXY_SUPPORT,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    Http::HdrType::VARY,
+    Http::HdrType::VIA,
+    Http::HdrType::WARNING,
+    Http::HdrType::WWW_AUTHENTICATE,
+    Http::HdrType::AUTHENTICATION_INFO,
+    Http::HdrType::PROXY_AUTHENTICATION_INFO,
+    /* Http::HdrType::TE, Http::HdrType::TRAILER */
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+    Http::HdrType::HDR_X_ACCELERATOR_VARY,
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,
+    Http::HdrType::X_NEXT_SERVICES,
 #endif
-    HDR_SURROGATE_CAPABILITY,
-    HDR_SURROGATE_CONTROL,
-    HDR_FORWARDED,
-    HDR_X_FORWARDED_FOR
+    Http::HdrType::SURROGATE_CAPABILITY,
+    Http::HdrType::SURROGATE_CONTROL,
+    Http::HdrType::FORWARDED,
+    Http::HdrType::X_FORWARDED_FOR
 };
 
 /* general-headers */
-static http_hdr_type GeneralHeadersArr[] = {
-    HDR_CACHE_CONTROL,
-    HDR_CONNECTION,
-    HDR_DATE,
-    HDR_FORWARDED,
-    HDR_X_FORWARDED_FOR,
-    HDR_MIME_VERSION,
-    HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    /* HDR_TRAILER, */
-    HDR_VIA,
+static Http::HdrType GeneralHeadersArr[] = {
+    Http::HdrType::CACHE_CONTROL,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::DATE,
+    Http::HdrType::FORWARDED,
+    Http::HdrType::X_FORWARDED_FOR,
+    Http::HdrType::MIME_VERSION,
+    Http::HdrType::PRAGMA,
+    Http::HdrType::PROXY_CONNECTION,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    /* Http::HdrType::TRAILER, */
+    Http::HdrType::VIA,
 };
 
 /* entity-headers */
-static http_hdr_type EntityHeadersArr[] = {
-    HDR_ALLOW,
-    HDR_CONTENT_BASE,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONTENT_LENGTH,
-    HDR_CONTENT_LOCATION,
-    HDR_CONTENT_MD5,
-    HDR_CONTENT_RANGE,
-    HDR_CONTENT_TYPE,
-    HDR_ETAG,
-    HDR_EXPIRES,
-    HDR_LAST_MODIFIED,
-    HDR_LINK,
-    HDR_OTHER
+static Http::HdrType EntityHeadersArr[] = {
+    Http::HdrType::ALLOW,
+    Http::HdrType::CONTENT_BASE,
+    Http::HdrType::CONTENT_ENCODING,
+    Http::HdrType::CONTENT_LANGUAGE,
+    Http::HdrType::CONTENT_LENGTH,
+    Http::HdrType::CONTENT_LOCATION,
+    Http::HdrType::CONTENT_MD5,
+    Http::HdrType::CONTENT_RANGE,
+    Http::HdrType::CONTENT_TYPE,
+    Http::HdrType::ETAG,
+    Http::HdrType::EXPIRES,
+    Http::HdrType::LAST_MODIFIED,
+    Http::HdrType::LINK,
+    Http::HdrType::OTHER
 };
 
 /* request-only headers */
 static HttpHeaderMask RequestHeadersMask;   /* set run-time using RequestHeaders */
-static http_hdr_type RequestHeadersArr[] = {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET,
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_LANGUAGE,
-    HDR_AUTHORIZATION,
-    HDR_EXPECT,
-    HDR_FROM,
-    HDR_HOST,
-    HDR_HTTP2_SETTINGS,
-    HDR_IF_MATCH,
-    HDR_IF_MODIFIED_SINCE,
-    HDR_IF_NONE_MATCH,
-    HDR_IF_RANGE,
-    HDR_IF_UNMODIFIED_SINCE,
-    HDR_MAX_FORWARDS,
-    HDR_ORIGIN,
-    HDR_PROXY_AUTHORIZATION,
-    HDR_RANGE,
-    HDR_REFERER,
-    HDR_REQUEST_RANGE,
-    HDR_TE,
-    HDR_USER_AGENT,
-    HDR_SURROGATE_CAPABILITY
+static Http::HdrType RequestHeadersArr[] = {
+    Http::HdrType::ACCEPT,
+    Http::HdrType::ACCEPT_CHARSET,
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_LANGUAGE,
+    Http::HdrType::AUTHORIZATION,
+    Http::HdrType::EXPECT,
+    Http::HdrType::FROM,
+    Http::HdrType::HOST,
+    Http::HdrType::HTTP2_SETTINGS,
+    Http::HdrType::IF_MATCH,
+    Http::HdrType::IF_MODIFIED_SINCE,
+    Http::HdrType::IF_NONE_MATCH,
+    Http::HdrType::IF_RANGE,
+    Http::HdrType::IF_UNMODIFIED_SINCE,
+    Http::HdrType::MAX_FORWARDS,
+    Http::HdrType::ORIGIN,
+    Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::RANGE,
+    Http::HdrType::REFERER,
+    Http::HdrType::REQUEST_RANGE,
+    Http::HdrType::TE,
+    Http::HdrType::USER_AGENT,
+    Http::HdrType::SURROGATE_CAPABILITY
 };
 
 /* reply-only headers */
 static HttpHeaderMask ReplyHeadersMask;     /* set run-time using ReplyHeaders */
-static http_hdr_type ReplyHeadersArr[] = {
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_RANGES,
-    HDR_AGE,
-    HDR_KEY,
-    HDR_LOCATION,
-    HDR_PROXY_AUTHENTICATE,
-    HDR_PUBLIC,
-    HDR_RETRY_AFTER,
-    HDR_SERVER,
-    HDR_SET_COOKIE,
-    HDR_SET_COOKIE2,
-    HDR_VARY,
-    HDR_WARNING,
-    HDR_WWW_AUTHENTICATE,
-    HDR_X_CACHE,
-    HDR_X_CACHE_LOOKUP,
-    HDR_X_REQUEST_URI,
+static Http::HdrType ReplyHeadersArr[] = {
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_RANGES,
+    Http::HdrType::AGE,
+    Http::HdrType::KEY,
+    Http::HdrType::LOCATION,
+    Http::HdrType::PROXY_AUTHENTICATE,
+    Http::HdrType::PUBLIC,
+    Http::HdrType::RETRY_AFTER,
+    Http::HdrType::SERVER,
+    Http::HdrType::SET_COOKIE,
+    Http::HdrType::SET_COOKIE2,
+    Http::HdrType::VARY,
+    Http::HdrType::WARNING,
+    Http::HdrType::WWW_AUTHENTICATE,
+    Http::HdrType::X_CACHE,
+    Http::HdrType::X_CACHE_LOOKUP,
+    Http::HdrType::X_REQUEST_URI,
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+    Http::HdrType::HDR_X_ACCELERATOR_VARY,
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,
+    Http::HdrType::X_NEXT_SERVICES,
 #endif
-    HDR_X_SQUID_ERROR,
-    HDR_SURROGATE_CONTROL
+    Http::HdrType::X_SQUID_ERROR,
+    Http::HdrType::SURROGATE_CONTROL
 };
 
 /* hop-by-hop headers */
 static HttpHeaderMask HopByHopHeadersMask;
-static http_hdr_type HopByHopHeadersArr[] = {
-    HDR_ALTERNATE_PROTOCOL,
-    HDR_CONNECTION,
-    HDR_HTTP2_SETTINGS,
-    HDR_KEEP_ALIVE,
-    /*HDR_PROXY_AUTHENTICATE, // removal handled specially for peer login */
-    HDR_PROXY_AUTHORIZATION,
-    HDR_TE,
-    HDR_TRAILER,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_PROXY_CONNECTION
+static Http::HdrType HopByHopHeadersArr[] = {
+    Http::HdrType::ALTERNATE_PROTOCOL,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::HTTP2_SETTINGS,
+    Http::HdrType::KEEP_ALIVE,
+    /*Http::HdrType::PROXY_AUTHENTICATE, // removal handled specially for peer login */
+    Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::TE,
+    Http::HdrType::TRAILER,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    Http::HdrType::PROXY_CONNECTION
 };
 
 /* header accounting */
@@ -344,12 +239,9 @@
  */
 
 class StoreEntry;
-#define assert_eid(id) assert((id) >= 0 && (id) < HDR_ENUM_END)
-
-static void httpHeaderNoteParsedEntry(http_hdr_type id, String const &value, int error);
-
+
+static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, int error);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
-
 /** store report about current header usage and other stats */
 static void httpHeaderStoreReport(StoreEntry * e);
 
@@ -369,14 +261,13 @@
 httpHeaderInitModule(void)
 {
     /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= HDR_ENUM_END);
-    /* all headers must be described */
-    assert(countof(HeadersAttrs) == HDR_ENUM_END);
-
-    if (!Headers)
-        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-
-    /* create masks */
+    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::ENUM_END);
+
+    // check invariant: for each index in headerTable, (int)headerTable[index] = index
+    for (int i = 0; Http::HeaderTable[i].name; ++i)
+        assert(Http::HeaderTable[i].id == i);
+
+    /* create masks. XXX: migrate to std::vector<bool>? */
     httpHeaderMaskInit(&ListHeadersMask, 0);
     httpHeaderCalcMask(&ListHeadersMask, ListHeadersArr, countof(ListHeadersArr));
 
@@ -406,8 +297,6 @@
 void
 httpHeaderCleanModule(void)
 {
-    httpHeaderDestroyFieldsInfo(Headers, HDR_ENUM_END);
-    Headers = NULL;
     httpHdrCcCleanModule();
     httpHdrScCleanModule();
 }
@@ -484,7 +373,7 @@
         HttpHeaderEntry *e = *i;
         if (e == NULL)
             continue;
-        if (e->id < 0 || e->id >= HDR_ENUM_END) {
+        if (e->id >= Http::HdrType::ENUM_END) {
             debugs(55, DBG_CRITICAL, "BUG: invalid entry (" << e->id << "). Ignored.");
         } else {
             if (owner <= hoReply)
@@ -531,12 +420,12 @@
     assert(this != fresh);
 
     while ((e = fresh->getEntry(&pos))) {
-        /* deny bad guys (ok to check for HDR_OTHER) here */
+        /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        if (e->id != HDR_OTHER)
+        if (e->id != Http::HdrType::OTHER)
             delById(e->id);
         else
             delByName(e->name.termedBuf());
@@ -544,12 +433,12 @@
 
     pos = HttpHeaderInitPos;
     while ((e = fresh->getEntry(&pos))) {
-        /* deny bad guys (ok to check for HDR_OTHER) here */
+        /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        debugs(55, 7, "Updating header '" << HeadersAttrs[e->id].name << "' in cached entry");
+        debugs(55, 7, "Updating header '" << Http::HeaderTable[e->id].name << "' in cached entry");
 
         addEntry(e->clone());
     }
@@ -673,7 +562,7 @@
             return reset();
         }
 
-        if (e->id == HDR_CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
+        if (e->id == Http::HdrType::CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
             if (e->value != e2->value) {
                 int64_t l1, l2;
                 debugs(55, warnOnError, "WARNING: found two conflicting content-length headers in {" <<
@@ -710,7 +599,7 @@
             }
         }
 
-        if (e->id == HDR_OTHER && stringHasWhitespace(e->name.termedBuf())) {
+        if (e->id == Http::HdrType::OTHER && stringHasWhitespace(e->name.termedBuf())) {
             debugs(55, warnOnError, "WARNING: found whitespace in HTTP header name {" <<
                    getStringPrefix(field_start, field_end-field_start) << "}");
 
@@ -726,7 +615,7 @@
 
     if (chunked()) {
         // RFC 2616 section 4.4: ignore Content-Length with Transfer-Encoding
-        delById(HDR_CONTENT_LENGTH);
+        delById(Http::HdrType::CONTENT_LENGTH);
     }
 
     PROF_stop(HttpHeaderParse);
@@ -751,13 +640,13 @@
 
         bool maskThisEntry = false;
         switch (e->id) {
-        case HDR_AUTHORIZATION:
-        case HDR_PROXY_AUTHORIZATION:
+        case Http::HdrType::AUTHORIZATION:
+        case Http::HdrType::PROXY_AUTHORIZATION:
             maskThisEntry = true;
             break;
 
-        case HDR_FTP_ARGUMENTS:
-            if (const HttpHeaderEntry *cmd = findEntry(HDR_FTP_COMMAND))
+        case Http::HdrType::FTP_ARGUMENTS:
+            if (const HttpHeaderEntry *cmd = findEntry(Http::HdrType::FTP_COMMAND))
                 maskThisEntry = (cmd->value == "PASS");
             break;
 
@@ -798,11 +687,11 @@
  * "list" headers
  */
 HttpHeaderEntry *
-HttpHeader::findEntry(http_hdr_type id) const
+HttpHeader::findEntry(Http::HdrType id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
-    assert_eid(id);
+    assert(any_valid_header(id));
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
@@ -826,12 +715,12 @@
  * same as httpHeaderFindEntry
  */
 HttpHeaderEntry *
-HttpHeader::findLastEntry(http_hdr_type id) const
+HttpHeader::findLastEntry(Http::HdrType id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
     HttpHeaderEntry *result = NULL;
-    assert_eid(id);
+    assert(any_valid_header(id));
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
@@ -873,14 +762,14 @@
 
 /* deletes all entries with a given id, returns the #entries deleted */
 int
-HttpHeader::delById(http_hdr_type id)
+HttpHeader::delById(Http::HdrType id)
 {
     int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
     debugs(55, 8, this << " del-by-id " << id);
-    assert_eid(id);
-    assert(id != HDR_OTHER);        /* does not make sense */
+    assert(any_valid_header(id));
+    assert(id != Http::HdrType::OTHER);        /* does not make sense */
 
     if (!CBIT_TEST(mask, id))
         return 0;
@@ -948,15 +837,18 @@
 HttpHeader::addEntry(HttpHeaderEntry * e)
 {
     assert(e);
-    assert_eid(e->id);
+    assert(any_registered_header(e->id));
     assert(e->name.size());
 
     debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
-    if (CBIT_TEST(mask, e->id))
-        ++ Headers[e->id].stat.repCount;
-    else
-        CBIT_SET(mask, e->id);
+    if (e->id != Http::HdrType::BAD_HDR) {
+        if (CBIT_TEST(mask, e->id)) {
+            ++ headerStatsTable[e->id].repCount;
+        } else {
+            CBIT_SET(mask, e->id);
+        }
+    }
 
     entries.push_back(e);
 
@@ -971,14 +863,16 @@
 HttpHeader::insertEntry(HttpHeaderEntry * e)
 {
     assert(e);
-    assert_eid(e->id);
+    assert(any_valid_header(e->id));
 
     debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
-    if (CBIT_TEST(mask, e->id))
-        ++ Headers[e->id].stat.repCount;
-    else
+    // Http::HdrType::BAD_HDR is filtered out by assert_any_valid_header
+    if (CBIT_TEST(mask, e->id)) {
+        ++ headerStatsTable[e->id].repCount;
+    } else {
         CBIT_SET(mask, e->id);
+    }
 
     entries.insert(entries.begin(),e);
 
@@ -987,7 +881,7 @@
 }
 
 bool
-HttpHeader::getList(http_hdr_type id, String *s) const
+HttpHeader::getList(Http::HdrType id, String *s) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -1010,7 +904,7 @@
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s->size())
-        debugs(55, 3, "empty list header: " << Headers[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -1019,7 +913,7 @@
 
 /* return a list of entries with the same id separated by ',' and ws */
 String
-HttpHeader::getList(http_hdr_type id) const
+HttpHeader::getList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -1044,7 +938,7 @@
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s.size())
-        debugs(55, 3, "empty list header: " << Headers[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -1053,7 +947,7 @@
 
 /* return a string or list of entries with the same id separated by ',' and ws */
 String
-HttpHeader::getStrOrList(http_hdr_type id) const
+HttpHeader::getStrOrList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
 
@@ -1081,16 +975,16 @@
 bool
 HttpHeader::getByNameIfPresent(const char *name, String &result) const
 {
-    http_hdr_type id;
+    Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
 
     assert(name);
 
     /* First try the quick path */
-    id = httpHeaderIdByNameDef(name, strlen(name));
+    id = Http::HeaderLookupTable.lookup(SBuf(name));
 
-    if (id != -1) {
+    if (id != Http::HdrType::BAD_HDR) {
         if (!has(id))
             return false;
         result = getStrOrList(id);
@@ -1100,7 +994,7 @@
     /* Sorry, an unknown header name. Do linear search */
     bool found = false;
     while ((e = getEntry(&pos))) {
-        if (e->id == HDR_OTHER && e->name.caseCmp(name) == 0) {
+        if (e->id == Http::HdrType::OTHER && e->name.caseCmp(name) == 0) {
             found = true;
             strListAdd(&result, e->value.termedBuf(), ',');
         }
@@ -1141,7 +1035,7 @@
  * returns a the value of the specified list member, if any.
  */
 String
-HttpHeader::getListMember(http_hdr_type id, const char *member, const char separator) const
+HttpHeader::getListMember(Http::HdrType id, const char *member, const char separator) const
 {
     String header;
     const char *pos = NULL;
@@ -1149,7 +1043,7 @@
     int ilen;
     int mlen = strlen(member);
 
-    assert(id >= 0);
+    assert(any_valid_header(id));
 
     header = getStrOrList(id);
     String result;
@@ -1167,55 +1061,55 @@
 
 /* test if a field is present */
 int
-HttpHeader::has(http_hdr_type id) const
+HttpHeader::has(Http::HdrType id) const
 {
-    assert_eid(id);
-    assert(id != HDR_OTHER);
+    assert(any_valid_header(id));
+    assert(id != Http::HdrType::OTHER);
     debugs(55, 9, this << " lookup for " << id);
     return CBIT_TEST(mask, id);
 }
 
 void
-HttpHeader::putInt(http_hdr_type id, int number)
+HttpHeader::putInt(Http::HdrType id, int number)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt);  /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xitoa(number)));
 }
 
 void
-HttpHeader::putInt64(http_hdr_type id, int64_t number)
+HttpHeader::putInt64(Http::HdrType id, int64_t number)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt64);    /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xint64toa(number)));
 }
 
 void
-HttpHeader::putTime(http_hdr_type id, time_t htime)
+HttpHeader::putTime(Http::HdrType id, time_t htime)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);    /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
 void
-HttpHeader::insertTime(http_hdr_type id, time_t htime)
+HttpHeader::insertTime(Http::HdrType id, time_t htime)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);    /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     insertEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
 void
-HttpHeader::putStr(http_hdr_type id, const char *str)
+HttpHeader::putStr(Http::HdrType id, const char *str)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);  /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
     assert(str);
     addEntry(new HttpHeaderEntry(id, NULL, str));
 }
@@ -1224,7 +1118,7 @@
 HttpHeader::putAuth(const char *auth_scheme, const char *realm)
 {
     assert(auth_scheme && realm);
-    httpHeaderPutStrf(this, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
+    httpHeaderPutStrf(this, Http::HdrType::WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
 }
 
 void
@@ -1232,13 +1126,13 @@
 {
     assert(cc);
     /* remove old directives if any */
-    delById(HDR_CACHE_CONTROL);
+    delById(Http::HdrType::CACHE_CONTROL);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     cc->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_CACHE_CONTROL, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::CACHE_CONTROL, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1248,13 +1142,13 @@
 {
     assert(cr);
     /* remove old directives if any */
-    delById(HDR_CONTENT_RANGE);
+    delById(Http::HdrType::CONTENT_RANGE);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     httpHdrContRangePackInto(cr, &mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_CONTENT_RANGE, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::CONTENT_RANGE, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1264,13 +1158,13 @@
 {
     assert(range);
     /* remove old directives if any */
-    delById(HDR_RANGE);
+    delById(Http::HdrType::RANGE);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     range->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_RANGE, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::RANGE, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1280,13 +1174,13 @@
 {
     assert(sc);
     /* remove old directives if any */
-    delById(HDR_SURROGATE_CONTROL);
+    delById(Http::HdrType::SURROGATE_CONTROL);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     sc->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_SURROGATE_CONTROL, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::SURROGATE_CONTROL, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1296,7 +1190,7 @@
 {
     char buf[512];
     snprintf(buf, sizeof(buf), "%i %s \"%s\"", code, visible_appname_string, text);
-    putStr(HDR_WARNING, buf);
+    putStr(Http::HdrType::WARNING, buf);
 }
 
 /* add extension header (these fields are not parsed/analyzed/joined, etc.) */
@@ -1305,14 +1199,14 @@
 {
     assert(name && value);
     debugs(55, 8, this << " adds ext entry " << name << " : " << value);
-    addEntry(new HttpHeaderEntry(HDR_OTHER, name, value));
+    addEntry(new HttpHeaderEntry(Http::HdrType::OTHER, name, value));
 }
 
 int
-HttpHeader::getInt(http_hdr_type id) const
+HttpHeader::getInt(Http::HdrType id) const
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt);  /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1322,10 +1216,10 @@
 }
 
 int64_t
-HttpHeader::getInt64(http_hdr_type id) const
+HttpHeader::getInt64(Http::HdrType id) const
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt64);    /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1335,12 +1229,12 @@
 }
 
 time_t
-HttpHeader::getTime(http_hdr_type id) const
+HttpHeader::getTime(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     time_t value = -1;
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);    /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         value = parse_rfc1123(e->value.termedBuf());
@@ -1352,11 +1246,11 @@
 
 /* sync with httpHeaderGetLastStr */
 const char *
-HttpHeader::getStr(http_hdr_type id) const
+HttpHeader::getStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);  /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
@@ -1368,11 +1262,11 @@
 
 /* unusual */
 const char *
-HttpHeader::getLastStr(http_hdr_type id) const
+HttpHeader::getLastStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);  /* must be of an appropriate type */
+    assert(any_valid_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findLastEntry(id))) {
         httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
@@ -1385,12 +1279,12 @@
 HttpHdrCc *
 HttpHeader::getCc() const
 {
-    if (!CBIT_TEST(mask, HDR_CACHE_CONTROL))
+    if (!CBIT_TEST(mask, Http::HdrType::CACHE_CONTROL))
         return NULL;
     PROF_start(HttpHeader_getCc);
 
     String s;
-    getList(HDR_CACHE_CONTROL, &s);
+    getList(Http::HdrType::CACHE_CONTROL, &s);
 
     HttpHdrCc *cc=new HttpHdrCc();
 
@@ -1404,7 +1298,7 @@
     if (cc)
         httpHdrCcUpdateStats(cc, &HttpHeaderStats[owner].ccTypeDistr);
 
-    httpHeaderNoteParsedEntry(HDR_CACHE_CONTROL, s, !cc);
+    httpHeaderNoteParsedEntry(Http::HdrType::CACHE_CONTROL, s, !cc);
 
     PROF_stop(HttpHeader_getCc);
 
@@ -1421,8 +1315,8 @@
      * this "if" should work correctly in both cases;
      * hopefully no clients send mismatched headers! */
 
-    if ((e = findEntry(HDR_RANGE)) ||
-            (e = findEntry(HDR_REQUEST_RANGE))) {
+    if ((e = findEntry(Http::HdrType::RANGE)) ||
+            (e = findEntry(Http::HdrType::REQUEST_RANGE))) {
         r = HttpHdrRange::ParseCreate(&e->value);
         httpHeaderNoteParsedEntry(e->id, e->value, !r);
     }
@@ -1433,12 +1327,12 @@
 HttpHdrSc *
 HttpHeader::getSc() const
 {
-    if (!CBIT_TEST(mask, HDR_SURROGATE_CONTROL))
+    if (!CBIT_TEST(mask, Http::HdrType::SURROGATE_CONTROL))
         return NULL;
 
     String s;
 
-    (void) getList(HDR_SURROGATE_CONTROL, &s);
+    (void) getList(Http::HdrType::SURROGATE_CONTROL, &s);
 
     HttpHdrSc *sc = httpHdrScParseCreate(s);
 
@@ -1447,7 +1341,7 @@
     if (sc)
         sc->updateStats(&HttpHeaderStats[owner].scTypeDistr);
 
-    httpHeaderNoteParsedEntry(HDR_SURROGATE_CONTROL, s, !sc);
+    httpHeaderNoteParsedEntry(Http::HdrType::SURROGATE_CONTROL, s, !sc);
 
     return sc;
 }
@@ -1458,7 +1352,7 @@
     HttpHdrContRange *cr = NULL;
     HttpHeaderEntry *e;
 
-    if ((e = findEntry(HDR_CONTENT_RANGE))) {
+    if ((e = findEntry(Http::HdrType::CONTENT_RANGE))) {
         cr = httpHdrContRangeParseCreate(e->value.termedBuf());
         httpHeaderNoteParsedEntry(e->id, e->value, !cr);
     }
@@ -1467,7 +1361,7 @@
 }
 
 const char *
-HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
+HttpHeader::getAuth(Http::HdrType id, const char *auth_scheme) const
 {
     const char *field;
     int l;
@@ -1506,11 +1400,11 @@
 }
 
 ETag
-HttpHeader::getETag(http_hdr_type id) const
+HttpHeader::getETag(Http::HdrType id) const
 {
     ETag etag = {NULL, -1};
     HttpHeaderEntry *e;
-    assert(Headers[id].type == ftETag);     /* must be of an appropriate type */
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
 
     if ((e = findEntry(id)))
         etagParseInit(&etag, e->value.termedBuf());
@@ -1519,11 +1413,11 @@
 }
 
 TimeOrTag
-HttpHeader::getTimeOrTag(http_hdr_type id) const
+HttpHeader::getTimeOrTag(Http::HdrType id) const
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
-    assert(Headers[id].type == ftDate_1123_or_ETag);    /* must be of an appropriate type */
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
 
     if ((e = findEntry(id))) {
@@ -1549,39 +1443,34 @@
  * HttpHeaderEntry
  */
 
-HttpHeaderEntry::HttpHeaderEntry(http_hdr_type anId, const char *aName, const char *aValue)
+HttpHeaderEntry::HttpHeaderEntry(Http::HdrType anId, const char *aName, const char *aValue)
 {
-    assert_eid(anId);
+    assert(any_registered_header(anId));
     id = anId;
 
-    if (id != HDR_OTHER)
-        name = Headers[id].name;
+    if (id != Http::HdrType::OTHER)
+        name = Http::HeaderTable[id].name;
     else
         name = aName;
 
     value = aValue;
 
-    ++ Headers[id].stat.aliveCount;
+    if (anId != Http::HdrType::BAD_HDR)
+        ++ headerStatsTable[id].aliveCount;
 
     debugs(55, 9, "created HttpHeaderEntry " << this << ": '" << name << " : " << value );
 }
 
 HttpHeaderEntry::~HttpHeaderEntry()
 {
-    assert_eid(id);
+    assert(any_valid_header(id));
     debugs(55, 9, "destroying entry " << this << ": '" << name << ": " << value << "'");
-    /* clean name if needed */
-
-    if (id == HDR_OTHER)
-        name.clean();
-
-    value.clean();
-
-    assert(Headers[id].stat.aliveCount);
-
-    -- Headers[id].stat.aliveCount;
-
-    id = HDR_BAD_HDR;
+
+    // Http::HdrType::BAD_HDR is filtered out by assert_any_valid_header
+    assert(headerStatsTable[id].aliveCount);
+    -- headerStatsTable[id].aliveCount;
+
+    id = Http::HdrType::BAD_HDR;
 }
 
 /* parses and inits header entry, returns true/false */
@@ -1623,22 +1512,23 @@
     debugs(55, 9, "parsing HttpHeaderEntry: near '" <<  getStringPrefix(field_start, field_end-field_start) << "'");
 
     /* is it a "known" field? */
-    http_hdr_type id = httpHeaderIdByName(field_start, name_len, Headers, HDR_ENUM_END);
+    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(field_start,name_len));
+    debugs(55, 9, "got hdr-id=" << id);
 
     String name;
 
     String value;
 
-    if (id < 0)
-        id = HDR_OTHER;
+    if (id == Http::HdrType::BAD_HDR)
+        id = Http::HdrType::OTHER;
 
-    assert_eid(id);
+    assert(any_valid_header(id));
 
     /* set field name */
-    if (id == HDR_OTHER)
+    if (id == Http::HdrType::OTHER)
         name.limitInit(field_start, name_len);
     else
-        name = Headers[id].name;
+        name = Http::HeaderTable[id].name;
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
@@ -1651,7 +1541,7 @@
         /* String must be LESS THAN 64K and it adds a terminating NULL */
         debugs(55, DBG_IMPORTANT, "WARNING: ignoring '" << name << "' header of " << (field_end - value_start) << " bytes");
 
-        if (id == HDR_OTHER)
+        if (id == Http::HdrType::OTHER)
             name.clean();
 
         return NULL;
@@ -1660,7 +1550,8 @@
     /* set field value */
     value.limitInit(value_start, field_end - value_start);
 
-    ++ Headers[id].stat.seenCount;
+    if (id != Http::HdrType::BAD_HDR)
+        ++ headerStatsTable[id].seenCount;
 
     debugs(55, 9, "parsed HttpHeaderEntry: '" << name << ": " << value << "'");
 
@@ -1686,8 +1577,6 @@
 int
 HttpHeaderEntry::getInt() const
 {
-    assert_eid (id);
-    assert (Headers[id].type == ftInt);
     int val = -1;
     int ok = httpHeaderParseInt(value.termedBuf(), &val);
     httpHeaderNoteParsedEntry(id, value, !ok);
@@ -1700,8 +1589,6 @@
 int64_t
 HttpHeaderEntry::getInt64() const
 {
-    assert_eid (id);
-    assert (Headers[id].type == ftInt64);
     int64_t val = -1;
     int ok = httpHeaderParseOffset(value.termedBuf(), &val);
     httpHeaderNoteParsedEntry(id, value, !ok);
@@ -1712,13 +1599,15 @@
 }
 
 static void
-httpHeaderNoteParsedEntry(http_hdr_type id, String const &context, int error)
+httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, int error)
 {
-    ++ Headers[id].stat.parsCount;
+    if (id != Http::HdrType::BAD_HDR)
+        ++ headerStatsTable[id].parsCount;
 
     if (error) {
-        ++ Headers[id].stat.errCount;
-        debugs(55, 2, "cannot parse hdr field: '" << Headers[id].name << ": " << context << "'");
+        if (id != Http::HdrType::BAD_HDR)
+            ++ headerStatsTable[id].errCount;
+        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderTable[id].name << ": " << context << "'");
     }
 }
 
@@ -1733,9 +1622,9 @@
 void
 httpHeaderFieldStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
-    const int id = (int) val;
-    const int valid_id = id >= 0 && id < HDR_ENUM_END;
-    const char *name = valid_id ? Headers[id].name.termedBuf() : "INVALID";
+    const int id = static_cast<int>(val);
+    const bool valid_id = id < Http::HdrType::ENUM_END;
+    const char *name = valid_id ? Http::HeaderTable[id].name : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
 
@@ -1759,7 +1648,8 @@
 static void
 httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
 {
-    assert(hs && e);
+    assert(hs);
+    assert(e);
 
     dump_stat = hs;
     storeAppendPrintf(e, "\nHeader Stats: %s\n", hs->label);
@@ -1787,7 +1677,6 @@
 httpHeaderStoreReport(StoreEntry * e)
 {
     int i;
-    http_hdr_type ht;
     assert(e);
 
     HttpHeaderStats[0].parsedCount =
@@ -1809,12 +1698,15 @@
     storeAppendPrintf(e, "%2s\t %-25s\t %5s\t %6s\t %6s\n",
                       "id", "name", "#alive", "%err", "%repeat");
 
-    for (ht = (http_hdr_type)0; ht < HDR_ENUM_END; ++ht) {
-        HttpHeaderFieldInfo *f = Headers + ht;
+    // scan heaaderTable and output
+    for (int j = 0; Http::HeaderTable[j].name != nullptr; ++j) {
+        auto stats = headerStatsTable[j];
         storeAppendPrintf(e, "%2d\t %-25s\t %5d\t %6.3f\t %6.3f\n",
-                          f->id, f->name.termedBuf(), f->stat.aliveCount,
-                          xpercent(f->stat.errCount, f->stat.parsCount),
-                          xpercent(f->stat.repCount, f->stat.seenCount));
+                          Http::HeaderTable[j].id,
+                          Http::HeaderTable[j].name,
+                          stats.aliveCount,
+                          xpercent(stats.errCount, stats.parsCount),
+                          xpercent(stats.repCount, stats.seenCount));
     }
 
     storeAppendPrintf(e, "Headers Parsed: %d + %d = %d\n",
@@ -1824,44 +1716,8 @@
     storeAppendPrintf(e, "Hdr Fields Parsed: %d\n", HeaderEntryParsedCount);
 }
 
-http_hdr_type
-httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * info, int end)
-{
-    if (name_len > 0) {
-        for (int i = 0; i < end; ++i) {
-            if (name_len != info[i].name.size())
-                continue;
-
-            if (!strncasecmp(name, info[i].name.rawBuf(), name_len))
-                return info[i].id;
-        }
-    }
-
-    return HDR_BAD_HDR;
-}
-
-http_hdr_type
-httpHeaderIdByNameDef(const char *name, int name_len)
-{
-    if (!Headers)
-        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-
-    return httpHeaderIdByName(name, name_len, Headers, HDR_ENUM_END);
-}
-
-const char *
-httpHeaderNameById(int id)
-{
-    if (!Headers)
-        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-
-    assert(id >= 0 && id < HDR_ENUM_END);
-
-    return Headers[id].name.termedBuf();
-}
-
 int
-HttpHeader::hasListMember(http_hdr_type id, const char *member, const char separator) const
+HttpHeader::hasListMember(Http::HdrType id, const char *member, const char separator) const
 {
     int result = 0;
     const char *pos = NULL;
@@ -1869,7 +1725,7 @@
     int ilen;
     int mlen = strlen(member);
 
-    assert(id >= 0);
+    assert(any_valid_header(id));
 
     String header (getStrOrList(id));
 
@@ -1917,7 +1773,7 @@
     HttpHeaderPos pos = HttpHeaderInitPos;
     int headers_deleted = 0;
     while ((e = getEntry(&pos))) {
-        int id = e->id;
+        Http::HdrType id = e->id;
         if (CBIT_TEST(HopByHopHeadersMask, id)) {
             delAt(pos, headers_deleted);
             CBIT_CLR(mask, id);
@@ -1928,11 +1784,11 @@
 void
 HttpHeader::removeConnectionHeaderEntries()
 {
-    if (has(HDR_CONNECTION)) {
+    if (has(Http::HdrType::CONNECTION)) {
         /* anything that matches Connection list member will be deleted */
         String strConnection;
 
-        (void) getList(HDR_CONNECTION, &strConnection);
+        (void) getList(Http::HdrType::CONNECTION, &strConnection);
         const HttpHeaderEntry *e;
         HttpHeaderPos pos = HttpHeaderInitPos;
         /*

=== modified file 'src/HttpHeader.h'
--- src/HttpHeader.h	2015-03-03 11:43:26 +0000
+++ src/HttpHeader.h	2015-08-04 19:57:07 +0000
@@ -9,6 +9,7 @@
 #ifndef SQUID_HTTPHEADER_H
 #define SQUID_HTTPHEADER_H
 
+#include "base/LookupTable.h"
 #include "http/RegisteredHeaders.h"
 /* because we pass a spec by value */
 #include "HttpHeaderMask.h"
@@ -23,24 +24,8 @@
 class HttpHdrRange;
 class HttpHdrSc;
 class Packable;
-class StoreEntry;
 class SBuf;
 
-/** possible types for http header fields */
-typedef enum {
-    ftInvalid = HDR_ENUM_END,   /**< to catch nasty errors with hdr_id<->fld_type clashes */
-    ftInt,
-    ftInt64,
-    ftStr,
-    ftDate_1123,
-    ftETag,
-    ftPCc,
-    ftPContRange,
-    ftPRange,
-    ftPSc,
-    ftDate_1123_or_ETag
-} field_type;
-
 /** Possible owners of http header */
 typedef enum {
     hoNone =0,
@@ -55,23 +40,6 @@
     hoEnd
 } http_hdr_owner_type;
 
-class HttpHeaderFieldAttrs
-{
-public:
-    HttpHeaderFieldAttrs() : name(NULL), id(HDR_BAD_HDR), type(ftInvalid) {}
-    HttpHeaderFieldAttrs(const char *aName, http_hdr_type anId, field_type aType = ftInvalid) : name(aName), id(anId), type(aType) {}
-#if __cplusplus >= 201103L
-    HttpHeaderFieldAttrs(const HttpHeaderFieldAttrs &) = default;
-    HttpHeaderFieldAttrs(HttpHeaderFieldAttrs &&) = default;
-#endif
-    // nothing to do as name is a pointer to global const string
-    ~HttpHeaderFieldAttrs() {}
-
-    const char *name;
-    http_hdr_type id;
-    field_type type;
-};
-
 /** Iteration for headers; use HttpHeaderPos as opaque type, do not interpret */
 typedef ssize_t HttpHeaderPos;
 
@@ -83,7 +51,7 @@
     MEMPROXY_CLASS(HttpHeaderEntry);
 
 public:
-    HttpHeaderEntry(http_hdr_type id, const char *name, const char *value);
+    HttpHeaderEntry(Http::HdrType id, const char *name, const char *value);
     ~HttpHeaderEntry();
     static HttpHeaderEntry *parse(const char *field_start, const char *field_end);
     HttpHeaderEntry *clone() const;
@@ -91,7 +59,7 @@
     int getInt() const;
     int64_t getInt64() const;
 
-    http_hdr_type id;
+    Http::HdrType id;
     String name;
     String value;
 };
@@ -119,27 +87,27 @@
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
-    HttpHeaderEntry *findEntry(http_hdr_type id) const;
+    HttpHeaderEntry *findEntry(Http::HdrType id) const;
     int delByName(const char *name);
-    int delById(http_hdr_type id);
+    int delById(Http::HdrType id);
     void delAt(HttpHeaderPos pos, int &headers_deleted);
     void refreshMask();
     void addEntry(HttpHeaderEntry * e);
     void insertEntry(HttpHeaderEntry * e);
-    String getList(http_hdr_type id) const;
-    bool getList(http_hdr_type id, String *s) const;
-    String getStrOrList(http_hdr_type id) const;
+    String getList(Http::HdrType id) const;
+    bool getList(Http::HdrType id, String *s) const;
+    String getStrOrList(Http::HdrType id) const;
     String getByName(const char *name) const;
     /// sets value and returns true iff a [possibly empty] named field is there
     bool getByNameIfPresent(const char *name, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
-    String getListMember(http_hdr_type id, const char *member, const char separator) const;
-    int has(http_hdr_type id) const;
-    void putInt(http_hdr_type id, int number);
-    void putInt64(http_hdr_type id, int64_t number);
-    void putTime(http_hdr_type id, time_t htime);
-    void insertTime(http_hdr_type id, time_t htime);
-    void putStr(http_hdr_type id, const char *str);
+    String getListMember(Http::HdrType id, const char *member, const char separator) const;
+    int has(Http::HdrType id) const;
+    void putInt(Http::HdrType id, int number);
+    void putInt64(Http::HdrType id, int64_t number);
+    void putTime(Http::HdrType id, time_t htime);
+    void insertTime(Http::HdrType id, time_t htime);
+    void putStr(Http::HdrType id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
     void putContRange(const HttpHdrContRange * cr);
@@ -147,19 +115,19 @@
     void putSc(HttpHdrSc *sc);
     void putWarning(const int code, const char *const text); ///< add a Warning header
     void putExt(const char *name, const char *value);
-    int getInt(http_hdr_type id) const;
-    int64_t getInt64(http_hdr_type id) const;
-    time_t getTime(http_hdr_type id) const;
-    const char *getStr(http_hdr_type id) const;
-    const char *getLastStr(http_hdr_type id) const;
+    int getInt(Http::HdrType id) const;
+    int64_t getInt64(Http::HdrType id) const;
+    time_t getTime(Http::HdrType id) const;
+    const char *getStr(Http::HdrType id) const;
+    const char *getLastStr(Http::HdrType id) const;
     HttpHdrCc *getCc() const;
     HttpHdrRange *getRange() const;
     HttpHdrSc *getSc() const;
     HttpHdrContRange *getContRange() const;
-    const char *getAuth(http_hdr_type id, const char *auth_scheme) const;
-    ETag getETag(http_hdr_type id) const;
-    TimeOrTag getTimeOrTag(http_hdr_type id) const;
-    int hasListMember(http_hdr_type id, const char *member, const char separator) const;
+    const char *getAuth(Http::HdrType id, const char *auth_scheme) const;
+    ETag getETag(Http::HdrType id) const;
+    TimeOrTag getTimeOrTag(Http::HdrType id) const;
+    int hasListMember(Http::HdrType id, const char *member, const char separator) const;
     int hasByNameListMember(const char *name, const char *member, const char separator) const;
     void removeHopByHopEntries();
     inline bool chunked() const; ///< whether message uses chunked Transfer-Encoding
@@ -175,7 +143,7 @@
     void removeConnectionHeaderEntries();
 
 private:
-    HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
+    HttpHeaderEntry *findLastEntry(Http::HdrType id) const;
 };
 
 int httpHeaderParseQuotedString(const char *start, const int len, String *val);
@@ -185,13 +153,13 @@
 
 int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
 void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
-void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
+void httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
 {
-    return has(HDR_TRANSFER_ENCODING) &&
-           hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
+    return has(Http::HdrType::TRANSFER_ENCODING) &&
+           hasListMember(Http::HdrType::TRANSFER_ENCODING, "chunked", ',');
 }
 
 void httpHeaderInitModule(void);

=== modified file 'src/HttpHeaderFieldInfo.h'
--- src/HttpHeaderFieldInfo.h	2015-01-13 07:25:36 +0000
+++ src/HttpHeaderFieldInfo.h	2015-08-04 20:12:39 +0000
@@ -9,6 +9,7 @@
 #ifndef SQUID_HTTPHEADERFIELDINFO_H_
 #define SQUID_HTTPHEADERFIELDINFO_H_
 
+#include "http/RegisteredHeaders.h"
 #include "HttpHeaderFieldStat.h"
 #include "SquidString.h"
 
@@ -16,11 +17,11 @@
 class HttpHeaderFieldInfo
 {
 public:
-    HttpHeaderFieldInfo() : id(HDR_ACCEPT), type(ftInvalid) {}
+    HttpHeaderFieldInfo() : id(Http::HdrType::ACCEPT), type(Http::HdrFieldType::ftInvalid) {}
 
-    http_hdr_type id;
+    Http::HdrType id;
     String name;
-    field_type type;
+    Http::HdrFieldType type;
     HttpHeaderFieldStat stat;
 };
 

=== modified file 'src/HttpHeaderStat.h'
--- src/HttpHeaderStat.h	2015-01-13 07:25:36 +0000
+++ src/HttpHeaderStat.h	2015-08-04 19:57:07 +0000
@@ -9,6 +9,8 @@
 #ifndef HTTPHEADERSTAT_H_
 #define HTTPHEADERSTAT_H_
 
+#include "HttpHdrCc.h"
+#include "HttpHdrSc.h"
 #include "StatHist.h"
 
 /// HTTP per header statistics
@@ -25,7 +27,7 @@
         busyDestroyedCount(0)
     {
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(HDR_ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
         ccTypeDistr.enumInit(CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -41,7 +43,7 @@
     {
         assert(label);
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(HDR_ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
         ccTypeDistr.enumInit(CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }

=== modified file 'src/HttpHeaderTools.cc'
--- src/HttpHeaderTools.cc	2015-03-03 16:51:03 +0000
+++ src/HttpHeaderTools.cc	2015-08-04 21:04:09 +0000
@@ -18,6 +18,7 @@
 #include "ConfigParser.h"
 #include "fde.h"
 #include "globals.h"
+#include "http/RegisteredHeaders.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
@@ -36,45 +37,7 @@
 #include <cerrno>
 #include <string>
 
-static void httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs);
-
-HttpHeaderFieldInfo *
-httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count)
-{
-    int i;
-    HttpHeaderFieldInfo *table = NULL;
-    assert(attrs && count);
-
-    /* allocate space */
-    table = new HttpHeaderFieldInfo[count];
-
-    for (i = 0; i < count; ++i) {
-        const http_hdr_type id = attrs[i].id;
-        HttpHeaderFieldInfo *info = table + id;
-        /* sanity checks */
-        assert(id >= 0 && id < count);
-        assert(attrs[i].name);
-        assert(info->id == HDR_ACCEPT && info->type == ftInvalid);  /* was not set before */
-        /* copy and init fields */
-        info->id = id;
-        info->type = attrs[i].type;
-        info->name = attrs[i].name;
-        assert(info->name.size());
-    }
-
-    return table;
-}
-
-void
-httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * table, int count)
-{
-    int i;
-
-    for (i = 0; i < count; ++i)
-        table[i].name.clean();
-
-    delete [] table;
-}
+static void httpHeaderPutStrvf(HttpHeader * hdr, Http::HdrType id, const char *fmt, va_list vargs);
 
 void
 httpHeaderMaskInit(HttpHeaderMask * mask, int value)
@@ -84,7 +47,7 @@
 
 /** calculates a bit mask of a given array; does not reset mask! */
 void
-httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count)
+httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count)
 {
     size_t i;
     const int * enums = (const int *) http_hdr_type_enums;
@@ -99,7 +62,7 @@
 
 /* same as httpHeaderPutStr, but formats the string using snprintf first */
 void
-httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...)
+httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
@@ -110,7 +73,7 @@
 
 /* used by httpHeaderPutStrf */
 static void
-httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs)
+httpHeaderPutStrvf(HttpHeader * hdr, Http::HdrType id, const char *fmt, va_list vargs)
 {
     MemBuf mb;
     mb.init();
@@ -132,8 +95,8 @@
 
 /**
  * return true if a given directive is found in at least one of
- * the "connection" header-fields note: if HDR_PROXY_CONNECTION is
- * present we ignore HDR_CONNECTION.
+ * the "connection" header-fields note: if Http::HdrType::PROXY_CONNECTION is
+ * present we ignore Http::HdrType::CONNECTION.
  */
 int
 httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
@@ -143,12 +106,12 @@
     /* what type of header do we have? */
 
 #if USE_HTTP_VIOLATIONS
-    if (hdr->has(HDR_PROXY_CONNECTION))
-        list = hdr->getList(HDR_PROXY_CONNECTION);
+    if (hdr->has(Http::HdrType::PROXY_CONNECTION))
+        list = hdr->getList(Http::HdrType::PROXY_CONNECTION);
     else
 #endif
-        if (hdr->has(HDR_CONNECTION))
-            list = hdr->getList(HDR_CONNECTION);
+        if (hdr->has(Http::HdrType::CONNECTION))
+            list = hdr->getList(Http::HdrType::CONNECTION);
         else
             return 0;
 
@@ -411,7 +374,7 @@
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i)
+    for (int i = 0; i < Http::HdrType::ENUM_END; ++i)
         header_mangler_clean(known[i]);
 
     typedef ManglersByName::iterator MBNI;
@@ -424,9 +387,8 @@
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i) {
-        header_mangler_dump_access(entry, name, known[i],
-                                   httpHeaderNameById(i));
+    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
+        header_mangler_dump_access(entry, name, known[i], Http::HeaderTable[i].name);
     }
 
     typedef ManglersByName::const_iterator MBNCI;
@@ -439,9 +401,8 @@
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i) {
-        header_mangler_dump_replacement(entry, name, known[i],
-                                        httpHeaderNameById(i));
+    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
+        header_mangler_dump_replacement(entry, name, known[i],Http::HeaderTable[i].name);
     }
 
     typedef ManglersByName::const_iterator MBNCI;
@@ -456,22 +417,22 @@
 headerMangler *
 HeaderManglers::track(const char *name)
 {
-    int id = httpHeaderIdByNameDef(name, strlen(name));
+    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name));
 
-    if (id == HDR_BAD_HDR) { // special keyword or a custom header
+    if (id == Http::HdrType::BAD_HDR) { // special keyword or a custom header
         if (strcmp(name, "All") == 0)
-            id = HDR_ENUM_END;
+            id = Http::HdrType::ENUM_END;
         else if (strcmp(name, "Other") == 0)
-            id = HDR_OTHER;
+            id = Http::HdrType::OTHER;
     }
 
     headerMangler *m = NULL;
-    if (id == HDR_ENUM_END) {
+    if (id == Http::HdrType::ENUM_END) {
         m = &all;
-    } else if (id == HDR_BAD_HDR) {
+    } else if (id == Http::HdrType::BAD_HDR) {
         m = &custom[name];
     } else {
-        m = &known[id]; // including HDR_OTHER
+        m = &known[id]; // including Http::HdrType::OTHER
     }
 
     assert(m);
@@ -493,12 +454,12 @@
 HeaderManglers::find(const HttpHeaderEntry &e) const
 {
     // a known header with a configured ACL list
-    if (e.id != HDR_OTHER && 0 <= e.id && e.id < HDR_ENUM_END &&
+    if (e.id != Http::HdrType::OTHER && Http::any_registered_header(e.id) &&
             known[e.id].access_list)
         return &known[e.id];
 
     // a custom header
-    if (e.id == HDR_OTHER) {
+    if (e.id == Http::HdrType::OTHER) {
         // does it have an ACL list configured?
         // Optimize: use a name type that we do not need to convert to here
         const ManglersByName::const_iterator i = custom.find(e.name.termedBuf());
@@ -507,8 +468,8 @@
     }
 
     // Next-to-last resort: "Other" rules match any custom header
-    if (e.id == HDR_OTHER && known[HDR_OTHER].access_list)
-        return &known[HDR_OTHER];
+    if (e.id == Http::HdrType::OTHER && known[Http::HdrType::OTHER].access_list)
+        return &known[Http::HdrType::OTHER];
 
     // Last resort: "All" rules match any header
     if (all.access_list)

=== modified file 'src/HttpHeaderTools.h'
--- src/HttpHeaderTools.h	2015-01-13 07:25:36 +0000
+++ src/HttpHeaderTools.h	2015-08-04 19:57:07 +0000
@@ -24,7 +24,6 @@
 
 class HeaderWithAcl;
 class HttpHeader;
-class HttpHeaderFieldInfo;
 class HttpRequest;
 class StoreEntry;
 class String;
@@ -75,7 +74,7 @@
     typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
-    headerMangler known[HDR_ENUM_END];
+    headerMangler known[static_cast<int>(Http::HdrType::ENUM_END)];
 
     /// one mangler for each custom header
     ManglersByName custom;
@@ -92,7 +91,7 @@
 class HeaderWithAcl
 {
 public:
-    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(HDR_BAD_HDR), quoted(false) {}
+    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(Http::HdrType::BAD_HDR), quoted(false) {}
 
     /// HTTP header field name
     std::string fieldName;
@@ -107,7 +106,7 @@
     Format::Format *valueFormat;
 
     /// internal ID for "known" headers or HDR_OTHER
-    http_hdr_type fieldId;
+    Http::HdrType fieldId;
 
     /// whether fieldValue may contain macros
     bool quoted;
@@ -115,14 +114,9 @@
 
 int httpHeaderParseOffset(const char *start, int64_t * off);
 
-HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
-void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
-http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
-http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
-const char *httpHeaderNameById(int id);
 int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
 int httpHeaderParseInt(const char *start, int *val);
-void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
+void httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...) PRINTF_FORMAT_ARG3;
 
 const char *getStringPrefix(const char *str, size_t len);
 

=== modified file 'src/HttpMsg.cc'
--- src/HttpMsg.cc	2015-04-27 05:31:56 +0000
+++ src/HttpMsg.cc	2015-08-04 19:57:07 +0000
@@ -292,8 +292,8 @@
 void
 HttpMsg::setContentLength(int64_t clen)
 {
-    header.delById(HDR_CONTENT_LENGTH); // if any
-    header.putInt64(HDR_CONTENT_LENGTH, clen);
+    header.delById(Http::HdrType::CONTENT_LENGTH); // if any
+    header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     content_length = clen;
 }
 
@@ -321,7 +321,7 @@
 
 void HttpMsg::hdrCacheInit()
 {
-    content_length = header.getInt64(HDR_CONTENT_LENGTH);
+    content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
     assert(NULL == cache_control);
     cache_control = header.getCc();
 }

=== modified file 'src/HttpReply.cc'
--- src/HttpReply.cc	2015-04-27 05:31:56 +0000
+++ src/HttpReply.cc	2015-08-04 19:57:07 +0000
@@ -40,13 +40,13 @@
  *     all entity-headers except Expires and Content-Location
  */
 static HttpHeaderMask Denied304HeadersMask;
-static http_hdr_type Denied304HeadersArr[] = {
+static Http::HdrType Denied304HeadersArr[] = {
     // hop-by-hop headers
-    HDR_CONNECTION, HDR_KEEP_ALIVE, HDR_PROXY_AUTHENTICATE, HDR_PROXY_AUTHORIZATION,
-    HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE,
+    Http::HdrType::CONNECTION, Http::HdrType::KEEP_ALIVE, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::TE, Http::HdrType::TRAILER, Http::HdrType::TRANSFER_ENCODING, Http::HdrType::UPGRADE,
     // entity headers
-    HDR_ALLOW, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE, HDR_CONTENT_LENGTH,
-    HDR_CONTENT_MD5, HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_LAST_MODIFIED
+    Http::HdrType::ALLOW, Http::HdrType::CONTENT_ENCODING, Http::HdrType::CONTENT_LANGUAGE, Http::HdrType::CONTENT_LENGTH,
+    Http::HdrType::CONTENT_MD5, Http::HdrType::CONTENT_RANGE, Http::HdrType::CONTENT_TYPE, Http::HdrType::LAST_MODIFIED
 };
 
 /* module initialization */
@@ -135,7 +135,7 @@
 HttpReply *
 HttpReply::make304() const
 {
-    static const http_hdr_type ImsEntries[] = {HDR_DATE, HDR_CONTENT_TYPE, HDR_EXPIRES, HDR_LAST_MODIFIED, /* eof */ HDR_OTHER};
+    static const Http::HdrType ImsEntries[] = {Http::HdrType::DATE, Http::HdrType::CONTENT_TYPE, Http::HdrType::EXPIRES, Http::HdrType::LAST_MODIFIED, /* eof */ Http::HdrType::OTHER};
 
     HttpReply *rv = new HttpReply;
     int t;
@@ -151,7 +151,7 @@
     /* rv->keep_alive */
     rv->sline.set(Http::ProtocolVersion(), Http::scNotModified, NULL);
 
-    for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
+    for (t = 0; ImsEntries[t] != Http::HdrType::OTHER; ++t)
         if ((e = header.findEntry(ImsEntries[t])))
             rv->header.addEntry(e->clone());
 
@@ -178,24 +178,24 @@
     HttpHeader *hdr;
     sline.set(Http::ProtocolVersion(), status, reason);
     hdr = &header;
-    hdr->putStr(HDR_SERVER, visible_appname_string);
-    hdr->putStr(HDR_MIME_VERSION, "1.0");
-    hdr->putTime(HDR_DATE, squid_curtime);
+    hdr->putStr(Http::HdrType::SERVER, visible_appname_string);
+    hdr->putStr(Http::HdrType::MIME_VERSION, "1.0");
+    hdr->putTime(Http::HdrType::DATE, squid_curtime);
 
     if (ctype) {
-        hdr->putStr(HDR_CONTENT_TYPE, ctype);
+        hdr->putStr(Http::HdrType::CONTENT_TYPE, ctype);
         content_type = ctype;
     } else
         content_type = String();
 
     if (clen >= 0)
-        hdr->putInt64(HDR_CONTENT_LENGTH, clen);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, clen);
 
     if (expiresTime >= 0)
-        hdr->putTime(HDR_EXPIRES, expiresTime);
+        hdr->putTime(Http::HdrType::EXPIRES, expiresTime);
 
     if (lmt > 0)        /* this used to be lmt != 0 @?@ */
-        hdr->putTime(HDR_LAST_MODIFIED, lmt);
+        hdr->putTime(Http::HdrType::LAST_MODIFIED, lmt);
 
     date = squid_curtime;
 
@@ -212,10 +212,10 @@
     HttpHeader *hdr;
     sline.set(Http::ProtocolVersion(), status, NULL);
     hdr = &header;
-    hdr->putStr(HDR_SERVER, APP_FULLNAME);
-    hdr->putTime(HDR_DATE, squid_curtime);
-    hdr->putInt64(HDR_CONTENT_LENGTH, 0);
-    hdr->putStr(HDR_LOCATION, loc);
+    hdr->putStr(Http::HdrType::SERVER, APP_FULLNAME);
+    hdr->putTime(Http::HdrType::DATE, squid_curtime);
+    hdr->putInt64(Http::HdrType::CONTENT_LENGTH, 0);
+    hdr->putStr(Http::HdrType::LOCATION, loc);
     date = squid_curtime;
     content_length = 0;
 }
@@ -239,9 +239,9 @@
         return 0;
 
     /* ETag */
-    one = header.getStrOrList(HDR_ETAG);
+    one = header.getStrOrList(Http::HdrType::ETAG);
 
-    two = otherRep->header.getStrOrList(HDR_ETAG);
+    two = otherRep->header.getStrOrList(Http::HdrType::ETAG);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
@@ -253,9 +253,9 @@
         return 0;
 
     /* MD5 */
-    one = header.getStrOrList(HDR_CONTENT_MD5);
+    one = header.getStrOrList(Http::HdrType::CONTENT_MD5);
 
-    two = otherRep->header.getStrOrList(HDR_CONTENT_MD5);
+    two = otherRep->header.getStrOrList(Http::HdrType::CONTENT_MD5);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
@@ -311,16 +311,16 @@
     }
 
     if (Config.onoff.vary_ignore_expire &&
-            header.has(HDR_VARY)) {
-        const time_t d = header.getTime(HDR_DATE);
-        const time_t e = header.getTime(HDR_EXPIRES);
+            header.has(Http::HdrType::VARY)) {
+        const time_t d = header.getTime(Http::HdrType::DATE);
+        const time_t e = header.getTime(Http::HdrType::EXPIRES);
 
         if (d == e)
             return -1;
     }
 
-    if (header.has(HDR_EXPIRES)) {
-        const time_t e = header.getTime(HDR_EXPIRES);
+    if (header.has(Http::HdrType::EXPIRES)) {
+        const time_t e = header.getTime(Http::HdrType::EXPIRES);
         /*
          * HTTP/1.0 says that robust implementations should consider
          * bad or malformed Expires header as equivalent to "expires
@@ -339,13 +339,13 @@
     HttpMsg::hdrCacheInit();
 
     http_ver = sline.version;
-    content_length = header.getInt64(HDR_CONTENT_LENGTH);
-    date = header.getTime(HDR_DATE);
-    last_modified = header.getTime(HDR_LAST_MODIFIED);
+    content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
+    date = header.getTime(Http::HdrType::DATE);
+    last_modified = header.getTime(Http::HdrType::LAST_MODIFIED);
     surrogate_control = header.getSc();
     content_range = header.getContRange();
     keep_alive = persistent() ? 1 : 0;
-    const char *str = header.getStr(HDR_CONTENT_TYPE);
+    const char *str = header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (str)
         content_type.limitInit(str, strcspn(str, ";\t "));
@@ -593,14 +593,14 @@
 void HttpReply::removeStaleWarnings()
 {
     String warning;
-    if (header.getList(HDR_WARNING, &warning)) {
+    if (header.getList(Http::HdrType::WARNING, &warning)) {
         const String newWarning = removeStaleWarningValues(warning);
         if (warning.size() && warning.size() == newWarning.size())
             return; // some warnings are there and none changed
-        header.delById(HDR_WARNING);
+        header.delById(Http::HdrType::WARNING);
         if (newWarning.size()) { // some warnings left
             HttpHeaderEntry *const e =
-                new HttpHeaderEntry(HDR_WARNING, NULL, newWarning.termedBuf());
+                new HttpHeaderEntry(Http::HdrType::WARNING, NULL, newWarning.termedBuf());
             header.addEntry(e);
         }
     }

=== modified file 'src/HttpRequest.cc'
--- src/HttpRequest.cc	2015-08-01 02:22:12 +0000
+++ src/HttpRequest.cc	2015-08-04 19:57:07 +0000
@@ -593,8 +593,8 @@
 HttpRequest::conditional() const
 {
     return flags.ims ||
-           header.has(HDR_IF_MATCH) ||
-           header.has(HDR_IF_NONE_MATCH);
+           header.has(Http::HdrType::IF_MATCH) ||
+           header.has(Http::HdrType::IF_NONE_MATCH);
 }
 
 void
@@ -653,8 +653,8 @@
 HttpRequest::canHandle1xx() const
 {
     // old clients do not support 1xx unless they sent Expect: 100-continue
-    // (we reject all other HDR_EXPECT values so just check for HDR_EXPECT)
-    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(HDR_EXPECT))
+    // (we reject all other Http::HdrType::EXPECT values so just check for Http::HdrType::EXPECT)
+    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(Http::HdrType::EXPECT))
         return false;
 
     // others must support 1xx control messages

=== modified file 'src/acl/Browser.cc'
--- src/acl/Browser.cc	2015-01-13 07:25:36 +0000
+++ src/acl/Browser.cc	2015-08-04 19:57:07 +0000
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_USER_AGENT>;
+template class ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>;
 

=== modified file 'src/acl/HttpHeaderData.cc'
--- src/acl/HttpHeaderData.cc	2015-07-27 12:51:43 +0000
+++ src/acl/HttpHeaderData.cc	2015-08-04 21:04:09 +0000
@@ -25,7 +25,7 @@
  * TODO: This can be generalised by making the type of the regex_rule into a
  * template parameter - so that we can use different rules types in future.
  */
-ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(HDR_BAD_HDR), regex_rule(new ACLRegexData)
+ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(Http::HdrType::BAD_HDR), regex_rule(new ACLRegexData)
 {}
 
 ACLHTTPHeaderData::~ACLHTTPHeaderData()
@@ -42,7 +42,7 @@
     debugs(28, 3, "aclHeaderData::match: checking '" << hdrName << "'");
 
     String value;
-    if (hdrId != HDR_BAD_HDR) {
+    if (hdrId != Http::HdrType::BAD_HDR) {
         if (!hdr->has(hdrId))
             return false;
         value = hdr->getStrOrList(hdrId);
@@ -76,14 +76,14 @@
     char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
-    hdrId = httpHeaderIdByNameDef(hdrName.rawBuf(), hdrName.size());
+    hdrId = Http::HeaderLookupTable.lookup(SBuf(hdrName));
     regex_rule->parse();
 }
 
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == HDR_BAD_HDR && hdrName.size()==0) || regex_rule->empty();
+    return (hdrId == Http::HdrType::BAD_HDR && hdrName.size()==0) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *

=== modified file 'src/acl/HttpHeaderData.h'
--- src/acl/HttpHeaderData.h	2015-01-13 07:25:36 +0000
+++ src/acl/HttpHeaderData.h	2015-08-04 19:57:07 +0000
@@ -27,7 +27,7 @@
     virtual ACLData<HttpHeader*> *clone() const;
 
 private:
-    http_hdr_type hdrId;                /**< set if header is known */
+    Http::HdrType hdrId;                /**< set if header is known */
     String hdrName;                     /**< always set */
     ACLData<char const *> * regex_rule;
 };

=== modified file 'src/acl/Referer.cc'
--- src/acl/Referer.cc	2015-01-13 07:25:36 +0000
+++ src/acl/Referer.cc	2015-08-04 19:57:07 +0000
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_REFERER>;
+template class ACLRequestHeaderStrategy<Http::HdrType::REFERER>;
 

=== modified file 'src/acl/ReplyHeaderStrategy.h'
--- src/acl/ReplyHeaderStrategy.h	2015-01-13 07:25:36 +0000
+++ src/acl/ReplyHeaderStrategy.h	2015-08-04 19:57:07 +0000
@@ -17,7 +17,7 @@
 #include "acl/Strategy.h"
 #include "HttpReply.h"
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
@@ -38,7 +38,7 @@
     ACLReplyHeaderStrategy&operator=(ACLReplyHeaderStrategy const &);
 };
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 int
 ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
@@ -50,7 +50,7 @@
     return data->match(theHeader);
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLReplyHeaderStrategy<header> *
 ACLReplyHeaderStrategy<header>::Instance()
 {
@@ -60,7 +60,7 @@
     return Instance_;
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLReplyHeaderStrategy<header> * ACLReplyHeaderStrategy<header>::Instance_ = NULL;
 
 #endif /* SQUID_REPLYHEADERSTRATEGY_H */

=== modified file 'src/acl/ReplyMimeType.cc'
--- src/acl/ReplyMimeType.cc	2015-01-13 07:25:36 +0000
+++ src/acl/ReplyMimeType.cc	2015-08-04 19:57:07 +0000
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>;
+template class ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
 

=== modified file 'src/acl/ReplyMimeType.h'
--- src/acl/ReplyMimeType.h	2015-01-13 07:25:36 +0000
+++ src/acl/ReplyMimeType.h	2015-08-04 19:57:07 +0000
@@ -28,9 +28,9 @@
 
 template <>
 inline int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->reply->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";

=== modified file 'src/acl/RequestHeaderStrategy.h'
--- src/acl/RequestHeaderStrategy.h	2015-01-13 07:25:36 +0000
+++ src/acl/RequestHeaderStrategy.h	2015-08-04 19:57:07 +0000
@@ -14,7 +14,7 @@
 #include "acl/Strategy.h"
 #include "HttpRequest.h"
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 
 class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
@@ -36,7 +36,7 @@
     ACLRequestHeaderStrategy&operator=(ACLRequestHeaderStrategy const &);
 };
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 int
 ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
@@ -48,7 +48,7 @@
     return data->match(theHeader);
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLRequestHeaderStrategy<header> *
 ACLRequestHeaderStrategy<header>::Instance()
 {
@@ -58,7 +58,7 @@
     return Instance_;
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLRequestHeaderStrategy<header> * ACLRequestHeaderStrategy<header>::Instance_ = NULL;
 
 #endif /* SQUID_REQUESTHEADERSTRATEGY_H */

=== modified file 'src/acl/RequestMimeType.cc'
--- src/acl/RequestMimeType.cc	2015-01-13 07:25:36 +0000
+++ src/acl/RequestMimeType.cc	2015-08-04 19:57:07 +0000
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>;
+template class ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
 

=== modified file 'src/acl/RequestMimeType.h'
--- src/acl/RequestMimeType.h	2015-01-13 07:25:36 +0000
+++ src/acl/RequestMimeType.h	2015-08-04 19:57:07 +0000
@@ -28,9 +28,9 @@
 
 template <>
 inline int
-ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->request->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";

=== modified file 'src/adaptation/ecap/Host.cc'
--- src/adaptation/ecap/Host.cc	2015-01-13 07:25:36 +0000
+++ src/adaptation/ecap/Host.cc	2015-08-04 19:57:07 +0000
@@ -38,12 +38,12 @@
     // assign our host-specific IDs to well-known names
     // this code can run only once
 
-    libecap::headerTransferEncoding.assignHostId(HDR_TRANSFER_ENCODING);
-    libecap::headerReferer.assignHostId(HDR_REFERER);
-    libecap::headerContentLength.assignHostId(HDR_CONTENT_LENGTH);
-    libecap::headerVia.assignHostId(HDR_VIA);
-    // TODO: libecap::headerXClientIp.assignHostId(HDR_X_CLIENT_IP);
-    // TODO: libecap::headerXServerIp.assignHostId(HDR_X_SERVER_IP);
+    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);
+    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);
+    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);
+    libecap::headerVia.assignHostId(Http::HdrType::VIA);
+    // TODO: libecap::headerXClientIp.assignHostId(Http::HdrType::X_CLIENT_IP);
+    // TODO: libecap::headerXServerIp.assignHostId(Http::HdrType::X_SERVER_IP);
 
     libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);
     libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);

=== modified file 'src/adaptation/ecap/MessageRep.cc'
--- src/adaptation/ecap/MessageRep.cc	2015-07-19 13:23:01 +0000
+++ src/adaptation/ecap/MessageRep.cc	2015-08-04 19:57:07 +0000
@@ -32,9 +32,9 @@
 bool
 Adaptation::Ecap::HeaderRep::hasAny(const Name &name) const
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
+    const Http::HdrType squidId = TranslateHeaderId(name);
     // XXX: optimize to remove getByName: we do not need the value here
-    return squidId == HDR_OTHER ?
+    return squidId == Http::HdrType::OTHER ?
            theHeader.getByName(name.image().c_str()).size() > 0:
            (bool)theHeader.has(squidId);
 }
@@ -42,8 +42,8 @@
 Adaptation::Ecap::HeaderRep::Value
 Adaptation::Ecap::HeaderRep::value(const Name &name) const
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
-    const String value = squidId == HDR_OTHER ?
+    const Http::HdrType squidId = TranslateHeaderId(name);
+    const String value = squidId == Http::HdrType::OTHER ?
                          theHeader.getByName(name.image().c_str()) :
                          theHeader.getStrOrList(squidId);
     return value.size() > 0 ?
@@ -53,26 +53,26 @@
 void
 Adaptation::Ecap::HeaderRep::add(const Name &name, const Value &value)
 {
-    const http_hdr_type squidId = TranslateHeaderId(name); // HDR_OTHER OK
+    const Http::HdrType squidId = TranslateHeaderId(name); // Http::HdrType::OTHER OK
     HttpHeaderEntry *e = new HttpHeaderEntry(squidId, name.image().c_str(),
             value.toString().c_str());
     theHeader.addEntry(e);
 
-    if (squidId == HDR_CONTENT_LENGTH)
-        theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
+    if (squidId == Http::HdrType::CONTENT_LENGTH)
+        theMessage.content_length = theHeader.getInt64(Http::HdrType::CONTENT_LENGTH);
 }
 
 void
 Adaptation::Ecap::HeaderRep::removeAny(const Name &name)
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
-    if (squidId == HDR_OTHER)
+    const Http::HdrType squidId = TranslateHeaderId(name);
+    if (squidId == Http::HdrType::OTHER)
         theHeader.delByName(name.image().c_str());
     else
         theHeader.delById(squidId);
 
-    if (squidId == HDR_CONTENT_LENGTH)
-        theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
+    if (squidId == Http::HdrType::CONTENT_LENGTH)
+        theMessage.content_length = theHeader.getInt64(Http::HdrType::CONTENT_LENGTH);
 }
 
 void
@@ -103,12 +103,12 @@
     Must(theMessage.parse(buf.start, buf.size, true, &error));
 }
 
-http_hdr_type
+Http::HdrType
 Adaptation::Ecap::HeaderRep::TranslateHeaderId(const Name &name)
 {
     if (name.assignedHostId())
-        return static_cast<http_hdr_type>(name.hostId());
-    return HDR_OTHER;
+        return static_cast<Http::HdrType>(name.hostId());
+    return Http::HdrType::OTHER;
 }
 
 /* FirstLineRep */

=== modified file 'src/adaptation/ecap/MessageRep.h'
--- src/adaptation/ecap/MessageRep.h	2015-01-13 07:25:36 +0000
+++ src/adaptation/ecap/MessageRep.h	2015-08-04 19:57:07 +0000
@@ -51,7 +51,7 @@
     virtual void parse(const Area &buf); // throws on failures
 
 protected:
-    static http_hdr_type TranslateHeaderId(const Name &name);
+    static Http::HdrType TranslateHeaderId(const Name &name);
 
 private:
     HttpHeader &theHeader; // the header being translated to libecap

=== modified file 'src/adaptation/icap/ModXact.cc'
--- src/adaptation/icap/ModXact.cc	2015-07-26 18:26:52 +0000
+++ src/adaptation/icap/ModXact.cc	2015-08-04 19:57:07 +0000
@@ -833,12 +833,12 @@
     // update the adaptation plan if needed (all status codes!)
     if (service().cfg().routing) {
         String services;
-        if (icapReply->header.getList(HDR_X_NEXT_SERVICES, &services)) {
+        if (icapReply->header.getList(Http::HdrType::X_NEXT_SERVICES, &services)) {
             Adaptation::History::Pointer ah = request->adaptHistory(true);
             if (ah != NULL)
                 ah->updateNextServices(services);
         }
-    } // TODO: else warn (occasionally!) if we got HDR_X_NEXT_SERVICES
+    } // TODO: else warn (occasionally!) if we got Http::HdrType::X_NEXT_SERVICES
 
     // We need to store received ICAP headers for <icapLastHeader logformat option.
     // If we already have stored headers from previous ICAP transaction related to this
@@ -1341,12 +1341,12 @@
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
-    if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
+    if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getByName("Proxy-Authenticate");
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
-    if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
+    if (virgin.header->header.has(Http::HdrType::PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
         buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
@@ -1553,7 +1553,7 @@
     // end cloning
 
     // remove all hop-by-hop headers from the clone
-    headClone->header.delById(HDR_PROXY_AUTHENTICATE);
+    headClone->header.delById(Http::HdrType::PROXY_AUTHENTICATE);
     headClone->header.removeHopByHopEntries();
 
     // pack polished HTTP header

=== modified file 'src/adaptation/icap/Options.cc'
--- src/adaptation/icap/Options.cc	2015-07-07 11:53:08 +0000
+++ src/adaptation/icap/Options.cc	2015-08-04 19:57:07 +0000
@@ -117,15 +117,15 @@
 
     cfgIntHeader(h, "Options-TTL", theTTL);
 
-    theTimestamp = h->getTime(HDR_DATE);
+    theTimestamp = h->getTime(Http::HdrType::DATE);
 
     if (theTimestamp < 0)
         theTimestamp = squid_curtime;
 
-    if (h->hasListMember(HDR_ALLOW, "204", ','))
+    if (h->hasListMember(Http::HdrType::ALLOW, "204", ','))
         allow204 = true;
 
-    if (h->hasListMember(HDR_ALLOW, "206", ','))
+    if (h->hasListMember(Http::HdrType::ALLOW, "206", ','))
         allow206 = true;
 
     cfgIntHeader(h, "Preview", preview);

=== modified file 'src/auth/Acl.cc'
--- src/auth/Acl.cc	2015-01-13 07:25:36 +0000
+++ src/auth/Acl.cc	2015-08-04 19:57:07 +0000
@@ -28,7 +28,7 @@
 {
     ACLFilledChecklist *checklist = Filled(ch);
     HttpRequest *request = checklist->request;
-    http_hdr_type headertype;
+    Http::HdrType headertype;
 
     if (NULL == request) {
         fatal ("requiresRequest SHOULD have been true for this ACL!!");
@@ -42,13 +42,13 @@
             return ACCESS_DENIED;
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
-        headertype = HDR_AUTHORIZATION;
+        headertype = Http::HdrType::AUTHORIZATION;
     } else if (request->flags.intercepted || request->flags.interceptTproxy) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
         /* Proxy authorization on proxy requests */
-        headertype = HDR_PROXY_AUTHORIZATION;
+        headertype = Http::HdrType::PROXY_AUTHORIZATION;
     }
 
     /* get authed here */

=== modified file 'src/auth/Config.h'
--- src/auth/Config.h	2015-01-13 07:25:36 +0000
+++ src/auth/Config.h	2015-08-04 19:57:07 +0000
@@ -20,7 +20,7 @@
 class HttpRequest;
 class wordlist;
 
-/* for http_hdr_type parameters-by-value */
+/* for Http::HdrType parameters-by-value */
 #include "HttpHeader.h"
 
 namespace Format
@@ -106,7 +106,7 @@
     virtual bool dump(StoreEntry *, const char *, Config *) const;
 
     /** add headers as needed when challenging for auth */
-    virtual void fixHeader(UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *) = 0;
+    virtual void fixHeader(UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *) = 0;
 
     /// Find any existing user credentials in the authentication cache by name and type.
     virtual Auth::User::Pointer findUserInCache(const char *nameKey, Auth::Type type);

=== modified file 'src/auth/UserRequest.cc'
--- src/auth/UserRequest.cc	2015-01-13 07:25:36 +0000
+++ src/auth/UserRequest.cc	2015-08-04 19:57:07 +0000
@@ -218,7 +218,7 @@
  * This is basically a handle approach.
  */
 static void
-authenticateAuthenticateUser(Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, ConnStateData * conn, http_hdr_type type)
+authenticateAuthenticateUser(Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, ConnStateData * conn, Http::HdrType type)
 {
     assert(auth_user_request.getRaw() != NULL);
 
@@ -271,7 +271,7 @@
  * Caller is responsible for locking and unlocking their *auth_user_request!
  */
 AuthAclState
-Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
+Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
 {
     const char *proxy_auth;
     assert(headertype != 0);
@@ -433,7 +433,7 @@
 }
 
 AuthAclState
-Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer * aUR, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
+Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer * aUR, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
 {
     // If we have already been called, return the cached value
     Auth::UserRequest::Pointer t = authTryGetUser(*aUR, conn, request);
@@ -464,24 +464,24 @@
 Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal)
 /* send the auth types we are configured to support (and have compiled in!) */
 {
-    http_hdr_type type;
+    Http::HdrType type;
 
     switch (rep->sline.status()) {
 
     case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
-        type = HDR_PROXY_AUTHENTICATE;
+        type = Http::HdrType::PROXY_AUTHENTICATE;
         break;
 
     case Http::scUnauthorized:
         /* WWW Authorisation needed */
-        type = HDR_WWW_AUTHENTICATE;
+        type = Http::HdrType::WWW_AUTHENTICATE;
         break;
 
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
-        type = HDR_ENUM_END;
+        type = Http::HdrType::ENUM_END;
         break;
     }
 

=== modified file 'src/auth/UserRequest.h'
--- src/auth/UserRequest.h	2015-04-16 13:18:44 +0000
+++ src/auth/UserRequest.h	2015-08-04 19:57:07 +0000
@@ -126,7 +126,7 @@
      */
     bool valid() const;
 
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type) = 0;
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type) = 0;
 
     /* template method - what needs to be done next? advertise schemes, challenge, handle error, nothing? */
     virtual Direction module_direction() = 0;
@@ -162,7 +162,7 @@
      *
      * \return Some AUTH_ACL_* state
      */
-    static AuthAclState tryToAuthenticateAndSetAuthUser(UserRequest::Pointer *aUR, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &);
+    static AuthAclState tryToAuthenticateAndSetAuthUser(UserRequest::Pointer *aUR, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &);
 
     /// Add the appropriate [Proxy-]Authenticate header to the given reply
     static void addReplyAuthHeader(HttpReply * rep, UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal);
@@ -218,7 +218,7 @@
 
 private:
 
-    static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
+    static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
 
     /** return a message on the 407 error pages */
     char *message;

=== modified file 'src/auth/basic/Config.cc'
--- src/auth/basic/Config.cc	2015-06-05 05:56:36 +0000
+++ src/auth/basic/Config.cc	2015-08-04 19:57:07 +0000
@@ -72,7 +72,7 @@
 }
 
 void
-Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
+Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)
 {
     if (authenticateProgram) {
         debugs(29, 9, "Sending type:" << hdrType << " header: 'Basic realm=\"" << realm << "\"'");

=== modified file 'src/auth/basic/Config.h'
--- src/auth/basic/Config.h	2015-01-13 07:25:36 +0000
+++ src/auth/basic/Config.h	2015-08-04 19:57:07 +0000
@@ -30,7 +30,7 @@
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     void decode(char const *httpAuthHeader, Auth::UserRequest::Pointer);

=== modified file 'src/auth/basic/UserRequest.cc'
--- src/auth/basic/UserRequest.cc	2015-01-13 07:25:36 +0000
+++ src/auth/basic/UserRequest.cc	2015-08-04 19:57:07 +0000
@@ -50,7 +50,7 @@
 /* log a basic user in
  */
 void
-Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, http_hdr_type)
+Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, Http::HdrType)
 {
     assert(user() != NULL);
 

=== modified file 'src/auth/basic/UserRequest.h'
--- src/auth/basic/UserRequest.h	2015-01-13 07:25:36 +0000
+++ src/auth/basic/UserRequest.h	2015-08-04 19:57:07 +0000
@@ -31,7 +31,7 @@
     virtual ~UserRequest() { assert(LockCount()==0); }
 
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData *conn, Http::HdrType type);
     virtual Auth::Direction module_direction();
     virtual void startHelperLookup(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();

=== modified file 'src/auth/digest/Config.cc'
--- src/auth/digest/Config.cc	2015-07-28 12:12:10 +0000
+++ src/auth/digest/Config.cc	2015-08-04 19:57:07 +0000
@@ -509,7 +509,7 @@
 
 /* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */
 void
-Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
+Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)
 {
     if (!authenticateProgram)
         return;

=== modified file 'src/auth/digest/Config.h'
--- src/auth/digest/Config.h	2015-02-08 09:37:12 +0000
+++ src/auth/digest/Config.h	2015-08-04 19:57:07 +0000
@@ -79,7 +79,7 @@
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);

=== modified file 'src/auth/digest/UserRequest.cc'
--- src/auth/digest/UserRequest.cc	2015-01-20 10:29:45 +0000
+++ src/auth/digest/UserRequest.cc	2015-08-04 19:57:07 +0000
@@ -78,7 +78,7 @@
 /** log a digest user in
  */
 void
-Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, http_hdr_type)
+Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, Http::HdrType)
 {
     HASHHEX SESSIONKEY;
     HASHHEX HA2 = "";
@@ -145,7 +145,7 @@
                 digest_request->setDenyMessage("Incorrect password");
                 return;
             } else {
-                const char *useragent = request->header.getStr(HDR_USER_AGENT);
+                const char *useragent = request->header.getStr(Http::HdrType::USER_AGENT);
 
                 static Ip::Address last_broken_addr;
                 static int seen_broken_client = 0;
@@ -223,14 +223,14 @@
 void
 Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
 {
-    http_hdr_type type;
+    Http::HdrType type;
 
     /* don't add to authentication error pages */
     if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
             || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
+    type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
 #if WAITING_FOR_TE
     /* test for http/1.1 transfer chunked encoding */
@@ -272,7 +272,7 @@
             || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
+    type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
     if ((static_cast<Auth::Digest::Config*>(digestScheme::GetInstance()->getConfig())->authenticate) && authDigestNonceLastRequest(nonce)) {
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());

=== modified file 'src/auth/digest/UserRequest.h'
--- src/auth/digest/UserRequest.h	2015-01-13 07:25:36 +0000
+++ src/auth/digest/UserRequest.h	2015-08-04 19:57:07 +0000
@@ -32,7 +32,7 @@
     virtual ~UserRequest();
 
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
 #if WAITING_FOR_TE

=== modified file 'src/auth/negotiate/Config.cc'
--- src/auth/negotiate/Config.cc	2015-06-05 05:56:36 +0000
+++ src/auth/negotiate/Config.cc	2015-08-04 19:57:07 +0000
@@ -174,7 +174,7 @@
 /* Negotiate Scheme */
 
 void
-Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type reqType, HttpRequest * request)
+Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType reqType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;

=== modified file 'src/auth/negotiate/Config.h'
--- src/auth/negotiate/Config.h	2015-01-13 07:25:36 +0000
+++ src/auth/negotiate/Config.h	2015-08-04 19:57:07 +0000
@@ -30,7 +30,7 @@
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);

=== modified file 'src/auth/negotiate/UserRequest.cc'
--- src/auth/negotiate/UserRequest.cc	2015-04-16 13:18:44 +0000
+++ src/auth/negotiate/UserRequest.cc	2015-08-04 19:57:07 +0000
@@ -181,7 +181,7 @@
 }
 
 void
-Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
+Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, Http::HdrType type)
 {
     /* Check that we are in the client side, where we can generate
      * auth challenges */

=== modified file 'src/auth/negotiate/UserRequest.h'
--- src/auth/negotiate/UserRequest.h	2015-01-31 14:10:25 +0000
+++ src/auth/negotiate/UserRequest.h	2015-08-04 19:57:07 +0000
@@ -30,7 +30,7 @@
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();

=== modified file 'src/auth/ntlm/Config.cc'
--- src/auth/ntlm/Config.cc	2015-06-05 05:56:36 +0000
+++ src/auth/ntlm/Config.cc	2015-08-04 19:57:07 +0000
@@ -164,7 +164,7 @@
 /* NTLM Scheme */
 
 void
-Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest * request)
+Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;

=== modified file 'src/auth/ntlm/Config.h'
--- src/auth/ntlm/Config.h	2015-01-13 07:25:36 +0000
+++ src/auth/ntlm/Config.h	2015-08-04 19:57:07 +0000
@@ -33,7 +33,7 @@
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);

=== modified file 'src/auth/ntlm/UserRequest.cc'
--- src/auth/ntlm/UserRequest.cc	2015-04-16 13:18:44 +0000
+++ src/auth/ntlm/UserRequest.cc	2015-08-04 19:57:07 +0000
@@ -175,7 +175,7 @@
 }
 
 void
-Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
+Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, Http::HdrType type)
 {
     /* Check that we are in the client side, where we can generate
      * auth challenges */

=== modified file 'src/auth/ntlm/UserRequest.h'
--- src/auth/ntlm/UserRequest.h	2015-01-13 07:25:36 +0000
+++ src/auth/ntlm/UserRequest.h	2015-08-04 19:57:07 +0000
@@ -29,7 +29,7 @@
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Auth::Direction module_direction();
     virtual void startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();

=== modified file 'src/base/LookupTable.h'
--- src/base/LookupTable.h	2015-07-28 12:12:10 +0000
+++ src/base/LookupTable.h	2015-08-04 14:58:58 +0000
@@ -14,11 +14,27 @@
 #include <map>
 
 /**
- * SBuf -> enum lookup table
+ * a record in the initializer list for a LookupTable
+ *
+ * In case it is wished to extend the structure of a LookupTable's initializer
+ * list, it can be done by using a custom struct which must match
+ * LookupTableRecord's signature plus any extra custom fields the user may
+ * wish to add; the extended record type must then be passed as RecordType
+ * template parameter to LookupTable.
+ */
+template <typename EnumType>
+struct LookupTableRecord
+{
+    const char *name;
+    EnumType id;
+};
+
+/**
+ * SBuf -> case-insensitive enum lookup table
  *
  * How to use:
  * enum enum_type { ... };
- * static const LookupTable<enum_type>::Record initializerTable[] {
+ * static const LookupTable<enum_type>::Record initializerTable[] = {
  *   {"key1", ENUM_1}, {"key2", ENUM_2}, ... {nullptr, ENUM_INVALID_VALUE}
  * };
  * LookupTable<enum_type> lookupTableInstance(ENUM_INVALID_VALUE, initializerTable);
@@ -29,15 +45,20 @@
  * if (item != ENUM_INVALID_VALUE) { // do stuff }
  *
  */
-template<typename EnumType>
+
+class SBufCaseInsensitiveLess : public std::binary_function<SBuf, SBuf, bool> {
+public:
+    bool operator() (const SBuf &x, const SBuf &y) const {
+        return x.caseCmp(y) < 0;
+    }
+};
+
+template<typename EnumType, typename RecordType = LookupTableRecord<EnumType> >
 class LookupTable
 {
 public:
     /// element of the lookup table initialization list
-    typedef struct {
-        const char *name;
-        EnumType id;
-    } Record;
+    typedef RecordType Record;
 
     LookupTable(const EnumType theInvalid, const Record data[]) :
         invalidValue(theInvalid)
@@ -46,6 +67,7 @@
             lookupTable[SBuf(data[i].name)] = data[i].id;
         }
     }
+
     EnumType lookup(const SBuf &key) const {
         auto r = lookupTable.find(key);
         if (r == lookupTable.end())
@@ -54,7 +76,7 @@
     }
 
 private:
-    typedef std::map<const SBuf, EnumType> lookupTable_t;
+    typedef std::map<const SBuf, EnumType, SBufCaseInsensitiveLess> lookupTable_t;
     lookupTable_t lookupTable;
     EnumType invalidValue;
 };

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-07-29 07:11:17 +0000
+++ src/cache_cf.cc	2015-08-04 21:04:09 +0000
@@ -4608,9 +4608,9 @@
     }
     HeaderWithAcl hwa;
     hwa.fieldName = fn;
-    hwa.fieldId = httpHeaderIdByNameDef(fn, strlen(fn));
-    if (hwa.fieldId == HDR_BAD_HDR)
-        hwa.fieldId = HDR_OTHER;
+    hwa.fieldId = Http::HeaderLookupTable.lookup(SBuf(fn));
+    if (hwa.fieldId == Http::HdrType::BAD_HDR)
+        hwa.fieldId = Http::HdrType::OTHER;
 
     Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
     ConfigParser::EnableMacros();

=== modified file 'src/cache_manager.cc'
--- src/cache_manager.cc	2015-01-13 07:25:36 +0000
+++ src/cache_manager.cc	2015-08-04 19:57:07 +0000
@@ -243,7 +243,7 @@
     // TODO: use the authentication system decode to retrieve these details properly.
 
     /* base 64 _decoded_ user:passwd pair */
-    const char *basic_cookie = request->header.getAuth(HDR_AUTHORIZATION, "Basic");
+    const char *basic_cookie = request->header.getAuth(Http::HdrType::AUTHORIZATION, "Basic");
 
     if (!basic_cookie)
         return;
@@ -356,8 +356,8 @@
         rep->header.putAuth("Basic", actionName);
 #endif
         // Allow cachemgr and other XHR scripts access to our version string
-        if (request->header.has(HDR_ORIGIN)) {
-            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
+        if (request->header.has(Http::HdrType::ORIGIN)) {
+            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(Http::HdrType::ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif
@@ -374,8 +374,8 @@
         return;
     }
 
-    if (request->header.has(HDR_ORIGIN)) {
-        cmd->params.httpOrigin = request->header.getStr(HDR_ORIGIN);
+    if (request->header.has(Http::HdrType::ORIGIN)) {
+        cmd->params.httpOrigin = request->header.getStr(Http::HdrType::ORIGIN);
     }
 
     debugs(16, 2, "CacheManager: " <<
@@ -391,8 +391,8 @@
         if (strncmp(rep->body.content(),"Internal Error:", 15) == 0)
             rep->sline.set(Http::ProtocolVersion(1,1), Http::scNotFound);
         // Allow cachemgr and other XHR scripts access to our version string
-        if (request->header.has(HDR_ORIGIN)) {
-            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
+        if (request->header.has(Http::HdrType::ORIGIN)) {
+            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(Http::HdrType::ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2015-08-03 09:36:20 +0000
+++ src/client_side.cc	2015-08-04 19:57:07 +0000
@@ -1047,8 +1047,8 @@
 
     /* stuff the header with required entries and pack it */
 
-    if (rep->header.has(HDR_CONTENT_TYPE))
-        hdr.putStr(HDR_CONTENT_TYPE, rep->header.getStr(HDR_CONTENT_TYPE));
+    if (rep->header.has(Http::HdrType::CONTENT_TYPE))
+        hdr.putStr(Http::HdrType::CONTENT_TYPE, rep->header.getStr(Http::HdrType::CONTENT_TYPE));
 
     httpHeaderAddContRange(&hdr, *spec, rep->content_length);
 
@@ -1191,7 +1191,7 @@
 static int
 clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
 {
-    const TimeOrTag spec = http->request->header.getTimeOrTag(HDR_IF_RANGE);
+    const TimeOrTag spec = http->request->header.getTimeOrTag(Http::HdrType::IF_RANGE);
     /* check for parsing falure */
 
     if (!spec.valid)
@@ -1199,7 +1199,7 @@
 
     /* got an ETag? */
     if (spec.tag.str) {
-        ETag rep_tag = rep->header.getETag(HDR_ETAG);
+        ETag rep_tag = rep->header.getETag(Http::HdrType::ETAG);
         debugs(33, 3, "clientIfRangeMatch: ETags: " << spec.tag.str << " and " <<
                (rep_tag.str ? rep_tag.str : "<none>"));
 
@@ -1253,7 +1253,7 @@
         range_err = "no [parse-able] reply";
     else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
         range_err = "wrong status code";
-    else if (hdr->has(HDR_CONTENT_RANGE))
+    else if (hdr->has(Http::HdrType::CONTENT_RANGE))
         range_err = "origin server does ranges";
     else if (rep->content_length < 0)
         range_err = "unknown length";
@@ -1263,7 +1263,7 @@
     /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates
      */
-    else if (http->logType.isTcpHit() && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
+    else if (http->logType.isTcpHit() && http->request->header.has(Http::HdrType::IF_RANGE) && !clientIfRangeMatch(http, rep))
         range_err = "If-Range match failed";
     else if (!http->request->range->canonize(rep))
         range_err = "canonization failed";
@@ -1299,7 +1299,7 @@
 
         if (spec_count == 1) {
             if (!replyMatchRequest) {
-                hdr->delById(HDR_CONTENT_RANGE);
+                hdr->delById(Http::HdrType::CONTENT_RANGE);
                 hdr->putContRange(rep->content_range);
                 actual_clen = rep->content_length;
                 //http->range_iter.pos = rep->content_range->spec.begin();
@@ -1311,7 +1311,7 @@
                 assert(*pos);
                 /* append Content-Range */
 
-                if (!hdr->has(HDR_CONTENT_RANGE)) {
+                if (!hdr->has(Http::HdrType::CONTENT_RANGE)) {
                     /* No content range, so this was a full object we are
                      * sending parts of.
                      */
@@ -1327,8 +1327,8 @@
             /* generate boundary string */
             http->range_iter.boundary = http->rangeBoundaryStr();
             /* delete old Content-Type, add ours */
-            hdr->delById(HDR_CONTENT_TYPE);
-            httpHeaderPutStrf(hdr, HDR_CONTENT_TYPE,
+            hdr->delById(Http::HdrType::CONTENT_TYPE);
+            httpHeaderPutStrf(hdr, Http::HdrType::CONTENT_TYPE,
                               "multipart/byteranges; boundary=\"" SQUIDSTRINGPH "\"",
                               SQUIDSTRINGPRINT(http->range_iter.boundary));
             /* Content-Length is not required in multipart responses
@@ -1341,9 +1341,9 @@
         /* replace Content-Length header */
         assert(actual_clen >= 0);
 
-        hdr->delById(HDR_CONTENT_LENGTH);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
 
-        hdr->putInt64(HDR_CONTENT_LENGTH, actual_clen);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, actual_clen);
 
         debugs(33, 3, "clientBuildRangeHeader: actual content length: " << actual_clen);
 
@@ -2609,14 +2609,14 @@
 
     if (request->header.chunked()) {
         chunked = true;
-    } else if (request->header.has(HDR_TRANSFER_ENCODING)) {
-        const String te = request->header.getList(HDR_TRANSFER_ENCODING);
+    } else if (request->header.has(Http::HdrType::TRANSFER_ENCODING)) {
+        const String te = request->header.getList(Http::HdrType::TRANSFER_ENCODING);
         // HTTP/1.1 requires chunking to be the last encoding if there is one
         unsupportedTe = te.size() && te != "identity";
     } // else implied identity coding
 
     mustReplyToOptions = (request->method == Http::METHOD_OPTIONS) &&
-                         (request->header.getInt64(HDR_MAX_FORWARDS) == 0);
+                         (request->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0);
     if (!urlCheckRequest(request.getRaw()) || mustReplyToOptions || unsupportedTe) {
         clientStreamNode *node = context->getClientReplyContext();
         conn->quitAfterError(request.getRaw());
@@ -4556,11 +4556,11 @@
 varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
 {
     const char *vary = request->vary_headers;
-    int has_vary = entry->getReply()->header.has(HDR_VARY);
+    int has_vary = entry->getReply()->header.has(Http::HdrType::VARY);
 #if X_ACCELERATOR_VARY
 
     has_vary |=
-        entry->getReply()->header.has(HDR_X_ACCELERATOR_VARY);
+        entry->getReply()->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 #endif
 
     if (!has_vary || !entry->mem_obj->vary_headers) {

=== modified file 'src/client_side_reply.cc'
--- src/client_side_reply.cc	2015-07-19 13:23:01 +0000
+++ src/client_side_reply.cc	2015-08-04 19:57:07 +0000
@@ -297,7 +297,7 @@
 
     http->request->lastmod = old_entry->lastmod;
 
-    if (!http->request->header.has(HDR_IF_NONE_MATCH)) {
+    if (!http->request->header.has(Http::HdrType::IF_NONE_MATCH)) {
         ETag etag = {NULL, -1}; // TODO: make that a default ETag constructor
         if (old_entry->hasEtag(etag) && !etag.weak)
             http->request->etag = etag.str;
@@ -743,20 +743,20 @@
 
     HttpRequest &r = *http->request;
 
-    if (r.header.has(HDR_IF_MATCH) && !e->hasIfMatchEtag(r)) {
+    if (r.header.has(Http::HdrType::IF_MATCH) && !e->hasIfMatchEtag(r)) {
         // RFC 2616: reply with 412 Precondition Failed if If-Match did not match
         sendPreconditionFailedError();
         return;
     }
 
     bool matchedIfNoneMatch = false;
-    if (r.header.has(HDR_IF_NONE_MATCH)) {
+    if (r.header.has(Http::HdrType::IF_NONE_MATCH)) {
         if (!e->hasIfNoneMatchEtag(r)) {
             // RFC 2616: ignore IMS if If-None-Match did not match
             r.flags.ims = false;
             r.ims = -1;
             r.imslen = 0;
-            r.header.delById(HDR_IF_MODIFIED_SINCE);
+            r.header.delById(Http::HdrType::IF_MODIFIED_SINCE);
             http->logType = LOG_TCP_MISS;
             sendMoreData(result);
             return;
@@ -1318,13 +1318,13 @@
 #endif
 
     if (is_hit)
-        hdr->delById(HDR_SET_COOKIE);
+        hdr->delById(Http::HdrType::SET_COOKIE);
     // TODO: RFC 2965 : Must honour Cache-Control: no-cache="set-cookie2" and remove header.
 
     // if there is not configured a peer proxy with login=PASS or login=PASSTHRU option enabled
     // remove the Proxy-Authenticate header
     if ( !request->peer_login || (strcmp(request->peer_login,"PASS") != 0 && strcmp(request->peer_login,"PASSTHRU") != 0))
-        reply->header.delById(HDR_PROXY_AUTHENTICATE);
+        reply->header.delById(Http::HdrType::PROXY_AUTHENTICATE);
 
     reply->header.removeHopByHopEntries();
 
@@ -1340,27 +1340,27 @@
          * (note that the existing header is passed along unmodified
          * on cache misses)
          */
-        hdr->delById(HDR_AGE);
+        hdr->delById(Http::HdrType::AGE);
         /*
          * This adds the calculated object age. Note that the details of the
          * age calculation is performed by adjusting the timestamp in
          * StoreEntry::timestampsSet(), not here.
          */
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
-            hdr->delById(HDR_DATE);
-            hdr->insertTime(HDR_DATE, squid_curtime);
+            hdr->delById(Http::HdrType::DATE);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
-            HttpHeaderEntry *h = hdr->findEntry(HDR_DATE);
+            HttpHeaderEntry *h = hdr->findEntry(Http::HdrType::DATE);
             if (h)
                 hdr->putExt("X-Origin-Date", h->value.termedBuf());
-            hdr->delById(HDR_DATE);
-            hdr->insertTime(HDR_DATE, squid_curtime);
-            h = hdr->findEntry(HDR_EXPIRES);
+            hdr->delById(Http::HdrType::DATE);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            h = hdr->findEntry(Http::HdrType::EXPIRES);
             if (h && http->storeEntry()->expires >= 0) {
                 hdr->putExt("X-Origin-Expires", h->value.termedBuf());
-                hdr->delById(HDR_EXPIRES);
-                hdr->insertTime(HDR_EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
+                hdr->delById(Http::HdrType::EXPIRES);
+                hdr->insertTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
@@ -1369,7 +1369,7 @@
                 hdr->putExt("X-Cache-Age", age);
             }
         } else if (http->storeEntry()->timestamp <= squid_curtime) {
-            hdr->putInt(HDR_AGE,
+            hdr->putInt(Http::HdrType::AGE,
                         squid_curtime - http->storeEntry()->timestamp);
             /* Signal old objects.  NB: rfc 2616 is not clear,
              * by implication, on whether we should do this to all
@@ -1385,7 +1385,7 @@
                 snprintf (tbuf, sizeof(tbuf), "%s %s %s",
                           "113", ThisCache,
                           "This cache hit is still fresh and more than 1 day old");
-                hdr->putStr(HDR_WARNING, tbuf);
+                hdr->putStr(Http::HdrType::WARNING, tbuf);
             }
         }
     }
@@ -1397,11 +1397,11 @@
      *
      * NP: done after Age: to prevent ENTRY_SPECIAL double-handling this header.
      */
-    if ( !hdr->has(HDR_DATE) ) {
+    if ( !hdr->has(Http::HdrType::DATE) ) {
         if (!http->storeEntry())
-            hdr->insertTime(HDR_DATE, squid_curtime);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
         else if (http->storeEntry()->timestamp > 0)
-            hdr->insertTime(HDR_DATE, http->storeEntry()->timestamp);
+            hdr->insertTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
         else {
             debugs(88,DBG_IMPORTANT,"BUG 3279: HTTP reply without Date:");
             /* dump something useful about the problem */
@@ -1418,13 +1418,13 @@
 
     /* Filter unproxyable authentication types */
     if (http->logType.oldType != LOG_TCP_DENIED &&
-            hdr->has(HDR_WWW_AUTHENTICATE)) {
+            hdr->has(Http::HdrType::WWW_AUTHENTICATE)) {
         HttpHeaderPos pos = HttpHeaderInitPos;
         HttpHeaderEntry *e;
 
         int connection_auth_blocked = 0;
         while ((e = hdr->getEntry(&pos))) {
-            if (e->id == HDR_WWW_AUTHENTICATE) {
+            if (e->id == Http::HdrType::WWW_AUTHENTICATE) {
                 const char *value = e->value.rawBuf();
 
                 if ((strncasecmp(value, "NTLM", 4) == 0 &&
@@ -1441,14 +1441,14 @@
                     }
                     request->flags.mustKeepalive = true;
                     if (!request->flags.accelerated && !request->flags.intercepted) {
-                        httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
+                        httpHeaderPutStrf(hdr, Http::HdrType::PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
                           We send "Connection: Proxy-Support" header to mark
                           Proxy-Support as a hop-by-hop header for intermediaries that do not
                           understand the semantics of this header. The RFC should have included
                           this recommendation.
                         */
-                        httpHeaderPutStrf(hdr, HDR_CONNECTION, "Proxy-support");
+                        httpHeaderPutStrf(hdr, Http::HdrType::CONNECTION, "Proxy-support");
                     }
                     break;
                 }
@@ -1477,12 +1477,12 @@
 #endif
 
     /* Append X-Cache */
-    httpHeaderPutStrf(hdr, HDR_X_CACHE, "%s from %s",
+    httpHeaderPutStrf(hdr, Http::HdrType::X_CACHE, "%s from %s",
                       is_hit ? "HIT" : "MISS", getMyHostname());
 
 #if USE_CACHE_DIGESTS
     /* Append X-Cache-Lookup: -- temporary hack, to be removed @?@ @?@ */
-    httpHeaderPutStrf(hdr, HDR_X_CACHE_LOOKUP, "%s from %s:%d",
+    httpHeaderPutStrf(hdr, Http::HdrType::X_CACHE_LOOKUP, "%s from %s:%d",
                       lookup_type ? lookup_type : "NONE",
                       getMyHostname(), getMyPort());
 
@@ -1534,24 +1534,24 @@
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
         request->flags.chunkedReply = true;
-        hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
+        hdr->putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     /* Append VIA */
     if (Config.onoff.via) {
         LOCAL_ARRAY(char, bbuf, MAX_URL + 32);
         String strVia;
-        hdr->getList(HDR_VIA, &strVia);
+        hdr->getList(Http::HdrType::VIA, &strVia);
         snprintf(bbuf, MAX_URL + 32, "%d.%d %s",
                  reply->sline.version.major,
                  reply->sline.version.minor,
                  ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        hdr->delById(HDR_VIA);
-        hdr->putStr(HDR_VIA, strVia.termedBuf());
+        hdr->delById(Http::HdrType::VIA);
+        hdr->putStr(Http::HdrType::VIA, strVia.termedBuf());
     }
     /* Signal keep-alive or close explicitly */
-    hdr->putStr(HDR_CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
+    hdr->putStr(Http::HdrType::CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
 
 #if ADD_X_REQUEST_URI
     /*
@@ -1560,15 +1560,15 @@
      * but X-Request-URI is likely to be the very last header to ease use from a
      * debugger [hdr->entries.count-1].
      */
-    hdr->putStr(HDR_X_REQUEST_URI,
+    hdr->putStr(Http::HdrType::X_REQUEST_URI,
                 http->memOjbect()->url ? http->memObject()->url : http->uri);
 
 #endif
 
     /* Surrogate-Control requires Surrogate-Capability from upstream to pass on */
-    if ( hdr->has(HDR_SURROGATE_CONTROL) ) {
-        if (!request->header.has(HDR_SURROGATE_CAPABILITY)) {
-            hdr->delById(HDR_SURROGATE_CONTROL);
+    if ( hdr->has(Http::HdrType::SURROGATE_CONTROL) ) {
+        if (!request->header.has(Http::HdrType::SURROGATE_CAPABILITY)) {
+            hdr->delById(Http::HdrType::SURROGATE_CONTROL);
         }
         /* TODO: else case: drop any controls intended specifically for our surrogate ID */
     }
@@ -1753,7 +1753,7 @@
     // OPTIONS with Max-Forwards:0 handled in clientProcessRequest()
 
     if (context->http->request->method == Http::METHOD_TRACE) {
-        if (context->http->request->header.getInt64(HDR_MAX_FORWARDS) == 0) {
+        if (context->http->request->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0) {
             context->traceReply(aNode);
             return;
         }

=== modified file 'src/client_side_request.cc'
--- src/client_side_request.cc	2015-07-29 00:41:57 +0000
+++ src/client_side_request.cc	2015-08-04 19:57:07 +0000
@@ -573,7 +573,7 @@
 
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: Host header forgery detected on " <<
            http->getConn()->clientConnection << " (" << A << " does not match " << B << ")");
-    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(HDR_USER_AGENT));
+    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(Http::HdrType::USER_AGENT));
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: on URL: " << http->request->effectiveRequestUri());
 
     // IP address validation for Host: failed. reject the connection.
@@ -599,7 +599,7 @@
 ClientRequestContext::hostHeaderVerify()
 {
     // Require a Host: header.
-    const char *host = http->request->header.getStr(HDR_HOST);
+    const char *host = http->request->header.getStr(Http::HdrType::HOST);
 
     if (!host) {
         // TODO: dump out the HTTP/1.1 error about missing host header.
@@ -696,14 +696,14 @@
 #if FOLLOW_X_FORWARDED_FOR
     if (!http->request->flags.doneFollowXff() &&
             Config.accessList.followXFF &&
-            http->request->header.has(HDR_X_FORWARDED_FOR)) {
+            http->request->header.has(Http::HdrType::X_FORWARDED_FOR)) {
 
         /* we always trust the direct client address for actual use */
         http->request->indirect_client_addr = http->request->client_addr;
         http->request->indirect_client_addr.port(0);
 
         /* setup the XFF iterator for processing */
-        http->request->x_forwarded_for_iterator = http->request->header.getList(HDR_X_FORWARDED_FOR);
+        http->request->x_forwarded_for_iterator = http->request->header.getList(Http::HdrType::X_FORWARDED_FOR);
 
         /* begin by checking to see if we trust direct client enough to walk XFF */
         acl_checklist = clientAclChecklistCreate(Config.accessList.followXFF, http);
@@ -1016,19 +1016,19 @@
      * is already pinned if it was pinned earlier due to proxy auth
      */
     if (!request->flags.connectionAuth) {
-        if (req_hdr->has(HDR_AUTHORIZATION) || req_hdr->has(HDR_PROXY_AUTHORIZATION)) {
+        if (req_hdr->has(Http::HdrType::AUTHORIZATION) || req_hdr->has(Http::HdrType::PROXY_AUTHORIZATION)) {
             HttpHeaderPos pos = HttpHeaderInitPos;
             HttpHeaderEntry *e;
             int may_pin = 0;
             while ((e = req_hdr->getEntry(&pos))) {
-                if (e->id == HDR_AUTHORIZATION || e->id == HDR_PROXY_AUTHORIZATION) {
+                if (e->id == Http::HdrType::AUTHORIZATION || e->id == Http::HdrType::PROXY_AUTHORIZATION) {
                     const char *value = e->value.rawBuf();
                     if (strncasecmp(value, "NTLM ", 5) == 0
                             ||
                             strncasecmp(value, "Negotiate ", 10) == 0
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
-                        if (e->id == HDR_AUTHORIZATION) {
+                        if (e->id == Http::HdrType::AUTHORIZATION) {
                             request->flags.connectionAuth = true;
                             may_pin = 1;
                         } else {
@@ -1055,7 +1055,7 @@
     const char *str;
 
     request->imslen = -1;
-    request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
+    request->ims = req_hdr->getTime(Http::HdrType::IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
         request->flags.ims = true;
@@ -1066,8 +1066,8 @@
                 no_cache=true;
 
             // RFC 2616: treat Pragma:no-cache as if it was Cache-Control:no-cache when Cache-Control is missing
-        } else if (req_hdr->has(HDR_PRAGMA))
-            no_cache = req_hdr->hasListMember(HDR_PRAGMA,"no-cache",',');
+        } else if (req_hdr->has(Http::HdrType::PRAGMA))
+            no_cache = req_hdr->hasListMember(Http::HdrType::PRAGMA,"no-cache",',');
 
         /*
         * Work around for supporting the Reload button in IE browsers when Squid
@@ -1078,7 +1078,7 @@
         */
         if (Config.onoff.ie_refresh) {
             if (http->flags.accel && request->flags.ims) {
-                if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
+                if ((str = req_hdr->getStr(Http::HdrType::USER_AGENT))) {
                     if (strstr(str, "MSIE 5.01") != NULL)
                         no_cache=true;
                     else if (strstr(str, "MSIE 5.0") != NULL)
@@ -1136,12 +1136,12 @@
      * If these headers appear on any other type of request, delete them now.
      */
     else {
-        req_hdr->delById(HDR_RANGE);
-        req_hdr->delById(HDR_REQUEST_RANGE);
+        req_hdr->delById(Http::HdrType::RANGE);
+        req_hdr->delById(Http::HdrType::REQUEST_RANGE);
         request->ignoreRange("neither HEAD nor GET");
     }
 
-    if (req_hdr->has(HDR_AUTHORIZATION))
+    if (req_hdr->has(Http::HdrType::AUTHORIZATION))
         request->flags.auth = true;
 
     clientCheckPinning(http);
@@ -1149,8 +1149,8 @@
     if (!request->url.userInfo().isEmpty())
         request->flags.auth = true;
 
-    if (req_hdr->has(HDR_VIA)) {
-        String s = req_hdr->getList(HDR_VIA);
+    if (req_hdr->has(Http::HdrType::VIA)) {
+        String s = req_hdr->getList(Http::HdrType::VIA);
         /*
          * ThisCache cannot be a member of Via header, "1.1 ThisCache" can.
          * Note ThisCache2 has a space prepended to the hostname so we don't
@@ -1173,8 +1173,8 @@
 
 #if USE_FORW_VIA_DB
 
-    if (req_hdr->has(HDR_X_FORWARDED_FOR)) {
-        String s = req_hdr->getList(HDR_X_FORWARDED_FOR);
+    if (req_hdr->has(Http::HdrType::X_FORWARDED_FOR)) {
+        String s = req_hdr->getList(Http::HdrType::X_FORWARDED_FOR);
         fvdbCountForw(s.termedBuf());
         s.clean();
     }

=== modified file 'src/clients/Client.cc'
--- src/clients/Client.cc	2015-07-19 13:23:01 +0000
+++ src/clients/Client.cc	2015-08-04 19:57:07 +0000
@@ -449,7 +449,7 @@
 
 // purges entries that match the value of a given HTTP [response] header
 static void
-purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hdr_type hdr)
+purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, Http::HdrType hdr)
 {
     const char *hdrUrl, *absUrl;
 
@@ -497,8 +497,8 @@
     const char *reqUrl = tmp.c_str();
     debugs(88, 5, "maybe purging due to " << request->method << ' ' << tmp);
     purgeEntriesByUrl(request, reqUrl);
-    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
-    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, Http::HdrType::LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, Http::HdrType::CONTENT_LOCATION);
 }
 
 /// called when we have final (possibly adapted) reply headers; kids extend

=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-07-29 00:41:57 +0000
+++ src/clients/FtpGateway.cc	2015-08-04 19:57:07 +0000
@@ -1045,7 +1045,7 @@
 
 #if HAVE_AUTH_MODULE_BASIC
     /* Check HTTP Authorization: headers (better than defaults, but less than URL) */
-    const SBuf auth(req_hdr->getAuth(HDR_AUTHORIZATION, "Basic"));
+    const SBuf auth(req_hdr->getAuth(Http::HdrType::AUTHORIZATION, "Basic"));
     if (!auth.isEmpty()) {
         flags.authenticated = 1;
         loginParser(auth, false);
@@ -2045,7 +2045,7 @@
         snprintf(cbuf, CTRL_BUFLEN, "STOR %s\r\n", ftpState->filepath);
         ftpState->writeCommand(cbuf);
         ftpState->state = Ftp::Client::SENT_STOR;
-    } else if (ftpState->request->header.getInt64(HDR_CONTENT_LENGTH) > 0) {
+    } else if (ftpState->request->header.getInt64(Http::HdrType::CONTENT_LENGTH) > 0) {
         /* File upload without a filename. use STOU to generate one */
         snprintf(cbuf, CTRL_BUFLEN, "STOU\r\n");
         ftpState->writeCommand(cbuf);
@@ -2605,7 +2605,7 @@
 
     /* additional info */
     if (mime_enc)
-        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
     setVirginReply(reply);
     adaptOrFinalizeReply();

=== modified file 'src/clients/FtpRelay.cc'
--- src/clients/FtpRelay.cc	2015-01-13 07:25:36 +0000
+++ src/clients/FtpRelay.cc	2015-08-04 19:57:07 +0000
@@ -396,8 +396,8 @@
     HttpReply *const reply = Ftp::HttpReplyWrapper(ctrl.replycode, ctrl.last_reply, httpStatus, clen);
     if (ctrl.message) {
         for (wordlist *W = ctrl.message; W && W->next; W = W->next)
-            reply->header.putStr(HDR_FTP_PRE, httpHeaderQuoteString(W->key).c_str());
-        // no hdrCacheInit() is needed for after HDR_FTP_PRE addition
+            reply->header.putStr(Http::HdrType::FTP_PRE, httpHeaderQuoteString(W->key).c_str());
+        // no hdrCacheInit() is needed for after Http::HdrType::FTP_PRE addition
     }
     return reply;
 }
@@ -473,16 +473,16 @@
 void
 Ftp::Relay::sendCommand()
 {
-    if (!fwd->request->header.has(HDR_FTP_COMMAND)) {
+    if (!fwd->request->header.has(Http::HdrType::FTP_COMMAND)) {
         abortTransaction("Internal error: FTP relay request with no command");
         return;
     }
 
     HttpHeader &header = fwd->request->header;
-    assert(header.has(HDR_FTP_COMMAND));
-    const String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
-    assert(header.has(HDR_FTP_ARGUMENTS));
-    const String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+    assert(header.has(Http::HdrType::FTP_COMMAND));
+    const String &cmd = header.findEntry(Http::HdrType::FTP_COMMAND)->value;
+    assert(header.has(Http::HdrType::FTP_ARGUMENTS));
+    const String &params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)->value;
 
     if (params.size() > 0)
         debugs(9, 5, "command: " << cmd << ", parameters: " << params);

=== modified file 'src/enums.h'
--- src/enums.h	2015-01-13 07:25:36 +0000
+++ src/enums.h	2015-08-04 14:32:37 +0000
@@ -31,33 +31,6 @@
     PEER_MULTICAST
 } peer_t;
 
-typedef enum {
-    CC_BADHDR = -1,
-    CC_PUBLIC = 0,
-    CC_PRIVATE,
-    CC_NO_CACHE,
-    CC_NO_STORE,
-    CC_NO_TRANSFORM,
-    CC_MUST_REVALIDATE,
-    CC_PROXY_REVALIDATE,
-    CC_MAX_AGE,
-    CC_S_MAXAGE,
-    CC_MAX_STALE,
-    CC_MIN_FRESH,
-    CC_ONLY_IF_CACHED,
-    CC_STALE_IF_ERROR,
-    CC_OTHER,
-    CC_ENUM_END
-} http_hdr_cc_type;
-
-typedef enum {
-    SC_NO_STORE,
-    SC_NO_STORE_REMOTE,
-    SC_MAX_AGE,
-    SC_CONTENT,
-    SC_OTHER,
-    SC_ENUM_END
-} http_hdr_sc_type;
 
 typedef enum _mem_status_t {
     NOT_IN_MEMORY,

=== modified file 'src/errorpage.cc'
--- src/errorpage.cc	2015-07-19 13:23:01 +0000
+++ src/errorpage.cc	2015-08-04 19:57:07 +0000
@@ -418,7 +418,7 @@
     if (loaded()) // already loaded?
         return true;
 
-    if (!request || !request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr) )
+    if (!request || !request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr) )
         return false;
 
     char lang[256];
@@ -1149,10 +1149,10 @@
             MemBuf redirect_location;
             redirect_location.init();
             DenyInfoLocation(name, request, redirect_location);
-            httpHeaderPutStrf(&rep->header, HDR_LOCATION, "%s", redirect_location.content() );
+            httpHeaderPutStrf(&rep->header, Http::HdrType::LOCATION, "%s", redirect_location.content() );
         }
 
-        httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
+        httpHeaderPutStrf(&rep->header, Http::HdrType::X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
     } else {
         MemBuf *content = BuildContent();
         rep->setHeaders(httpStatus, NULL, "text/html;charset=utf-8", content->contentSize(), 0, -1);
@@ -1164,7 +1164,7 @@
          * might want to know. Someone _will_ want to know OTOH, the first
          * X-CACHE-MISS entry should tell us who.
          */
-        httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d", name, xerrno);
+        httpHeaderPutStrf(&rep->header, Http::HdrType::X_SQUID_ERROR, "%s %d", name, xerrno);
 
 #if USE_ERR_LOCALES
         /*
@@ -1175,20 +1175,20 @@
          */
         if (!Config.errorDirectory) {
             /* We 'negotiated' this ONLY from the Accept-Language. */
-            rep->header.delById(HDR_VARY);
-            rep->header.putStr(HDR_VARY, "Accept-Language");
+            rep->header.delById(Http::HdrType::VARY);
+            rep->header.putStr(Http::HdrType::VARY, "Accept-Language");
         }
 
         /* add the Content-Language header according to RFC section 14.12 */
         if (err_language) {
-            rep->header.putStr(HDR_CONTENT_LANGUAGE, err_language);
+            rep->header.putStr(Http::HdrType::CONTENT_LANGUAGE, err_language);
         } else
 #endif /* USE_ERROR_LOCALES */
         {
             /* default templates are in English */
             /* language is known unless error_directory override used */
             if (!Config.errorDirectory)
-                rep->header.putStr(HDR_CONTENT_LANGUAGE, "en");
+                rep->header.putStr(Http::HdrType::CONTENT_LANGUAGE, "en");
         }
 
         rep->body.setMb(content);

=== modified file 'src/esi/Esi.cc'
--- src/esi/Esi.cc	2015-02-03 15:42:23 +0000
+++ src/esi/Esi.cc	2015-08-04 19:57:07 +0000
@@ -839,10 +839,10 @@
         /* remove specific headers for ESI to prevent
          * downstream cache confusion */
         HttpHeader *hdr = &rep->header;
-        hdr->delById(HDR_ACCEPT_RANGES);
-        hdr->delById(HDR_ETAG);
-        hdr->delById(HDR_CONTENT_LENGTH);
-        hdr->delById(HDR_CONTENT_MD5);
+        hdr->delById(Http::HdrType::ACCEPT_RANGES);
+        hdr->delById(Http::HdrType::ETAG);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
+        hdr->delById(Http::HdrType::CONTENT_MD5);
         rv->tree = new esiSequence (rv, true);
         rv->thisNode = thisNode;
         rv->http = http;

=== modified file 'src/esi/VarState.cc'
--- src/esi/VarState.cc	2015-02-03 15:42:23 +0000
+++ src/esi/VarState.cc	2015-08-04 19:57:07 +0000
@@ -319,8 +319,8 @@
      * In future, this may be better implemented as a regexp.
      */
 
-    if (state.header().has(HDR_USER_AGENT)) {
-        char const *s = state.header().getStr(HDR_USER_AGENT);
+    if (state.header().has(Http::HdrType::USER_AGENT)) {
+        char const *s = state.header().getStr(Http::HdrType::USER_AGENT);
         UserOs = identifyOs(s);
         char const *t, *t1;
 
@@ -376,11 +376,11 @@
     const char *s = NULL;
     state.cookieUsed();
 
-    if (state.header().has(HDR_COOKIE)) {
+    if (state.header().has(Http::HdrType::COOKIE)) {
         if (!subref)
-            s = state.header().getStr (HDR_COOKIE);
+            s = state.header().getStr (Http::HdrType::COOKIE);
         else {
-            String S = state.header().getListMember (HDR_COOKIE, subref, ';');
+            String S = state.header().getListMember (Http::HdrType::COOKIE, subref, ';');
 
             if (S.size())
                 ESISegment::ListAppend (state.getOutput(), S.rawBuf(), S.size());
@@ -400,8 +400,8 @@
     const char *s = NULL;
     state.hostUsed();
 
-    if (!subref && state.header().has(HDR_HOST)) {
-        s = state.header().getStr (HDR_HOST);
+    if (!subref && state.header().has(Http::HdrType::HOST)) {
+        s = state.header().getStr (Http::HdrType::HOST);
     } else
         s = found_default;
 
@@ -414,12 +414,12 @@
     char const *s = NULL;
     state.languageUsed();
 
-    if (state.header().has(HDR_ACCEPT_LANGUAGE)) {
+    if (state.header().has(Http::HdrType::ACCEPT_LANGUAGE)) {
         if (!subref) {
-            String S (state.header().getList (HDR_ACCEPT_LANGUAGE));
+            String S (state.header().getList (Http::HdrType::ACCEPT_LANGUAGE));
             ESISegment::ListAppend (state.getOutput(), S.rawBuf(), S.size());
         } else {
-            if (state.header().hasListMember (HDR_ACCEPT_LANGUAGE, subref, ',')) {
+            if (state.header().hasListMember (Http::HdrType::ACCEPT_LANGUAGE, subref, ',')) {
                 s = "true";
             } else {
                 s = "false";
@@ -463,8 +463,8 @@
     const char *s = NULL;
     state.refererUsed();
 
-    if (!subref && state.header().has(HDR_REFERER))
-        s = state.header().getStr (HDR_REFERER);
+    if (!subref && state.header().has(Http::HdrType::REFERER))
+        s = state.header().getStr (Http::HdrType::REFERER);
     else
         s = found_default;
 
@@ -477,9 +477,9 @@
     char const *s = NULL;
     state.useragentUsed();
 
-    if (state.header().has(HDR_USER_AGENT)) {
+    if (state.header().has(Http::HdrType::USER_AGENT)) {
         if (!subref)
-            s = state.header().getStr (HDR_USER_AGENT);
+            s = state.header().getStr (Http::HdrType::USER_AGENT);
         else {
             if (!strcmp (subref, "os")) {
                 s = esiUserOs[UserOs];
@@ -830,10 +830,10 @@
     if (!tempstr[0])
         return;
 
-    String strVary (rep->header.getList (HDR_VARY));
+    String strVary (rep->header.getList (Http::HdrType::VARY));
 
     if (!strVary.size() || strVary[0] != '*') {
-        rep->header.putStr (HDR_VARY, tempstr);
+        rep->header.putStr (Http::HdrType::VARY, tempstr);
     }
 }
 

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-07-21 00:12:11 +0000
+++ src/external_acl.cc	2015-08-04 21:04:09 +0000
@@ -73,7 +73,7 @@
 public:
     typedef RefCount<external_acl_format> Pointer;
 
-    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(HDR_BAD_HDR) {}
+    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(Http::HdrType::BAD_HDR) {}
     ~external_acl_format() {
         xfree(header);
         xfree(member);
@@ -84,7 +84,7 @@
     char *header;
     char *member;
     char separator;
-    http_hdr_type header_id;
+    Http::HdrType header_id;
 };
 
 class external_acl
@@ -244,7 +244,7 @@
     }
 
     format->header = xstrdup(header);
-    format->header_id = httpHeaderIdByNameDef(header, strlen(header));
+    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header));
 }
 
 void
@@ -1010,7 +1010,7 @@
         break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER:
-            if (format->header_id == -1)
+            if (format->header_id == Http::HdrType::BAD_HDR)
                 sb = request->header.getByName(format->header);
             else
                 sb = request->header.getStrOrList(format->header_id);
@@ -1018,7 +1018,7 @@
             break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-            if (format->header_id == -1)
+            if (format->header_id == Http::HdrType::BAD_HDR)
                 sb = request->header.getByNameListMember(format->header, format->member, format->separator);
             else
                 sb = request->header.getListMember(format->header_id, format->member, format->separator);
@@ -1027,7 +1027,7 @@
 
         case Format::LFT_REPLY_HEADER:
             if (reply) {
-                if (format->header_id == -1)
+                if (format->header_id == Http::HdrType::BAD_HDR)
                     sb = reply->header.getByName(format->header);
                 else
                     sb = reply->header.getStrOrList(format->header_id);
@@ -1037,7 +1037,7 @@
 
         case Format::LFT_REPLY_HEADER_ELEM:
             if (reply) {
-                if (format->header_id == -1)
+                if (format->header_id == Http::HdrType::BAD_HDR)
                     sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
                 else
                     sb = reply->header.getListMember(format->header_id, format->member, format->separator);

=== modified file 'src/ftp/Elements.cc'
--- src/ftp/Elements.cc	2015-01-13 07:25:36 +0000
+++ src/ftp/Elements.cc	2015-08-04 19:57:07 +0000
@@ -36,18 +36,18 @@
     reply->sline.set(httpVersion, httpStatus);
 
     HttpHeader &header = reply->header;
-    header.putTime(HDR_DATE, squid_curtime);
+    header.putTime(Http::HdrType::DATE, squid_curtime);
     {
         HttpHdrCc cc;
         cc.Private(String());
         header.putCc(&cc);
     }
     if (ftpStatus > 0)
-        header.putInt(HDR_FTP_STATUS, ftpStatus);
+        header.putInt(Http::HdrType::FTP_STATUS, ftpStatus);
     if (ftpReason)
-        header.putStr(HDR_FTP_REASON, ftpReason);
+        header.putStr(Http::HdrType::FTP_REASON, ftpReason);
     if (clen >= 0)
-        header.putInt64(HDR_CONTENT_LENGTH, clen);
+        header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     reply->hdrCacheInit();
     return reply;
 }

=== modified file 'src/gopher.cc'
--- src/gopher.cc	2015-07-29 00:41:57 +0000
+++ src/gopher.cc	2015-08-04 19:57:07 +0000
@@ -243,7 +243,7 @@
     entry->buffer();
     reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, -1, -1, -2);
     if (mime_enc)
-        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
     entry->replaceHttpReply(reply);
 }

=== modified file 'src/htcp.cc'
--- src/htcp.cc	2015-07-12 10:07:01 +0000
+++ src/htcp.cc	2015-08-04 19:57:07 +0000
@@ -843,9 +843,9 @@
         stuff.S.req_hdrs = spec->req_hdrs;
         stuff.S.reqHdrsSz = spec->reqHdrsSz;
         if (e)
-            hdr.putInt(HDR_AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
+            hdr.putInt(Http::HdrType::AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
         else
-            hdr.putInt(HDR_AGE, 0);
+            hdr.putInt(Http::HdrType::AGE, 0);
         MemBuf mb;
         mb.init();
         hdr.packInto(&mb);
@@ -856,10 +856,10 @@
         hdr.reset();
 
         if (e && e->expires > -1)
-            hdr.putTime(HDR_EXPIRES, e->expires);
+            hdr.putTime(Http::HdrType::EXPIRES, e->expires);
 
         if (e && e->lastmod > -1)
-            hdr.putTime(HDR_LAST_MODIFIED, e->lastmod);
+            hdr.putTime(Http::HdrType::LAST_MODIFIED, e->lastmod);
 
         hdr.packInto(&mb);
 

=== modified file 'src/http.cc'
--- src/http.cc	2015-07-19 13:23:01 +0000
+++ src/http.cc	2015-08-04 19:57:07 +0000
@@ -439,7 +439,7 @@
      * continuous push replies.  These are generally dynamic and
      * probably should not be cachable
      */
-    if ((v = hdr->getStr(HDR_CONTENT_TYPE)))
+    if ((v = hdr->getStr(Http::HdrType::CONTENT_TYPE)))
         if (!strncasecmp(v, "multipart/x-mixed-replace", 25)) {
             debugs(22, 3, HERE << "NO because Content-Type:multipart/x-mixed-replace");
             return 0;
@@ -586,7 +586,7 @@
     static String vstr;
 
     vstr.clean();
-    vary = reply->header.getList(HDR_VARY);
+    vary = reply->header.getList(Http::HdrType::VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -619,7 +619,7 @@
 #if X_ACCELERATOR_VARY
 
     pos = NULL;
-    vary = reply->header.getList(HDR_X_ACCELERATOR_VARY);
+    vary = reply->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -912,10 +912,10 @@
       reply and has in its list the "Session-Based-Authentication"
       which means that the peer supports connection pinning.
      */
-    if (!hdr->has(HDR_PROXY_SUPPORT))
+    if (!hdr->has(Http::HdrType::PROXY_SUPPORT))
         return false;
 
-    header = hdr->getStrOrList(HDR_PROXY_SUPPORT);
+    header = hdr->getStrOrList(Http::HdrType::PROXY_SUPPORT);
     /* XXX This ought to be done in a case-insensitive manner */
     rc = (strstr(header.termedBuf(), "Session-Based-Authentication") != NULL);
 
@@ -941,9 +941,9 @@
         httpMaybeRemovePublic(entry, rep->sline.status());
 
     bool varyFailure = false;
-    if (rep->header.has(HDR_VARY)
+    if (rep->header.has(Http::HdrType::VARY)
 #if X_ACCELERATOR_VARY
-            || rep->header.has(HDR_X_ACCELERATOR_VARY)
+            || rep->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY)
 #endif
        ) {
         const char *vary = httpMakeVaryMark(request, rep);
@@ -1018,8 +1018,8 @@
 
             /* HACK: Pragma: no-cache in _replies_ is not documented in HTTP,
              * but servers like "Active Imaging Webcast/2.0" sure do use it */
-            if (rep->header.has(HDR_PRAGMA) &&
-                    rep->header.hasListMember(HDR_PRAGMA,"no-cache",','))
+            if (rep->header.has(Http::HdrType::PRAGMA) &&
+                    rep->header.hasListMember(Http::HdrType::PRAGMA,"no-cache",','))
                 EBIT_SET(entry->flags, ENTRY_REVALIDATE);
         }
 #endif
@@ -1655,7 +1655,7 @@
 static void
 httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHeader * hdr_out, const HttpStateFlags &flags)
 {
-    http_hdr_type header = flags.originpeer ? HDR_AUTHORIZATION : HDR_PROXY_AUTHORIZATION;
+    Http::HdrType header = flags.originpeer ? Http::HdrType::AUTHORIZATION : Http::HdrType::PROXY_AUTHORIZATION;
 
     /* Nothing to do unless we are forwarding to a peer */
     if (!request->flags.proxying)
@@ -1674,8 +1674,8 @@
         return;
 
     /* PROXYPASS is a special case, single-signon to servers with the proxy password (basic only) */
-    if (flags.originpeer && strcmp(request->peer_login, "PROXYPASS") == 0 && hdr_in->has(HDR_PROXY_AUTHORIZATION)) {
-        const char *auth = hdr_in->getStr(HDR_PROXY_AUTHORIZATION);
+    if (flags.originpeer && strcmp(request->peer_login, "PROXYPASS") == 0 && hdr_in->has(Http::HdrType::PROXY_AUTHORIZATION)) {
+        const char *auth = hdr_in->getStr(Http::HdrType::PROXY_AUTHORIZATION);
 
         if (auth && strncasecmp(auth, "basic ", 6) == 0) {
             hdr_out->putStr(header, auth);
@@ -1767,18 +1767,18 @@
 
     /* use our IMS header if the cached entry has Last-Modified time */
     if (request->lastmod > -1)
-        hdr_out->putTime(HDR_IF_MODIFIED_SINCE, request->lastmod);
+        hdr_out->putTime(Http::HdrType::IF_MODIFIED_SINCE, request->lastmod);
 
     // Add our own If-None-Match field if the cached entry has a strong ETag.
     // copyOneHeaderFromClientsideRequestToUpstreamRequest() adds client ones.
     if (request->etag.size() > 0) {
-        hdr_out->addEntry(new HttpHeaderEntry(HDR_IF_NONE_MATCH, NULL,
+        hdr_out->addEntry(new HttpHeaderEntry(Http::HdrType::IF_NONE_MATCH, NULL,
                                               request->etag.termedBuf()));
     }
 
     bool we_do_ranges = decideIfWeDoRanges (request);
 
-    String strConnection (hdr_in->getList(HDR_CONNECTION));
+    String strConnection (hdr_in->getList(Http::HdrType::CONNECTION));
 
     while ((e = hdr_in->getEntry(&pos)))
         copyOneHeaderFromClientsideRequestToUpstreamRequest(e, strConnection, request, hdr_out, we_do_ranges, flags);
@@ -1797,31 +1797,31 @@
     /* append Via */
     if (Config.onoff.via) {
         String strVia;
-        strVia = hdr_in->getList(HDR_VIA);
+        strVia = hdr_in->getList(Http::HdrType::VIA);
         snprintf(bbuf, BBUF_SZ, "%d.%d %s",
                  request->http_ver.major,
                  request->http_ver.minor, ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        hdr_out->putStr(HDR_VIA, strVia.termedBuf());
+        hdr_out->putStr(Http::HdrType::VIA, strVia.termedBuf());
         strVia.clean();
     }
 
     if (request->flags.accelerated) {
         /* Append Surrogate-Capabilities */
-        String strSurrogate(hdr_in->getList(HDR_SURROGATE_CAPABILITY));
+        String strSurrogate(hdr_in->getList(Http::HdrType::SURROGATE_CAPABILITY));
 #if USE_SQUID_ESI
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0 ESI/1.0\"", Config.Accel.surrogate_id);
 #else
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0\"", Config.Accel.surrogate_id);
 #endif
         strListAdd(&strSurrogate, bbuf, ',');
-        hdr_out->putStr(HDR_SURROGATE_CAPABILITY, strSurrogate.termedBuf());
+        hdr_out->putStr(Http::HdrType::SURROGATE_CAPABILITY, strSurrogate.termedBuf());
     }
 
     /** \pre Handle X-Forwarded-For */
     if (strcmp(opt_forwarded_for, "delete") != 0) {
 
-        String strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
+        String strFwd = hdr_in->getList(Http::HdrType::X_FORWARDED_FOR);
 
         if (strFwd.size() > 65536/2) {
             // There is probably a forwarding loop with Via detection disabled.
@@ -1855,22 +1855,22 @@
                 strFwd = request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN);
         }
         if (strFwd.size() > 0)
-            hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.termedBuf());
+            hdr_out->putStr(Http::HdrType::X_FORWARDED_FOR, strFwd.termedBuf());
     }
     /** If set to DELETE - do not copy through. */
 
     /* append Host if not there already */
-    if (!hdr_out->has(HDR_HOST)) {
+    if (!hdr_out->has(Http::HdrType::HOST)) {
         if (request->peer_domain) {
-            hdr_out->putStr(HDR_HOST, request->peer_domain);
+            hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);
         } else {
             SBuf authority = request->url.authority();
-            hdr_out->putStr(HDR_HOST, authority.c_str());
+            hdr_out->putStr(Http::HdrType::HOST, authority.c_str());
         }
     }
 
     /* append Authorization if known in URL, not in header and going direct */
-    if (!hdr_out->has(HDR_AUTHORIZATION)) {
+    if (!hdr_out->has(Http::HdrType::AUTHORIZATION)) {
         if (!request->flags.proxying && !request->url.userInfo().isEmpty()) {
             static uint8_t result[base64_encode_len(MAX_URL*2)]; // should be big enough for a single URI segment
             struct base64_encode_ctx ctx;
@@ -1879,7 +1879,7 @@
             blen += base64_encode_final(&ctx, result+blen);
             result[blen] = '\0';
             if (blen)
-                httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %.*s", (int)blen, result);
+                httpHeaderPutStrf(hdr_out, Http::HdrType::AUTHORIZATION, "Basic %.*s", (int)blen, result);
         }
     }
 
@@ -1917,19 +1917,19 @@
 
     /* maybe append Connection: keep-alive */
     if (flags.keepalive) {
-        hdr_out->putStr(HDR_CONNECTION, "keep-alive");
+        hdr_out->putStr(Http::HdrType::CONNECTION, "keep-alive");
     }
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
         if (flags.front_end_https == 1 || request->url.getScheme() == AnyP::PROTO_HTTPS)
-            hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
+            hdr_out->putStr(Http::HdrType::FRONT_END_HTTPS, "On");
     }
 
     if (flags.chunked_request) {
         // Do not just copy the original value so that if the client-side
         // starts decode other encodings, this code may remain valid.
-        hdr_out->putStr(HDR_TRANSFER_ENCODING, "chunked");
+        hdr_out->putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     /* Now mangle the headers. */
@@ -1955,7 +1955,7 @@
 
     /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid should not pass on. */
 
-    case HDR_PROXY_AUTHORIZATION:
+    case Http::HdrType::PROXY_AUTHORIZATION:
         /** \par Proxy-Authorization:
          * Only pass on proxy authentication to peers for which
          * authentication forwarding is explicitly enabled
@@ -1970,18 +1970,18 @@
 
     /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid does not pass on. */
 
-    case HDR_CONNECTION:          /** \par Connection: */
-    case HDR_TE:                  /** \par TE: */
-    case HDR_KEEP_ALIVE:          /** \par Keep-Alive: */
-    case HDR_PROXY_AUTHENTICATE:  /** \par Proxy-Authenticate: */
-    case HDR_TRAILER:             /** \par Trailer: */
-    case HDR_UPGRADE:             /** \par Upgrade: */
-    case HDR_TRANSFER_ENCODING:   /** \par Transfer-Encoding: */
+    case Http::HdrType::CONNECTION:          /** \par Connection: */
+    case Http::HdrType::TE:                  /** \par TE: */
+    case Http::HdrType::KEEP_ALIVE:          /** \par Keep-Alive: */
+    case Http::HdrType::PROXY_AUTHENTICATE:  /** \par Proxy-Authenticate: */
+    case Http::HdrType::TRAILER:             /** \par Trailer: */
+    case Http::HdrType::UPGRADE:             /** \par Upgrade: */
+    case Http::HdrType::TRANSFER_ENCODING:   /** \par Transfer-Encoding: */
         break;
 
     /** \par OTHER headers I haven't bothered to track down yet. */
 
-    case HDR_AUTHORIZATION:
+    case Http::HdrType::AUTHORIZATION:
         /** \par WWW-Authorization:
          * Pass on WWW authentication */
 
@@ -2001,7 +2001,7 @@
 
         break;
 
-    case HDR_HOST:
+    case Http::HdrType::HOST:
         /** \par Host:
          * Normally Squid rewrites the Host: header.
          * However, there is one case when we don't: If the URL
@@ -2009,17 +2009,17 @@
          * 'redir_rewrites_host' to be off.
          */
         if (request->peer_domain)
-            hdr_out->putStr(HDR_HOST, request->peer_domain);
+            hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);
         else if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
             hdr_out->addEntry(e->clone());
         else {
             SBuf authority = request->url.authority();
-            hdr_out->putStr(HDR_HOST, authority.c_str());
+            hdr_out->putStr(Http::HdrType::HOST, authority.c_str());
         }
 
         break;
 
-    case HDR_IF_MODIFIED_SINCE:
+    case Http::HdrType::IF_MODIFIED_SINCE:
         /** \par If-Modified-Since:
          * append unless we added our own,
          * but only if cache_miss_revalidate is enabled, or
@@ -2028,13 +2028,13 @@
          * \note at most one client's If-Modified-Since header can pass through
          */
         // XXX: need to check and cleanup the auth case so cacheable auth requests get cached.
-        if (hdr_out->has(HDR_IF_MODIFIED_SINCE))
+        if (hdr_out->has(Http::HdrType::IF_MODIFIED_SINCE))
             break;
         else if (Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_IF_NONE_MATCH:
+    case Http::HdrType::IF_NONE_MATCH:
         /** \par If-None-Match:
          * append if the wildcard '*' special case value is present, or
          *   cache_miss_revalidate is disabled, or
@@ -2043,23 +2043,23 @@
          * \note this header lists a set of responses for the server to elide sending. Squid added values are extending that set.
          */
         // XXX: need to check and cleanup the auth case so cacheable auth requests get cached.
-        if (hdr_out->hasListMember(HDR_IF_MATCH, "*", ',') || Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
+        if (hdr_out->hasListMember(Http::HdrType::IF_MATCH, "*", ',') || Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_MAX_FORWARDS:
+    case Http::HdrType::MAX_FORWARDS:
         /** \par Max-Forwards:
          * pass only on TRACE or OPTIONS requests */
         if (request->method == Http::METHOD_TRACE || request->method == Http::METHOD_OPTIONS) {
             const int64_t hops = e->getInt64();
 
             if (hops > 0)
-                hdr_out->putInt64(HDR_MAX_FORWARDS, hops - 1);
+                hdr_out->putInt64(Http::HdrType::MAX_FORWARDS, hops - 1);
         }
 
         break;
 
-    case HDR_VIA:
+    case Http::HdrType::VIA:
         /** \par Via:
          * If Via is disabled then forward any received header as-is.
          * Otherwise leave for explicit updated addition later. */
@@ -2069,11 +2069,11 @@
 
         break;
 
-    case HDR_RANGE:
-
-    case HDR_IF_RANGE:
-
-    case HDR_REQUEST_RANGE:
+    case Http::HdrType::RANGE:
+
+    case Http::HdrType::IF_RANGE:
+
+    case Http::HdrType::REQUEST_RANGE:
         /** \par Range:, If-Range:, Request-Range:
          * Only pass if we accept ranges */
         if (!we_do_ranges)
@@ -2081,25 +2081,25 @@
 
         break;
 
-    case HDR_PROXY_CONNECTION: // SHOULD ignore. But doing so breaks things.
+    case Http::HdrType::PROXY_CONNECTION: // SHOULD ignore. But doing so breaks things.
         break;
 
-    case HDR_CONTENT_LENGTH:
+    case Http::HdrType::CONTENT_LENGTH:
         // pass through unless we chunk; also, keeping this away from default
         // prevents request smuggling via Connection: Content-Length tricks
         if (!flags.chunked_request)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_X_FORWARDED_FOR:
+    case Http::HdrType::X_FORWARDED_FOR:
 
-    case HDR_CACHE_CONTROL:
+    case Http::HdrType::CACHE_CONTROL:
         /** \par X-Forwarded-For:, Cache-Control:
          * handled specially by Squid, so leave off for now.
          * append these after the loop if needed */
         break;
 
-    case HDR_FRONT_END_HTTPS:
+    case Http::HdrType::FRONT_END_HTTPS:
         /** \par Front-End-Https:
          * Pass thru only if peer is configured with front-end-https */
         if (!flags.front_end_https)
@@ -2175,7 +2175,7 @@
 
         if (request->flags.pinned && request->flags.connectionAuth)
             request->flags.authSent = true;
-        else if (hdr.has(HDR_AUTHORIZATION))
+        else if (hdr.has(Http::HdrType::AUTHORIZATION))
             request->flags.authSent = true;
 
         hdr.packInto(mb);

=== modified file 'src/http/Makefile.am'
--- src/http/Makefile.am	2015-08-03 03:50:25 +0000
+++ src/http/Makefile.am	2015-08-04 11:09:58 +0000
@@ -19,6 +19,7 @@
 	MethodType.h \
 	ProtocolVersion.h \
 	RegisteredHeaders.h \
+	RegisteredHeaders.cc \
 	RequestMethod.cc \
 	RequestMethod.h \
 	StatusCode.cc \

=== added file 'src/http/RegisteredHeaders.cc'
--- src/http/RegisteredHeaders.cc	1970-01-01 00:00:00 +0000
+++ src/http/RegisteredHeaders.cc	2015-08-04 21:04:09 +0000
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "RegisteredHeaders.h"
+
+#include <ostream>
+
+namespace Http
+{
+/*
+ * A table with major attributes for every known field.
+ *
+ * Invariant on this table:
+ * for each index in HeaderTable, (int)HeaderTable[index] = index
+ */
+const HeaderTableRecord HeaderTable[] = {
+    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr},
+    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr},
+    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr},
+    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr},
+    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr},
+    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt},
+    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr},
+    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr},
+    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
+    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr},    /* for now */
+    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc},
+    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr},
+    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr},
+    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr},  /* for now */
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr},
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr},
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64},
+    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr},
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr},    /* for now */
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange},
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr},
+    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr},
+    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr},
+    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123},
+    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag},
+    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr},
+    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123},
+    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr},
+    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr},
+    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr},
+    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr}, /* for now */
+    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr},  /* for now */
+    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
+    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr},    /* for now */
+    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag},
+    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr},
+    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr},
+    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123},
+    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr},
+    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr},
+    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64},
+    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr},  /* for now */
+    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr},
+    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr},
+    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr},
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr},
+    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr},
+    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr},
+    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr},
+    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr},
+    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange},
+    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr},
+    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange}, /* usually matches Http::HdrType::RANGE */
+    {"Retry-AHttp::HdrFieldType::fter", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr},    /* for now (Http::HdrFieldType::ftDate_1123 or Http::HdrFieldType::ftInt!} */
+    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr},
+    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr},
+    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr},
+    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr},
+    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr},
+    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr},
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr},
+    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr},    /* for now. may need to crop */
+    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr},  /* for now ignore. may need to crop */
+    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr},    /* for now */
+    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr},
+    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr},  /* for now */
+    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr},    /* for now */
+    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr},    /* for now */
+    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr},
+    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr},
+    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr},
+    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr},
+    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr},
+    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr},
+#if X_ACCELERATOR_VARY
+    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr},
+#endif
+#if USE_ADAPTATION
+    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr},
+#endif
+    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr},
+    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc},
+    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr},
+    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr},
+    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr},
+    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr},
+    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt},
+    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr},
+    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr},    /* ':' will not allow matches */
+    {nullptr, Http::HdrType::ENUM_END, Http::HdrFieldType::ftInvalid},    /* end of table */
+    {nullptr, Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid}
+};
+
+const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable(Http::HdrType::BAD_HDR, HeaderTable);
+
+}; /* namespace Http */
+
+extern std::ostream &
+operator << (std::ostream &s , Http::HdrType id)
+{
+    if (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END)
+        s << Http::HeaderTable[id].name << '(' << static_cast<int>(id) << ')';
+    else
+        s << "invalid" << '(' << static_cast<int>(id) << ')';
+    return s;
+}
+

=== modified file 'src/http/RegisteredHeaders.h'
--- src/http/RegisteredHeaders.h	2015-05-15 00:38:20 +0000
+++ src/http/RegisteredHeaders.h	2015-08-04 21:04:09 +0000
@@ -9,115 +9,167 @@
 #ifndef SQUID_HTTP_REGISTEREDHEADERS_H
 #define SQUID_HTTP_REGISTEREDHEADERS_H
 
+#include "base/LookupTable.h"
+#include <iosfwd>
+
+namespace Http
+{
 /// recognized or "known" header fields; and the RFC which defines them (or not)
 /// http://www.iana.org/assignments/message-headers/message-headers.xhtml
-typedef enum {
-    HDR_BAD_HDR = -1,
-    HDR_ACCEPT = 0,                     /**< RFC 7231 */
-    HDR_ACCEPT_CHARSET,                 /**< RFC 7231 */
-    HDR_ACCEPT_ENCODING,                /**< RFC 7231 */
-    /*HDR_ACCEPT_FEATURES,*/            /* RFC 2295 */
-    HDR_ACCEPT_LANGUAGE,                /**< RFC 7231 */
-    HDR_ACCEPT_RANGES,                  /**< RFC 7233 */
-    HDR_AGE,                            /**< RFC 7234 */
-    HDR_ALLOW,                          /**< RFC 7231 */
-    HDR_ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
-    HDR_AUTHENTICATION_INFO,            /**< RFC 2617 */
-    HDR_AUTHORIZATION,                  /**< RFC 7235, 4559 */
-    HDR_CACHE_CONTROL,                  /**< RFC 7234 */
-    HDR_CONNECTION,                     /**< RFC 7230 */
-    HDR_CONTENT_BASE,                   /**< obsoleted RFC 2068 */
-    HDR_CONTENT_DISPOSITION,            /**< RFC 2183, 6266 */
-    HDR_CONTENT_ENCODING,               /**< RFC 7231 */
-    HDR_CONTENT_LANGUAGE,               /**< RFC 7231 */
-    HDR_CONTENT_LENGTH,                 /**< RFC 7230 */
-    HDR_CONTENT_LOCATION,               /**< RFC 7231 */
-    HDR_CONTENT_MD5,                    /**< deprecated, RFC 2616 */
-    HDR_CONTENT_RANGE,                  /**< RFC 7233 */
-    HDR_CONTENT_TYPE,                   /**< RFC 7231 */
-    HDR_COOKIE,                         /**< RFC 6265 header we may need to erase */
-    HDR_COOKIE2,                        /**< obsolete RFC 2965 header we may need to erase */
-    HDR_DATE,                           /**< RFC 7231 */
-    /*HDR_DAV,*/                        /* RFC 2518 */
-    /*HDR_DEPTH,*/                      /* RFC 2518 */
-    /*HDR_DERIVED_FROM,*/               /* deprecated RFC 2068 */
-    /*HDR_DESTINATION,*/                /* RFC 2518 */
-    HDR_ETAG,                           /**< RFC 7232 */
-    HDR_EXPECT,                         /**< RFC 7231 */
-    HDR_EXPIRES,                        /**< RFC 7234 */
-    HDR_FORWARDED,                      /**< RFC 7239 */
-    HDR_FROM,                           /**< RFC 7231 */
-    HDR_HOST,                           /**< RFC 7230 */
-    HDR_HTTP2_SETTINGS,                 /**< RFC 7540 */
-    /*HDR_IF,*/                         /* RFC 2518 */
-    HDR_IF_MATCH,                       /**< RFC 7232 */
-    HDR_IF_MODIFIED_SINCE,              /**< RFC 7232 */
-    HDR_IF_NONE_MATCH,                  /**< RFC 7232 */
-    HDR_IF_RANGE,                       /**< RFC 7233 */
-    HDR_IF_UNMODIFIED_SINCE,            /**< RFC 7232 */
-    HDR_KEEP_ALIVE,                     /**< obsoleted RFC 2068 header we may need to erase */
-    HDR_KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
-    HDR_LAST_MODIFIED,                  /**< RFC 7232 */
-    HDR_LINK,                           /**< RFC 5988 */
-    HDR_LOCATION,                       /**< RFC 7231 */
-    /*HDR_LOCK_TOKEN,*/                 /* RFC 2518 */
-    HDR_MAX_FORWARDS,                   /**< RFC 7231 */
-    HDR_MIME_VERSION,                   /**< RFC 2045, 7231 */
-    HDR_NEGOTIATE,                      /**< experimental RFC 2295. Why only this one from 2295? */
-    /*HDR_OVERWRITE,*/                  /* RFC 2518 */
-    HDR_ORIGIN,                         /* CORS Draft specification (see http://www.w3.org/TR/cors/) */
-    HDR_PRAGMA,                         /**< RFC 7234 */
-    HDR_PROXY_AUTHENTICATE,             /**< RFC 7235 */
-    HDR_PROXY_AUTHENTICATION_INFO,      /**< RFC 2617 */
-    HDR_PROXY_AUTHORIZATION,            /**< RFC 7235 */
-    HDR_PROXY_CONNECTION,               /**< obsolete Netscape header we may need to erase. */
-    HDR_PROXY_SUPPORT,                  /**< RFC 4559 */
-    HDR_PUBLIC,                         /**<  RFC 2068 */
-    HDR_RANGE,                          /**< RFC 7233 */
-    HDR_REFERER,                        /**< RFC 7231 */
-    HDR_REQUEST_RANGE,                  /**< some clients use this, sigh */
-    HDR_RETRY_AFTER,                    /**< RFC 7231 */
-    HDR_SERVER,                         /**< RFC 7231 */
-    HDR_SET_COOKIE,                     /**< RFC 6265 header we may need to erase */
-    HDR_SET_COOKIE2,                    /**< obsoleted RFC 2965 header we may need to erase */
-    /*HDR_STATUS_URI,*/                 /* RFC 2518 */
-    /*HDR_TCN,*/                        /* experimental RFC 2295 */
-    HDR_TE,                             /**< RFC 7230 */
-    /*HDR_TIMEOUT,*/                    /* RFC 2518 */
-    HDR_TITLE,                          /* obsolete draft suggested header */
-    HDR_TRAILER,                        /**< RFC 7230 */
-    HDR_TRANSFER_ENCODING,              /**< RFC 7230 */
-    HDR_TRANSLATE,                      /**< IIS custom header we may need to erase */
-    HDR_UNLESS_MODIFIED_SINCE,          /**< IIS custom header we may need to erase */
-    HDR_UPGRADE,                        /**< RFC 7230 */
-    HDR_USER_AGENT,                     /**< RFC 7231 */
-    /*HDR_VARIANT_VARY,*/               /* experimental RFC 2295 */
-    HDR_VARY,                           /**< RFC 7231 */
-    HDR_VIA,                            /**< RFC 7230 */
-    HDR_WARNING,                        /**< RFC 7234 */
-    HDR_WWW_AUTHENTICATE,               /**< RFC 7235, 4559 */
-    HDR_X_CACHE,                        /**< Squid custom header */
-    HDR_X_CACHE_LOOKUP,                 /**< Squid custom header. temporary hack that became de-facto. TODO remove */
-    HDR_X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
-    HDR_X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
-    HDR_X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
+enum HdrType {
+    ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
+    ACCEPT_CHARSET,                 /**< RFC 7231 */
+    ACCEPT_ENCODING,                /**< RFC 7231 */
+    /*ACCEPT_FEATURES,*/            /* RFC 2295 */
+    ACCEPT_LANGUAGE,                /**< RFC 7231 */
+    ACCEPT_RANGES,                  /**< RFC 7233 */
+    AGE,                            /**< RFC 7234 */
+    ALLOW,                          /**< RFC 7231 */
+    ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
+    AUTHENTICATION_INFO,            /**< RFC 2617 */
+    AUTHORIZATION,                  /**< RFC 7235, 4559 */
+    CACHE_CONTROL,                  /**< RFC 7234 */
+    CONNECTION,                     /**< RFC 7230 */
+    CONTENT_BASE,                   /**< obsoleted RFC 2068 */
+    CONTENT_DISPOSITION,            /**< RFC 2183, 6266 */
+    CONTENT_ENCODING,               /**< RFC 7231 */
+    CONTENT_LANGUAGE,               /**< RFC 7231 */
+    CONTENT_LENGTH,                 /**< RFC 7230 */
+    CONTENT_LOCATION,               /**< RFC 7231 */
+    CONTENT_MD5,                    /**< deprecated, RFC 2616 */
+    CONTENT_RANGE,                  /**< RFC 7233 */
+    CONTENT_TYPE,                   /**< RFC 7231 */
+    COOKIE,                         /**< RFC 6265 header we may need to erase */
+    COOKIE2,                        /**< obsolete RFC 2965 header we may need to erase */
+    DATE,                           /**< RFC 7231 */
+    /*DAV,*/                        /* RFC 2518 */
+    /*DEPTH,*/                      /* RFC 2518 */
+    /*DERIVED_FROM,*/               /* deprecated RFC 2068 */
+    /*DESTINATION,*/                /* RFC 2518 */
+    ETAG,                           /**< RFC 7232 */
+    EXPECT,                         /**< RFC 7231 */
+    EXPIRES,                        /**< RFC 7234 */
+    FORWARDED,                      /**< RFC 7239 */
+    FROM,                           /**< RFC 7231 */
+    HOST,                           /**< RFC 7230 */
+    HTTP2_SETTINGS,                 /**< RFC 7540 */
+    /*IF,*/                         /* RFC 2518 */
+    IF_MATCH,                       /**< RFC 7232 */
+    IF_MODIFIED_SINCE,              /**< RFC 7232 */
+    IF_NONE_MATCH,                  /**< RFC 7232 */
+    IF_RANGE,                       /**< RFC 7233 */
+    IF_UNMODIFIED_SINCE,            /**< RFC 7232 */
+    KEEP_ALIVE,                     /**< obsoleted RFC 2068 header we may need to erase */
+    KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
+    LAST_MODIFIED,                  /**< RFC 7232 */
+    LINK,                           /**< RFC 5988 */
+    LOCATION,                       /**< RFC 7231 */
+    /*LOCK_TOKEN,*/                 /* RFC 2518 */
+    MAX_FORWARDS,                   /**< RFC 7231 */
+    MIME_VERSION,                   /**< RFC 2045, 7231 */
+    NEGOTIATE,                      /**< experimental RFC 2295. Why only this one from 2295? */
+    /*OVERWRITE,*/                  /* RFC 2518 */
+    ORIGIN,                         /* CORS Draft specification (see http://www.w3.org/TR/cors/) */
+    PRAGMA,                         /**< RFC 7234 */
+    PROXY_AUTHENTICATE,             /**< RFC 7235 */
+    PROXY_AUTHENTICATION_INFO,      /**< RFC 2617 */
+    PROXY_AUTHORIZATION,            /**< RFC 7235 */
+    PROXY_CONNECTION,               /**< obsolete Netscape header we may need to erase. */
+    PROXY_SUPPORT,                  /**< RFC 4559 */
+    PUBLIC,                         /**<  RFC 2068 */
+    RANGE,                          /**< RFC 7233 */
+    REFERER,                        /**< RFC 7231 */
+    REQUEST_RANGE,                  /**< some clients use this, sigh */
+    RETRY_AFTER,                    /**< RFC 7231 */
+    SERVER,                         /**< RFC 7231 */
+    SET_COOKIE,                     /**< RFC 6265 header we may need to erase */
+    SET_COOKIE2,                    /**< obsoleted RFC 2965 header we may need to erase */
+    /*STATUS_URI,*/                 /* RFC 2518 */
+    /*TCN,*/                        /* experimental RFC 2295 */
+    TE,                             /**< RFC 7230 */
+    /*TIMEOUT,*/                    /* RFC 2518 */
+    TITLE,                          /* obsolete draft suggested header */
+    TRAILER,                        /**< RFC 7230 */
+    TRANSFER_ENCODING,              /**< RFC 7230 */
+    TRANSLATE,                      /**< IIS custom header we may need to erase */
+    UNLESS_MODIFIED_SINCE,          /**< IIS custom header we may need to erase */
+    UPGRADE,                        /**< RFC 7230 */
+    USER_AGENT,                     /**< RFC 7231 */
+    /*VARIANT_VARY,*/               /* experimental RFC 2295 */
+    VARY,                           /**< RFC 7231 */
+    VIA,                            /**< RFC 7230 */
+    WARNING,                        /**< RFC 7234 */
+    WWW_AUTHENTICATE,               /**< RFC 7235, 4559 */
+    X_CACHE,                        /**< Squid custom header */
+    X_CACHE_LOOKUP,                 /**< Squid custom header. temporary hack that became de-facto. TODO remove */
+    X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
+    X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
+    X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
 #if X_ACCELERATOR_VARY
     HDR_X_ACCELERATOR_VARY,             /**< obsolete Squid custom header. */
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,                /**< Squid custom ICAP header */
+    X_NEXT_SERVICES,                /**< Squid custom ICAP header */
 #endif
-    HDR_SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
-    HDR_SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
-    HDR_FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
-    HDR_FTP_COMMAND,                    /**< Internal header for FTP command */
-    HDR_FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
-    HDR_FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
-    HDR_FTP_STATUS,                     /**< Internal header for FTP reply status */
-    HDR_FTP_REASON,                     /**< Internal header for FTP reply reason */
-    HDR_OTHER,                          /**< internal tag value for "unknown" headers */
-    HDR_ENUM_END
-} http_hdr_type;
+    SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
+    SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
+    FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
+    FTP_COMMAND,                    /**< Internal header for FTP command */
+    FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
+    FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
+    FTP_STATUS,                     /**< Internal header for FTP reply status */
+    FTP_REASON,                     /**< Internal header for FTP reply reason */
+    OTHER,                          /**< internal tag value for "unknown" headers */
+    ENUM_END,                       /**< internal tag for end-of-valid headers */
+    BAD_HDR                         /**< Invalid header. Must be after ENUM_END */
+};
+
+/** possible types for http header fields */
+enum class HdrFieldType {
+    ftInvalid,  /**< to catch nasty errors with hdr_id<->fld_type clashes */
+    ftInt,
+    ftInt64,
+    ftStr,
+    ftDate_1123,
+    ftETag,
+    ftPCc,
+    ftPContRange,
+    ftPRange,
+    ftPSc,
+    ftDate_1123_or_ETag
+};
+
+/* POD for HeaderTable */
+class HeaderTableRecord {
+public:
+    const char *name;
+    Http::HdrType id;
+    Http::HdrFieldType type;
+};
+
+/// header ID->namelookup table.
+extern const HeaderTableRecord HeaderTable[];
+
+/// for header name->id lookup, use HeaderLookupTable.lookup(hdr-as-sbuf);
+extern const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable;
+
+inline bool
+any_registered_header (const Http::HdrType id)
+{
+    return (id == Http::HdrType::BAD_HDR || (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END));
+}
+
+inline bool
+any_valid_header (const Http::HdrType id)
+{
+    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END);
+}
+
+
+}; /* namespace Http */
+
+std::ostream &
+operator << (std::ostream &, Http::HdrType);
 
 #endif /* SQUID_HTTP_REGISTEREDHEADERS_H */
 

=== modified file 'src/log/FormatHttpdCombined.cc'
--- src/log/FormatHttpdCombined.cc	2015-07-12 10:04:45 +0000
+++ src/log/FormatHttpdCombined.cc	2015-08-04 19:57:07 +0000
@@ -32,8 +32,8 @@
         if (al->request->auth_user_request != NULL)
             user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
 #endif
-        referer = al->request->header.getStr(HDR_REFERER);
-        agent = al->request->header.getStr(HDR_USER_AGENT);
+        referer = al->request->header.getStr(Http::HdrType::REFERER);
+        agent = al->request->header.getStr(Http::HdrType::USER_AGENT);
     }
 
     if (!referer || *referer == '\0')

=== modified file 'src/log/FormatSquidReferer.cc'
--- src/log/FormatSquidReferer.cc	2015-01-13 07:25:36 +0000
+++ src/log/FormatSquidReferer.cc	2015-08-04 19:57:07 +0000
@@ -20,7 +20,7 @@
 {
     const char *referer = NULL;
     if (al->request)
-        referer = al->request->header.getStr(HDR_REFERER);
+        referer = al->request->header.getStr(Http::HdrType::REFERER);
 
     if (!referer || *referer == '\0')
         referer = "-";

=== modified file 'src/log/FormatSquidUseragent.cc'
--- src/log/FormatSquidUseragent.cc	2015-01-13 07:25:36 +0000
+++ src/log/FormatSquidUseragent.cc	2015-08-04 19:57:07 +0000
@@ -21,7 +21,7 @@
     const char *agent = NULL;
 
     if (al->request)
-        agent = al->request->header.getStr(HDR_USER_AGENT);
+        agent = al->request->header.getStr(Http::HdrType::USER_AGENT);
 
     if (!agent || *agent == '\0')
         agent = "-";

=== modified file 'src/mgr/Inquirer.cc'
--- src/mgr/Inquirer.cc	2015-05-23 20:17:16 +0000
+++ src/mgr/Inquirer.cc	2015-08-04 19:57:07 +0000
@@ -83,7 +83,7 @@
     } else {
         std::unique_ptr<HttpReply> reply(new HttpReply);
         reply->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
-        reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
+        reply->header.putStr(Http::HdrType::CONNECTION, "close"); // until we chunk response
         replyBuf.reset(reply->pack());
     }
     writer = asyncCall(16, 5, "Mgr::Inquirer::noteWroteHeader",

=== modified file 'src/peer_digest.cc'
--- src/peer_digest.cc	2015-07-25 14:19:36 +0000
+++ src/peer_digest.cc	2015-08-04 19:57:07 +0000
@@ -343,9 +343,9 @@
     /* add custom headers */
     assert(!req->header.len);
 
-    req->header.putStr(HDR_ACCEPT, StoreDigestMimeStr);
+    req->header.putStr(Http::HdrType::ACCEPT, StoreDigestMimeStr);
 
-    req->header.putStr(HDR_ACCEPT, "text/html");
+    req->header.putStr(Http::HdrType::ACCEPT, "text/html");
 
     if (p->login &&
             p->login[0] != '*' &&

=== modified file 'src/servers/FtpServer.cc'
--- src/servers/FtpServer.cc	2015-05-26 18:12:08 +0000
+++ src/servers/FtpServer.cc	2015-08-04 19:57:07 +0000
@@ -492,7 +492,7 @@
     assert(99 < code && code < 1000);
 
     const bool sendDetails = reply != NULL &&
-                             reply->header.has(HDR_FTP_STATUS) && reply->header.has(HDR_FTP_REASON);
+                             reply->header.has(Http::HdrType::FTP_STATUS) && reply->header.has(Http::HdrType::FTP_REASON);
 
     MemBuf mb;
     mb.init();
@@ -727,11 +727,11 @@
     request->flags.cachable = false; // XXX: reset later by maybeCacheable()
     request->flags.noCache = true;
 
-    request->header.putStr(HDR_FTP_COMMAND, cmd.c_str());
-    request->header.putStr(HDR_FTP_ARGUMENTS, params.c_str()); // may be ""
+    request->header.putStr(Http::HdrType::FTP_COMMAND, cmd.c_str());
+    request->header.putStr(Http::HdrType::FTP_ARGUMENTS, params.c_str()); // may be ""
     if (method == Http::METHOD_PUT) {
-        request->header.putStr(HDR_EXPECT, "100-continue");
-        request->header.putStr(HDR_TRANSFER_ENCODING, "chunked");
+        request->header.putStr(Http::HdrType::EXPECT, "100-continue");
+        request->header.putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     ClientHttpRequest *const http = new ClientHttpRequest(this);
@@ -808,11 +808,11 @@
     bool hasEPSV = false;
     int prependSpaces = 1;
 
-    featReply->header.putStr(HDR_FTP_PRE, "\"211-Features:\"");
-    const int scode = serverReplyHeader.getInt(HDR_FTP_STATUS);
+    featReply->header.putStr(Http::HdrType::FTP_PRE, "\"211-Features:\"");
+    const int scode = serverReplyHeader.getInt(Http::HdrType::FTP_STATUS);
     if (scode == 211) {
         while (const HttpHeaderEntry *e = serverReplyHeader.getEntry(&pos)) {
-            if (e->id == HDR_FTP_PRE) {
+            if (e->id == Http::HdrType::FTP_PRE) {
                 // assume RFC 2389 FEAT response format, quoted by Squid:
                 // <"> SP NAME [SP PARAMS] <">
                 // but accommodate MS servers sending four SPs before NAME
@@ -848,11 +848,11 @@
     char buf[256];
     if (!hasEPRT) {
         snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPRT");
-        featReply->header.putStr(HDR_FTP_PRE, buf);
+        featReply->header.putStr(Http::HdrType::FTP_PRE, buf);
     }
     if (!hasEPSV) {
         snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPSV");
-        featReply->header.putStr(HDR_FTP_PRE, buf);
+        featReply->header.putStr(Http::HdrType::FTP_PRE, buf);
     }
 
     featReply->header.refreshMask();
@@ -1023,8 +1023,8 @@
 {
     assert(reply != NULL);
     const HttpHeader &header = reply->header;
-    // adaptation and forwarding errors lack HDR_FTP_STATUS
-    if (!header.has(HDR_FTP_STATUS)) {
+    // adaptation and forwarding errors lack Http::HdrType::FTP_STATUS
+    if (!header.has(Http::HdrType::FTP_STATUS)) {
         writeForwardedForeign(reply); // will get to Ftp::Server::wroteReply
         return;
     }
@@ -1103,8 +1103,8 @@
 #endif
 
     assert(reply != NULL);
-    const char *reason = reply->header.has(HDR_FTP_REASON) ?
-                         reply->header.getStr(HDR_FTP_REASON):
+    const char *reason = reply->header.has(Http::HdrType::FTP_REASON) ?
+                         reply->header.getStr(Http::HdrType::FTP_REASON):
                          reply->sline.reason();
 
     mb.appendf("%i %s\r\n", scode, reason); // error terminating line
@@ -1131,7 +1131,7 @@
 Ftp::Server::writeControlMsgAndCall(ClientSocketContext *, HttpReply *reply, AsyncCall::Pointer &call)
 {
     // the caller guarantees that we are dealing with the current context only
-    // the caller should also make sure reply->header.has(HDR_FTP_STATUS)
+    // the caller should also make sure reply->header.has(Http::HdrType::FTP_STATUS)
     writeForwardedReplyAndCall(reply, call);
 }
 
@@ -1142,9 +1142,9 @@
     const HttpHeader &header = reply->header;
 
     // without status, the caller must use the writeForwardedForeign() path
-    Must(header.has(HDR_FTP_STATUS));
-    Must(header.has(HDR_FTP_REASON));
-    const int scode = header.getInt(HDR_FTP_STATUS);
+    Must(header.has(Http::HdrType::FTP_STATUS));
+    Must(header.has(Http::HdrType::FTP_REASON));
+    const int scode = header.getInt(Http::HdrType::FTP_STATUS);
     debugs(33, 7, "scode: " << scode);
 
     // Status 125 or 150 implies upload or data request, but we still check
@@ -1194,16 +1194,16 @@
 
     HttpHeaderPos pos = HttpHeaderInitPos;
     while (const HttpHeaderEntry *e = header.getEntry(&pos)) {
-        if (e->id == HDR_FTP_PRE) {
+        if (e->id == Http::HdrType::FTP_PRE) {
             String raw;
             if (httpHeaderParseQuotedString(e->value.rawBuf(), e->value.size(), &raw))
                 mb.appendf("%s\r\n", raw.termedBuf());
         }
     }
 
-    if (header.has(HDR_FTP_STATUS)) {
-        const char *reason = header.getStr(HDR_FTP_REASON);
-        mb.appendf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
+    if (header.has(Http::HdrType::FTP_STATUS)) {
+        const char *reason = header.getStr(Http::HdrType::FTP_REASON);
+        mb.appendf("%i %s\r\n", header.getInt(Http::HdrType::FTP_STATUS),
                    (reason ? reason : 0));
     }
 }
@@ -1279,10 +1279,10 @@
     Must(request);
 
     HttpHeader &header = request->header;
-    Must(header.has(HDR_FTP_COMMAND));
-    String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
-    Must(header.has(HDR_FTP_ARGUMENTS));
-    String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+    Must(header.has(Http::HdrType::FTP_COMMAND));
+    String &cmd = header.findEntry(Http::HdrType::FTP_COMMAND)->value;
+    Must(header.has(Http::HdrType::FTP_ARGUMENTS));
+    String &params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)->value;
 
     if (do_debug(9, 2)) {
         MemBuf mb;
@@ -1596,10 +1596,10 @@
     HttpRequest *const request = http->request;
     assert(request != NULL);
     HttpHeader &header = request->header;
-    header.delById(HDR_FTP_COMMAND);
-    header.putStr(HDR_FTP_COMMAND, "PASV");
-    header.delById(HDR_FTP_ARGUMENTS);
-    header.putStr(HDR_FTP_ARGUMENTS, "");
+    header.delById(Http::HdrType::FTP_COMMAND);
+    header.putStr(Http::HdrType::FTP_COMMAND, "PASV");
+    header.delById(Http::HdrType::FTP_ARGUMENTS);
+    header.putStr(Http::HdrType::FTP_ARGUMENTS, "");
     debugs(9, 5, "client data command converted to fake PASV");
 }
 

=== modified file 'src/servers/Http1Server.cc'
--- src/servers/Http1Server.cc	2015-01-20 12:33:23 +0000
+++ src/servers/Http1Server.cc	2015-08-04 19:57:07 +0000
@@ -193,8 +193,8 @@
     ClientHttpRequest *http = context->http;
     HttpRequest::Pointer request = http->request;
 
-    if (request->header.has(HDR_EXPECT)) {
-        const String expect = request->header.getList(HDR_EXPECT);
+    if (request->header.has(Http::HdrType::EXPECT)) {
+        const String expect = request->header.getList(Http::HdrType::EXPECT);
         const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
         if (!supportedExpect) {
             clientStreamNode *node = context->getClientReplyContext();
@@ -276,7 +276,7 @@
     // apply selected clientReplyContext::buildReplyHeader() mods
     // it is not clear what headers are required for control messages
     rep->header.removeHopByHopEntries();
-    rep->header.putStr(HDR_CONNECTION, "keep-alive");
+    rep->header.putStr(Http::HdrType::CONNECTION, "keep-alive");
     httpHdrMangleList(&rep->header, getCurrentContext()->http->request, ROR_REPLY);
 
     MemBuf *mb = rep->pack();

=== modified file 'src/ssl/ErrorDetailManager.cc'
--- src/ssl/ErrorDetailManager.cc	2015-01-13 07:25:36 +0000
+++ src/ssl/ErrorDetailManager.cc	2015-08-04 19:57:07 +0000
@@ -127,7 +127,7 @@
 {
 #if USE_ERR_LOCALES
     String hdr;
-    if (request != NULL && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr)) {
+    if (request != NULL && request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr)) {
         ErrorDetailsList::Pointer errDetails = NULL;
         //Try to retrieve from cache
         size_t pos = 0;

=== modified file 'src/store.cc'
--- src/store.cc	2015-08-01 02:22:12 +0000
+++ src/store.cc	2015-08-04 19:57:07 +0000
@@ -721,20 +721,20 @@
             /* We are allowed to do this typecast */
             HttpReply *rep = new HttpReply;
             rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
-            vary = mem_obj->getReply()->header.getList(HDR_VARY);
+            vary = mem_obj->getReply()->header.getList(Http::HdrType::VARY);
 
             if (vary.size()) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_VARY, vary.termedBuf());
+                rep->header.putStr(Http::HdrType::VARY, vary.termedBuf());
                 vary.clean();
             }
 
 #if X_ACCELERATOR_VARY
-            vary = mem_obj->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
+            vary = mem_obj->getReply()->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 
             if (vary.size() > 0) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.termedBuf());
+                rep->header.putStr(Http::HdrType::HDR_X_ACCELERATOR_VARY, vary.termedBuf());
                 vary.clean();
             }
 
@@ -1597,7 +1597,7 @@
 {
     const HttpReply *reply = getReply();
     time_t served_date = reply->date;
-    int age = reply->header.getInt(HDR_AGE);
+    int age = reply->header.getInt(Http::HdrType::AGE);
     /* Compute the timestamp, mimicking RFC2616 section 13.2.3. */
     /* make sure that 0 <= served_date <= squid_curtime */
 
@@ -2049,7 +2049,7 @@
 StoreEntry::hasEtag(ETag &etag) const
 {
     if (const HttpReply *reply = getReply()) {
-        etag = reply->header.getETag(HDR_ETAG);
+        etag = reply->header.getETag(Http::HdrType::ETAG);
         if (etag.str)
             return true;
     }
@@ -2059,14 +2059,14 @@
 bool
 StoreEntry::hasIfMatchEtag(const HttpRequest &request) const
 {
-    const String reqETags = request.header.getList(HDR_IF_MATCH);
+    const String reqETags = request.header.getList(Http::HdrType::IF_MATCH);
     return hasOneOfEtags(reqETags, false);
 }
 
 bool
 StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 {
-    const String reqETags = request.header.getList(HDR_IF_NONE_MATCH);
+    const String reqETags = request.header.getList(Http::HdrType::IF_NONE_MATCH);
     // weak comparison is allowed only for HEAD or full-body GET requests
     const bool allowWeakMatch = !request.flags.isRanged &&
                                 (request.method == Http::METHOD_GET || request.method == Http::METHOD_HEAD);
@@ -2077,7 +2077,7 @@
 bool
 StoreEntry::hasOneOfEtags(const String &reqETags, const bool allowWeakMatch) const
 {
-    const ETag repETag = getReply()->header.getETag(HDR_ETAG);
+    const ETag repETag = getReply()->header.getETag(Http::HdrType::ETAG);
     if (!repETag.str)
         return strListIsMember(&reqETags, "*", ',');
 

=== modified file 'src/tests/stub_libauth.cc'
--- src/tests/stub_libauth.cc	2015-01-13 07:25:36 +0000
+++ src/tests/stub_libauth.cc	2015-08-04 19:57:07 +0000
@@ -71,8 +71,8 @@
 void Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply *, int) STUB
 void Auth::UserRequest::releaseAuthServer() STUB
 const char * Auth::UserRequest::connLastHeader() STUB_RETVAL("stub")
-AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
-AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
+AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
+AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
 void Auth::UserRequest::addReplyAuthHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int) STUB

=== modified file 'src/tests/test_http_range.cc'
--- src/tests/test_http_range.cc	2015-01-13 07:25:36 +0000
+++ src/tests/test_http_range.cc	2015-08-04 19:57:07 +0000
@@ -15,7 +15,7 @@
 
 /** \todo CLEANUP: This file should be called something_stub.cc */
 
-void httpHeaderPutStr(HttpHeader * hdr, http_hdr_type type, const char *str)
+void httpHeaderPutStr(HttpHeader * hdr, Http::HdrType type, const char *str)
 {
     fatal ("dummy function\n");
 }
@@ -26,13 +26,13 @@
     return NULL;
 }
 
-String httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
+String httpHeaderGetList(const HttpHeader * hdr, Http::HdrType id)
 {
     fatal ("dummy function\n");
     return String();
 }
 
-int httpHeaderHas(const HttpHeader * hdr, http_hdr_type type)
+int httpHeaderHas(const HttpHeader * hdr, Http::HdrType type)
 {
     fatal ("dummy function\n");
     return 0;

=== modified file 'src/url.cc'
--- src/url.cc	2015-07-31 00:16:40 +0000
+++ src/url.cc	2015-08-04 19:57:07 +0000
@@ -760,7 +760,7 @@
     // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)
     // we also support forwarding OPTIONS and TRACE, except for the *-URI ones
     if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)
-        return (r->header.getInt64(HDR_MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
+        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
 
     if (r->method == Http::METHOD_PURGE)
         return 1;

=== modified file 'src/urn.cc'
--- src/urn.cc	2015-07-29 00:41:57 +0000
+++ src/urn.cc	2015-08-04 19:57:07 +0000
@@ -163,7 +163,7 @@
         return;
     }
 
-    urlres_r->header.putStr(HDR_ACCEPT, "text/plain");
+    urlres_r->header.putStr(Http::HdrType::ACCEPT, "text/plain");
 }
 
 void
@@ -371,7 +371,7 @@
     if (urnState->flags.force_menu) {
         debugs(51, 3, "urnHandleReply: forcing menu");
     } else if (min_u) {
-        rep->header.putStr(HDR_LOCATION, min_u->url);
+        rep->header.putStr(Http::HdrType::LOCATION, min_u->url);
     }
 
     rep->body.setMb(mb);

# Begin bundle
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
AA==
