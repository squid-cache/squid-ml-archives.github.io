# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20150816070338-pi0zt9cyh7qvia2f
# target_branch: ../trunk/
# testament_sha1: fff1effbe92ae837256d705131c9abe95993214d
# timestamp: 2015-08-16 09:03:51 +0200
# base_revision_id: squidadm@squid-cache.org-20150813001211-\
#   d02ig2a361nmvla8
# 
# Begin patch
=== added file 'acinclude/squid-cpp11-features.m4'
--- acinclude/squid-cpp11-features.m4	1970-01-01 00:00:00 +0000
+++ acinclude/squid-cpp11-features.m4	2015-08-15 16:46:43 +0000
@@ -0,0 +1,29 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+## SQUID_CXX_STD_UNDERLYING_TYPE
+## checks whether the std::underlying_type<enumType>::type trait exists
+AC_DEFUN([SQUID_CXX_STD_UNDERLYING_TYPE],[
+  AC_CACHE_CHECK([whether compiler supports std::underlying_type],
+    [squid_cv_have_std_underlying_type],[
+      AC_REQUIRE([AC_PROG_CXX])
+      AC_LANG_PUSH([C++])
+      AC_COMPILE_IFELSE([
+        AC_LANG_PROGRAM([
+#include <type_traits>
+enum class testEnum { one, two, three };
+        ],[
+        std::underlying_type<testEnum>::type testNum = 0;
+        ])],
+        [squid_cv_have_std_underlying_type=yes],
+        [squid_cv_have_std_underlying_type=no])
+      AC_LANG_POP
+  ])
+  SQUID_DEFINE_BOOL([HAVE_STD_UNDERLYING_TYPE],
+     [$squid_cv_have_std_underlying_type],
+     [Define if stdlibc support std::underlying_type for enums])
+])

=== modified file 'configure.ac'
--- configure.ac	2015-08-03 03:50:25 +0000
+++ configure.ac	2015-08-15 16:46:43 +0000
@@ -24,6 +24,7 @@
 m4_include([acinclude/pam.m4])
 m4_include([acinclude/pkg.m4])
 m4_include([acinclude/lib-checks.m4])
+m4_include([acinclude/squid-cpp11-features.m4])
 m4_include([acinclude/ax_cxx_compile_stdcxx_11.m4])
 m4_include([acinclude/ax_cxx_0x_types.m4])
 
@@ -2952,6 +2953,8 @@
 AX_CXX_TYPE_UNIQUE_PTR
 AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS
 
+SQUID_CXX_STD_UNDERLYING_TYPE
+
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
 dnl For this reason, we must check if pad128_t and upad128_t are defined.

=== modified file 'src/HttpHeader.cc'
--- src/HttpHeader.cc	2015-08-11 00:12:10 +0000
+++ src/HttpHeader.cc	2015-08-16 07:03:38 +0000
@@ -9,7 +9,7 @@
 /* DEBUG: section 55    HTTP Header */
 
 #include "squid.h"
-//#include "base/LookupTable.h" // pulled by HttpHdrCc.h
+#include "base/EnumIterator.h"
 #include "base64.h"
 #include "globals.h"
 #include "HttpHdrCc.h"
@@ -61,160 +61,13 @@
  */
 
 // statistics counters for headers. clients must not allow Http::HdrType::BAD_HDR to be counted
-std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::ENUM_END);
-
-/*
- * headers with field values defined as #(values) in HTTP/1.1
- * Headers that are currently not recognized, are commented out.
- */
-static HttpHeaderMask ListHeadersMask;  /* set run-time using  ListHeadersArr */
-static Http::HdrType ListHeadersArr[] = {
-    Http::HdrType::ACCEPT,
-    Http::HdrType::ACCEPT_CHARSET,
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_LANGUAGE,
-    Http::HdrType::ACCEPT_RANGES,
-    Http::HdrType::ALLOW,
-    Http::HdrType::CACHE_CONTROL,
-    Http::HdrType::CONTENT_ENCODING,
-    Http::HdrType::CONTENT_LANGUAGE,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::EXPECT,
-    Http::HdrType::IF_MATCH,
-    Http::HdrType::IF_NONE_MATCH,
-    Http::HdrType::KEY,
-    Http::HdrType::LINK,
-    Http::HdrType::PRAGMA,
-    Http::HdrType::PROXY_CONNECTION,
-    Http::HdrType::PROXY_SUPPORT,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    Http::HdrType::VARY,
-    Http::HdrType::VIA,
-    Http::HdrType::WARNING,
-    Http::HdrType::WWW_AUTHENTICATE,
-    Http::HdrType::AUTHENTICATION_INFO,
-    Http::HdrType::PROXY_AUTHENTICATION_INFO,
-    /* Http::HdrType::TE, Http::HdrType::TRAILER */
-#if X_ACCELERATOR_VARY
-    Http::HdrType::HDR_X_ACCELERATOR_VARY,
-#endif
-#if USE_ADAPTATION
-    Http::HdrType::X_NEXT_SERVICES,
-#endif
-    Http::HdrType::SURROGATE_CAPABILITY,
-    Http::HdrType::SURROGATE_CONTROL,
-    Http::HdrType::FORWARDED,
-    Http::HdrType::X_FORWARDED_FOR
-};
-
-/* general-headers */
-static Http::HdrType GeneralHeadersArr[] = {
-    Http::HdrType::CACHE_CONTROL,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::DATE,
-    Http::HdrType::FORWARDED,
-    Http::HdrType::X_FORWARDED_FOR,
-    Http::HdrType::MIME_VERSION,
-    Http::HdrType::PRAGMA,
-    Http::HdrType::PROXY_CONNECTION,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    /* Http::HdrType::TRAILER, */
-    Http::HdrType::VIA,
-};
-
-/* entity-headers */
-static Http::HdrType EntityHeadersArr[] = {
-    Http::HdrType::ALLOW,
-    Http::HdrType::CONTENT_BASE,
-    Http::HdrType::CONTENT_ENCODING,
-    Http::HdrType::CONTENT_LANGUAGE,
-    Http::HdrType::CONTENT_LENGTH,
-    Http::HdrType::CONTENT_LOCATION,
-    Http::HdrType::CONTENT_MD5,
-    Http::HdrType::CONTENT_RANGE,
-    Http::HdrType::CONTENT_TYPE,
-    Http::HdrType::ETAG,
-    Http::HdrType::EXPIRES,
-    Http::HdrType::LAST_MODIFIED,
-    Http::HdrType::LINK,
-    Http::HdrType::OTHER
-};
-
-/* request-only headers */
+std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::enumEnd_);
+
+/* request-only headers. Used for cachemgr */
 static HttpHeaderMask RequestHeadersMask;   /* set run-time using RequestHeaders */
-static Http::HdrType RequestHeadersArr[] = {
-    Http::HdrType::ACCEPT,
-    Http::HdrType::ACCEPT_CHARSET,
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_LANGUAGE,
-    Http::HdrType::AUTHORIZATION,
-    Http::HdrType::EXPECT,
-    Http::HdrType::FROM,
-    Http::HdrType::HOST,
-    Http::HdrType::HTTP2_SETTINGS,
-    Http::HdrType::IF_MATCH,
-    Http::HdrType::IF_MODIFIED_SINCE,
-    Http::HdrType::IF_NONE_MATCH,
-    Http::HdrType::IF_RANGE,
-    Http::HdrType::IF_UNMODIFIED_SINCE,
-    Http::HdrType::MAX_FORWARDS,
-    Http::HdrType::ORIGIN,
-    Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::RANGE,
-    Http::HdrType::REFERER,
-    Http::HdrType::REQUEST_RANGE,
-    Http::HdrType::TE,
-    Http::HdrType::USER_AGENT,
-    Http::HdrType::SURROGATE_CAPABILITY
-};
 
-/* reply-only headers */
+/* reply-only headers. Used for cachemgr */
 static HttpHeaderMask ReplyHeadersMask;     /* set run-time using ReplyHeaders */
-static Http::HdrType ReplyHeadersArr[] = {
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_RANGES,
-    Http::HdrType::AGE,
-    Http::HdrType::KEY,
-    Http::HdrType::LOCATION,
-    Http::HdrType::PROXY_AUTHENTICATE,
-    Http::HdrType::PUBLIC,
-    Http::HdrType::RETRY_AFTER,
-    Http::HdrType::SERVER,
-    Http::HdrType::SET_COOKIE,
-    Http::HdrType::SET_COOKIE2,
-    Http::HdrType::VARY,
-    Http::HdrType::WARNING,
-    Http::HdrType::WWW_AUTHENTICATE,
-    Http::HdrType::X_CACHE,
-    Http::HdrType::X_CACHE_LOOKUP,
-    Http::HdrType::X_REQUEST_URI,
-#if X_ACCELERATOR_VARY
-    Http::HdrType::HDR_X_ACCELERATOR_VARY,
-#endif
-#if USE_ADAPTATION
-    Http::HdrType::X_NEXT_SERVICES,
-#endif
-    Http::HdrType::X_SQUID_ERROR,
-    Http::HdrType::SURROGATE_CONTROL
-};
-
-/* hop-by-hop headers */
-static HttpHeaderMask HopByHopHeadersMask;
-static Http::HdrType HopByHopHeadersArr[] = {
-    Http::HdrType::ALTERNATE_PROTOCOL,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::HTTP2_SETTINGS,
-    Http::HdrType::KEEP_ALIVE,
-    /*Http::HdrType::PROXY_AUTHENTICATE, // removal handled specially for peer login */
-    Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::TE,
-    Http::HdrType::TRAILER,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    Http::HdrType::PROXY_CONNECTION
-};
 
 /* header accounting */
 // NP: keep in sync with enum http_hdr_owner_type
@@ -240,7 +93,9 @@
 
 class StoreEntry;
 
-static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, int error);
+// update parse statistics for header id; if error is true also account
+// for errors and write to debug log what happened
+static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, bool error);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
 /** store report about current header usage and other stats */
 static void httpHeaderStoreReport(StoreEntry * e);
@@ -261,28 +116,15 @@
 httpHeaderInitModule(void)
 {
     /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::ENUM_END);
-
-    // check invariant: for each index in headerTable, (int)headerTable[index] = index
-    for (int i = 0; Http::HeaderTable[i].name; ++i)
-        assert(Http::HeaderTable[i].id == i);
-
-    /* create masks. XXX: migrate to std::vector<bool>? */
-    httpHeaderMaskInit(&ListHeadersMask, 0);
-    httpHeaderCalcMask(&ListHeadersMask, ListHeadersArr, countof(ListHeadersArr));
-
-    httpHeaderMaskInit(&ReplyHeadersMask, 0);
-    httpHeaderCalcMask(&ReplyHeadersMask, ReplyHeadersArr, countof(ReplyHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
-
-    httpHeaderMaskInit(&RequestHeadersMask, 0);
-    httpHeaderCalcMask(&RequestHeadersMask, RequestHeadersArr, countof(RequestHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
-
-    httpHeaderMaskInit(&HopByHopHeadersMask, 0);
-    httpHeaderCalcMask(&HopByHopHeadersMask, HopByHopHeadersArr, countof(HopByHopHeadersArr));
+    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::enumEnd_);
+
+    // masks are needed for stats page still
+    for (auto h : WholeEnum<Http::HdrType>()) {
+    	if (Http::HeaderLookupTable.lookup(h).request)
+    		CBIT_SET(RequestHeadersMask,h);
+    	if (Http::HeaderLookupTable.lookup(h).reply)
+    		CBIT_SET(ReplyHeadersMask,h);
+    }
 
     /* header stats initialized by class constructor */
     assert(HttpHeaderStatCount == hoReply + 1);
@@ -386,23 +228,13 @@
 void
 HttpHeader::append(const HttpHeader * src)
 {
-    const HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     assert(src);
     assert(src != this);
     debugs(55, 7, "appending hdr: " << this << " += " << src);
 
-    while ((e = src->getEntry(&pos))) {
-        addEntry(e->clone());
-    }
-}
-
-/* use fresh entries to replace old ones */
-void
-httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask)
-{
-    assert (old);
-    old->update (fresh, denied_mask);
+    for (auto e : src->entries)
+        if (e != nullptr)
+            addEntry (e->clone());
 }
 
 void
@@ -432,20 +264,12 @@
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        debugs(55, 7, "Updating header '" << Http::HeaderTable[e->id].name << "' in cached entry");
+        debugs(55, 7, "Updating header '" << Http::HeaderLookupTable.lookup(e->id).name << "' in cached entry");
 
         addEntry(e->clone());
     }
 }
 
-/* just handy in parsing: resets and returns false */
-int
-HttpHeader::reset()
-{
-    clean();
-    return 0;
-}
-
 int
 HttpHeader::parse(const char *header_start, size_t hdrLen)
 {
@@ -465,7 +289,8 @@
         debugs(55, DBG_IMPORTANT, "WARNING: HTTP header contains NULL characters {" <<
                getStringPrefix(header_start, nulpos-header_start) << "}\nNULL\n{" << getStringPrefix(nulpos+1, hdrLen-(nulpos-header_start)-1));
         PROF_stop(HttpHeaderParse);
-        return reset();
+        clean();
+        return 0;
     }
 
     /* common format headers are "<name>:[ws]<value>" lines delimited by <CRLF>.
@@ -481,7 +306,8 @@
             if (!field_ptr) {
                 // missing <LF>
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
 
             field_end = field_ptr;
@@ -502,7 +328,8 @@
                                "header field to prevent request smuggling attacks: {" <<
                                getStringPrefix(header_start, hdrLen) << "}");
                         PROF_stop(HttpHeaderParse);
-                        return reset();
+                        clean();
+                        return 0;
                     }
                 }
             }
@@ -521,7 +348,8 @@
                     }
                 } else {
                     PROF_stop(HttpHeaderParse);
-                    return reset();
+                    clean();
+                    return 0;
                 }
             }
 
@@ -529,7 +357,8 @@
                 debugs(55, warnOnError, "WARNING: Blank continuation line in HTTP header {" <<
                        getStringPrefix(header_start, hdrLen) << "}");
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         } while (field_ptr < header_end && (*field_ptr == ' ' || *field_ptr == '\t'));
 
@@ -538,7 +367,8 @@
                 debugs(55, warnOnError, "WARNING: unparseable HTTP header field near {" <<
                        getStringPrefix(field_start, hdrLen-(field_start-header_start)) << "}");
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
 
             break;      /* terminating blank line */
@@ -553,7 +383,8 @@
                 continue;
 
             PROF_stop(HttpHeaderParse);
-            return reset();
+            clean();
+            return 0;
         }
 
         // XXX: RFC 7230 Section 3.3.3 item #4 requires sending a 502 error in
@@ -567,7 +398,8 @@
                 if (!Config.onoff.relaxed_header_parser) {
                     delete e;
                     PROF_stop(HttpHeaderParse);
-                    return reset();
+                    clean();
+                    return 0;
                 }
 
                 if (!httpHeaderParseOffset(e->value.termedBuf(), &l1)) {
@@ -591,7 +423,8 @@
                     continue;
 
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         }
 
@@ -602,7 +435,8 @@
             if (!Config.onoff.relaxed_header_parser) {
                 delete e;
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         }
 
@@ -690,10 +524,8 @@
 HttpHeaderEntry *
 HttpHeader::findEntry(Http::HdrType id) const
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(!CBIT_TEST(ListHeadersMask, id));
+    assert(! Http::HeaderLookupTable.lookup(id).list);
 
     /* check mask first */
 
@@ -701,15 +533,13 @@
         return NULL;
 
     /* looks like we must have it, do linear search */
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
+    for (auto e : entries)
+        if (e != nullptr && e->id == id)
             return e;
-    }
 
     /* hm.. we thought it was there, but it was not found */
     assert(0);
-
-    return NULL;        /* not reached */
+    return nullptr;        /* not reached */
 }
 
 /*
@@ -718,25 +548,20 @@
 HttpHeaderEntry *
 HttpHeader::findLastEntry(Http::HdrType id) const
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    HttpHeaderEntry *result = NULL;
     assert(any_registered_header(id));
-    assert(!CBIT_TEST(ListHeadersMask, id));
+    assert(! Http::HeaderLookupTable.lookup(id).list);
 
     /* check mask first */
-
     if (!CBIT_TEST(mask, id))
         return NULL;
 
-    /* looks like we must have it, do linear search */
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
-            result = e;
-    }
+    for (auto e = entries.rbegin(); e != entries.rend(); ++e)
+        if (*e && (*e)->id == id)
+            return *e;
 
-    assert(result);     /* must be there! */
-    return result;
+    /* hm.. we thought it was there, but it was not found */
+    assert(0);
+    return nullptr; /* not reached */
 }
 
 /*
@@ -765,19 +590,17 @@
 int
 HttpHeader::delById(Http::HdrType id)
 {
-    int count = 0;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
     debugs(55, 8, this << " del-by-id " << id);
     assert(any_registered_header(id));
 
     if (!CBIT_TEST(mask, id))
         return 0;
 
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
-            delAt(pos, count);
-    }
+    int sz_before = entries.size();
+    entries.erase(std::remove_if(entries.begin(), entries.end(),
+    [=](HttpHeaderEntry *e) { return e && e->id == id; }),
+    entries.end());
+    int count = entries.size() - sz_before;
 
     CBIT_CLR(mask, id);
     assert(count);
@@ -811,9 +634,8 @@
 HttpHeader::compact()
 {
     // TODO: optimize removal, or possibly make it so that's not needed.
-    std::vector<HttpHeaderEntry *>::iterator newend;
-    newend = std::remove(entries.begin(), entries.end(), static_cast<HttpHeaderEntry *>(NULL));
-    entries.resize(newend-entries.begin());
+    entries.erase( std::remove(entries.begin(), entries.end(), nullptr),
+                   entries.end());
 }
 
 /*
@@ -824,10 +646,9 @@
 {
     httpHeaderMaskInit(&mask, 0);
     debugs(55, 7, "refreshing the mask in hdr " << this);
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    while (HttpHeaderEntry *e = getEntry(&pos)) {
-        CBIT_SET(mask, e->id);
-    }
+    for ( auto e : entries )
+        if (e != nullptr)
+            CBIT_SET(mask, e->id);
 }
 
 /* appends an entry;
@@ -883,19 +704,16 @@
 bool
 HttpHeader::getList(Http::HdrType id, String *s) const
 {
-    HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     debugs(55, 9, this << " joining for id " << id);
     /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
+    assert(Http::HeaderLookupTable.lookup(id).list);
 
     if (!CBIT_TEST(mask, id))
         return false;
 
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
+    for (auto e: entries)
+        if (e != nullptr && e->id == id)
             strListAdd(s, e->value.termedBuf(), ',');
-    }
 
     /*
      * note: we might get an empty (size==0) string if there was an "empty"
@@ -904,7 +722,7 @@
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s->size())
-        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderLookupTable.lookup(id).name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -919,7 +737,7 @@
     HttpHeaderPos pos = HttpHeaderInitPos;
     debugs(55, 9, this << "joining for id " << id);
     /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
+    assert(Http::HeaderLookupTable.lookup(id).list);
 
     if (!CBIT_TEST(mask, id))
         return String();
@@ -938,7 +756,7 @@
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s.size())
-        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderLookupTable.lookup(id).name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -951,7 +769,7 @@
 {
     HttpHeaderEntry *e;
 
-    if (CBIT_TEST(ListHeadersMask, id))
+    if (Http::HeaderLookupTable.lookup(id).list)
         return getList(id);
 
     if ((e = findEntry(id)))
@@ -968,12 +786,46 @@
 {
     String result;
     // ignore presence: return undefined string if an empty header is present
+    (void)getByNameIfPresent(name, strlen(name), result);
+    return result;
+}
+
+String
+HttpHeader::getByName(const SBuf &name) const
+{
+    String result;
+    // ignore presence: return undefined string if an empty header is present
     (void)getByNameIfPresent(name, result);
     return result;
 }
 
-bool
-HttpHeader::getByNameIfPresent(const char *name, String &result) const
+String
+HttpHeader::getById(Http::HdrType id) const
+{
+    String result;
+    (void)getByIdIfPresent(id,result);
+    return result;
+}
+
+bool
+HttpHeader::getByNameIfPresent(const SBuf &s, String &result) const
+{
+    return getByNameIfPresent(s.rawContent(), s.length(), result);
+}
+
+bool
+HttpHeader::getByIdIfPresent(Http::HdrType id, String &result) const
+{
+    if (id == Http::HdrType::BAD_HDR)
+        return false;
+    if (!has(id))
+        return false;
+    result = getStrOrList(id);
+    return true;
+}
+
+bool
+HttpHeader::getByNameIfPresent(const char *name, int namelen, String &result) const
 {
     Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -982,13 +834,11 @@
     assert(name);
 
     /* First try the quick path */
-    id = Http::HeaderLookupTable.lookup(SBuf(name));
+    id = Http::HeaderLookupTable.lookup(name,namelen).id;
 
     if (id != Http::HdrType::BAD_HDR) {
-        if (!has(id))
-            return false;
-        result = getStrOrList(id);
-        return true;
+        if (getByIdIfPresent(id, result))
+            return true;
     }
 
     /* Sorry, an unknown header name. Do linear search */
@@ -1072,7 +922,7 @@
 HttpHeader::putInt(Http::HdrType id, int number)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xitoa(number)));
 }
@@ -1081,7 +931,7 @@
 HttpHeader::putInt64(Http::HdrType id, int64_t number)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xint64toa(number)));
 }
@@ -1090,25 +940,16 @@
 HttpHeader::putTime(Http::HdrType id, time_t htime)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
 void
-HttpHeader::insertTime(Http::HdrType id, time_t htime)
-{
-    assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
-    assert(htime >= 0);
-    insertEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
-}
-
-void
 HttpHeader::putStr(Http::HdrType id, const char *str)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
     assert(str);
     addEntry(new HttpHeaderEntry(id, NULL, str));
 }
@@ -1205,7 +1046,7 @@
 HttpHeader::getInt(Http::HdrType id) const
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1218,7 +1059,7 @@
 HttpHeader::getInt64(Http::HdrType id) const
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1233,7 +1074,7 @@
     HttpHeaderEntry *e;
     time_t value = -1;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         value = parse_rfc1123(e->value.termedBuf());
@@ -1249,10 +1090,10 @@
 {
     HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
-        httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
+        httpHeaderNoteParsedEntry(e->id, e->value, false);  /* no errors are possible */
         return e->value.termedBuf();
     }
 
@@ -1265,10 +1106,10 @@
 {
     HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findLastEntry(id))) {
-        httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
+        httpHeaderNoteParsedEntry(e->id, e->value, false);  /* no errors are possible */
         return e->value.termedBuf();
     }
 
@@ -1403,7 +1244,7 @@
 {
     ETag etag = {NULL, -1};
     HttpHeaderEntry *e;
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
 
     if ((e = findEntry(id)))
         etagParseInit(&etag, e->value.termedBuf());
@@ -1416,7 +1257,7 @@
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
 
     if ((e = findEntry(id))) {
@@ -1448,7 +1289,7 @@
     id = anId;
 
     if (id != Http::HdrType::OTHER)
-        name = Http::HeaderTable[id].name;
+        name = Http::HeaderLookupTable.lookup(id).name;
     else
         name = aName;
 
@@ -1511,7 +1352,7 @@
     debugs(55, 9, "parsing HttpHeaderEntry: near '" <<  getStringPrefix(field_start, field_end-field_start) << "'");
 
     /* is it a "known" field? */
-    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(field_start,name_len));
+    Http::HdrType id = Http::HeaderLookupTable.lookup(field_start,name_len).id;
     debugs(55, 9, "got hdr-id=" << id);
 
     String name;
@@ -1525,7 +1366,7 @@
     if (id == Http::HdrType::OTHER)
         name.limitInit(field_start, name_len);
     else
-        name = Http::HeaderTable[id].name;
+        name = Http::HeaderLookupTable.lookup(id).name;
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
@@ -1576,7 +1417,7 @@
 {
     int val = -1;
     int ok = httpHeaderParseInt(value.termedBuf(), &val);
-    httpHeaderNoteParsedEntry(id, value, !ok);
+    httpHeaderNoteParsedEntry(id, value, ok == 0);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
@@ -1588,7 +1429,7 @@
 {
     int64_t val = -1;
     int ok = httpHeaderParseOffset(value.termedBuf(), &val);
-    httpHeaderNoteParsedEntry(id, value, !ok);
+    httpHeaderNoteParsedEntry(id, value, ok == 0);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
@@ -1596,7 +1437,7 @@
 }
 
 static void
-httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, int error)
+httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, bool error)
 {
     if (id != Http::HdrType::BAD_HDR)
         ++ headerStatsTable[id].parsCount;
@@ -1604,7 +1445,7 @@
     if (error) {
         if (id != Http::HdrType::BAD_HDR)
             ++ headerStatsTable[id].errCount;
-        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderTable[id].name << ": " << context << "'");
+        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderLookupTable.lookup(id).name << ": " << context << "'");
     }
 }
 
@@ -1621,7 +1462,7 @@
 {
     const int id = static_cast<int>(val);
     const bool valid_id = Http::any_valid_header(static_cast<Http::HdrType>(id));
-    const char *name = valid_id ? Http::HeaderTable[id].name : "INVALID";
+    const char *name = valid_id ? Http::HeaderLookupTable.lookup(static_cast<Http::HdrType>(id)).name : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
 
@@ -1696,11 +1537,11 @@
                       "id", "name", "#alive", "%err", "%repeat");
 
     // scan heaaderTable and output
-    for (int j = 0; Http::HeaderTable[j].name != nullptr; ++j) {
-        auto stats = headerStatsTable[j];
+    for (auto h : WholeEnum<Http::HdrType>()) {
+        auto stats = headerStatsTable[h];
         storeAppendPrintf(e, "%2d\t %-25s\t %5d\t %6.3f\t %6.3f\n",
-                          Http::HeaderTable[j].id,
-                          Http::HeaderTable[j].name,
+                          Http::HeaderLookupTable.lookup(h).id,
+                          Http::HeaderLookupTable.lookup(h).name,
                           stats.aliveCount,
                           xpercent(stats.errCount, stats.parsCount),
                           xpercent(stats.repCount, stats.seenCount));
@@ -1771,7 +1612,7 @@
     int headers_deleted = 0;
     while ((e = getEntry(&pos))) {
         Http::HdrType id = e->id;
-        if (CBIT_TEST(HopByHopHeadersMask, id)) {
+        if (Http::HeaderLookupTable.lookup(id).hopbyhop) {
             delAt(pos, headers_deleted);
             CBIT_CLR(mask, id);
         }

=== modified file 'src/HttpHeader.h'
--- src/HttpHeader.h	2015-08-10 21:23:12 +0000
+++ src/HttpHeader.h	2015-08-13 07:25:26 +0000
@@ -83,7 +83,6 @@
     void append(const HttpHeader * src);
     void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
     void compact();
-    int reset();
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
@@ -98,16 +97,20 @@
     bool getList(Http::HdrType id, String *s) const;
     bool conflictingContentLength() const { return conflictingContentLength_; }
     String getStrOrList(Http::HdrType id) const;
+    String getByName(const SBuf &name) const;
     String getByName(const char *name) const;
+    String getById(Http::HdrType id) const;
+    /// sets value and returns true iff a [possibly empty] field identified by id is there
+    bool getByIdIfPresent(Http::HdrType id, String &result) const;
     /// sets value and returns true iff a [possibly empty] named field is there
-    bool getByNameIfPresent(const char *name, String &value) const;
+    bool getByNameIfPresent(const SBuf &s, String &value) const;
+    bool getByNameIfPresent(const char *name, int namelen, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(Http::HdrType id, const char *member, const char separator) const;
     int has(Http::HdrType id) const;
     void putInt(Http::HdrType id, int number);
     void putInt64(Http::HdrType id, int64_t number);
     void putTime(Http::HdrType id, time_t htime);
-    void insertTime(Http::HdrType id, time_t htime);
     void putStr(Http::HdrType id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
@@ -153,8 +156,6 @@
 /// quotes string using RFC 7230 quoted-string rules
 SBuf httpHeaderQuoteString(const char *raw);
 
-int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
 void httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count);
 
 inline bool

=== modified file 'src/HttpHeaderStat.h'
--- src/HttpHeaderStat.h	2015-08-05 13:47:19 +0000
+++ src/HttpHeaderStat.h	2015-08-13 12:27:56 +0000
@@ -27,7 +27,7 @@
         busyDestroyedCount(0)
     {
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::enumEnd_);
         ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -43,7 +43,7 @@
     {
         assert(label);
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::enumEnd_);
         ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }

=== modified file 'src/HttpHeaderTools.cc'
--- src/HttpHeaderTools.cc	2015-08-05 13:47:19 +0000
+++ src/HttpHeaderTools.cc	2015-08-15 21:31:26 +0000
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
+#include "base/EnumIterator.h"
 #include "client_side.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
@@ -45,21 +46,6 @@
     memset(mask, value, sizeof(*mask));
 }
 
-/** calculates a bit mask of a given array; does not reset mask! */
-void
-httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count)
-{
-    size_t i;
-    const int * enums = (const int *) http_hdr_type_enums;
-    assert(mask && enums);
-    assert(count < sizeof(*mask) * 8);  /* check for overflow */
-
-    for (i = 0; i < count; ++i) {
-        assert(!CBIT_TEST(*mask, enums[i]));    /* check for duplicates */
-        CBIT_SET(*mask, enums[i]);
-    }
-}
-
 /* same as httpHeaderPutStr, but formats the string using snprintf first */
 void
 httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...)
@@ -374,12 +360,11 @@
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < Http::HdrType::ENUM_END; ++i)
+    for (auto i : WholeEnum<Http::HdrType>())
         header_mangler_clean(known[i]);
 
-    typedef ManglersByName::iterator MBNI;
-    for (MBNI i = custom.begin(); i != custom.end(); ++i)
-        header_mangler_clean(i->second);
+    for (auto i : custom)
+        header_mangler_clean(i.second);
 
     header_mangler_clean(all);
 }
@@ -387,13 +372,11 @@
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
-        header_mangler_dump_access(entry, name, known[i], Http::HeaderTable[i].name);
-    }
+    for (auto id : WholeEnum<Http::HdrType>())
+        header_mangler_dump_access(entry, name, known[id], Http::HeaderLookupTable.lookup(id).name);
 
-    typedef ManglersByName::const_iterator MBNCI;
-    for (MBNCI i = custom.begin(); i != custom.end(); ++i)
-        header_mangler_dump_access(entry, name, i->second, i->first.c_str());
+    for (auto i : custom)
+        header_mangler_dump_access(entry, name, i.second, i.first.c_str());
 
     header_mangler_dump_access(entry, name, all, "All");
 }
@@ -401,14 +384,12 @@
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
-        header_mangler_dump_replacement(entry, name, known[i],Http::HeaderTable[i].name);
-    }
+    for (auto id : WholeEnum<Http::HdrType>())
+        header_mangler_dump_replacement(entry, name, known[id], Http::HeaderLookupTable.lookup(id).name);
 
-    typedef ManglersByName::const_iterator MBNCI;
-    for (MBNCI i = custom.begin(); i != custom.end(); ++i) {
-        header_mangler_dump_replacement(entry, name, i->second,
-                                        i->first.c_str());
+    for (auto i: custom) {
+        header_mangler_dump_replacement(entry, name, i.second,
+                                        i.first.c_str());
     }
 
     header_mangler_dump_replacement(entry, name, all, "All");
@@ -417,25 +398,21 @@
 headerMangler *
 HeaderManglers::track(const char *name)
 {
-    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name));
+    const Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name)).id;
+    headerMangler *m = nullptr;
 
     if (id == Http::HdrType::BAD_HDR) { // special keyword or a custom header
         if (strcmp(name, "All") == 0)
-            id = Http::HdrType::ENUM_END;
+            m = &all;
         else if (strcmp(name, "Other") == 0)
-            id = Http::HdrType::OTHER;
-    }
-
-    headerMangler *m = NULL;
-    if (id == Http::HdrType::ENUM_END) {
-        m = &all;
-    } else if (id == Http::HdrType::BAD_HDR) {
-        m = &custom[name];
+            m = &known[Http::HdrType::OTHER];
+        else
+            m = &custom[name];
     } else {
-        m = &known[id]; // including Http::HdrType::OTHER
+        m = &known[id];
     }
 
-    assert(m);
+    // m cannot be nullptr, it's set in all code paths
     return m;
 }
 

=== modified file 'src/HttpHeaderTools.h'
--- src/HttpHeaderTools.h	2015-08-04 19:57:07 +0000
+++ src/HttpHeaderTools.h	2015-08-13 12:27:56 +0000
@@ -74,7 +74,7 @@
     typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
-    headerMangler known[static_cast<int>(Http::HdrType::ENUM_END)];
+    headerMangler known[static_cast<int>(Http::HdrType::enumEnd_)];
 
     /// one mangler for each custom header
     ManglersByName custom;

=== modified file 'src/HttpReply.cc'
--- src/HttpReply.cc	2015-08-04 19:57:07 +0000
+++ src/HttpReply.cc	2015-08-15 21:29:15 +0000
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
+#include "base/EnumIterator.h"
 #include "globals.h"
 #include "HttpBody.h"
 #include "HttpHdrCc.h"
@@ -38,16 +39,11 @@
  * The list of headers we don't update is made up of:
  *     all hop-by-hop headers
  *     all entity-headers except Expires and Content-Location
+ *
+ * These headers are now stored in RegisteredHeadersHash.gperf and accessible
+ * as Http::HeaderLookupTable.lookup(id).denied304
  */
 static HttpHeaderMask Denied304HeadersMask;
-static Http::HdrType Denied304HeadersArr[] = {
-    // hop-by-hop headers
-    Http::HdrType::CONNECTION, Http::HdrType::KEEP_ALIVE, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::TE, Http::HdrType::TRAILER, Http::HdrType::TRANSFER_ENCODING, Http::HdrType::UPGRADE,
-    // entity headers
-    Http::HdrType::ALLOW, Http::HdrType::CONTENT_ENCODING, Http::HdrType::CONTENT_LANGUAGE, Http::HdrType::CONTENT_LENGTH,
-    Http::HdrType::CONTENT_MD5, Http::HdrType::CONTENT_RANGE, Http::HdrType::CONTENT_TYPE, Http::HdrType::LAST_MODIFIED
-};
 
 /* module initialization */
 void
@@ -55,7 +51,10 @@
 {
     assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
     httpHeaderMaskInit(&Denied304HeadersMask, 0);
-    httpHeaderCalcMask(&Denied304HeadersMask, Denied304HeadersArr, countof(Denied304HeadersArr));
+
+    for (auto id : WholeEnum<Http::HdrType>())
+    	if (Http::HeaderLookupTable.lookup(id).denied304)
+    		CBIT_SET(Denied304HeadersMask, id);
 }
 
 HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-08-03 03:50:25 +0000
+++ src/Makefile.am	2015-08-12 15:36:38 +0000
@@ -420,6 +420,8 @@
 	send-announce.h \
 	send-announce.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	SBufDetailedStats.cc \
 	SBufStatsAction.h \
@@ -904,6 +906,7 @@
 	tests/testCharacterSet \
 	tests/testDiskIO \
 	tests/testDns \
+	tests/testEnumIterator \
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
@@ -997,6 +1000,8 @@
 	SquidString.h \
 	SquidTime.h \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -1109,6 +1114,8 @@
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -1375,6 +1382,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -1546,6 +1555,8 @@
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	StoreFileSystem.cc \
@@ -1809,6 +1820,8 @@
 	StrList.h \
 	StrList.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2049,6 +2062,8 @@
 	refresh.h \
 	refresh.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2287,6 +2302,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2434,6 +2451,8 @@
 	cache_cf.h \
 	YesNoNone.h \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	tests/stub_SBufDetailedStats.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
@@ -2609,6 +2628,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2817,6 +2838,8 @@
 	store_key_md5.h \
 	store_key_md5.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3061,6 +3084,8 @@
 	tests/stub_helper.cc \
 	cbdata.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3237,6 +3262,8 @@
 	store_swapmeta.cc \
 	store_swapout.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3454,6 +3481,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -3747,7 +3776,9 @@
 	tests/stub_SBufDetailedStats.cc \
 	base/LookupTable.h \
 	String.cc \
-	$(SBUF_SOURCE)
+	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc
 nodist_tests_testLookupTable_SOURCES = $(TESTSOURCES)
 tests_testLookupTable_LDFLAGS = $(LIBADD_DL)
 tests_testLookupTable_LDADD = \
@@ -3757,6 +3788,20 @@
 	$(XTRA_LIBS)
 tests_testLookupTable_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testEnumIterator_SOURCES = \
+	tests/testEnumIterator.h \
+	tests/testEnumIterator.cc \
+	base/EnumIterator.h \
+	tests/stub_debug.cc
+nodist_tests_testEnumIterator_SOURCES = $(TESTSOURCES)
+tests_testEnumIterator_LDFLAGS = $(LIBADD_DL)
+tests_testEnumIterator_LDADD = \
+	base/libbase.la \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+tests_testEnumIterator_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
+
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script

=== modified file 'src/SBufAlgos.cc'
--- src/SBufAlgos.cc	2015-07-29 18:12:16 +0000
+++ src/SBufAlgos.cc	2015-08-13 13:55:42 +0000
@@ -9,17 +9,32 @@
 #include "squid.h"
 #include "SBufAlgos.h"
 
-std::size_t std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+#include <cctype>
+
+static std::size_t
+lowSBufHash (const SBuf & sbuf, bool caseInsensitive = false) noexcept
 {
     //ripped and adapted from hash_string
     const char *s = sbuf.rawContent();
     size_t rv = 0;
     SBuf::size_type len=sbuf.length();
     while (len != 0) {
-        rv ^= 271 * *s;
+        rv ^= 271 * (caseInsensitive? tolower(*s) : *s);
         ++s;
         --len;
     }
     return rv ^ (sbuf.length() * 271);
 }
 
+std::size_t
+std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+{
+    return lowSBufHash(sbuf);
+}
+
+std::size_t
+CaseInsensitiveSBufHash::operator() (const SBuf & sbuf) const noexcept
+{
+    return lowSBufHash(sbuf, true);
+}
+

=== modified file 'src/SBufAlgos.h'
--- src/SBufAlgos.h	2015-07-29 18:12:16 +0000
+++ src/SBufAlgos.h	2015-08-06 09:30:28 +0000
@@ -90,5 +90,11 @@
 };
 }
 
+class CaseInsensitiveSBufHash
+{
+public:
+    std::size_t operator()(const SBuf &) const noexcept;
+};
+
 #endif /* SQUID_SBUFALGOS_H_ */
 

=== modified file 'src/acl/HttpHeaderData.cc'
--- src/acl/HttpHeaderData.cc	2015-08-04 21:04:09 +0000
+++ src/acl/HttpHeaderData.cc	2015-08-11 10:29:25 +0000
@@ -47,7 +47,7 @@
             return false;
         value = hdr->getStrOrList(hdrId);
     } else {
-        if (!hdr->getByNameIfPresent(hdrName.termedBuf(), value))
+        if (!hdr->getByNameIfPresent(hdrName, value))
             return false;
     }
 
@@ -76,14 +76,14 @@
     char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
-    hdrId = Http::HeaderLookupTable.lookup(SBuf(hdrName));
+    hdrId = Http::HeaderLookupTable.lookup(hdrName).id;
     regex_rule->parse();
 }
 
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == Http::HdrType::BAD_HDR && hdrName.size()==0) || regex_rule->empty();
+    return (hdrId == Http::HdrType::BAD_HDR && hdrName.isEmpty()) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *

=== modified file 'src/acl/HttpHeaderData.h'
--- src/acl/HttpHeaderData.h	2015-08-04 19:57:07 +0000
+++ src/acl/HttpHeaderData.h	2015-08-10 15:57:56 +0000
@@ -11,6 +11,7 @@
 
 #include "acl/Data.h"
 #include "HttpHeader.h"
+#include "SBuf.h"
 #include "SquidString.h"
 
 class ACLHTTPHeaderData : public ACLData<HttpHeader*>
@@ -28,7 +29,7 @@
 
 private:
     Http::HdrType hdrId;                /**< set if header is known */
-    String hdrName;                     /**< always set */
+    SBuf hdrName;                     /**< always set */
     ACLData<char const *> * regex_rule;
 };
 

=== modified file 'src/adaptation/icap/ModXact.cc'
--- src/adaptation/icap/ModXact.cc	2015-08-04 19:57:07 +0000
+++ src/adaptation/icap/ModXact.cc	2015-08-11 06:49:51 +0000
@@ -830,6 +830,7 @@
         }
     }
 
+#if USE_ADAPTATION
     // update the adaptation plan if needed (all status codes!)
     if (service().cfg().routing) {
         String services;
@@ -839,6 +840,7 @@
                 ah->updateNextServices(services);
         }
     } // TODO: else warn (occasionally!) if we got Http::HdrType::X_NEXT_SERVICES
+#endif
 
     // We need to store received ICAP headers for <icapLastHeader logformat option.
     // If we already have stored headers from previous ICAP transaction related to this
@@ -1342,12 +1344,12 @@
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
-        String vh=virgin.header->header.getByName("Proxy-Authenticate");
+        String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHENTICATE);
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHORIZATION)) {
-        String vh=virgin.header->header.getByName("Proxy-Authorization");
+        String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHORIZATION);
         buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
         struct base64_encode_ctx ctx;

=== modified file 'src/auth/UserRequest.cc'
--- src/auth/UserRequest.cc	2015-08-04 19:57:07 +0000
+++ src/auth/UserRequest.cc	2015-08-13 12:27:56 +0000
@@ -481,11 +481,11 @@
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
-        type = Http::HdrType::ENUM_END;
+        type = Http::HdrType::BAD_HDR;
         break;
     }
 
-    debugs(29, 9, HERE << "headertype:" << type << " authuser:" << auth_user_request);
+    debugs(29, 9, "headertype:" << type << " authuser:" << auth_user_request);
 
     if (((rep->sline.status() == Http::scProxyAuthenticationRequired)
             || (rep->sline.status() == Http::scUnauthorized)) && internal)

=== added file 'src/base/EnumIterator.h'
--- src/base/EnumIterator.h	1970-01-01 00:00:00 +0000
+++ src/base/EnumIterator.h	2015-08-15 16:46:43 +0000
@@ -0,0 +1,163 @@
+#ifndef SQUID_BASE_ENUMITERATOR_H
+#define SQUID_BASE_ENUMITERATOR_H
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include <iterator>
+#include <type_traits>
+
+/* code shared between forward and reverse iterators */
+template <typename Enum>
+class EnumIteratorBase : public std::iterator<std::bidirectional_iterator_tag, Enum>
+{
+public:
+    explicit EnumIteratorBase(Enum e) : current(static_cast<iterator_type>(e)) {}
+
+    bool operator==(const EnumIteratorBase &i) const {
+        return current == i.current;
+    }
+
+    bool operator!=(const EnumIteratorBase &i) const {
+        return current != i.current;
+    }
+
+    Enum operator*() const {
+        return static_cast<Enum>(current);
+    }
+
+protected:
+#if HAVE_STD_UNDERLYING_TYPE
+    typedef typename std::underlying_type<Enum>::type iterator_type;
+#else
+    typedef int iterator_type;
+#endif
+    iterator_type current;
+};
+
+/** iterator over an enum type
+ *
+ */
+template <typename Enum>
+class EnumIterator : public EnumIteratorBase<Enum>
+{
+public:
+    explicit EnumIterator(Enum e) : EnumIteratorBase<Enum>(e) {}
+
+    // prefix increment
+    EnumIterator& operator++() {
+        ++ EnumIteratorBase<Enum>::current;
+        return *this;
+    }
+
+    // postfix increment
+    EnumIterator& operator++(int) {
+        EnumIterator rv(*this);
+        ++ EnumIteratorBase<Enum>::current;
+        return rv;
+    }
+
+    // prefix decrement
+    EnumIterator& operator--() {
+        -- EnumIteratorBase<Enum>::current;
+        return *this;
+    }
+
+    // postfix decrement
+    EnumIterator& operator--(int) {
+        EnumIterator rv(*this);
+        -- EnumIteratorBase<Enum>::current;
+        return rv;
+    }
+};
+
+template <typename Enum>
+class ReverseEnumIterator : public EnumIteratorBase<Enum>
+{
+public:
+    explicit ReverseEnumIterator(Enum e) : EnumIteratorBase<Enum>(e) {}
+
+    // prefix increment
+    ReverseEnumIterator& operator++() {
+        -- EnumIteratorBase<Enum>::current;
+        return *this;
+    }
+
+    // postfix increment
+    ReverseEnumIterator& operator++(int) {
+        ReverseEnumIterator rv(*this);
+        -- EnumIteratorBase<Enum>::current;
+        return rv;
+    }
+
+    // prefix decrement
+    ReverseEnumIterator& operator--() {
+        ++ EnumIteratorBase<Enum>::current;
+        return *this;
+    }
+
+    // postfix decrement
+    ReverseEnumIterator& operator--(int) {
+        ReverseEnumIterator rv(*this);
+        ++ EnumIteratorBase<Enum>::current;
+        return rv;
+    }
+};
+
+/** Class expressing a range of an enum
+ *
+ * This class is suited to use range-for over a continuous portion of an enum.
+ * This class requires that the underlying enum values be represented by
+ * continuous values of an integral type.
+ * Typical use:
+ * for ( auto enumvalue : EnumRangeT<EnumType>(EnumType::somevalue,
+ *                        EnumType::someOtherValue) )
+ * { do_stuff(); }
+ * Note that EnumIterator<enum>(EnumType::firstmember,EnumType::lastmember)
+ * will miss EnumType::lastmember while iterating. If you need to iterate
+ * over all of EnumType, use class WholeEnum. Otherwise you'll have to
+ * explicitly address lastmember outside the iteration loop.
+ */
+template <typename Enum>
+class EnumRangeT
+{
+public:
+    typedef EnumIterator<Enum> iterator;
+    typedef ReverseEnumIterator<Enum> reverse_iterator;
+    EnumRangeT(Enum first, Enum one_past_last) : begin_(first), end_(one_past_last) { }
+    iterator begin() const { return iterator(begin_);}
+    iterator end() const { return iterator(end_);}
+    reverse_iterator rbegin() const { return ++reverse_iterator(end_); }
+    reverse_iterator rend() const { return ++reverse_iterator(begin_); }
+private:
+    Enum begin_;
+    Enum end_;
+};
+
+/// convenience function to deduce the right type for instantiating EnumRangeT
+template <typename Enum>
+EnumRangeT<Enum> EnumRange(Enum begin, Enum one_past_end)
+{
+    return EnumRangeT<Enum>(begin,one_past_end);
+}
+
+/** Class for iterating all enum values, from Enum::enumBegin_ up to, but
+ *  not including, Enum::enumEnd_. Both markers must be present as enum values.
+ *
+ * This class requires that the underlying enum values be represented by
+ * continuous values of an integral type.
+ * Typical use: for( auto enumvalue : WholeEnum<EnumType>() ) { do_stuff(); }
+ */
+template <typename Enum>
+class WholeEnum : public EnumRangeT<Enum>
+{
+public:
+    WholeEnum() : EnumRangeT<Enum>(Enum::enumBegin_, Enum::enumEnd_) {}
+};
+
+#endif /* SQUID_BASE_ENUMITERATOR_H */
+

=== modified file 'src/base/LookupTable.h'
--- src/base/LookupTable.h	2015-08-04 14:58:58 +0000
+++ src/base/LookupTable.h	2015-08-06 15:38:27 +0000
@@ -10,8 +10,9 @@
 #define SQUID_LOOKUPTABLE_H_
 
 #include "SBuf.h"
+#include "SBufAlgos.h"
 
-#include <map>
+#include <unordered_map>
 
 /**
  * a record in the initializer list for a LookupTable
@@ -53,7 +54,7 @@
     }
 };
 
-template<typename EnumType, typename RecordType = LookupTableRecord<EnumType> >
+template<typename EnumType, typename RecordType = LookupTableRecord<EnumType>, typename Hasher = CaseInsensitiveSBufHash >
 class LookupTable
 {
 public:
@@ -76,7 +77,7 @@
     }
 
 private:
-    typedef std::map<const SBuf, EnumType, SBufCaseInsensitiveLess> lookupTable_t;
+    typedef std::unordered_map<const SBuf, EnumType, Hasher> lookupTable_t;
     lookupTable_t lookupTable;
     EnumType invalidValue;
 };

=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2015-08-03 02:08:22 +0000
+++ src/base/Makefile.am	2015-08-12 15:36:38 +0000
@@ -35,4 +35,5 @@
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	TidyPointer.h
+	TidyPointer.h \
+	EnumIterator.h

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-08-11 04:41:55 +0000
+++ src/cache_cf.cc	2015-08-13 07:25:26 +0000
@@ -4606,7 +4606,7 @@
     }
     HeaderWithAcl hwa;
     hwa.fieldName = fn;
-    hwa.fieldId = Http::HeaderLookupTable.lookup(SBuf(fn));
+    hwa.fieldId = Http::HeaderLookupTable.lookup(hwa.fieldName).id;
     if (hwa.fieldId == Http::HdrType::BAD_HDR)
         hwa.fieldId = Http::HdrType::OTHER;
 

=== modified file 'src/client_side_reply.cc'
--- src/client_side_reply.cc	2015-08-04 19:57:07 +0000
+++ src/client_side_reply.cc	2015-08-10 20:14:03 +0000
@@ -1348,19 +1348,19 @@
          */
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             hdr->delById(Http::HdrType::DATE);
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
             HttpHeaderEntry *h = hdr->findEntry(Http::HdrType::DATE);
             if (h)
                 hdr->putExt("X-Origin-Date", h->value.termedBuf());
             hdr->delById(Http::HdrType::DATE);
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
             h = hdr->findEntry(Http::HdrType::EXPIRES);
             if (h && http->storeEntry()->expires >= 0) {
                 hdr->putExt("X-Origin-Expires", h->value.termedBuf());
                 hdr->delById(Http::HdrType::EXPIRES);
-                hdr->insertTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
+                hdr->putTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
@@ -1399,9 +1399,9 @@
      */
     if ( !hdr->has(Http::HdrType::DATE) ) {
         if (!http->storeEntry())
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
         else if (http->storeEntry()->timestamp > 0)
-            hdr->insertTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
+            hdr->putTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
         else {
             debugs(88,DBG_IMPORTANT,"BUG 3279: HTTP reply without Date:");
             /* dump something useful about the problem */

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-08-04 21:04:09 +0000
+++ src/external_acl.cc	2015-08-11 10:29:25 +0000
@@ -244,7 +244,7 @@
     }
 
     format->header = xstrdup(header);
-    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header));
+    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header)).id;
 }
 
 void

=== modified file 'src/htcp.cc'
--- src/htcp.cc	2015-08-04 19:57:07 +0000
+++ src/htcp.cc	2015-08-10 22:24:57 +0000
@@ -853,7 +853,7 @@
         stuff.D.respHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: resp_hdrs = {" << stuff.D.resp_hdrs << "}");
         mb.reset();
-        hdr.reset();
+        hdr.clean();
 
         if (e && e->expires > -1)
             hdr.putTime(Http::HdrType::EXPIRES, e->expires);
@@ -869,8 +869,7 @@
         debugs(31, 3, "htcpTstReply: entity_hdrs = {" << stuff.D.entity_hdrs << "}");
 
         mb.reset();
-
-        hdr.reset();
+        hdr.clean();
 
 #if USE_ICMP
         if (char *host = urlHostname(spec->uri)) {

=== modified file 'src/http.cc'
--- src/http.cc	2015-08-10 21:23:12 +0000
+++ src/http.cc	2015-08-13 13:56:43 +0000
@@ -589,22 +589,15 @@
     vary = reply->header.getList(Http::HdrType::VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
-        char *name = (char *)xmalloc(ilen + 1);
-        xstrncpy(name, item, ilen + 1);
-        Tolower(name);
-
-        if (strcmp(name, "*") == 0) {
-            /* Can not handle "Vary: *" withtout ETag support */
-            safe_free(name);
+        SBuf name(item, ilen);
+        if (name.cmp("*",1) == 0) {
             vstr.clean();
             break;
         }
-
-        strListAdd(&vstr, name, ',');
+        name.toLower();
+        strListAdd(&vstr, name.c_str(), ',');
         hdr = request->header.getByName(name);
-        safe_free(name);
         value = hdr.termedBuf();
-
         if (value) {
             value = rfc1738_escape_part(value);
             vstr.append("=\"", 2);

=== modified file 'src/http/Makefile.am'
--- src/http/Makefile.am	2015-08-04 11:09:58 +0000
+++ src/http/Makefile.am	2015-08-11 09:51:46 +0000
@@ -20,6 +20,8 @@
 	ProtocolVersion.h \
 	RegisteredHeaders.h \
 	RegisteredHeaders.cc \
+	RegisteredHeadersHash.cci \
+	RegisteredHeadersHash.gperf \
 	RequestMethod.cc \
 	RequestMethod.h \
 	StatusCode.cc \
@@ -33,4 +35,7 @@
 	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk sbuf=1 < $(srcdir)/MethodType.h | \
 		sed -e 's%METHOD_%%' -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
 
+RegisteredHeadersHash.cci: RegisteredHeadersHash.gperf
+	gperf --output-file=$@ -m 100000 $<
+
 CLEANFILES += MethodType.cc

=== modified file 'src/http/RegisteredHeaders.cc'
--- src/http/RegisteredHeaders.cc	2015-08-06 12:12:11 +0000
+++ src/http/RegisteredHeaders.cc	2015-08-15 21:29:15 +0000
@@ -10,114 +10,61 @@
 #include "RegisteredHeaders.h"
 
 #include <ostream>
+#include <vector>
 
 namespace Http
 {
-/*
- * A table with major attributes for every known field.
- *
- * Invariant on this table:
- * for each index in HeaderTable, (int)HeaderTable[index] = index
- *
- * To be kept in sync with Http::HdrType
- */
-const HeaderTableRecord HeaderTable[] = {
-    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr},
-    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr},
-    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr},
-    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr},
-    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr},
-    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt},
-    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr},
-    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr},
-    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
-    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr},    /* for now */
-    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc},
-    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr},
-    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr},
-    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr},  /* for now */
-    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr},
-    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr},
-    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64},
-    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr},
-    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr},    /* for now */
-    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange},
-    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr},
-    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr},
-    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr},
-    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123},
-    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag},
-    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr},
-    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123},
-    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr},
-    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr},
-    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr},
-    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr}, /* for now */
-    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr},  /* for now */
-    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
-    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr},    /* for now */
-    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag},
-    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
-    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr},
-    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr},
-    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123},
-    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr},
-    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr},
-    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64},
-    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr},  /* for now */
-    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr},
-    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr},
-    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr},
-    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr},
-    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
-    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr},
-    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr},
-    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr},
-    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr},
-    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange},
-    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr},
-    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange}, /* usually matches Http::HdrType::RANGE */
-    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr},    /* for now (Http::HdrFieldType::ftDate_1123 or Http::HdrFieldType::ftInt!} */
-    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr},
-    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr},
-    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr},
-    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr},
-    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr},
-    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr},
-    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr},
-    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr},    /* for now. may need to crop */
-    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr},  /* for now ignore. may need to crop */
-    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr},    /* for now */
-    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr},
-    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr},  /* for now */
-    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr},    /* for now */
-    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr},    /* for now */
-    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr},
-    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr},
-    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr},
-    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr},
-    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr},
-    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr},
-#if X_ACCELERATOR_VARY
-    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr},
-#endif
-#if USE_ADAPTATION
-    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr},
-#endif
-    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr},
-    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc},
-    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr},
-    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr},
-    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr},
-    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr},
-    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt},
-    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr},
-    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr},    /* ':' will not allow matches */
-    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid}, /* ':' will not allow matches */
-    {nullptr, Http::HdrType::ENUM_END, Http::HdrFieldType::ftInvalid}    /* end of table */
-};
-
-const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable(Http::HdrType::BAD_HDR, HeaderTable);
+/* glue to code generated by gperf */
+#include "http/RegisteredHeadersHash.cci"
+
+HeaderTableRecord::HeaderTableRecord() :
+                name(""), id(HdrType::BAD_HDR),type(HdrFieldType::ftInvalid),
+                list(false), request(false), reply(false), hopbyhop(false)
+{}
+
+HeaderTableRecord::HeaderTableRecord(const char *n) :
+                name(n), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),
+                list(false), request(false), reply(false), hopbyhop(false)
+{}
+
+HeaderTableRecord::HeaderTableRecord(const char *n, HdrType theId, HdrFieldType theType, int theKind) :
+                name(n), id(theId), type(theType),
+                list(theKind & HdrKind::ListHeader), request(theKind & HdrKind::RequestHeader),
+                reply(theKind & HdrKind::ReplyHeader), hopbyhop(theKind & HdrKind::HopByHopHeader),
+				denied304(theKind & HdrKind::Denied304Header)
+{}
+
+
+const HeaderTableRecord&
+HeaderLookupTable_t::lookup (const char *buf, const std::size_t len) const {
+    const HeaderTableRecord *r = HttpHeaderHashTable::lookup(buf, len);
+    if (!r)
+        return BadHdr;
+    return *r;
+}
+const HeaderTableRecord HeaderLookupTable_t::BadHdr {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None};
+
+HeaderLookupTable_t::HeaderLookupTable_t()
+{
+    initCache();
+}
+
+void
+HeaderLookupTable_t::initCache()
+{
+    idCache.resize(TOTAL_KEYWORDS);
+    for (int j = MIN_HASH_VALUE; j <= MAX_HASH_VALUE; ++j) { //MAX_HASH_VALUE is exported by gperf
+        if (HttpHeaderDefinitionsTable[j].name[0] != '\0') { //some slots are empty
+            idCache[static_cast<int>(HttpHeaderDefinitionsTable[j].id)] =
+                & HttpHeaderDefinitionsTable[j];
+        }
+    }
+    //check after the fact. The cache array must be full
+    for (auto e : idCache) {
+        assert(e->name);
+    }
+}
+const HeaderLookupTable_t HeaderLookupTable;
 
 }; /* namespace Http */
 
@@ -125,7 +72,7 @@
 operator<< (std::ostream &s, Http::HdrType id)
 {
     if (Http::any_HdrType_enum_value(id))
-        s << Http::HeaderTable[id].name << '[' << static_cast<int>(id) << ']';
+        s << Http::HeaderLookupTable.lookup(id).name << '[' << static_cast<int>(id) << ']';
     else
         s << "Invalid-Header[" << static_cast<int>(id) << ']';
     return s;

=== modified file 'src/http/RegisteredHeaders.h'
--- src/http/RegisteredHeaders.h	2015-08-06 02:50:14 +0000
+++ src/http/RegisteredHeaders.h	2015-08-15 21:29:15 +0000
@@ -17,6 +17,7 @@
 /// recognized or "known" header fields; and the RFC which defines them (or not)
 /// http://www.iana.org/assignments/message-headers/message-headers.xhtml
 enum HdrType {
+    enumBegin_ = 0,                 // service value for WholeEnum iteration
     ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
     ACCEPT_CHARSET,                 /**< RFC 7231 */
     ACCEPT_ENCODING,                /**< RFC 7231 */
@@ -105,12 +106,8 @@
     X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
     X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
     X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
-#if X_ACCELERATOR_VARY
     HDR_X_ACCELERATOR_VARY,             /**< obsolete Squid custom header. */
-#endif
-#if USE_ADAPTATION
     X_NEXT_SERVICES,                /**< Squid custom ICAP header */
-#endif
     SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
     SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
     FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
@@ -120,8 +117,8 @@
     FTP_STATUS,                     /**< Internal header for FTP reply status */
     FTP_REASON,                     /**< Internal header for FTP reply reason */
     OTHER,                          /**< internal tag value for "unknown" headers */
-    BAD_HDR,                        /**< Invalid header. Must be after ENUM_END */
-    ENUM_END                        /**< internal tag for end-of-headers */
+    BAD_HDR,                        /**< Invalid header */
+    enumEnd_                        // internal tag for end-of-headers
 };
 
 /** possible types for http header fields */
@@ -139,31 +136,72 @@
     ftDate_1123_or_ETag
 };
 
+enum HdrKind {
+    None = 0,
+    ListHeader = 1,
+    RequestHeader = 1 << 1,
+    ReplyHeader = 1 << 2,
+    HopByHopHeader = 1 << 3,
+	Denied304Header = 1 << 4, //see comment in HttpReply.cc for meaning
+    GeneralHeader = RequestHeader | ReplyHeader,
+    EntityHeader = RequestHeader | ReplyHeader
+};
+
+
 /* POD for HeaderTable */
 class HeaderTableRecord {
 public:
+    HeaderTableRecord();
+    HeaderTableRecord(const char *n);
+    HeaderTableRecord(const char *, Http::HdrType, Http::HdrFieldType, int /* HdrKind */);
     const char *name;
     Http::HdrType id;
     Http::HdrFieldType type;
+    // flags set by constructor from HdrKind parameter
+    bool list;       //header with field values defined as #(values) in HTTP/1.1
+    bool request;    //header is a request header
+    bool reply;      //header is a reply header
+    bool hopbyhop;   //header is hop by hop
+    bool denied304;  //header is not to be updated on receiving a 304 in cache revalidation (see HttpReply.cc)
 };
 
-/// header ID->namelookup table.
-extern const HeaderTableRecord HeaderTable[];
-
-/** LookupTable for HTTP Header name -> Http::HdrType lookup.
+/** Class for looking up registered header types' definitions
  *
- * use as HeaderLookupTable.lookup(header-as-sbuf).
- * It will return Http::HdrType::HDR_BAD if the header is unknown/not registered,
- * including the case of Http::HdrType::OTHER, which will have to be handled
- * by the caller.
+ * Look up HeaderTableRecord's by name or registered header ID.
+ * Actual records are defined in file RegisteredHeadersHash.gperf, which is
+ * compiled using gperf to RegisteredHeadersHash.cci which is then included
+ * in RegisteredHeaders.cc.
  */
-extern const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable;
+class HeaderLookupTable_t {
+public:
+    HeaderLookupTable_t();
+    /// look record type up by name (C-string and length)
+    const HeaderTableRecord& lookup (const char *buf, const std::size_t len) const;
+    /// look record type up by name (std::string)
+    const HeaderTableRecord& lookup (const std::string &key) const {
+        return lookup(key.data(), key.length());
+    }
+    /// look record type up by name (SBuf)
+    const HeaderTableRecord& lookup (const SBuf &key) const {
+        return lookup(key.rawContent(), key.length());
+    }
+    ///look record type up by header ID
+    const HeaderTableRecord& lookup (Http::HdrType id) const {
+        return *(idCache[static_cast<int>(id)]);
+    }
+
+private:
+    void initCache();
+    std::vector<const HeaderTableRecord *> idCache;
+    static const HeaderTableRecord BadHdr; // used to signal "not found" from lookups
+};
+extern const HeaderLookupTable_t HeaderLookupTable;
 
 /// match any known header type, including OTHER and BAD
 inline bool
 any_HdrType_enum_value (const Http::HdrType id)
 {
-    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END);
+    return (id >= Http::HdrType::enumBegin_ && id < Http::HdrType::enumEnd_);
 }
 
 /// match any valid header type, including OTHER but not BAD

=== added file 'src/http/RegisteredHeadersHash.cci'
--- src/http/RegisteredHeadersHash.cci	1970-01-01 00:00:00 +0000
+++ src/http/RegisteredHeadersHash.cci	2015-08-15 21:29:15 +0000
@@ -0,0 +1,372 @@
+/* C++ code produced by gperf version 3.0.3 */
+/* Command-line: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/gperf --output-file=RegisteredHeadersHash.cci -m 100000 RegisteredHeadersHash.gperf  */
+/* Computed positions: -k'1,9,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "RegisteredHeadersHash.gperf"
+
+#line 15 "RegisteredHeadersHash.gperf"
+struct HeaderTableRecord;
+enum
+  {
+    TOTAL_KEYWORDS = 88,
+    MIN_WORD_LENGTH = 2,
+    MAX_WORD_LENGTH = 25,
+    MIN_HASH_VALUE = 7,
+    MAX_HASH_VALUE = 113
+  };
+
+/* maximum key range = 107, duplicates = 0 */
+
+#ifndef GPERF_DOWNCASE
+#define GPERF_DOWNCASE 1
+static unsigned char gperf_downcase[256] =
+  {
+      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
+     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
+     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
+     60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,
+    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
+    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
+    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
+    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
+    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
+    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
+    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
+    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
+    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
+    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
+    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
+    255
+  };
+#endif
+
+#ifndef GPERF_CASE_MEMCMP
+#define GPERF_CASE_MEMCMP 1
+static int
+gperf_case_memcmp (register const char *s1, register const char *s2, register unsigned int n)
+{
+  for (; n > 0;)
+    {
+      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];
+      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];
+      if (c1 == c2)
+        {
+          n--;
+          continue;
+        }
+      return (int)c1 - (int)c2;
+    }
+  return 0;
+}
+#endif
+
+class HttpHeaderHashTable
+{
+private:
+  static inline unsigned int HttpHeaderHash (const char *str, unsigned int len);
+public:
+  static const struct HeaderTableRecord *lookup (const char *str, unsigned int len);
+};
+
+inline unsigned int
+HttpHeaderHashTable::HttpHeaderHash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114,  14, 114, 114,   5, 114, 114, 114, 114,
+       64, 114, 114,  14, 114, 114, 114, 114,   1, 114,
+      114, 114, 114, 114, 114,   4,   5,  15,  29,   1,
+       17,  60,  35,  19, 114,  51,  15,  42,   8,  50,
+       11, 114,   1,  19,   7,  28,   4,  41,  33,  15,
+      114, 114, 114, 114, 114, 114, 114,   4,   5,  15,
+       29,   1,  17,  60,  35,  19, 114,  51,  15,  42,
+        8,  50,  11, 114,   1,  19,   7,  28,   4,  41,
+       33,  15, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114
+    };
+  register unsigned int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[8]];
+      /*FALLTHROUGH*/
+      case 8:
+      case 7:
+      case 6:
+      case 5:
+      case 4:
+      case 3:
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+static const unsigned char lengthtable[] =
+  {
+     0,  0,  0,  0,  0,  0,  0,  5,  3,  7,  2,  3,  0,  5,
+     6,  7, 13,  6,  9,  9, 11,  6,  6,  4, 15,  7,  6,  7,
+     8, 13, 13,  8,  6, 12,  4, 12,  7, 18, 18, 10, 13,  7,
+    13, 16,  0, 19,  4, 16, 13, 10,  5, 13, 17, 10, 16, 20,
+    17,  6, 19, 16, 14, 11,  8,  4,  6,  4, 10, 18, 15,  3,
+     4, 19, 13, 14, 10, 14, 13, 12, 15, 14, 15, 12, 11, 10,
+     9, 10,  7, 15, 19, 17,  0, 13, 16, 25,  0,  0,  0,  0,
+     0,  0, 21,  0,  0,  0,  0,  0,  0,  0,  7, 13,  0,  0,
+     0, 11
+  };
+
+static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
+  {
+    {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 69 "RegisteredHeadersHash.gperf"
+    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange, HdrKind::RequestHeader},
+#line 22 "RegisteredHeadersHash.gperf"
+    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader},
+#line 70 "RegisteredHeadersHash.gperf"
+    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 76 "RegisteredHeadersHash.gperf"
+    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 85 "RegisteredHeadersHash.gperf"
+    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+    {""},
+#line 77 "RegisteredHeadersHash.gperf"
+    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 42 "RegisteredHeadersHash.gperf"
+    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 78 "RegisteredHeadersHash.gperf"
+    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 71 "RegisteredHeadersHash.gperf"
+    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None},
+#line 17 "RegisteredHeadersHash.gperf"
+    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 80 "RegisteredHeadersHash.gperf"
+    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 60 "RegisteredHeadersHash.gperf"
+    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 72 "RegisteredHeadersHash.gperf"
+    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 62 "RegisteredHeadersHash.gperf"
+    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 38 "RegisteredHeadersHash.gperf"
+    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 84 "RegisteredHeadersHash.gperf"
+    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 20 "RegisteredHeadersHash.gperf"
+    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 100 "RegisteredHeadersHash.gperf"
+    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 73 "RegisteredHeadersHash.gperf"
+    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 43 "RegisteredHeadersHash.gperf"
+    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader},
+#line 51 "RegisteredHeadersHash.gperf"
+    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None},
+#line 26 "RegisteredHeadersHash.gperf"
+    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 36 "RegisteredHeadersHash.gperf"
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 57 "RegisteredHeadersHash.gperf"
+    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 68 "RegisteredHeadersHash.gperf"
+    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 29 "RegisteredHeadersHash.gperf"
+    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 40 "RegisteredHeadersHash.gperf"
+    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader},
+#line 37 "RegisteredHeadersHash.gperf"
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 82 "RegisteredHeadersHash.gperf"
+    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 63 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header},
+#line 24 "RegisteredHeadersHash.gperf"
+    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader},
+#line 104 "RegisteredHeadersHash.gperf"
+    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None},
+#line 21 "RegisteredHeadersHash.gperf"
+    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 88 "RegisteredHeadersHash.gperf"
+    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 67 "RegisteredHeadersHash.gperf"
+    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+#line 66 "RegisteredHeadersHash.gperf"
+    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
+    {""},
+#line 65 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 46 "RegisteredHeadersHash.gperf"
+    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 32 "RegisteredHeadersHash.gperf"
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 92 "RegisteredHeadersHash.gperf"
+    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 74 "RegisteredHeadersHash.gperf"
+    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 23 "RegisteredHeadersHash.gperf"
+    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 27 "RegisteredHeadersHash.gperf"
+    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 96 "RegisteredHeadersHash.gperf"
+    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 83 "RegisteredHeadersHash.gperf"
+    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 34 "RegisteredHeadersHash.gperf"
+    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 95 "RegisteredHeadersHash.gperf"
+    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 49 "RegisteredHeadersHash.gperf"
+    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::RequestHeader},
+#line 103 "RegisteredHeadersHash.gperf"
+    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 52 "RegisteredHeadersHash.gperf"
+    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None},
+#line 87 "RegisteredHeadersHash.gperf"
+    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 18 "RegisteredHeadersHash.gperf"
+    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 98 "RegisteredHeadersHash.gperf"
+    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 48 "RegisteredHeadersHash.gperf"
+    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 45 "RegisteredHeadersHash.gperf"
+    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 61 "RegisteredHeadersHash.gperf"
+    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 41 "RegisteredHeadersHash.gperf"
+    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader},
+#line 53 "RegisteredHeadersHash.gperf"
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 93 "RegisteredHeadersHash.gperf"
+    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 94 "RegisteredHeadersHash.gperf"
+    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 54 "RegisteredHeadersHash.gperf"
+    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 56 "RegisteredHeadersHash.gperf"
+    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader},
+#line 30 "RegisteredHeadersHash.gperf"
+    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 91 "RegisteredHeadersHash.gperf"
+    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 89 "RegisteredHeadersHash.gperf"
+    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 101 "RegisteredHeadersHash.gperf"
+    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt, HdrKind::None},
+#line 47 "RegisteredHeadersHash.gperf"
+    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader},
+#line 55 "RegisteredHeadersHash.gperf"
+    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 58 "RegisteredHeadersHash.gperf"
+    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64, HdrKind::RequestHeader},
+#line 90 "RegisteredHeadersHash.gperf"
+    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 33 "RegisteredHeadersHash.gperf"
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 97 "RegisteredHeadersHash.gperf"
+    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 59 "RegisteredHeadersHash.gperf"
+    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader},
+#line 35 "RegisteredHeadersHash.gperf"
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 28 "RegisteredHeadersHash.gperf"
+    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 44 "RegisteredHeadersHash.gperf"
+    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 102 "RegisteredHeadersHash.gperf"
+    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 39 "RegisteredHeadersHash.gperf"
+    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 19 "RegisteredHeadersHash.gperf"
+    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader|HdrKind::ReplyHeader},
+#line 25 "RegisteredHeadersHash.gperf"
+    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+#line 79 "RegisteredHeadersHash.gperf"
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {""},
+#line 99 "RegisteredHeadersHash.gperf"
+    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 31 "RegisteredHeadersHash.gperf"
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 64 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+    {""}, {""}, {""}, {""}, {""}, {""},
+#line 81 "RegisteredHeadersHash.gperf"
+    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None},
+    {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 86 "RegisteredHeadersHash.gperf"
+    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 50 "RegisteredHeadersHash.gperf"
+    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+    {""}, {""}, {""},
+#line 75 "RegisteredHeadersHash.gperf"
+    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader}
+  };
+
+const struct HeaderTableRecord *
+HttpHeaderHashTable::lookup (register const char *str, register unsigned int len)
+{
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      unsigned int key = HttpHeaderHash (str, len);
+
+      if (key <= MAX_HASH_VALUE)
+        if (len == lengthtable[key])
+          {
+            register const char *s = HttpHeaderDefinitionsTable[key].name;
+
+            if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_memcmp (str, s, len))
+              return &HttpHeaderDefinitionsTable[key];
+          }
+    }
+  return 0;
+}
+#line 105 "RegisteredHeadersHash.gperf"
+

=== added file 'src/http/RegisteredHeadersHash.gperf'
--- src/http/RegisteredHeadersHash.gperf	1970-01-01 00:00:00 +0000
+++ src/http/RegisteredHeadersHash.gperf	2015-08-15 21:29:15 +0000
@@ -0,0 +1,105 @@
+%{
+%}
+%language=C++
+%define hash-function-name HttpHeaderHash
+%define lookup-function-name lookup
+%define class-name HttpHeaderHashTable
+%define word-array-name HttpHeaderDefinitionsTable
+%compare-lengths
+%compare-strncmp
+%readonly-tables
+%enum
+%global-table
+%ignore-case
+%struct-type 
+struct HeaderTableRecord;
+%%
+Accept, Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Charset, Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Encoding, Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader|HdrKind::ReplyHeader
+Accept-Language, Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Ranges, Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Age, Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader
+Allow, Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Alternate-Protocol, Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader
+Authentication-Info, Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Authorization, Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Cache-Control, Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader
+Connection, Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Content-Base, Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-Disposition, Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None
+Content-Encoding, Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Language, Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Length, Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Location, Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-MD5, Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Range, Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Type, Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Cookie, Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None
+Cookie2, Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None
+Date, Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader
+ETag, Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader
+Expect, Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Expires, Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader
+Forwarded, Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+From, Http::HdrType::FROM, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Host, Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+HTTP2-Settings, Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader
+If-Match, Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+If-Modified-Since, Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::RequestHeader
+If-None-Match, Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+If-Range, Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None
+If-Unmodified-Since, Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None
+Keep-Alive, Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Key, Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Last-Modified, Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader|HdrKind::Denied304Header
+Link, Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
+Location, Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Max-Forwards, Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64, HdrKind::RequestHeader
+Mime-Version, Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader
+Negotiate, Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None
+Origin, Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Pragma, Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+Proxy-Authenticate, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header
+Proxy-Authentication-Info, Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Proxy-Authorization, Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Proxy-Connection, Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
+Proxy-support, Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Public, Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Range, Http::HdrType::RANGE, Http::HdrFieldType::ftPRange, HdrKind::RequestHeader
+Referer, Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Request-Range, Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None
+Retry-After, Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Server, Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Set-Cookie, Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Set-Cookie2, Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+TE, Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Title, Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None
+Trailer, Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Transfer-Encoding, Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Translate, Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None
+Unless-Modified-Since, Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None
+Upgrade, Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+User-Agent, Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Vary, Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Via, Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+Warning, Http::HdrType::WARNING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+WWW-Authenticate, Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+X-Cache, Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Cache-Lookup, Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Forwarded-For, Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+X-Request-URI, Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Squid-Error, Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Accelerator-Vary, Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+X-Next-Services, Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Surrogate-Capability, Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Surrogate-Control, Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc, HdrKind::ListHeader|HdrKind::ReplyHeader
+Front-End-Https, Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Command, Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Arguments, Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Pre, Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Status, Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt, HdrKind::None
+FTP-Reason, Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr, HdrKind::None
+Other:, Http::HdrType::OTHER, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+*INVALID*:, Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None
+%%

=== added file 'src/tests/testEnumIterator.cc'
--- src/tests/testEnumIterator.cc	1970-01-01 00:00:00 +0000
+++ src/tests/testEnumIterator.cc	2015-08-13 13:55:42 +0000
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "testEnumIterator.h"
+#include "unitTestMain.h"
+
+#include <cppunit/TestAssert.h>
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testEnumIterator );
+
+enum class TestEnum {
+    enumBegin_ = 0,
+    zero = 0,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+enum class UnsignedTestEnum : unsigned char {
+    enumBegin_ = 0,
+    zero = 0,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+void
+testEnumIterator::testForwardIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().end());
+}
+
+void
+testEnumIterator::testReverseIter()
+{
+    WholeEnum<TestEnum>::reverse_iterator i = WholeEnum<TestEnum>().rbegin();
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().rend());
+}
+
+void
+testEnumIterator::testBidirectionalIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    --i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+}
+
+void
+testEnumIterator::testRangeFor()
+{
+    int j = 0;
+    for (auto e : WholeEnum<TestEnum>()) {
+        (void)e;
+        ++j;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+
+void
+testEnumIterator::testRangeForRange()
+{
+    int j = 0;
+    // free function-based range
+    for (auto e : EnumRange(TestEnum::two, TestEnum::four)) {
+        (void)e;
+        ++j;
+    }
+    CPPUNIT_ASSERT_EQUAL(2,j);
+}
+
+void
+testEnumIterator::testUnsignedEnum()
+{
+    int j = 0;
+    for (auto e = WholeEnum<TestEnum>().rbegin(); e != WholeEnum<TestEnum>().rend(); ++e ) {
+        (void)e;
+        ++j;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+

=== added file 'src/tests/testEnumIterator.h'
--- src/tests/testEnumIterator.h	1970-01-01 00:00:00 +0000
+++ src/tests/testEnumIterator.h	2015-08-13 13:55:42 +0000
@@ -0,0 +1,36 @@
+#ifndef SQUID_TESTENUMITERATOR_H_
+#define SQUID_TESTENUMITERATOR_H_
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "base/EnumIterator.h"
+
+#include <cppunit/extensions/HelperMacros.h>
+
+class testEnumIterator : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testEnumIterator );
+    CPPUNIT_TEST( testForwardIter );
+    CPPUNIT_TEST( testReverseIter );
+    CPPUNIT_TEST( testBidirectionalIter );
+    CPPUNIT_TEST( testRangeFor );
+    CPPUNIT_TEST( testRangeForRange );
+    CPPUNIT_TEST( testUnsignedEnum );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    void testForwardIter();
+    void testReverseIter();
+    void testBidirectionalIter();
+    void testRangeFor();
+    void testRangeForRange();
+    void testUnsignedEnum();
+};
+
+#endif /* SQUID_TESTENUMITERATOR_H_ */
+

# Begin bundle
IyBCYXphYXIgcmV2aXNpb24gYnVuZGxlIHY0CiMKQlpoOTFBWSZTWf9ZFJoA1Rn/gH125UB/////
/////7////9gwz5496728B6DNdm4D328984BJud1V9Ka8vbYHhkr3Ax132cUTwPdY+FVSgWzVK7N
tuwa0CzGnz7q+2uxoVoHXVA+mrrvnB4158noiAfezvd1VD3rV7vV7sd2+rffOB8PA99wD7O9b3mo
21Jzdw2bmJ8Y9A6e92vtuZs60add9mFGPlwd23vRoFXvBxzs1e1b3N9AeIPT3Xvvg+vvW6ma29tO
h7qwfex0Ne4Pb1eoa+nW221a+S7ao333g91QNayPTVGtDrAvb1XFC+Gap61Uj1gfTKQgUAF3e4N7
XT3YUoBSt73g8r1TRVBoaS1gmn3NToDTQCu+60GXznrdvbAJQSNG0zX3so8h6YAFEAKKANa1M1B0
0UDttPuxyBcH1QevPZgNKUPbtJCg4djoByAunpUVu9UA8gFxbuYyK93uAAesevJs70oejtvrHQfb
SKDW59AC2O0KKeslGg1s2slKoWzTAJbBsZVtpBZNG2hNAaoa2wJsQazANQyqswWz6++eOqvkia+4
3sfL6TyqNG1jYwKKK0NVKystosdAEkgAEBIIaJkGggjRPVPJianonqeo09CPUyaaZMjQNBphKACQ
hISnpU80KZkPU9Q0JkyDAQwCMgMBGJggBhNIQFAqeEpsZU9T0mR6hso0AyDT1ANBoAAAAASaSQgQ
jQI1MaKn5NkKbJNNNTzIppmp6RoNNNqD1AA9GoaeoESiAgEyZAAE000AKeECaaAZT1T2RkjETaaN
TUyeptQKkhAgBENJgTBCYmTKeptFP01E/SjT1H6pkyBppoAAA3gDrgvaKEFQ7YSIi5mIGaCK8rAB
U7QiiVgKAwbDAIkkgFGSVIBWBWIKJYIK2hUrPkOPYHT+4/p7J9e+2fvv2JgBqEvFwphtrc/YzZFD
fdKdSPH8O3yMwdV+3u1mpD8Fk+bih+C92OBg38ebA+w+sLiqo/1VlA/Ofo/J+r9r7Ui8vg9tY+pt
eMYGKeJi7qqnNhl29x61syjYzFpsmFxXWnpru2aHKbDqhGnQxKzQavGlI6oTGOCPagQPBAgf0+Xp
VIR95bbV/n/Swvhw8vO/HBttp/zt/50Xafuz1LCcc+FCtfbd2V4Ijmfo2kf/sXMj7i1n2sV62jPE
dVhGLRZkmuUBuI6YH+SA89bbz1+oeG83pg/6v1KKCwN/p8aBJ2NvJ5bo7Ja+/dLjXyNM4zBBfJrM
5pRUe79u2jSKsWO0pUWLulRRegWnFKKLvs3EURRMpf3ZvmmIiiKK7auCKZSy2xRERtt8PDWja0UU
U22HMFFFFOLTa2LERTGsUXe0U2C0UREdms52nOlFRRrRFNWiinB7uetG9LFRlt9qVV4tEujuwtEu
wpDLQ6Z4NZ/qW+6lIxjFP0LagqzrvYef46TwQ9X+Pl20InYtPFN3vTym1VeGK868tYpoZUhQt8P6
qca2yAtTw56yHxieZlQ7pA39Nncv9uef5qHun0Pz4W01+4p7spcx9/Q/2V/8lP7GL+5e1F5dPhwy
53U1rnRtDkt3XOy5T9xdzJ4D9Yyr7r5d89dfpOu48qqbI69rCXdt/UYW89A4EMpzqlXw0mJ/wym8
f+D1UUvrq39A+UV9A3GCOEPc/bz6ctrbPmuaeHMu8LH4FaCu1OzrY2xKvDLkVJMRzN5Ru5wnbtsd
ZW704rd4zlbp7LO2Z8vAXu9zFYbR3fyFL5P7qDrwrCW7AqO1GFdfcA95Q4e8a5+AkVZFYJKaZEpN
P8tt/bBqnN8nirNIioUvGdzAal+2WdQyZjn0qIn5xp+7xfQ7LXETKM+LtJfHZ+hYM11FLofyrVdV
I0K6YtTYI0t0AEw/H1uCIzyFYFtHKbCI5DOE7aiau4ZnbRvrRWszY/gPQFkA5pwk2+kUUUVRRGKI
iqIigqLERFBFFFRRRRVFUVRfG0UWKoKsVRURRFRViqKKKiKIjqlYqrFFUUqVURVFiLFiKlaxVBVF
FFFUU35QOurAqF34OXpaSZ4rhfCOTvUS+peXCuOmtUQkQwf/WlE75pm1W7KXrzU6d+M2G+R1pMS5
TEWLLKwJjIaYddB7+xo3O4+jW+jxcBtKmwurVPYKyi/ty5Se5I/RKX7+PykLccYUcHZf0R7mPpiO
2BbccUV1kP4nhL7l5CzisrOwsILfw9HLvJGBVBDMFJT4L5x/bektMJAeASC3UTc68XfUv4bzavMn
MO93kHP7rd9fKH+VM2nJwmCNPMZfn3r+998z0Khbkdb5O8/5P3R97v9P/D4emq+7Mfvb6drkp/3f
0xLBJj5OuBwa+Rqa7tbaRYPY+Cz6vl2MT4xEYsUVPL81wO+2OUooiKW1UROtjSiiqpaUT5bREVBR
EREVVNWiIiIiIi6alpRYiMUREURE7rRFNmixHrS7WiIqKb0oiIiONa0U2tVT6LRE2tiLtS5bjRUt
9uaynFKltET4bWIicrREREVVVE+Tx+Dp6fzdR+fPuOnH99555vE8nQ+GJddv/UhHH6z5dfZIwNb9
aN/n7z5RHMRcS+DqfYeOgceTv1tkl4/VkJnEJH83Ba1Nm+jAhyGZkMyHJVcVUJna1FQXWGg0IsFW
LNKMbWi2UhDr+fynf6RT7k8E+9xTNry/up4J9mqeHy+MPujXquval6Yr6wl3NU/q5xsMN+ms1spl
3uxthy95I3FXljM9RFxdTy+W0UNVOtPE8jNqin5UTDTzk1WuC3buKzsCkKKrqQcaFalbm1k+UXW8
7VpS1YQ/i+GueP536k47e4fOGfOKey+7t06OJ788OQiivhabX19S96fhd/fttt1THOM2TyeSzs4y
Dxv4O+iH4yP0jTnfDMfZXG9um8nO6j0+MXRs1Gk8Ox+JM8+2fanqTtv72ZrtnRcttPzJxqnsTNqL
GWOczPWA5Nj6u8MQMs972B7H8Xn7uIHbFGN/4XHNdUPT6aae1Lbw3PHanN08W+hqHCKfMm8T+kOr
WmpUE7dBv1AoQ1QpE2RrWnXSlke1DECLIbpuwxkhUCbpNkhdUFPmYHCEkzKQKhDTKgshNkNkJJkU
ZFkWyFsQrBcIKtIgpsihbAM2oHK2bskxmzIVk2Sc0Kk1aVimyG3Fmt6BWE0kWFZPWwUMYQ52wE+l
mlBzNYatJfcodGKQIOYTfl+tyQIXHp73efH5c+OvXtmtt9/MUPMqAAuUsPJ48LkCbOyBXavMHmj6
TN0uLxlJzODWTvKWR6cZxhbSRPWs6y6xjVW8YwVUwamZspTCyG6c2xRNoERbuIvNWTdgFQm2WLJs
3ewqRQm+mXMZYFlbFtpnFS3d1h9XTFbVdXx9iRb25qVnZnKzHmo2LvbGMRumFSpEjLumiACLBeTA
rFkUiyQV09DndU46HO82jPPGJ3lLuZriDllXkZDpDo60RlrsZLZwQQZ3ha4wyMsa3LguZpYfV5Uu
9xayapVcZ02CXRlnRttZfObXG5eSNuszWWy7mEYPsw6yuW8a0uu7Wbb06ojrGPxMYDkSpexPNZ3i
DirmizxpXisFqCTy+ESuK02+KwqUsLMFbVbj4G0sZI3Ma5jHqmqGhdj9LQIiRFKCJmrzbbfC4gGr
2OkVzRTG4kk4OnNUsL8/jrPdubpZgPK5rVyNvk2W8dt6kdTSvGHjpVsTJB8kU5p0ThkhoCUrTfVV
EMYyCoihgK+xEliQBkUE1xFWQAkAJF/lGSSsBYQhBSChjAkFCACgQWskikikWBBYQFkkmkhlv81g
322gqU4Q66q2LZKA0IojIBCKsIERIgpGCDGIjFIwYIxBQGIjBkCMQhGMEiSDGIRIxBt/TDEgYRUM
OM/9mc2xPQ+x/OBJVe7v7vp934RjH7frP7Gn9aUkUqQdN7p1moTailFzozKSnOi3MyTGTurmvNru
5axeK0PuwttazRdwQ+2zYuRutKqXkiq2LjZJWaNlXLtbbusblWUPM0u7brbNDsRsUw5VYrreO1Zd
u7XWO+xrKu5u47aztm42tru2bmvr6y7M0u1evuKZBhkRjtmwubrLurmNm7GNCtmtuQNrrt62s+Zu
uPqu26uY+7Ea7Y7te7NK25WvsXD3uQ3QI8xKHPHZ8r+rkvPEvCnW62IIONpD/fq9Qe9w9jn5pgey
0kakcg0IFQqQtu/jbz75zmJGxxHoUQCBoJSrkDN7z23AVLVDhq9u+eW8REWaD+ITx0FLyGf7Z8vh
sSdufIReMuALYf/G7nzXz1Zhr5AOeGeCB1Q0XcfR3WvPo7r8yG9BzGD6L3X2Mag+n4Fyn/T8Evt/
8PUeHXxm71YxEJMw1GRVTWmOEeg53l0lRZY9tQWTgd/6UuuG1oF+i/l4Eyfz/a5iyTghv90WQkB0
0YnwqVpk+AquUvO9PigLzoobICFAUhBWMGMFFWRFEFgpIoMYLBQFixEIpFgCMIKoIICJEQWLIKSQ
WQEZARkgpIKSEYiSCsijIwiKySCEIjIoLILIKRYQFWBFJFiqRZBVFgsiDBVFEZIpEVIoCMUAYigM
ZBSCqCqQFUisIEIsgpUDEyBRIJIoobFaBCfB1CKgenGTn9OWtqBT191LK1tnrssr229tlbLMFHzb
a65Ww0PVRzjTrkNuWLhs5qu8RRrEWubL0tTT7LxqYpb6tPWTDXRrVKxCMrTT28K1NlzNreZm5C5K
rEzD1cbEZEa7RUYZBY+EVizejU1VizmZbu5t20LEXFxuGzVlMQbGuPu2rNt5uzFw0E5SuXMS8yrM
ytr7EbMa+LRcNBVyPikEtUVePLo1QZGY+5ZWvoz6QKTc0YufCtHSjJoVVj/D9HJe73fy+DdAi7DC
oIoiEVV50LIHiHp/DfTCHU9TN+VHvweGx1QKsMJkk83CVnl1EH/oEBx248icH+aHjpC8TgVu0mBa
OLNpYOJVB+wOEpIepTkpKSEJkepSUM2TiuujaOcXEwG321PtJSz2V05CSN2vUJA/TdAvfInHrYHr
t5xu1bwKACCHBQ7lGg/3EO9rNinBvVGAylRoAAEkPsI0aErmGDvFGhY0FutWbHMztZsTCx1vvvYa
A3727KJMA4LuuUdrNihwuoZWaNYlqGY3kMYyhRrigItoyswDQQc6V81XXPav077fTUinOlHTpE8R
QRGBV3cjbKBmGe2rZwEFNCQ0hsidLCGQgd8ZrnDNCOIJRnZM2HnsF5m9OT7u08TQFAUR08UbddOl
Bu8JVVEYQ5RyI8pIDFBlWBzVq0dByiCVrKWWUpWW8ZvLXrua5naIKoKoCgoKSEerI0usvOWKQm0w
lGjzzTZotFqsVRsdO1EFTONX1nfAm74V76roRzJHRRNJdc9UN7ruOLUMiXbuWS72LzxGSUdkImQL
gFRmAMJCKyGRu0A8rdFCtYgTxcyEMhGQb4gyusdCrA6KQCD43ZrEqlzwziTmXUz1YFUGHjGYaYlW
g7fVSi7fT25AdnkonjPFsDNvm2Ke/PHODtlSjWmU7p976UEocZcEm8mLfecquFjsu0ewdFFIAIAc
UGO9UKIBJFMPnvuSN8sBIOu+oZIKFcyq+EDsD7IHiSAEnpgbv1ziV53lQ7eHp4yFt8dy64ZDylW7
tizgV8iMEx3xyLlrEqtwD4xRSI/Wzx73O30zx7mH4stYqVMcahkm8j8aFafIGYByXmw+HaSGtPiw
w+WMU3bITRyqxJUHHNC63qnvQrxGJ5r88Bk5zxF8jrMcd9d2lx3ZvBgbo46PUqlNulRkD30+QIzT
5POr061BFSDzzRqm3TIzMN3x3hht3uIXsNO0V97au+3HlmWd6cD1bXEWGarVCts0XSYd64A5uu+h
kopS0KRXTD1VV1qi6TF9MtDjljXUruZVDsoaXRXioTrJrsZ144yzW1AzNHbDMx3fYYQmKx2Xyhue
2ONutQNuumGt9M56ZayNNcmVyQFyw23pU6daNp16ti8+tN25Tu6U7Am252k7ilQ7dhe6iHduqYh+
3GW++OMvQdiCcOdODz1a8FGp+LlC3LOVTe/EQ9in7SHulPQWhIW0YG+GeueqP21FWWWvFseFMJhi
g7ztyBjmPZNPRvahVenPnhm9OuXqZQroTqDfL2j9qFKddsMp32wynfGIdr7tx1+mjixh4DuDrol4
RGyK52FB5ugOH1lQ02Z08Dgrag9rvdWlNjGHD4OFfDrsmZ8WfcgYCY4vdCcXYU41999EJ2rN2znY
K1cRwzGVRl0VFkYpbDuXRTtNTYteKC23GbFPJ4FQcTidP0pxeLC4i2lo1+MHYp43MDwA6WS8Vad0
zzvitrRe9CIfSiEdhxuvEkH71gpfTYEtBaWgMWqSpQSkog6WqcX163j6EkmpqdQHoZqBas2eJYCh
gcgHNCzZZO5RnGAI8HBvAwDjSko2Kc4NYemXMTEqaDwQ8Uvuud0/TsNl1nMZdVnmMsCTsg12IKCS
ta8wlJSSJPvEJSU6mpDpykpHfkhKSkTLb3aKOi2lp13NBxqSkZOpDt+qSkasWw6u0tGnuXoKSkdI
U4cbO3jA8Cjxl8ttG8jhF0vhjGdognAc8RwGOumkJSUzrEMsgDvyWjxIGs4DQvE4lxIbSUlJ3U8L
BpSwdIa0gw5SW8pd8OpsPLSaPFkITHVXDu3RSUYlaZqDwR67VrTxS12xKGQyyEcMktBGCiVa7Fmd
IGisQy3GALNBgMtgMvlGgFR4DtDZ2BwYcGPqwNjRsrhG7Ah31fFgIhkqy9thYHZkU21PG1iSFrrw
ROBMWvSK19ueWFmwmJ3DwspYxSLUBEJAy6sBgxKKZTSFdvSUw66rUCowSi840pCdv1fH8GLDCDAU
HCGHTqAkGL2xiBDKWmDObBhZUHg9Rg8GenuxAIKPTg6PuQHaYlJTv4shHpzpUgGNHTEoK8gOlKXA
mYh1tLBrUsFz1SUEFogcEGI3wpHebVKqlU5e6fWvgwsWe6eVdWf8LvRS6vhTScT2mFH1qfMm3nn4
tjkiKR98H63SGUsuPY4ts3kt7pPaQxszsLdakI5WwLF0KPMp/+OnQ/tkx2vkrftS37MGDzdabguj
+o9ASALVNbgrndFli5XEytHWFmWrTl+B+SFhZ+Wu9xuIBgP19fP6zEImC/sZfyftHEVa7lcTdXO6
MnMdx+I/nn4QVFV147/xb8Mz8+Zs9Tt14oVXsF3y006D56ohCKSKiwipICas9xopHLY3lIO1dziY
B2yS8pOKuUmBSGQmYEzCoUKDCAKxigCWxKxUasQwKUQIM5SRC36qKp4UmP2sRkxFP7N3C7du3hjJ
Jx9IQ6Yi3BdWhJPB2nBV87D/fpj/fqfhrlkpsB8n1zQMVumXt/xobSOP+N47O4cSy3u/wr7py8nT
30dG2douAOmX/tC/XXuhCHIOByj4Ahd2EMwH7gz3gY3VCGbbTaBgub9J8vdJrAJ13VJROGZ4NjXa
QAHT1/x6CYfc256yOD1vMeU4i78a/pZUsU+WEJ7I/3haz/yjUL8WC9dIZ7OkkMk8f6/jSBsEfIMB
hG/97+4P6j0vVhLR43LbfAae8Pkvv9hwRLsl+Y005YvUXSi8eOV/U++9wEXQBKh9tB9wdQNVcf3c
BDirkL66OOHIlDPzw4UtVtTeS1CiB4ZI6698C6O9B9JHaKaPXhw6LKcCXqDO39B/4PU8udfX7Xlv
tG+xm8F+j09M08Xlfvd7qj0nzl8hC2SDvXYkU83sftgeYcVPid8ZIKNtJ3nMhAmdbTQz1XrGTAfy
+MPcTEklb+MHHR8Mnqa5rOpuRDqFXuY+yySCaM+X4eghFIXLZ65t+Ggq9rMpnnv6MMZPNU42scF4
+LRRiFRbYynXssf1ShD383xHOXt7sP/DmJM/dxkmbt3oNz6/F91hGEu1smMhJOiMuvvNg1IUwenM
go9eZxj2PH2UPf/Wrn3tT608zvr5+s+dv0fPrPBO73tBmB1DPlnOy+FmRV9iVFZJkoVpzLQxBH99
2GMEbPaCtuQp9Gpxk84VbyHAvgGBlHJAl2S65tKBCDAYEhxrDPfVpzhynyPn7vCpnAMwzDnp/AMc
DbvUO4A666P2orxLTHVfepv5trhtly9PGSwDtFVwuLk/fmynTam6864nwH8oQUYn8AzB3mch3J8U
Jig6kaHw3TM0fyspzsP94D6U/pKuDIeVoMbt+HmO3p5iSS2pBhzlB57wGe0hhTF0S0fEiSKhJrr8
Q4t+nl6CYVZ0MvJmJHFjIQguiMTcgj13YY9DYPVycvgOM7abJ9nmAhEOAuHuNJO4euJB6b8qqfCE
+3nw2B2A36S0cfipXyj7/j+x2gISXHxKM/kPy44qKBQb7+Jzj5PK4PVnvwm7CT7bSSS39gBJJhxg
PcIIm5eP2RkyISHDMorz+4fzZx7H7JlP4c7M+b0Nn1fP/I76UcO/5qSNVD3we5yR8Oqp+XA5Ekeg
xgl+lpheyYHFJOehUL1xGBS7uoG36ejQFmHCVGzNbj7k/z7nJ1U7so6A8eP6Rk3sYPzqEW8719fH
fFg0ctm0ws2aTlrTXbROudVJG2mO2iWC2jG62hUuTPnGixE8kAhuUgn3e+Z8/tUDtO0QVPnnQ7T0
Wo5Y1HVwTWtGgCvJFAWVK1PT+j6PjX00l9P3cQevN/rC/puYqthUp3hYxjbKtuYzjbSq9U4bQ0hd
V5pmYlpnMo16H2liGykgeWvdute1yniNbdLnF+vgv6m+j/C7/ueIekQFEMVQVVJZ3lkCZ0B8MMg4
DPbpPMjPiQr5jz3My4zTc1pdZmpgiqqOVuNbgaxsqoqqCwKhVVIKsd/KDIKsRGLEYKiJBWIiLFEe
a1trKtbF6uYtVUF/KlQZhCH9f0/q9Wfwd1fj6+050oP/R/50o0XX6al+/l+P7649ziUb8T5/uniM
m77pxtwzZ7fUqxmmSNKOzSPXz/lxvrjuv6o+1vLqHM9vHno5kNHy9vBtKj3v2vDLq+euJ+2vhv7s
SlmefRt406dLzxtBzo4hCNXbff/6Ta9eVna6P56ja689VdW2es51E9vG5E8ePN9UpoxjTfKtavtG
yvGWZ4k7BmmoM6RLLqz077T8RJJ8XYPvKcXgXFy8o+tyHax+KdLzPU961aBawLwoHeFXclUNbG1y
mV33saBRtMGrvNzQMhkoqGJnPdNGajKVOM8q5zmBuPjYexRSVOc4Os/CYZTqWJrMzeYMJ9sznJ+u
WfYe0QV5v2bcfDx+TZXJq8OLh8/l2w8+/eefl5PJk6ceXVj5fA3zw3t3mu2eNQTmSIBEQ5qKyK0Q
gwgIMALGRkkhBAslotgCgFQKRQIK0CCEgjCAEYqsIKIyAjIAsiBPKKr+YD7QPPZQEEff99ZJJL57
f4FxewF7bT3qoBF/l/WqNgHiA2JP1nFJS2BS2BS2BS2BS2BS2BS2BS2BS2BS2BS2BS2BS0JS2BS2
BS2BS2BS2BS2BS2BKFFTBgh+QisSIQk/2zGD4O19L7Xjed8Hue18b3PqfE7XwfG+D9b736X0vpfG
/qf4v/bz/d5fL3vc9r2vzvwfrfQ/tfzv6n5H3vyvxfkfzP1PyvzPzv1P6X9b9D9b+1/3f+H/B/U/
sf7v3P4v2P/p/5fwf/x/yf8n+b/7f/L/J/yf/j/+v/T//P/1/7fxf7v+z/d/s/1f7P9n7fp+b6iU
i5GPuI/IRC0iv4xRzsRUqQYQYwRPtgh/n+6j+AwELX7/8+Tq8KJgXDqLj8CwoH3ZjL+twUQCj9ka
DffnYz+MPdXGwn7JvSE3/1/skvMXFdP80sskpgVmMqxgof19e5FXgUaGjsTt3tF+YuNM75EApIAs
UGXI7nHkhU/0BH+H7GGB0wP9k8UGHNuhgyEhml5pLOKDYWFLrkqjKR53TlyExbaOF8py+ye/V0Xf
k3zIoZNbmap9AVkZ9pVkTB1myqRKFAMBBBOXnNc55uWegV3NyhT6DkWCmPGBZ4m54Ylps3WzJNVq
blPXo9PqVYatLJqlJcgGDA4tJSHtkiaJEBfJw5w00+Y9C3P7IluolxcnmF+7/l/3/uW5z48P5+zW
cv+hN/+uPs4cMhZ2GTt9dta093zb+wj/mOoR93t8HVOzN/hhbqz/1FB3+3g59YnNSBHiMGZZrq5q
/bb9PlnI3S6BjWug1Of7+D9z+5/e2tr+9/e3NzvqakqKakuVNSVVNVUlJVUlJVVVNSVVNSVVNucW
9uY4t7c4tzi3tzi3Nzc4N7c4N7c4t6kqqakqqa2MMfy/5Ae/fjeBA9hw6MVycLJ/L3/l+e3JweRU
8iBE8Hg8jJAgQKFChQqQID3vfCE5zrWEIUpSlYQ9u+GO/H0G/z/aebNP/cPPVJoVq4aTEKOk37Pl
ux9jRD4XB+0oP+nypZUKuJftZ+h7/8BRRUfMdPTMD8jsMc4yh4sOm1rzFAmkDCD/QLEqKMdBmjR2
6imiYOgtqH35yKVwTxTQv1ceJwG4QkCklAhYDDJGhd7xijn3/nsT1tX/oa+vM8/Hfnu83pVb60MM
PdibpylB5CjEHReUi02b0GjNr4Xs88Vx/eByym6A0DbH1nv48jvFID8S+bO4DOr0QpVtKEWfSW2H
e0N4unT7PmzfsLYZi5M8H5lllKcndbRLzH06Lmo8J5CUqj9hUWiCsEYoCkRiBBW2AVEQTiNzbWxY
qHokYAv0iXlLA/tgsKpmgQWEQk9EtsRiMYSgk+0Igj7g7TA9T7wI6Alp6CS89ykC5g3ouTe14HqK
HkAQT8wx8g+Ovs9wasRU2Ekkvncnl7+amKXz7D3c7Dk2e5ZZzkRRrUc+bm52cZdjmyzcWkNJSKaG
yKwK0YwpVpSjWK1o00lppXVo0IqGpEyefI5WaQsYGYSxzOdqBqG+ikYEdTeOpvC5yq5DJfRDJBhF
xgQiGSPRDePNkmmEN0qE5pt0LtEF43eWR50u7o4Kmg8BRszOCqJ0djZ2ACNlK7DAQFQlJG9oGDBx
bAKt2LEtcXBqYtl7i4gajoYio9qqFIkJiOBiKUmJaYlEsLFsaYyOA0cAMW5wape4uLeBjKBCFpQq
mgMmpqakJSampqZEymJSQTaWjEICpKYbOAjk3dGoVCiEBZsYbwYrK2N2q21hmgVBpSKbF1pU/cZy
9h06MoXTBdowBgkFxocWco46tmptKz1ll1Nl2JLSiJVQUlCYFSSJNZUFURBUoKoANFGNNNNdJRpR
8tMkfYu73aZDGVkVLRptKStS0y3fZ2tvLkZUh0lMbMravdwVZEtF2UjZ2t29fBarXiEdt2J3dxLi
lfIyd293GVkVkXMzMy8ylKRppN0ZUAUUShREFFAQZRVEQBlAFXait13zMzNu93EMzMzMzd3dzMzM
zM3d3czMzMzGTNXd3Enr+J/DPlPvntNvR4nlTHbqayuhuW5Q1msqsJPxoQWKAskN0nN32pwgoZtr
DZhlpIsJnF3QihiZ09G3Hn3pM+v+BPnrFoRtU/XBsT3VBiJTnA+mFgDD7D0bl224v2lzl97b7+rw
mh8GudhHX6sn3vu6pD7b4oa+bwF7bc0J0xm97g+/K/jQ49PTO+1CNKhBaCtaTTTTo8nTmmEkg6pj
zkSCTfhpdenF+VVQbbqvTsb8CZbYbbDgl9dpXlim2q3EXMgoSnFyHvfltsKEQAp0o5S8+A7b8/Ni
QYxBSvF8ejxW1ZSCSccFvbHgr8s7Trx8FvNLMdPN3ad+MdefnsJ5znWtWcuo8Xa18FH9Vgw0N26e
HG+1yjm2o5upwxEezmtlMMaSmzJWZbjJMtpN9OH28p7GEecjaQ95GhH/rGH5Bn1jOYqfsGTQzIhu
MoinKIZEPzRDQz4REZqMYxGe8MozcZ2E7DPjGfcMwREwZuJzGaGfoGcDMEU6iKbiURSjERiGwziM
+YZyE4Eoim4yjO8Z/QJqIeQZtEEQ6iHuE2E+cSiKUVEZRnkGdwniM9UZsJvGeMQwVERRERnMZwIp
2EU2EU2GIz9AzgZ4CesZgz8Yb+bzbB5c5Ntds/n52vRePr+zc0faZtrR3YwumXlVc44SxRQvclGQ
Ju2jUtuPXVLbEyEasbOrM36clLk/VTAYYlvuQE9vypwGfDgdZmNXScBoOHSUu+K/rAgaTg/vgZCi
/mkjgA+AC9eX+f+3/M3LuPjSbn9Hxezo6iyKS3YlO5hpSwkkEkveA0mo6ckK/SEj6TciqVljOS2V
lAZALJYAiZvfOVz/ukU0P0USQSkQqyRJEm/QPotEfGotghJPh5dPuKotoXEN5Pp8pOApIntk2KRd
6hk+YtdlITCWIfEUZnVSDhLIGwUiklEDNUSXqSCZBkBRVEsIqPCAcSg8KsAg8aBoEuS0hO1JPwSG
EMkZJ9+YcjOJ7QG+mBYCWnU7HT2cTztlZIBUkTc1Kn4L0LaNoH0JX54EYwguA+gLwcEqNw2rUGop
hFgRIxOwG4elKD0g2KNwwT6qggxlkvsRBGcQoHSGxNsQYyKoXTCWTxDVC6YTETKN0mg7PLJJDDdm
v5MxaKAph3ChyNS1uwGgvGjgjnLqjsiMtz1eOquNnpf5HoDhCpDHqIt6KClEdYiZxE1ZEcDnE8e0
TYq7l14BvhegwS8MFQM5EcM9FC443QbZSW7RFm36IdNeseNqnDgFQ5IpGIlkNyTWjVEfh0Wk91MI
ODZosmqO5FoZSRdAXDAkPAyI9Ovt/k3enjvo9faw/8s/0/FU5O/DqlT+NmY/1/uP2qvSO/R2w48O
ZvU9fWcfWBJ8XqcoQZ8p3YYUpdZhfY9Mt0COp4TWVK7e2gs3cLdYgQnXbypulZr36bDpNW5ly2pt
lhdAaIYSBdgXZLs00TJIZisW9cRexuZmT+YpdwZcNC9LqbDRc2QkimJJSva9t1+VntrXetGUFSVx
tBhZchgwF76N/6qhmZlciqZzEXIli0TKUqfUYJEE7iCJeEvC9vJCQrTSykhVTIfBUD9QEnxy/qJP
FYIfTKoqsFQUYsYJVLRET9tp/G6jGH7/37ftmiB0ypthKj/3bEmmqi2QqWs0qz/znaZH2WAep2do
NIHjceCAfL6erf2xIN6+1ft+P/z+H0fDWXk0fLX53r89o3PrT8vxz+rG3Gu9s/qc7RrWaUzZ34t6
2378oA5znOcnOc5zi2hbbbC2ktpbQtpbS2y2hbS2y220LbbYW22y2y2222y2y2wtsLbC2ltktsC2
20LaW2W22wtrnOPFFfRX+bEc68Tnmfpnx4tPv+bjUc4rjGHmMYx1mGN3XlH3SlGkpTfsdKHdgh7p
dPc6JMPqkLoP1+voW57s5V/YGGSMcUq2Mqq/Zmk1Utf3Cy3mWaKfBRUqVcJemfF/gy2fFKeJabiy
OXdW8sq7K5b0OkvaXhZhwBBEuzm22RzN5mLKs0FVEXj8t86SQlQ6M4iGM2QnJNMkOTIVUBd2QUnQ
ZA3QWQN0JpJoEJUhUNCQxgcmQnNA5MIHDMYpArIcolImMJBZFLcMMbAyY0QyRUyRMIIXISpKk4QO
EkOSLJDZFhDkikmOkUgc3E6Isk5ODRmkUIdEUgdNJYoQqLsw6MArIKSdHdknRJpgG+WThkWLJwxT
h3ThANIb6sk2YaSdDfbLtebIOqByZzE3Zt0ukWTdJB1eTIHJIckBQAXhhDbjXHA73WyHOEkqiEXD
n+JvSF3S9m6tX9F/qNwquVuuFwrrg5Ny28w/pSbZYCgj0ltfb7iyE0yT8BpLCKAsgsgKTLZlNjUR
1zOJoxPLOgZsGcoWpmzljKVGJRvNW12NKWWYZ0VNVk1k1XN9OP6ZLP1se/GSjuuo6/m1YBZY4eIe
Il/EjJ2Egsh83slQo4aDPTtLE5JZ0HJqWjwVGeUltp5b+TcpkXQq9S0Ks4TTIQHQA9P8FyOYpK6D
JCf+Jq+/J3LJQsIQxuWbIQb5C5cEWasLdymS+wS67GABVCYBadM29IcB/L0u+cNGciTY5b3Jlpud
Gbt8RhzWFeDmRYxiyIABgSYQMwCAEogHyDV0hXiD7OSiiDcPsalDTioJaCWedLQ3BxjSRjxPRB77
7OjvnSuDv6bogFWIti+LjFCaKiXZU5rbkl0mG/XijYHJlEtCTaSClpJgySZstwK2VGeaBKwIjEES
hanPNCDUP0EF6NyuBIMI0MNLGtkGkv8aqZEphAUYQ9oJ9EZBodAHzgnZdjKd4AaQWfYYgosbCR8P
rhpcG9aGKvqjbrgLPbAoW2hfEEPOZUnEgyTY2AHe8QJSXtWFRFVKBjqnQSujDw4Rp6HJFjxJRKn1
SQEZiDbvVAghBClDc0OHFOIz2awdDfTu+MK7wMoq9fToFfQiDJQGnyaExcowGF86zh2OxD4WIgcQ
ERpK6Odo9IJI6p2cOJPD2xA6nr6FlRj2Ii1rK6ncCXdF0eApEiZYO94FEdDIAZBOgBYJDKJ1wYQT
DTlQ4nwpiRAU7FT0O/Z3wg3TS6Xvwk07OuIMp2N0MjMuQ+LjoUvaIoGYoaDdzaNZE1kTk224LIyk
MqRrwI6QRCc9nQph6PPRJ7PDSNH7NcrwXTschwmjF9JQxLZxsOHEHM8xeUkSukDoAAmYVDMQQG+I
ILVGwU1XYC6ULRzZMC4EE6MPQ51xW00kYPY/dH6iig+jOHpSxTWI9QL7dHUpLETwFqqT4KWAEoHR
yD2IKoUTQ4mXYQMM8dl1CuCW1jR3ofS6AAdm+tRQCLoQj0AX+cH+eK8topY5NhjfY5Wy4KFuTFBi
Rgka0+08MeBr75Lm5Dp44fUsqmxsWOBG2zNwSMmtOJS1haLnDjgoNbc0SWeicj5BFKN9UUYaZvwk
fkH8o9374eqRU5rem5MkXsm0OMmDg5NBo5n7pETPMAY6sNhYOdjjfQXJjYVQftAuIRngQiY6OtoT
fBvqI5eMxA4Gdu12ct9g2wUKTNjitzfBXm/5oX+kTEA9App2ieZHoUN8+gA3xgDVHqQ8qHF5kx7N
87LhPicZqG3rV59nCZ76zm2mHzErsVfpkgA8uHPmJQpmwM6gd0FWkFEtpRAkkhFJIQNTpcUt7k5O
yBNmVxAze9/fxdtAL1ENJnOwCKQlZIVNkmtawGRBAwy4FQLoYxbZkiGEQhES+UjaoHFB1BVCOVd6
085E3ccKmxiiCybMMNdfX7iNsXvXTdv10113UVVK2TkQl3DzxBEOQyiqqD2rMpZynRKlhEt1S4Jq
S2yh8HHgonXjmsnG5S7yuPcalznBbY5c7xlZJrdiyda9WreSM4i8qLFwBOhFqIqsZZ6VZnr0IEGx
6k/sMw/WsKiyt1pZWldf6jheyfyTEDK5axnGgZh1ATRDUvjN5NpvO0dhWdQTAVEzMzJ764AIhyN3
d6PPglAFgoiKYJOESEFBEP4K2aW5LMNkosGyZF5EExGLovgiPdwl0KUjRZFoOIUi1FqyqofhtsqI
Zbi6s7q44i21E3wHJVojQoA0SSaYIuhSNygzW9XDXOSZTTTOeI2zTHhYfTUOTXvXklZoXu3yoZ1m
L70dcEvjSJSUiXbqkuCl5Dh/ERHy93Vyd/f0q5g+IhHf8Zrz3syEdEiL6dRe4Iycn2jNPBMU/XPq
sxH0tLxsjdvbtwkvlUiG+90uJKwt1URL9LBVvHQzd2yk+NB35c/j3+ra18Vwy3aI5RNUKzdGBIn6
p3WALSypYkFS1iBYJYLOTnqReRq5WtcL3Hgq6o7u5Ia2TAUwnJZZfS0Zjm+Jf0qZ1zUmqDeiPMiM
O9x73Bm5ObMCGfMeAaz7bLdrMosmIknhls+UQm0KSadc2maSlRu1apHSu7IeiswboSaLrNXtaQDM
HIzKjK+ICSJEkcMsM8T3GBIOejBJHZN4ihKXXdW6Jr0WTYwQ783yaEEgrSHY8qSiqMwYcQMIjFA8
F4qSQyIqiqFLiAKikG9foN7y+RX3ie/tDNXOo9/lL3vG3m7DP4q/KycOu95LXnor14dd8z1rrvfr
7L666WuHkv095VHS9D9d5nl5nNme686rna+133167nrDrpepplX3WbrHuW65nfe11fXROMrr1Prg
gh532eDbBz3t+1+khw1tVsLl17tL2mDsqQspFqi+aS0ZTtq0iWukZKIxfKOjCQ0hQi9SHNaReSCt
XWzSkqi4YJsxiLBkQ6KExYuGxOCyykJMe6+ySWwyCBoZJMJDIHN1DFoIjRxBhYGqWKkzRAdlV+OH
B5T6oTiXxvUnjI14ahTjMK463zW02iQSlBSUSSKKBFFIJFJblHMvJYFSklUhni7khE7+13aJs8XH
lhJCCW0zl5UlV68mBNFwPEUcOEXHKnh3yIzYjJ0WUqJqcLrpoh3LRlR3VarbzODiYE1seHIcxY9B
CPqIR7hCNjyOMNoO8TLpv0Z6QM+2jlKJSlY21rOGyBLWonRHk9a0RhUTFZb4LSZ6jzLtiRVCRIpt
JYKXcaptLB4peJYI5SsuwrnqCYq22fFS1JzL3DYTFYeay8TVx0ujginmqDLQr297I6HDiGYGavHk
N8G40vYjWghg4TJWoZ24yvEDRNy0/MMSwFFDFToQYZVDuaBmETKSqO4oliJbRC2+5BqNmS1HCxzb
OSlVLYA6YolkM3CaKrjA0TNFZBxNRSZtctsMPOC483Gz3ubD6yzSSxsTYZQdAeQu5UyzgAeSA9Z+
NwLDZOUwSB7OuhD1xi0DUAIHQiABB3s8sV48gRUXZU7SDHgv6TFlvM9FyPD0bVh9XGTBeYiBAdll
5vc4qO5GGG2O3DxjdmwzRLdm3FDI8gGYDFy0Il3sTTTZGTtm3g54QedsnIGGCEhFBJn+d72iEUFx
sEvQiRiiTWAuBGAQQcQN3XO9vExcEti5AT+Dd4eN+x6CTjYemYuRcLZuCdP28GajdYNDGTaNz4AH
dNJmRNlE5enp7NiD5PiQq4yiKoZ7RNDTBvC6UjETJiNKCeuiClSCqgUFbuqmi+6pv8O+8bmHdmgy
7+DZfUeTfJe5ucl7ya0mjmsPLASUvRrnrueWSA/yJejE6HRcNZ8m6BCPumJJKQbZPItuPIDx8jOw
8seW9Sfhiu52XIm7jJIuVKnM4NE0bckDc0dELFomhi5QwMQWiZmBoxXaxxxYpixGMi29ChKWx6mT
9DmUrDyoxXc6ubki/RtEicRHl41nxbl9H8muhimbDyZCTwbsk7JJMIOFrwkljikEB/F7PRIx74o6
5JXJ7TmO1zzY0bHBW9vwzfRln6s+1JPrChDrc6JlTRycX5c/k0TqYHEDk2OsEd+Cp4QukD2h513C
BBqIYji87VHzi2oWAFoniI7nEMkdYOTyJHVDgOshgGHmQLdZtz0lOZpEyEbrL78N1LQGyCsijyYk
TyHe84UQaBpGkdAkg51tC0LDYLR2T4Y0hr1EKeOFHZzDHZON5NtGg66OOkCENx7ZmusziusOYjFj
xZhhhpcTjW17znLwe1WKNnKzHXXnLzDFLW6aYbiycCHZHHOPxBkzVFi6bmajtwYvXKtVOVjFFbhw
uOTjA5CcJ2WzLtVJSqlqpgdair1nLk40mftJNU23ikTo/gkqh6G+r6IvvD2JH609J6tNKi0rLKks
Gxkc537A+SucjDJgoEU9UT1BYnaOFcvgQhDsZjJmd985XN3f7Ih9B4fzrAH6xs2ibSSY2DAnHHcv
7b9S9Rq1cpbBqnRVh+Dw/WTiZNg/KxOBYIsDBOkACYCjdMGnC2USTTWyDehQgTEzhIuMJlXkIy7F
n8NjhdEqDoCJqCfTEQhA4k42PQklMZE9FR4OGvAiYKq308VMh6VHlKGntVJ7EfO1l2FdYvj0v5qE
oi38ANETBCIhy6AlYqpiJKbSDa2CBkAIusmCghkUQETiT89YkPpm1gi1EEkkBURcchOEptWbSt/B
aS9V20IuKUy+GLp1qlHEZNF4u3uyvQ6ObnTJkpq5c3N7kjN14jG+0dSqwrpawRLsa+r7gJRTPQAR
CYq0SgImTNM29pFr5SQZRKb9VmZhAcN9pJqXIomOBymkqOVWO5wicRk3B34zBLIczSQLZASqA/r4
KM0H0MeGHgpKCeVvyUGQK43WsMnhtvhsVhY7IRMDcgGpy4qwruRrIrEiyZ8RzxQk5ZEuRBB6LpID
ktcRGqkSDB1fHD2F+Dha+4RHODMeH3LMT3DEvFTyAHpcT4vlDEbs9nPHRi0XqLk7KBx48btTsn31
RRaDoD0Se0hsmxFaMOswi9Hjyg0NOUk1uxJuUWre3Kcbqo0rsDdkzt4sjZtckdHi3BPdqmmDRvdz
2gmHD67u3pNSQMxPwaEqAiIjJJDIoOCealdrkqsogjycrNzKhOAtXc8O3KfXBIrSSGxc/iudtI4K
DOScIw948Vx/mb847nIfMiPd2Ofoi4QR2H7yh4bJsuEUiiwBijQTk9fLNlXoAhkjaAb7s51oYUwh
DioacGBvpoWO/ysyQMXiezRw8PGBY9Yscbjwgh6HeAjzve4PRbULTWYXAItUdvfpvJSblERw6KBh
K0ssIE4qfJMLgJCTDyT0Cs39JENEzy4ITWnIbkbm0NmgZfwTXBAmZJm31LK7HBnL1mzMw9nvarw9
UgVS7RQTn0IHFokQ3BF4jykh3YwdaLGoKlTEjyN4qSHkkEyBBPwQHixqLy/RwVUAc0di47aC2Yfs
NLma2KNmAw4cSHnGN98J7ZYGNEsjWyWQpJZKL4eEK3c2ACFyceoxNDvFrwBbdBZ15sjc73iIvVTS
qwbl5vUxS9ZuujDw8VceCA5DpjiZ4fUfQvIPy1PqV5uCqQIWy+XySnxadTo6ODr8E45JG+5gorlb
D9qGHkybMeoA2sEMHeC5ckzRMRWYeCBDqJAwYNxuJJPfZCnY45hYp7KPRZsm0eQYIBrW1CNPZCzo
0bNIY4HxM43Nx5oiZIIsTMkDaqeMMXLDHn7SV5DncGxKW4gsbhyV4HvHjiGjNzBspjxp8G4++KV3
xV+6Hj1DJAtiBYapm9CpJn3cYu8yvZJdiRNfxpB6CNAh4kG8OETEZlRsjsjJHwB45E+EHzd6IPbw
6o1cOtpvOf6zY9CkrEquar7iHsCsyvGMYBO6ry2sRHOIs2KIQCCCpxHZDGlUg9qiWVR5Lsm7t7aH
ilZ2pQkUXLFys1VWJ2OcFfMxxypJMzD94m85zl5ycu8laq2zl427dEKK05BtzEUxNa1ZU3uJtRDI
iUt6i9VqzejW4yyKnORzL4+RG02y4pVsZUTUM0mjxXGmdUoE4mRG1Mm1kEciJXL789DAyfn+hKrR
dff3ttzi3uR0OZ0Ok0klDUWRgRi5AKsWNzuWdyjgopZYewCI0jpRHWmBpbbvG+9bt27dcm5IYiYS
LsEReQuySYSGYIFEGADRGZvp4rnvtpMJD2gWdiuGRzyqTBjGL3LrG2/LQr4fS22Y5rRedIb1rqZb
bxNxHMhKaf+FhBMmolpET0J+0kmNyJQA265RDNyrcjlZOHFItSiiKPTvtzUUcZIdaMEPMdwYybbm
mbjZDmRwTxJ5GMHEyEoqD4iJwROTlARwlgiZEBOSVCqAVbcX+LrtfNZ2VgEckjVCIOx+oBn7RIm0
CrF7PSC5WhJOTJZGIZoTN6l4hbY30ckHTNryzm7lBAdWqQFht1QdSANq4vCf6FG84INE+Y4YeYyS
gHAaKfPxEukgJA5jge8OjDx5W4+/BuQ6kuuIpu+Q8x46NtkeolGJhvh2ptLmC5heHpi9qnRMtESC
uH2MCiwzBFzOiOTnszD4Tk6MUfVfi5TplC7SFAKlixagBAiwi6Mdtskv30kLRy7qbkh6cLSE0tFh
iZuOF2AaaKehwojltqxQ0UOt3kyxtU0/kOsM0j34ZNjMhtI6ZmEs8EwA8KG26K5OOLoyeJZJm8Mr
1K3yEtOHVh1xLGWripFJhsgGD1EtG6DnJgcQJv+CqIzBmvGA3DU1p0bSkmbJR84knkMqDze8w3kg
dmTgwpnTJaBdKhdpeYhbh0YZ0rvs/MU8bQ0yZgcUcQLmTAxwuDBSxkMFHk6tSUzyS98zthf34cph
ZB8Wrmt5N2aqreQkPWCdH+bR6g9EiDsgwYBFA52HSOWOj3Gp3Z6Dl5CQ47NtQ7+8uo4ZhZkOyTNa
AMMFBxC9S4BOo1U5IPBdVRgs5NAdJlFmJmv7K+cPhfcC4KMc+Ho47GDWvfa+2f0wN2zDOKOqzPTi
VVghYlnVQIhwR89SclESOO1yMSxE9LzlYc42NzQcO2gUI6HBNbjlokWycD7nFziJQy43vkJ8NlOc
5hz87PeoMos0tieEodkogfj8NzprsYTRWVTKHGUdfv0YQNM4ufaUsVhrbo0OmmSI0va7sXTu1ZrZ
qUMmXEjNrEyZUjDRrkxdmsOGGyPLGS7sOIeCRj2csY6FFOhfQffhw0UsvZx+dUej98RrYa5MqaLG
gtA3QX1oeWO+5l5x5MnBgs7wgb03pFOl2I8OHGUY7LTT0eGH6tKGTxEk29nxPs+dcnBEpM0MbuJ1
q5zM5mdDcsdDi5fckr8ReTPBscmM6kUHvhLfWLNDAkDHI1zBo4IaGHE8RJXiXJBE4N5mCfAxYY0X
Hx9xJtE7vdzDzwaxvDnE+lhH2PmfMfxvQ/ZB2CalC4A9pgIbRTSvVv8pr5q7OG+vKSw4Wm/B7hm1
8XFckIopGt3SKtZ2mDxnAHJRgsZp0jMkKztbsFu3ao8EumO0qNGjPNXnOc4vBnuqvkE0WXS2amn7
yTlxt7u5ydIFm7epprGjJ3KmZiNUqGrMvBYSVN0zH3ZQklnhYNIxRZuIL02QpJJvTU2qe3oW9Lvb
uKm6stsuHVnti0UVWyZGWpEHym1teGVr88qmGUo/I+MY/mojqq6ssKKyrmRm0Qq98t52pIYgqlik
SMQsb2o1AtaXXtLEhg0QATwYSAAepuVHpyabWt+f5lp4rcXYEERWzMBEZcGmEt1pbnlW6VSJjfZL
bSlyUD8mU5fVDdHAYERAD7scD1XzcJVdWEIMCPmVcSIqM9hw8l2eb5mIoHssXK3ECFZqFCBbBL6/
XQehItud/uqcJRZxSI8dxB4KLoZ6jdzpzQp8DckRskSXVuI7Q9+NhKJzzB9uiesRqbG882oZHOub
PfXkiluZL2InBDu/Tmm/W5J6SEGQ3NDDEbafESlLKSTtoJ8RDU6kczJ0qq0IEDsUp+WHv2clPsLw
o9FXp54dSbwsaq+jrY8RPg2d1MkXKm0zkj9Y1/UAMIzHfeVBwQ231KFlpvQrolBlmsUtL0aZW1C7
Xsq3MshIYo1ThGDh1ZSqZEbPMTBOLjgmxQvscHfXBkvSrLsmTRvgyIyogFfqEEPfo+fGPnoz3vxX
SHbwGGGZBVg8cSIqkE8kY5Rmcc+Z4OfcoOIDJM1OcuJHij4dQuR2PyOxwQOrA218EzfjXTP5t0Eu
ZOkDxzkyg9kfH4j5RSBYKIPEHx3IMOcmGrHomQfgb15fdoG5yOST7+Q9xa7zlqz8e9o5t9dHd130
U4y9pe7msLXpDnfMo4YR6RHNIg4JIXkPHE6x2253CkOh49ayxY6g8pghbhcHX2hjsjazyH4iONgl
25/Y9z4PGe5rgRn+Prl2H6CBrL9NI/2PsflNlnC/X3G8g4ROzjrjgsbGDweDbcnMboeViO0SHAVS
QGy/HhghH1ktIZXZhIakAy+/v50U5YAfbutOsQKpnGCBjqtpGShzc3sTJXvfCzw9892GdtslBqjj
Zw9csnMoQAHzlLqfI86NcnJTgQb4Nxi9VguUcO2N4cwDRsSW2xlbhkNCEWYRHKRIOjQRGcQ9TZvc
Jzdmu/XCst5bPZyUiQLltDr4EqlRi8HVYeYLEiGOODp5Hw002Q6HOHc4WdKe6GWBj9oPg3anZ6Ph
QgcDwRcuoEC+h6icXHEkT4qRmprJsPycGxsRJiGLkTBfRM2rR5ioxl9QZcctihUt44qTzVyYYscm
zjRwPNGi3JubZ+SQKEQe2dSDp72dRsSL80JGiJDRHjFBihcUiZ0VIHOjrQyjzqOpUDDMa7jrD2CV
FuQ2qCiciNJtNvs+7nHXbpRkxOd2GEFHqLRY8U9RaoOr3pbDD4Qn9eh8FErB+mlAYdSHGThTupS0
7B+wuoCE8XrnCJF0neZwg1Gu9q00amu9ep0qmnKeIoei62HNJ2rMiiVIsaRJxV1hQoWqtDTdUVaY
eB+YPmEor8g3hDw2yc2aZlx7xM0ZGNuONyljjKinK1BlVXy2LvJ2dfaWEZUBg4ynExl7RA6Rvt7s
+r4QpTE+22R9y3WyktlJZVVq5gZtyDEQgyN45+O4hIUU9BgDFHQAssiGiwAxg7jguQusnVnAkIQN
aHTcYnnOoEheVx43ZTxCfqZM4MpCWQaJFmdQuTffcxu003cI0eIUZyByDscVldb/5JECK+mAqYQ7
ThpDzZ6OzS7kw0d2Ob059B01JG9VqEiRRUFnoc0U4nqq0K7n2fmdevon0yF/Q/bjhCjCUH5EGkBP
f2qKZPh1WEifENiajb0q7h0+rQhvUcwcDG4g4skS2wSyhX2HCIWqRpSRxm3DcIwmgbWNEowPQQaU
b4COqOgDnDi9ZCeOAG6vw/F2ISqAYqB8+vg4otNXGUUsd1XD3jzedcAi5EZW0XNHTjH619Yy3Ox5
TD/C9hGz9597BQa73+HwIQk8TOikgJIUue/D6TpEuxyUmT2HIEjBE2YvueDNcgi2x2rGBRSXgicE
dFJxInJuMTYokk2jJtlmIPxlaB548eQnbNOMWiqlsHY3LOIiJ0ec2Cj3fhh8Nzg7/Idb21zOfceg
JOyCwUFgsigoCgLBSLBYLBSLBSKCkUFIoKRSKCgpFIpFAUiwWRYCxZFgsUFixOx4+zzHbRzOx6iH
hd6NumcnsMOJPCDnCf6gwWtFx1DgqZO8aSSoUOPCsAeNxwC1u5sGDIaj4yQoNoi9vyEKbsZjtQ7U
UMMR4VPzhKlKlZakqBH4gCcW3gaqgrAA3NWfjal3kRjc5PM+36hJbbGDvB/QOOHF6Izo/LjrvxPS
qEQIzQ4rn347igkWSXpiZNLFSxxbp7YA2JkHHi6FwAtjweC+LlKDiEt6ONHrCxrRubmKSN236hnT
MDtmc6CtmB1SDkiU3gNedWCOZwz5ePjh9jAGELQo7fo6NNySIF+Qf1jJR8+D7BH8BpVYLuVkO8b7
yJMoDjA4oox39z0KMQUWx+DcIM/KlQ7HW78Pccu5J278S8D9jHNYDudYB0a0pexYPBKfcPOLujH3
OhuYULftMcg6srCMU/VZhw0uYGYieYBkmbmBpVIdaJmxyTMV8ZJRXJxaqMVnwdTdrK+yiknCJPh6
U9KezNTo7HI4c8rRVJKOnUuWdR+zD0cOmGFMPQmp8LNxi2smxIeNQmUf3xuIk2R0ixutFSJxEbVG
G2KEDZijyezwRO9BxwXICB/F9Zt+tIIzeQN8jjlqGR5M1K5Y33dEtPFJX3HkuFA40BrIconvI0eY
PqQzTvxHxtm97E7onjAfMWREwBEQztxjvt7GWcY8pR8oy97MOZ0+ZQVEri2BwUVakV3idJEUU4t6
XOrJyuK4szGXSpIyQ7vyiNpa5nJd+JQ5Btml4i68MRuPN1j3i7W5L1lTeXexCVlscvFlS54zCtjx
jEKaZTQjGLy211FIVa5UxjK+QcuII4zskJxI4LWpqUsNmpd3E0TD46pc2YYRrZVTZLto+xDyYZEp
YqszAzcx71tpLpZCbZpzeJzOVxcXFyGUkyMamZkkgVc7UMUpGQP0/rRk83Rw1tXd7qO+35HF5zjp
fAEsJCgQkQhARihAcsR0B23Ia+BwIHx2rAhV8aMkXw1L2+Mhm8vdo95ukgKJdMWJ5IFYbA8wPJgS
l6kBe2SwWgziggwdeFgYwqeHZqfgzqtT0DQL8+KpMiRQS1OJ058OD++XnTsbQhIRkCQNdnoSO4D0
KJsOFGBRw8mhXmMQBKpsRHTMGE3Bu40442UwCcG0FvdLDqDI8DosawjfBzffoIKrBAPZvr9uPs66
cg9kaiB94PdjHTWUehBZ+L69bLhDszhAIsMLr9yVSAsL9KI374iBXuiFH1UvonjKJ9DnoYl2P12T
Q3gIUIg8ufc4LmHHN9lGR5EmR2D5DImWgZNliUCBIaRIJj5L9F+MBPn40N2c3MIXSDWdN5mJGKW+
U0L1HhQu4wkHjxJ3cYk3Dg5Xpus7G6N22iiLnQoz3oaME5yGxMlp0YuaHrsbgFux5uecT0yXudMs
3I56ObVJNQU3HjlipvA5NzquxOWziBp4PGzBPGmz3QT2ZOoWHqmrcEEgNDhwq85T0ivl3qC5JmOf
Y8h4Umij4vkQeG6ew+ypy+jFDo+w0NEodFOfMkn+ouyRvKvZRxYsSZ0ORuzdxAfzqPiZzM+8Af2b
1OoHD9VvLQXy13F3jpwdzJO7IjiHlwPUqg51jseG1+BDxPNoncjgvVZNsbnFYToOcMTHjGDniu2M
bMh8BzHAOAesGdx5WK0rjqAhpyMHJA2MGjHBUdAmWOBxYuOO/KRMkIyGH0j9ohFkCEWA3yWmPFsR
IjzeQRk7ocdmTBFzE07mp9AExKfgtlxUAkh5eARHFhjcy2pkVsu4FB7jvuTx1FxIcUnHc23vXGTG
B5tV++waNiTbkmLumUHuw8yMQ5qZeQqPuYzxw4JkzyP1IV7DchuFD9kKDYOhu2ntudnMqDFdyFYk
X9ziZJlsEP5ECvGu+vF9Yyjs456+jR/dL3pMfCj5HDTDwodTEdqO/Epn2SU+RG4j5JD6E2kJ3JLP
iD6RMxNwm4U9SNiO7yBRHIrxiHBp4CU4HgoXXkGF7Dz8ZyhXrvdAJuZxmlub1UF5cxqIuEOX7rKS
W1y5tZem6ta3VtZ4pZKSYm2utjbLRGmlU40ORuZmrcxevu6XtuXaKaoW6kSzxdlbr4jpDMzNAulK
XO6aNRg9JEj1Mht2bpMVyHeKTnOI6cHfhURoq0O8rWaNlI8szixrzpS7ptWttbw7XHT/oPr9nPK/
UnidJ26HQ6HBxdDpBosQ0spkcjkbGxCYBKYEJvTmFOblO1frBXve173h7ABBJXFhApAEUiZjetno
J0VCGIuQlU03WHYCSfr9MEooskZvowPEgcThwXIJSSF7dD7QEsSBySx3kDsModjvsI50dxSAeFSd
eaM/BFDwFTWJn2YjZqDES1byMmwfSZwYJCIv2HpBkttqoZhuEBUMnNCIbEC+inGLvYHDhuXLd5V8
IRT7U9qIxm4BvRkjHF247tWYdMHVnfi3QhFOvyL3ZgIFEntz7SfXw+x2WkmHZA59xmBHVMmghAbi
znucRinQg/R9PpfgQF6juKpB2BXahM5JmTeg4fepNINiBAoYjQ4VcEDIxUmUOi3AVmzIYZybfrbg
0T4K9VLPwPIUIzQpwJG+ZltsESZgvu7LVOeDfncoTIErlKllGJ4PcFK3RmMHG+lJZ0iFQVWU8f0p
0x+H7F7D+Sl1shTJHfc30DkmAqIFYbY6dodzkqaeOvc3HGSxzvu75bb9QYxBnA6j2fDmCe0Bmmq9
wk3EnyUn9XqSBoJODDH3dII6b16s7Py+vwdYOC5kqZv2TMFzR24dvjEnhZjrESBl1JSZSdIemapy
PJEsbG5kbRzxsrFqFIXIbu4NEMDzk3QUL2YOXuYZ9IOhFR5xLeRAm7k5ID5EeSYXqWIyGup8+NFA
nOTsxLmHONaHuHHOxaFELby3Q67DMnJ2nCKdRemw68sxlomUKUJGjSodV6IzO6wNx3PfBVGDY01x
4Bl5He4ccFC3B0bA/J8hCOBAhRyMuje+cBuZdC+wwx0R5kSOnywSK8tggZCRc2Pp3GDiA91B5km+
hSj3ph9zzTh8VDRyT6G9ndDmkjse+GQckD0AMZfgxrYrPGCg4oYMbqpuqLmRI3JlDjLLRDA2yxuD
t3lajE2CcR1Deo42iN7rrQ5zxh5P3oJFLwswUkyTlG3HB5jPH/mCH8K3Zjgr9QDjqRp5u+HB0G4O
KnZTgoPKHRQvuWZNcb3Ujesz7Z7Poh7onyHCJQOpY9YDxjbrEwA4R1L48UalioGImk4NGynmGMez
2IO6z7xSsYEu2JSTutLqtet7bWM6mMGm6ui1EfkpjpzGxFs2oSLamzcZ+ZnB8lbnHrkVRkqVphpn
8F82V5RebmZyInMuWa2y8a8mqhr6Wl3EluKTaNxYdXHLWbvU3kSu82YeDicSLLYrhwmrsy9BSVdJ
Gfct6K1R1XXGu2e5t6U2atJmSGzHNBBO1+lzr9ki4/au/4yxZTU1hXWlk0UHOdFrC2ByHKaeSTB+
hdOVAmqjFPw/EtO0q5y9Zxh+LV959owPBDkoiIghIBSIHUII7UIohlcmm40H1uHgQTbvGTRi9Rsd
hcSDsZtiDHxPrE9wAephPEY37VgngukWjn8cTnhMEhzvFhJubOkgPEi1Tq8a9SDcixj7/veYbB3f
trb4YHPZxBnF6slZyCdLS0QOVEHKzKa4JGTojszib7QuX3mWsJIDfcckosgEzJBE5cJDGeRjgYkb
tWt1COZG+gkcnJDUz7iggK2TRvajufdlUXpkgWsPnHGCfoUCRxgIhx+iQlw4rZJXwDzELHJ19qSA
hUwHluszMnLF+4j9jvq5uDRYcw5PHalFP5QTmOFxDcfIpArId9YxOy/PZPggOJnB5czId5NHEWIV
4IDiD80FD5oMpDL+SqKMalyT92Sg9Bbtg58OSETBMqD5oKEqDGS+7+LmTB3wVHbFp1Kdngv4Vj24
nxg8I2nIgZ5g8+mSXr4Ono6AOJUeI8RKxouTLzw55E6MOU2gRsZGGLrMCPH6bG5AqcDz+AA9RUyL
LbOpSEaEpBEeQlIObOVCjtGNja9i5vCmPSeSJ4cs62OrEI2XkcEy4jDgxBRvxHZ5DyueogCelJav
lcwIPUoyUckUw9xU5iQwY4xA6NjnDLC2V5vK8VhOxNWMTTjj2uvua031vcHNvWtrxXUmLKKdbq2s
6qIxuw0zhQIFHNmNaZfuNQfHiTRwb1j9oBXip6jFC+2umeU6d1PEdmi8OXsmZuokDEHYZSfblikw
C1MljmDVLUGjttKUSQ+08EzL8DGxU0a54HElpiej3Fw4y21RCM/kIR/EeR4ONnjHg0dj99n0UeES
ei+sHKumOiz1xNb6Nd/BmPx6WS+DHUiLy9GNFh8pk8jGR4bbETRDI8uVLF4EbECn60LRMtg3KEyw
4s4w8ubPJsbGjIRhvJ4dih0SUQPJ0edpjfufXSadHpSCCImFhn9DHD0cPQp+f50Oeuzog6iYknt/
R0PHfueXVMPKnXDzaO5AiRG3ODBsWQ8hknWBj0EO5GJJmh9CTs9AeN6BiSdQ1fOaexJpC4D2BH5A
Jj0QrJLDG6D158HibOd5RoTNj+OR5w/Sfd96ev3QVvLb8a2v6y9jFonmaKPxWa9aL13pbZ7GiThy
Lvi81lebqnqYgtMHvB7zmzZK1Jl4tjRuXuK1ZorOtzdK0ReswOVGDUMskso9aa6am3TPlZF5Qu0Y
O8zqa9mErGDPessMUhcIkK2WWpG6u0y2PLQ2sabTStig+E5T/FXVFhUWVZYWjIzOnKNNVYYYCSDY
GCC/Cigj6vMA9VJgqUcVZYxR8rt99g8xeSDVN0pnBeu7rXd3W9+XRp0sWdL1AebF5KEPn6jfOP07
+Z0dCX0PrHABgow94BIGQsGwxu6Q42MSIXNzbY3yUfqR5XMnup9ssk7eG4A5zr4J2C8OtLTDDOjq
7SwkUAkGcz4fXPXu+gll7p35gppaqgEGeHWkB0TP0WacicNDo7UMcUUw9/fpjiAe6ULLNYcbxtJ0
HBFprBQybABkpWRcuYNPy7Y+9CWSho0sCCnDDa3wt07QO2QYXfPo9jko82prrHFMD7E4g8cdMznE
IA9XEGToZVYcckTGTBxVCg4jG2AoQSAveBwUOak5MYj9UcWHdkZNruYa9dKcziv1lYvfKkqkZTKt
D9trGbHlscD/K9em1wT5qQ0QORnimXHV72mNq/Qx4vEkYH9HW59DvCfh/ToIEOR4Zu4XE9O5eTk7
qcIKCB7gnTc2OOutCCogkcKRI7N6tyZOLFToiZnslwYo3Bg2JlyBAebd1OOgReRjgTnNSTxnkuDM
5YSEDk+ZGJzk4JRPTmUSBMa1jTybp26JjzWwcmt4ROeDfvc44ZyGKdOT6wzWCNMlJ7tFXFy0SFCb
DiXHk5J2xM8d2JToo8LPQ59DEGexqra99oMMDMLCiD+7RAt6EZFTBa1SrHR2acSwNkzM325Oh7+u
ix2dDhxwOHmoHJonoOTs2ZEbs6EOIRfFA9jvdm2TbrnBWZZaiO+6/bCF3JukQz3r8FjqQkFGBSeV
5WxGlblxxu4uQY4cYkAV3d6AhDEeOJWNFy5qWSxPki88ECKYrv0bnBUiXsW/QRYfo2s6rD8Bva40
Shkzvfb7eXPHaLmRip5GCVAnzAeTOOF0M8HmCM7xL9iQe4Tzvvs6nwPdDKSFM3caHGTeBwcyHFjg
c/kqnnt7vh7XJkjyMOIzm5xR7WMFZ19B5uYHdG5wUKDiA7Wc6tsdEoylqWcu3thmG5WiGinJ3+CF
NcDkn+IFSRAfbNzBI6NP3PRJKggPAj7w/SjhD6YlSeiJ5w3ui8PCJojvQwkvMO6HB5P9PEvTj37T
VGXmVVVVVVVVVVi58Qvg+33p8W3g+ncoHtSRSgh/IJL+kacrzks+iUodCO2O+IkQFuQQ0kkEUzoB
FlEiohRJUHsgiC9LylENGFRoihACKBEUIgpER/bAUNZ+kA21+AFEisQJJJQNcZmxrA0kpaFpbz0s
JWilrGo2uuNqWA66h2ojn3aeIsUAOCKIdMRDku46WcuEUS5FLoiquyICASIoFnLZuLFBbrJhjfai
LUrdllsyX2QvQFwvoihfEW8SRWYiJRXARMwiWAFQWAERmIiRRVdERULVMIipUiQUTVEXERaGSIuh
EpEWNERkvQiLpNTNYoI0b4hgIlBEoI7Xf5Cbf3FQ+sIYfmQonBmKFmiEkja+H0r2fri6WylP3rYU
8ViQNDG7qyy2Wb8xnMADRzX18ixeFYfVbUQtT4LiPBeiZyzDk6VUcKeIzkOmIzSbXHOFiT5dUIry
vwAIgk/k76bHtTxzsmxhwxNyiw5pMjQfxEh4fivHG5I99iHAqFUx3+OjFXQKDW8/xGjVagbHW3dv
c6S4OiiO0rfjjNJAbiYFeeXSIS833PZZPwoD9IWKDjks+DwFsjLXgbmw/n/wIeEHwpKAXNRE+/TH
uGvkLCHuy9kwmg2+nANM4mvEpdfqJJJolIjFqRGMWFVeoP7T+2WfSWLBAGRWQRIH+lFEpEFkQWQV
gpI4ISeBBsTIRFHan7AyWYwlogWRlCyiB/eA5EIcwKgsiigKyIqgKoxYMURRESAxFFAUYLEVIwEQ
RJFiIMYggQng2FgKMEBIUKFtWwgwrYFoQjBIQ+IFWKooKsFIooKKLFBRYqgqwVYsVVixYLBYKLIs
BVBRYqwVkRWkBGLBZrcMMEQEz2r9DUprJ0U70E/aLfHfim2IJhFC2F2F9QQuHCBfHR5PVnLV75zJ
VIJuUjYxU/lMIH5UMcUPEWiJAQpZe8l53mBaAkigDIooxiCr6wuf5fj94SEk+wPInrAbfvANH29s
/ZOWYf4fo9yERKj5EzJ/VSqWhng22P9VLVuA/3CJUW0u3kgrgLF7TUUHeCmf8RcwRf6JlBuNIEKi
+1LhDKOYW3FN1LJCFKNAtMD/hA/3w8nh/2OQxBAVCWQyHv9YTzKqqisQVe87pA3+ST1/RGMYxiRj
Dbg9pCtqy1hQetQIBSqQIw8hVPI30FslrGhCSjAox6Xb1qthIqISEEZIwhBRZBCDFkVSmRfuiPQc
f7Tvj1mNH+CjRpKcP0SpSlEej5B1meoJ9sFD+sAPSqFqji3SbH5g7mr5NIWah1JEOohYj/mhBND/
15uBF6MFeFFo3hZ2C5Eokil3B1FFDMlqaJokkJIQkUXUFIVRFVUYrQ+8QMLQPh5kDQdJ53wWi0eQ
8D+JZr65SyXPVaODFe+LpZEPkiFIw1eAQsTYnxyZqMQQQQQQQQYxgwYgxnymwSuRlEWxaELg4NE6
HdQTWNIwkJTgUO/ZuQ4iinGJwGMiXcYCVAkJ3CNo5EM8TMmKJiMheSYm6PGde0p4IPI9eSTqHrp6
KDwOEC843sz8wd7WiVeRldlh02EIQLkoUKCn5rS5+M/Xg6/pXV/Z4jDpzUVcDgUFDG8fi6zCSVW7
KbA05mK2IsPfSm2GLW+t6JgI4O6Z8MAycSN45RIr/quCVPLS1NKefpLukEywNatjrSaFSLvKLaxv
y5AHnW1qjbfTZvBAwHSUESlCEsjkDkkbkQjRGCfIkHCJeu9mcqaKSSEKZlyCbFjEwE4EtGiBzc2j
nZRhUlJLg6lg7Q4F3zGuYNYwauiqWLUsHbvm5dlweHIo+AugXugr3HWGznayJX5N0FL6AzRtoXRs
M1AMIH24RFDAEWEGItsct92DxVEcdQ+b5qhOVIhbbBGiQLosnLFyT8P9KmYN4bshDVKMO5+AdvGH
KtESndxCdaZEiEQ8g5MpGMYRjGMKql/aGKp4oHIgABaBu1cEYQjRxyMLFNwXCJWxjCGgNboSgj+i
FC0VBQVHE58orB0haN498MLcEA3grQDOvFETE7GQzu2j4wi9ahaLn8KImCWDaixSK0SBbr2BGxbl
txJPl9XvfYIWKitUySAETJOlB5fLBqQgfECASEs/tAFAFUQEYiCMUEYsRVkBRVFiiKgqixVFiASI
okVFRQFBYwRgqLBQiIxioykgpJJgMAhJ12P5pD9PxCs/FT+i4aVirjprTTGhcW3BqILTSZhpgpgT
LdZmtBghpLoWwhDmcpAiA+qzxjqQ1VDIwRkAuootuSxbonx9CAXnzwCATLjzMRRBBiKosRpIHRFY
iKooiIAVXNazMutNRcZlrq201TLlY6uKIg61SVuazK3VzNa1jlfn5EMsMhAG1UMu1hYjoIiitC6k
KtEge0pT79UCSpAIgkikgB76FQiyBIIYQpP/y4WRiIwGQSCnXlyMCPUb0kBGTbbBUUbbgJvGH/eN
DGgYQbiBZheNZDWnT1x6GLyh51509IWBAoqVDCqk8aB6gT1onZz+CJsUcqd46fYFV9a947yuXSGU
T+weGdjAIQZDYtUtS0N3oEyrcOSASQjCAkghs0j7duZdNuAw+OK4hnDSia0iFF1i+V8jPEPnCLp6
d8IEIwIEYwhdbCJAjxFZzg/Ye4yXDaeQFyRckSzzZSUJTAETrHp3kyA8x6kHVmCBGGVdDIKImh6s
rG/l2hRXJz9VBc48Y0OMIr7B9ia1pXxw5g0KWhilwVXoCA3WQjF0AY2JQILzpDmR3cDGgEsT0hzD
2vqECBvszcSmvexGInMzlSNxFBosSrFKH+RuDic3CnYHYmsXSGUNR5aLTYahuQgQ2htCCYLcXyNg
5UuXcxkXmKlps6sfVuW0te2e1IfhqAOS8hiSgRhmMgOPU8vql8qBjIRYLIsWHrh7TIu1E4klyQNq
OKbQuxWApeKxblaC0TFcBWiRYEC1G4C1AuQqosVILBGBAE4l2BQaF4tgkDYni2MJCNENWthryQNK
Bw0AoIVvHg7dr2idvUh2p0InOoUOJTfEYJVIkXfEviJJILIyBxrUUSwKiUBME7LOqwKZWMJzCa07
xc4XjcLRSi1TPUtHjTBDQGYDeKoBNhwcLGMO3gzbTc9CaQU5ws4lPBD8Q6dgUWpghffYN1wdXAO1
cB4xXgC1SQOEjiVG0cKkMGySZ8zEmkkdU6p07cu/tIdCe4Ag0qECMYECBGBGEPVOsk80AfeyMAsO
8QERRYsWJZ6EN4NQ01utSQYwai3qTaG+JiQIB6tjSM9S3faSybGaXSxqbSNDaMSUjE40CJatEMha
JzIZLEsTmCIBmcvt613cUcocY5HKLJFkolJLE5JeJeR1jxeStuNq/R5bp4KLLzEzKMRmqYMJQKTR
lJ94gTv3OQnlsAxAH7lfFM+gYG+E05JAkENzTJWfQDCF89L9VkhtuEco6bFb7yl8Ubr2NnyFwUND
OTl2m/OMOZ8dXVh96UEvq9fLGIZi4ZlzJ7vHsAd/p8maBmv2Wq0IrDj+WQg855Il/YIcSdYbEicC
RaiVuTUtKC0CxW1epajxWpa79VyO8clPfLkjeIblzEHKloNHGWjFaoZ0NC8KZdjDnGUYxhQRzBS6
gFR5/NCg9CigXFoHI8UOQtBFtyEYwycWecDTZ0NB4kdlyDCHmvsXNK7sN1dpMJyOpV3giiL0Jkj1
CxcuZ3WAZ4LAiSFjAwUW57huHlThQ5I3oWRJ0K8ipoG2gt4W2JkVOZcNbNrYpYlJSgVRUbQneFDe
Hy+voFynFo0guUEipkUNXk2aRdowLKL4wTKmoNilzQQibkuEotIkYSBwtlapGIXVoLgNKDRbEyBY
lWIWDRPR+c8YdUXLRQhMQViBYAChkJYRTqQN3XwLtiSB4gd/pqp10Ho4CGJnSlWBAgRj2VcsRItH
qankIVZZZYVUAAlQFVg0GECFCmQ7HsU/u8QcC9otQfJ2hQQ420Lwg9XSmIruWge5KIXjiGsLUhVD
sS1NOHoOtENIZzdwBHKnE47bbYkCpKMJtb1NIueQJISdS9iUXOWLUMmOZMgQtPisLXKm+dw+tNUm
0m/D61hkmmspnFyHgZoGawPaIAzpNZtLGMYxjEYyMYdx2IHZAoWnkDOgFcyZVdasFq0Hrew4zd5u
0WoqyyyreY+OLSMMJtAzngL8+9CcX9LU4x7wIWEh/3xS8vn7JeXw6KVliRCsCTAPHx+gy33GFqiP
9nOB+49afuh/j8bR+D2fV/k/n901nyx1x8GhD5n/aQlL/PUGP7j+V75Uq+RoGPm4mnn9R/sPeKeS
emP5zt9UGfDRuUMNpTQYJKKkJ3OoQK13Js9Q7yeRTAQqepiQgtE+luvT1RKB8S1KYJbeNRLBLz5I
FvfYtcChlgQIySF8CMbEtGJkQ0rgXtR9xElsJeeG2Efi0fW3ktN7YXH2UmscaKlUpVoWUlj9knEt
Jfn1K3aRbKMkMoxnF1LEP4rkVvyl6YJgUwkmDrGDgx4crQYVTIFUsF1pgBg70jVKmR4ChDiXxk8x
R+l/Q8R/sfoT9IuIO63nA/0uWwfcXXH7wsvtG0JIBEYoMFCEOsRIitFBixZ6r3/UqJnigjaEMFwC
ifwGDpY2ev0/7YKquBcG8HtKKOGCXVK/xhFkbwxtPliOAOwsv93ldKiZZUor+3lOvLZsZ6fplGGJ
hdH5hknMyr/r/d/se//zP58aPidjxx+yEJewcjiBGQTuVP3mi7j99tiJcsRKOvLYzjAmdMtjJgo0
sseggQql9FpmDahHUCokkoGGIlzBU/rdxPbJXg7EjJ/ZaGxyOLVIDoEzGRtQ6OmKDhhuBjSIjbZO
B2iRMuGi0SSiOJuC44ivgCJmeSygc4cVjD2SdHQ2mFcZm/BAo6ff7yYeHw0YIlDrhGalDoyWVQ4w
UHuPsSSYeWHOzx6I+3sZKZjYKPZ2HfDz14VpqRFHDR0XRzzjjiJXa58ADeMU44uZHZ4sQNFDckS6
NoHHITJGihuZCGTYpCcypU9kLsX2iNzRxMnzDKianeK3OyhEtMl8ZnY6hF3XEdKZmJfJidio4ocu
IERw+R1Wjrn/UgKm3BvG6ZxgzZ5ExB+GmS06VRrHn5XHydlULkD74YOCJEoZrM7MYmrHbkcjVpo8
haKUT5YfWfEqChEEkgDMJkwkMDz2/3UycDo1uvMyPMw7OBycehUYhsxN/Mdz2uBicJ06N45SEbjy
8pFSCgKQIDoI8n1cmSoaH9rRk/wz+s8oXtUykhs3ZzeNhud+VnjU9eH5yZt7w3rv6/73mZdEb/iY
c+skhIfI17JPJ6+nX2H2FHngGmPJTBmYjg93lIIDqETs1jZee5jLoufr+kq40Ou95QobnJvynE/M
zWZAoaJvGWFTO1hlz7TV2siSDTvOnhop6REiUAUe3vALw8x6Falq5A7LQ81n5iHGFqGAsPWYehWO
eVvNpLQr01RaL5dnKNwh56h+OJoMuZcFbsFPxgqUuR9KJmQDgg/FgwiwiSCEixYBIKrEItSBpygp
eobc+KBsuBElorELa/FCBBQhBCkQ3yxZ9SPGmHCFMhirtzeTxgGW4jwpKHVz6SNkPj+MMET2UJ6/
uhNJRRsvLIIqnE7c3YL0gYdUvPpHEab5zgFoZ5IloAfN3CafUwAJyjHjhIeJWAlhxBAbzRI1UIJV
JK7HdSlKStkyR5wPrQPU6Eap0rlF2DVwMuSSBNj4ANBEpyp+VgyGksgsdlnPmyyDZSXpYpZa0bQq
1MGGF5iUx7JHuT0zLRBrM6aPtTo3ojOrIoZrr4fHAlUuLLpY2pFgRgNtEoXW2iAnqoBf8D8BN8LB
6uDzA+6h8afQ1ixhyxoQKU6OUyQdIHInQIaisSe8TlKdvZioN/u3Hu+d8vQLPTzHoMPgZDJny8d5
YempYQqVLq3nxMx/HMOhxVtlfQo075m/NP32jO9H98PEVaPR+pA6F6lY3M1Oa7fhqv9mTlvaoNxb
no3sOr+N3VNx0IfsKkRtmoxyOLmBxckQTzixM24Zx0R6f57JFubGPPbj+j1WkmkcFKKNOQfvAhi0
rnz6yQKF5NvtwafwZyYfvE3HZkVfJXJloECzpGjjVjkAmXKEdiZU2qPIGjYqQMmPftJOvRh69kMa
Rh7Y67LGGLGPDK+EYQOb1dnDw0XD2UeyeCiQ5jUeNpJ4RI3vw4SkTNnltBkhxxA/eAZMmiBXIw84
TP4HEFAcPGtayQLg2ImCxOcpbr+wQFXBU5CT78QHFx41ThaKHXG4b7xMFT+gvoi+YD/7nA32/UqI
/QQefoduq86yTOzwbwPSxQeS4uUHdkyPg/TPywgwM/YLvOdnGeENLY7HOuvZZ6Pnw+GXpuPGJDjz
cUPLceWMHb3NQ5MmTk0udahDcdK9Ntn73ImChyc8j2JD9jMyG+c7ZK+BBQ2IOZIMnNtqR4NDc7G9
TBzGvzxqBmo83Mbn6H0HfvTmGHfmwybnmf4IhAK93HmTk8BY6a8J8ErExjg57PKUC9hMXPRxY+KF
T+ADdH6jrVAdA9mTDJQHAExEoV60abN30uHthEd9Vs0iJ1+g+j5nOQPxTnaLlyQ/EoP9UalsL1X8
ihrLQsRPctBDu5gDs+T9mSu4AQN0FBJFUEkAFapUAgkg+SDxVQAqdsrjvcfJgeybcXFh8shMICq9
+6vW3/BXO3ymcpzauT2/ChICjx5TkZUd9TI+v9q9y9k+knaK2jh8Wjt5buNjoSOfyKFOsQOQ2IFW
LjXebEzoYccizkiVKsNtkp98TQx+p7h5opUbwndkhxguQmZImx/1ZRJR9VgMfBTY86k+GkN+RJR+
LIg+UP0P55oZsbEihOch5TcoG5Cg3ZwSQfsJmOBm5JjjBE1qBtvk20uDBPERihTc0TJkClCRA30O
4YLhPBkcUGN0wzMQyQkXdQwaOTYsYiwZMkjJqpUEYBDZLlx7iBdxYrgNFDadDQ8ra3HGDW5wVGgG
cGeDMuIWzHceRVXGw6BIgX3dTRvvW5oXAxGMyxJbGhjh6FuMYOB6kTkol4vJY3KOL11sXJlDg8kF
e3CX6whS1DOw8g0bDyQ4tuQI9jjJE4IHVPM8hIBJuDzBAq75fwajfLQuoNDDo/oyMjIyMjIyNeTq
X0qF6B61ILtM0OHhN826jXy7Sgb/DAcQsKx6yPSJY9Ynu3SC57wEhMTzgwVHGG9jiIxGY4e4MHDy
rx1S+bGlWZuQ4WCn+MEFgqQ6IiRA/LbXBvuWjFjctuT+AkEi5A2mVPbyuZ5HEhtDq1OzwSgYNzwU
HlPJch6r5tE/giPANSG3N+3kB5r+Pg6meNyZ6nHfczklXdoFSo7s0TOhVMnBaQ+BxcqNGKX7pLsP
3wZMCTDhbCEPCfxBMOVfJ7O3cenkZ8EjwaKw3UaFqG0zHmHUSBBdQiU8QdaKGcAVTxUo50qcpOZG
7dIc0hT9shWjemrzo2wwglKL5RMpCDIHW+wns/6T+B/S3lxA8W/P9TgADpQh8UzmraHe+8RLA1of
WEcBTzjYYWdxCH/uUyb3v8GwPsPev1/bPxOahmKomwGaGgFpFLLEoRGDAYWUQT6//vNKi5hF6pKa
RE6Eep4keXhPMaj6Q2mYhDjzJz5vWW+tIgmpKMYcMIwQz8JrjLqWz8fj9QAezicW3oK0WNalQK74
R4sxUPIPx+JNniLtkKyDRn5MKWA5IfsIxZDMDRYlStb67oGGjY2MwQkPOULvap4tywnCC6ZoMsCL
RiRGUKokSG8jJpC6GDy/h+Hv+Ht4ff8NFczlY5cyHysuIWqSGkN4KjQakJMEklQWHCFyzVsNGhms
JiT8pAKTCVeLIYuISLXi2v6/v0s4vhPBww5Ofd5eDqhH7Tym4cUyxK43Mo+RuYp+lj7xCLlKGOcW
5HpprnvkmGE6X9DfMFkuzoYsPfeDjmh/B9kveSHFzOSmTsfkgdmi3I4c8vKxyTYnaFzg450AhZes
bn2LY0fs0tT8w4eWLZ0KiIGzwwhMXIG2pXOmN2jShA2HG1b0J25YfAlEoNNdUqYubmUgWrmE51rW
1U34EIlcwEt9D7yG4OOB5GJg5g781DR0Sk/0P6EYMktfkIeWpYmtyBHeWIHvQIRYmTIDqDhpbcM+
3NyEPOJQ28ypIiSIVtA7Inn52D3CBCyWOiY83uZLqD8EuBwh7+TfL4RNzJMsPOSRE0q1qNGJq50I
Q4xExQYgYKmi1ElbqpubkbmiO5MYmSMjhjJMuWIaNyJEdsQKECcr0wOLnXVDi2II8rEUXiADjrJA
ZAUQ1lyG5YIiN7zLc0GtKCAAdxe4gkQtCBUNh+/9AsHmMdrQ3q8keOeYTHvgRGbzPI3S8FbE9X/A
Pw8gOAVvCMVGGPVe/fweAeddEjt/uKLmh4XYNbBZosUuSCZA7LFA0eNjbbYkRJGx74Gzk9jk/FOY
jk4IbFT0Ni8eDB0bFCJIiXLGxkhTMiRyMQOedi/Bew6x+QkfAZku3oewM8a5sfO/keQ4oz2fByiX
GJETJ2XMLseHND3F0km+v7f3hkkVPQ2H0Dr27IMzkjs8pHfrLteXNvgMxUHI2Lf6Dr+dPX/AP3oH
CqxfXh59Ks73wVRvCKgpvh4W2I2IKqbgqOvlNZsL91nr9dnkdXgz4LPjXeubvN6NMtUfk5Antd0h
7hEeoR4qHk8C3kMZp7ZukPffU8ac5Lw+GzUqGHvk/ZP5lCpAFFQkRUYoiBxkMg6RU16hmtHAci/o
QQ96CoImFLiHuQtbfa79v7CUCsF5y8WqESDULFB8WTIcxQpfxTMvUsLaSD3rStr936zl657Pz/nh
sk/fhzdNqqv9O7dDCmODPkIopIUUkKKEUVJCikhRQiikhQwCH0wzDIg0oCuLQmJ2IxGka41GKRfA
PSkFR2RkUOnLyeOgokw/dU3Bn3dSb1Bf2tKgWjajsf4hiisJJL5uxI8oxdbp2COStACFTNLhl3jU
5GDQGv+MOwT8D98Y7KSmQbsHODBFHt2I3vG2/Qa4eWE++N5UuwIyHR1HoFgGoWextLZ0FpiiPl9v
y+749osmSovguFsbEUxgIJPFFaHqIeEOXKn/eV/BEIlLerjsc5oECY2giUQ0oXgr+TgIupRV+DyE
PgE3sNCXwXsQ9XFJliNQp6VAo9pjqtFjuSSP7SRQFJQYJDCeujg7OyIxyoIeiJgeoroHG5XObqNO
42RQo7YUO4Dl5Dr5YVGJzh1WMRUmwsmo38lTevsuVJG5dLJdbfS4jiKApSRqmmwVWlAu1cNDirXj
KcR2HcdkD8viO/hPz/OtypTJcqZLH6C+H6emw32kCDZJmpEoFYUPzz7/6/f6b8de78fj362/s501
tuKfnVoQiN+v8fv+EvwLfT4Y+Y5M4b28j4DiJE5PiSNx51owcOPbKQbAs4a5oGLFh+YxaBI6HP0e
76CBnwLFjcvuW4HHyI8GTYGobH2CW6FgqVsXKm2w4sOHtqg/BY5LxHX2J0tMdgY2HEBibi55iRzm
JIcU7c2imOvURV7xtuR2Gccn0+kJmj6bNt7Q68X+Xfjb2o6Pddtvn7Uf+bPvvCHn8j3/LXzjbvHz
38q+WGpA7j1PZp+/zl69/CrvpXO22N93+bebynvx6YnXHy8nQvK79yjP8W38ou2+2b+Y0+Dre/WZ
0f3fyxw6e3wnzvOTbvzX7Pd1zxhuOPhd778+W24+XvlGPwyMXNzB5/AyPK+46qOPfgeSqxQtJjBI
949fP3+hgPS5Y3cbD3mImCRcvo+1CYRm0jI/TjY+n01yEZlplTG7uyRLrccclS5UlcePc/aZY66p
QnzoYucOkMpmrPeaGvvxFxikDaA4aRDgsU1FnW++zrMlzh9DseV4Fn1E/R7FySehj0nczI4ho54m
tCD4hI1KUTombkIFzLHREgSgTXIXHS5+o7qUOPT3CIccVUJBBCQQASQgEbTrakkndKd/V3JdfKH6
2IVhdzWkghY0wJQ0eIVW4VW21IWqHfoVVE+9JJ7FZADmLBBGIsWKMQUkjCJCCSItAEi3PIXlmhsQ
cyGQaDocIYhYXi+5LITgUZjI+XRNFZQYbpjUh3MExkkkm2iNpCJqtGg5m0NIXmqi0UoYnFv8RCnP
x06uM6TccxpW+FCheU4SnNkylMDr4zIZj0KcREFIRYSSLBBAUiIQSQEQZGAMJJEQlKkkKiKgpBUF
AoISpEVERMOOqyfJE74PLSfzpZ0L90hOPs7D2EBs44PvDbyuQ8/B5k3ViSIHkJBArZ2rWKCljuMX
6BD0Ofn6snw7KIwr0eSeBfRoRIHng8NcbHKXmZl7LyQDkmEA1w9UeR7EnDkKIey/oJnzjc98ofY6
TVi+aKwDpFIIAfW03nQjc6io5K0cbRBNmcFhh/wJDiOfHfDU7SHDkwmEEeaeDn0Pw/D2c6oCPQmU
Ixp6lLe6BKWSW6Sfk3Hm4uV2IQhMwbVu423b4EBy9UrlAAVCw5gYVT2+BKx5/GvE4akTKnU4HXkO
PK3jD/7/PtzPuHr4n6fuq78B9KsWo6znSIfh77/ZKTzztP/y7D2JadhtOYzju5zL0WPSWkJ09JzF
5Woiefv5tFmrmx3+P8Z+/401+rx38+vxd428uqza8/i/9lPw+711qx7S9RCPMQj9nkH+sDhCcx0l
Iz6QMh5XHfYfWHrQ8x4x2Q8zksfYWgVY/TjS/tGS8ixxYeVoj7fsSRQRVgTCVjgZ+AXvE/NKilWS
GEREoE/pTqdhlQewOgD0HKIk39gh0YTT1buvs6OYt4renJx29nwbrz7gvLHG/xt8vu+/r1+n0+k3
CEV8Zb3VPJiLRHDQ9OZs2FVV8VS0pNLNzYEEPbf3/Fnnrd55Xfce+Glx3Z+btLNa0jDqsLzv/1iE
UBCPgAIA9wcJaPwDch4z1fMfL+Wj4+onSZecDOnuiXAeILWhQ8YKYNYQg4AXvtN+l6u/hQBfYpht
8m3DMT2hSMPmKvxZvbFDL/FF96ag+5NQMYnKHsBDz+B4d0nEVurqulqvMSXS8oYYYIMLqCm+xWgF
puEcmIqu8HBNhyf9/uLCpCQ90tHKmgziCP5vkLqdNQqJ+3EyMCNaIcxZzZAPtTqSg3h1+ZHnA0g9
khAkIIMDlUDlEKAVFkgRVIcQOMFGkpOKDzxFqykTkh7CBbCNsLKK1CCQbZ55KZHLqlkNXE4NTeby
z77E2DkPLkVBhdViy2rOatZmaZvUnIWA0qIyHuW1WCJZUuolBZIwVG2I1iAlZgsBfbfEnjarRUjW
KCqFRQqGkloSWqSGg1WJESxQJbdGIIS9D78lByCJerajlHmC47uXct78baCg6IAIORUgr++iRaFg
DmESyqmhD7BtIOqxER+WBjTh3cVnjrvmD5m0baN1xexoaLW20tZLsSLlRYn7cIjfhEbV/KiNBOCl
zlA3CJSpkzxR/CjCRFgjI0VSlEbQUirYoakzwdQMOMNQrqTDUZz3HQuGIGVRTn5RKYnnMa4AwSQF
V3xDR8omnaPKB6PIFE2n0DBQQ8fU+Ok+nsUIxYRU96hviJpQNDN7pA/KfIVqsCdQBBkKRgfV50tL
LlD7+pDSTViF22TKa0VrZCifZFQUwMIvi+Tr+bkn0ULr/1ubSaNNVDPoAti6uRL7Tak493FzX5/y
JD8Xh93A66PxfJOFeSBxY/pEblSU2/MRGGiZuOYPSEOH5nN83TtEfMm/feJtHIxJYKKOrH6pADtx
svkWJDkTNhje89nUHZ1wdzjJZJg3ZgcpBK6PDw+2mleSpR9CJg0XNEim1nCNk7Yc+lTGidtV44/A
5M0GwnGqDRFH6CtcbPRKY3Mi5ycRcYLE3lTfeE8bWsUrhftSDqERjI+WidDsxksMVKG52UhR1ipF
7ncyqVHRLKQxQ3555iQ6NM5OG5X9aFI4OScjcqOhk4QpER5fcqPNzJMZ5Imx0QdbgeRKBoOY6hAv
g2LsWJDD69ETAMrkOd7pVgdRf6e4YSR7wBwL80vUYMHkePDHZA6GF3yeRTkqeOuCJAqQkbfXQ3qT
8zgCfYv5ibCYVAXrk4NcvMG3nQiYKEj1OtwpV52TK2LnkZCNPI0YKlCZ8whfTjzjxiT2uSKlipR7
jHemlHs2htKBBfpZPCjCPrKdfrrBZnek56NmtlmFsOqtlmi6ty271nJZk86X4Oq3qrmsRgljrkeI
pZh5WZwUscCEI4PUge3fZQnzf3rjyOZbun1t1+5C+wCCPsQensemDiz/AxffJ0UJnpw+2oeXlM2A
Qh776weRt939RkS9yF70C8hLKjzvwA+Y6jqekt+YVWHAqeYVWxqCAXiGS2amrxZcKqqqtER4kdEL
e0PUGO7mR4RdYaUfRcyREii4kXOHbSllBE0iJAjQoDwI95YAquZX7OggywC60RI5A8QvKBnW8hIi
SD2kCEcItWAeDKEiRIQeY1AqCXFWTR0odmRHZLO4PmiWSZ7EjWR7onC5ykdB5/CHSDeg4YbZRGBR
gUBYUI0Bip5QihQIkFigjMk25CFw9ohYPBZJ0FCnSfqK1LChST12UTbe+AcfABwhSJaDCaTzC0GS
Qfxj6g2R+O9bvikbRBtO9/+fyNOCCZh50fEbbYE/JPvpSpD1EWgCKQynnP+Gq2M9B3HmEzuvZvwO
FI/OJsoom5Ln0KF4B9hBDv+c938ZYIMh5Zhc9u0gaxo0GNFSgUA87RS1ncn+pRtGXCIWlREiwJ7G
+Esk/L4g7k9KP1xLwyfBuWH9e/hcIj4ly/a1USGP6U9KySYfPWbnUse8M6h5A+Hdbk/AP8bT4vGF
0htEzb0H9AUlCRSkCKqKQAgtgHgESXbjaKHqCC9+bepjhJkO2D5gS5Pn4J7HKzyoi0icUJAWBGSr
vcR1geQ94B8gpYNywvLwiNyD5jTQPePWCWxQ+9BtO1YHFC0AzoG0Eoh7hNQ6UahF3+WUig4MSqSS
+s/DfWYU2kDaQGRk+wC1BBV9gBiwUtC8IvQGDHwPiIbTcB5QDYlh4G87wKoOV3hEifcjmLQC4vkn
nfwLS9P+KULW71iniHaonQIHJ+QA2HuQfiJqFDrGwRLBe9XpV8hdqn8EMsCp7T6wOUU3x+D4xDZR
SDOU8waSotyBYNosiwMwpEsk8b3vgpdiiUolOkh981XKTim65sETIjfXkXeH3wO55z1LLOYL7y+o
VqNRNozCgiBuwhlr9V2JdptA2Nibk0wkJG5EZjJmapCFNq+3bwmw3VJVPGZ/1T8uKI7j67jWPYk6
5WJVlLASPXEd8BOC22SxT+iAAEC294ETgESdKv+f83q/DS+8fl0ajoT/WqGLmTE9OOG+10cg5SXQ
hyUClRETLAGofBzKcQAF30x/drfkGPYLQCqEg99ZPhekueeOWkUXwW9EVNhbglxI2fufssT11JZD
4NrOCywX9whsFLtvUUE+wDsjFBGCiJQOhQFNaMCQYvw2vVOQ3yVoBv9nIUrjDzEbMWtU401kalrQ
tMjORV6H4uPq5B/UnSb1VRNe9CXtDcYyqGMAj5SgDSUE+saPkjXOtgiXiJiIlV1wIkQCBESpSFIi
ikIlIVSG/t877EPt7jwWEThNomntIxIkIJA/LB6fFcCq+/aI/oH8C+3qj0KFIRU5+0JB4tVz4eye
ejHnbeurAdScXAeLEuXpOg6qwZCbAGlK9VbbCsyDk6c0XOUpBYPjTVqM4ibRwETfRSlpVpWLEoYh
0a/UdAQgQIIk5ALlcmgJoVQMvIcBYc5sWUspZJCkKUrX534nH+ZsS8pppXdDzo4EdikfPE3z7o0Q
XfVIbr7+rcxmY24OZbme40QPmIf4YE94h8XgQPgId/zrzCFymcAm/B0gZfAW05BAt+dQdgn6kaC/
UW9Jp4glE6S1tZzuN14WkC6HCXu6SD69ERwI6vKjxh0DmRxQ9xxeUTKofclmhJddWqpNXUPWj9S0
KDA6VMitv6xMhnAYAApf5VBGvmFPzH5kgUVKNglBlIlGwSxKRLBCgJRsEpGFgJZElgJYlIlghZEs
SkSxKRKDKRLBCyJYlIlBlkSjYJYIWRKNglIwsiUbBKDLIlBlkSjYJRsEoMsiUGWRKRhZEpGFgJSM
LIliUiUBkoCUgwKQSjQSwQoCWJSJQZQSjYJSMKCUaCUaecRNXOeAmrIEnSeoC46BKK+0SvPq6znB
N5EB4w8aP2nQIcqPEa0vGcwhJSlKUiW0EZUEKCIOQyA/NMhhO4LtZtHyCI+MPqmQ4QenskSTg6hk
iPGBiCJxIwETYKHAq26QQ/J3u+mr5U9P63arAgnN2BOo38Vgztz8Yc4ATYbSCoAbdAeaeeJGkFVo
SNCAQrVBqIsFV5s0YkeuxQsY4oMBEoKrEd5A/mO9xLbxS5xNY94eR+gji2kA5SIcOyiUgF6VSiTS
oyD2Q15DuLJZN5HuDA9AYZ+yQ70nk/OCikKZ943oj9Gm8jvjcUmqGk1PwkkiKOZTXRX5TrF15XSP
08xv4o6ZdS2Hy4tQr0D8ERa9POiNoL1B8RYUgUF3gyIcGjfN1E1w6owj+xhSJKsIIlGkoMSksPUU
wOo5ENdhvd11qGodxlJMSXDtJJ3JmiPuTqDKO1FVAPMbUae09CrRHgQftRgmQ8cOUkmPSUdRRdLu
FoXM1iJZPbE68lHam8qfvnwvxbSh7yQrFQQRk8snLI/HNBgqnkOotwtToLQ+GGoQ+H/gTmRyGESc
9B1qgb6fa+CcDgdM10sOQJlJUiDnXkj45J2PYyRjn+QTwXugcSfA8xS5FMaNBEzRouhPTB7k5CBy
j5Io4RhCQokBIwFqFRPHupVkkGKjb/GsZe0qxjY5x14I8VPde0cUpiHciLkjbisiM/1j4omreQ4N
wmaI0eCNia0iPlQZIOMeg85HBEb1EqnihzJHFN06CIpYyH9BzWj/XTLyN+n6Dr6obOSTsjOdZ96P
cXFH0q2iZ/MRckOhCSRTUFaAFUqB2jMMdMpQWFpUPPIJYmEMIhmawwSXRSaQYikHRlyDvGSGogX6
HWXarS4asYjCYAYkTwIB1hBCkC2hcIUIlSn8jz8dS1RY5yFBEpQ9aHxE3PCQ8A/YJsewHsTZJm5Q
604pJJwjaLQROucECMuHzr6jfxAyASW0J+SMtnleAMAh/hQxS8hAsCEPrwtGwVWHx+orloUNA+49
unYuxw56K0oCJQALzvFN+odg20krvkCpKyFQcswkzVcHaFDNQIQXiypKlKyK+BZC0hmyM/qhe5QC
KqJIjIkQOkoNB6FbqpxoBJCVRjomSs7SXRFuI0SHjwhcqNf0EpIjfCFVIV9SKGkJdD1TsiLwi/Yd
NSmha1gwfpQWT9yGLIEjHzg/2Dwwjkd+I/ZOTEk2d8n6pN7xv7PvotwZUpfPhKROGAJ+ddRzppcV
dC7ous7wKK53hCnCNsNYHqFxEXcF62LeojfCSCmfcIG/I2mRXLLGCA70knxJsbtrIg1CVKDAoe0A
gpgkEUtCxGilo2DRUQsCMqyqKFGF9ijRetFLKiq1AgpSgNRrBIqo3BmDSjC52CWjcEjGIxIMSKAS
IsAYILCgQFqGYvV5RMbBVeMSZfEHZ8h6DbUhuJ1iJF4IA8pEcsPaTxQLdtDI5WEyjKfkc2EkIWhL
pzmQM4YBiSHsR96h3H92J+ET1/xCerk8XF3k8gdz6P4SNEz/N3BSHnjCDCNBTJgNgb+/CBCSS8LR
61Xs0+ne/M6HPKR8EN8eWIqPy2Q8w4PbHUJBVHXkKC8MGrUYQKBbyoNwiarFbVaMLihpdUf0CWID
O1axDIEkRkQKMF2kUoRFQNtyfgIXbT6X7CVsAnuh6zHpES0QxTcZzQrcK2KKG8lVBLAEI9wfFgEt
RYAjBiCkkFgQhBFIQi7gTYfYMAkK38ESDuh/IkhUmHXufuWtKJpESnHiX/PfZ80iWXoK7llBAWKz
VtoSFmJKR1NSgZWiSAVIlChQBfEjBEqz9IwFRwUHwi8gSgTBr3dElArcPoAQUzB59auQuQUuTQw9
CtdAJVAAr2zBBLq1B2jAzA8y2v3bhek0kIcWUbh4j1eUrs2bDYHAUTuuD2BDP2JO84zkiNRxETvE
1cAoQCEdaPYUqviXcYHOG+gZEdIIZTzI8Os0kEFFZYWLPZ89D8DD+GblA3GEIylnrUFgz8aChuci
QnMDDjOySJ8hT0lDoiPK3H2J/faxNXh+CLCRBvcpUEsMgEIKDBGJnFUyjYm5o+AiUFVggjHvGF6+
wb0PhJeAidoggh8Ui5LSimzA0RE3wRBy4DURLveoedH3BxRd1EPImbmm0l4POh5Ywk6TozTLx5kG
kOxnJ+9G62SpNeqyvn3C0/GjZvK/g+mTki8jCkO5I9Amh2VOTk8cj8ZiTw86I7SMMcdo2kFjhs5I
ezzQ8wef4hvThDi4p++MrofQj2ehFJOUcnezlRaUbbfmjMxRKd0PIcQnsAPtJD1hpD52hqHBHleC
HwR50YicCkM+XfW1aUlGhM6NaErei4CQvF6BL0eMAxRyqIegW0VRShtQ5xyIFB+Cr4AmoIbnMRiK
LE++WVVVVRVWKqixYKiKgqKqgqirGKqqqqxQVVVVVRUVUX37VVVtq36bRMGQoSKr3ectgpANtTCf
pgn1mQooIMZxLC7glpKVGAJFNOe9Q0iQWCJlqBBjLSwGJGQK6EznLIUlQPgjkScBZWMEGJ+stuFA
+Z5BExk2TQmTQGoZo1JITfdGCi6JVj4huu9i0WSYFEIJICA02KiGKEZGJIgCQ9BwmyF7rRLeeNrI
jB5hNImkT6EepPpcg9jaE0Tl3ud71YtaGJUJQlgBQUVUJEf2MLkheSksrEqCLyIgqXF5FgqPoI+L
HfPBGechE+9PlW5tbUW73iJgInCt6trdEUT2Aam0o7gR4s6BliCRl4FAaISQOgTqsw552zklRcxd
epUxPCLG5/jcyxPUaas6FQA+HWNKmO+HdjzhP2/th8P62SiQp9Uf4P1yi4VVP54P8MFBQUKFSVJx
u+weRb4kOZ5w4BEikFVisEEan0Md4tpXWpZF7Wmajxx5YbjR51Ukpv2e5d+fi/cbz+dUD7T9jse/
74/e56wE4Fvn/5c6cWm+844wpmAylMuVI4qGCNCo3d0HhoL/WrURMoiUARN8UQekFBSbT2v5k47J
vqTrF5IKecMnoG8bFTn+OewRMjCiBkPl+YUwLUbBetG4BTUTqBS1gqQS4uArUcVsnWpQH1+CkE16
UuRG5WlHtHwxDhKghufsANDoFbiKfbQIwhA1DIIqyQkk0qSCESSLCeWRHAKEUustRIyKspFKTqRS
inO3q8BgW1EnvDkVxLxlqiUosEiRGgolPgA8AB3mAqtxBkQZJAZESRZCCkkgQQfX6vV9Aviz5UWv
ylhMaen519rjeotx28s19soe915qaELHCgGNIfD84ZdGJ8KuJ8+CUrRKEhrpweA/dc+gn+K32CCl
1q1WNWj5Fm/fvJIlCrxrJ15QuMGfKgvBIksBuRJZToIyrD10HuHcP2B4ZMmSyyRP4BrKSVxJYBQ3
XYN2XnOSWgrEqoUWkGeBeC4ViUsCtZg+6VGzWO1jZFOpn/GWNaaD0PyR/Kj0vH+AP5BPmia9t+Z2
pzYlqiQS2skB1g88qO0RMLWGuT5D5CS9ETgTdJKqBoebhlVmEtxtJnIqDwn0mbBgjNCDGLBInyOf
9JcNhJLR0aLgz9WjPBE1Ba2Eojem6q+mpnEZTVvoqaUtPkRgOEX855kdSqg2CwTpzEiwjIyEiqki
gopFAUFAUUFixEEZBSCIoIgoCiCApBQRYsY+UVXHIK2rmDhtbcBVsdF4vACq2caEHc7xiKrmUyZQ
TtEzoFc5SwB7ZBYoLFBSLFkWRQWCgoKCwUFgsWCxYLFgsFixYLBYLFgKCkUBRSKCixRSQyLBtPGr
n4DvM5+YXlvzAxOQ0ugconSZhDbALBPvFAU6cJgGIfqP8ZVbbcTlMgVUmu6OlTFBaipFFIj+cLEf
ZfzS9mJQG77g4boitqMASXWnNYNYjWBfEBgwQhJQCw6AYgoQlEm4GWCFbbgMSwgCkURgsYpIDIMk
WSJFgMSRlI0JDPgNj7jsfaNbaUUE+ePmGNLJ+vVmUqw2Exh/EhrXIM6EnUAUDOEqmdzaA2qCP1tv
rcgaEPlKpRg0LDj9+//iBALH42d/0OeMLphg/sPMn2gPbc5X0qbSB0qR7eg2D1an42fl7tt6Q6Ou
l6+28Jie+ymBvMp9gcctc+t9o+XXIpnQw7LGAqRgIwMBNJbSBTsO78GlCdUCG/Pbngbn5ssKAxcK
ee/KQRlQ4goGKCiKxbqHOI6J0olRZo8XrBxbNJdDigloektPCE7CQ5TngnLUjxow0WEoLNwUYUZS
dwWLLKVa0WLCyjZm2YZsnKywXcbE4JwEoFWIIgKiCMhNSKxBjKTcmSYRO+CQhTkbjYiIUOJy5tzS
feyE86PuMfSFRPqzh8EjY6pXKZ1KksutLXpUXs6rwb5EZMqLpykTieUBKVRVKAJCKNbEqMjVBQLC
Ai2byarQLhVYGsVWjBVaUV2gboKjy+RxLl11pO63LkaptJI/xUqkFotAPSCfMj5jObwRWR9Rnf2u
KIWAHNBnSSTeUdkRhLIO9sgvOWc781V31pDEoFm1XlLODBKHWO6aLEUNIufH97KoORpRSNRjbzCJ
kWwCCQWDEgEAIAQYRhBWJJLQUALMGRyjoMx1Q+pnyn2AoeQnwQ1uxRRRdg2BjKyfQFzdMpaCq5AB
4vejmHtQdIbO3YFvHQqocRlFfMQiySRoI8RcKfnWwlpR84mF6tTc+Qplypa0ETIuuigQR0cwiUol
A9DcRHqZnRl6YaycMnq52lqpScVrNGL3KChYFBjLLJRCMKMG6BkskTeJFk9sPyttUfc4Ie50OT5k
HwT9o6xGkXRAaBInxNo3lcQt1mwTYpSSMjIKDCMgIWKiOiloSyZBEpBEhBE3gEPoIKCCWjbsR8qo
GBisaCCRsJFESiB6e3yn5Q6GwdiScFEiwaiotEqDMWkjvkwRJi+/qovXTPIxJSj9zwZs8R0/EjRC
J0DREabC39PvkgoSEKqEUKkpRSIVGH1wIJuyvnqGCikHhNXp7gLd/hOwlNTqjCEQUlK4lAfhzKUD
kklrAkX3xOGxDXA9RmWLaPtE18IYGyHuaVCukfci1R+lHpQsE0ABzFRNvehed6r3D4CF3O/QHWAd
Cg2eRH8/QMCIXLsVkPYAHBBpGZKIUiw0EaCUpQIeVCiJ9KiH3IPoYQSISk4qk+JUfEGRIkjxqb3G
J0D7X1MEcdFgvfqEiiYm8xSDIRJUT74r5SCABzcSUBdAkDwExHMPYvePjJCnGfHeqWnjniVqH+B5
oSj7kPKwCgFhFcxDSHziWipSpA+pJQJaNWq13aeCLRrDKIexGnVubiiqnAK+1SBTtuAomVDSQ7+G
FC75i85RcQtenkgQSEgdB9SCRtKhQFgXrkFPATaKdo8/qYGcT7gsE9alSQZyE8JJmbnE/JHCQ8Tt
Qr32jx8mWBD9RSlpX5SwsU6KeKD2wsBj5ngQOsMwn6DR6/GKIJkMBtlh6pJLDNB7TtrQsLg1GCqu
2wYlaCJFTMk9SPYFT0ABcBiFBn8C8FVwE93Aj2o/SuTgXgH1gHzgBnVfOKcp+b7PkE7UHzHtFh8o
B79iZQTqR7heAQwA4AU8rEtPMjyUEPEoeG4D9KG+H9xHyDdPnHsiO8el6+/OJXvRicvmCRvqG294
K/qnVE65sFImjuD21Gm1T1IZSRRxky+inuqc0aI9aNYMdbROLwDsDuFPlORQb0ewTjQDyC9IvW5V
B6EtGFIfHE4/LE+BHPv4HRO9JdPxU5Ejsh7m5yifUPSdGuEe9DtE8sh59o/hGkUkSIYq+gToqiKG
nvFxFONHMbkHuD0pDiRy6Kw325C0GLUx47F0RV5KrKlKWeOSMKHt4Nb6iGTcoZ8MuMUMEZqSiYWB
7OgpZGEmEIc99EIakoSzMlrIil3yuiHMY9cIeWGyLs8gKdGMgiJAUEFIpGCIjFGQkjIRkn0Ajkgv
PZmU1YmUTC4SBuAnp7OUT8g7UG1H15lDjVs7+cQxNX3BACSQEAWKCwSDEjAGMAAASKhVCpVRFK8C
PMdmck2RygeRH1AnyLzNeUZDhCwOdHoR7A7wMguBYLgp8aO9z8xGSHvSLyEunDekUeirwgpYWfS+
g8iPbHjNRyB7RPQiPQHZOId6KRkG7qNkeh9tKfzWlqlVKlSRhFImoYCfP+BT3Whd85YVkCQiJfEV
UFiwVRRVVFYgqgopBGEFRIIkRBIp1LZJAD4pdMTKT/wjNTYkkmB+/8zwcSURoIw0YY6w7K+KvOsk
lEu3BTP/t1Y8xSAwgw8hnxztMm8noYqIooskWfzMgVFIKKAsiIKCk70UIn1UzJYef2buV+Tb0606
Gob04d11Vo+zCrHbWZWxYLyy5lqsN0NDnKznou+1vGZpKlay1LRFY72wUWsq7t5XbJUS8YSu2oBD
vJ1GcFrelMRFUe4Ze6Wf/xdyRThQkP9ZFJo=
