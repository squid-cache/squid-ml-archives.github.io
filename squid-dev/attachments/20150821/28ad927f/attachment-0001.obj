=== modified file 'src/Debug.h'
--- src/Debug.h	2015-08-11 06:15:34 +0000
+++ src/Debug.h	2015-08-21 16:02:31 +0000
@@ -1,109 +1,109 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 00    Debug Routines */
 
 #ifndef SQUID_DEBUG_H
 #define SQUID_DEBUG_H
 
+#include "mem/forward.h"
+
 #include <iostream>
 #undef assert
 #include <sstream>
 #include <iomanip>
 #if defined(assert)
 #undef assert
 #endif
 
 #if PURIFY
 #define assert(EX) ((void)0)
 #elif defined(NODEBUG)
 #define assert(EX) ((void)0)
 #elif STDC_HEADERS
 #define assert(EX)  ((EX)?((void)0):xassert( # EX , __FILE__, __LINE__))
 #else
 #define assert(EX)  ((EX)?((void)0):xassert("EX", __FILE__, __LINE__))
 #endif
 
 /* context-based debugging, the actual type is subject to change */
 typedef int Ctx;
 Ctx ctx_enter(const char *descr);
 void ctx_exit(Ctx ctx);
 
 /* defined debug section limits */
 #define MAX_DEBUG_SECTIONS 100
 
 /* defined names for Debug Levels */
 #define DBG_CRITICAL    0   /**< critical messages always shown when they occur */
 #define DBG_IMPORTANT   1   /**< important messages always shown when their section is being checked */
 /* levels 2-8 are still being discussed amongst the developers */
 #define DBG_DATA    9   /**< output is a large data dump only necessary for advanced debugging */
 
 #define DBG_PARSE_NOTE(x) (opt_parse_cfg_only?0:(x)) /**< output is always to be displayed on '-k parse' but at level-x normally. */
 
 class Debug
 {
 
 public:
     static char *debugOptions;
     static char *cache_log;
     static int rotateNumber;
     static int Levels[MAX_DEBUG_SECTIONS];
     static int level; ///< minimum debugging level required by debugs() call
     static int sectionLevel; ///< maximum debugging level allowed now
     static int override_X;
     static int log_stderr;
     static bool log_syslog;
 
     static std::ostream &getDebugOut();
     static void finishDebug();
     static void parseOptions(char const *);
 
 private:
     // Hack: replaces global ::xassert() to debug debugging assertions
     static void xassert(const char *msg, const char *file, int line);
 
     /// Wrapper class to prevent SquidNew.h overrides getting confused
     /// with the libc++6 std::ostringstream definitions
     class OutStream : public std::ostringstream
     {
-        // XXX: use MEMPROXY_CLASS() once that no longer pulls in typedefs.h and enums.h and globals.h
+        MEMPROXY_CLASS(OutStream);
     public:
-        void *operator new(size_t size) throw(std::bad_alloc) {return xmalloc(size);}
-        void operator delete(void *address) throw() {xfree(address);}
-        void *operator new[] (size_t size) throw(std::bad_alloc) ; //{return xmalloc(size);}
-        void operator delete[] (void *address) throw() ; // {xfree(address);}
+        void *operator new[] (size_t size) throw(std::bad_alloc) = delete; //{return xmalloc(size);}
+        void operator delete[] (void *address) throw() = delete; // {xfree(address);}
     };
 
     static OutStream *CurrentDebug;
     static int TheDepth; // level of nested debugging calls
 };
 
 extern FILE *debug_log;
 
 size_t BuildPrefixInit();
 const char * SkipBuildPrefix(const char* path);
 
 /* Debug stream
  *
  * Unit tests can enable full debugging to stderr for one
  * debug section; to enable this, #define ENABLE_DEBUG_SECTION to the
  * section number before any header
  */
 #define debugs(SECTION, LEVEL, CONTENT) \
    do { \
         if ((Debug::level = (LEVEL)) <= Debug::Levels[SECTION]) { \
             Debug::sectionLevel = Debug::Levels[SECTION]; \
             std::ostream &_dbo=Debug::getDebugOut(); \
             if (Debug::level > DBG_IMPORTANT) { \
                 _dbo << (SECTION) << ',' << (LEVEL) << "| " \
                      << SkipBuildPrefix(__FILE__)<<"("<<__LINE__<<") "<<__FUNCTION__<<": "; \
             } \
             _dbo << CONTENT; \
             Debug::finishDebug(); \
         } \
    } while (/*CONSTCOND*/ 0)

=== modified file 'src/ExternalACLEntry.cc'
--- src/ExternalACLEntry.cc	2015-01-13 07:25:36 +0000
+++ src/ExternalACLEntry.cc	2015-08-21 16:32:41 +0000
@@ -1,51 +1,48 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 82    External ACL */
 
 #include "squid.h"
 #include "ExternalACLEntry.h"
 #include "SquidTime.h"
 
 /******************************************************************
  * external_acl cache
  */
 
 ExternalACLEntry::ExternalACLEntry() :
-    notes()
-{
-    lru.next = lru.prev = NULL;
-    result = ACCESS_DENIED;
-    date = 0;
-    def = NULL;
-}
+    result(ACCESS_DENIED),
+    date(0),
+    def(nullptr)
+{}
 
 ExternalACLEntry::~ExternalACLEntry()
 {
     safe_free(key);
 }
 
 void
 ExternalACLEntry::update(ExternalACLEntryData const &someData)
 {
     date = squid_curtime;
     result = someData.result;
 
     // replace all notes. not combine
     notes.entries.clear();
     notes.append(&someData.notes);
 
 #if USE_AUTH
     user = someData.user;
     password = someData.password;
 #endif
     message = someData.message;
     tag = someData.tag;
     log = someData.log;
 }
 

=== modified file 'src/HttpHdrRange.cc'
--- src/HttpHdrRange.cc	2015-03-05 06:44:43 +0000
+++ src/HttpHdrRange.cc	2015-08-18 10:16:03 +0000
@@ -18,62 +18,60 @@
 
 /*
  *    Currently only byte ranges are supported
  *
  *    Essentially, there are three types of byte ranges:
  *
  *      1) first-byte-pos "-" last-byte-pos  // range
  *      2) first-byte-pos "-"                // trailer
  *      3)                "-" suffix-length  // suffix (last length bytes)
  *
  *
  *    When Range field is parsed, we have no clue about the content
  *    length of the document. Thus, we simply code an "absent" part
  *    using HttpHdrRangeSpec::UnknownPosition constant.
  *
  *    Note: when response length becomes known, we convert any range
  *    spec into type one above. (Canonization process).
  */
 
 /* local routines */
 #define known_spec(s) ((s) > HttpHdrRangeSpec::UnknownPosition)
 
 /* globals */
 size_t HttpHdrRange::ParsedCount = 0;
 int64_t const HttpHdrRangeSpec::UnknownPosition = -1;
 
 /*
  * Range-Spec
  */
 
-HttpHdrRangeSpec::HttpHdrRangeSpec() : offset(UnknownPosition), length(UnknownPosition) {}
-
 /* parses range-spec and returns new object on success */
 HttpHdrRangeSpec *
 HttpHdrRangeSpec::Create(const char *field, int flen)
 {
     HttpHdrRangeSpec spec;
 
     if (!spec.parseInit(field, flen))
         return NULL;
 
     return new HttpHdrRangeSpec(spec);
 }
 
 bool
 HttpHdrRangeSpec::parseInit(const char *field, int flen)
 {
     const char *p;
 
     if (flen < 2)
         return false;
 
     /* is it a suffix-byte-range-spec ? */
     if (*field == '-') {
         if (!httpHeaderParseOffset(field + 1, &length) || !known_spec(length))
             return false;
     } else
         /* must have a '-' somewhere in _this_ field */
         if (!((p = strchr(field, '-')) && (p - field < flen))) {
             debugs(64, 2, "invalid (missing '-') range-spec near: '" << field << "'");
             return false;
         } else {

=== modified file 'src/HttpHeaderRange.h'
--- src/HttpHeaderRange.h	2015-05-26 09:18:13 +0000
+++ src/HttpHeaderRange.h	2015-08-19 06:54:23 +0000
@@ -1,61 +1,61 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
 #include "mem/forward.h"
 #include "Range.h"
 #include "SquidString.h"
 
 #include <vector>
 
 class HttpReply;
 class Packable;
 
 /* http byte-range-spec */
 
 class HttpHdrRangeSpec
 {
     MEMPROXY_CLASS(HttpHdrRangeSpec);
 
 public:
     typedef Range<int64_t, uint64_t> HttpRange;
     static int64_t const UnknownPosition;
 
-    HttpHdrRangeSpec();
+    HttpHdrRangeSpec() : offset(UnknownPosition), length(UnknownPosition) {}
     static HttpHdrRangeSpec *Create(const char *field, int fieldLen);
 
     bool parseInit(const char *field, int flen);
     int canonize(int64_t clen);
     void outputInfo( char const *note) const;
     void packInto(Packable * p) const;
     bool mergeWith(const HttpHdrRangeSpec * donor);
     int64_t offset;
     int64_t length;
 };
 
 /**
  * There may be more than one byte range specified in the request.
  * This object holds all range specs in order of their appearence
  * in the request because we SHOULD preserve that order.
  */
 class HttpHdrRange
 {
     MEMPROXY_CLASS(HttpHdrRange);
 
 public:
     static size_t ParsedCount;
     /* Http Range Header Field */
     static HttpHdrRange *ParseCreate(const String * range_spec);
 
     HttpHdrRange();
     HttpHdrRange(HttpHdrRange const &);
     ~HttpHdrRange();
     HttpHdrRange &operator= (HttpHdrRange const &);
 

=== modified file 'src/HttpRequest.cc'
--- src/HttpRequest.cc	2015-08-04 19:57:07 +0000
+++ src/HttpRequest.cc	2015-08-21 14:36:04 +0000
@@ -8,98 +8,115 @@
 
 /* DEBUG: section 73    HTTP Request */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "dns/LookupDetails.h"
 #include "err_detail_type.h"
 #include "globals.h"
 #include "gopher.h"
 #include "http.h"
 #include "http/one/RequestParser.h"
 #include "HttpHdrCc.h"
 #include "HttpHeaderRange.h"
 #include "HttpRequest.h"
 #include "log/Config.h"
 #include "MemBuf.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
 #if ICAP_CLIENT
 #include "adaptation/icap/icap_log.h"
 #endif
 
+// keep initializers in sync with init
 HttpRequest::HttpRequest() :
-    HttpMsg(hoRequest)
+    HttpMsg(hoRequest),
+    method(Http::METHOD_NONE),
+    range(nullptr),
+    ims(-1),
+    imslen(0),
+    dnsWait(-1),
+    errType(ERR_NONE),
+    errDetail(ERR_DETAIL_NONE),
+    peer_login(nullptr),
+    peer_host(nullptr),
+    lastmod(-1),
+    vary_headers(nullptr),
+    peer_domain(nullptr),
+    forcedBodyContinuation(false),
+    rangeOffsetLimit(-2) //a value of -2 means not checked yet
 {
-    init();
+    memset(&flags, 0, sizeof(flags));
 }
 
+// XXX rework to use initializer list to avoid rewriting same memory so many times
 HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
     HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
-    debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
+    debugs(93,7, "constructed, this=" << this << " id=" << ++id);
     init();
     initHTTP(aMethod, aProtocol, aUrlpath);
 }
 
 HttpRequest::~HttpRequest()
 {
     clean();
-    debugs(93,7, HERE << "destructed, this=" << this);
+    debugs(93,7, "destructed, this=" << this);
 }
 
 void
 HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
 {
     method = aMethod;
     url.setScheme(aProtocol);
     url.path(aUrlpath);
 }
 
+// keep in sync with default constructor
 void
 HttpRequest::init()
 {
     method = Http::METHOD_NONE;
     url.clear();
 #if USE_AUTH
     auth_user_request = NULL;
 #endif
-    memset(&flags, '\0', sizeof(flags));
+    memset(&flags, 0, sizeof(flags));
     range = NULL;
     ims = -1;
     imslen = 0;
     lastmod = -1;
     client_addr.setEmpty();
     my_addr.setEmpty();
     body_pipe = NULL;
     // hier
     dnsWait = -1;
     errType = ERR_NONE;
     errDetail = ERR_DETAIL_NONE;
     peer_login = NULL;      // not allocated/deallocated by this class
     peer_domain = NULL;     // not allocated/deallocated by this class
     peer_host = NULL;
     vary_headers = NULL;
     myportname = null_string;
     tag = null_string;
 #if USE_AUTH
     extacl_user = null_string;
     extacl_passwd = null_string;
 #endif
     extacl_log = null_string;
     extacl_message = null_string;
     pstate = psReadyToParseStartLine;
 #if FOLLOW_X_FORWARDED_FOR
     indirect_client_addr.setEmpty();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
 #endif

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-08-03 03:50:25 +0000
+++ src/Makefile.am	2015-08-21 14:09:15 +0000
@@ -1115,148 +1115,150 @@ tests_testACLMaxUserIP_SOURCES= \
 	store_dir.cc \
 	StoreIOState.cc \
 	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
 	StoreSwapLogData.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
 	swap_log_op.cc \
 	swap_log_op.h \
 	tests/stub_SwapDir.cc \
 	SwapDir.h \
 	Transients.cc \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_client_side.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_errorpage.cc \
 	fd.h \
 	tests/stub_fd.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_HttpReply.cc \
 	tests/stub_ipc_TypedMsgHdr.cc \
 	tests/stub_libauth.cc \
 	tests/stub_libcomm.cc \
 	tests/stub_libdiskio.cc \
 	tests/stub_libformat.cc \
+	tests/stub_libmem.cc \
 	tests/stub_libsslsquid.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	repl_modules.h \
 	tests/stub_store.cc \
 	tests/stub_store_client.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_store_swapout.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_UdsOp.cc \
 	tests/testACLMaxUserIP.cc \
 	tests/testACLMaxUserIP.h \
 	tests/stub_time.cc \
 	url.cc \
 	URL.h \
-	tests/stub_libmem.cc \
 	MemBuf.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testACLMaxUserIP_SOURCES= \
 	$(TESTSOURCES)
 tests_testACLMaxUserIP_LDADD= \
 	libsquid.la \
 	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testACLMaxUserIP_LDFLAGS = $(LIBADD_DL)
 ##tests_testACLMaxUserIP_DEPENDENCIES = \
 ##	$(SQUID_CPPUNIT_LA)
 
 ## a demonstration test that does nothing but shows the salient points
 ## involved in writing tests.
 tests_testBoilerplate_SOURCES = \
 	tests/testBoilerplate.cc \
 	tests/testBoilerplate.h \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	tests/stub_cbdata.cc \
 	tests/stub_MemBuf.cc \
 	$(TESTSOURCES)
 tests_testBoilerplate_LDADD= \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testBoilerplate_LDFLAGS = $(LIBADD_DL)
 tests_testBoilerplate_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests of base/libbase.la objects
 tests_testCharacterSet_SOURCES = \
 	tests/testCharacterSet.cc \
 	tests/testCharacterSet.h
 nodist_tests_testCharacterSet_SOURCES = \
 	base/CharacterSet.h \
 	$(TESTSOURCES) \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc
 tests_testCharacterSet_LDFLAGS = $(LIBADD_DL)
 tests_testCharacterSet_LDADD= \
 	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 
 ## Tests of the CacheManager module.
 tests_testCacheManager_SOURCES = \
 	AccessLogEntry.cc \
 	debug.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	String.cc \
 	tests/testCacheManager.cc \
 	tests/testCacheManager.h \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_EventLoop.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
@@ -1638,60 +1640,61 @@ tests_testDiskIO_LDADD = \
 	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
 	mgr/libmgr.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	dns/libdns.la \
 	base/libbase.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 tests_testDiskIO_LDFLAGS = $(LIBADD_DL)
 tests_testDiskIO_DEPENDENCIES = \
 	DiskIO/libdiskio.la \
 	$(SWAP_TEST_DS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_testDns_SOURCES= \
 	tests/testRFC1035.cc \
 	tests/testRFC1035.h
 nodist_tests_testDns_SOURCES= \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_SBuf.cc \
 	tests/stub_tools.cc
 tests_testDns_LDADD= \
 	dns/libdns.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SQUID_CPPUNIT_LIBS)
 tests_testDns_LDFLAGS= $(LIBADD_DL)
 
 tests_testEvent_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cache_cf.h \
 	AuthReg.h \
 	YesNoNone.h \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
 	CachePeer.cc \
 	CachePeer.h \
 	cache_manager.cc \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
 	client_db.h \
@@ -2400,75 +2403,75 @@ tests_test_http_range_DEPENDENCIES = \
 
 ## Tests of parser/* objects
 tests_testTokenizer_SOURCES = \
 	tests/testTokenizer.h \
 	tests/testTokenizer.cc
 nodist_tests_testTokenizer_SOURCES = \
 	parser/Tokenizer.h \
 	$(SBUF_SOURCE) \
 	SquidString.h \
 	String.cc \
 	$(TESTSOURCES) \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
 	tests/stub_time.cc \
 	tests/stub_SBufDetailedStats.cc
 tests_testTokenizer_LDFLAGS = $(LIBADD_DL)
 tests_testTokenizer_LDADD = \
 	parser/libsquid-parser.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 
 tests_testHttp1Parser_SOURCES = \
 	Debug.h \
 	MemBuf.cc \
 	MemBuf.h \
 	tests/stub_MemObject.cc \
-	tests/stub_libmem.cc \
 	mime_header.cc \
 	mime_header.h \
 	String.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	$(SBUF_SOURCE) \
 	tests/stub_SBufDetailedStats.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_comm.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_event.cc \
 	tests/stub_HelperChildConfig.cc \
+	tests/stub_libmem.cc \
 	tests/stub_libsecurity.cc \
 	tests/stub_stmem.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/testHttp1Parser.cc \
 	tests/testHttp1Parser.h \
 	tests/stub_time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttp1Parser_SOURCES = \
 	$(TESTSOURCES)
 tests_testHttp1Parser_LDADD= \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	anyp/libanyp.la \
 	SquidConfig.o \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttp1Parser_LDFLAGS = $(LIBADD_DL)
 tests_testHttp1Parser_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests of the HttpRequest module.
 tests_testHttpRequest_SOURCES = \
@@ -2693,79 +2696,81 @@ tests_testHttpRequest_LDADD = \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpRequest_LDFLAGS = $(LIBADD_DL)
 tests_testHttpRequest_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 ## Tests for icmp/* objects
 # icmp/libicmp-core.la is used by pinger so SHOULD NOT require more dependancies! :-(
 tests_testIcmp_SOURCES = \
 	tests/testIcmp.h \
 	tests/testIcmp.cc
 nodist_tests_testIcmp_SOURCES = \
 	icmp/Icmp.h \
 	SquidTime.h \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	time.cc \
 	globals.cc
 tests_testIcmp_LDFLAGS = $(LIBADD_DL)
 tests_testIcmp_LDADD=\
 	icmp/libicmp-core.la \
 	ip/libip.la \
 	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 
 ## Tests for ip/* objects
 tests_testIpAddress_SOURCES= \
 	tests/testAddress.cc \
 	tests/testAddress.h
 nodist_tests_testIpAddress_SOURCES= \
 	ip/Address.h \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_tools.cc
 tests_testIpAddress_LDADD= \
 	ip/libip.la \
 	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 tests_testIpAddress_LDFLAGS= $(LIBADD_DL)
 
 ## why so many sources? well httpHeaderTools requites ACLChecklist & friends.
 ## first line - what we are testing.
 tests_testStore_SOURCES= \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	ClientInfo.h \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	ETag.cc \
 	event.cc \
 	EventLoop.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
@@ -2898,75 +2903,75 @@ tests_testStore_LDADD= \
 	acl/libstate.la \
 	acl/libapi.la \
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	mem/libmem.la \
 	DiskIO/libdiskio.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testStore_LDFLAGS = $(LIBADD_DL)
 tests_testStore_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 ## string needs mem.cc.
 ## mem.cc needs ClientInfo.h
 ## libsquid pulls in SquidConfig and children. stub them.
 tests_testString_SOURCES = \
 	ClientInfo.h \
-	tests/stub_libmem.cc \
 	MemBuf.cc \
 	String.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	tests/testString.cc \
 	tests/testString.h \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
+	tests/stub_libmem.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/stub_time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testString_SOURCES = \
 	$(TESTSOURCES)
 tests_testString_LDADD = \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testString_LDFLAGS = $(LIBADD_DL)
 tests_testString_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
 SWAP_TEST_DS =\
 	repl_modules.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -3131,60 +3136,61 @@ tests_testUfs_LDADD = \
 	acl/libacls.la \
 	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
 tests_testUfs_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
 check_PROGRAMS += testRefCount
 testRefCount_SOURCES= \
 	base/Lock.h \
 	base/RefCount.h \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc \
 	tests/testRefCount.cc
 testRefCount_LDADD = \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 tests_testRock_SOURCES = \
 	cbdata.cc \
 	CacheDigest.h \
 	CollapsedForwarding.h \
 	CollapsedForwarding.cc \
 	tests/stub_CacheDigest.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	disk.h \
 	disk.cc \
 	ETag.cc \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
 	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpHeaderFieldStat.h \
@@ -3399,61 +3405,60 @@ tests_testURL_SOURCES = \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
-	tests/stub_libmem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
 	peer_sourcehash.h \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -3472,60 +3477,61 @@ tests_testURL_SOURCES = \
 	store_client.cc \
 	store_digest.h \
 	tests/stub_store_digest.cc \
 	store_dir.cc \
 	store_io.cc \
 	store_key_md5.h \
 	store_key_md5.cc \
 	store_log.h \
 	store_log.cc \
 	store_rebuild.h \
 	store_rebuild.cc \
 	store_swapin.h \
 	store_swapin.cc \
 	store_swapmeta.cc \
 	store_swapout.cc \
 	StoreFileSystem.cc \
 	StoreIOState.cc \
 	tests/stub_StoreMeta.cc \
 	StoreMetaUnpacker.cc \
 	StoreSwapLogData.cc \
 	String.cc \
 	StrList.h \
 	StrList.cc \
 	Transients.cc \
 	tests/stub_SwapDir.cc \
 	MemStore.cc \
 	tests/stub_debug.cc \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
 	tests/stub_libdiskio.cc \
+	tests/stub_libmem.cc \
 	tests/stub_libsecurity.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_store_stats.cc \
 	tests/testURL.cc \
 	tests/testURL.h \
 	tests/testUriScheme.cc \
 	tests/testUriScheme.h \
 	tests/stub_time.cc \
 	tests/stub_EventLoop.cc \
 	tools.h \
 	tools.cc \
 	tests/stub_tunnel.cc \
 	url.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
 	tests/stub_wccp2.cc \
 	whois.h \
 	tests/stub_whois.cc \
 	FadingCounter.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
 	libsquid.la \
 	clients/libclients.la \
 	servers/libservers.la \
@@ -3631,78 +3637,78 @@ tests_testSBufList_SOURCES= \
 	tests/stub_fatal.cc \
 	tests/stub_fd.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_libmem.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_store.cc \
 	tests/stub_stmem.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_tools.cc \
 	SquidString.h \
 	StatCounters.cc \
 	String.cc \
 	tests/stub_wordlist.cc \
 	tests/stub_MemBuf.cc
 nodist_tests_testSBufList_SOURCES=$(TESTSOURCES)
 tests_testSBufList_LDFLAGS = $(LIBADD_DL)
 tests_testSBufList_LDADD=\
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testSBufList_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
 
 tests_testConfigParser_SOURCES = \
 	ClientInfo.h \
-	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc \
 	tests/stub_time.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
 	ConfigParser.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	tests/testConfigParser.cc \
 	tests/testConfigParser.h \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testConfigParser_SOURCES = \
 	$(TESTSOURCES)
 tests_testConfigParser_LDADD = \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testConfigParser_LDFLAGS = $(LIBADD_DL)
 tests_testConfigParser_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 	
 tests_testStatHist_SOURCES = \
 	tests/stub_cbdata.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	tests/stub_MemBuf.cc \
 	$(SBUF_SOURCE) \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	StatHist.cc \

=== modified file 'src/MemObject.cc'
--- src/MemObject.cc	2015-05-26 17:25:04 +0000
+++ src/MemObject.cc	2015-08-21 14:37:14 +0000
@@ -69,70 +69,70 @@ MemObject::logUri() const
 }
 
 bool
 MemObject::hasUris() const
 {
     return storeId_.size();
 }
 
 void
 MemObject::setUris(char const *aStoreId, char const *aLogUri, const HttpRequestMethod &aMethod)
 {
     storeId_ = aStoreId;
 
     // fast pointer comparison for a common storeCreateEntry(url,url,...) case
     if (!aLogUri || aLogUri == aStoreId)
         logUri_.clean(); // use storeId_ by default to minimize copying
     else
         logUri_ = aLogUri;
 
     method = aMethod;
 
 #if URL_CHECKSUM_DEBUG
     chksum = url_checksum(urlXXX());
 #endif
 }
 
 MemObject::MemObject() :
     inmem_lo(0),
     nclients(0),
     smpCollapsed(false),
-    request(NULL),
-    ping_reply_callback(NULL),
-    ircb_data(NULL),
+    request(nullptr),
+    ping_reply_callback(nullptr),
+    ircb_data(nullptr),
     id(0),
     object_sz(-1),
     swap_hdr_sz(0),
 #if URL_CHECKSUM_DEBUG
     chksum(0),
 #endif
-    vary_headers(NULL)
+    vary_headers(nullptr)
 {
     debugs(20, 3, "new MemObject " << this);
     memset(&start_ping, 0, sizeof(start_ping));
     memset(&abort, 0, sizeof(abort));
     _reply = new HttpReply;
     HTTPMSGLOCK(_reply);
 }
 
 MemObject::~MemObject()
 {
     debugs(20, 3, "del MemObject " << this);
     const Ctx ctx = ctx_enter(hasUris() ? urlXXX() : "[unknown_ctx]");
 
 #if URL_CHECKSUM_DEBUG
     checkUrlChecksum();
 #endif
 
     if (!shutting_down) { // Store::Root() is FATALly missing during shutdown
         assert(xitTable.index < 0);
         assert(memCache.index < 0);
         assert(swapout.sio == NULL);
     }
 
     data_hdr.freeContent();
 
 #if 0
     /*
      * There is no way to abort FD-less clients, so they might
      * still have mem->clients set.
      */

=== modified file 'src/StoreMeta.cc'
--- src/StoreMeta.cc	2015-01-13 07:25:36 +0000
+++ src/StoreMeta.cc	2015-08-21 14:44:00 +0000
@@ -159,30 +159,43 @@ StoreMeta::Add(StoreMeta **tail, StoreMe
 bool
 StoreMeta::checkConsistency(StoreEntry *) const
 {
     switch (getType()) {
 
     case STORE_META_KEY:
 
     case STORE_META_URL:
 
     case STORE_META_VARY_HEADERS:
         assert(0);
         break;
 
     case STORE_META_STD:
         break;
 
     case STORE_META_STD_LFS:
         break;
 
     case STORE_META_OBJSIZE:
         break;
 
     default:
         debugs(20, DBG_IMPORTANT, "WARNING: got unused STORE_META type " << getType());
         break;
     }
 
     return true;
 }
 
+StoreMeta::StoreMeta(const StoreMeta &s) :
+    length(s.length),
+    value(s.value),
+    next(s.next)
+{}
+
+StoreMeta& StoreMeta::operator=(const StoreMeta &s)
+{
+    length=s.length;
+    value=s.value;
+    next=s.next;
+    return *this;
+}

=== modified file 'src/StoreMeta.h'
--- src/StoreMeta.h	2015-01-13 07:25:36 +0000
+++ src/StoreMeta.h	2015-08-21 14:44:00 +0000
@@ -84,57 +84,62 @@ enum {
 
     /**
      * Reserved for future hit-metering (RFC 2227) stuff
      */
     STORE_META_HITMETERING,
 
     /// \todo DOCS: document.
     STORE_META_VALID,
 
     /**
      * Stores Vary request headers
      */
     STORE_META_VARY_HEADERS,
 
     /**
      * Updated version of STORE_META_STD, with support for  >2GB objects.
      * As STORE_META_STD except that the swap_file_sz is a 64-bit integer instead of 32-bit.
      */
     STORE_META_STD_LFS,
 
     STORE_META_OBJSIZE,
 
     STORE_META_STOREURL,    /* the store url, if different to the normal URL */
     STORE_META_VARY_ID,     /* Unique ID linking variants */
     STORE_META_END
 };
 
 /// \ingroup SwapStoreAPI
 class StoreMeta
 {
+protected:
+	StoreMeta() : length(-1), value(nullptr), next(nullptr) { }
+	StoreMeta(const StoreMeta &);
+	StoreMeta& operator=(const StoreMeta &);
+
 public:
     static bool validType(char);
     static int const MaximumTLVLength;
     static int const MinimumTLVLength;
     static StoreMeta *Factory(char type, size_t len, void const *value);
     static StoreMeta **Add(StoreMeta **tail, StoreMeta *aNode);
     static void FreeList(StoreMeta **head);
 
     virtual char getType() const = 0;
     virtual bool validLength(int) const;
     virtual bool checkConsistency(StoreEntry *) const;
     virtual ~StoreMeta() {}
 
     int length;
     void *value;
     tlv *next;
 };
 
 /// \ingroup SwapStoreAPI
 char *storeSwapMetaPack(tlv * tlv_list, int *length);
 /// \ingroup SwapStoreAPI
 tlv *storeSwapMetaBuild(StoreEntry * e);
 /// \ingroup SwapStoreAPI
 void storeSwapTLVFree(tlv * n);
 
 #endif /* SQUID_TYPELENGTHVALUE_H */
 

=== modified file 'src/URL.h'
--- src/URL.h	2015-07-31 00:16:40 +0000
+++ src/URL.h	2015-08-21 16:34:16 +0000
@@ -1,60 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_URL_H
 #define SQUID_SRC_URL_H
 
 #include "anyp/UriScheme.h"
 #include "ip/Address.h"
 #include "rfc2181.h"
 #include "SBuf.h"
 
 #include <iosfwd>
 
 /**
  * The URL class represents a Uniform Resource Location
  *
  * Governed by RFC 3986
  */
 class URL
 {
     MEMPROXY_CLASS(URL);
 
 public:
-    URL() : scheme_(), hostIsNumeric_(false), port_(0) {*host_=0;}
-    URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme), hostIsNumeric_(false), port_(0) {*host_=0;}
+    URL() :
+        hostIsNumeric_(false), port_(0), absolute_() {*host_=0;}
+    URL(AnyP::UriScheme const &aScheme) :
+        scheme_(aScheme), hostIsNumeric_(false), port_(0) {*host_=0;}
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
         hostIsNumeric_ = false;
         *host_ = 0;
         hostAddr_.setEmpty();
         port_ = 0;
         touch();
     }
     void touch(); ///< clear the cached URI display forms
 
     AnyP::UriScheme const & getScheme() const {return scheme_;}
 
     /// convert the URL scheme to that given
     void setScheme(const AnyP::ProtocolType &p) {scheme_=p; touch();}
 
     void userInfo(const SBuf &s) {userInfo_=s; touch();}
     const SBuf &userInfo() const {return userInfo_;}
 
     void host(const char *src);
     const char *host(void) const {return host_;}
     int hostIsNumeric(void) const {return hostIsNumeric_;}
     Ip::Address const & hostIP(void) const {return hostAddr_;}
 
     void port(unsigned short p) {port_=p; touch();}
     unsigned short port() const {return port_;}
 
     void path(const char *p) {path_=p; touch();}
     void path(const SBuf &p) {path_=p; touch();}
     const SBuf &path() const;

=== modified file 'src/acl/Acl.cc'
--- src/acl/Acl.cc	2015-01-13 08:42:16 +0000
+++ src/acl/Acl.cc	2015-08-17 09:42:33 +0000
@@ -307,63 +307,61 @@ ACL::matchForCache(ACLChecklist *)
     return 0;       /* NOTREACHED */
 }
 
 /*
  * we lookup an acl's cached results, and if we cannot find the acl being
  * checked we check it and cache the result. This function is a template
  * method to support caching of multiple acl types.
  * Note that caching of time based acl's is not
  * wise in long lived caches (i.e. the auth_user proxy match cache)
  * RBC
  * TODO: does a dlink_list perform well enough? Kinkie
  */
 int
 ACL::cacheMatchAcl(dlink_list * cache, ACLChecklist *checklist)
 {
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link;
     link = cache->head;
 
     while (link) {
         auth_match = (acl_proxy_auth_match_cache *)link->data;
 
         if (auth_match->acl_data == this) {
             debugs(28, 4, "ACL::cacheMatchAcl: cache hit on acl '" << name << "' (" << this << ")");
             return auth_match->matchrv;
         }
 
         link = link->next;
     }
 
-    auth_match = new acl_proxy_auth_match_cache();
-    auth_match->matchrv = matchForCache (checklist);
-    auth_match->acl_data = this;
+    auth_match = new acl_proxy_auth_match_cache(matchForCache(checklist), this);
     dlinkAddTail(auth_match, &auth_match->link, cache);
     debugs(28, 4, "ACL::cacheMatchAcl: miss for '" << name << "'. Adding result " << auth_match->matchrv);
     return auth_match->matchrv;
 }
 
 void
 aclCacheMatchFlush(dlink_list * cache)
 {
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link, *tmplink;
     link = cache->head;
 
     debugs(28, 8, "aclCacheMatchFlush called for cache " << cache);
 
     while (link) {
         auth_match = (acl_proxy_auth_match_cache *)link->data;
         tmplink = link;
         link = link->next;
         dlinkDelete(tmplink, cache);
         delete auth_match;
     }
 }
 
 bool
 ACL::requiresReply() const
 {
     return false;
 }
 
 bool

=== modified file 'src/acl/Acl.h'
--- src/acl/Acl.h	2015-08-17 07:16:17 +0000
+++ src/acl/Acl.h	2015-08-20 08:12:35 +0000
@@ -189,41 +189,44 @@ public:
     aclMatchCode code; ///< ACCESS_* code
     int kind; ///< which custom access list verb matched
 };
 
 inline std::ostream &
 operator <<(std::ostream &o, const allow_t a)
 {
     switch (a) {
     case ACCESS_DENIED:
         o << "DENIED";
         break;
     case ACCESS_ALLOWED:
         o << "ALLOWED";
         break;
     case ACCESS_DUNNO:
         o << "DUNNO";
         break;
     case ACCESS_AUTH_REQUIRED:
         o << "AUTH_REQUIRED";
         break;
     }
     return o;
 }
 
 /// \ingroup ACLAPI
 class acl_proxy_auth_match_cache
 {
     MEMPROXY_CLASS(acl_proxy_auth_match_cache);
 
 public:
+    acl_proxy_auth_match_cache(int matchRv, void * aclData) :
+        matchrv(matchRv), acl_data(aclData) {}
+
     dlink_node link;
     int matchrv;
     void *acl_data;
 };
 
 /// \ingroup ACLAPI
 /// XXX: find a way to remove or at least use a refcounted ACL pointer
 extern const char *AclMatchedName;  /* NULL */
 
 #endif /* SQUID_ACL_H */
 

=== modified file 'src/acl/Asn.h'
--- src/acl/Asn.h	2015-01-13 07:25:36 +0000
+++ src/acl/Asn.h	2015-08-19 06:54:23 +0000
@@ -2,49 +2,50 @@
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLASN_H
 #define SQUID_ACLASN_H
 
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 #include "base/CbDataList.h"
 #include "ip/Address.h"
 
 int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
 void asnInit(void);
 
 /// \ingroup ACLAPI
 void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
 {
     MEMPROXY_CLASS(ACLASN);
 
 public:
+    ACLASN() : data(nullptr) {}
     virtual ~ACLASN();
 
     virtual bool match(Ip::Address);
     virtual SBufList dump() const;
     virtual void parse();
     bool empty() const;
     virtual ACLData<Ip::Address> *clone() const;
     virtual void prepareForUse();
 
 private:
     static ACL::Prototype SourceRegistryProtoype;
     static ACLStrategised<Ip::Address> SourceRegistryEntry_;
     static ACL::Prototype DestinationRegistryProtoype;
     static ACLStrategised<Ip::Address> DestinationRegistryEntry_;
     CbDataList<int> *data;
 };
 
 #endif /* SQUID_ACLASN_H */
 

=== modified file 'src/acl/DomainData.h'
--- src/acl/DomainData.h	2015-04-10 08:54:13 +0000
+++ src/acl/DomainData.h	2015-08-19 06:54:23 +0000
@@ -1,32 +1,33 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLDOMAINDATA_H
 #define SQUID_ACLDOMAINDATA_H
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "splay.h"
 
 class ACLDomainData : public ACLData<char const *>
 {
     MEMPROXY_CLASS(ACLDomainData);
 
 public:
+    ACLDomainData() : domains(nullptr) {}
     virtual ~ACLDomainData();
     virtual bool match(char const *);
     virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
 
     Splay<char *> *domains;
 };
 
 #endif /* SQUID_ACLDOMAINDATA_H */
 

=== modified file 'src/acl/ExtUser.h'
--- src/acl/ExtUser.h	2015-01-13 07:25:36 +0000
+++ src/acl/ExtUser.h	2015-08-19 06:54:23 +0000
@@ -1,47 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_EXTUSER_H
 #define SQUID_EXTUSER_H
 
 #if USE_AUTH
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 
 class ACLExtUser : public ACL
 {
     MEMPROXY_CLASS(ACLExtUser);
 
 public:
-    ACLExtUser(ACLData<char const *> *newData, char const *);
+    ACLExtUser(ACLData<char const *> *newData, char const * type);
     ACLExtUser (ACLExtUser const &old);
     ACLExtUser & operator= (ACLExtUser const &rhs);
     ~ACLExtUser();
 
     virtual char const *typeString() const;
     virtual void parse();
 
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual ACL *clone()const;
 
 private:
     static Prototype UserRegistryProtoype;
     static ACLExtUser UserRegistryEntry_;
     static Prototype RegexRegistryProtoype;
     static ACLExtUser RegexRegistryEntry_;
     ACLData<char const *> *data;
     char const *type_;
 };
 
 #endif /* USE_AUTH */
 #endif /* SQUID_EXTUSER_H */
 

=== modified file 'src/acl/UserData.cc'
--- src/acl/UserData.cc	2015-05-16 08:41:00 +0000
+++ src/acl/UserData.cc	2015-08-21 16:36:43 +0000
@@ -33,67 +33,62 @@ ACLUserData::match(char const *user)
     bool result = (userDataNames.find(SBuf(user)) != userDataNames.end());
     debugs(28, 7, "returning " << result);
     return result;
 }
 
 SBufList
 ACLUserData::dump() const
 {
     SBufList sl;
 
     if (flags.required) {
         sl.push_back(SBuf("REQUIRED"));
         return sl;
     }
 
     if (flags.case_insensitive)
         sl.push_back(SBuf("-i"));
 
     sl.insert(sl.end(), userDataNames.begin(), userDataNames.end());
 
     debugs(28,5, "ACLUserData dump output: " << SBufContainerJoin(userDataNames,SBuf(" ")));
     return sl;
 }
 
 static bool
 CaseInsensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
 {
     return (lhs.caseCmp(rhs) < 0);
 }
 
-static bool
-CaseSensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
-{
-    return (lhs < rhs);
-}
-
-ACLUserData::ACLUserData() : userDataNames(CaseSensitveSBufCompare)
+ACLUserData::ACLUserData() :
+    userDataNames()
 {
     flags.case_insensitive = false;
     flags.required = false;
 }
 
 void
 ACLUserData::parse()
 {
     debugs(28, 2, "parsing user list");
 
     char *t = NULL;
     if ((t = ConfigParser::strtokFile())) {
         SBuf s(t);
         debugs(28, 5, "first token is " << s);
 
         if (s.cmp("-i",2) == 0) {
             debugs(28, 5, "Going case-insensitive");
             flags.case_insensitive = true;
             // due to how the std::set API work, if we want to change
             // the comparison function we have to create a new std::set
             UserDataNames_t newUdn(CaseInsensitveSBufCompare);
             newUdn.insert(userDataNames.begin(), userDataNames.end());
             swap(userDataNames,newUdn);
         } else if (s.cmp("REQUIRED") == 0) {
             debugs(28, 5, "REQUIRED-type enabled");
             flags.required = true;
         } else {
             if (flags.case_insensitive)
                 s.toLower();
 

=== modified file 'src/auth/AclProxyAuth.cc'
--- src/auth/AclProxyAuth.cc	2015-01-13 07:25:36 +0000
+++ src/auth/AclProxyAuth.cc	2015-08-21 14:29:17 +0000
@@ -1,60 +1,65 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/UserData.h"
 #include "auth/Acl.h"
 #include "auth/AclProxyAuth.h"
 #include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "HttpRequest.h"
 
 ACLProxyAuth::~ACLProxyAuth()
 {
     delete data;
 }
 
-ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) : data(newData), type_(theType) {}
+ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) :
+    data(newData),
+    type_(theType)
+{}
 
-ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) : data(old.data->clone()), type_(old.type_)
+ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) :
+    data(old.data->clone()),
+    type_(old.type_)
 {}
 
 ACLProxyAuth &
 ACLProxyAuth::operator=(ACLProxyAuth const &rhs)
 {
     data = rhs.data->clone();
     type_ = rhs.type_;
     return *this;
 }
 
 char const *
 ACLProxyAuth::typeString() const
 {
     return type_;
 }
 
 void
 ACLProxyAuth::parse()
 {
     data->parse();
 }
 
 int
 ACLProxyAuth::match(ACLChecklist *checklist)
 {
     allow_t answer = AuthenticateAcl(checklist);
 
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:

=== modified file 'src/auth/Gadgets.cc'
--- src/auth/Gadgets.cc	2015-01-13 07:25:36 +0000
+++ src/auth/Gadgets.cc	2015-08-21 14:30:22 +0000
@@ -87,44 +87,44 @@ authenticateInit(Auth::ConfigVector * co
 
 void
 authenticateRotate(void)
 {
     for (Auth::ConfigVector::iterator i = Auth::TheConfig.begin(); i != Auth::TheConfig.end(); ++i)
         if ((*i)->configured())
             (*i)->rotateHelpers();
 }
 
 void
 authenticateReset(void)
 {
     debugs(29, 2, HERE << "Reset authentication State.");
 
     /* free all username cache entries */
     hash_first(proxy_auth_username_cache);
     AuthUserHashPointer *usernamehash;
     while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
         debugs(29, 5, HERE << "Clearing entry for user: " << usernamehash->user()->username());
         hash_remove_link(proxy_auth_username_cache, (hash_link *)usernamehash);
         delete usernamehash;
     }
 
     /* schedule shutdown of the helpers */
     authenticateRotate();
 
     /* free current global config details too. */
     Auth::TheConfig.clear();
 }
 
-AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user):
+AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user) :
     auth_user(anAuth_user)
 {
     key = (void *)anAuth_user->userKey();
-    next = NULL;
+    next = nullptr;
     hash_join(proxy_auth_username_cache, (hash_link *) this);
 }
 
 Auth::User::Pointer
 AuthUserHashPointer::user() const
 {
     return auth_user;
 }
 

=== modified file 'src/auth/Gadgets.h'
--- src/auth/Gadgets.h	2015-01-13 07:25:36 +0000
+++ src/auth/Gadgets.h	2015-08-19 06:54:23 +0000
@@ -6,61 +6,61 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_GADGETS_H
 #define SQUID_AUTH_GADGETS_H
 
 #if USE_AUTH
 
 #include "auth/Config.h"
 #include "auth/User.h"
 #include "hash.h"
 
 /**
  \ingroup AuthAPI
  *
  * This is used to link AuthUsers objects into the username cache.
  * Because some schemes may link in aliases to a user,
  * the link is not part of the AuthUser structure itself.
  *
  * Code must not hold onto copies of these objects.
  * They may exist only so long as the AuthUser being referenced
  * is recorded in the cache. Any caller using hash_remove_link
  * must then delete the AuthUserHashPointer.
  */
 class AuthUserHashPointer : public hash_link
 {
     MEMPROXY_CLASS(AuthUserHashPointer);
 
 public:
     AuthUserHashPointer(Auth::User::Pointer);
-    ~AuthUserHashPointer() { auth_user = NULL; };
+    ~AuthUserHashPointer() { auth_user = nullptr; }
 
     Auth::User::Pointer user() const;
 
 private:
     Auth::User::Pointer auth_user;
 };
 
 namespace Auth
 {
 class Scheme;
 }
 class ConnStateData;
 class StoreEntry;
 
 /**
  \ingroup AuthAPI
  \todo this should be a generic cachemgr API type ?
  */
 typedef void AUTHSSTATS(StoreEntry *);
 
 /// \ingroup AuthAPI
 void authenticateInit(Auth::ConfigVector *);
 
 /** \ingroup AuthAPI
  * Remove all idle authentication state. Intended for use by reconfigure.
  *
  * Removes the username cache contents and global configuration state.
  * Stops just short of detaching the auth components completely.
  *
  * Currently active requests should finish. Howevee new requests will not use

=== modified file 'src/auth/QueueNode.h'
--- src/auth/QueueNode.h	2015-01-13 07:25:36 +0000
+++ src/auth/QueueNode.h	2015-08-19 06:54:23 +0000
@@ -8,54 +8,54 @@
 
 #ifndef SQUID_SRC_AUTH_QUEUENODE_H
 #define SQUID_SRC_AUTH_QUEUENODE_H
 
 #include "cbdata.h"
 
 namespace Auth
 {
 
 /**
  * A queue of auth requests waiting for verification to occur.
  *
  * Certain authentication schemes such a Basic and Bearer auth
  * permit credentials tokens to be repeated from multiple sources
  * simultaneously. This queue node allows multiple validation
  * queries to be collapsed into one backend helper lookup.
  * CBDATA and handlers stored in these queue nodes can be notified
  * all at once with a result when the lookup completes.
  */
 class QueueNode
 {
     MEMPROXY_CLASS(Auth::QueueNode);
 
 private:
     // we store CBDATA here, copy is not safe
     QueueNode(const QueueNode &);
     QueueNode &operator =(const QueueNode &);
 
 public:
     QueueNode(Auth::UserRequest *aRequest, AUTHCB *aHandler, void *aData) :
-        next(NULL),
+        next(nullptr),
         auth_user_request(aRequest),
         handler(aHandler),
         data(cbdataReference(aData)) {}
     ~QueueNode() {
         cbdataReferenceDone(data);
         while (next) {
             QueueNode *tmp = next->next;
             next->next = NULL;
             delete next;
             next = tmp;
         };
     }
 
     Auth::QueueNode *next;
     Auth::UserRequest::Pointer auth_user_request;
     AUTHCB *handler;
     void *data;
 };
 
 } // namespace Auth
 
 #endif /* SQUID_SRC_AUTH_QUEUENODE_H */
 

=== modified file 'src/auth/User.cc'
--- src/auth/User.cc	2015-02-08 11:40:30 +0000
+++ src/auth/User.cc	2015-08-18 10:20:35 +0000
@@ -1,63 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/Gadgets.h"
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "event.h"
 #include "globals.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
 time_t Auth::User::last_discard = 0;
 
 Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
     auth_type(Auth::AUTH_UNKNOWN),
     config(aConfig),
     ipcount(0),
     expiretime(0),
-    notes(),
     credentials_state(Auth::Unchecked),
-    username_(NULL),
+    username_(nullptr),
     requestRealm_(aRequestRealm)
 {
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
     ip_list.head = ip_list.tail = NULL;
     debugs(29, 5, HERE << "Initialised auth_user '" << this << "'.");
 }
 
 Auth::CredentialState
 Auth::User::credentials() const
 {
     return credentials_state;
 }
 
 void
 Auth::User::credentials(CredentialState newCreds)
 {
     credentials_state = newCreds;
 }
 
 /**
  * Combine two user structs. ONLY to be called from within a scheme
  * module. The scheme module is responsible for ensuring that the
  * two users _can_ be merged without invalidating all the request
  * scheme data. The scheme is also responsible for merging any user
  * related scheme data itself.
  * The caller is responsible for altering all refcount pointers to
  * the 'from' object. They are invalid once this method is complete.
  */
 void
 Auth::User::absorb(Auth::User::Pointer from)

=== modified file 'src/auth/negotiate/UserRequest.cc'
--- src/auth/negotiate/UserRequest.cc	2015-08-04 19:57:07 +0000
+++ src/auth/negotiate/UserRequest.cc	2015-08-21 14:31:14 +0000
@@ -1,64 +1,63 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "auth/negotiate/Config.h"
 #include "auth/negotiate/UserRequest.h"
 #include "auth/State.h"
 #include "auth/User.h"
 #include "client_side.h"
 #include "fatal.h"
 #include "format/Format.h"
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
-Auth::Negotiate::UserRequest::UserRequest()
-{
-    waiting=0;
-    client_blob=0;
-    server_blob=0;
-    authserver=NULL;
-    request=NULL;
-}
+Auth::Negotiate::UserRequest::UserRequest() :
+    authserver(nullptr),
+    server_blob(nullptr),
+    client_blob(nullptr),
+    waiting(0),
+    request(nullptr)
+{}
 
 Auth::Negotiate::UserRequest::~UserRequest()
 {
     assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
     releaseAuthServer();
 
     if (request) {
         HTTPMSGUNLOCK(request);
         request = NULL;
     }
 }
 
 const char *
 Auth::Negotiate::UserRequest::connLastHeader()
 {
     return NULL;
 }
 
 int
 Auth::Negotiate::UserRequest::authenticated() const
 {
     if (user() != NULL && user()->credentials() == Auth::Ok) {
         debugs(29, 9, HERE << "user authenticated.");
         return 1;
     }
 
     debugs(29, 9, HERE << "user not fully authenticated.");

=== modified file 'src/auth/ntlm/UserRequest.cc'
--- src/auth/ntlm/UserRequest.cc	2015-08-04 19:57:07 +0000
+++ src/auth/ntlm/UserRequest.cc	2015-08-21 14:31:44 +0000
@@ -1,63 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "auth/ntlm/Config.h"
 #include "auth/ntlm/UserRequest.h"
 #include "auth/State.h"
 #include "cbdata.h"
 #include "client_side.h"
 #include "fatal.h"
 #include "format/Format.h"
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
-Auth::Ntlm::UserRequest::UserRequest()
-{
-    waiting=0;
-    client_blob=0;
-    server_blob=0;
-    authserver=NULL;
-    request=NULL;
-}
+Auth::Ntlm::UserRequest::UserRequest() :
+    authserver(nullptr),
+    server_blob(nullptr),
+    client_blob(nullptr),
+    waiting(0),
+    request(nullptr)
+{}
 
 Auth::Ntlm::UserRequest::~UserRequest()
 {
     assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
     releaseAuthServer();
 
     if (request) {
         HTTPMSGUNLOCK(request);
         request = NULL;
     }
 }
 
 const char *
 Auth::Ntlm::UserRequest::connLastHeader()
 {
     return NULL;
 }
 
 int
 Auth::Ntlm::UserRequest::authenticated() const
 {
     if (user() != NULL && user()->credentials() == Auth::Ok) {
         debugs(29, 9, HERE << "user authenticated.");
         return 1;
     }
 
     debugs(29, 9, HERE << "user not fully authenticated.");

=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-08-04 19:57:07 +0000
+++ src/clients/FtpGateway.cc	2015-08-21 15:38:13 +0000
@@ -1447,61 +1447,61 @@ ftpReadType(Ftp::Gateway * ftpState)
     } else {
         ftpFail(ftpState);
     }
 }
 
 static void
 ftpTraverseDirectory(Ftp::Gateway * ftpState)
 {
     wordlist *w;
     debugs(9, 4, HERE << (ftpState->filepath ? ftpState->filepath : "<NULL>"));
 
     safe_free(ftpState->dirpath);
     ftpState->dirpath = ftpState->filepath;
     ftpState->filepath = NULL;
 
     /* Done? */
 
     if (ftpState->pathcomps == NULL) {
         debugs(9, 3, HERE << "the final component was a directory");
         ftpListDir(ftpState);
         return;
     }
 
     /* Go to next path component */
     w = ftpState->pathcomps;
 
     ftpState->filepath = w->key;
 
     ftpState->pathcomps = w->next;
 
-    delete w;
+    wordlistDestroy(&w);
 
     /* Check if we are to CWD or RETR */
     if (ftpState->pathcomps != NULL || ftpState->flags.isdir) {
         ftpSendCwd(ftpState);
     } else {
         debugs(9, 3, HERE << "final component is probably a file");
         ftpGetFile(ftpState);
         return;
     }
 }
 
 static void
 ftpSendCwd(Ftp::Gateway * ftpState)
 {
     char *path = NULL;
 
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendCwd"))
         return;
 
     debugs(9, 3, HERE);
 
     path = ftpState->filepath;
 
     if (!strcmp(path, "..") || !strcmp(path, "/")) {
         ftpState->flags.no_dotdot = 1;
     } else {
         ftpState->flags.no_dotdot = 0;
     }
 

=== modified file 'src/comm/Connection.cc'
--- src/comm/Connection.cc	2015-06-02 10:15:06 +0000
+++ src/comm/Connection.cc	2015-08-18 15:58:59 +0000
@@ -1,64 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "CachePeer.h"
 #include "cbdata.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
 #include "neighbors.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 
 class CachePeer;
 bool
 Comm::IsConnOpen(const Comm::ConnectionPointer &conn)
 {
     return conn != NULL && conn->isOpen();
 }
 
 Comm::Connection::Connection() :
-    local(),
-    remote(),
     peerType(HIER_NONE),
     fd(-1),
     tos(0),
     nfmark(0),
     flags(COMM_NONBLOCKING),
-    peer_(NULL),
+    peer_(nullptr),
     startTime_(squid_curtime)
 {
     *rfc931 = 0; // quick init the head. the rest does not matter.
 }
 
 static int64_t lost_conn = 0;
 Comm::Connection::~Connection()
 {
     if (fd >= 0) {
         debugs(5, 4, "BUG #3329: Orphan Comm::Connection: " << *this);
         debugs(5, 4, "NOTE: " << ++lost_conn << " Orphans since last started.");
         close();
     }
 
     cbdataReferenceDone(peer_);
 }
 
 Comm::ConnectionPointer
 Comm::Connection::copyDetails() const
 {
     ConnectionPointer c = new Comm::Connection;
 
     c->setAddrs(local, remote);
     c->peerType = peerType;
     c->tos = tos;
     c->nfmark = nfmark;
     c->flags = flags;
     c->startTime_ = startTime_;
 
     // ensure FD is not open in the new copy.

=== modified file 'src/esi/Esi.cc'
--- src/esi/Esi.cc	2015-08-04 19:57:07 +0000
+++ src/esi/Esi.cc	2015-08-21 14:32:54 +0000
@@ -1457,65 +1457,64 @@ esiComment::finish()
 
 void
 esiComment::render(ESISegment::Pointer output)
 {
     /* Comments do nothing dude */
     debugs(86, 5, "esiCommentRender: Rendering comment " << this << " into " << output.getRaw());
 }
 
 ESIElement::Pointer
 esiComment::makeCacheable() const
 {
     debugs(86, 5, "esiComment::makeCacheable: returning NULL");
     return NULL;
 }
 
 ESIElement::Pointer
 esiComment::makeUsable(esiTreeParentPtr, ESIVarState &) const
 {
     fatal ("esiComment::Usable: unreachable code!\n");
     return NULL;
 }
 
 /* esiLiteral */
 esiLiteral::~esiLiteral()
 {
     debugs(86, 5, "esiLiteral::~esiLiteral: " << this);
     ESISegmentFreeList (buffer);
     cbdataReferenceDone (varState);
 }
 
-esiLiteral::esiLiteral(ESISegment::Pointer aSegment)
+esiLiteral::esiLiteral(ESISegment::Pointer aSegment) :
+    buffer(aSegment),
+    varState(nullptr)
 {
-    buffer = aSegment;
-    /* we've been handed a complete, processed string */
-    varState = NULL;
     /* Nothing to do */
     flags.donevars = 1;
 }
 
 void
 esiLiteral::finish()
 {}
 
 /* precondition: the buffer chain has at least start + length bytes of data
  */
 esiLiteral::esiLiteral(ESIContext *context, const char *s, int numberOfCharacters)
 {
     assert (s);
     flags.donevars = 0;
     buffer = new ESISegment;
     ESISegment::Pointer local = buffer;
     size_t start = 0;
     int remainingCharacters = numberOfCharacters;
 
     while (remainingCharacters > 0) {
         if (local->len == sizeof (local->buf)) {
             local->next = new ESISegment;
             local=local->next;
         }
 
         size_t len = local->append (&s[start], remainingCharacters);
         start += len;
         remainingCharacters -= len;
     }
 
@@ -1854,61 +1853,64 @@ esiTry::makeUsable(esiTreeParentPtr newP
         resultT->attempt = attempt->makeUsable(resultT, newVarState);
 
     if (except.getRaw())
         resultT->except  = except->makeUsable(resultT, newVarState);
 
     return result;
 }
 
 void
 esiTry::finish()
 {
     parent = NULL;
 
     if (attempt.getRaw())
         attempt->finish();
 
     attempt = NULL;
 
     if (except.getRaw())
         except->finish();
 
     except = NULL;
 }
 
 /* esiChoose */
 esiChoose::~esiChoose()
 {
     debugs(86, 5, "esiChoose::~esiChoose " << this);
 }
 
-esiChoose::esiChoose(esiTreeParentPtr aParent) : elements (), chosenelement (-1),parent (aParent)
+esiChoose::esiChoose(esiTreeParentPtr aParent) :
+    elements(),
+    chosenelement(-1),
+    parent(aParent)
 {}
 
 void
 esiChoose::render(ESISegment::Pointer output)
 {
     /* append all processed elements, and trim processed and rendered elements */
     assert (output->next == NULL);
     assert (elements.size() || otherwise.getRaw());
     debugs(86, 5, "esiChooseRender: rendering");
 
     if (chosenelement >= 0)
         elements[chosenelement]->render(output);
     else if (otherwise.getRaw())
         otherwise->render(output);
 }
 
 bool
 esiChoose::addElement(ESIElement::Pointer element)
 {
     /* add an element to the output list */
 
     if (dynamic_cast<esiLiteral*>(element.getRaw())) {
         /* Swallow whitespace */
         debugs(86, 5, "esiChooseAdd: Choose " << this << " skipping whitespace " << element.getRaw());
         return true;
     }
 
     /* Some elements require specific parents */
     if (!(dynamic_cast<esiWhen*>(element.getRaw()) || dynamic_cast<esiOtherwise*>(element.getRaw()))) {
         debugs(86, DBG_CRITICAL, "esiChooseAdd: invalid child node for esi:choose (section 3.3)");

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-08-04 21:04:09 +0000
+++ src/external_acl.cc	2015-08-21 16:36:43 +0000
@@ -46,61 +46,67 @@
 #endif
 #if USE_IDENT
 #include "ident/AclIdent.h"
 #endif
 
 #ifndef DEFAULT_EXTERNAL_ACL_TTL
 #define DEFAULT_EXTERNAL_ACL_TTL 1 * 60 * 60
 #endif
 #ifndef DEFAULT_EXTERNAL_ACL_CHILDREN
 #define DEFAULT_EXTERNAL_ACL_CHILDREN 5
 #endif
 
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static void external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry);
 static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
 
 /******************************************************************
  * external_acl directive
  */
 
 class external_acl_format : public RefCountable
 {
     MEMPROXY_CLASS(external_acl_format);
 
 public:
     typedef RefCount<external_acl_format> Pointer;
 
-    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(Http::HdrType::BAD_HDR) {}
+    external_acl_format() :
+        type(Format::LFT_NONE),
+        header(nullptr),
+        member(nullptr),
+        separator(' '),
+        header_id(Http::HdrType::BAD_HDR)
+    {}
     ~external_acl_format() {
         xfree(header);
         xfree(member);
     }
 
     Format::ByteCode_t type;
     external_acl_format::Pointer next;
     char *header;
     char *member;
     char separator;
     Http::HdrType header_id;
 };
 
 class external_acl
 {
     /* FIXME: These are not really cbdata, but it is an easy way
      * to get them pooled, refcounted, accounted and freed properly...
      */
     CBDATA_CLASS(external_acl);
 
 public:
     external_acl();
     ~external_acl();
 
     external_acl *next;
 
     void add(const ExternalACLEntryPointer &);
 
     void trimCache();
 

=== modified file 'src/fs/ufs/UFSStoreState.h'
--- src/fs/ufs/UFSStoreState.h	2015-05-16 08:41:00 +0000
+++ src/fs/ufs/UFSStoreState.h	2015-08-21 16:37:40 +0000
@@ -21,74 +21,85 @@ namespace Ufs
 class UFSStoreState : public StoreIOState, public IORequestor
 {
     CBDATA_CLASS(UFSStoreState);
 
 public:
     UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB * callback_, void *callback_data_);
     ~UFSStoreState();
     virtual void close(int how);
     virtual void closeCompleted();
     // protected:
     virtual void ioCompletedNotification();
     virtual void readCompleted(const char *buf, int len, int errflag, RefCount<ReadRequest>);
     virtual void writeCompleted(int errflag, size_t len, RefCount<WriteRequest>);
     RefCount<DiskFile> theFile;
     bool opening;
     bool creating;
     bool closing;
     bool reading;
     bool writing;
     /* StoreIOState API */
     void read_(char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data);
     virtual bool write(char const *buf, size_t size, off_t offset, FREE * free_func);
 
 protected:
     virtual void doCloseCallback (int errflag);
 
     class _queued_read
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_read);
     public:
-        _queued_read() : buf(NULL), size(0), offset(0), callback(NULL), callback_data(NULL) {}
+        _queued_read() :
+            buf(nullptr),
+            size(0),
+            offset(0),
+            callback(nullptr),
+            callback_data(nullptr)
+        {}
 
         char *buf;
         size_t size;
         off_t offset;
         STRCB *callback;
         void *callback_data;
     };
 
     class _queued_write
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_write);
     public:
-        _queued_write() : buf(NULL), size(0), offset(0), free_func(NULL) {}
+        _queued_write() :
+            buf(NULL),
+            size(0),
+            offset(0),
+            free_func(NULL)
+        {}
 
         char const *buf;
         size_t size;
         off_t offset;
         FREE *free_func;
     };
 
     /** \todo These should be in the IO strategy */
 
     struct {
         /**
          * DPW 2006-05-24
          * the write_draining flag is used to avoid recursion inside
          * the UFSStoreState::drainWriteQueue() method.
          */
         bool write_draining;
         /**
          * DPW 2006-05-24
          * The try_closing flag is set by UFSStoreState::tryClosing()
          * when UFSStoreState wants to close the file, but cannot
          * because of pending I/Os.  If set, UFSStoreState will
          * try to close again in the I/O callbacks.
          */
         bool try_closing;
     } flags;
     link_list *pending_reads;
     link_list *pending_writes;
     void queueRead(char *, size_t, off_t, STRCB *, void *);
     void queueWrite(char const *, size_t, off_t, FREE *);
     bool kickReadQueue();

=== modified file 'src/icmp/Makefile.am'
--- src/icmp/Makefile.am	2015-08-03 03:44:59 +0000
+++ src/icmp/Makefile.am	2015-08-19 09:34:27 +0000
@@ -17,85 +17,95 @@ DEFS += -DDEFAULT_CONFIG_FILE=NULL
 
 if ENABLE_PINGER
 libexec_PROGRAMS = pinger
 else
 EXTRA_PROGRAMS = pinger
 endif
 
 noinst_LTLIBRARIES = libicmp-core.la libicmp.la
 
 # ICMP API definition ...
 libicmp_core_la_SOURCES = \
 	Icmp.h \
 	Icmp.cc
 
 # Squid Internal ICMP helper interface
 libicmp_la_SOURCES = \
 	IcmpConfig.cc \
 	IcmpConfig.h \
 	IcmpSquid.h \
 	IcmpSquid.cc \
 	net_db.h \
 	net_db.cc
 
 # pinger depends on these but install/dist is done elsewhere.
 COPIED_SOURCE= \
 	debug.cc \
 	globals.cc \
 	SquidConfig.cc \
 	SquidNew.cc \
 	stub_HelperChildConfig.cc \
+	stub_libmem.cc \
+	STUB.h \
 	time.cc
 
 # ICMP lookup helper
 pinger_SOURCES = \
 	Icmp.h \
 	IcmpPinger.h \
 	IcmpPinger.cc \
 	Icmp4.h \
 	Icmp4.cc \
 	Icmp6.h \
 	Icmp6.cc \
 	pinger.cc
 nodist_pinger_SOURCES = $(COPIED_SOURCE)
 pinger_LDFLAGS = $(LIBADD_DL)
+#libmem is needed for MemAllocatorProxy, libmiscutil for splayLastResult
 pinger_LDADD=\
 	libicmp-core.la \
 	$(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/src/base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 CLEANFILES += $(COPIED_SOURCE)
 
 ##install-pinger:
 ##	@f=$(PINGER_EXE); \
 ##	if test -f $(libexecdir)/$$f; then \
 ##		echo $(MV) $(libexecdir)/$$f $(libexecdir)/-$$f; \
 ##		$(MV) $(libexecdir)/$$f $(libexecdir)/-$$f; \
 ##	fi; \
 ##	echo $(INSTALL_SUID) $$f $(libexecdir); \
 ##	$(INSTALL_SUID) $$f $(libexecdir) || exit 1; \
 ##	if test -f $(libexecdir)/-$$f; then \
 ##		echo $(RM) -f $(libexecdir)/-$$f; \
 ##		$(RM) -f $(libexecdir)/-$$f; \
 ##	fi
 
 ## files we need to pull in from other locations
 ## copied like this to avoid subdir-objects collisions on 'make clean'
 debug.cc: $(top_srcdir)/src/debug.cc
-	cp $(top_srcdir)/src/debug.cc .
+	cp $< $@
 
 globals.cc: $(top_srcdir)/src/globals.h
 	cp $(top_builddir)/src/globals.cc .
 
 time.cc: $(top_srcdir)/src/time.cc
-	cp $(top_srcdir)/src/time.cc .
+	cp $< $@
 
 SquidConfig.cc: $(top_srcdir)/src/SquidConfig.cc
-	cp $(top_srcdir)/src/SquidConfig.cc .
+	cp $< $@
 
 SquidNew.cc: $(top_srcdir)/src/SquidNew.cc
-	cp $(top_srcdir)/src/SquidNew.cc .
+	cp $< $@
 
 stub_HelperChildConfig.cc: $(top_srcdir)/src/tests/stub_HelperChildConfig.cc
-	cp $(top_srcdir)/src/tests/stub_HelperChildConfig.cc .
+	cp $< $@
+
+stub_libmem.cc: $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $< $@
+
+STUB.h: $(top_srcdir)/src/tests/STUB.h
+	cp $< $@
+	
\ No newline at end of file

=== modified file 'src/ident/AclIdent.h'
--- src/ident/AclIdent.h	2015-01-13 07:25:36 +0000
+++ src/ident/AclIdent.h	2015-08-19 06:54:23 +0000
@@ -20,44 +20,44 @@ class IdentLookup : public ACLChecklist:
 public:
     static IdentLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
 
 private:
     static IdentLookup instance_;
     static void LookupDone(const char *ident, void *data);
 };
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
 
 /// \ingroup ACLAPI
 class ACLIdent : public ACL
 {
     MEMPROXY_CLASS(ACLIdent);
 
 public:
     ACLIdent(ACLData<char const *> *newData, char const *);
     ACLIdent (ACLIdent const &old);
     ACLIdent & operator= (ACLIdent const &rhs);
     ~ACLIdent();
 
     virtual char const *typeString() const;
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
 
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
-    virtual ACL *clone()const;
+    virtual ACL *clone() const;
 
 private:
     static Prototype UserRegistryProtoype;
     static ACLIdent UserRegistryEntry_;
     static Prototype RegexRegistryProtoype;
     static ACLIdent RegexRegistryEntry_;
     ACLData<char const *> *data;
     char const *type_;
 };
 
 #endif /* USE_IDENT */
 #endif /* SQUID_IDENT_ACLIDENT_H */
 

=== modified file 'src/mem/AllocatorProxy.cc'
--- src/mem/AllocatorProxy.cc	2015-01-13 07:25:36 +0000
+++ src/mem/AllocatorProxy.cc	2015-08-17 07:08:01 +0000
@@ -1,56 +1,64 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "mem/AllocatorProxy.h"
 #include "mem/Pool.h"
 
 void *
 Mem::AllocatorProxy::alloc()
 {
     return getAllocator()->alloc();
 }
 
 void
 Mem::AllocatorProxy::freeOne(void *address)
 {
     getAllocator()->freeOne(address);
     /* TODO: check for empty, and if so, if the default type has altered,
      * switch
      */
 }
 
 MemAllocator *
 Mem::AllocatorProxy::getAllocator() const
 {
-    if (!theAllocator)
+    if (!theAllocator) {
         theAllocator = MemPools::GetInstance().create(objectType(), size);
+        theAllocator->zeroBlocks(doZero);
+    }
     return theAllocator;
 }
 
 int
 Mem::AllocatorProxy::inUseCount() const
 {
     if (!theAllocator)
         return 0;
     else
         return memPoolInUseCount(theAllocator);
 }
 
+void
+Mem::AllocatorProxy::zeroBlocks(bool doIt)
+{
+	getAllocator()->zeroBlocks(doIt);
+}
+
 MemPoolMeter const &
 Mem::AllocatorProxy::getMeter() const
 {
     return getAllocator()->getMeter();
 }
 
 int
 Mem::AllocatorProxy::getStats(MemPoolStats * stats)
 {
     return getAllocator()->getStats(stats);
 }
 

=== modified file 'src/mem/AllocatorProxy.h'
--- src/mem/AllocatorProxy.h	2015-01-13 07:25:36 +0000
+++ src/mem/AllocatorProxy.h	2015-08-19 06:54:23 +0000
@@ -1,81 +1,88 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_SRC_MEM_ALLOCATORPROXY_H
 #define _SQUID_SRC_MEM_ALLOCATORPROXY_H
 
 class MemAllocator;
 class MemPoolStats;
 class MemPoolMeter;
 
 /**
  * \hideinitializer
  *
  * Pool and account the memory used for the CLASS object.
  * This macro is intended for use within the declaration of a class.
+ * The store allocated by new is not zeroed; it is the users'
+ * responsibility to ensure that constructors correctly initialize
+ * all data members.
  */
 #define MEMPROXY_CLASS(CLASS) \
     private: \
     static inline Mem::AllocatorProxy &Pool() { \
-        static Mem::AllocatorProxy thePool(#CLASS, sizeof(CLASS)); \
+        static Mem::AllocatorProxy thePool(#CLASS, sizeof(CLASS), false); \
         return thePool; \
     } \
     public: \
     void *operator new(size_t byteCount) { \
         /* derived classes with different sizes must implement their own new */ \
         assert(byteCount == sizeof(CLASS)); \
         return Pool().alloc(); \
     } \
     void operator delete(void *address) {Pool().freeOne(address);} \
     private:
 
 namespace Mem
 {
 
 /**
  * Support late binding of pool type for allocator agnostic classes
  */
 class AllocatorProxy
 {
 public:
-    AllocatorProxy(char const *aLabel, size_t const &aSize):
+    AllocatorProxy(char const *aLabel, size_t const &aSize, bool doZeroBlocks = true):
         label(aLabel),
         size(aSize),
-        theAllocator(NULL)
+        theAllocator(NULL),
+		doZero(doZeroBlocks)
     {}
 
     /// Allocate one element from the pool
     void *alloc();
 
     /// Free a element allocated by Mem::AllocatorProxy::alloc()
     void freeOne(void *);
 
     int inUseCount() const;
     size_t objectSize() const {return size;}
     char const * objectType() const {return label;}
 
     MemPoolMeter const &getMeter() const;
 
     /**
      * \param stats Object to be filled with statistical data about pool.
      * \retval      Number of objects in use, ie. allocated.
      */
     int getStats(MemPoolStats * stats);
 
+    void zeroBlocks(bool doIt);
+
 private:
     MemAllocator *getAllocator() const;
 
     const char *label;
     size_t size;
     mutable MemAllocator *theAllocator;
+    bool doZero;
 };
 
 } // namespace Mem
 
 #endif /* _SQUID_SRC_MEM_ALLOCATORPROXY_H */
 

=== modified file 'src/mime.cc'
--- src/mime.cc	2015-07-07 11:53:08 +0000
+++ src/mime.cc	2015-08-21 14:33:56 +0000
@@ -89,64 +89,63 @@ mimeGetEntry(const char *fn, int skip_en
 
         for (m = MimeTable; m; m = m->next) {
             if (regexec(&m->compiled_pattern, name, 0, 0, 0) == 0)
                 break;
         }
 
         if (!skip_encodings)
             (void) 0;
         else if (m == NULL)
             (void) 0;
         else if (strcmp(m->content_type, dash_str))
             (void) 0;
         else if (!strcmp(m->content_encoding, dash_str))
             (void) 0;
         else {
             /* Assume we matched /\.\w$/ and cut off the last extension */
             if ((t = strrchr(name, '.'))) {
                 *t = '\0';
             } else {
                 /* What? A encoding without a extension? */
                 m = NULL;
             }
         }
     } while (t);
 
     xfree(name);
     return m;
 }
 
 MimeIcon::MimeIcon(const char *aName) :
-    icon_(aName)
-{
-    url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
-}
+    icon_(aName),
+    url_(xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_)))
+{}
 
 MimeIcon::~MimeIcon()
 {
     xfree(url_);
 }
 
 void
 MimeIcon::setName(char const *aString)
 {
     xfree(url_);
     icon_ = aString;
     url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
 }
 
 SBuf
 MimeIcon::getName() const
 {
     return icon_;
 }
 
 const SBuf
 mimeGetIcon(const char *fn)
 {
     MimeEntry *m = mimeGetEntry(fn, 1);
 
     if (!m || !m->theIcon.getName().cmp(dash_str))
         return SBuf();
 
     return m->theIcon.getName();
 }

=== modified file 'src/tests/stub_wordlist.cc'
--- src/tests/stub_wordlist.cc	2015-01-13 07:25:36 +0000
+++ src/tests/stub_wordlist.cc	2015-08-21 15:59:22 +0000
@@ -1,20 +1,19 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "wordlist.h"
 
 #define STUB_API "wordlist.cc"
 #include "tests/STUB.h"
 
 const char *wordlistAdd(wordlist **, const char *) STUB_RETVAL(NULL)
 void wordlistAddWl(wordlist **, wordlist *) STUB
 void wordlistJoin(wordlist **, wordlist **) STUB
-wordlist *wordlistDup(const wordlist *) STUB_RETVAL(NULL)
 void wordlistDestroy(wordlist **) STUB
 

=== modified file 'src/wordlist.cc'
--- src/wordlist.cc	2015-03-05 06:44:43 +0000
+++ src/wordlist.cc	2015-08-21 15:54:51 +0000
@@ -5,96 +5,76 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 03    Configuration File Parsing */
 
 #include "squid.h"
 #include "MemBuf.h"
 #include "wordlist.h"
 
 void
 wordlistDestroy(wordlist ** list)
 {
     wordlist *w = NULL;
 
     while ((w = *list) != NULL) {
         *list = w->next;
         safe_free(w->key);
         delete w;
     }
 
     *list = NULL;
 }
 
 const char *
 wordlistAdd(wordlist ** list, const char *key)
 {
     while (*list)
         list = &(*list)->next;
 
-    *list = new wordlist;
-
-    (*list)->key = xstrdup(key);
-
-    (*list)->next = NULL;
-
+    *list = new wordlist(key);
     return (*list)->key;
 }
 
 void
 wordlistJoin(wordlist ** list, wordlist ** wl)
 {
     while (*list)
         list = &(*list)->next;
 
     *list = *wl;
 
     *wl = NULL;
 }
 
 void
 wordlistAddWl(wordlist ** list, wordlist * wl)
 {
     while (*list)
         list = &(*list)->next;
 
     for (; wl; wl = wl->next, list = &(*list)->next) {
-        *list = new wordlist();
-        (*list)->key = xstrdup(wl->key);
-        (*list)->next = NULL;
+        *list = new wordlist(wl->key);
     }
 }
 
 void
 wordlistCat(const wordlist * w, MemBuf * mb)
 {
     while (NULL != w) {
         mb->appendf("%s\n", w->key);
         w = w->next;
     }
 }
 
-wordlist *
-wordlistDup(const wordlist * w)
-{
-    wordlist *D = NULL;
-
-    while (NULL != w) {
-        wordlistAdd(&D, w->key);
-        w = w->next;
-    }
-
-    return D;
-}
-
 SBufList
 ToSBufList(wordlist *wl)
 {
     SBufList rv;
     while (wl != NULL) {
         rv.push_back(SBuf(wl->key));
         wl = wl->next;
     }
     return rv;
 }
 

=== modified file 'src/wordlist.h'
--- src/wordlist.h	2015-01-13 07:25:36 +0000
+++ src/wordlist.h	2015-08-21 15:54:51 +0000
@@ -1,65 +1,74 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_WORDLIST_H
 #define SQUID_WORDLIST_H
 
 #include "globals.h"
 #include "profiler/Profiler.h"
 #include "SBufList.h"
 
 /** A list of C-strings
  *
  * \deprecated use SBufList instead
  */
 class wordlist
 {
     MEMPROXY_CLASS(wordlist);
+    friend void wordlistDestroy(wordlist ** list);
 
 public:
+    wordlist() : key(nullptr), next(nullptr) {}
+    // create a new wordlist node, with a copy of k as key
+    explicit wordlist(const char *k) : key(xstrdup(k)), next(nullptr) {}
+
+    wordlist(const wordlist &) = delete;
+    wordlist &operator=(const wordlist &) = delete;
+
     char *key;
     wordlist *next;
+
+private:
+    // use wordlistDestroy instead
+    ~wordlist() = default;
 };
 
 class MemBuf;
 
 /** Add a null-terminated c-string to a wordlist
  *
  * \deprecated use SBufList.push_back(SBuf(word)) instead
  */
 const char *wordlistAdd(wordlist **, const char *);
 
 /** Concatenate a wordlist
  *
  * \deprecated use SBufListContainerJoin(SBuf()) from SBufAlgos.h instead
  */
 void wordlistCat(const wordlist *, MemBuf *);
 
 /** append a wordlist to another
  *
  * \deprecated use SBufList.merge(otherwordlist) instead
  */
 void wordlistAddWl(wordlist **, wordlist *);
 
 /** Concatenate the words in a wordlist
  *
  * \deprecated use SBufListContainerJoin(SBuf()) from SBufAlgos.h instead
  */
 void wordlistJoin(wordlist **, wordlist **);
 
-/// duplicate a wordlist
-wordlist *wordlistDup(const wordlist *);
-
 /// destroy a wordlist
 void wordlistDestroy(wordlist **);
 
 /// convert a wordlist to a SBufList
 SBufList ToSBufList(wordlist *);
 
 #endif /* SQUID_WORDLIST_H */
 

=== modified file 'test-suite/Makefile.am'
--- test-suite/Makefile.am	2015-08-03 03:50:25 +0000
+++ test-suite/Makefile.am	2015-08-21 16:32:07 +0000
@@ -30,111 +30,124 @@ ESI_ALL_TESTS = \
 if USE_ESI
   ESI_TESTS = $(ESI_ALL_TESTS)
 else
   ESI_TESTS = 
 endif
 
 ## Sort by dependencies - test lowest layers first
 TESTS += debug \
 	syntheticoperators \
 	VirtualDeleteOperator \
 	splay\
 	MemPoolTest\
 	mem_node_test\
 	mem_hdr_test\
 	$(ESI_TESTS) \
 	squid-conf-tests
 
 ## Sort by alpha - any build failures are significant.
 check_PROGRAMS += debug \
 		$(ESI_TESTS) \
 		MemPoolTest\
 		mem_node_test\
 		mem_hdr_test \
 		splay \
 		syntheticoperators \
 		VirtualDeleteOperator
 
 
 tcp_banger2_LDADD = $(top_builddir)/lib/libmiscutil.la
 
-STUBS = stub_cbdata.cc stub_debug.cc stub_MemBuf.cc stub_SBuf.cc stub_tools.cc stub_fatal.cc
+#do not include stub_libmem.cc here, as it would override libmem.la in
+# several tests whose purpose is testing libmem itself.
+STUBS = stub_cbdata.cc stub_debug.cc stub_MemBuf.cc \
+	stub_SBuf.cc stub_tools.cc stub_fatal.cc \
+	STUB.h
 DEBUG_SOURCE = test_tools.cc $(STUBS)
 CLEANFILES += $(STUBS)
 
 stub_cbdata.cc: $(top_srcdir)/src/tests/stub_cbdata.cc
-	cp $(top_srcdir)/src/tests/stub_cbdata.cc .
+	cp $< $@
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
-	cp $(top_srcdir)/src/tests/stub_debug.cc .
+	cp $< $@
 
 stub_MemBuf.cc: $(top_srcdir)/src/tests/stub_MemBuf.cc
-	cp $(top_srcdir)/src/tests/stub_MemBuf.cc .
+	cp $< $@
 
 stub_SBuf.cc: $(top_srcdir)/src/tests/stub_SBuf.cc
-	cp $(top_srcdir)/src/tests/stub_SBuf.cc .
+	cp $< $@
 
 stub_tools.cc: $(top_srcdir)/src/tests/stub_tools.cc
-	cp $(top_srcdir)/src/tests/stub_tools.cc .
+	cp $< $@
 
 stub_fatal.cc: $(top_srcdir)/src/tests/stub_fatal.cc
-	cp $(top_srcdir)/src/tests/stub_fatal.cc .
+	cp $< $@
+
+stub_libmem.cc : $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $< $@
+	
+STUB.h : $(top_srcdir)/src/tests/STUB.h
+	cp $< $@
 
 ## XXX: somewhat broken. Its meant to test our debugs() implementation.
 ## but it has never been linked to the actual src/debug.cc implementation !!
 ## all it tests are the stream operators and macro in src/Debug.h
-debug_SOURCES = debug.cc $(DEBUG_SOURCE)
+debug_SOURCES = debug.cc stub_libmem.cc $(DEBUG_SOURCE) 
 
-ESIExpressions_SOURCES = ESIExpressions.cc $(DEBUG_SOURCE)
+ESIExpressions_SOURCES = ESIExpressions.cc stub_libmem.cc $(DEBUG_SOURCE)
 ESIExpressions_LDADD = $(top_builddir)/src/esi/Expression.o \
 		$(LDADD)
 
 mem_node_test_SOURCES = mem_node_test.cc $(DEBUG_SOURCE)
 mem_node_test_LDADD = \
 	$(top_builddir)/src/mem_node.o \
 	$(top_builddir)/src/mem/libmem.la \
 	$(LDADD)
 
 mem_hdr_test_SOURCES = mem_hdr_test.cc $(DEBUG_SOURCE)
 mem_hdr_test_LDADD = \
 	$(top_builddir)/src/stmem.o \
 	$(top_builddir)/src/mem_node.o \
 	$(top_builddir)/src/mem/libmem.la \
 	$(LDADD)
 
 MemPoolTest_SOURCES = MemPoolTest.cc $(DEBUG_SOURCE)
+MemPoolTest_LDADD = \
+	$(top_builddir)/src/mem/libmem.la \
+	$(LDADD)
 
-splay_SOURCES = splay.cc $(DEBUG_SOURCE)
+splay_SOURCES = splay.cc stub_libmem.cc $(DEBUG_SOURCE)
 
-syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
+syntheticoperators_SOURCES = syntheticoperators.cc stub_libmem.cc $(DEBUG_SOURCE)
 
-VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
+VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc stub_libmem.cc $(DEBUG_SOURCE)
 
 ## membanger won't link today. Bitrot..
 ##CC	= gcc
 ##CFLAGS	= -g -Wall -I../include -I../src
 ##OBJS	= membanger.o hash.o SizeToPool.o
 ##LIB	= -L. -lMem
 ##TARGLIB = libMem.a
 ##LIBOBJS = Mem.o \
 ##          Stack.o
 ##AR_R      = /usr/bin/ar r
 ##RM      = rm
 ##XTRA_LIBS = -lm  -lmalloc
 ##
 ##all:  membanger
 ##
 ##membanger: $(OBJS) $(TARGLIB)
 ##	$(CC) -o membanger $(OBJS) $(LIB)
 ##
 ##$(TARGLIB): $(LIBOBJS)
 ##	$(AR_R) $(TARGLIB) $(LIBOBJS)
 
 squid-conf-tests: $(top_builddir)/src/squid.conf.default $(srcdir)/squidconf/*
 	@failed=0; cfglist="$?"; rm -f $@ || $(TRUE); \
 	for cfg in $$cfglist ; do \
 		$(top_builddir)/src/squid -k parse -f $$cfg || \
 			{ echo "FAIL: squid.conf test: $$cfg" | \
 				sed s%$(top_builddir)/src/%% | \
 				sed s%$(srcdir)/squidconf/%% ; \
 				failed=1; break; \
 			}; \

=== modified file 'tools/Makefile.am'
--- tools/Makefile.am	2015-08-03 03:50:25 +0000
+++ tools/Makefile.am	2015-08-21 16:39:11 +0000
@@ -2,85 +2,90 @@
 ##
 ## Squid software is distributed under GPLv2+ license and includes
 ## contributions from numerous individuals and organizations.
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
 AM_CPPFLAGS += -I$(srcdir)
 
 SUBDIRS= helper-mux purge squidclient systemd sysvinit
 EXTRA_DIST=
 man_MANS=
 DISTCLEANFILES=
 
 LDADD= \
 	$(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
 	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 include $(top_srcdir)/doc/manuals/Substitute.am
 
 ## Several files need to be shared but we cannot depend on the other
 ## directories to be built.
 test_tools.cc: $(top_srcdir)/test-suite/test_tools.cc
-	cp $(top_srcdir)/test-suite/test_tools.cc .
+	cp $< $@
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
-	cp $(top_srcdir)/src/tests/stub_debug.cc .
+	cp $< $@
 
 time.cc: $(top_srcdir)/src/time.cc
-	cp $(top_srcdir)/src/time.cc .
+	cp $< $@
+
+stub_libmem.cc : $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $< $@
+	
+STUB.h : $(top_srcdir)/src/tests/STUB.h
+	cp $< $@
 
 # stock tools for unit tests - library independent versions of dlink_list
 # etc.
 # globals.cc is needed by test_tools.cc.
 # Neither of these should be disted from here.
 TESTSOURCES= test_tools.cc
-CLEANFILES += test_tools.cc stub_debug.cc time.cc
+CLEANFILES += test_tools.cc stub_debug.cc time.cc stub_libmem.cc STUB.h
 
 ## Test Scripts
 EXTRA_DIST += helper-ok-dying.pl helper-ok.pl
 
-
 ## ##### cachemgr.cgi  #####
 
 DEFAULT_CACHEMGR_CONFIG = $(sysconfdir)/cachemgr.conf
 
 libexec_PROGRAMS = cachemgr$(CGIEXT)
 
 cachemgr__CGIEXT__SOURCES = cachemgr.cc \
 	stub_debug.cc \
 	test_tools.cc \
-	time.cc
+	time.cc \
+	stub_libmem.cc \
+	STUB.h
 
 cachemgr__CGIEXT__CXXFLAGS = -DDEFAULT_CACHEMGR_CONFIG=\"$(DEFAULT_CACHEMGR_CONFIG)\" $(AM_CXXFLAGS)
 
 EXTRA_DIST += cachemgr.conf cachemgr.cgi.8 cachemgr.cgi.8.in
 CLEANFILES += cachemgr.cgi.8
 man_MANS += cachemgr.cgi.8
 
 cachemgr.cgi.8: $(srcdir)/cachemgr.cgi.8.in Makefile
 	$(SUBSTITUTE) < $(srcdir)/cachemgr.cgi.8.in > $@
 
-
-
 ## Shared
 
 install-data-local:
 	$(INSTALL_DATA) $(srcdir)/cachemgr.conf $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG).default
 	@if test -f $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG) ; then \
 	        echo "$@ will not overwrite existing $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG)" ; \
 	else \
 	        echo "$(INSTALL_DATA) $(srcdir)/cachemgr.conf $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG)"; \
 	        $(INSTALL_DATA) $(srcdir)/cachemgr.conf $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG); \
 	fi
 
 uninstall-local:
 	@$(SHELL) $(top_srcdir)/scripts/remove-cfg.sh "$(RM)" $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG)
 	$(RM) -f $(DESTDIR)$(DEFAULT_CACHEMGR_CONFIG).default

=== modified file 'tools/squidclient/Makefile.am'
--- tools/squidclient/Makefile.am	2015-08-03 03:50:25 +0000
+++ tools/squidclient/Makefile.am	2015-08-19 09:41:35 +0000
@@ -1,60 +1,69 @@
 ## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
 ##
 ## Squid software is distributed under GPLv2+ license and includes
 ## contributions from numerous individuals and organizations.
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
 include $(top_srcdir)/src/Common.am
 
 SUBDIRS =
 EXTRA_DIST = squidclient.1
 man_MANS = squidclient.1
 DISTCLEANFILES =
 
 LDADD = \
 	$(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
 	$(LIBGNUTLS_LIBS) \
 	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 include $(top_srcdir)/doc/manuals/Substitute.am
 
 ## Several files need to be shared but we cannot depend on the other
 ## directories to be built.
 test_tools.cc: $(top_srcdir)/test-suite/test_tools.cc
-	cp $(top_srcdir)/test-suite/test_tools.cc .
+	cp $< $@
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
-	cp $(top_srcdir)/src/tests/stub_debug.cc .
+	cp $< $@
 
 time.cc: $(top_srcdir)/src/time.cc
-	cp $(top_srcdir)/src/time.cc .
+	cp $< $@
+
+stub_libmem.cc : $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $< $@
+	
+STUB.h : $(top_srcdir)/src/tests/STUB.h
+	cp $< $@
+	
 
 # stock tools for unit tests - library independent versions of dlink_list
 # etc.
 # globals.cc is needed by test_tools.cc.
 # Neither of these should be disted from here.
 TESTSOURCES= test_tools.cc
-CLEANFILES += test_tools.cc stub_debug.cc time.cc
+CLEANFILES += test_tools.cc stub_debug.cc time.cc stub_libmem.cc STUB.h
 
 ## ##### squidclient  #####
 
 bin_PROGRAMS = squidclient
 
 squidclient_SOURCES = \
 	gssapi_support.cc \
 	gssapi_support.h \
 	Parameters.h \
 	Ping.cc \
 	Ping.h \
 	squidclient.cc \
 	stub_debug.cc \
 	test_tools.cc \
+	stub_libmem.cc \
+	STUB.h \
 	time.cc \
 	Transport.cc \
 	Transport.h

