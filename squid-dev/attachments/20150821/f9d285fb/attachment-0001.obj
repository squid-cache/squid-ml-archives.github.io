# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20150821103030-mh72gkskqn6j0gvx
# target_branch: file:///home/kinkie/squid/workspace/trunk/
# testament_sha1: 1ba375f2310a9aa056e73be752400095fbd49f08
# timestamp: 2015-08-21 12:32:29 +0200
# base_revision_id: kinkie@squid-cache.org-20150820120101-\
#   7qg6tue66iqx3k56
# 
# Begin patch
=== modified file 'acinclude/ax_cxx_0x_types.m4'
--- acinclude/ax_cxx_0x_types.m4	2015-05-23 20:17:16 +0000
+++ acinclude/ax_cxx_0x_types.m4	2015-08-20 13:38:59 +0000
@@ -75,3 +75,26 @@
   fi
   AC_LANG_POP
 ])
+
+## SQUID_CXX_STD_UNDERLYING_TYPE
+## checks whether the std::underlying_type<enumType>::type trait exists
+AC_DEFUN([SQUID_CXX_STD_UNDERLYING_TYPE],[
+  AC_CACHE_CHECK([whether compiler supports std::underlying_type],
+    [squid_cv_have_std_underlying_type],[
+      AC_REQUIRE([AC_PROG_CXX])
+      AC_LANG_PUSH([C++])
+      AC_COMPILE_IFELSE([
+        AC_LANG_PROGRAM([
+#include <type_traits>
+enum class testEnum { one, two, three };
+        ],[
+        std::underlying_type<testEnum>::type testNum = 0;
+        ])],
+        [squid_cv_have_std_underlying_type=yes],
+        [squid_cv_have_std_underlying_type=no])
+      AC_LANG_POP
+  ])
+  SQUID_DEFINE_BOOL([HAVE_STD_UNDERLYING_TYPE],
+     [$squid_cv_have_std_underlying_type],
+     [Define if stdlibc support std::underlying_type for enums])
+])

=== modified file 'configure.ac'
--- configure.ac	2015-08-03 03:50:25 +0000
+++ configure.ac	2015-08-20 13:38:59 +0000
@@ -2952,6 +2952,8 @@
 AX_CXX_TYPE_UNIQUE_PTR
 AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS
 
+SQUID_CXX_STD_UNDERLYING_TYPE
+
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
 dnl For this reason, we must check if pad128_t and upad128_t are defined.

=== modified file 'src/HttpHeader.cc'
--- src/HttpHeader.cc	2015-08-11 00:12:10 +0000
+++ src/HttpHeader.cc	2015-08-20 16:06:38 +0000
@@ -9,7 +9,7 @@
 /* DEBUG: section 55    HTTP Header */
 
 #include "squid.h"
-//#include "base/LookupTable.h" // pulled by HttpHdrCc.h
+#include "base/EnumIterator.h"
 #include "base64.h"
 #include "globals.h"
 #include "HttpHdrCc.h"
@@ -61,160 +61,13 @@
  */
 
 // statistics counters for headers. clients must not allow Http::HdrType::BAD_HDR to be counted
-std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::ENUM_END);
-
-/*
- * headers with field values defined as #(values) in HTTP/1.1
- * Headers that are currently not recognized, are commented out.
- */
-static HttpHeaderMask ListHeadersMask;  /* set run-time using  ListHeadersArr */
-static Http::HdrType ListHeadersArr[] = {
-    Http::HdrType::ACCEPT,
-    Http::HdrType::ACCEPT_CHARSET,
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_LANGUAGE,
-    Http::HdrType::ACCEPT_RANGES,
-    Http::HdrType::ALLOW,
-    Http::HdrType::CACHE_CONTROL,
-    Http::HdrType::CONTENT_ENCODING,
-    Http::HdrType::CONTENT_LANGUAGE,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::EXPECT,
-    Http::HdrType::IF_MATCH,
-    Http::HdrType::IF_NONE_MATCH,
-    Http::HdrType::KEY,
-    Http::HdrType::LINK,
-    Http::HdrType::PRAGMA,
-    Http::HdrType::PROXY_CONNECTION,
-    Http::HdrType::PROXY_SUPPORT,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    Http::HdrType::VARY,
-    Http::HdrType::VIA,
-    Http::HdrType::WARNING,
-    Http::HdrType::WWW_AUTHENTICATE,
-    Http::HdrType::AUTHENTICATION_INFO,
-    Http::HdrType::PROXY_AUTHENTICATION_INFO,
-    /* Http::HdrType::TE, Http::HdrType::TRAILER */
-#if X_ACCELERATOR_VARY
-    Http::HdrType::HDR_X_ACCELERATOR_VARY,
-#endif
-#if USE_ADAPTATION
-    Http::HdrType::X_NEXT_SERVICES,
-#endif
-    Http::HdrType::SURROGATE_CAPABILITY,
-    Http::HdrType::SURROGATE_CONTROL,
-    Http::HdrType::FORWARDED,
-    Http::HdrType::X_FORWARDED_FOR
-};
-
-/* general-headers */
-static Http::HdrType GeneralHeadersArr[] = {
-    Http::HdrType::CACHE_CONTROL,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::DATE,
-    Http::HdrType::FORWARDED,
-    Http::HdrType::X_FORWARDED_FOR,
-    Http::HdrType::MIME_VERSION,
-    Http::HdrType::PRAGMA,
-    Http::HdrType::PROXY_CONNECTION,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    /* Http::HdrType::TRAILER, */
-    Http::HdrType::VIA,
-};
-
-/* entity-headers */
-static Http::HdrType EntityHeadersArr[] = {
-    Http::HdrType::ALLOW,
-    Http::HdrType::CONTENT_BASE,
-    Http::HdrType::CONTENT_ENCODING,
-    Http::HdrType::CONTENT_LANGUAGE,
-    Http::HdrType::CONTENT_LENGTH,
-    Http::HdrType::CONTENT_LOCATION,
-    Http::HdrType::CONTENT_MD5,
-    Http::HdrType::CONTENT_RANGE,
-    Http::HdrType::CONTENT_TYPE,
-    Http::HdrType::ETAG,
-    Http::HdrType::EXPIRES,
-    Http::HdrType::LAST_MODIFIED,
-    Http::HdrType::LINK,
-    Http::HdrType::OTHER
-};
-
-/* request-only headers */
+std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::enumEnd_);
+
+/* request-only headers. Used for cachemgr */
 static HttpHeaderMask RequestHeadersMask;   /* set run-time using RequestHeaders */
-static Http::HdrType RequestHeadersArr[] = {
-    Http::HdrType::ACCEPT,
-    Http::HdrType::ACCEPT_CHARSET,
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_LANGUAGE,
-    Http::HdrType::AUTHORIZATION,
-    Http::HdrType::EXPECT,
-    Http::HdrType::FROM,
-    Http::HdrType::HOST,
-    Http::HdrType::HTTP2_SETTINGS,
-    Http::HdrType::IF_MATCH,
-    Http::HdrType::IF_MODIFIED_SINCE,
-    Http::HdrType::IF_NONE_MATCH,
-    Http::HdrType::IF_RANGE,
-    Http::HdrType::IF_UNMODIFIED_SINCE,
-    Http::HdrType::MAX_FORWARDS,
-    Http::HdrType::ORIGIN,
-    Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::RANGE,
-    Http::HdrType::REFERER,
-    Http::HdrType::REQUEST_RANGE,
-    Http::HdrType::TE,
-    Http::HdrType::USER_AGENT,
-    Http::HdrType::SURROGATE_CAPABILITY
-};
 
-/* reply-only headers */
+/* reply-only headers. Used for cachemgr */
 static HttpHeaderMask ReplyHeadersMask;     /* set run-time using ReplyHeaders */
-static Http::HdrType ReplyHeadersArr[] = {
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_RANGES,
-    Http::HdrType::AGE,
-    Http::HdrType::KEY,
-    Http::HdrType::LOCATION,
-    Http::HdrType::PROXY_AUTHENTICATE,
-    Http::HdrType::PUBLIC,
-    Http::HdrType::RETRY_AFTER,
-    Http::HdrType::SERVER,
-    Http::HdrType::SET_COOKIE,
-    Http::HdrType::SET_COOKIE2,
-    Http::HdrType::VARY,
-    Http::HdrType::WARNING,
-    Http::HdrType::WWW_AUTHENTICATE,
-    Http::HdrType::X_CACHE,
-    Http::HdrType::X_CACHE_LOOKUP,
-    Http::HdrType::X_REQUEST_URI,
-#if X_ACCELERATOR_VARY
-    Http::HdrType::HDR_X_ACCELERATOR_VARY,
-#endif
-#if USE_ADAPTATION
-    Http::HdrType::X_NEXT_SERVICES,
-#endif
-    Http::HdrType::X_SQUID_ERROR,
-    Http::HdrType::SURROGATE_CONTROL
-};
-
-/* hop-by-hop headers */
-static HttpHeaderMask HopByHopHeadersMask;
-static Http::HdrType HopByHopHeadersArr[] = {
-    Http::HdrType::ALTERNATE_PROTOCOL,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::HTTP2_SETTINGS,
-    Http::HdrType::KEEP_ALIVE,
-    /*Http::HdrType::PROXY_AUTHENTICATE, // removal handled specially for peer login */
-    Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::TE,
-    Http::HdrType::TRAILER,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    Http::HdrType::PROXY_CONNECTION
-};
 
 /* header accounting */
 // NP: keep in sync with enum http_hdr_owner_type
@@ -240,7 +93,9 @@
 
 class StoreEntry;
 
-static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, int error);
+// update parse statistics for header id; if error is true also account
+// for errors and write to debug log what happened
+static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, bool error);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
 /** store report about current header usage and other stats */
 static void httpHeaderStoreReport(StoreEntry * e);
@@ -261,28 +116,15 @@
 httpHeaderInitModule(void)
 {
     /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::ENUM_END);
-
-    // check invariant: for each index in headerTable, (int)headerTable[index] = index
-    for (int i = 0; Http::HeaderTable[i].name; ++i)
-        assert(Http::HeaderTable[i].id == i);
-
-    /* create masks. XXX: migrate to std::vector<bool>? */
-    httpHeaderMaskInit(&ListHeadersMask, 0);
-    httpHeaderCalcMask(&ListHeadersMask, ListHeadersArr, countof(ListHeadersArr));
-
-    httpHeaderMaskInit(&ReplyHeadersMask, 0);
-    httpHeaderCalcMask(&ReplyHeadersMask, ReplyHeadersArr, countof(ReplyHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
-
-    httpHeaderMaskInit(&RequestHeadersMask, 0);
-    httpHeaderCalcMask(&RequestHeadersMask, RequestHeadersArr, countof(RequestHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
-
-    httpHeaderMaskInit(&HopByHopHeadersMask, 0);
-    httpHeaderCalcMask(&HopByHopHeadersMask, HopByHopHeadersArr, countof(HopByHopHeadersArr));
+    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::enumEnd_);
+
+    // masks are needed for stats page still
+    for (auto h : WholeEnum<Http::HdrType>()) {
+        if (Http::HeaderLookupTable.lookup(h).request)
+            CBIT_SET(RequestHeadersMask,h);
+        if (Http::HeaderLookupTable.lookup(h).reply)
+            CBIT_SET(ReplyHeadersMask,h);
+    }
 
     /* header stats initialized by class constructor */
     assert(HttpHeaderStatCount == hoReply + 1);
@@ -363,7 +205,7 @@
         HttpHeaderStats[owner].busyDestroyedCount += entries.size() > 0;
     } // if (owner <= hoReply)
 
-    for(HttpHeaderEntry *e : entries) {
+    for (HttpHeaderEntry *e : entries) {
         if (e == nullptr)
             continue;
         if (!Http::any_valid_header(e->id)) {
@@ -386,25 +228,16 @@
 void
 HttpHeader::append(const HttpHeader * src)
 {
-    const HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     assert(src);
     assert(src != this);
     debugs(55, 7, "appending hdr: " << this << " += " << src);
 
-    while ((e = src->getEntry(&pos))) {
-        addEntry(e->clone());
+    for (auto e : src->entries) {
+        if (e != nullptr)
+            addEntry (e->clone());
     }
 }
 
-/* use fresh entries to replace old ones */
-void
-httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask)
-{
-    assert (old);
-    old->update (fresh, denied_mask);
-}
-
 void
 HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
 {
@@ -432,20 +265,12 @@
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        debugs(55, 7, "Updating header '" << Http::HeaderTable[e->id].name << "' in cached entry");
+        debugs(55, 7, "Updating header '" << Http::HeaderLookupTable.lookup(e->id).name << "' in cached entry");
 
         addEntry(e->clone());
     }
 }
 
-/* just handy in parsing: resets and returns false */
-int
-HttpHeader::reset()
-{
-    clean();
-    return 0;
-}
-
 int
 HttpHeader::parse(const char *header_start, size_t hdrLen)
 {
@@ -465,7 +290,8 @@
         debugs(55, DBG_IMPORTANT, "WARNING: HTTP header contains NULL characters {" <<
                getStringPrefix(header_start, nulpos-header_start) << "}\nNULL\n{" << getStringPrefix(nulpos+1, hdrLen-(nulpos-header_start)-1));
         PROF_stop(HttpHeaderParse);
-        return reset();
+        clean();
+        return 0;
     }
 
     /* common format headers are "<name>:[ws]<value>" lines delimited by <CRLF>.
@@ -481,7 +307,8 @@
             if (!field_ptr) {
                 // missing <LF>
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
 
             field_end = field_ptr;
@@ -502,7 +329,8 @@
                                "header field to prevent request smuggling attacks: {" <<
                                getStringPrefix(header_start, hdrLen) << "}");
                         PROF_stop(HttpHeaderParse);
-                        return reset();
+                        clean();
+                        return 0;
                     }
                 }
             }
@@ -521,7 +349,8 @@
                     }
                 } else {
                     PROF_stop(HttpHeaderParse);
-                    return reset();
+                    clean();
+                    return 0;
                 }
             }
 
@@ -529,7 +358,8 @@
                 debugs(55, warnOnError, "WARNING: Blank continuation line in HTTP header {" <<
                        getStringPrefix(header_start, hdrLen) << "}");
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         } while (field_ptr < header_end && (*field_ptr == ' ' || *field_ptr == '\t'));
 
@@ -538,7 +368,8 @@
                 debugs(55, warnOnError, "WARNING: unparseable HTTP header field near {" <<
                        getStringPrefix(field_start, hdrLen-(field_start-header_start)) << "}");
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
 
             break;      /* terminating blank line */
@@ -553,7 +384,8 @@
                 continue;
 
             PROF_stop(HttpHeaderParse);
-            return reset();
+            clean();
+            return 0;
         }
 
         // XXX: RFC 7230 Section 3.3.3 item #4 requires sending a 502 error in
@@ -567,7 +399,8 @@
                 if (!Config.onoff.relaxed_header_parser) {
                     delete e;
                     PROF_stop(HttpHeaderParse);
-                    return reset();
+                    clean();
+                    return 0;
                 }
 
                 if (!httpHeaderParseOffset(e->value.termedBuf(), &l1)) {
@@ -591,7 +424,8 @@
                     continue;
 
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         }
 
@@ -602,7 +436,8 @@
             if (!Config.onoff.relaxed_header_parser) {
                 delete e;
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         }
 
@@ -690,10 +525,8 @@
 HttpHeaderEntry *
 HttpHeader::findEntry(Http::HdrType id) const
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(!CBIT_TEST(ListHeadersMask, id));
+    assert(!Http::HeaderLookupTable.lookup(id).list);
 
     /* check mask first */
 
@@ -701,15 +534,14 @@
         return NULL;
 
     /* looks like we must have it, do linear search */
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
+    for (auto e : entries) {
+        if (e != nullptr && e->id == id)
             return e;
     }
 
     /* hm.. we thought it was there, but it was not found */
     assert(0);
-
-    return NULL;        /* not reached */
+    return nullptr;        /* not reached */
 }
 
 /*
@@ -718,25 +550,21 @@
 HttpHeaderEntry *
 HttpHeader::findLastEntry(Http::HdrType id) const
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    HttpHeaderEntry *result = NULL;
     assert(any_registered_header(id));
-    assert(!CBIT_TEST(ListHeadersMask, id));
+    assert(!Http::HeaderLookupTable.lookup(id).list);
 
     /* check mask first */
-
     if (!CBIT_TEST(mask, id))
         return NULL;
 
-    /* looks like we must have it, do linear search */
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
-            result = e;
+    for (auto e = entries.rbegin(); e != entries.rend(); ++e) {
+        if (*e && (*e)->id == id)
+            return *e;
     }
 
-    assert(result);     /* must be there! */
-    return result;
+    /* hm.. we thought it was there, but it was not found */
+    assert(0);
+    return nullptr; /* not reached */
 }
 
 /*
@@ -765,19 +593,17 @@
 int
 HttpHeader::delById(Http::HdrType id)
 {
-    int count = 0;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
     debugs(55, 8, this << " del-by-id " << id);
     assert(any_registered_header(id));
 
     if (!CBIT_TEST(mask, id))
         return 0;
 
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
-            delAt(pos, count);
-    }
+    int sz_before = entries.size();
+    entries.erase(std::remove_if(entries.begin(), entries.end(),
+    [=](HttpHeaderEntry *e) { return e && e->id == id; }),
+    entries.end());
+    int count = entries.size() - sz_before;
 
     CBIT_CLR(mask, id);
     assert(count);
@@ -811,9 +637,8 @@
 HttpHeader::compact()
 {
     // TODO: optimize removal, or possibly make it so that's not needed.
-    std::vector<HttpHeaderEntry *>::iterator newend;
-    newend = std::remove(entries.begin(), entries.end(), static_cast<HttpHeaderEntry *>(NULL));
-    entries.resize(newend-entries.begin());
+    entries.erase( std::remove(entries.begin(), entries.end(), nullptr),
+                   entries.end());
 }
 
 /*
@@ -824,9 +649,9 @@
 {
     httpHeaderMaskInit(&mask, 0);
     debugs(55, 7, "refreshing the mask in hdr " << this);
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    while (HttpHeaderEntry *e = getEntry(&pos)) {
-        CBIT_SET(mask, e->id);
+    for (auto e : entries) {
+        if (e != nullptr)
+            CBIT_SET(mask, e->id);
     }
 }
 
@@ -883,17 +708,15 @@
 bool
 HttpHeader::getList(Http::HdrType id, String *s) const
 {
-    HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     debugs(55, 9, this << " joining for id " << id);
     /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
+    assert(Http::HeaderLookupTable.lookup(id).list);
 
     if (!CBIT_TEST(mask, id))
         return false;
 
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
+    for (auto e: entries) {
+        if (e != nullptr && e->id == id)
             strListAdd(s, e->value.termedBuf(), ',');
     }
 
@@ -904,7 +727,7 @@
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s->size())
-        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderLookupTable.lookup(id).name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -919,7 +742,7 @@
     HttpHeaderPos pos = HttpHeaderInitPos;
     debugs(55, 9, this << "joining for id " << id);
     /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
+    assert(Http::HeaderLookupTable.lookup(id).list);
 
     if (!CBIT_TEST(mask, id))
         return String();
@@ -938,7 +761,7 @@
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s.size())
-        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderLookupTable.lookup(id).name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -951,7 +774,7 @@
 {
     HttpHeaderEntry *e;
 
-    if (CBIT_TEST(ListHeadersMask, id))
+    if (Http::HeaderLookupTable.lookup(id).list)
         return getList(id);
 
     if ((e = findEntry(id)))
@@ -968,12 +791,46 @@
 {
     String result;
     // ignore presence: return undefined string if an empty header is present
+    (void)getByNameIfPresent(name, strlen(name), result);
+    return result;
+}
+
+String
+HttpHeader::getByName(const SBuf &name) const
+{
+    String result;
+    // ignore presence: return undefined string if an empty header is present
     (void)getByNameIfPresent(name, result);
     return result;
 }
 
-bool
-HttpHeader::getByNameIfPresent(const char *name, String &result) const
+String
+HttpHeader::getById(Http::HdrType id) const
+{
+    String result;
+    (void)getByIdIfPresent(id,result);
+    return result;
+}
+
+bool
+HttpHeader::getByNameIfPresent(const SBuf &s, String &result) const
+{
+    return getByNameIfPresent(s.rawContent(), s.length(), result);
+}
+
+bool
+HttpHeader::getByIdIfPresent(Http::HdrType id, String &result) const
+{
+    if (id == Http::HdrType::BAD_HDR)
+        return false;
+    if (!has(id))
+        return false;
+    result = getStrOrList(id);
+    return true;
+}
+
+bool
+HttpHeader::getByNameIfPresent(const char *name, int namelen, String &result) const
 {
     Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -982,13 +839,11 @@
     assert(name);
 
     /* First try the quick path */
-    id = Http::HeaderLookupTable.lookup(SBuf(name));
+    id = Http::HeaderLookupTable.lookup(name,namelen).id;
 
     if (id != Http::HdrType::BAD_HDR) {
-        if (!has(id))
-            return false;
-        result = getStrOrList(id);
-        return true;
+        if (getByIdIfPresent(id, result))
+            return true;
     }
 
     /* Sorry, an unknown header name. Do linear search */
@@ -1072,7 +927,7 @@
 HttpHeader::putInt(Http::HdrType id, int number)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xitoa(number)));
 }
@@ -1081,7 +936,7 @@
 HttpHeader::putInt64(Http::HdrType id, int64_t number)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xint64toa(number)));
 }
@@ -1090,25 +945,16 @@
 HttpHeader::putTime(Http::HdrType id, time_t htime)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
 void
-HttpHeader::insertTime(Http::HdrType id, time_t htime)
-{
-    assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
-    assert(htime >= 0);
-    insertEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
-}
-
-void
 HttpHeader::putStr(Http::HdrType id, const char *str)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
     assert(str);
     addEntry(new HttpHeaderEntry(id, NULL, str));
 }
@@ -1205,7 +1051,7 @@
 HttpHeader::getInt(Http::HdrType id) const
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1218,7 +1064,7 @@
 HttpHeader::getInt64(Http::HdrType id) const
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1233,7 +1079,7 @@
     HttpHeaderEntry *e;
     time_t value = -1;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         value = parse_rfc1123(e->value.termedBuf());
@@ -1249,10 +1095,10 @@
 {
     HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
-        httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
+        httpHeaderNoteParsedEntry(e->id, e->value, false);  /* no errors are possible */
         return e->value.termedBuf();
     }
 
@@ -1265,10 +1111,10 @@
 {
     HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findLastEntry(id))) {
-        httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
+        httpHeaderNoteParsedEntry(e->id, e->value, false);  /* no errors are possible */
         return e->value.termedBuf();
     }
 
@@ -1403,7 +1249,7 @@
 {
     ETag etag = {NULL, -1};
     HttpHeaderEntry *e;
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
 
     if ((e = findEntry(id)))
         etagParseInit(&etag, e->value.termedBuf());
@@ -1416,7 +1262,7 @@
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
 
     if ((e = findEntry(id))) {
@@ -1448,7 +1294,7 @@
     id = anId;
 
     if (id != Http::HdrType::OTHER)
-        name = Http::HeaderTable[id].name;
+        name = Http::HeaderLookupTable.lookup(id).name;
     else
         name = aName;
 
@@ -1511,7 +1357,7 @@
     debugs(55, 9, "parsing HttpHeaderEntry: near '" <<  getStringPrefix(field_start, field_end-field_start) << "'");
 
     /* is it a "known" field? */
-    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(field_start,name_len));
+    Http::HdrType id = Http::HeaderLookupTable.lookup(field_start,name_len).id;
     debugs(55, 9, "got hdr-id=" << id);
 
     String name;
@@ -1525,7 +1371,7 @@
     if (id == Http::HdrType::OTHER)
         name.limitInit(field_start, name_len);
     else
-        name = Http::HeaderTable[id].name;
+        name = Http::HeaderLookupTable.lookup(id).name;
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
@@ -1576,7 +1422,7 @@
 {
     int val = -1;
     int ok = httpHeaderParseInt(value.termedBuf(), &val);
-    httpHeaderNoteParsedEntry(id, value, !ok);
+    httpHeaderNoteParsedEntry(id, value, ok == 0);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
@@ -1588,7 +1434,7 @@
 {
     int64_t val = -1;
     int ok = httpHeaderParseOffset(value.termedBuf(), &val);
-    httpHeaderNoteParsedEntry(id, value, !ok);
+    httpHeaderNoteParsedEntry(id, value, ok == 0);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
@@ -1596,7 +1442,7 @@
 }
 
 static void
-httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, int error)
+httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, bool error)
 {
     if (id != Http::HdrType::BAD_HDR)
         ++ headerStatsTable[id].parsCount;
@@ -1604,7 +1450,7 @@
     if (error) {
         if (id != Http::HdrType::BAD_HDR)
             ++ headerStatsTable[id].errCount;
-        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderTable[id].name << ": " << context << "'");
+        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderLookupTable.lookup(id).name << ": " << context << "'");
     }
 }
 
@@ -1621,7 +1467,7 @@
 {
     const int id = static_cast<int>(val);
     const bool valid_id = Http::any_valid_header(static_cast<Http::HdrType>(id));
-    const char *name = valid_id ? Http::HeaderTable[id].name : "INVALID";
+    const char *name = valid_id ? Http::HeaderLookupTable.lookup(static_cast<Http::HdrType>(id)).name : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
 
@@ -1696,11 +1542,11 @@
                       "id", "name", "#alive", "%err", "%repeat");
 
     // scan heaaderTable and output
-    for (int j = 0; Http::HeaderTable[j].name != nullptr; ++j) {
-        auto stats = headerStatsTable[j];
+    for (auto h : WholeEnum<Http::HdrType>()) {
+        auto stats = headerStatsTable[h];
         storeAppendPrintf(e, "%2d\t %-25s\t %5d\t %6.3f\t %6.3f\n",
-                          Http::HeaderTable[j].id,
-                          Http::HeaderTable[j].name,
+                          Http::HeaderLookupTable.lookup(h).id,
+                          Http::HeaderLookupTable.lookup(h).name,
                           stats.aliveCount,
                           xpercent(stats.errCount, stats.parsCount),
                           xpercent(stats.repCount, stats.seenCount));
@@ -1771,7 +1617,7 @@
     int headers_deleted = 0;
     while ((e = getEntry(&pos))) {
         Http::HdrType id = e->id;
-        if (CBIT_TEST(HopByHopHeadersMask, id)) {
+        if (Http::HeaderLookupTable.lookup(id).hopbyhop) {
             delAt(pos, headers_deleted);
             CBIT_CLR(mask, id);
         }

=== modified file 'src/HttpHeader.h'
--- src/HttpHeader.h	2015-08-10 21:23:12 +0000
+++ src/HttpHeader.h	2015-08-17 07:08:29 +0000
@@ -83,7 +83,6 @@
     void append(const HttpHeader * src);
     void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
     void compact();
-    int reset();
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
@@ -98,16 +97,20 @@
     bool getList(Http::HdrType id, String *s) const;
     bool conflictingContentLength() const { return conflictingContentLength_; }
     String getStrOrList(Http::HdrType id) const;
+    String getByName(const SBuf &name) const;
     String getByName(const char *name) const;
+    String getById(Http::HdrType id) const;
+    /// sets value and returns true iff a [possibly empty] field identified by id is there
+    bool getByIdIfPresent(Http::HdrType id, String &result) const;
     /// sets value and returns true iff a [possibly empty] named field is there
-    bool getByNameIfPresent(const char *name, String &value) const;
+    bool getByNameIfPresent(const SBuf &s, String &value) const;
+    bool getByNameIfPresent(const char *name, int namelen, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(Http::HdrType id, const char *member, const char separator) const;
     int has(Http::HdrType id) const;
     void putInt(Http::HdrType id, int number);
     void putInt64(Http::HdrType id, int64_t number);
     void putTime(Http::HdrType id, time_t htime);
-    void insertTime(Http::HdrType id, time_t htime);
     void putStr(Http::HdrType id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
@@ -153,8 +156,6 @@
 /// quotes string using RFC 7230 quoted-string rules
 SBuf httpHeaderQuoteString(const char *raw);
 
-int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
 void httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count);
 
 inline bool

=== modified file 'src/HttpHeaderStat.h'
--- src/HttpHeaderStat.h	2015-08-05 13:47:19 +0000
+++ src/HttpHeaderStat.h	2015-08-13 12:27:56 +0000
@@ -27,7 +27,7 @@
         busyDestroyedCount(0)
     {
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::enumEnd_);
         ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -43,7 +43,7 @@
     {
         assert(label);
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::enumEnd_);
         ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }

=== modified file 'src/HttpHeaderTools.cc'
--- src/HttpHeaderTools.cc	2015-08-05 13:47:19 +0000
+++ src/HttpHeaderTools.cc	2015-08-21 10:30:30 +0000
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
+#include "base/EnumIterator.h"
 #include "client_side.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
@@ -45,21 +46,6 @@
     memset(mask, value, sizeof(*mask));
 }
 
-/** calculates a bit mask of a given array; does not reset mask! */
-void
-httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count)
-{
-    size_t i;
-    const int * enums = (const int *) http_hdr_type_enums;
-    assert(mask && enums);
-    assert(count < sizeof(*mask) * 8);  /* check for overflow */
-
-    for (i = 0; i < count; ++i) {
-        assert(!CBIT_TEST(*mask, enums[i]));    /* check for duplicates */
-        CBIT_SET(*mask, enums[i]);
-    }
-}
-
 /* same as httpHeaderPutStr, but formats the string using snprintf first */
 void
 httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...)
@@ -155,9 +141,12 @@
 {
     errno = 0;
     int64_t res = strtoll(start, NULL, 10);
-    if (!res && EINVAL == errno)    /* maybe not portable? */
+    if (!res && EINVAL == errno) {   /* maybe not portable? */
+        debugs(66, 7, "failed to parse offset in " << start);
         return 0;
+    }
     *value = res;
+    debugs(66, 7, "offset " << start << " parsed as " << res);
     return 1;
 }
 
@@ -295,13 +284,16 @@
     }
 
     /* manglers are not configured for this message kind */
-    if (!hms)
+    if (!hms) {
+        debugs(66, 7, "no manglers configured for message kind " << req_or_rep);
         return 1;
+    }
 
     const headerMangler *hm = hms->find(*e);
 
     /* mangler or checklist went away. default allow */
     if (!hm || !hm->access_list) {
+        debugs(66, 7, "couldn't find mangler or access list. Allowing");
         return 1;
     }
 
@@ -309,15 +301,18 @@
 
     if (checklist.fastCheck() == ACCESS_ALLOWED) {
         /* aclCheckFast returns true for allow. */
+        debugs(66, 7, "checklist for mangler is positive. Mangle");
         retval = 1;
     } else if (NULL == hm->replacement) {
         /* It was denied, and we don't have any replacement */
+        debugs(66, 7, "checklist denied, we have no replacement. Pass");
         retval = 0;
     } else {
         /* It was denied, but we have a replacement. Replace the
          * header on the fly, and return that the new header
          * is allowed.
          */
+        debugs(66, 7, "checklist denied but we have replacement. Replace");
         e->value = hm->replacement;
         retval = 1;
     }
@@ -374,12 +369,11 @@
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < Http::HdrType::ENUM_END; ++i)
+    for (auto i : WholeEnum<Http::HdrType>())
         header_mangler_clean(known[i]);
 
-    typedef ManglersByName::iterator MBNI;
-    for (MBNI i = custom.begin(); i != custom.end(); ++i)
-        header_mangler_clean(i->second);
+    for (auto i : custom)
+        header_mangler_clean(i.second);
 
     header_mangler_clean(all);
 }
@@ -387,13 +381,11 @@
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
-        header_mangler_dump_access(entry, name, known[i], Http::HeaderTable[i].name);
-    }
+    for (auto id : WholeEnum<Http::HdrType>())
+        header_mangler_dump_access(entry, name, known[id], Http::HeaderLookupTable.lookup(id).name);
 
-    typedef ManglersByName::const_iterator MBNCI;
-    for (MBNCI i = custom.begin(); i != custom.end(); ++i)
-        header_mangler_dump_access(entry, name, i->second, i->first.c_str());
+    for (auto i : custom)
+        header_mangler_dump_access(entry, name, i.second, i.first.c_str());
 
     header_mangler_dump_access(entry, name, all, "All");
 }
@@ -401,14 +393,12 @@
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
-        header_mangler_dump_replacement(entry, name, known[i],Http::HeaderTable[i].name);
+    for (auto id : WholeEnum<Http::HdrType>()) {
+        header_mangler_dump_replacement(entry, name, known[id], Http::HeaderLookupTable.lookup(id).name);
     }
 
-    typedef ManglersByName::const_iterator MBNCI;
-    for (MBNCI i = custom.begin(); i != custom.end(); ++i) {
-        header_mangler_dump_replacement(entry, name, i->second,
-                                        i->first.c_str());
+    for (auto i: custom) {
+        header_mangler_dump_replacement(entry, name, i.second, i.first.c_str());
     }
 
     header_mangler_dump_replacement(entry, name, all, "All");
@@ -417,26 +407,18 @@
 headerMangler *
 HeaderManglers::track(const char *name)
 {
-    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name));
-
-    if (id == Http::HdrType::BAD_HDR) { // special keyword or a custom header
-        if (strcmp(name, "All") == 0)
-            id = Http::HdrType::ENUM_END;
-        else if (strcmp(name, "Other") == 0)
-            id = Http::HdrType::OTHER;
-    }
-
-    headerMangler *m = NULL;
-    if (id == Http::HdrType::ENUM_END) {
-        m = &all;
-    } else if (id == Http::HdrType::BAD_HDR) {
-        m = &custom[name];
-    } else {
-        m = &known[id]; // including Http::HdrType::OTHER
-    }
-
-    assert(m);
-    return m;
+    if (strcmp(name, "All") == 0)
+        return &all;
+
+    const Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name)).id;
+
+    if (id != Http::HdrType::BAD_HDR)
+        return &known[id];
+
+    if (strcmp(name, "Other") == 0)
+        return &known[Http::HdrType::OTHER];
+
+    return &custom[name];
 }
 
 void

=== modified file 'src/HttpHeaderTools.h'
--- src/HttpHeaderTools.h	2015-08-04 19:57:07 +0000
+++ src/HttpHeaderTools.h	2015-08-13 12:27:56 +0000
@@ -74,7 +74,7 @@
     typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
-    headerMangler known[static_cast<int>(Http::HdrType::ENUM_END)];
+    headerMangler known[static_cast<int>(Http::HdrType::enumEnd_)];
 
     /// one mangler for each custom header
     ManglersByName custom;

=== modified file 'src/HttpReply.cc'
--- src/HttpReply.cc	2015-08-04 19:57:07 +0000
+++ src/HttpReply.cc	2015-08-20 16:06:38 +0000
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
+#include "base/EnumIterator.h"
 #include "globals.h"
 #include "HttpBody.h"
 #include "HttpHdrCc.h"
@@ -38,16 +39,11 @@
  * The list of headers we don't update is made up of:
  *     all hop-by-hop headers
  *     all entity-headers except Expires and Content-Location
+ *
+ * These headers are now stored in RegisteredHeadersHash.gperf and accessible
+ * as Http::HeaderLookupTable.lookup(id).denied304
  */
 static HttpHeaderMask Denied304HeadersMask;
-static Http::HdrType Denied304HeadersArr[] = {
-    // hop-by-hop headers
-    Http::HdrType::CONNECTION, Http::HdrType::KEEP_ALIVE, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::TE, Http::HdrType::TRAILER, Http::HdrType::TRANSFER_ENCODING, Http::HdrType::UPGRADE,
-    // entity headers
-    Http::HdrType::ALLOW, Http::HdrType::CONTENT_ENCODING, Http::HdrType::CONTENT_LANGUAGE, Http::HdrType::CONTENT_LENGTH,
-    Http::HdrType::CONTENT_MD5, Http::HdrType::CONTENT_RANGE, Http::HdrType::CONTENT_TYPE, Http::HdrType::LAST_MODIFIED
-};
 
 /* module initialization */
 void
@@ -55,7 +51,10 @@
 {
     assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
     httpHeaderMaskInit(&Denied304HeadersMask, 0);
-    httpHeaderCalcMask(&Denied304HeadersMask, Denied304HeadersArr, countof(Denied304HeadersArr));
+
+    for (auto id : WholeEnum<Http::HdrType>())
+        if (Http::HeaderLookupTable.lookup(id).denied304)
+            CBIT_SET(Denied304HeadersMask, id);
 }
 
 HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-08-03 03:50:25 +0000
+++ src/Makefile.am	2015-08-20 14:15:30 +0000
@@ -420,6 +420,8 @@
 	send-announce.h \
 	send-announce.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	SBufDetailedStats.cc \
 	SBufStatsAction.h \
@@ -904,6 +906,7 @@
 	tests/testCharacterSet \
 	tests/testDiskIO \
 	tests/testDns \
+	tests/testEnumIterator \
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
@@ -945,6 +948,7 @@
 #	X.h \
 #	X.cc
 #nodist_tests_testX_SOURCES=\
+#   tests/stubs_as_needed.cc\
 #	$(TESTSOURCES)
 #tests_testX_LDFLAGS = $(LIBADD_DL)
 #tests_testX_LDADD=\
@@ -997,6 +1001,8 @@
 	SquidString.h \
 	SquidTime.h \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -1109,6 +1115,8 @@
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -1375,6 +1383,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -1546,6 +1556,8 @@
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	StoreFileSystem.cc \
@@ -1809,6 +1821,8 @@
 	StrList.h \
 	StrList.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2049,6 +2063,8 @@
 	refresh.h \
 	refresh.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2287,6 +2303,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2434,6 +2452,8 @@
 	cache_cf.h \
 	YesNoNone.h \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	tests/stub_SBufDetailedStats.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
@@ -2609,6 +2629,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2817,6 +2839,8 @@
 	store_key_md5.h \
 	store_key_md5.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3061,6 +3085,8 @@
 	tests/stub_helper.cc \
 	cbdata.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3237,6 +3263,8 @@
 	store_swapmeta.cc \
 	store_swapout.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3454,6 +3482,8 @@
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -3747,7 +3777,9 @@
 	tests/stub_SBufDetailedStats.cc \
 	base/LookupTable.h \
 	String.cc \
-	$(SBUF_SOURCE)
+	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc
 nodist_tests_testLookupTable_SOURCES = $(TESTSOURCES)
 tests_testLookupTable_LDFLAGS = $(LIBADD_DL)
 tests_testLookupTable_LDADD = \
@@ -3757,6 +3789,22 @@
 	$(XTRA_LIBS)
 tests_testLookupTable_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testEnumIterator_SOURCES = \
+	tests/testEnumIterator.h \
+	tests/testEnumIterator.cc
+nodist_tests_testEnumIterator_SOURCES = \
+	base/EnumIterator.h \
+	tests/stub_debug.cc \
+	$(TESTSOURCES)
+tests_testEnumIterator_LDFLAGS = $(LIBADD_DL)
+tests_testEnumIterator_LDADD = \
+	base/libbase.la \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(SQUID_CPPUNIT_LA) \
+	$(XTRA_LIBS)
+tests_testEnumIterator_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
+
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script

=== modified file 'src/SBufAlgos.cc'
--- src/SBufAlgos.cc	2015-07-29 18:12:16 +0000
+++ src/SBufAlgos.cc	2015-08-13 13:55:42 +0000
@@ -9,17 +9,32 @@
 #include "squid.h"
 #include "SBufAlgos.h"
 
-std::size_t std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+#include <cctype>
+
+static std::size_t
+lowSBufHash (const SBuf & sbuf, bool caseInsensitive = false) noexcept
 {
     //ripped and adapted from hash_string
     const char *s = sbuf.rawContent();
     size_t rv = 0;
     SBuf::size_type len=sbuf.length();
     while (len != 0) {
-        rv ^= 271 * *s;
+        rv ^= 271 * (caseInsensitive? tolower(*s) : *s);
         ++s;
         --len;
     }
     return rv ^ (sbuf.length() * 271);
 }
 
+std::size_t
+std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+{
+    return lowSBufHash(sbuf);
+}
+
+std::size_t
+CaseInsensitiveSBufHash::operator() (const SBuf & sbuf) const noexcept
+{
+    return lowSBufHash(sbuf, true);
+}
+

=== modified file 'src/SBufAlgos.h'
--- src/SBufAlgos.h	2015-07-29 18:12:16 +0000
+++ src/SBufAlgos.h	2015-08-20 14:32:36 +0000
@@ -90,5 +90,16 @@
 };
 }
 
+/** hash functor for SBufs, meant so support case-insensitive std::unordered_map
+ *
+ * Typical use:
+ * `auto m = std::unordered_map<SBuf, ValueType, CaseInsensitiveSBufHash>();`
+ */
+class CaseInsensitiveSBufHash
+{
+public:
+    std::size_t operator()(const SBuf &) const noexcept;
+};
+
 #endif /* SQUID_SBUFALGOS_H_ */
 

=== modified file 'src/acl/HttpHeaderData.cc'
--- src/acl/HttpHeaderData.cc	2015-08-04 21:04:09 +0000
+++ src/acl/HttpHeaderData.cc	2015-08-11 10:29:25 +0000
@@ -47,7 +47,7 @@
             return false;
         value = hdr->getStrOrList(hdrId);
     } else {
-        if (!hdr->getByNameIfPresent(hdrName.termedBuf(), value))
+        if (!hdr->getByNameIfPresent(hdrName, value))
             return false;
     }
 
@@ -76,14 +76,14 @@
     char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
-    hdrId = Http::HeaderLookupTable.lookup(SBuf(hdrName));
+    hdrId = Http::HeaderLookupTable.lookup(hdrName).id;
     regex_rule->parse();
 }
 
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == Http::HdrType::BAD_HDR && hdrName.size()==0) || regex_rule->empty();
+    return (hdrId == Http::HdrType::BAD_HDR && hdrName.isEmpty()) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *

=== modified file 'src/acl/HttpHeaderData.h'
--- src/acl/HttpHeaderData.h	2015-08-04 19:57:07 +0000
+++ src/acl/HttpHeaderData.h	2015-08-10 15:57:56 +0000
@@ -11,6 +11,7 @@
 
 #include "acl/Data.h"
 #include "HttpHeader.h"
+#include "SBuf.h"
 #include "SquidString.h"
 
 class ACLHTTPHeaderData : public ACLData<HttpHeader*>
@@ -28,7 +29,7 @@
 
 private:
     Http::HdrType hdrId;                /**< set if header is known */
-    String hdrName;                     /**< always set */
+    SBuf hdrName;                     /**< always set */
     ACLData<char const *> * regex_rule;
 };
 

=== modified file 'src/adaptation/icap/ModXact.cc'
--- src/adaptation/icap/ModXact.cc	2015-08-04 19:57:07 +0000
+++ src/adaptation/icap/ModXact.cc	2015-08-20 15:56:45 +0000
@@ -1342,12 +1342,12 @@
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
-        String vh=virgin.header->header.getByName("Proxy-Authenticate");
+        String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHENTICATE);
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHORIZATION)) {
-        String vh=virgin.header->header.getByName("Proxy-Authorization");
+        String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHORIZATION);
         buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
         struct base64_encode_ctx ctx;

=== modified file 'src/auth/UserRequest.cc'
--- src/auth/UserRequest.cc	2015-08-04 19:57:07 +0000
+++ src/auth/UserRequest.cc	2015-08-13 12:27:56 +0000
@@ -481,11 +481,11 @@
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
-        type = Http::HdrType::ENUM_END;
+        type = Http::HdrType::BAD_HDR;
         break;
     }
 
-    debugs(29, 9, HERE << "headertype:" << type << " authuser:" << auth_user_request);
+    debugs(29, 9, "headertype:" << type << " authuser:" << auth_user_request);
 
     if (((rep->sline.status() == Http::scProxyAuthenticationRequired)
             || (rep->sline.status() == Http::scUnauthorized)) && internal)

=== added file 'src/base/EnumIterator.h'
--- src/base/EnumIterator.h	1970-01-01 00:00:00 +0000
+++ src/base/EnumIterator.h	2015-08-20 15:56:45 +0000
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+#ifndef SQUID_BASE_ENUMITERATOR_H
+#define SQUID_BASE_ENUMITERATOR_H
+
+#include <iterator>
+#include <type_traits>
+
+/** Shared functionality between forward and reverse enum iterators
+ *
+ * This class is not very useful by itself, it contains code shared by
+ * EnumIterator and ReverseEnumIterator.
+ *
+ * \see EnumIterator, ReverseEnumIterator
+ */
+template <typename EnumType>
+class EnumIteratorBase : public std::iterator<std::bidirectional_iterator_tag, EnumType>
+{
+public:
+    explicit EnumIteratorBase(EnumType e) : current(static_cast<iterator_type>(e)) {}
+
+    bool operator==(const EnumIteratorBase &i) const {
+        return current == i.current;
+    }
+
+    bool operator!=(const EnumIteratorBase &i) const {
+        return current != i.current;
+    }
+
+    EnumType operator*() const {
+        return static_cast<EnumType>(current);
+    }
+
+protected:
+#if HAVE_STD_UNDERLYING_TYPE
+    typedef typename std::underlying_type<EnumType>::type iterator_type;
+#else
+    typedef int iterator_type;
+#endif
+    iterator_type current;
+};
+
+/** bidirectional iterator over an enum type
+ *
+ * It can be instantiated using any enum (or c++11 strongly-typed enum)
+ * value; the most common expected use scenario has iterators emitted by
+ * EnumRange and WholeEnum via standard `begin()` and `end()` calls.
+ *
+ * In order for the iterator to work, it is mandatory that the underlying
+ * enum type's representation values be sequential.
+ *
+ * The iterator doesn't check for bounds; behavior is undefined if the iterator
+ * is incremented (or decremented) outside the range representing valid
+ * enum symbols (remember: an enum is not a data structure)
+ *
+ * \see EnumRange, WholeEnum, ReverseEnumIterator
+ */
+template <typename EnumType>
+class EnumIterator : public EnumIteratorBase<EnumType>
+{
+public:
+    explicit EnumIterator(EnumType e) : EnumIteratorBase<EnumType>(e) {}
+
+    // prefix increment
+    EnumIterator& operator++() {
+        ++ EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix increment
+    EnumIterator& operator++(int) {
+        EnumIterator rv(*this);
+        ++ EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+
+    // prefix decrement
+    EnumIterator& operator--() {
+        -- EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix decrement
+    EnumIterator& operator--(int) {
+        EnumIterator rv(*this);
+        -- EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+};
+
+/** bidirectional reverse iterator over an enum type
+ *
+ * It can be instantiated using any enum (or c++11 strongly-typed enum)
+ * value; the most common expected use scenario has iterators emitted by
+ * EnumRange and WholeEnum via standard `rbegin()` and `rend()` calls.
+ *
+ * In order for the iterator to work, it is mandatory that the underlying
+ * enum type's representation values be sequential.
+ *
+ * The iterator doesn't check for bounds; behavior is undefined if the iterator
+ * is incremented (or decremented) outside the range representing valid
+ * enum symbols (remember: an enum is not a data structure).
+ *
+ * \see EnumRange, WholeEnum, EnumIterator
+ */
+template <typename EnumType>
+class ReverseEnumIterator : public EnumIteratorBase<EnumType>
+{
+public:
+    explicit ReverseEnumIterator(EnumType e) : EnumIteratorBase<EnumType>(e) {}
+
+    // prefix increment
+    ReverseEnumIterator& operator++() {
+        -- EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix increment
+    ReverseEnumIterator& operator++(int) {
+        ReverseEnumIterator rv(*this);
+        -- EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+
+    // prefix decrement
+    ReverseEnumIterator& operator--() {
+        ++ EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix decrement
+    ReverseEnumIterator& operator--(int) {
+        ReverseEnumIterator rv(*this);
+        ++ EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+};
+
+/** Class expressing a continuous range of an enum for range-for expressions
+ *
+ * This class requires that the underlying enum values be represented by
+ * continuous values of an integral type.
+ * Users will usually not rely on this class directly but on the more convenient
+ * EnumRange function
+ *
+ * \mote `EnumIterator<enum>(EnumType::firstmember,EnumType::lastmember)`
+ * will miss `EnumType::lastmember` while iterating. If you need to iterate
+ * over all of EnumType, use class WholeEnum. Otherwise you'll have to
+ * explicitly address lastmember outside the iteration loop.
+ *
+ * \see EnumRange(EnumType begin, EnumType one_past_end), WholeEnum
+ */
+template <typename EnumType>
+class EnumRangeT
+{
+public:
+    typedef EnumIterator<EnumType> iterator;
+    typedef ReverseEnumIterator<EnumType> reverse_iterator;
+    EnumRangeT(EnumType first, EnumType one_past_last) : begin_(first), end_(one_past_last) { }
+    iterator begin() const { return iterator(begin_);}
+    iterator end() const { return iterator(end_);}
+    reverse_iterator rbegin() const { return ++reverse_iterator(end_); }
+    reverse_iterator rend() const { return ++reverse_iterator(begin_); }
+private:
+    EnumType begin_;
+    EnumType end_;
+};
+
+/** Generate a continuous range of an enum for range-for expressions
+ *
+ * convenience function to deduce the right type for instantiating EnumRangeT.
+ * See EnumRangeT for more detailed documentation and caveats.
+ *
+ * Typical use:
+ * \code
+ * for (auto enumvalue : EnumRange(EnumType::first,EnumType::onePastLast))
+ *      { do_stuff(); }
+ * \endcode
+ */
+template <typename EnumType>
+EnumRangeT<EnumType> EnumRange(EnumType begin, EnumType one_past_end)
+{
+    return EnumRangeT<EnumType>(begin,one_past_end);
+}
+
+/** Class for iterating all enum values, from EnumType::enumBegin_ up to, but
+ *  not including, EnumType::enumEnd_. Both markers must be present as enum values.
+ *
+ * This class requires that the underlying enum values be represented by
+ * continuous values of an integral type.
+ *
+ * Typical use:
+ * \code
+ * for(auto enumvalue : WholeEnum<EnumType>())
+ * { do_stuff(); }
+ * \endcode
+ */
+template <typename EnumType>
+class WholeEnum : public EnumRangeT<EnumType>
+{
+public:
+    WholeEnum() : EnumRangeT<EnumType>(EnumType::enumBegin_, EnumType::enumEnd_) {}
+};
+
+#endif /* SQUID_BASE_ENUMITERATOR_H */
+

=== modified file 'src/base/LookupTable.h'
--- src/base/LookupTable.h	2015-08-04 14:58:58 +0000
+++ src/base/LookupTable.h	2015-08-06 15:38:27 +0000
@@ -10,8 +10,9 @@
 #define SQUID_LOOKUPTABLE_H_
 
 #include "SBuf.h"
+#include "SBufAlgos.h"
 
-#include <map>
+#include <unordered_map>
 
 /**
  * a record in the initializer list for a LookupTable
@@ -53,7 +54,7 @@
     }
 };
 
-template<typename EnumType, typename RecordType = LookupTableRecord<EnumType> >
+template<typename EnumType, typename RecordType = LookupTableRecord<EnumType>, typename Hasher = CaseInsensitiveSBufHash >
 class LookupTable
 {
 public:
@@ -76,7 +77,7 @@
     }
 
 private:
-    typedef std::map<const SBuf, EnumType, SBufCaseInsensitiveLess> lookupTable_t;
+    typedef std::unordered_map<const SBuf, EnumType, Hasher> lookupTable_t;
     lookupTable_t lookupTable;
     EnumType invalidValue;
 };

=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2015-08-03 02:08:22 +0000
+++ src/base/Makefile.am	2015-08-20 15:56:45 +0000
@@ -23,6 +23,7 @@
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
+	EnumIterator.h \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2015-08-11 04:41:55 +0000
+++ src/cache_cf.cc	2015-08-13 07:25:26 +0000
@@ -4606,7 +4606,7 @@
     }
     HeaderWithAcl hwa;
     hwa.fieldName = fn;
-    hwa.fieldId = Http::HeaderLookupTable.lookup(SBuf(fn));
+    hwa.fieldId = Http::HeaderLookupTable.lookup(hwa.fieldName).id;
     if (hwa.fieldId == Http::HdrType::BAD_HDR)
         hwa.fieldId = Http::HdrType::OTHER;
 

=== modified file 'src/client_side_reply.cc'
--- src/client_side_reply.cc	2015-08-04 19:57:07 +0000
+++ src/client_side_reply.cc	2015-08-10 20:14:03 +0000
@@ -1348,19 +1348,19 @@
          */
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             hdr->delById(Http::HdrType::DATE);
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
             HttpHeaderEntry *h = hdr->findEntry(Http::HdrType::DATE);
             if (h)
                 hdr->putExt("X-Origin-Date", h->value.termedBuf());
             hdr->delById(Http::HdrType::DATE);
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
             h = hdr->findEntry(Http::HdrType::EXPIRES);
             if (h && http->storeEntry()->expires >= 0) {
                 hdr->putExt("X-Origin-Expires", h->value.termedBuf());
                 hdr->delById(Http::HdrType::EXPIRES);
-                hdr->insertTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
+                hdr->putTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
@@ -1399,9 +1399,9 @@
      */
     if ( !hdr->has(Http::HdrType::DATE) ) {
         if (!http->storeEntry())
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
         else if (http->storeEntry()->timestamp > 0)
-            hdr->insertTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
+            hdr->putTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
         else {
             debugs(88,DBG_IMPORTANT,"BUG 3279: HTTP reply without Date:");
             /* dump something useful about the problem */

=== modified file 'src/esi/Libxml2Parser.h'
--- src/esi/Libxml2Parser.h	2015-08-20 12:01:01 +0000
+++ src/esi/Libxml2Parser.h	2015-08-20 16:06:38 +0000
@@ -25,7 +25,7 @@
 #undef free
 #endif
 
-#if __clang__ 
+#if __clang__
 // workaround for clang complaining of unknown attributes in libxml2 on fedora22
 #ifdef LIBXML_ATTR_ALLOC_SIZE
 #undef LIBXML_ATTR_ALLOC_SIZE

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-08-04 21:04:09 +0000
+++ src/external_acl.cc	2015-08-11 10:29:25 +0000
@@ -244,7 +244,7 @@
     }
 
     format->header = xstrdup(header);
-    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header));
+    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header)).id;
 }
 
 void

=== modified file 'src/htcp.cc'
--- src/htcp.cc	2015-08-04 19:57:07 +0000
+++ src/htcp.cc	2015-08-10 22:24:57 +0000
@@ -853,7 +853,7 @@
         stuff.D.respHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: resp_hdrs = {" << stuff.D.resp_hdrs << "}");
         mb.reset();
-        hdr.reset();
+        hdr.clean();
 
         if (e && e->expires > -1)
             hdr.putTime(Http::HdrType::EXPIRES, e->expires);
@@ -869,8 +869,7 @@
         debugs(31, 3, "htcpTstReply: entity_hdrs = {" << stuff.D.entity_hdrs << "}");
 
         mb.reset();
-
-        hdr.reset();
+        hdr.clean();
 
 #if USE_ICMP
         if (char *host = urlHostname(spec->uri)) {

=== modified file 'src/http.cc'
--- src/http.cc	2015-08-10 21:23:12 +0000
+++ src/http.cc	2015-08-13 13:56:43 +0000
@@ -589,22 +589,15 @@
     vary = reply->header.getList(Http::HdrType::VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
-        char *name = (char *)xmalloc(ilen + 1);
-        xstrncpy(name, item, ilen + 1);
-        Tolower(name);
-
-        if (strcmp(name, "*") == 0) {
-            /* Can not handle "Vary: *" withtout ETag support */
-            safe_free(name);
+        SBuf name(item, ilen);
+        if (name.cmp("*",1) == 0) {
             vstr.clean();
             break;
         }
-
-        strListAdd(&vstr, name, ',');
+        name.toLower();
+        strListAdd(&vstr, name.c_str(), ',');
         hdr = request->header.getByName(name);
-        safe_free(name);
         value = hdr.termedBuf();
-
         if (value) {
             value = rfc1738_escape_part(value);
             vstr.append("=\"", 2);

=== modified file 'src/http/Makefile.am'
--- src/http/Makefile.am	2015-08-04 11:09:58 +0000
+++ src/http/Makefile.am	2015-08-11 09:51:46 +0000
@@ -20,6 +20,8 @@
 	ProtocolVersion.h \
 	RegisteredHeaders.h \
 	RegisteredHeaders.cc \
+	RegisteredHeadersHash.cci \
+	RegisteredHeadersHash.gperf \
 	RequestMethod.cc \
 	RequestMethod.h \
 	StatusCode.cc \
@@ -33,4 +35,7 @@
 	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk sbuf=1 < $(srcdir)/MethodType.h | \
 		sed -e 's%METHOD_%%' -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
 
+RegisteredHeadersHash.cci: RegisteredHeadersHash.gperf
+	gperf --output-file=$@ -m 100000 $<
+
 CLEANFILES += MethodType.cc

=== modified file 'src/http/RegisteredHeaders.cc'
--- src/http/RegisteredHeaders.cc	2015-08-06 12:12:11 +0000
+++ src/http/RegisteredHeaders.cc	2015-08-20 16:06:38 +0000
@@ -10,114 +10,60 @@
 #include "RegisteredHeaders.h"
 
 #include <ostream>
+#include <vector>
 
 namespace Http
 {
-/*
- * A table with major attributes for every known field.
- *
- * Invariant on this table:
- * for each index in HeaderTable, (int)HeaderTable[index] = index
- *
- * To be kept in sync with Http::HdrType
- */
-const HeaderTableRecord HeaderTable[] = {
-    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr},
-    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr},
-    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr},
-    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr},
-    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr},
-    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt},
-    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr},
-    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr},
-    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
-    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr},    /* for now */
-    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc},
-    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr},
-    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr},
-    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr},  /* for now */
-    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr},
-    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr},
-    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64},
-    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr},
-    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr},    /* for now */
-    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange},
-    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr},
-    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr},
-    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr},
-    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123},
-    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag},
-    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr},
-    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123},
-    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr},
-    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr},
-    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr},
-    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr}, /* for now */
-    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr},  /* for now */
-    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
-    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr},    /* for now */
-    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag},
-    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
-    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr},
-    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr},
-    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123},
-    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr},
-    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr},
-    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64},
-    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr},  /* for now */
-    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr},
-    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr},
-    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr},
-    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr},
-    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
-    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr},
-    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr},
-    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr},
-    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr},
-    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange},
-    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr},
-    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange}, /* usually matches Http::HdrType::RANGE */
-    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr},    /* for now (Http::HdrFieldType::ftDate_1123 or Http::HdrFieldType::ftInt!} */
-    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr},
-    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr},
-    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr},
-    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr},
-    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr},
-    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr},
-    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr},
-    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr},    /* for now. may need to crop */
-    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr},  /* for now ignore. may need to crop */
-    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr},    /* for now */
-    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr},
-    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr},  /* for now */
-    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr},    /* for now */
-    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr},    /* for now */
-    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr},
-    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr},
-    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr},
-    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr},
-    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr},
-    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr},
-#if X_ACCELERATOR_VARY
-    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr},
-#endif
-#if USE_ADAPTATION
-    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr},
-#endif
-    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr},
-    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc},
-    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr},
-    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr},
-    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr},
-    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr},
-    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt},
-    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr},
-    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr},    /* ':' will not allow matches */
-    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid}, /* ':' will not allow matches */
-    {nullptr, Http::HdrType::ENUM_END, Http::HdrFieldType::ftInvalid}    /* end of table */
-};
-
-const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable(Http::HdrType::BAD_HDR, HeaderTable);
+/* glue to code generated by gperf */
+#include "http/RegisteredHeadersHash.cci"
+
+HeaderTableRecord::HeaderTableRecord() :
+    name(""), id(HdrType::BAD_HDR),type(HdrFieldType::ftInvalid),
+    list(false), request(false), reply(false), hopbyhop(false)
+{}
+
+HeaderTableRecord::HeaderTableRecord(const char *n) :
+    name(n), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),
+    list(false), request(false), reply(false), hopbyhop(false)
+{}
+
+HeaderTableRecord::HeaderTableRecord(const char *n, HdrType theId, HdrFieldType theType, int theKind) :
+    name(n), id(theId), type(theType),
+    list(theKind & HdrKind::ListHeader), request(theKind & HdrKind::RequestHeader),
+    reply(theKind & HdrKind::ReplyHeader), hopbyhop(theKind & HdrKind::HopByHopHeader),
+    denied304(theKind & HdrKind::Denied304Header)
+{}
+
+const HeaderTableRecord&
+HeaderLookupTable_t::lookup (const char *buf, const std::size_t len) const {
+    const HeaderTableRecord *r = HttpHeaderHashTable::lookup(buf, len);
+    if (!r)
+        return BadHdr;
+    return *r;
+}
+const HeaderTableRecord HeaderLookupTable_t::BadHdr {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None};
+
+HeaderLookupTable_t::HeaderLookupTable_t()
+{
+    initCache();
+}
+
+void
+HeaderLookupTable_t::initCache()
+{
+    idCache.resize(TOTAL_KEYWORDS);
+    for (int j = MIN_HASH_VALUE; j <= MAX_HASH_VALUE; ++j) { //MAX_HASH_VALUE is exported by gperf
+        if (HttpHeaderDefinitionsTable[j].name[0] != '\0') { //some slots are empty
+            idCache[static_cast<int>(HttpHeaderDefinitionsTable[j].id)] =
+                & HttpHeaderDefinitionsTable[j];
+        }
+    }
+    //check after the fact. The cache array must be full
+    for (auto e : idCache) {
+        assert(e->name);
+    }
+}
+const HeaderLookupTable_t HeaderLookupTable;
 
 }; /* namespace Http */
 
@@ -125,7 +71,7 @@
 operator<< (std::ostream &s, Http::HdrType id)
 {
     if (Http::any_HdrType_enum_value(id))
-        s << Http::HeaderTable[id].name << '[' << static_cast<int>(id) << ']';
+        s << Http::HeaderLookupTable.lookup(id).name << '[' << static_cast<int>(id) << ']';
     else
         s << "Invalid-Header[" << static_cast<int>(id) << ']';
     return s;

=== modified file 'src/http/RegisteredHeaders.h'
--- src/http/RegisteredHeaders.h	2015-08-06 02:50:14 +0000
+++ src/http/RegisteredHeaders.h	2015-08-20 16:06:38 +0000
@@ -17,7 +17,8 @@
 /// recognized or "known" header fields; and the RFC which defines them (or not)
 /// http://www.iana.org/assignments/message-headers/message-headers.xhtml
 enum HdrType {
-    ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
+    enumBegin_ = 0,                 // service value for WholeEnum iteration
+    ACCEPT = enumBegin_,            /**< RFC 7231 */ /* MUST BE FIRST */
     ACCEPT_CHARSET,                 /**< RFC 7231 */
     ACCEPT_ENCODING,                /**< RFC 7231 */
     /*ACCEPT_FEATURES,*/            /* RFC 2295 */
@@ -105,12 +106,8 @@
     X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
     X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
     X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
-#if X_ACCELERATOR_VARY
     HDR_X_ACCELERATOR_VARY,             /**< obsolete Squid custom header. */
-#endif
-#if USE_ADAPTATION
     X_NEXT_SERVICES,                /**< Squid custom ICAP header */
-#endif
     SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
     SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
     FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
@@ -120,8 +117,8 @@
     FTP_STATUS,                     /**< Internal header for FTP reply status */
     FTP_REASON,                     /**< Internal header for FTP reply reason */
     OTHER,                          /**< internal tag value for "unknown" headers */
-    BAD_HDR,                        /**< Invalid header. Must be after ENUM_END */
-    ENUM_END                        /**< internal tag for end-of-headers */
+    BAD_HDR,                        /**< Invalid header */
+    enumEnd_                        // internal tag for end-of-headers
 };
 
 /** possible types for http header fields */
@@ -139,31 +136,74 @@
     ftDate_1123_or_ETag
 };
 
+enum HdrKind {
+    None = 0,
+    ListHeader = 1,
+    RequestHeader = 1 << 1,
+    ReplyHeader = 1 << 2,
+    HopByHopHeader = 1 << 3,
+    Denied304Header = 1 << 4, //see comment in HttpReply.cc for meaning
+    GeneralHeader = RequestHeader | ReplyHeader,
+    EntityHeader = RequestHeader | ReplyHeader
+};
+
 /* POD for HeaderTable */
 class HeaderTableRecord {
 public:
+    HeaderTableRecord();
+    HeaderTableRecord(const char *n);
+    HeaderTableRecord(const char *, Http::HdrType, Http::HdrFieldType, int /* HdrKind */);
+
+public:
     const char *name;
     Http::HdrType id;
     Http::HdrFieldType type;
+    // flags set by constructor from HdrKind parameter
+    bool list;       //header with field values defined as #(values) in HTTP/1.1
+    bool request;    //header is a request header
+    bool reply;      //header is a reply header
+    bool hopbyhop;   //header is hop by hop
+    bool denied304;  //header is not to be updated on receiving a 304 in cache revalidation (see HttpReply.cc)
 };
 
-/// header ID->namelookup table.
-extern const HeaderTableRecord HeaderTable[];
-
-/** LookupTable for HTTP Header name -> Http::HdrType lookup.
- *
- * use as HeaderLookupTable.lookup(header-as-sbuf).
- * It will return Http::HdrType::HDR_BAD if the header is unknown/not registered,
- * including the case of Http::HdrType::OTHER, which will have to be handled
- * by the caller.
+/** Class for looking up registered header types' definitions
+ *
+ * Look up HeaderTableRecord's by name or registered header ID.
+ *
+ * Actual records are defined in file RegisteredHeadersHash.gperf, which is
+ * compiled using gperf to RegisteredHeadersHash.cci which is then included
+ * in RegisteredHeaders.cc.
  */
-extern const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable;
+class HeaderLookupTable_t {
+public:
+    HeaderLookupTable_t();
+    /// look record type up by name (C-string and length)
+    const HeaderTableRecord& lookup (const char *buf, const std::size_t len) const;
+    /// look record type up by name (std::string)
+    const HeaderTableRecord& lookup (const std::string &key) const {
+        return lookup(key.data(), key.length());
+    }
+    /// look record type up by name (SBuf)
+    const HeaderTableRecord& lookup (const SBuf &key) const {
+        return lookup(key.rawContent(), key.length());
+    }
+    /// look record type up by header ID
+    const HeaderTableRecord& lookup (Http::HdrType id) const {
+        return *(idCache[static_cast<int>(id)]);
+    }
+
+private:
+    void initCache();
+    std::vector<const HeaderTableRecord *> idCache;
+    static const HeaderTableRecord BadHdr; // used to signal "not found" from lookups
+};
+extern const HeaderLookupTable_t HeaderLookupTable;
 
 /// match any known header type, including OTHER and BAD
 inline bool
 any_HdrType_enum_value (const Http::HdrType id)
 {
-    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END);
+    return (id >= Http::HdrType::enumBegin_ && id < Http::HdrType::enumEnd_);
 }
 
 /// match any valid header type, including OTHER but not BAD

=== added file 'src/http/RegisteredHeadersHash.cci'
--- src/http/RegisteredHeadersHash.cci	1970-01-01 00:00:00 +0000
+++ src/http/RegisteredHeadersHash.cci	2015-08-20 15:56:45 +0000
@@ -0,0 +1,381 @@
+/* C++ code produced by gperf version 3.0.4 */
+/* Command-line: gperf --output-file=RegisteredHeadersHash.cci -m 100000 RegisteredHeadersHash.gperf  */
+/* Computed positions: -k'1,9,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "RegisteredHeadersHash.gperf"
+
+/* AUTO GENERATED FROM RegisteredHeadersHash.gperf. DO NOT EDIT */
+
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+#line 24 "RegisteredHeadersHash.gperf"
+struct HeaderTableRecord;
+enum
+  {
+    TOTAL_KEYWORDS = 88,
+    MIN_WORD_LENGTH = 2,
+    MAX_WORD_LENGTH = 25,
+    MIN_HASH_VALUE = 7,
+    MAX_HASH_VALUE = 113
+  };
+
+/* maximum key range = 107, duplicates = 0 */
+
+#ifndef GPERF_DOWNCASE
+#define GPERF_DOWNCASE 1
+static unsigned char gperf_downcase[256] =
+  {
+      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
+     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
+     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
+     60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,
+    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
+    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
+    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
+    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
+    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
+    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
+    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
+    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
+    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
+    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
+    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
+    255
+  };
+#endif
+
+#ifndef GPERF_CASE_MEMCMP
+#define GPERF_CASE_MEMCMP 1
+static int
+gperf_case_memcmp (register const char *s1, register const char *s2, register unsigned int n)
+{
+  for (; n > 0;)
+    {
+      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];
+      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];
+      if (c1 == c2)
+        {
+          n--;
+          continue;
+        }
+      return (int)c1 - (int)c2;
+    }
+  return 0;
+}
+#endif
+
+class HttpHeaderHashTable
+{
+private:
+  static inline unsigned int HttpHeaderHash (const char *str, unsigned int len);
+public:
+  static const struct HeaderTableRecord *lookup (const char *str, unsigned int len);
+};
+
+inline unsigned int
+HttpHeaderHashTable::HttpHeaderHash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114,  14, 114, 114,   5, 114, 114, 114, 114,
+       64, 114, 114,  14, 114, 114, 114, 114,   1, 114,
+      114, 114, 114, 114, 114,   4,   5,  15,  29,   1,
+       17,  60,  35,  19, 114,  51,  15,  42,   8,  50,
+       11, 114,   1,  19,   7,  28,   4,  41,  33,  15,
+      114, 114, 114, 114, 114, 114, 114,   4,   5,  15,
+       29,   1,  17,  60,  35,  19, 114,  51,  15,  42,
+        8,  50,  11, 114,   1,  19,   7,  28,   4,  41,
+       33,  15, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+      114, 114, 114, 114, 114, 114
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[8]];
+      /*FALLTHROUGH*/
+      case 8:
+      case 7:
+      case 6:
+      case 5:
+      case 4:
+      case 3:
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+static const unsigned char lengthtable[] =
+  {
+     0,  0,  0,  0,  0,  0,  0,  5,  3,  7,  2,  3,  0,  5,
+     6,  7, 13,  6,  9,  9, 11,  6,  6,  4, 15,  7,  6,  7,
+     8, 13, 13,  8,  6, 12,  4, 12,  7, 18, 18, 10, 13,  7,
+    13, 16,  0, 19,  4, 16, 13, 10,  5, 13, 17, 10, 16, 20,
+    17,  6, 19, 16, 14, 11,  8,  4,  6,  4, 10, 18, 15,  3,
+     4, 19, 13, 14, 10, 14, 13, 12, 15, 14, 15, 12, 11, 10,
+     9, 10,  7, 15, 19, 17,  0, 13, 16, 25,  0,  0,  0,  0,
+     0,  0, 21,  0,  0,  0,  0,  0,  0,  0,  7, 13,  0,  0,
+     0, 11
+  };
+
+static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
+  {
+    {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 78 "RegisteredHeadersHash.gperf"
+    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange, HdrKind::RequestHeader},
+#line 31 "RegisteredHeadersHash.gperf"
+    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader},
+#line 79 "RegisteredHeadersHash.gperf"
+    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 85 "RegisteredHeadersHash.gperf"
+    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 94 "RegisteredHeadersHash.gperf"
+    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+    {""},
+#line 86 "RegisteredHeadersHash.gperf"
+    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 51 "RegisteredHeadersHash.gperf"
+    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 87 "RegisteredHeadersHash.gperf"
+    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 80 "RegisteredHeadersHash.gperf"
+    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None},
+#line 26 "RegisteredHeadersHash.gperf"
+    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 89 "RegisteredHeadersHash.gperf"
+    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 69 "RegisteredHeadersHash.gperf"
+    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 81 "RegisteredHeadersHash.gperf"
+    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 71 "RegisteredHeadersHash.gperf"
+    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 47 "RegisteredHeadersHash.gperf"
+    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 93 "RegisteredHeadersHash.gperf"
+    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 29 "RegisteredHeadersHash.gperf"
+    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 109 "RegisteredHeadersHash.gperf"
+    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 82 "RegisteredHeadersHash.gperf"
+    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 52 "RegisteredHeadersHash.gperf"
+    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader},
+#line 60 "RegisteredHeadersHash.gperf"
+    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None},
+#line 35 "RegisteredHeadersHash.gperf"
+    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 45 "RegisteredHeadersHash.gperf"
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 66 "RegisteredHeadersHash.gperf"
+    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 77 "RegisteredHeadersHash.gperf"
+    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 38 "RegisteredHeadersHash.gperf"
+    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 49 "RegisteredHeadersHash.gperf"
+    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader},
+#line 46 "RegisteredHeadersHash.gperf"
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 91 "RegisteredHeadersHash.gperf"
+    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 72 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header},
+#line 33 "RegisteredHeadersHash.gperf"
+    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader},
+#line 113 "RegisteredHeadersHash.gperf"
+    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None},
+#line 30 "RegisteredHeadersHash.gperf"
+    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 97 "RegisteredHeadersHash.gperf"
+    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 76 "RegisteredHeadersHash.gperf"
+    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+#line 75 "RegisteredHeadersHash.gperf"
+    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
+    {""},
+#line 74 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 55 "RegisteredHeadersHash.gperf"
+    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 41 "RegisteredHeadersHash.gperf"
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 101 "RegisteredHeadersHash.gperf"
+    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 83 "RegisteredHeadersHash.gperf"
+    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 32 "RegisteredHeadersHash.gperf"
+    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 36 "RegisteredHeadersHash.gperf"
+    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 105 "RegisteredHeadersHash.gperf"
+    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 92 "RegisteredHeadersHash.gperf"
+    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 43 "RegisteredHeadersHash.gperf"
+    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 104 "RegisteredHeadersHash.gperf"
+    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 58 "RegisteredHeadersHash.gperf"
+    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::RequestHeader},
+#line 112 "RegisteredHeadersHash.gperf"
+    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 61 "RegisteredHeadersHash.gperf"
+    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None},
+#line 96 "RegisteredHeadersHash.gperf"
+    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 27 "RegisteredHeadersHash.gperf"
+    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 107 "RegisteredHeadersHash.gperf"
+    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 57 "RegisteredHeadersHash.gperf"
+    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 54 "RegisteredHeadersHash.gperf"
+    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 70 "RegisteredHeadersHash.gperf"
+    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 50 "RegisteredHeadersHash.gperf"
+    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader},
+#line 62 "RegisteredHeadersHash.gperf"
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 102 "RegisteredHeadersHash.gperf"
+    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 103 "RegisteredHeadersHash.gperf"
+    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 63 "RegisteredHeadersHash.gperf"
+    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 65 "RegisteredHeadersHash.gperf"
+    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader},
+#line 39 "RegisteredHeadersHash.gperf"
+    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 100 "RegisteredHeadersHash.gperf"
+    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 98 "RegisteredHeadersHash.gperf"
+    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 110 "RegisteredHeadersHash.gperf"
+    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt, HdrKind::None},
+#line 56 "RegisteredHeadersHash.gperf"
+    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader},
+#line 64 "RegisteredHeadersHash.gperf"
+    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 67 "RegisteredHeadersHash.gperf"
+    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64, HdrKind::RequestHeader},
+#line 99 "RegisteredHeadersHash.gperf"
+    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 42 "RegisteredHeadersHash.gperf"
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 106 "RegisteredHeadersHash.gperf"
+    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 68 "RegisteredHeadersHash.gperf"
+    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader},
+#line 44 "RegisteredHeadersHash.gperf"
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 37 "RegisteredHeadersHash.gperf"
+    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 53 "RegisteredHeadersHash.gperf"
+    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 111 "RegisteredHeadersHash.gperf"
+    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 48 "RegisteredHeadersHash.gperf"
+    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 28 "RegisteredHeadersHash.gperf"
+    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader|HdrKind::ReplyHeader},
+#line 34 "RegisteredHeadersHash.gperf"
+    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+#line 88 "RegisteredHeadersHash.gperf"
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {""},
+#line 108 "RegisteredHeadersHash.gperf"
+    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 40 "RegisteredHeadersHash.gperf"
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 73 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+    {""}, {""}, {""}, {""}, {""}, {""},
+#line 90 "RegisteredHeadersHash.gperf"
+    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None},
+    {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 95 "RegisteredHeadersHash.gperf"
+    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 59 "RegisteredHeadersHash.gperf"
+    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+    {""}, {""}, {""},
+#line 84 "RegisteredHeadersHash.gperf"
+    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader}
+  };
+
+const struct HeaderTableRecord *
+HttpHeaderHashTable::lookup (register const char *str, register unsigned int len)
+{
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = HttpHeaderHash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        if (len == lengthtable[key])
+          {
+            register const char *s = HttpHeaderDefinitionsTable[key].name;
+
+            if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_memcmp (str, s, len))
+              return &HttpHeaderDefinitionsTable[key];
+          }
+    }
+  return 0;
+}
+#line 114 "RegisteredHeadersHash.gperf"
+

=== added file 'src/http/RegisteredHeadersHash.gperf'
--- src/http/RegisteredHeadersHash.gperf	1970-01-01 00:00:00 +0000
+++ src/http/RegisteredHeadersHash.gperf	2015-08-20 15:56:45 +0000
@@ -0,0 +1,114 @@
+%{
+/* AUTO GENERATED FROM RegisteredHeadersHash.gperf. DO NOT EDIT */
+
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+%}
+%language=C++
+%define hash-function-name HttpHeaderHash
+%define lookup-function-name lookup
+%define class-name HttpHeaderHashTable
+%define word-array-name HttpHeaderDefinitionsTable
+%compare-lengths
+%compare-strncmp
+%readonly-tables
+%enum
+%global-table
+%ignore-case
+%struct-type 
+struct HeaderTableRecord;
+%%
+Accept, Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Charset, Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Encoding, Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader|HdrKind::ReplyHeader
+Accept-Language, Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Ranges, Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Age, Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader
+Allow, Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Alternate-Protocol, Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader
+Authentication-Info, Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Authorization, Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Cache-Control, Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader
+Connection, Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Content-Base, Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-Disposition, Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None
+Content-Encoding, Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Language, Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Length, Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Location, Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-MD5, Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Range, Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Type, Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Cookie, Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None
+Cookie2, Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None
+Date, Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader
+ETag, Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader
+Expect, Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Expires, Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader
+Forwarded, Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+From, Http::HdrType::FROM, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Host, Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+HTTP2-Settings, Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader
+If-Match, Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+If-Modified-Since, Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::RequestHeader
+If-None-Match, Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+If-Range, Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None
+If-Unmodified-Since, Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None
+Keep-Alive, Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Key, Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Last-Modified, Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader|HdrKind::Denied304Header
+Link, Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
+Location, Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Max-Forwards, Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64, HdrKind::RequestHeader
+Mime-Version, Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader
+Negotiate, Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None
+Origin, Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Pragma, Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+Proxy-Authenticate, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header
+Proxy-Authentication-Info, Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Proxy-Authorization, Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Proxy-Connection, Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
+Proxy-support, Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Public, Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Range, Http::HdrType::RANGE, Http::HdrFieldType::ftPRange, HdrKind::RequestHeader
+Referer, Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Request-Range, Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None
+Retry-After, Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Server, Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Set-Cookie, Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Set-Cookie2, Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+TE, Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Title, Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None
+Trailer, Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Transfer-Encoding, Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Translate, Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None
+Unless-Modified-Since, Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None
+Upgrade, Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+User-Agent, Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Vary, Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Via, Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+Warning, Http::HdrType::WARNING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+WWW-Authenticate, Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+X-Cache, Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Cache-Lookup, Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Forwarded-For, Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+X-Request-URI, Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Squid-Error, Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Accelerator-Vary, Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+X-Next-Services, Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Surrogate-Capability, Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Surrogate-Control, Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc, HdrKind::ListHeader|HdrKind::ReplyHeader
+Front-End-Https, Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Command, Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Arguments, Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Pre, Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Status, Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt, HdrKind::None
+FTP-Reason, Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr, HdrKind::None
+Other:, Http::HdrType::OTHER, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+*INVALID*:, Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None
+%%

=== added file 'src/tests/testEnumIterator.cc'
--- src/tests/testEnumIterator.cc	1970-01-01 00:00:00 +0000
+++ src/tests/testEnumIterator.cc	2015-08-20 15:56:45 +0000
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "tests/testEnumIterator.h"
+#include "unitTestMain.h"
+
+#include <cppunit/TestAssert.h>
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testEnumIterator );
+
+enum class TestEnum {
+    enumBegin_ = 0,
+    zero = enumBegin_,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+enum class UnsignedTestEnum : unsigned char {
+    enumBegin_ = 0,
+    zero = enumBegin_,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+void
+testEnumIterator::testForwardIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().end());
+}
+
+void
+testEnumIterator::testReverseIter()
+{
+    WholeEnum<TestEnum>::reverse_iterator i = WholeEnum<TestEnum>().rbegin();
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().rend());
+}
+
+void
+testEnumIterator::testBidirectionalIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    --i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+
+    auto enumBegin=WholeEnum<TestEnum>().begin();
+    auto enumEnd=WholeEnum<TestEnum>().end();
+    i=enumBegin;
+    int count=0;
+    while (i != enumEnd) {
+        ++i;
+        ++count;
+    }
+    while (i != enumBegin) {
+        --i;
+        ++count;
+    }
+    CPPUNIT_ASSERT_EQUAL(10, count);
+}
+
+void
+testEnumIterator::testRangeFor()
+{
+    int j = 0;
+    for (auto e : WholeEnum<TestEnum>()) {
+        (void)e;
+        ++j;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+
+void
+testEnumIterator::testRangeForRange()
+{
+    int j = 0;
+    // free function-based range
+    for (auto e : EnumRange(TestEnum::two, TestEnum::four)) {
+        (void)e;
+        ++j;
+    }
+    CPPUNIT_ASSERT_EQUAL(2,j);
+}
+
+void
+testEnumIterator::testUnsignedEnum()
+{
+    int j = 0;
+    for (auto e = WholeEnum<TestEnum>().rbegin(); e != WholeEnum<TestEnum>().rend(); ++e ) {
+        (void)e;
+        ++j;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+

=== added file 'src/tests/testEnumIterator.h'
--- src/tests/testEnumIterator.h	1970-01-01 00:00:00 +0000
+++ src/tests/testEnumIterator.h	2015-08-20 15:56:45 +0000
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+#ifndef SQUID_TESTENUMITERATOR_H_
+#define SQUID_TESTENUMITERATOR_H_
+
+#include "base/EnumIterator.h"
+
+#include <cppunit/extensions/HelperMacros.h>
+
+class testEnumIterator : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testEnumIterator );
+    CPPUNIT_TEST( testForwardIter );
+    CPPUNIT_TEST( testReverseIter );
+    CPPUNIT_TEST( testBidirectionalIter );
+    CPPUNIT_TEST( testRangeFor );
+    CPPUNIT_TEST( testRangeForRange );
+    CPPUNIT_TEST( testUnsignedEnum );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    void testForwardIter();
+    void testReverseIter();
+    void testBidirectionalIter();
+    void testRangeFor();
+    void testRangeForRange();
+    void testUnsignedEnum();
+};
+
+#endif /* SQUID_TESTENUMITERATOR_H_ */
+

# Begin bundle
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
b1piIqid4y98s//i7kinChIZbvIQoA==
