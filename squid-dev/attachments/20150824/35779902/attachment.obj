=== modified file 'src/acl/ExtUser.h'
--- src/acl/ExtUser.h	2015-01-13 07:25:36 +0000
+++ src/acl/ExtUser.h	2015-08-24 12:27:01 +0000
@@ -1,47 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_EXTUSER_H
 #define SQUID_EXTUSER_H
 
 #if USE_AUTH
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 
 class ACLExtUser : public ACL
 {
     MEMPROXY_CLASS(ACLExtUser);
 
 public:
-    ACLExtUser(ACLData<char const *> *newData, char const *);
+    ACLExtUser(ACLData<char const *> *newData, char const * type);
     ACLExtUser (ACLExtUser const &old);
     ACLExtUser & operator= (ACLExtUser const &rhs);
     ~ACLExtUser();
 
     virtual char const *typeString() const;
     virtual void parse();
 
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual ACL *clone()const;
 
 private:
     static Prototype UserRegistryProtoype;
     static ACLExtUser UserRegistryEntry_;
     static Prototype RegexRegistryProtoype;
     static ACLExtUser RegexRegistryEntry_;
     ACLData<char const *> *data;
     char const *type_;
 };
 
 #endif /* USE_AUTH */
 #endif /* SQUID_EXTUSER_H */
 

=== modified file 'src/auth/Gadgets.cc'
--- src/auth/Gadgets.cc	2015-01-13 07:25:36 +0000
+++ src/auth/Gadgets.cc	2015-08-24 12:27:01 +0000
@@ -87,44 +87,44 @@ authenticateInit(Auth::ConfigVector * co
 
 void
 authenticateRotate(void)
 {
     for (Auth::ConfigVector::iterator i = Auth::TheConfig.begin(); i != Auth::TheConfig.end(); ++i)
         if ((*i)->configured())
             (*i)->rotateHelpers();
 }
 
 void
 authenticateReset(void)
 {
     debugs(29, 2, HERE << "Reset authentication State.");
 
     /* free all username cache entries */
     hash_first(proxy_auth_username_cache);
     AuthUserHashPointer *usernamehash;
     while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
         debugs(29, 5, HERE << "Clearing entry for user: " << usernamehash->user()->username());
         hash_remove_link(proxy_auth_username_cache, (hash_link *)usernamehash);
         delete usernamehash;
     }
 
     /* schedule shutdown of the helpers */
     authenticateRotate();
 
     /* free current global config details too. */
     Auth::TheConfig.clear();
 }
 
-AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user):
+AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user) :
     auth_user(anAuth_user)
 {
     key = (void *)anAuth_user->userKey();
-    next = NULL;
+    next = nullptr;
     hash_join(proxy_auth_username_cache, (hash_link *) this);
 }
 
 Auth::User::Pointer
 AuthUserHashPointer::user() const
 {
     return auth_user;
 }
 

=== modified file 'src/auth/Gadgets.h'
--- src/auth/Gadgets.h	2015-01-13 07:25:36 +0000
+++ src/auth/Gadgets.h	2015-08-24 12:27:01 +0000
@@ -6,61 +6,61 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_AUTH_GADGETS_H
 #define SQUID_AUTH_GADGETS_H
 
 #if USE_AUTH
 
 #include "auth/Config.h"
 #include "auth/User.h"
 #include "hash.h"
 
 /**
  \ingroup AuthAPI
  *
  * This is used to link AuthUsers objects into the username cache.
  * Because some schemes may link in aliases to a user,
  * the link is not part of the AuthUser structure itself.
  *
  * Code must not hold onto copies of these objects.
  * They may exist only so long as the AuthUser being referenced
  * is recorded in the cache. Any caller using hash_remove_link
  * must then delete the AuthUserHashPointer.
  */
 class AuthUserHashPointer : public hash_link
 {
     MEMPROXY_CLASS(AuthUserHashPointer);
 
 public:
     AuthUserHashPointer(Auth::User::Pointer);
-    ~AuthUserHashPointer() { auth_user = NULL; };
+    ~AuthUserHashPointer() { auth_user = nullptr; }
 
     Auth::User::Pointer user() const;
 
 private:
     Auth::User::Pointer auth_user;
 };
 
 namespace Auth
 {
 class Scheme;
 }
 class ConnStateData;
 class StoreEntry;
 
 /**
  \ingroup AuthAPI
  \todo this should be a generic cachemgr API type ?
  */
 typedef void AUTHSSTATS(StoreEntry *);
 
 /// \ingroup AuthAPI
 void authenticateInit(Auth::ConfigVector *);
 
 /** \ingroup AuthAPI
  * Remove all idle authentication state. Intended for use by reconfigure.
  *
  * Removes the username cache contents and global configuration state.
  * Stops just short of detaching the auth components completely.
  *
  * Currently active requests should finish. Howevee new requests will not use

=== modified file 'src/auth/QueueNode.h'
--- src/auth/QueueNode.h	2015-01-13 07:25:36 +0000
+++ src/auth/QueueNode.h	2015-08-24 12:27:01 +0000
@@ -8,54 +8,54 @@
 
 #ifndef SQUID_SRC_AUTH_QUEUENODE_H
 #define SQUID_SRC_AUTH_QUEUENODE_H
 
 #include "cbdata.h"
 
 namespace Auth
 {
 
 /**
  * A queue of auth requests waiting for verification to occur.
  *
  * Certain authentication schemes such a Basic and Bearer auth
  * permit credentials tokens to be repeated from multiple sources
  * simultaneously. This queue node allows multiple validation
  * queries to be collapsed into one backend helper lookup.
  * CBDATA and handlers stored in these queue nodes can be notified
  * all at once with a result when the lookup completes.
  */
 class QueueNode
 {
     MEMPROXY_CLASS(Auth::QueueNode);
 
 private:
     // we store CBDATA here, copy is not safe
     QueueNode(const QueueNode &);
     QueueNode &operator =(const QueueNode &);
 
 public:
     QueueNode(Auth::UserRequest *aRequest, AUTHCB *aHandler, void *aData) :
-        next(NULL),
+        next(nullptr),
         auth_user_request(aRequest),
         handler(aHandler),
         data(cbdataReference(aData)) {}
     ~QueueNode() {
         cbdataReferenceDone(data);
         while (next) {
             QueueNode *tmp = next->next;
             next->next = NULL;
             delete next;
             next = tmp;
         };
     }
 
     Auth::QueueNode *next;
     Auth::UserRequest::Pointer auth_user_request;
     AUTHCB *handler;
     void *data;
 };
 
 } // namespace Auth
 
 #endif /* SQUID_SRC_AUTH_QUEUENODE_H */
 

