=== modified file 'src/SBufAlgos.cc'
--- src/SBufAlgos.cc	2015-07-29 18:12:16 +0000
+++ src/SBufAlgos.cc	2015-08-24 17:12:22 +0000
@@ -1,25 +1,38 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "SBufAlgos.h"
 
-std::size_t std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+static std::size_t
+lowSBufHash (const SBuf & sbuf, bool caseInsensitive = false) noexcept
 {
     //ripped and adapted from hash_string
     const char *s = sbuf.rawContent();
     size_t rv = 0;
     SBuf::size_type len=sbuf.length();
     while (len != 0) {
-        rv ^= 271 * *s;
+        rv ^= 271 * (caseInsensitive? xtolower(*s) : *s);
         ++s;
         --len;
     }
     return rv ^ (sbuf.length() * 271);
 }
 
+std::size_t
+std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+{
+    return lowSBufHash(sbuf);
+}
+
+std::size_t
+CaseInsensitiveSBufHash::operator() (const SBuf & sbuf) const noexcept
+{
+    return lowSBufHash(sbuf, true);
+}
+

=== modified file 'src/SBufAlgos.h'
--- src/SBufAlgos.h	2015-07-29 18:12:16 +0000
+++ src/SBufAlgos.h	2015-08-24 17:12:22 +0000
@@ -63,32 +63,45 @@ SBufContainerJoin(const Container &items
     const SBuf::size_type sz = std::accumulate(items.begin(), items.end(), 0, SBufAddLength(separator));
 
     // sz can be zero in two cases: either items is empty, or all items
     //  are zero-length. In the former case, we must protect against
     //  dereferencing the iterator later on, and checking sz is more efficient
     //  than checking items.size(). This check also provides an optimization
     //  for the latter case without adding complexity.
     if (sz == 0)
         return SBuf();
 
     SBuf rv;
     rv.reserveSpace(sz);
 
     typename Container::const_iterator i(items.begin());
     rv.append(*i);
     ++i;
     for (; i != items.end(); ++i)
         rv.append(separator).append(*i);
     return rv;
 }
 
 namespace std {
 /// default hash functor to support std::unordered_map<SBuf,*>
 template <>
 struct hash<SBuf>
 {
     size_t operator()(const SBuf &) const noexcept;
 };
 }
 
+/** hash functor for SBufs, meant so support case-insensitive std::unordered_map
+ *
+ * Typical use:
+ * \code
+ * auto m = std::unordered_map<SBuf, ValueType, CaseInsensitiveSBufHash>();
+ * \endcode
+ */
+class CaseInsensitiveSBufHash
+{
+public:
+    std::size_t operator()(const SBuf &) const noexcept;
+};
+
 #endif /* SQUID_SBUFALGOS_H_ */
 

