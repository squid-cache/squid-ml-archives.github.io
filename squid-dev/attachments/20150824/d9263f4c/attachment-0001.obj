=== modified file 'src/clients/FtpGateway.cc'
--- src/clients/FtpGateway.cc	2015-08-04 19:57:07 +0000
+++ src/clients/FtpGateway.cc	2015-08-24 14:50:14 +0000
@@ -1425,83 +1425,76 @@ ftpReadType(Ftp::Gateway * ftpState)
 
         while (*p) {
             d = p;
             p += strcspn(p, "/");
 
             if (*p) {
                 *p = '\0';
                 ++p;
             }
 
             rfc1738_unescape(d);
 
             if (*d)
                 wordlistAdd(&ftpState->pathcomps, d);
         }
 
         xfree(path);
 
         if (ftpState->pathcomps)
             ftpTraverseDirectory(ftpState);
         else
             ftpListDir(ftpState);
     } else {
         ftpFail(ftpState);
     }
 }
 
 static void
 ftpTraverseDirectory(Ftp::Gateway * ftpState)
 {
-    wordlist *w;
     debugs(9, 4, HERE << (ftpState->filepath ? ftpState->filepath : "<NULL>"));
 
     safe_free(ftpState->dirpath);
     ftpState->dirpath = ftpState->filepath;
     ftpState->filepath = NULL;
 
     /* Done? */
 
     if (ftpState->pathcomps == NULL) {
         debugs(9, 3, HERE << "the final component was a directory");
         ftpListDir(ftpState);
         return;
     }
 
     /* Go to next path component */
-    w = ftpState->pathcomps;
-
-    ftpState->filepath = w->key;
-
-    ftpState->pathcomps = w->next;
-
-    delete w;
+    ftpState->filepath = wordlistChopHead(& ftpState->pathcomps);
 
     /* Check if we are to CWD or RETR */
     if (ftpState->pathcomps != NULL || ftpState->flags.isdir) {
         ftpSendCwd(ftpState);
     } else {
         debugs(9, 3, HERE << "final component is probably a file");
         ftpGetFile(ftpState);
         return;
     }
 }
 
 static void
 ftpSendCwd(Ftp::Gateway * ftpState)
 {
     char *path = NULL;
 
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendCwd"))
         return;
 
     debugs(9, 3, HERE);
 
     path = ftpState->filepath;
 
     if (!strcmp(path, "..") || !strcmp(path, "/")) {
         ftpState->flags.no_dotdot = 1;
     } else {
         ftpState->flags.no_dotdot = 0;
     }
 

=== modified file 'src/tests/stub_wordlist.cc'
--- src/tests/stub_wordlist.cc	2015-01-13 07:25:36 +0000
+++ src/tests/stub_wordlist.cc	2015-08-21 15:59:22 +0000
@@ -1,20 +1,19 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "wordlist.h"
 
 #define STUB_API "wordlist.cc"
 #include "tests/STUB.h"
 
 const char *wordlistAdd(wordlist **, const char *) STUB_RETVAL(NULL)
 void wordlistAddWl(wordlist **, wordlist *) STUB
 void wordlistJoin(wordlist **, wordlist **) STUB
-wordlist *wordlistDup(const wordlist *) STUB_RETVAL(NULL)
 void wordlistDestroy(wordlist **) STUB
 

=== modified file 'src/wordlist.cc'
--- src/wordlist.cc	2015-03-05 06:44:43 +0000
+++ src/wordlist.cc	2015-08-24 15:09:36 +0000
@@ -5,96 +5,88 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 03    Configuration File Parsing */
 
 #include "squid.h"
 #include "MemBuf.h"
 #include "wordlist.h"
 
 void
 wordlistDestroy(wordlist ** list)
 {
     wordlist *w = NULL;
 
     while ((w = *list) != NULL) {
         *list = w->next;
         safe_free(w->key);
         delete w;
     }
 
     *list = NULL;
 }
 
 const char *
 wordlistAdd(wordlist ** list, const char *key)
 {
     while (*list)
         list = &(*list)->next;
 
-    *list = new wordlist;
-
-    (*list)->key = xstrdup(key);
-
-    (*list)->next = NULL;
-
+    *list = new wordlist(key);
     return (*list)->key;
 }
 
 void
 wordlistJoin(wordlist ** list, wordlist ** wl)
 {
     while (*list)
         list = &(*list)->next;
 
     *list = *wl;
 
     *wl = NULL;
 }
 
 void
 wordlistAddWl(wordlist ** list, wordlist * wl)
 {
     while (*list)
         list = &(*list)->next;
 
     for (; wl; wl = wl->next, list = &(*list)->next) {
-        *list = new wordlist();
-        (*list)->key = xstrdup(wl->key);
-        (*list)->next = NULL;
+        *list = new wordlist(wl->key);
     }
 }
 
 void
 wordlistCat(const wordlist * w, MemBuf * mb)
 {
     while (NULL != w) {
         mb->appendf("%s\n", w->key);
         w = w->next;
     }
 }
 
-wordlist *
-wordlistDup(const wordlist * w)
-{
-    wordlist *D = NULL;
-
-    while (NULL != w) {
-        wordlistAdd(&D, w->key);
-        w = w->next;
-    }
-
-    return D;
-}
-
 SBufList
 ToSBufList(wordlist *wl)
 {
     SBufList rv;
     while (wl != NULL) {
         rv.push_back(SBuf(wl->key));
         wl = wl->next;
     }
     return rv;
 }
 
+char *
+wordlistChopHead(wordlist **wl)
+{
+    if (*wl == nullptr)
+        return nullptr;
+
+    wordlist *w = *wl;
+    char *rv = w->key;
+    *wl = w->next;
+    delete w;
+    return rv;
+}

=== modified file 'src/wordlist.h'
--- src/wordlist.h	2015-01-13 07:25:36 +0000
+++ src/wordlist.h	2015-08-24 14:54:12 +0000
@@ -1,65 +1,83 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_WORDLIST_H
 #define SQUID_WORDLIST_H
 
 #include "globals.h"
 #include "profiler/Profiler.h"
 #include "SBufList.h"
 
 /** A list of C-strings
  *
  * \deprecated use SBufList instead
  */
 class wordlist
 {
     MEMPROXY_CLASS(wordlist);
+    friend void wordlistDestroy(wordlist ** list);
+    friend char *wordlistChopHead(wordlist **);
 
 public:
+    wordlist() : key(nullptr), next(nullptr) {}
+    // create a new wordlist node, with a copy of k as key
+    explicit wordlist(const char *k) : key(xstrdup(k)), next(nullptr) {}
+
+    wordlist(const wordlist &) = delete;
+    wordlist &operator=(const wordlist &) = delete;
+
     char *key;
     wordlist *next;
+
+private:
+    // use wordlistDestroy instead
+    ~wordlist() = default;
 };
 
 class MemBuf;
 
 /** Add a null-terminated c-string to a wordlist
  *
  * \deprecated use SBufList.push_back(SBuf(word)) instead
  */
 const char *wordlistAdd(wordlist **, const char *);
 
 /** Concatenate a wordlist
  *
  * \deprecated use SBufListContainerJoin(SBuf()) from SBufAlgos.h instead
  */
 void wordlistCat(const wordlist *, MemBuf *);
 
 /** append a wordlist to another
  *
  * \deprecated use SBufList.merge(otherwordlist) instead
  */
 void wordlistAddWl(wordlist **, wordlist *);
 
 /** Concatenate the words in a wordlist
  *
  * \deprecated use SBufListContainerJoin(SBuf()) from SBufAlgos.h instead
  */
 void wordlistJoin(wordlist **, wordlist **);
 
-/// duplicate a wordlist
-wordlist *wordlistDup(const wordlist *);
-
 /// destroy a wordlist
 void wordlistDestroy(wordlist **);
 
+/** remove the first element in a wordlist, and return its key
+ *
+ * \note the returned key must be freed by the caller using safe_free
+ * \note wl is altered so that it points to the second element
+ * \return nullptr if pointed-to wordlist is nullptr.
+ */
+char *wordlistChopHead(wordlist **);
+
 /// convert a wordlist to a SBufList
 SBufList ToSBufList(wordlist *);
 
 #endif /* SQUID_WORDLIST_H */
 

