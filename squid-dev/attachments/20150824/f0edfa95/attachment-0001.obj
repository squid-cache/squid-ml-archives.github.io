=== modified file 'src/MemObject.cc'
--- src/MemObject.cc	2015-05-26 17:25:04 +0000
+++ src/MemObject.cc	2015-08-24 12:13:55 +0000
@@ -69,70 +69,70 @@ MemObject::logUri() const
 }
 
 bool
 MemObject::hasUris() const
 {
     return storeId_.size();
 }
 
 void
 MemObject::setUris(char const *aStoreId, char const *aLogUri, const HttpRequestMethod &aMethod)
 {
     storeId_ = aStoreId;
 
     // fast pointer comparison for a common storeCreateEntry(url,url,...) case
     if (!aLogUri || aLogUri == aStoreId)
         logUri_.clean(); // use storeId_ by default to minimize copying
     else
         logUri_ = aLogUri;
 
     method = aMethod;
 
 #if URL_CHECKSUM_DEBUG
     chksum = url_checksum(urlXXX());
 #endif
 }
 
 MemObject::MemObject() :
     inmem_lo(0),
     nclients(0),
     smpCollapsed(false),
-    request(NULL),
-    ping_reply_callback(NULL),
-    ircb_data(NULL),
+    request(nullptr),
+    ping_reply_callback(nullptr),
+    ircb_data(nullptr),
     id(0),
     object_sz(-1),
     swap_hdr_sz(0),
 #if URL_CHECKSUM_DEBUG
     chksum(0),
 #endif
-    vary_headers(NULL)
+    vary_headers(nullptr)
 {
     debugs(20, 3, "new MemObject " << this);
     memset(&start_ping, 0, sizeof(start_ping));
     memset(&abort, 0, sizeof(abort));
     _reply = new HttpReply;
     HTTPMSGLOCK(_reply);
 }
 
 MemObject::~MemObject()
 {
     debugs(20, 3, "del MemObject " << this);
     const Ctx ctx = ctx_enter(hasUris() ? urlXXX() : "[unknown_ctx]");
 
 #if URL_CHECKSUM_DEBUG
     checkUrlChecksum();
 #endif
 
     if (!shutting_down) { // Store::Root() is FATALly missing during shutdown
         assert(xitTable.index < 0);
         assert(memCache.index < 0);
         assert(swapout.sio == NULL);
     }
 
     data_hdr.freeContent();
 
 #if 0
     /*
      * There is no way to abort FD-less clients, so they might
      * still have mem->clients set.
      */

=== modified file 'src/StoreMeta.cc'
--- src/StoreMeta.cc	2015-01-13 07:25:36 +0000
+++ src/StoreMeta.cc	2015-08-24 12:13:55 +0000
@@ -159,30 +159,43 @@ StoreMeta::Add(StoreMeta **tail, StoreMe
 bool
 StoreMeta::checkConsistency(StoreEntry *) const
 {
     switch (getType()) {
 
     case STORE_META_KEY:
 
     case STORE_META_URL:
 
     case STORE_META_VARY_HEADERS:
         assert(0);
         break;
 
     case STORE_META_STD:
         break;
 
     case STORE_META_STD_LFS:
         break;
 
     case STORE_META_OBJSIZE:
         break;
 
     default:
         debugs(20, DBG_IMPORTANT, "WARNING: got unused STORE_META type " << getType());
         break;
     }
 
     return true;
 }
 
+StoreMeta::StoreMeta(const StoreMeta &s) :
+    length(s.length),
+    value(s.value),
+    next(s.next)
+{}
+
+StoreMeta& StoreMeta::operator=(const StoreMeta &s)
+{
+    length=s.length;
+    value=s.value;
+    next=s.next;
+    return *this;
+}

=== modified file 'src/StoreMeta.h'
--- src/StoreMeta.h	2015-01-13 07:25:36 +0000
+++ src/StoreMeta.h	2015-08-24 12:13:55 +0000
@@ -84,57 +84,62 @@ enum {
 
     /**
      * Reserved for future hit-metering (RFC 2227) stuff
      */
     STORE_META_HITMETERING,
 
     /// \todo DOCS: document.
     STORE_META_VALID,
 
     /**
      * Stores Vary request headers
      */
     STORE_META_VARY_HEADERS,
 
     /**
      * Updated version of STORE_META_STD, with support for  >2GB objects.
      * As STORE_META_STD except that the swap_file_sz is a 64-bit integer instead of 32-bit.
      */
     STORE_META_STD_LFS,
 
     STORE_META_OBJSIZE,
 
     STORE_META_STOREURL,    /* the store url, if different to the normal URL */
     STORE_META_VARY_ID,     /* Unique ID linking variants */
     STORE_META_END
 };
 
 /// \ingroup SwapStoreAPI
 class StoreMeta
 {
+protected:
+	StoreMeta() : length(-1), value(nullptr), next(nullptr) { }
+	StoreMeta(const StoreMeta &);
+	StoreMeta& operator=(const StoreMeta &);
+
 public:
     static bool validType(char);
     static int const MaximumTLVLength;
     static int const MinimumTLVLength;
     static StoreMeta *Factory(char type, size_t len, void const *value);
     static StoreMeta **Add(StoreMeta **tail, StoreMeta *aNode);
     static void FreeList(StoreMeta **head);
 
     virtual char getType() const = 0;
     virtual bool validLength(int) const;
     virtual bool checkConsistency(StoreEntry *) const;
     virtual ~StoreMeta() {}
 
     int length;
     void *value;
     tlv *next;
 };
 
 /// \ingroup SwapStoreAPI
 char *storeSwapMetaPack(tlv * tlv_list, int *length);
 /// \ingroup SwapStoreAPI
 tlv *storeSwapMetaBuild(StoreEntry * e);
 /// \ingroup SwapStoreAPI
 void storeSwapTLVFree(tlv * n);
 
 #endif /* SQUID_TYPELENGTHVALUE_H */
 

=== modified file 'src/URL.h'
--- src/URL.h	2015-07-31 00:16:40 +0000
+++ src/URL.h	2015-08-24 12:13:55 +0000
@@ -1,60 +1,60 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_URL_H
 #define SQUID_SRC_URL_H
 
 #include "anyp/UriScheme.h"
 #include "ip/Address.h"
 #include "rfc2181.h"
 #include "SBuf.h"
 
 #include <iosfwd>
 
 /**
  * The URL class represents a Uniform Resource Location
  *
  * Governed by RFC 3986
  */
 class URL
 {
     MEMPROXY_CLASS(URL);
 
 public:
-    URL() : scheme_(), hostIsNumeric_(false), port_(0) {*host_=0;}
-    URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme), hostIsNumeric_(false), port_(0) {*host_=0;}
+    URL() : hostIsNumeric_(false), port_(0) {*host_=0;}
+    URL(AnyP::UriScheme const &aScheme);
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
         hostIsNumeric_ = false;
         *host_ = 0;
         hostAddr_.setEmpty();
         port_ = 0;
         touch();
     }
     void touch(); ///< clear the cached URI display forms
 
     AnyP::UriScheme const & getScheme() const {return scheme_;}
 
     /// convert the URL scheme to that given
     void setScheme(const AnyP::ProtocolType &p) {scheme_=p; touch();}
 
     void userInfo(const SBuf &s) {userInfo_=s; touch();}
     const SBuf &userInfo() const {return userInfo_;}
 
     void host(const char *src);
     const char *host(void) const {return host_;}
     int hostIsNumeric(void) const {return hostIsNumeric_;}
     Ip::Address const & hostIP(void) const {return hostAddr_;}
 
     void port(unsigned short p) {port_=p; touch();}
     unsigned short port() const {return port_;}
 
     void path(const char *p) {path_=p; touch();}
     void path(const SBuf &p) {path_=p; touch();}
     const SBuf &path() const;

=== modified file 'src/acl/Acl.cc'
--- src/acl/Acl.cc	2015-01-13 08:42:16 +0000
+++ src/acl/Acl.cc	2015-08-24 12:13:55 +0000
@@ -100,60 +100,69 @@ ACL::FindByName(const char *name)
     debugs(28, 9, "ACL::FindByName '" << name << "'");
 
     for (a = Config.aclList; a; a = a->next)
         if (!strcasecmp(a->name, name))
             return a;
 
     debugs(28, 9, "ACL::FindByName found no match");
 
     return NULL;
 }
 
 ACL *
 ACL::Factory (char const *type)
 {
     ACL *result = Prototype::Factory (type);
 
     if (!result)
         fatal ("Unknown acl type in ACL::Factory");
 
     return result;
 }
 
 ACL::ACL() :
     cfgline(NULL),
     next(NULL),
     registered(false)
 {
     *name = 0;
 }
 
+ACL::ACL(const ACLFlag flgs[]) :
+    cfgline(NULL),
+    next(NULL),
+    flags(flgs),
+    registered(false)
+{
+    *name = 0;
+}
+
 bool ACL::valid () const
 {
     return true;
 }
 
 bool
 ACL::matches(ACLChecklist *checklist) const
 {
     PROF_start(ACL_matches);
     debugs(28, 5, "checking " << name);
 
     // XXX: AclMatchedName does not contain a matched ACL name when the acl
     // does not match. It contains the last (usually leaf) ACL name checked
     // (or is NULL if no ACLs were checked).
     AclMatchedName = name;
 
     int result = 0;
     if (!checklist->hasRequest() && requiresRequest()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP request. Assuming mismatch.");
     } else if (!checklist->hasReply() && requiresReply()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP response. Assuming mismatch.");
     } else {
         // have to cast because old match() API is missing const
         result = const_cast<ACL*>(this)->match(checklist);
     }
 
     const char *extra = checklist->asyncInProgress() ? " async" : "";
     debugs(28, 3, "checked: " << name << " = " << result << extra);
@@ -307,63 +316,61 @@ ACL::matchForCache(ACLChecklist *)
     return 0;       /* NOTREACHED */
 }
 
 /*
  * we lookup an acl's cached results, and if we cannot find the acl being
  * checked we check it and cache the result. This function is a template
  * method to support caching of multiple acl types.
  * Note that caching of time based acl's is not
  * wise in long lived caches (i.e. the auth_user proxy match cache)
  * RBC
  * TODO: does a dlink_list perform well enough? Kinkie
  */
 int
 ACL::cacheMatchAcl(dlink_list * cache, ACLChecklist *checklist)
 {
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link;
     link = cache->head;
 
     while (link) {
         auth_match = (acl_proxy_auth_match_cache *)link->data;
 
         if (auth_match->acl_data == this) {
             debugs(28, 4, "ACL::cacheMatchAcl: cache hit on acl '" << name << "' (" << this << ")");
             return auth_match->matchrv;
         }
 
         link = link->next;
     }
 
-    auth_match = new acl_proxy_auth_match_cache();
-    auth_match->matchrv = matchForCache (checklist);
-    auth_match->acl_data = this;
+    auth_match = new acl_proxy_auth_match_cache(matchForCache(checklist), this);
     dlinkAddTail(auth_match, &auth_match->link, cache);
     debugs(28, 4, "ACL::cacheMatchAcl: miss for '" << name << "'. Adding result " << auth_match->matchrv);
     return auth_match->matchrv;
 }
 
 void
 aclCacheMatchFlush(dlink_list * cache)
 {
     acl_proxy_auth_match_cache *auth_match;
     dlink_node *link, *tmplink;
     link = cache->head;
 
     debugs(28, 8, "aclCacheMatchFlush called for cache " << cache);
 
     while (link) {
         auth_match = (acl_proxy_auth_match_cache *)link->data;
         tmplink = link;
         link = link->next;
         dlinkDelete(tmplink, cache);
         delete auth_match;
     }
 }
 
 bool
 ACL::requiresReply() const
 {
     return false;
 }
 
 bool

=== modified file 'src/acl/Acl.h'
--- src/acl/Acl.h	2015-08-17 07:16:17 +0000
+++ src/acl/Acl.h	2015-08-24 12:13:55 +0000
@@ -53,63 +53,61 @@ private:
     /// They are 57 different characters which can be fit to the bits of an 64bit
     /// integer.
     uint64_t flagToInt(const ACLFlag f) const {
         assert('A' <= f && f <= 'z');
         return ((uint64_t)1 << (f - 'A'));
     }
 
     std::string supported_; ///< The supported character flags
     uint64_t flags_; ///< The flags which is set
 public:
     static const ACLFlag NoFlags[1]; ///< An empty flags list
 };
 
 /// A configurable condition. A node in the ACL expression tree.
 /// Can evaluate itself in FilledChecklist context.
 /// Does not change during evaluation.
 /// \ingroup ACLAPI
 class ACL
 {
 
 public:
     void *operator new(size_t);
     void operator delete(void *);
 
     static ACL *Factory(char const *);
     static void ParseAclLine(ConfigParser &parser, ACL ** head);
     static void Initialize();
     static ACL *FindByName(const char *name);
 
     ACL();
-    explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs), registered(false) {
-        *name = 0;
-    }
+    explicit ACL(const ACLFlag flgs[]);
     virtual ~ACL();
 
     /// sets user-specified ACL name and squid.conf context
     void context(const char *name, const char *configuration);
 
     /// Orchestrates matching checklist against the ACL using match(),
     /// after checking preconditions and while providing debugging.
     /// Returns true if and only if there was a successful match.
     /// Updates the checklist state on match, async, and failure.
     bool matches(ACLChecklist *checklist) const;
 
     virtual ACL *clone() const = 0;
 
     /// parses node represenation in squid.conf; dies on failures
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
     virtual SBufList dump() const = 0;
     virtual bool empty() const = 0;
     virtual bool valid() const;
 
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
 
     virtual void prepareForUse() {}
 
     char name[ACL_NAME_SZ];
     char *cfgline;
     ACL *next; // XXX: remove or at least use refcounting
     ACLFlags flags; ///< The list of given ACL flags
@@ -189,41 +187,44 @@ public:
     aclMatchCode code; ///< ACCESS_* code
     int kind; ///< which custom access list verb matched
 };
 
 inline std::ostream &
 operator <<(std::ostream &o, const allow_t a)
 {
     switch (a) {
     case ACCESS_DENIED:
         o << "DENIED";
         break;
     case ACCESS_ALLOWED:
         o << "ALLOWED";
         break;
     case ACCESS_DUNNO:
         o << "DUNNO";
         break;
     case ACCESS_AUTH_REQUIRED:
         o << "AUTH_REQUIRED";
         break;
     }
     return o;
 }
 
 /// \ingroup ACLAPI
 class acl_proxy_auth_match_cache
 {
     MEMPROXY_CLASS(acl_proxy_auth_match_cache);
 
 public:
+    acl_proxy_auth_match_cache(int matchRv, void * aclData) :
+        matchrv(matchRv), acl_data(aclData) {}
+
     dlink_node link;
     int matchrv;
     void *acl_data;
 };
 
 /// \ingroup ACLAPI
 /// XXX: find a way to remove or at least use a refcounted ACL pointer
 extern const char *AclMatchedName;  /* NULL */
 
 #endif /* SQUID_ACL_H */
 

=== modified file 'src/acl/Asn.h'
--- src/acl/Asn.h	2015-01-13 07:25:36 +0000
+++ src/acl/Asn.h	2015-08-24 12:13:55 +0000
@@ -2,49 +2,50 @@
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLASN_H
 #define SQUID_ACLASN_H
 
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 #include "base/CbDataList.h"
 #include "ip/Address.h"
 
 int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
 void asnInit(void);
 
 /// \ingroup ACLAPI
 void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
 {
     MEMPROXY_CLASS(ACLASN);
 
 public:
+    ACLASN() : data(nullptr) {}
     virtual ~ACLASN();
 
     virtual bool match(Ip::Address);
     virtual SBufList dump() const;
     virtual void parse();
     bool empty() const;
     virtual ACLData<Ip::Address> *clone() const;
     virtual void prepareForUse();
 
 private:
     static ACL::Prototype SourceRegistryProtoype;
     static ACLStrategised<Ip::Address> SourceRegistryEntry_;
     static ACL::Prototype DestinationRegistryProtoype;
     static ACLStrategised<Ip::Address> DestinationRegistryEntry_;
     CbDataList<int> *data;
 };
 
 #endif /* SQUID_ACLASN_H */
 

=== modified file 'src/acl/DomainData.h'
--- src/acl/DomainData.h	2015-04-10 08:54:13 +0000
+++ src/acl/DomainData.h	2015-08-24 12:13:55 +0000
@@ -1,32 +1,33 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLDOMAINDATA_H
 #define SQUID_ACLDOMAINDATA_H
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "splay.h"
 
 class ACLDomainData : public ACLData<char const *>
 {
     MEMPROXY_CLASS(ACLDomainData);
 
 public:
+    ACLDomainData() : domains(nullptr) {}
     virtual ~ACLDomainData();
     virtual bool match(char const *);
     virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
 
     Splay<char *> *domains;
 };
 
 #endif /* SQUID_ACLDOMAINDATA_H */
 

=== modified file 'src/acl/UserData.cc'
--- src/acl/UserData.cc	2015-05-16 08:41:00 +0000
+++ src/acl/UserData.cc	2015-08-24 12:13:55 +0000
@@ -33,67 +33,62 @@ ACLUserData::match(char const *user)
     bool result = (userDataNames.find(SBuf(user)) != userDataNames.end());
     debugs(28, 7, "returning " << result);
     return result;
 }
 
 SBufList
 ACLUserData::dump() const
 {
     SBufList sl;
 
     if (flags.required) {
         sl.push_back(SBuf("REQUIRED"));
         return sl;
     }
 
     if (flags.case_insensitive)
         sl.push_back(SBuf("-i"));
 
     sl.insert(sl.end(), userDataNames.begin(), userDataNames.end());
 
     debugs(28,5, "ACLUserData dump output: " << SBufContainerJoin(userDataNames,SBuf(" ")));
     return sl;
 }
 
 static bool
 CaseInsensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
 {
     return (lhs.caseCmp(rhs) < 0);
 }
 
-static bool
-CaseSensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
-{
-    return (lhs < rhs);
-}
-
-ACLUserData::ACLUserData() : userDataNames(CaseSensitveSBufCompare)
+ACLUserData::ACLUserData() :
+    userDataNames()
 {
     flags.case_insensitive = false;
     flags.required = false;
 }
 
 void
 ACLUserData::parse()
 {
     debugs(28, 2, "parsing user list");
 
     char *t = NULL;
     if ((t = ConfigParser::strtokFile())) {
         SBuf s(t);
         debugs(28, 5, "first token is " << s);
 
         if (s.cmp("-i",2) == 0) {
             debugs(28, 5, "Going case-insensitive");
             flags.case_insensitive = true;
             // due to how the std::set API work, if we want to change
             // the comparison function we have to create a new std::set
             UserDataNames_t newUdn(CaseInsensitveSBufCompare);
             newUdn.insert(userDataNames.begin(), userDataNames.end());
             swap(userDataNames,newUdn);
         } else if (s.cmp("REQUIRED") == 0) {
             debugs(28, 5, "REQUIRED-type enabled");
             flags.required = true;
         } else {
             if (flags.case_insensitive)
                 s.toLower();
 

=== modified file 'src/auth/AclProxyAuth.cc'
--- src/auth/AclProxyAuth.cc	2015-01-13 07:25:36 +0000
+++ src/auth/AclProxyAuth.cc	2015-08-24 12:13:55 +0000
@@ -1,60 +1,65 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/UserData.h"
 #include "auth/Acl.h"
 #include "auth/AclProxyAuth.h"
 #include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "HttpRequest.h"
 
 ACLProxyAuth::~ACLProxyAuth()
 {
     delete data;
 }
 
-ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) : data(newData), type_(theType) {}
+ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) :
+    data(newData),
+    type_(theType)
+{}
 
-ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) : data(old.data->clone()), type_(old.type_)
+ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) :
+    data(old.data->clone()),
+    type_(old.type_)
 {}
 
 ACLProxyAuth &
 ACLProxyAuth::operator=(ACLProxyAuth const &rhs)
 {
     data = rhs.data->clone();
     type_ = rhs.type_;
     return *this;
 }
 
 char const *
 ACLProxyAuth::typeString() const
 {
     return type_;
 }
 
 void
 ACLProxyAuth::parse()
 {
     data->parse();
 }
 
 int
 ACLProxyAuth::match(ACLChecklist *checklist)
 {
     allow_t answer = AuthenticateAcl(checklist);
 
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:

=== modified file 'src/auth/User.cc'
--- src/auth/User.cc	2015-02-08 11:40:30 +0000
+++ src/auth/User.cc	2015-08-24 12:13:55 +0000
@@ -1,63 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 29    Authenticator */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/Gadgets.h"
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "event.h"
 #include "globals.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
 time_t Auth::User::last_discard = 0;
 
 Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
     auth_type(Auth::AUTH_UNKNOWN),
     config(aConfig),
     ipcount(0),
     expiretime(0),
-    notes(),
     credentials_state(Auth::Unchecked),
-    username_(NULL),
+    username_(nullptr),
     requestRealm_(aRequestRealm)
 {
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
     ip_list.head = ip_list.tail = NULL;
     debugs(29, 5, HERE << "Initialised auth_user '" << this << "'.");
 }
 
 Auth::CredentialState
 Auth::User::credentials() const
 {
     return credentials_state;
 }
 
 void
 Auth::User::credentials(CredentialState newCreds)
 {
     credentials_state = newCreds;
 }
 
 /**
  * Combine two user structs. ONLY to be called from within a scheme
  * module. The scheme module is responsible for ensuring that the
  * two users _can_ be merged without invalidating all the request
  * scheme data. The scheme is also responsible for merging any user
  * related scheme data itself.
  * The caller is responsible for altering all refcount pointers to
  * the 'from' object. They are invalid once this method is complete.
  */
 void
 Auth::User::absorb(Auth::User::Pointer from)

=== modified file 'src/auth/negotiate/UserRequest.cc'
--- src/auth/negotiate/UserRequest.cc	2015-08-04 19:57:07 +0000
+++ src/auth/negotiate/UserRequest.cc	2015-08-24 12:13:55 +0000
@@ -1,64 +1,63 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "auth/negotiate/Config.h"
 #include "auth/negotiate/UserRequest.h"
 #include "auth/State.h"
 #include "auth/User.h"
 #include "client_side.h"
 #include "fatal.h"
 #include "format/Format.h"
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
-Auth::Negotiate::UserRequest::UserRequest()
-{
-    waiting=0;
-    client_blob=0;
-    server_blob=0;
-    authserver=NULL;
-    request=NULL;
-}
+Auth::Negotiate::UserRequest::UserRequest() :
+    authserver(nullptr),
+    server_blob(nullptr),
+    client_blob(nullptr),
+    waiting(0),
+    request(nullptr)
+{}
 
 Auth::Negotiate::UserRequest::~UserRequest()
 {
     assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
     releaseAuthServer();
 
     if (request) {
         HTTPMSGUNLOCK(request);
         request = NULL;
     }
 }
 
 const char *
 Auth::Negotiate::UserRequest::connLastHeader()
 {
     return NULL;
 }
 
 int
 Auth::Negotiate::UserRequest::authenticated() const
 {
     if (user() != NULL && user()->credentials() == Auth::Ok) {
         debugs(29, 9, HERE << "user authenticated.");
         return 1;
     }
 
     debugs(29, 9, HERE << "user not fully authenticated.");

=== modified file 'src/auth/ntlm/UserRequest.cc'
--- src/auth/ntlm/UserRequest.cc	2015-08-04 19:57:07 +0000
+++ src/auth/ntlm/UserRequest.cc	2015-08-24 12:13:55 +0000
@@ -1,63 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "auth/ntlm/Config.h"
 #include "auth/ntlm/UserRequest.h"
 #include "auth/State.h"
 #include "cbdata.h"
 #include "client_side.h"
 #include "fatal.h"
 #include "format/Format.h"
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
-Auth::Ntlm::UserRequest::UserRequest()
-{
-    waiting=0;
-    client_blob=0;
-    server_blob=0;
-    authserver=NULL;
-    request=NULL;
-}
+Auth::Ntlm::UserRequest::UserRequest() :
+    authserver(nullptr),
+    server_blob(nullptr),
+    client_blob(nullptr),
+    waiting(0),
+    request(nullptr)
+{}
 
 Auth::Ntlm::UserRequest::~UserRequest()
 {
     assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
     releaseAuthServer();
 
     if (request) {
         HTTPMSGUNLOCK(request);
         request = NULL;
     }
 }
 
 const char *
 Auth::Ntlm::UserRequest::connLastHeader()
 {
     return NULL;
 }
 
 int
 Auth::Ntlm::UserRequest::authenticated() const
 {
     if (user() != NULL && user()->credentials() == Auth::Ok) {
         debugs(29, 9, HERE << "user authenticated.");
         return 1;
     }
 
     debugs(29, 9, HERE << "user not fully authenticated.");

=== modified file 'src/comm/Connection.cc'
--- src/comm/Connection.cc	2015-06-02 10:15:06 +0000
+++ src/comm/Connection.cc	2015-08-24 12:13:55 +0000
@@ -1,64 +1,62 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "CachePeer.h"
 #include "cbdata.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
 #include "neighbors.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 
 class CachePeer;
 bool
 Comm::IsConnOpen(const Comm::ConnectionPointer &conn)
 {
     return conn != NULL && conn->isOpen();
 }
 
 Comm::Connection::Connection() :
-    local(),
-    remote(),
     peerType(HIER_NONE),
     fd(-1),
     tos(0),
     nfmark(0),
     flags(COMM_NONBLOCKING),
-    peer_(NULL),
+    peer_(nullptr),
     startTime_(squid_curtime)
 {
     *rfc931 = 0; // quick init the head. the rest does not matter.
 }
 
 static int64_t lost_conn = 0;
 Comm::Connection::~Connection()
 {
     if (fd >= 0) {
         debugs(5, 4, "BUG #3329: Orphan Comm::Connection: " << *this);
         debugs(5, 4, "NOTE: " << ++lost_conn << " Orphans since last started.");
         close();
     }
 
     cbdataReferenceDone(peer_);
 }
 
 Comm::ConnectionPointer
 Comm::Connection::copyDetails() const
 {
     ConnectionPointer c = new Comm::Connection;
 
     c->setAddrs(local, remote);
     c->peerType = peerType;
     c->tos = tos;
     c->nfmark = nfmark;
     c->flags = flags;
     c->startTime_ = startTime_;
 
     // ensure FD is not open in the new copy.

=== modified file 'src/esi/Esi.cc'
--- src/esi/Esi.cc	2015-08-04 19:57:07 +0000
+++ src/esi/Esi.cc	2015-08-24 12:13:55 +0000
@@ -1457,65 +1457,64 @@ esiComment::finish()
 
 void
 esiComment::render(ESISegment::Pointer output)
 {
     /* Comments do nothing dude */
     debugs(86, 5, "esiCommentRender: Rendering comment " << this << " into " << output.getRaw());
 }
 
 ESIElement::Pointer
 esiComment::makeCacheable() const
 {
     debugs(86, 5, "esiComment::makeCacheable: returning NULL");
     return NULL;
 }
 
 ESIElement::Pointer
 esiComment::makeUsable(esiTreeParentPtr, ESIVarState &) const
 {
     fatal ("esiComment::Usable: unreachable code!\n");
     return NULL;
 }
 
 /* esiLiteral */
 esiLiteral::~esiLiteral()
 {
     debugs(86, 5, "esiLiteral::~esiLiteral: " << this);
     ESISegmentFreeList (buffer);
     cbdataReferenceDone (varState);
 }
 
-esiLiteral::esiLiteral(ESISegment::Pointer aSegment)
+esiLiteral::esiLiteral(ESISegment::Pointer aSegment) :
+    buffer(aSegment),
+    varState(nullptr)
 {
-    buffer = aSegment;
-    /* we've been handed a complete, processed string */
-    varState = NULL;
     /* Nothing to do */
     flags.donevars = 1;
 }
 
 void
 esiLiteral::finish()
 {}
 
 /* precondition: the buffer chain has at least start + length bytes of data
  */
 esiLiteral::esiLiteral(ESIContext *context, const char *s, int numberOfCharacters)
 {
     assert (s);
     flags.donevars = 0;
     buffer = new ESISegment;
     ESISegment::Pointer local = buffer;
     size_t start = 0;
     int remainingCharacters = numberOfCharacters;
 
     while (remainingCharacters > 0) {
         if (local->len == sizeof (local->buf)) {
             local->next = new ESISegment;
             local=local->next;
         }
 
         size_t len = local->append (&s[start], remainingCharacters);
         start += len;
         remainingCharacters -= len;
     }
 
@@ -1854,61 +1853,64 @@ esiTry::makeUsable(esiTreeParentPtr newP
         resultT->attempt = attempt->makeUsable(resultT, newVarState);
 
     if (except.getRaw())
         resultT->except  = except->makeUsable(resultT, newVarState);
 
     return result;
 }
 
 void
 esiTry::finish()
 {
     parent = NULL;
 
     if (attempt.getRaw())
         attempt->finish();
 
     attempt = NULL;
 
     if (except.getRaw())
         except->finish();
 
     except = NULL;
 }
 
 /* esiChoose */
 esiChoose::~esiChoose()
 {
     debugs(86, 5, "esiChoose::~esiChoose " << this);
 }
 
-esiChoose::esiChoose(esiTreeParentPtr aParent) : elements (), chosenelement (-1),parent (aParent)
+esiChoose::esiChoose(esiTreeParentPtr aParent) :
+    elements(),
+    chosenelement(-1),
+    parent(aParent)
 {}
 
 void
 esiChoose::render(ESISegment::Pointer output)
 {
     /* append all processed elements, and trim processed and rendered elements */
     assert (output->next == NULL);
     assert (elements.size() || otherwise.getRaw());
     debugs(86, 5, "esiChooseRender: rendering");
 
     if (chosenelement >= 0)
         elements[chosenelement]->render(output);
     else if (otherwise.getRaw())
         otherwise->render(output);
 }
 
 bool
 esiChoose::addElement(ESIElement::Pointer element)
 {
     /* add an element to the output list */
 
     if (dynamic_cast<esiLiteral*>(element.getRaw())) {
         /* Swallow whitespace */
         debugs(86, 5, "esiChooseAdd: Choose " << this << " skipping whitespace " << element.getRaw());
         return true;
     }
 
     /* Some elements require specific parents */
     if (!(dynamic_cast<esiWhen*>(element.getRaw()) || dynamic_cast<esiOtherwise*>(element.getRaw()))) {
         debugs(86, DBG_CRITICAL, "esiChooseAdd: invalid child node for esi:choose (section 3.3)");

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2015-08-04 21:04:09 +0000
+++ src/external_acl.cc	2015-08-24 12:13:55 +0000
@@ -46,61 +46,67 @@
 #endif
 #if USE_IDENT
 #include "ident/AclIdent.h"
 #endif
 
 #ifndef DEFAULT_EXTERNAL_ACL_TTL
 #define DEFAULT_EXTERNAL_ACL_TTL 1 * 60 * 60
 #endif
 #ifndef DEFAULT_EXTERNAL_ACL_CHILDREN
 #define DEFAULT_EXTERNAL_ACL_CHILDREN 5
 #endif
 
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static int external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry);
 static void external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry);
 static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
 
 /******************************************************************
  * external_acl directive
  */
 
 class external_acl_format : public RefCountable
 {
     MEMPROXY_CLASS(external_acl_format);
 
 public:
     typedef RefCount<external_acl_format> Pointer;
 
-    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(Http::HdrType::BAD_HDR) {}
+    external_acl_format() :
+        type(Format::LFT_NONE),
+        header(nullptr),
+        member(nullptr),
+        separator(' '),
+        header_id(Http::HdrType::BAD_HDR)
+    {}
     ~external_acl_format() {
         xfree(header);
         xfree(member);
     }
 
     Format::ByteCode_t type;
     external_acl_format::Pointer next;
     char *header;
     char *member;
     char separator;
     Http::HdrType header_id;
 };
 
 class external_acl
 {
     /* FIXME: These are not really cbdata, but it is an easy way
      * to get them pooled, refcounted, accounted and freed properly...
      */
     CBDATA_CLASS(external_acl);
 
 public:
     external_acl();
     ~external_acl();
 
     external_acl *next;
 
     void add(const ExternalACLEntryPointer &);
 
     void trimCache();
 

=== modified file 'src/fs/ufs/UFSStoreState.h'
--- src/fs/ufs/UFSStoreState.h	2015-05-16 08:41:00 +0000
+++ src/fs/ufs/UFSStoreState.h	2015-08-24 12:13:55 +0000
@@ -21,74 +21,85 @@ namespace Ufs
 class UFSStoreState : public StoreIOState, public IORequestor
 {
     CBDATA_CLASS(UFSStoreState);
 
 public:
     UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB * callback_, void *callback_data_);
     ~UFSStoreState();
     virtual void close(int how);
     virtual void closeCompleted();
     // protected:
     virtual void ioCompletedNotification();
     virtual void readCompleted(const char *buf, int len, int errflag, RefCount<ReadRequest>);
     virtual void writeCompleted(int errflag, size_t len, RefCount<WriteRequest>);
     RefCount<DiskFile> theFile;
     bool opening;
     bool creating;
     bool closing;
     bool reading;
     bool writing;
     /* StoreIOState API */
     void read_(char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data);
     virtual bool write(char const *buf, size_t size, off_t offset, FREE * free_func);
 
 protected:
     virtual void doCloseCallback (int errflag);
 
     class _queued_read
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_read);
     public:
-        _queued_read() : buf(NULL), size(0), offset(0), callback(NULL), callback_data(NULL) {}
+        _queued_read() :
+            buf(nullptr),
+            size(0),
+            offset(0),
+            callback(nullptr),
+            callback_data(nullptr)
+        {}
 
         char *buf;
         size_t size;
         off_t offset;
         STRCB *callback;
         void *callback_data;
     };
 
     class _queued_write
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_write);
     public:
-        _queued_write() : buf(NULL), size(0), offset(0), free_func(NULL) {}
+        _queued_write() :
+            buf(nullptr),
+            size(0),
+            offset(0),
+            free_func(nullptr)
+        {}
 
         char const *buf;
         size_t size;
         off_t offset;
         FREE *free_func;
     };
 
     /** \todo These should be in the IO strategy */
 
     struct {
         /**
          * DPW 2006-05-24
          * the write_draining flag is used to avoid recursion inside
          * the UFSStoreState::drainWriteQueue() method.
          */
         bool write_draining;
         /**
          * DPW 2006-05-24
          * The try_closing flag is set by UFSStoreState::tryClosing()
          * when UFSStoreState wants to close the file, but cannot
          * because of pending I/Os.  If set, UFSStoreState will
          * try to close again in the I/O callbacks.
          */
         bool try_closing;
     } flags;
     link_list *pending_reads;
     link_list *pending_writes;
     void queueRead(char *, size_t, off_t, STRCB *, void *);
     void queueWrite(char const *, size_t, off_t, FREE *);
     bool kickReadQueue();

=== modified file 'src/mime.cc'
--- src/mime.cc	2015-07-07 11:53:08 +0000
+++ src/mime.cc	2015-08-24 12:13:55 +0000
@@ -89,64 +89,63 @@ mimeGetEntry(const char *fn, int skip_en
 
         for (m = MimeTable; m; m = m->next) {
             if (regexec(&m->compiled_pattern, name, 0, 0, 0) == 0)
                 break;
         }
 
         if (!skip_encodings)
             (void) 0;
         else if (m == NULL)
             (void) 0;
         else if (strcmp(m->content_type, dash_str))
             (void) 0;
         else if (!strcmp(m->content_encoding, dash_str))
             (void) 0;
         else {
             /* Assume we matched /\.\w$/ and cut off the last extension */
             if ((t = strrchr(name, '.'))) {
                 *t = '\0';
             } else {
                 /* What? A encoding without a extension? */
                 m = NULL;
             }
         }
     } while (t);
 
     xfree(name);
     return m;
 }
 
 MimeIcon::MimeIcon(const char *aName) :
-    icon_(aName)
-{
-    url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
-}
+    icon_(aName),
+    url_(xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_)))
+{}
 
 MimeIcon::~MimeIcon()
 {
     xfree(url_);
 }
 
 void
 MimeIcon::setName(char const *aString)
 {
     xfree(url_);
     icon_ = aString;
     url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
 }
 
 SBuf
 MimeIcon::getName() const
 {
     return icon_;
 }
 
 const SBuf
 mimeGetIcon(const char *fn)
 {
     MimeEntry *m = mimeGetEntry(fn, 1);
 
     if (!m || !m->theIcon.getName().cmp(dash_str))
         return SBuf();
 
     return m->theIcon.getName();
 }

=== modified file 'src/url.cc'
--- src/url.cc	2015-08-04 19:57:07 +0000
+++ src/url.cc	2015-08-24 12:13:55 +0000
@@ -889,30 +889,37 @@ URLHostName::trimTrailingChars()
 
 void
 URLHostName::trimAuth()
 {
     char *t;
 
     if ((t = strrchr(Host, '@'))) {
         ++t;
         memmove(Host, t, strlen(t) + 1);
     }
 }
 
 char *
 URLHostName::extract(char const *aUrl)
 {
     init(aUrl);
     findHostStart();
 
     if (hostStart == NULL)
         return NULL;
 
     xstrncpy(Host, hostStart, SQUIDHOSTNAMELEN);
 
     trimTrailingChars();
 
     trimAuth();
 
     return Host;
 }
 
+URL::URL(AnyP::UriScheme const &aScheme) :
+    scheme_(aScheme),
+    hostIsNumeric_(false),
+    port_(0)
+{
+    *host_=0;
+}

