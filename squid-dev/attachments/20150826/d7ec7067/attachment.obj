=== modified file 'acinclude/ax_cxx_0x_types.m4'
--- acinclude/ax_cxx_0x_types.m4	2015-08-25 14:36:54 +0000
+++ acinclude/ax_cxx_0x_types.m4	2015-08-26 09:53:30 +0000
@@ -53,30 +53,53 @@
 
 ## Hand crafted for Squid under GPL version 2
 AC_DEFUN([AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS],[
   AC_REQUIRE([AC_PROG_CXX])
   AC_LANG_PUSH([C++])
   AC_CHECK_HEADERS(tr1/random)
   AC_CACHE_CHECK([whether std::uniform_int_distribution<T> is supported],
                  [squid_cv_std_uniform_int_distribution_works],[
     AC_TRY_COMPILE([#include <random>],[std::uniform_int_distribution<int> c;],
       [squid_cv_std_uniform_int_distribution_works=yes],
       [squid_cv_std_uniform_int_distribution_works=no])
     ])
   SQUID_DEFINE_BOOL([HAVE_STD_UNIFORM_INT_DISTRIBUTION],
       [$squid_cv_std_uniform_int_distribution_works],
       [Define if c++11 std::uniform_int_distribution is supported])
 
   AC_CACHE_CHECK([whether std::uniform_real_distribution<T> is supported],
                  [squid_cv_std_uniform_real_distribution_works],[
     AC_REQUIRE([AC_PROG_CXX])
     AC_LANG_PUSH([C++])
     AC_TRY_COMPILE([#include <random>],[std::uniform_real_distribution<double> c;],
       [squid_cv_std_uniform_real_distribution_works=yes],
       [squid_cv_std_uniform_real_distribution_works=no])
     ])
   SQUID_DEFINE_BOOL([HAVE_STD_UNIFORM_REAL_DISTRIBUTION],
       [$squid_cv_std_uniform_real_distribution_works],
       [Define if c++11 std::uniform_real_distribution is supported])
 
   AC_LANG_POP
 ])
+
+AC_DEFUN([AX_CXX11_SUPPORTS_OVERRIDE_KEYWORD],[
+  AC_REQUIRE([AC_PROG_CXX])
+  AC_LANG_PUSH([C++])
+  AC_CACHE_CHECK([whether the c++11 compiler supports the override keyword],
+    [squid_cv_cxx11_supports_override],[
+      AC_TRY_COMPILE([],[
+class Base {
+  public:
+    virtual void method() {}
+};
+class Derived : public Base {
+  public:
+    virtual void method() override {}
+};
+Derived d; d.method();
+      ],[squid_cv_cxx11_supports_override=yes],[squid_cv_cxx11_supports_override=no])
+      ])
+  AC_LANG_POP
+  SQUID_DEFINE_BOOL([HAVE_CXX11_OVERRIDE_KEYWORD],[$squid_cv_cxx11_supports_override],
+    [Define if the c++11 compiler supports c++ override keyword for class methods])
+])
+   

=== modified file 'compat/types.h'
--- compat/types.h	2015-08-25 14:36:54 +0000
+++ compat/types.h	2015-08-26 11:59:03 +0000
@@ -154,32 +154,39 @@
 typedef unsigned long fd_mask;
 #endif
 
 #ifndef HAVE_SOCKLEN_T
 typedef int socklen_t;
 #endif
 
 #ifndef HAVE_MTYP_T
 typedef long mtyp_t;
 #endif
 
 #ifndef NULL
 #define NULL 0
 #endif
 
 /***********************************************************/
 /* uniform_int_distribution backward compatibility wrapper */
 /***********************************************************/
 #if HAVE_STD_UNIFORM_INT_DISTRIBUTION
 #define xuniform_int_distribution std::uniform_int_distribution
 #else
 #define xuniform_int_distribution std::tr1::uniform_int
 #endif
 
 #if HAVE_STD_UNIFORM_REAL_DISTRIBUTION
 #define xuniform_real_distribution std::uniform_real_distribution
 #else
 #define xuniform_real_distribution std::tr1::uniform_real
 #endif
 
+#if HAVE_CXX11_OVERRIDE_KEYWORD
+///use in place of c++11 "override" keyword, will expand to keyword if compiler supports
+#define OVERRIDE override
+#else
+#define OVERRIDE
+#endif
+
 #endif /* SQUID_TYPES_H */
 

=== modified file 'configure.ac'
--- configure.ac	2015-08-23 11:53:54 +0000
+++ configure.ac	2015-08-26 09:49:50 +0000
@@ -2927,60 +2927,61 @@
 AC_CHECK_SIZEOF(void *)
 
 # check for a bunch of types
 AC_TYPE_INT8_T
 AC_TYPE_UINT8_T
 AC_TYPE_INT16_T
 AC_TYPE_UINT16_T
 AC_TYPE_INT32_T
 AC_TYPE_UINT32_T
 AC_TYPE_INT64_T
 AC_TYPE_UINT64_T
 AC_TYPE_PID_T
 AC_TYPE_SIZE_T
 AC_TYPE_SSIZE_T
 AC_TYPE_OFF_T
 AC_TYPE_UID_T
 AC_CHECK_TYPE([bool])
 #need the defines for PRId64
 AC_CHECK_SIZEOF(int64_t)
 AC_CHECK_SIZEOF(long)
 #need the defines for PRIuSIZE
 AC_CHECK_SIZEOF(size_t)
 #need the define for overflow checks
 AC_CHECK_SIZEOF(off_t)
 AC_CHECK_SIZEOF(size_t)
 
 dnl Some C++11 types we try to use
 AX_CXX_TYPE_NULLPTR
 AX_CXX_TYPE_UNIQUE_PTR
 AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS
+AX_CXX11_SUPPORTS_OVERRIDE_KEYWORD
 
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
 dnl For this reason, we must check if pad128_t and upad128_t are defined.
 AC_CHECK_TYPE(pad128_t,
   AC_DEFINE(HAVE_PAD128_T,1,[pad128_t is defined in system headers]),
   ,SQUID_DEFAULT_INCLUDES)
 
 AC_CHECK_TYPE(upad128_t,
   AC_DEFINE(HAVE_UPAD128_T,1,[upad128_t is defined in system headers]),
   ,SQUID_DEFAULT_INCLUDES)
 
 AC_CHECK_TYPE(mode_t, AC_DEFINE(HAVE_MODE_T,1,[mode_t is defined by the system headers]),,SQUID_DEFAULT_INCLUDES)
 AC_CHECK_TYPE(fd_mask,  AC_DEFINE(HAVE_FD_MASK,1,[fd_mask is defined by the system headers]),,SQUID_DEFAULT_INCLUDES)
 
 AC_CHECK_TYPE(socklen_t,AC_DEFINE(HAVE_SOCKLEN_T,1,[socklen_t is defined by the system headers]),,[
 #include <sys/types.h>
 #include <sys/socket.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif])
 
 AC_CHECK_TYPE(mtyp_t,AC_DEFINE(HAVE_MTYP_T,1,
    [mtyp_t is defined by the system headers]),,[#include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/msg.h>])
 
 # check for compiler support of %zu printf macro
 AH_TEMPLATE(PRIuSIZE,[Compiler supports %zu printf macro])

=== modified file 'src/acl/Tree.h'
--- src/acl/Tree.h	2015-08-17 07:16:17 +0000
+++ src/acl/Tree.h	2015-08-26 09:28:19 +0000
@@ -14,42 +14,42 @@
 
 namespace Acl
 {
 
 /// An ORed set of rules at the top of the ACL expression tree, providing two
 /// unique properties: cbdata protection and optional rule actions.
 class Tree: public OrNode
 {
     // XXX: We should use refcounting instead, but it requires making ACLs
     // refcounted as well. Otherwise, async lookups will reach deleted ACLs.
     CBDATA_CLASS(Tree);
 
 public:
     /// dumps <name, action, rule, new line> tuples
     /// action.kind is mapped to a string using the supplied conversion table
     typedef const char **ActionToString;
     SBufList treeDump(const char *name, const ActionToString &convert) const;
 
     /// Returns the corresponding action after a successful tree match.
     allow_t winningAction() const;
 
     /// what action to use if no nodes matched
     allow_t lastAction() const;
 
     /// appends and takes control over the rule with a given action
     void add(ACL *rule, const allow_t &action);
     void add(ACL *rule); ///< same as InnerNode::add()
 
 protected:
     /// Acl::OrNode API
-    virtual bool bannedAction(ACLChecklist *, Nodes::const_iterator) const override;
+    virtual bool bannedAction(ACLChecklist *, Nodes::const_iterator) const OVERRIDE;
     allow_t actionAt(const Nodes::size_type pos) const;
 
     /// if not empty, contains actions corresponding to InnerNode::nodes
     typedef std::vector<allow_t> Actions;
     Actions actions;
 };
 
 } // namespace Acl
 
 #endif /* SQUID_ACL_TREE_H */
 

