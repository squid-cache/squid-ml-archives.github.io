=== modified file 'acinclude/ax_cxx_0x_types.m4'
--- acinclude/ax_cxx_0x_types.m4	2015-08-26 15:32:31 +0000
+++ acinclude/ax_cxx_0x_types.m4	2015-08-27 09:43:55 +0000
@@ -53,30 +53,53 @@ AC_DEFUN([AX_CXX_TYPE_UNIQUE_PTR],[
 
 ## Hand crafted for Squid under GPL version 2
 AC_DEFUN([AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS],[
   AC_REQUIRE([AC_PROG_CXX])
   AC_LANG_PUSH([C++])
   AC_CHECK_HEADERS(tr1/random)
   AC_CACHE_CHECK([whether std::uniform_int_distribution<T> is supported],
                  [squid_cv_std_uniform_int_distribution_works],[
     AC_TRY_COMPILE([#include <random>],[std::uniform_int_distribution<int> c;],
       [squid_cv_std_uniform_int_distribution_works=yes],
       [squid_cv_std_uniform_int_distribution_works=no])
     ])
   SQUID_DEFINE_BOOL([HAVE_STD_UNIFORM_INT_DISTRIBUTION],
       [$squid_cv_std_uniform_int_distribution_works],
       [Define if c++11 std::uniform_int_distribution is supported])
 
   AC_CACHE_CHECK([whether std::uniform_real_distribution<T> is supported],
                  [squid_cv_std_uniform_real_distribution_works],[
     AC_REQUIRE([AC_PROG_CXX])
     AC_LANG_PUSH([C++])
     AC_TRY_COMPILE([#include <random>],[std::uniform_real_distribution<double> c;],
       [squid_cv_std_uniform_real_distribution_works=yes],
       [squid_cv_std_uniform_real_distribution_works=no])
     ])
   SQUID_DEFINE_BOOL([HAVE_STD_UNIFORM_REAL_DISTRIBUTION],
       [$squid_cv_std_uniform_real_distribution_works],
       [Define if c++11 std::uniform_real_distribution is supported])
 
   AC_LANG_POP
 ])
+
+## SQUID_CXX_STD_UNDERLYING_TYPE
+## checks whether the std::underlying_type<enumType>::type trait exists
+AC_DEFUN([SQUID_CXX_STD_UNDERLYING_TYPE],[
+  AC_CACHE_CHECK([whether compiler supports std::underlying_type],
+    [squid_cv_have_std_underlying_type],[
+      AC_REQUIRE([AC_PROG_CXX])
+      AC_LANG_PUSH([C++])
+      AC_COMPILE_IFELSE([
+        AC_LANG_PROGRAM([
+#include <type_traits>
+enum class testEnum { one, two, three };
+        ],[
+        std::underlying_type<testEnum>::type testNum = 0;
+        ])],
+        [squid_cv_have_std_underlying_type=yes],
+        [squid_cv_have_std_underlying_type=no])
+      AC_LANG_POP
+  ])
+  SQUID_DEFINE_BOOL([HAVE_STD_UNDERLYING_TYPE],
+     [$squid_cv_have_std_underlying_type],
+     [Define if stdlibc support std::underlying_type for enums])
+])

=== modified file 'configure.ac'
--- configure.ac	2015-08-26 15:32:31 +0000
+++ configure.ac	2015-08-27 09:43:55 +0000
@@ -2912,60 +2912,61 @@ dnl Check for typedefs
 AC_CHECK_SIZEOF(void *)
 
 # check for a bunch of types
 AC_TYPE_INT8_T
 AC_TYPE_UINT8_T
 AC_TYPE_INT16_T
 AC_TYPE_UINT16_T
 AC_TYPE_INT32_T
 AC_TYPE_UINT32_T
 AC_TYPE_INT64_T
 AC_TYPE_UINT64_T
 AC_TYPE_PID_T
 AC_TYPE_SIZE_T
 AC_TYPE_SSIZE_T
 AC_TYPE_OFF_T
 AC_TYPE_UID_T
 AC_CHECK_TYPE([bool])
 #need the defines for PRId64
 AC_CHECK_SIZEOF(int64_t)
 AC_CHECK_SIZEOF(long)
 #need the defines for PRIuSIZE
 AC_CHECK_SIZEOF(size_t)
 #need the define for overflow checks
 AC_CHECK_SIZEOF(off_t)
 AC_CHECK_SIZEOF(size_t)
 
 dnl Some C++11 types we try to use
 AX_CXX_TYPE_NULLPTR
 AX_CXX_TYPE_UNIQUE_PTR
 AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS
+SQUID_CXX_STD_UNDERLYING_TYPE
 
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
 dnl For this reason, we must check if pad128_t and upad128_t are defined.
 AC_CHECK_TYPE(pad128_t,
   AC_DEFINE(HAVE_PAD128_T,1,[pad128_t is defined in system headers]),
   ,SQUID_DEFAULT_INCLUDES)
 
 AC_CHECK_TYPE(upad128_t,
   AC_DEFINE(HAVE_UPAD128_T,1,[upad128_t is defined in system headers]),
   ,SQUID_DEFAULT_INCLUDES)
 
 AC_CHECK_TYPE(mode_t, AC_DEFINE(HAVE_MODE_T,1,[mode_t is defined by the system headers]),,SQUID_DEFAULT_INCLUDES)
 AC_CHECK_TYPE(fd_mask,  AC_DEFINE(HAVE_FD_MASK,1,[fd_mask is defined by the system headers]),,SQUID_DEFAULT_INCLUDES)
 
 AC_CHECK_TYPE(socklen_t,AC_DEFINE(HAVE_SOCKLEN_T,1,[socklen_t is defined by the system headers]),,[
 #include <sys/types.h>
 #include <sys/socket.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif])
 
 AC_CHECK_TYPE(mtyp_t,AC_DEFINE(HAVE_MTYP_T,1,
    [mtyp_t is defined by the system headers]),,[#include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/msg.h>])
 
 # check for compiler support of %zu printf macro
 AH_TEMPLATE(PRIuSIZE,[Compiler supports %zu printf macro])

=== added file 'src/base/EnumIterator.h'
--- src/base/EnumIterator.h	1970-01-01 00:00:00 +0000
+++ src/base/EnumIterator.h	2015-08-27 09:43:55 +0000
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_BASE_ENUMITERATOR_H
+#define SQUID_BASE_ENUMITERATOR_H
+
+#include <iterator>
+#include <type_traits>
+
+/** Shared functionality between forward and reverse enum iterators
+ *
+ * This class is not very useful by itself, it contains code shared by
+ * EnumIterator and ReverseEnumIterator.
+ *
+ * \see EnumIterator, ReverseEnumIterator
+ */
+template <typename EnumType>
+class EnumIteratorBase : public std::iterator<std::bidirectional_iterator_tag, EnumType>
+{
+protected:
+#if HAVE_STD_UNDERLYING_TYPE
+    typedef typename std::underlying_type<EnumType>::type iterator_type;
+#else
+    typedef int iterator_type;
+#endif
+
+public:
+    explicit EnumIteratorBase(EnumType e) : current(static_cast<iterator_type>(e)) {}
+
+    bool operator==(const EnumIteratorBase &i) const {
+        return current == i.current;
+    }
+
+    bool operator!=(const EnumIteratorBase &i) const {
+        return current != i.current;
+    }
+
+    EnumType operator*() const {
+        return static_cast<EnumType>(current);
+    }
+protected:
+    iterator_type current;
+};
+
+/** bidirectional iterator over an enum type
+ *
+ * It can be instantiated using any enum (or C++11 strongly-typed enum)
+ * value; the most common expected use scenario has iterators emitted by
+ * EnumRange and WholeEnum via standard begin() and end() calls.
+ *
+ * In order for the iterator to work, it is mandatory that the underlying
+ * enum type's representation values be sequential.
+ *
+ * The iterator does not check for bounds when incrementing or decrementing,
+ * that responsibility is left to the caller.
+ *
+ * \see EnumRange, WholeEnum, ReverseEnumIterator
+ */
+template <typename EnumType>
+class EnumIterator : public EnumIteratorBase<EnumType>
+{
+public:
+    explicit EnumIterator(EnumType e) : EnumIteratorBase<EnumType>(e) {}
+
+    EnumIterator& operator++() {
+        ++ EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    EnumIterator& operator++(int) {
+        EnumIterator rv(*this);
+        ++ EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+
+    EnumIterator& operator--() {
+        -- EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    EnumIterator& operator--(int) {
+        EnumIterator rv(*this);
+        -- EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+};
+
+/** bidirectional reverse iterator over an enum type
+ *
+ * It can be instantiated using any enum (or C++11 strongly-typed enum)
+ * value; the most common expected use scenario has iterators emitted by
+ * EnumRange and WholeEnum via standard rbegin() and rend() calls.
+ *
+ * In order for the iterator to work, it is mandatory that the underlying
+ * enum type's representation values be sequential.
+ *
+ * The iterator does not check for bounds; behavior is undefined if the iterator
+ * is incremented (or decremented) outside the range representing valid
+ * enum symbols (remember: an enum is not a data structure).
+ *
+ * \see EnumRange, WholeEnum, EnumIterator
+ */
+template <typename EnumType>
+class ReverseEnumIterator : public EnumIteratorBase<EnumType>
+{
+public:
+    explicit ReverseEnumIterator(EnumType e) : EnumIteratorBase<EnumType>(e) {}
+
+    // prefix increment
+    ReverseEnumIterator& operator++() {
+        -- EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix increment
+    ReverseEnumIterator& operator++(int) {
+        ReverseEnumIterator rv(*this);
+        -- EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+
+    // prefix decrement
+    ReverseEnumIterator& operator--() {
+        ++ EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix decrement
+    ReverseEnumIterator& operator--(int) {
+        ReverseEnumIterator rv(*this);
+        ++ EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+};
+
+/** Class expressing a continuous range of an enum for range-for expressions
+ *
+ * This class requires that the underlying enum values be represented by
+ * continuous values of an integral type.
+ * Users will usually not rely on this class directly but on the more convenient
+ * EnumRange function
+ *
+ * \note EnumIterator<enum>(EnumType::firstmember,EnumType::lastmember)
+ * will miss EnumType::lastmember while iterating. If you need to iterate
+ * over all of EnumType, use class WholeEnum.
+ *
+ * \see EnumRange(EnumType begin, EnumType one_past_end), WholeEnum
+ */
+template <typename EnumType>
+class EnumRangeT
+{
+public:
+    typedef EnumIterator<EnumType> iterator;
+    typedef ReverseEnumIterator<EnumType> reverse_iterator;
+    EnumRangeT(EnumType first, EnumType one_past_last) : begin_(first), end_(one_past_last) { }
+    iterator begin() const { return iterator(begin_);}
+    iterator end() const { return iterator(end_);}
+    reverse_iterator rbegin() const { return ++reverse_iterator(end_); }
+    reverse_iterator rend() const { return ++reverse_iterator(begin_); }
+private:
+    EnumType begin_;
+    EnumType end_;
+};
+
+/** Generate a continuous range of an enum for range-for expressions
+ *
+ * convenience function to deduce the right type for instantiating EnumRangeT.
+ * See EnumRangeT for more detailed documentation and caveats.
+ *
+ * Typical use:
+ * \code
+ * enum class EnumType {
+ *   zeroth, first, second, onePastLast, fourth
+ * };
+ * for (auto enumvalue : EnumRange(EnumType::first,EnumType::onePastLast)) {
+ *   do_stuff();
+ * }
+ * \endcode
+ */
+template <typename EnumType>
+EnumRangeT<EnumType> EnumRange(EnumType begin, EnumType one_past_end)
+{
+    return EnumRangeT<EnumType>(begin,one_past_end);
+}
+
+/** generate a continuous range of a whole enum for range-for expressions
+ *
+ * Class for iterating all enum values, from EnumType::enumBegin_ up to, but
+ * not including, EnumType::enumEnd_.
+ *
+ * This class requires that:
+ * - the underlying enum values be represented by continuous values of
+ *   an integral type.
+ * - both enumBegin_ and enumEnd_ markers must be present as EnumType values;
+ * - enumBegin_ must have the same representation as the first element of the
+ *   enum
+ * - enumEnd_ must have a representation that is one past the last
+ *   user-accessible value of the enum.
+ *
+ * Typical use:
+ * \code
+ * enum class EnumType {
+ *   enumBegin_ = 0,
+ *   first_value = enumBegin_,
+ *   second_value,
+ *   enumEnd_
+ * };
+ * for(auto enumvalue : WholeEnum<EnumType>()) {
+ *   do_stuff();
+ * }
+ * \endcode
+ */
+template <typename EnumType>
+class WholeEnum : public EnumRangeT<EnumType>
+{
+public:
+    WholeEnum() : EnumRangeT<EnumType>(EnumType::enumBegin_, EnumType::enumEnd_) {}
+};
+
+#endif /* SQUID_BASE_ENUMITERATOR_H */
+

=== modified file 'src/base/Makefile.am'
--- src/base/Makefile.am	2015-08-03 02:08:22 +0000
+++ src/base/Makefile.am	2015-08-27 09:43:55 +0000
@@ -1,38 +1,39 @@
 ## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
 ##
 ## Squid software is distributed under GPLv2+ license and includes
 ## contributions from numerous individuals and organizations.
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
 noinst_LTLIBRARIES = libbase.la
 
 libbase_la_SOURCES = \
 	AsyncCall.cc \
 	AsyncCall.h \
 	AsyncCbdataCalls.h \
 	AsyncJob.h \
 	AsyncJob.cc \
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
 	CbcPointer.h \
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
+	EnumIterator.h \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
 	LruMap.h \
 	Packable.h \
 	RegexPattern.cc \
 	RegexPattern.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
 	TidyPointer.h

=== modified file 'src/icp_opcode.h'
--- src/icp_opcode.h	2015-01-13 07:25:36 +0000
+++ src/icp_opcode.h	2015-08-27 09:43:55 +0000
@@ -1,44 +1,46 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_ICP_OPCODE_H
 #define _SQUID_ICP_OPCODE_H
 
 /// \ingroup ServerProtocolICPAPI
-typedef enum {
-    ICP_INVALID,
+enum icp_opcode {
+    enumBegin_ = 0,
+    ICP_INVALID = enumBegin_,
     ICP_QUERY,
     ICP_HIT,
     ICP_MISS,
     ICP_ERR,
     ICP_SEND,
     ICP_SENDA,
     ICP_DATABEG,
     ICP_DATA,
     ICP_DATAEND,
     ICP_SECHO,
     ICP_DECHO,
     ICP_NOTIFY,
     ICP_INVALIDATE,
     ICP_DELETE,
     ICP_UNUSED15,
     ICP_UNUSED16,
     ICP_UNUSED17,
     ICP_UNUSED18,
     ICP_UNUSED19,
     ICP_UNUSED20,
     ICP_MISS_NOFETCH,
     ICP_DENIED,
     ICP_HIT_OBJ,
-    ICP_END
-} icp_opcode;
+    ICP_END,
+    enumEnd_ = ICP_END
+};
 
 extern const char *icp_opcode_str[];
 
 #endif /* _SQUID_ICP_OPCODE_H */
 

=== modified file 'src/icp_v2.cc'
--- src/icp_v2.cc	2015-06-11 05:02:13 +0000
+++ src/icp_v2.cc	2015-08-27 09:43:55 +0000
@@ -74,64 +74,64 @@ Comm::ConnectionPointer icpIncomingConn
 Comm::ConnectionPointer icpOutgoingConn = NULL;
 
 /* icp_common_t */
 _icp_common_t::_icp_common_t() :
     opcode(ICP_INVALID), version(0), length(0), reqnum(0),
     flags(0), pad(0), shostid(0)
 {}
 
 _icp_common_t::_icp_common_t(char *buf, unsigned int len) :
     opcode(ICP_INVALID), version(0), reqnum(0), flags(0), pad(0), shostid(0)
 {
     if (len < sizeof(_icp_common_t)) {
         /* mark as invalid */
         length = len + 1;
         return;
     }
 
     memcpy(this, buf, sizeof(icp_common_t));
     /*
      * Convert network order sensitive fields
      */
     length = ntohs(length);
     reqnum = ntohl(reqnum);
     flags = ntohl(flags);
     pad = ntohl(pad);
 }
 
 icp_opcode
 _icp_common_t::getOpCode() const
 {
-    if (opcode > (char)ICP_END)
+    if (opcode > static_cast<char>(icp_opcode::ICP_END))
         return ICP_INVALID;
 
-    return (icp_opcode)opcode;
+    return static_cast<icp_opcode>(opcode);
 }
 
 /* ICPState */
 
 ICPState::ICPState(icp_common_t &aHeader, HttpRequest *aRequest):
     header(aHeader),
     request(aRequest),
     fd(-1),
     url(NULL)
 {
     HTTPMSGLOCK(request);
 }
 
 ICPState::~ICPState()
 {
     safe_free(url);
     HTTPMSGUNLOCK(request);
 }
 
 /* End ICPState */
 
 /* ICP2State */
 
 /// \ingroup ServerProtocolICPInternal2
 class ICP2State : public ICPState, public StoreClient
 {
 
 public:
     ICP2State(icp_common_t & aHeader, HttpRequest *aRequest):
         ICPState(aHeader, aRequest),rtt(0),src_rtt(0),flags(0) {}

=== modified file 'src/mk-string-arrays.awk'
--- src/mk-string-arrays.awk	2015-08-25 14:10:22 +0000
+++ src/mk-string-arrays.awk	2015-08-27 09:43:55 +0000
@@ -7,69 +7,86 @@
 
 # tested with gawk, mawk, and nawk.
 # creates "enum.c" (on stdout) from "enum.h".
 # when invoked:  awk -f mk-string-arrays.awk enum.h
 #
 # 2006 by Christopher Kerr.
 #
 # 2009 modified by Amos Jeffries
 #   Adapted to convert individual enum headers
 #
 
 BEGIN {
 	print "/*"
 	print " * Auto-Generated File. Changes will be destroyed."
 	print " */"
 	print "#include \"squid.h\""
         codeSkip = 1
         e = 0
         nspath = ""
 }
 
 # when namespace is encountered store it
 /^namespace *[a-zA-Z]+/	{
 	nspath = tolower($2) "/"		# nested folder
 	namespace = $2				# code namespace reconstruct
 	next
 }
 
 # Skip all lines outside of typedef {}
 /^typedef/		{ codeSkip = 0; next }
+/^enum class / {
+  codeSkip = 0
+  type = $3
+  next;
+}
+/^enum / {
+  codeSkip = 0
+  type = $2
+  next;
+}
 codeSkip == 1		{ next }
 
 /^[ \t]*[A-Z]/ {
 	split($1, t, ",")			# remove ,
 	if (sbuf) Element[++e] = "SBuf(\"" t[1] "\")"
 	else Element[++e] = "\"" t[1] "\""
 	next
 }
 
 /^#/ {
 	if (codeSkip) next
 
 	Wrapper[++e] = $0
 	next
 }
 
+/};/ {
+  codeSkip = 1;
+}
+
 /^} / {
 	split($2, t, ";")			# remove ;
-	type = t[1]
-        codeSkip = 1
+  if (!type)
+    type = t[1]
+  codeSkip = 1
+  next
+}
 
+END {
 	if (sbuf) print "#include \"SBuf.h\""
 	print "#include \"" nspath type ".h\""
 
 	# if namesapce is not empty ??
 	if (namespace) print "namespace " namespace
 	if (namespace) print "{"
 
 	if (sbuf) print "\nconst SBuf " type "_sb[] = {"
 	else print "\nconst char * " type "_str[] = {"
 	for ( i = 1; i < e; ++i)
 		if (Wrapper[i]) print Wrapper[i]
 		else print "\t" Element[i] ","
 
 	print "\t" Element[i]
 	print "};"
 	if (namespace) print "}; // namespace " namespace
-	next
 }

=== modified file 'src/neighbors.cc'
--- src/neighbors.cc	2015-07-17 09:30:47 +0000
+++ src/neighbors.cc	2015-08-27 09:43:55 +0000
@@ -1,43 +1,44 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 15    Neighbor Routines */
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "anyp/PortCfg.h"
+#include "base/EnumIterator.h"
 #include "CacheDigest.h"
 #include "CachePeer.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
 #include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "ICP.h"
 #include "int.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
 #include "ipcache.h"
 #include "MemObject.h"
 #include "mgr/Registration.h"
 #include "multicast.h"
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
 #include "pconn.h"
 #include "PeerDigest.h"
 #include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "stat.h"
 #include "Store.h"
@@ -1545,61 +1546,60 @@ dump_peer_options(StoreEntry * sentry, C
 
     if (p->options.no_tproxy)
         storeAppendPrintf(sentry, " no-tproxy");
 
     if (p->max_conn > 0)
         storeAppendPrintf(sentry, " max-conn=%d", p->max_conn);
     if (p->standby.limit > 0)
         storeAppendPrintf(sentry, " standby=%d", p->standby.limit);
 
     if (p->options.originserver)
         storeAppendPrintf(sentry, " originserver");
 
     if (p->domain)
         storeAppendPrintf(sentry, " forceddomain=%s", p->domain);
 
     if (p->connection_auth == 0)
         storeAppendPrintf(sentry, " connection-auth=off");
     else if (p->connection_auth == 1)
         storeAppendPrintf(sentry, " connection-auth=on");
     else if (p->connection_auth == 2)
         storeAppendPrintf(sentry, " connection-auth=auto");
 
     p->secure.dumpCfg(sentry,"tls-");
     storeAppendPrintf(sentry, "\n");
 }
 
 static void
 dump_peers(StoreEntry * sentry, CachePeer * peers)
 {
     char ntoabuf[MAX_IPSTRLEN];
-    icp_opcode op;
     int i;
 
     if (peers == NULL)
         storeAppendPrintf(sentry, "There are no neighbors installed.\n");
 
     for (CachePeer *e = peers; e; e = e->next) {
         assert(e->host != NULL);
         storeAppendPrintf(sentry, "\n%-11.11s: %s\n",
                           neighborTypeStr(e),
                           e->name);
         storeAppendPrintf(sentry, "Host       : %s/%d/%d\n",
                           e->host,
                           e->http_port,
                           e->icp.port);
         storeAppendPrintf(sentry, "Flags      :");
         dump_peer_options(sentry, e);
 
         for (i = 0; i < e->n_addresses; ++i) {
             storeAppendPrintf(sentry, "Address[%d] : %s\n", i,
                               e->addresses[i].toStr(ntoabuf,MAX_IPSTRLEN) );
         }
 
         storeAppendPrintf(sentry, "Status     : %s\n",
                           neighborUp(e) ? "Up" : "Down");
         storeAppendPrintf(sentry, "FETCHES    : %d\n", e->stats.fetches);
         storeAppendPrintf(sentry, "OPEN CONNS : %d\n", e->stats.conn_open);
         storeAppendPrintf(sentry, "AVG RTT    : %d msec\n", e->stats.rtt);
 
         if (!e->options.no_query) {
             storeAppendPrintf(sentry, "LAST QUERY : %8d seconds ago\n",
@@ -1607,61 +1607,61 @@ dump_peers(StoreEntry * sentry, CachePee
 
             if (e->stats.last_reply > 0)
                 storeAppendPrintf(sentry, "LAST REPLY : %8d seconds ago\n",
                                   (int) (squid_curtime - e->stats.last_reply));
             else
                 storeAppendPrintf(sentry, "LAST REPLY : none received\n");
 
             storeAppendPrintf(sentry, "PINGS SENT : %8d\n", e->stats.pings_sent);
 
             storeAppendPrintf(sentry, "PINGS ACKED: %8d %3d%%\n",
                               e->stats.pings_acked,
                               Math::intPercent(e->stats.pings_acked, e->stats.pings_sent));
         }
 
         storeAppendPrintf(sentry, "IGNORED    : %8d %3d%%\n", e->stats.ignored_replies, Math::intPercent(e->stats.ignored_replies, e->stats.pings_acked));
 
         if (!e->options.no_query) {
             storeAppendPrintf(sentry, "Histogram of PINGS ACKED:\n");
 #if USE_HTCP
 
             if (e->options.htcp) {
                 storeAppendPrintf(sentry, "\tMisses\t%8d %3d%%\n",
                                   e->htcp.counts[0],
                                   Math::intPercent(e->htcp.counts[0], e->stats.pings_acked));
                 storeAppendPrintf(sentry, "\tHits\t%8d %3d%%\n",
                                   e->htcp.counts[1],
                                   Math::intPercent(e->htcp.counts[1], e->stats.pings_acked));
             } else {
 #endif
 
-                for (op = ICP_INVALID; op < ICP_END; ++op) {
+                for (icp_opcode op : WholeEnum<icp_opcode>()) {
                     if (e->icp.counts[op] == 0)
                         continue;
 
                     storeAppendPrintf(sentry, "    %12.12s : %8d %3d%%\n",
                                       icp_opcode_str[op],
                                       e->icp.counts[op],
                                       Math::intPercent(e->icp.counts[op], e->stats.pings_acked));
                 }
 
 #if USE_HTCP
 
             }
 
 #endif
 
         }
 
         if (e->stats.last_connect_failure) {
             storeAppendPrintf(sentry, "Last failed connect() at: %s\n",
                               Time::FormatHttpd(e->stats.last_connect_failure));
         }
 
         storeAppendPrintf(sentry, "keep-alive ratio: %d%%\n", Math::intPercent(e->stats.n_keepalives_recv, e->stats.n_keepalives_sent));
     }
 }
 
 #if USE_HTCP
 void
 neighborsHtcpReply(const cache_key * key, HtcpReplyData * htcp, const Ip::Address &from)
 {

=== added file 'src/tests/testEnumIterator.cc'
--- src/tests/testEnumIterator.cc	1970-01-01 00:00:00 +0000
+++ src/tests/testEnumIterator.cc	2015-08-27 09:43:55 +0000
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "tests/testEnumIterator.h"
+#include "unitTestMain.h"
+
+#include <cppunit/TestAssert.h>
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testEnumIterator );
+
+enum class TestEnum {
+    enumBegin_ = 0,
+    zero = enumBegin_,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+enum class UnsignedTestEnum : unsigned char {
+    enumBegin_ = 0,
+    zero = enumBegin_,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+void
+testEnumIterator::testForwardIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().end());
+}
+
+void
+testEnumIterator::testReverseIter()
+{
+    WholeEnum<TestEnum>::reverse_iterator i = WholeEnum<TestEnum>().rbegin();
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().rend());
+}
+
+void
+testEnumIterator::testBidirectionalIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    --i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+
+    auto enumBegin=WholeEnum<TestEnum>().begin();
+    auto enumEnd=WholeEnum<TestEnum>().end();
+    i=enumBegin;
+    int count=0;
+    while (i != enumEnd) {
+        ++i;
+        ++count;
+        if (count > 20) // prevent infinite loops in test
+            break;
+    }
+    while (i != enumBegin) {
+        --i;
+        ++count;
+        if (count > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(10, count);
+
+    --i; //intentional out-of-bounds
+    CPPUNIT_ASSERT(i != enumBegin);
+    CPPUNIT_ASSERT(*i != TestEnum::zero);
+}
+
+void
+testEnumIterator::testRangeFor()
+{
+    int j = 0;
+    for (auto e : WholeEnum<TestEnum>()) {
+        (void)e;
+        ++j;
+        if (j > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+
+void
+testEnumIterator::testRangeForRange()
+{
+    int j = 0;
+    // free function-based range
+    for (auto e : EnumRange(TestEnum::two, TestEnum::four)) {
+        (void)e;
+        ++j;
+        if (j > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(2,j);
+}
+
+void
+testEnumIterator::testUnsignedEnum()
+{
+    int j = 0;
+    for (auto e = WholeEnum<TestEnum>().rbegin(); e != WholeEnum<TestEnum>().rend(); ++e ) {
+        (void)e;
+        ++j;
+        if (j > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+

=== added file 'src/tests/testEnumIterator.h'
--- src/tests/testEnumIterator.h	1970-01-01 00:00:00 +0000
+++ src/tests/testEnumIterator.h	2015-08-27 09:43:55 +0000
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_TESTENUMITERATOR_H_
+#define SQUID_TESTENUMITERATOR_H_
+
+#include "base/EnumIterator.h"
+
+#include <cppunit/extensions/HelperMacros.h>
+
+class testEnumIterator : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testEnumIterator );
+    CPPUNIT_TEST( testForwardIter );
+    CPPUNIT_TEST( testReverseIter );
+    CPPUNIT_TEST( testBidirectionalIter );
+    CPPUNIT_TEST( testRangeFor );
+    CPPUNIT_TEST( testRangeForRange );
+    CPPUNIT_TEST( testUnsignedEnum );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    void testForwardIter();
+    void testReverseIter();
+    void testBidirectionalIter();
+    void testRangeFor();
+    void testRangeForRange();
+    void testUnsignedEnum();
+};
+
+#endif /* SQUID_TESTENUMITERATOR_H_ */
+

