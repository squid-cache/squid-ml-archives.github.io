=== modified file 'include/hash.h'
--- include/hash.h	2015-01-13 07:25:36 +0000
+++ include/hash.h	2015-08-27 13:49:35 +0000
@@ -1,53 +1,54 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HASH_H
 #define SQUID_HASH_H
 
 typedef void HASHFREE(void *);
 typedef int HASHCMP(const void *, const void *);
 typedef unsigned int HASHHASH(const void *, unsigned int);
-typedef struct _hash_link hash_link;
-typedef struct _hash_table hash_table;
 
-struct _hash_link {
+class hash_link {
+public:
+    hash_link() : key(nullptr), next(nullptr) {}
     void *key;
     hash_link *next;
 };
 
-struct _hash_table {
+class hash_table {
+public:
     hash_link **buckets;
     HASHCMP *cmp;
     HASHHASH *hash;
     unsigned int size;
     unsigned int current_slot;
     hash_link *next;
     int count;
 };
 
 SQUIDCEXTERN hash_table *hash_create(HASHCMP *, int, HASHHASH *);
 SQUIDCEXTERN void hash_join(hash_table *, hash_link *);
 SQUIDCEXTERN void hash_remove_link(hash_table *, hash_link *);
 SQUIDCEXTERN int hashPrime(int n);
 SQUIDCEXTERN hash_link *hash_lookup(hash_table *, const void *);
 SQUIDCEXTERN void hash_first(hash_table *);
 SQUIDCEXTERN hash_link *hash_next(hash_table *);
 SQUIDCEXTERN void hash_last(hash_table *);
 SQUIDCEXTERN hash_link *hash_get_bucket(hash_table *, unsigned int);
 SQUIDCEXTERN void hashFreeMemory(hash_table *);
 SQUIDCEXTERN void hashFreeItems(hash_table *, HASHFREE *);
 SQUIDCEXTERN HASHHASH hash_string;
 SQUIDCEXTERN HASHHASH hash4;
 SQUIDCEXTERN const char *hashKeyStr(hash_link *);
 
 /*
  *  Here are some good prime number choices.  It's important not to
  *  choose a prime number that is too close to exact powers of 2.
  *
  *  HASH_SIZE 103               // prime number < 128
  *  HASH_SIZE 229               // prime number < 256

=== modified file 'src/Store.h'
--- src/Store.h	2015-08-24 21:07:31 +0000
+++ src/Store.h	2015-08-27 13:50:13 +0000
@@ -16,60 +16,61 @@
 #include "hash.h"
 #include "http/forward.h"
 #include "http/RequestMethod.h"
 #include "HttpReply.h"
 #include "MemObject.h"
 #include "Range.h"
 #include "RemovalPolicy.h"
 #include "StoreIOBuffer.h"
 #include "StoreStats.h"
 
 #if USE_SQUID_ESI
 #include "esi/Element.h"
 #endif
 
 #include <ostream>
 
 class AsyncCall;
 class HttpRequest;
 class RequestFlags;
 class StoreClient;
 class StoreSearch;
 class SwapDir;
 
 extern StoreIoStats store_io_stats;
 
 /// maximum number of entries per cache_dir
 enum { SwapFilenMax = 0xFFFFFF }; // keep in sync with StoreEntry::swap_filen
 
 class StoreEntry : public hash_link, public Packable
 {
+    MEMPROXY_CLASS(StoreEntry);
 
 public:
     static DeferredRead::DeferrableRead DeferReader;
     bool checkDeferRead(int fd) const;
 
     virtual const char *getMD5Text() const;
     StoreEntry();
     virtual ~StoreEntry();
 
     virtual HttpReply const *getReply() const;
     virtual void write (StoreIOBuffer);
 
     /** Check if the Store entry is emtpty
      * \retval true   Store contains 0 bytes of data.
      * \retval false  Store contains 1 or more bytes of data.
      * \retval false  Store contains negative content !!!!!!
      */
     virtual bool isEmpty() const {
         assert (mem_obj);
         return mem_obj->endOffset() == 0;
     }
     virtual bool isAccepting() const;
     virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const;
     /// flags [truncated or too big] entry with ENTRY_BAD_LENGTH and releases it
     void lengthWentBad(const char *reason);
     virtual void complete();
     virtual store_client_t storeClientType() const;
     virtual char const *getSerialisedMetaData();
     /// Store a prepared error response. MemObject locks the reply object.
     void storeErrorResponse(HttpReply *reply);
@@ -150,62 +151,60 @@ public:
     time_t expires;
     time_t lastmod;
     uint64_t swap_file_sz;
     uint16_t refcount;
     uint16_t flags;
     /* END OF ON-DISK STORE_META_STD */
 
     /// unique ID inside a cache_dir for swapped out entries; -1 for others
     sfileno swap_filen:25; // keep in sync with SwapFilenMax
 
     sdirno swap_dirn:7;
 
     mem_status_t mem_status:3;
 
     ping_status_t ping_status:3;
 
     store_status_t store_status:3;
 
     swap_status_t swap_status:3;
 
 public:
     static size_t inUseCount();
     static void getPublicByRequestMethod(StoreClient * aClient, HttpRequest * request, const HttpRequestMethod& method);
     static void getPublicByRequest(StoreClient * aClient, HttpRequest * request);
     static void getPublic(StoreClient * aClient, const char *uri, const HttpRequestMethod& method);
 
     virtual bool isNull() {
         return false;
     };
 
-    void *operator new(size_t byteCount);
-    void operator delete(void *address);
     void setReleaseFlag();
 #if USE_SQUID_ESI
 
     ESIElement::Pointer cachedESITree;
 #endif
     /** disable sending content to the clients */
     virtual void buffer();
     /** flush any buffered content */
     virtual void flush();
     virtual int64_t objectLen() const;
     virtual int64_t contentLen() const;
 
     /// claim shared ownership of this entry (for use in a given context)
     /// matching lock() and unlock() contexts eases leak triage but is optional
     void lock(const char *context);
 
     /// disclaim shared ownership; may remove entry from store and delete it
     /// returns remaning lock level (zero for unlocked and possibly gone entry)
     int unlock(const char *context);
 
     /// returns a local concurrent use counter, for debugging
     int locks() const { return static_cast<int>(lock_count); }
 
     /// update last reference timestamp and related Store metadata
     void touch();
 
     virtual void release();
 
 #if USE_ADAPTATION
     /// call back producer when more buffer space is available

=== modified file 'src/store.cc'
--- src/store.cc	2015-08-24 21:07:31 +0000
+++ src/store.cc	2015-08-27 13:50:13 +0000
@@ -122,79 +122,60 @@ void
 Store::Root(StorePointer aRoot)
 {
     Root(aRoot.getRaw());
 }
 
 void
 Store::Stats(StoreEntry * output)
 {
     assert(output);
     Root().stat(*output);
 }
 
 void
 Store::create()
 {}
 
 void
 Store::diskFull()
 {}
 
 void
 Store::sync()
 {}
 
 void
 Store::unlink(StoreEntry &)
 {
     fatal("Store::unlink on invalid Store\n");
 }
 
-void *
-StoreEntry::operator new (size_t bytecount)
-{
-    assert(bytecount == sizeof (StoreEntry));
-
-    if (!pool) {
-        pool = memPoolCreate ("StoreEntry", bytecount);
-        pool->setChunkSize(2048 * 1024);
-    }
-
-    return pool->alloc();
-}
-
-void
-StoreEntry::operator delete (void *address)
-{
-    pool->freeOne(address);
-}
-
 void
 StoreEntry::makePublic()
 {
     /* This object can be cached for a long time */
 
     if (!EBIT_TEST(flags, RELEASE_REQUEST))
         setPublicKey();
 }
 
 void
 StoreEntry::makePrivate()
 {
     /* This object should never be cached at all */
     expireNow();
     releaseRequest(); /* delete object when not used */
 }
 
 void
 StoreEntry::cacheNegatively()
 {
     /* This object may be negatively cached */
     negativeCache();
     makePublic();
 }
 
 size_t
 StoreEntry::inUseCount()
 {
     if (!pool)
         return 0;
@@ -331,61 +312,61 @@ StoreEntry::storeClientType() const
                 return STORE_MEM_CLIENT;
             }
         }
         return STORE_DISK_CLIENT;
     }
 
     /* here and past, entry is STORE_PENDING */
     /*
      * If this is the first client, let it be the mem client
      */
     if (mem_obj->nclients == 1)
         return STORE_MEM_CLIENT;
 
     /*
      * If there is no disk file to open yet, we must make this a
      * mem client.  If we can't open the swapin file before writing
      * to the client, there is no guarantee that we will be able
      * to open it later when we really need it.
      */
     if (swap_status == SWAPOUT_NONE)
         return STORE_MEM_CLIENT;
 
     /*
      * otherwise, make subsequent clients read from disk so they
      * can not delay the first, and vice-versa.
      */
     return STORE_DISK_CLIENT;
 }
 
 StoreEntry::StoreEntry() :
-    mem_obj(NULL),
+    mem_obj(nullptr),
     timestamp(-1),
     lastref(-1),
     expires(-1),
     lastmod(-1),
     swap_file_sz(0),
     refcount(0),
     flags(0),
     swap_filen(-1),
     swap_dirn(-1),
     mem_status(NOT_IN_MEMORY),
     ping_status(PING_NONE),
     store_status(STORE_PENDING),
     swap_status(SWAPOUT_NONE),
     lock_count(0)
 {
     debugs(20, 5, "StoreEntry constructed, this=" << this);
 }
 
 StoreEntry::~StoreEntry()
 {
     debugs(20, 5, "StoreEntry destructed, this=" << this);
 }
 
 #if USE_ADAPTATION
 void
 StoreEntry::deferProducer(const AsyncCall::Pointer &producer)
 {
     if (!deferredProducer)
         deferredProducer = producer;
     else

=== modified file 'src/tests/stub_store.cc'
--- src/tests/stub_store.cc	2015-05-26 09:18:13 +0000
+++ src/tests/stub_store.cc	2015-08-27 14:06:43 +0000
@@ -54,66 +54,60 @@ void StoreEntry::purgeMem() STUB
 void StoreEntry::swapOut() STUB
 void StoreEntry::swapOutFileClose(int how) STUB
 const char *StoreEntry::url() const STUB_RETVAL(NULL)
 bool StoreEntry::checkCachable() STUB_RETVAL(false)
 int StoreEntry::checkNegativeHit() const STUB_RETVAL(0)
 int StoreEntry::locked() const STUB_RETVAL(0)
 int StoreEntry::validToSend() const STUB_RETVAL(0)
 bool StoreEntry::memoryCachable() STUB_RETVAL(false)
 MemObject *StoreEntry::makeMemObject() STUB_RETVAL(NULL)
 void StoreEntry::createMemObject(const char *, const char *, const HttpRequestMethod &aMethod) STUB
 void StoreEntry::dump(int debug_lvl) const STUB
 void StoreEntry::hashDelete() STUB
 void StoreEntry::hashInsert(const cache_key *) STUB
 void StoreEntry::registerAbort(STABH * cb, void *) STUB
 void StoreEntry::reset() STUB
 void StoreEntry::setMemStatus(mem_status_t) STUB
 void StoreEntry::timestampsSet() STUB
 void StoreEntry::unregisterAbort() STUB
 void StoreEntry::destroyMemObject() STUB
 int StoreEntry::checkTooSmall() STUB_RETVAL(0)
 void StoreEntry::delayAwareRead(const Comm::ConnectionPointer&, char *buf, int len, AsyncCall::Pointer callback) STUB
 void StoreEntry::setNoDelay (bool const) STUB
 bool StoreEntry::modifiedSince(HttpRequest * request) const STUB_RETVAL(false)
 bool StoreEntry::hasIfMatchEtag(const HttpRequest &request) const STUB_RETVAL(false)
 bool StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const STUB_RETVAL(false)
 RefCount<SwapDir> StoreEntry::store() const STUB_RETVAL(NULL)
 size_t StoreEntry::inUseCount() STUB_RETVAL(0)
 void StoreEntry::getPublicByRequestMethod(StoreClient * aClient, HttpRequest * request, const HttpRequestMethod& method) STUB
 void StoreEntry::getPublicByRequest(StoreClient * aClient, HttpRequest * request) STUB
 void StoreEntry::getPublic(StoreClient * aClient, const char *uri, const HttpRequestMethod& method) STUB
-void *StoreEntry::operator new(size_t byteCount)
-{
-    STUB
-    return new StoreEntry();
-}
-void StoreEntry::operator delete(void *address) STUB
 void StoreEntry::setReleaseFlag() STUB
 //#if USE_SQUID_ESI
 //ESIElement::Pointer StoreEntry::cachedESITree STUB_RETVAL(NULL)
 //#endif
 void StoreEntry::buffer() STUB
 void StoreEntry::flush() STUB
 int StoreEntry::unlock(const char *) STUB_RETVAL(0)
 int64_t StoreEntry::objectLen() const STUB_RETVAL(0)
 int64_t StoreEntry::contentLen() const STUB_RETVAL(0)
 void StoreEntry::lock(const char *) STUB
 void StoreEntry::touch() STUB
 void StoreEntry::release() STUB
 void StoreEntry::append(char const *, int) STUB
 void StoreEntry::vappendf(const char *, va_list) STUB
 
 NullStoreEntry *NullStoreEntry::getInstance() STUB_RETVAL(NULL)
 const char *NullStoreEntry::getMD5Text() const STUB_RETVAL(NULL)
 void NullStoreEntry::operator delete(void *address) STUB
 // private virtual. Why is this linked from outside?
 const char *NullStoreEntry::getSerialisedMetaData() STUB_RETVAL(NULL)
 
 void Store::Root(Store *) STUB
 void Store::Root(RefCount<Store>) STUB
 void Store::Stats(StoreEntry * output) STUB
 void Store::Maintain(void *unused) STUB
 void Store::create() STUB
 void Store::diskFull() STUB
 void Store::sync() STUB
 void Store::unlink(StoreEntry &) STUB
 

