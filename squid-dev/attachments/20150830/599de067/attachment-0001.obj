=== modified file 'src/CacheDigest.h'
--- src/CacheDigest.h	2015-01-13 07:25:36 +0000
+++ src/CacheDigest.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 70    Cache Digest */
 
 #ifndef SQUID_CACHEDIGEST_H_
 #define SQUID_CACHEDIGEST_H_
 
 /* for cache_key */
-#include "typedefs.h"
+#include "store_key_md5.h"
 
 class CacheDigestGuessStats;
 class StoreEntry;
 
 // currently a POD
 class CacheDigest
 {
 public:
     /* public, read-only */
     char *mask;         /* bit mask */
     int mask_size;      /* mask size in bytes */
     int capacity;       /* expected maximum for .count, not a hard limit */
     int bits_per_entry;     /* number of bits allocated for each entry from capacity */
     int count;          /* number of digested entries */
     int del_count;      /* number of deletions performed so far */
 };
 
 CacheDigest *cacheDigestCreate(int capacity, int bpe);
 void cacheDigestDestroy(CacheDigest * cd);
 CacheDigest *cacheDigestClone(const CacheDigest * cd);
 void cacheDigestClear(CacheDigest * cd);
 void cacheDigestChangeCap(CacheDigest * cd, int new_cap);
 int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
 void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
 void cacheDigestDel(CacheDigest * cd, const cache_key * key);
 size_t cacheDigestCalcMaskSize(int cap, int bpe);
 int cacheDigestBitUtil(const CacheDigest * cd);
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
 void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);

=== modified file 'src/ClientInfo.h'
--- src/ClientInfo.h	2015-08-30 00:26:47 +0000
+++ src/ClientInfo.h	2015-08-30 02:06:07 +0000
@@ -1,48 +1,48 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID__SRC_CLIENTINFO_H
 #define SQUID__SRC_CLIENTINFO_H
 
 #include "base/ByteCounter.h"
 #include "cbdata.h"
 #include "enums.h"
 #include "hash.h"
 #include "ip/Address.h"
 #include "LogTags.h"
-#include "typedefs.h"
+#include "typedefs.h" //for kb_t
 
 #include <deque>
 
 #if USE_DELAY_POOLS
 class CommQuotaQueue;
 #endif
 
 class ClientInfo
 {
 public:
     hash_link hash;             /* must be first */
 
     Ip::Address addr;
 
     struct {
         int result_hist[LOG_TYPE_MAX];
         int n_requests;
         ByteCounter kbytes_in;
         ByteCounter kbytes_out;
         ByteCounter hit_kbytes_out;
     } Http, Icp;
 
     struct {
         time_t time;
         int n_req;
         int n_denied;
     } cutoff;
     int n_established;          /* number of current established connections */
     time_t last_seen;
 #if USE_DELAY_POOLS

=== modified file 'src/CollapsedForwarding.h'
--- src/CollapsedForwarding.h	2015-05-23 20:17:16 +0000
+++ src/CollapsedForwarding.h	2015-08-29 20:12:55 +0000
@@ -1,46 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 17    Request Forwarding */
 
 #ifndef SQUID_COLLAPSED_FORWARDING_H
 #define SQUID_COLLAPSED_FORWARDING_H
 
 #include "ipc/forward.h"
 #include "ipc/Queue.h"
-#include "typedefs.h"
 
 #include <memory>
 
 class StoreEntry;
 
 /// Sends and handles collapsed forwarding notifications.
 class CollapsedForwarding
 {
 public:
     /// open shared memory segment
     static void Init();
 
     /// notify other workers about changes in entry state (e.g., new data)
     static void Broadcast(const StoreEntry &e);
 
     /// kick worker with empty IPC queue
     static void Notify(const int workerId);
 
     /// handle new data messages in IPC queue
     static void HandleNewData(const char *const when);
 
     /// handle queue push notifications from worker or disker
     static void HandleNotification(const Ipc::TypedMsgHdr &msg);
 
 private:
     typedef Ipc::MultiQueue Queue;
     static std::unique_ptr<Queue> queue; ///< IPC queue
 };
 
 #endif /* SQUID_COLLAPSED_FORWARDING_H */

=== modified file 'src/DiskIO/AIO/async_io.h'
--- src/DiskIO/AIO/async_io.h	2015-07-21 13:56:20 +0000
+++ src/DiskIO/AIO/async_io.h	2015-08-29 20:12:55 +0000
@@ -1,53 +1,52 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef __ASYNC_IO_H__
 #define __ASYNC_IO_H__
 
 #if HAVE_DISKIO_MODULE_AIO
 
 #if _SQUID_WINDOWS_
 #include "DiskIO/AIO/aio_win32.h"
 #else
 #if HAVE_AIO_H
 #include <aio.h>
 #endif
 #endif
 
-/* for FREE* */
-#include "typedefs.h"
+#include "mem/forward.h"
 
 #define MAX_ASYNCOP     128
 
 typedef enum {
     AQ_STATE_NONE,      /* Not active/uninitialised */
     AQ_STATE_SETUP      /* Initialised */
 } async_queue_state_t;
 
 typedef enum {
     AQ_ENTRY_FREE,
     AQ_ENTRY_USED
 } async_queue_entry_state_t;
 
 typedef enum {
     AQ_ENTRY_NONE,
     AQ_ENTRY_READ,
     AQ_ENTRY_WRITE
 } async_queue_entry_type_t;
 
 typedef struct _async_queue_entry async_queue_entry_t;
 
 typedef struct _async_queue async_queue_t;
 
 /* An async queue entry */
 
 class AIODiskFile;
 
 struct _async_queue_entry {
     async_queue_entry_state_t aq_e_state;
     async_queue_entry_type_t aq_e_type;

=== modified file 'src/DiskIO/Blocking/BlockingFile.h'
--- src/DiskIO/Blocking/BlockingFile.h	2015-01-13 07:25:36 +0000
+++ src/DiskIO/Blocking/BlockingFile.h	2015-08-29 20:12:55 +0000
@@ -1,46 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 47    Store Directory Routines */
 
 #ifndef SQUID_BLOCKINGFILE_H
 #define SQUID_BLOCKINGFILE_H
 
 #include "cbdata.h"
 #include "DiskIO/DiskFile.h"
 #include "DiskIO/IORequestor.h"
+#include "typedefs.h" //DRCB, DWCB
 
 class BlockingFile : public DiskFile
 {
     CBDATA_CLASS(BlockingFile);
 
 public:
     BlockingFile(char const *path);
     ~BlockingFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void create(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void read(ReadRequest *);
     virtual void write(WriteRequest *);
     virtual void close();
     virtual bool error() const;
     virtual int getFD() const { return fd;}
 
     virtual bool canRead() const;
     virtual bool ioInProgress() const;
 
 private:
     static DRCB ReadDone;
     static DWCB WriteDone;
     int fd;
     bool closed;
     void error (bool const &);
     bool error_;
     char const *path_;
     RefCount<IORequestor> ioRequestor;
     RefCount<ReadRequest> readRequest;
     RefCount<WriteRequest> writeRequest;

=== modified file 'src/DiskIO/DiskFile.h'
--- src/DiskIO/DiskFile.h	2015-01-13 07:25:36 +0000
+++ src/DiskIO/DiskFile.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_DISKFILE_H
 #define SQUID_DISKFILE_H
 
 #include "base/RefCount.h"
-#include "typedefs.h"
+#include "SquidTime.h"
 
 class IORequestor;
 
 class ReadRequest;
 
 class WriteRequest;
 
 class DiskFile : public RefCountable
 {
 
 public:
 
     /// generally useful configuration options supported by some children
     class Config
     {
     public:
         Config(): ioTimeout(0), ioRate(-1) {}
 
         /// canRead/Write should return false if expected I/O delay exceeds it
         time_msec_t ioTimeout; // not enforced if zero, which is the default
 
         /// shape I/O request stream to approach that many per second
         int ioRate; // not enforced if negative, which is the default
     };
 
     typedef RefCount<DiskFile> Pointer;
 
     /// notes supported configuration options; kids must call this first
     virtual void configure(const Config &) {}
 

=== modified file 'src/DiskIO/DiskThreads/DiskThreads.h'
--- src/DiskIO/DiskThreads/DiskThreads.h	2015-01-13 07:25:36 +0000
+++ src/DiskIO/DiskThreads/DiskThreads.h	2015-08-29 20:12:55 +0000
@@ -1,49 +1,49 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /*
  * DiskThreads.h
  *
  * Internal declarations for the DiskThreads routines
  */
 
 #ifndef __DISKTHREADS_H__
 #define __DISKTHREADS_H__
 
 #include "dlink.h"
-#include "typedefs.h"
+#include "mem/forward.h"
 
 /* this non-standard-conformant include is needed in order to have stat(2) and struct stat
    properly defined on some systems (e.g. OpenBSD 5.4) */
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
 #if AUFS_IO_THREADS
 #define NUMTHREADS AUFS_IO_THREADS
 #else
 #define NUMTHREADS (Config.cacheSwap.n_configured*16)
 #endif
 
 /* Queue limit where swapouts are deferred (load calculation) */
 #define MAGIC1 (NUMTHREADS*Config.cacheSwap.n_configured*5)
 /* Queue limit where swapins are deferred (open/create fails) */
 #define MAGIC2 (NUMTHREADS*Config.cacheSwap.n_configured*20)
 
 /* Which operations to run async */
 #define ASYNC_OPEN 1
 #define ASYNC_CLOSE 0
 #define ASYNC_CREATE 1
 #define ASYNC_WRITE 0
 #define ASYNC_READ 1
 
 enum _squidaio_request_type {
     _AIO_OP_NONE = 0,
     _AIO_OP_OPEN,
     _AIO_OP_READ,
     _AIO_OP_WRITE,

=== modified file 'src/DiskIO/DiskThreads/DiskThreadsDiskFile.h'
--- src/DiskIO/DiskThreads/DiskThreadsDiskFile.h	2015-01-13 07:25:36 +0000
+++ src/DiskIO/DiskThreads/DiskThreadsDiskFile.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,46 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 79    Disk IO Routines */
 
 #ifndef SQUID_DISKTHREADSDISKFILE_H
 #define SQUID_DISKTHREADSDISKFILE_H
 #include "cbdata.h"
 #include "DiskIO/DiskFile.h"
 #include "DiskThreads.h"
+#include "typedefs.h" //for DWCB
 
 class DiskThreadsDiskFile : public DiskFile
 {
     CBDATA_CLASS(DiskThreadsDiskFile);
 
 public:
     DiskThreadsDiskFile(char const *path, DiskThreadsIOStrategy *);
     ~DiskThreadsDiskFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void create(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void read(ReadRequest *);
     virtual void write(WriteRequest *);
     virtual void close();
     virtual bool error() const;
     virtual int getFD() const { return fd;}
 
     virtual bool canRead() const;
     virtual bool canWrite() const;
     virtual bool ioInProgress() const;
 
 private:
 #if ASYNC_READ
 
     static AIOCB ReadDone;
 #else
 
     static DRCB ReadDone;
 #endif
 #if ASYNC_WRITE
 

=== modified file 'src/DiskIO/WriteRequest.h'
--- src/DiskIO/WriteRequest.h	2015-01-13 07:25:36 +0000
+++ src/DiskIO/WriteRequest.h	2015-08-29 20:12:55 +0000
@@ -1,31 +1,32 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_WRITEREQUEST_H
 #define SQUID_WRITEREQUEST_H
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "mem/forward.h"
 
 class WriteRequest : public RefCountable
 {
     CBDATA_CLASS(WriteRequest);
 
 public:
     typedef RefCount<WriteRequest> Pointer;
     WriteRequest(char const *buf, off_t offset, size_t len, FREE *);
     virtual ~WriteRequest() {}
 
     char const *buf;
     off_t offset;
     size_t len;
     FREE *free_func;
 };
 
 #endif /* SQUID_WRITEREQUEST_H */
 

=== modified file 'src/FileMap.h'
--- src/FileMap.h	2015-01-13 07:25:36 +0000
+++ src/FileMap.h	2015-08-29 20:12:55 +0000
@@ -1,44 +1,44 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 08    Swap File Bitmap */
 
 #ifndef FILEMAP_H_
 #define FILEMAP_H_
 
-#include "typedefs.h"
+#include "fs/forward.h"
 
 /** A bitmap used for managing UFS StoreEntry "file numbers".
  *
  * Nth bit represents whether file number N is used.
  * The map automatically grows to hold up to 2^24 bits.
  * New bit is "off" or zero by default, representing unused fileno.
  * TODO: consider using std::bitset instead.
  */
 class FileMap
 {
 public:
     FileMap();
     ~FileMap();
 
     /** Set the num-th bit in the FileMap
      *
      * \warning FileMap's backing storage will be extended as needed to
      * hold the representation, but  if the bit is already set
      * it will break the file number accounting, so the caller must
      * ensure that setBit is only called if the bit is not already set,
      * by using testBit on it before.
      */
     bool setBit(sfileno num);
 
     /// Test whether the num-th bit in the FileMap is set
     bool testBit(sfileno num) const;
 
     /** Clear the num-th bit in the FileMap
      *
      * \warning that clearBit doesn't do any bounds checking, nor it

=== modified file 'src/HttpHeaderTools.h'
--- src/HttpHeaderTools.h	2015-08-04 19:57:07 +0000
+++ src/HttpHeaderTools.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,44 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPHEADERTOOLS_H
 #define SQUID_HTTPHEADERTOOLS_H
 
 #include "acl/forward.h"
 #include "format/Format.h"
 #include "HttpHeader.h"
-#include "typedefs.h"
 
 #include <functional>
 #include <list>
 #include <map>
 #include <string>
 #if HAVE_STRINGS_H
 #include <strings.h>
 #endif
 
 class HeaderWithAcl;
 class HttpHeader;
 class HttpRequest;
 class StoreEntry;
 class String;
 
 typedef std::list<HeaderWithAcl> HeaderWithAclList;
 
 // Currently a POD
 class headerMangler
 {
 public:
     acl_access *access_list;
     char *replacement;
 };
 
 /// A collection of headerMangler objects for a given message kind.
 class HeaderManglers
 {
 public:
     HeaderManglers();

=== modified file 'src/HttpMsg.h'
--- src/HttpMsg.h	2015-04-26 16:41:06 +0000
+++ src/HttpMsg.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,44 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTTPMSG_H
 #define SQUID_HTTPMSG_H
 
 #include "base/Lock.h"
 #include "BodyPipe.h"
+#include "enums.h"
 #include "http/forward.h"
 #include "http/ProtocolVersion.h"
 #include "http/StatusCode.h"
 #include "HttpHeader.h"
 
 /// common parts of HttpRequest and HttpReply
 class HttpMsg : public RefCountable
 {
 
 public:
     typedef RefCount<HttpMsg> Pointer;
 
     HttpMsg(http_hdr_owner_type owner);
     virtual ~HttpMsg();
 
     virtual void reset() = 0; // will have body when http*Clean()s are gone
 
     void packInto(Packable * p, bool full_uri) const;
 
     ///< produce a message copy, except for a few connection-specific settings
     virtual HttpMsg *clone() const = 0; ///< \todo rename: not a true copy?
 
     /// [re]sets Content-Length header and cached value
     void setContentLength(int64_t clen);
 
     /**
      * \retval true  the message sender asks to keep the connection open.
      * \retval false the message sender will close the connection.
      *
      * Factors other than the headers may result in connection closure.

=== modified file 'src/ICP.h'
--- src/ICP.h	2015-06-11 05:02:13 +0000
+++ src/ICP.h	2015-08-29 20:12:55 +0000
@@ -1,51 +1,52 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ICP_H
 #define SQUID_ICP_H
 
 /**
  \defgroup ServerProtocolICPAPI ICP
  \ingroup ServerProtocol
  */
 
 #include "comm/forward.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
 #include "LogTags.h"
 #include "StoreClient.h"
+#include "store_key_md5.h"
 
 class HttpRequest;
 
 /**
  \ingroup ServerProtocolICPAPI
  *
  * This struct is the wire-level header.
  * DO NOT add more move fields on pain of breakage.
  * DO NOT add virtual methods.
  */
 struct _icp_common_t {
     /** opcode */
     unsigned char opcode;
     /** version number */
     unsigned char version;
     /** total length (bytes) */
     unsigned short length;
     /** req number (req'd for UDP) */
     uint32_t reqnum;
     uint32_t flags;
     uint32_t pad;
     /** sender host id */
     uint32_t shostid;
 
 /// \todo I don't believe this header is included in non-c++ code anywhere
 ///     the struct should become a public POD class and kill these ifdef.
 #ifdef __cplusplus
 
     _icp_common_t();
     _icp_common_t(char *buf, unsigned int len);

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2015-08-25 15:04:22 +0000
+++ src/Makefile.am	2015-08-29 20:12:55 +0000
@@ -285,60 +285,61 @@
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	enums.h \
 	err_type.h \
 	err_detail_type.h \
 	errorpage.cc \
 	errorpage.h \
 	ETag.cc \
 	ETag.h \
 	event.cc \
 	event.h \
 	EventLoop.h \
 	EventLoop.cc \
 	external_acl.cc \
 	ExternalACL.h \
 	ExternalACLEntry.cc \
 	ExternalACLEntry.h \
 	FadingCounter.h \
 	FadingCounter.cc \
 	fatal.h \
 	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	fde.h \
 	FileMap.h \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	Generic.h \
 	globals.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	helper.h \
 	hier_code.h \
 	HierarchyLogEntry.h \
 	$(HTCPSOURCE) \
 	HttpStateFlags.h \
 	http.cc \
 	http.h \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrSc.h \
 	HttpHdrScTarget.cc \
 	HttpHdrScTarget.h \
 	HttpHdrContRange.cc \
 	HttpHdrContRange.h \
 	HttpHeaderStat.h \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
 	HttpHeaderRange.h \
@@ -1277,60 +1278,61 @@
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	tests/stub_ETag.cc \
 	event.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	hier_code.h \
 	helper.cc \
 	$(HTCPSOURCE) \
 	HttpStateFlags.h \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
@@ -1478,60 +1480,61 @@
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testCacheManager_LDFLAGS = $(LIBADD_DL)
 tests_testCacheManager_DEPENDENCIES = \
 	$(REPL_OBJS) \
 	$(SQUID_CPPUNIT_LA)
 
 tests_testDiskIO_SOURCES = \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	client_db.h \
 	ClientInfo.h \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	tests/stub_ETag.cc \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHdrRange.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	refresh.h \
@@ -1707,60 +1710,61 @@
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	tests/stub_ETag.cc \
 	event.cc \
 	EventLoop.h \
 	EventLoop.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	FadingCounter.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -1950,60 +1954,61 @@
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	tests/stub_ETag.cc \
 	EventLoop.h \
 	EventLoop.cc \
 	event.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	FadingCounter.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2188,60 +2193,61 @@
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	tests/stub_ETag.cc \
 	event.cc \
 	FadingCounter.cc \
 	fatal.h \
 	tests/stub_libauth.cc \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2512,60 +2518,61 @@
 	client_side.h \
 	client_side.cc \
 	client_side_reply.cc \
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	tests/stub_ETag.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
@@ -2745,60 +2752,61 @@
 	tests/stub_tools.cc
 tests_testIpAddress_LDADD= \
 	ip/libip.la \
 	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(XTRA_LIBS)
 tests_testIpAddress_LDFLAGS= $(LIBADD_DL)
 
 ## why so many sources? well httpHeaderTools requites ACLChecklist & friends.
 ## first line - what we are testing.
 tests_testStore_SOURCES= \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cbdata.cc \
 	ClientInfo.h \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	ETag.cc \
 	event.cc \
 	EventLoop.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	RequestFlags.cc \
 	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	refresh.h \
@@ -2989,60 +2997,61 @@
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libsecurity.cc \
 	tests/stub_stat.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
 	fde.cc \
 	client_db.h \
 	disk.h \
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
 	int.h \
 	int.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
 	Transients.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemObject.cc \
 	Notes.h \
 	Notes.cc \
 	StoreSwapLogData.cc \
 	StoreIOState.cc \
 	StoreMetaUnpacker.cc \
 	$(STOREMETA_SOURCE) \
 	StoreFileSystem.cc \
 	store_io.cc \
 	store_swapout.cc \
 	store_swapmeta.cc \
 	$(UNLINKDSOURCE) \
 	$(WIN32_SOURCE) \
 	event.cc \
 	$(DELAY_POOL_SOURCE) \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	ConfigParser.cc \
@@ -3164,60 +3173,61 @@
 	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc \
 	tests/testRefCount.cc
 testRefCount_LDADD = \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 tests_testRock_SOURCES = \
 	cbdata.cc \
 	CacheDigest.h \
 	CollapsedForwarding.h \
 	CollapsedForwarding.cc \
 	tests/stub_CacheDigest.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	disk.h \
 	disk.cc \
 	ETag.cc \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
 	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpHeaderFieldStat.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHdrCc.cc \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MasterXaction.cc \
 	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	RequestFlags.cc \
 	RequestFlags.h \
@@ -3358,60 +3368,61 @@
 	client_side_request.cc \
 	ClientInfo.h \
 	clientStream.cc \
 	tests/stub_CollapsedForwarding.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	CpuAffinityMap.cc \
 	CpuAffinityMap.h \
 	CpuAffinitySet.cc \
 	CpuAffinitySet.h \
 	$(DELAY_POOL_SOURCE) \
 	disk.h \
 	disk.cc \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	ETag.cc \
 	event.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \

=== modified file 'src/MemBuf.h'
--- src/MemBuf.h	2015-03-04 16:02:53 +0000
+++ src/MemBuf.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_MEMBUF_H
 #define SQUID_MEMBUF_H
 
 #include "base/Packable.h"
 #include "cbdata.h"
+#include "mem/forward.h"
+
+/* in case we want to change it later */
+typedef ssize_t mb_size_t;
 
 /**
  * Auto-growing memory-resident buffer with Packable interface
  * \deprecated Use SBuf instead.
  */
 class MemBuf : public Packable
 {
     CBDATA_CLASS(MemBuf);
 
 public:
     MemBuf():
         buf(NULL),
         size(0),
         max_capacity(0),
         capacity(0),
         stolen(0)
     {}
     virtual ~MemBuf() {
         if (!stolen && buf)
             clean();
     }
 
     /// start of the added data
     char *content() { return buf; }
 
     /// start of the added data
     const char *content() const { return buf; }
 
     /// available data size
     mb_size_t contentSize() const { return size; }

=== modified file 'src/MemObject.h'
--- src/MemObject.h	2015-07-25 12:03:27 +0000
+++ src/MemObject.h	2015-08-29 20:12:55 +0000
@@ -1,54 +1,56 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_MEMOBJECT_H
 #define SQUID_MEMOBJECT_H
 
 #include "CommRead.h"
 #include "dlink.h"
 #include "http/RequestMethod.h"
 #include "RemovalPolicy.h"
 #include "stmem.h"
 #include "StoreIOBuffer.h"
 #include "StoreIOState.h"
+#include "typedefs.h" //for IRCB
 
 #if USE_DELAY_POOLS
 #include "DelayId.h"
 #endif
 
 typedef void STMCB (void *data, StoreIOBuffer wroteBuffer);
+typedef void STABH(void *);
 
 class store_client;
 class HttpRequest;
 class HttpReply;
 
 class MemObject
 {
     MEMPROXY_CLASS(MemObject);
 
 public:
     static size_t inUseCount();
 
     void dump() const;
     MemObject();
     ~MemObject();
 
     /// sets store ID, log URI, and request method; TODO: find a better name
     void setUris(char const *aStoreId, char const *aLogUri, const HttpRequestMethod &aMethod);
 
     /// whether setUris() has been called
     bool hasUris() const;
 
     void write(const StoreIOBuffer &buf);
     void unlinkRequest();
     HttpReply const *getReply() const;
     void replaceHttpReply(HttpReply *newrep);
     void stat (MemBuf * mb) const;
     int64_t endOffset () const;
     void markEndOfReplyHeaders(); ///< sets _reply->hdr_sz to endOffset()
     /// negative if unknown; otherwise, expected object_sz, expected endOffset

=== modified file 'src/Notes.h'
--- src/Notes.h	2015-01-13 07:25:36 +0000
+++ src/Notes.h	2015-08-29 20:12:55 +0000
@@ -1,47 +1,46 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_NOTES_H
 #define SQUID_NOTES_H
 
 #include "acl/forward.h"
 #include "base/RefCount.h"
 #include "format/Format.h"
 #include "mem/forward.h"
 #include "SquidString.h"
-#include "typedefs.h"
 
 #include <string>
 #include <vector>
 
 class HttpRequest;
 class HttpReply;
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 
 /**
  * Used to store a note configuration. The notes are custom key:value
  * pairs ICAP request headers or ECAP options used to pass
  * custom transaction-state related meta information to squid
  * internal subsystems or to adaptation services.
  */
 class Note: public RefCountable
 {
 public:
     typedef RefCount<Note> Pointer;
     /// Stores a value for the note.
     class Value: public RefCountable
     {
     public:
         typedef RefCount<Value> Pointer;
         String value; ///< Configured annotation value, possibly with %macros
         ACLList *aclList; ///< The access list used to determine if this value is valid for a request
         /// Compiled annotation value format
         Format::Format *valueFormat;
         explicit Value(const String &aVal) : value(aVal), aclList(NULL), valueFormat(NULL) {}
         ~Value();
     };

=== modified file 'src/RemovalPolicy.h'
--- src/RemovalPolicy.h	2015-01-13 07:25:36 +0000
+++ src/RemovalPolicy.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef   SQUID_REMOVALPOLICY_H
 #define   SQUID_REMOVALPOLICY_H
 
 #include "cbdata.h"
 
 class RemovalPolicyWalker;
 class RemovalPurgeWalker;
+class wordlist;
+class StoreEntry;
 
 class RemovalPolicySettings
 {
 
 public:
     RemovalPolicySettings() : type(NULL), args(NULL) {};
 
     char *type;
     wordlist *args;
 };
 
 class RemovalPolicyNode
 {
 
 public:
     RemovalPolicyNode() : data(NULL) {}
 
     void *data;
 };
 
 class RemovalPolicy
 {
     CBDATA_CLASS(RemovalPolicy);
 
 public:
     const char *_type;
     void *_data;
     void (*Free) (RemovalPolicy * policy);
     void (*Add) (RemovalPolicy * policy, StoreEntry * entry, RemovalPolicyNode * node);
     void (*Remove) (RemovalPolicy * policy, StoreEntry * entry, RemovalPolicyNode * node);

=== modified file 'src/SquidConfig.h'
--- src/SquidConfig.h	2015-06-28 15:02:53 +0000
+++ src/SquidConfig.h	2015-08-29 20:12:55 +0000
@@ -1,61 +1,63 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SQUIDCONFIG_H_
 #define SQUID_SQUIDCONFIG_H_
 
 #include "acl/forward.h"
 #include "base/RefCount.h"
 #include "ClientDelayConfig.h"
 #include "DelayConfig.h"
 #include "helper/ChildConfig.h"
 #include "HttpHeaderTools.h"
 #include "ip/Address.h"
 #include "Notes.h"
 #include "security/forward.h"
+#include "SquidTime.h"
 #include "YesNoNone.h"
 
 #if USE_OPENSSL
 class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
 
 namespace Mgr
 {
 class ActionPasswordList;
 } // namespace Mgr
+class CachePeer;
 class CustomLog;
 class CpuAffinityMap;
 class external_acl;
 class HeaderManglers;
 class RefreshPattern;
 class RemovalPolicySettings;
 class SwapDir;
 
 namespace AnyP
 {
 class PortCfg;
 }
 
 /// the representation of the configuration. POD.
 class SquidConfig
 {
 public:
     struct {
         /* These should be for the Store::Root instance.
         * this needs pluggable parsing to be done smoothly.
         */
         int highWaterMark;
         int lowWaterMark;
     } Swap;
 
     YesNoNone memShared; ///< whether the memory cache is shared among workers
     size_t memMaxSize;
 
     struct {
         int64_t min;

=== modified file 'src/SquidList.cc'
--- src/SquidList.cc	2015-01-13 07:25:36 +0000
+++ src/SquidList.cc	2015-08-29 20:12:55 +0000
@@ -1,44 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: none          Linked list functions (deprecated) */
 
 #include "squid.h"
 #include "mem/forward.h"
 #include "SquidList.h"
-#include "typedefs.h"
 
 /* This should go away, in favour of the List template class */
 
 void
 linklistPush(link_list ** L, void *p)
 {
     link_list *l = (link_list *)memAllocate(MEM_LINK_LIST);
     l->next = NULL;
     l->ptr = p;
 
     while (*L)
         L = &(*L)->next;
 
     *L = l;
 }
 
 void *
 linklistShift(link_list ** L)
 {
     void *p;
     link_list *l;
 
     if (NULL == *L)
         return NULL;
 
     l = *L;
 
     p = l->ptr;
 
     *L = (*L)->next;

=== modified file 'src/SquidTime.h'
--- src/SquidTime.h	2015-01-13 07:25:36 +0000
+++ src/SquidTime.h	2015-08-29 20:12:55 +0000
@@ -1,48 +1,51 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 21    Time Functions */
 
 #ifndef   SQUID_TIME_H
 #define   SQUID_TIME_H
 
 #include "rfc1123.h"
 
 #include <ctime>
 /* NP: sys/time.h is provided by libcompat */
 
+/*Use uint64_t to store miliseconds*/
+typedef uint64_t time_msec_t;
+
 /* globals for accessing time */
 extern struct timeval current_time;
 extern double current_dtime;
 extern time_t squid_curtime;
 
 time_t getCurrentTime(void);
 int tvSubMsec(struct timeval, struct timeval);
 
 /// timeval substraction operation
 /// \param[out] res = t2 - t1
 void tvSub(struct timeval &res, struct timeval const &t1, struct timeval const &t2);
 
 /// timeval addition operation
 /// \param[out] res = t1 + t2
 void tvAdd(struct timeval &res, struct timeval const &t1, struct timeval const &t2);
 
 /// timeval addition assignment operation
 /// \param[out] t += add
 void tvAssignAdd(struct timeval &t, struct timeval const &add);
 
 /// Convert timeval to milliseconds
 inline long int tvToMsec(struct timeval &t)
 {
     return t.tv_sec * 1000 + t.tv_usec / 1000;
 }
 
 /** event class for doing synthetic time etc */
 class TimeEngine
 {
 

=== modified file 'src/Store.h'
--- src/Store.h	2015-08-24 21:07:31 +0000
+++ src/Store.h	2015-08-29 20:12:55 +0000
@@ -1,68 +1,91 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_STORE_H
 #define SQUID_STORE_H
 
 #include "base/Packable.h"
 #include "base/RefCount.h"
 #include "comm/forward.h"
 #include "CommRead.h"
 #include "hash.h"
 #include "http/forward.h"
 #include "http/RequestMethod.h"
 #include "HttpReply.h"
 #include "MemObject.h"
 #include "Range.h"
 #include "RemovalPolicy.h"
+#include "store_key_md5.h"
 #include "StoreIOBuffer.h"
 #include "StoreStats.h"
 
 #if USE_SQUID_ESI
 #include "esi/Element.h"
 #endif
 
 #include <ostream>
 
 class AsyncCall;
 class HttpRequest;
 class RequestFlags;
 class StoreClient;
 class StoreSearch;
 class SwapDir;
 
+enum mem_status_t {
+    NOT_IN_MEMORY,
+    IN_MEMORY
+};
+
+enum store_status_t {
+    STORE_OK,
+    STORE_PENDING
+};
+
+enum swap_status_t {
+    SWAPOUT_NONE,
+    SWAPOUT_WRITING,
+    SWAPOUT_DONE
+};
+
+enum store_client_t {
+    STORE_NON_CLIENT,
+    STORE_MEM_CLIENT,
+    STORE_DISK_CLIENT
+};
+
 extern StoreIoStats store_io_stats;
 
 /// maximum number of entries per cache_dir
 enum { SwapFilenMax = 0xFFFFFF }; // keep in sync with StoreEntry::swap_filen
 
 class StoreEntry : public hash_link, public Packable
 {
 
 public:
     static DeferredRead::DeferrableRead DeferReader;
     bool checkDeferRead(int fd) const;
 
     virtual const char *getMD5Text() const;
     StoreEntry();
     virtual ~StoreEntry();
 
     virtual HttpReply const *getReply() const;
     virtual void write (StoreIOBuffer);
 
     /** Check if the Store entry is emtpty
      * \retval true   Store contains 0 bytes of data.
      * \retval false  Store contains 1 or more bytes of data.
      * \retval false  Store contains negative content !!!!!!
      */
     virtual bool isEmpty() const {
         assert (mem_obj);
         return mem_obj->endOffset() == 0;
     }
     virtual bool isAccepting() const;
     virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const;

=== modified file 'src/StoreIOState.h'
--- src/StoreIOState.h	2015-05-16 08:41:00 +0000
+++ src/StoreIOState.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_STOREIOSTATE_H
 #define SQUID_STOREIOSTATE_H
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "fs/forward.h"
+#include "mem/forward.h"
 
 class StoreIOState : public RefCountable
 {
 
 public:
     typedef RefCount<StoreIOState> Pointer;
 
     /*
      * STRCB is the "store read callback".  STRCB functions are
      * passed to storeRead().  Examples of STRCB callbacks are:
      * storeClientReadBody
      * storeClientReadHeader
      */
     typedef void STRCB(void *their_data, const char *buf, ssize_t len, StoreIOState::Pointer self);
 
     /*
      * STFNCB is the "store file number callback."  It is called
      * when an underlying storage module has allocated the swap
      * file number and also indicates that the swap file has been
      * opened for reading or writing.  STFNCB functions are passed
      * to storeCreate() and storeOpen().  Examples of STFNCB callbacks
      * are:
      * storeSwapInFileNotify
      * storeSwapOutFileNotify
      */
     typedef void STFNCB(void *their_data, int errflag, StoreIOState::Pointer self);
 
     /*
      * STIOCB is the "store close callback" for store files.  It
      * is called when the store file is closed.  STIOCB functions

=== modified file 'src/StoreSwapLogData.h'
--- src/StoreSwapLogData.h	2015-01-13 07:25:36 +0000
+++ src/StoreSwapLogData.h	2015-08-29 20:12:55 +0000
@@ -10,61 +10,61 @@
 #define SQUID_STORESWAPLOGDATA_H
 
 /**
  \defgroup FileFormatSwapStateAPI swap.state File Structure
  \ingroup FileSystems
  \section ImplementationNotes Implementation Notes
  \par
  *      When writing an object to disk, we must first write the meta data.
  *      This is done with a couple of functions.  First, storeSwapMetaPack()
  *      takes a StoreEntry as a parameter and returns a tlv linked
  *      list.  Second, storeSwapMetaPack() converts the tlv list
  *      into a character buffer that we can write.
  *
  \note  MemObject has a MemObject::swap_hdr_sz.
  *      This value is the size of that character buffer; the size of the
  *      swap file meta data.  The StoreEntry has a member
  *      StoreEntry::swap_file_sz that represents the size of the disk file.
  *      Thus, the size of the object "content" is
  \code    StoreEntry->swap_file_sz  - MemObject->swap_hdr_sz;    \endcode
  \note The swap file content includes the HTTP reply headers and the HTTP reply body (if any).
  *
  \par
  *      When reading a swap file, there is a similar process to extract
  *      the swap meta data.  First, storeSwapMetaUnpack() converts a
  *      character buffer into a tlv linked list.  It also tells us
  *      the value for MemObject->swap_hdr_sz.
  */
 
 #include "md5.h"
 #include "mem/forward.h"
-#include "typedefs.h"
+#include "fs/forward.h"
 
 /// maintains a 24-bit checksum over integer fields
 class SwapChecksum24
 {
 public:
     SwapChecksum24() { raw[0] = raw[1] = raw[2] = 0; }
 
     bool operator ==(const SwapChecksum24 &o) const {
         return raw[0] == o.raw[0] && raw[1] == o.raw[1] && raw[2] == o.raw[2];
     }
 
     bool operator !=(const SwapChecksum24 &o) const {
         return !(*this == o);
     }
 
     /// compute and store checksum based on three 32bit integers
     void set(uint32_t f1, uint32_t f2, uint32_t f3);
 
     /// compute and store checksum based on int32_t and uint64_t integers
     void set(int32_t f1, uint64_t f2);
 
     // printing for debugging
     std::ostream &print(std::ostream &os) const;
 
 private:
     uint8_t raw[3]; // designed to follow "op" members, in pading space
 };
 
 inline std::ostream &
 operator <<(std::ostream &os, const SwapChecksum24 &sum)

=== modified file 'src/SwapDir.h'
--- src/SwapDir.h	2015-08-01 02:13:13 +0000
+++ src/SwapDir.h	2015-08-29 20:12:55 +0000
@@ -1,56 +1,58 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SWAPDIR_H
 #define SQUID_SWAPDIR_H
 
 #include "mgr/forward.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StoreIOState.h"
 
 /* forward decls */
 class RemovalPolicy;
 class MemStore;
 class Transients;
 class RequestFlags;
 class HttpRequestMethod;
 
 /* Store dir configuration routines */
 /* SwapDir *sd, char *path ( + char *opt later when the strtok mess is gone) */
 
+typedef int STDIRSELECT(const StoreEntry *);
+
 class ConfigOption;
 
 /// hides memory/disk cache distinction from callers
 class StoreController : public Store
 {
 
 public:
     StoreController();
     virtual ~StoreController();
     virtual int callback();
     virtual void create();
 
     virtual StoreEntry * get(const cache_key *);
 
     virtual void get(String const, STOREGETCLIENT, void * cbdata);
 
     /* Store parent API */
     virtual void markForUnlink(StoreEntry &e);
     virtual void handleIdleEntry(StoreEntry &e);
     virtual void transientsCompleteWriting(StoreEntry &e);
     virtual void transientsAbandon(StoreEntry &e);
     virtual int transientReaders(const StoreEntry &e) const;
     virtual void transientsDisconnect(MemObject &mem_obj);
     virtual void memoryOut(StoreEntry &e, const bool preserveSwappable);
     virtual void memoryUnlink(StoreEntry &e);
     virtual void memoryDisconnect(StoreEntry &e);
     virtual void allowCollapsing(StoreEntry *e, const RequestFlags &reqFlags, const HttpRequestMethod &reqMethod);
     virtual void syncCollapsed(const sfileno xitIndex);
 
     virtual void init();

=== modified file 'src/acl/DestinationDomain.h'
--- src/acl/DestinationDomain.h	2015-01-29 16:09:11 +0000
+++ src/acl/DestinationDomain.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,46 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLDESTINATIONDOMAIN_H
 #define SQUID_ACLDESTINATIONDOMAIN_H
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
+#include "dns/forward.h"
 
 /// \ingroup ACLAPI
 class ACLDestinationDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
     virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLDestinationDomainStrategy *Instance();
     virtual bool requiresRequest() const {return true;}
 
     /**
      * Not implemented to prevent copies of the instance.
      \par
      * Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends
      */
     ACLDestinationDomainStrategy(ACLDestinationDomainStrategy const &);
 
 private:
     static ACLDestinationDomainStrategy Instance_;
     ACLDestinationDomainStrategy() {}
 
     ACLDestinationDomainStrategy&operator=(ACLDestinationDomainStrategy const &);
 };
 
 /// \ingroup ACLAPI
 class DestinationDomainLookup : public ACLChecklist::AsyncState
 {
 
 public:

=== modified file 'src/acl/SourceDomain.h'
--- src/acl/SourceDomain.h	2015-01-29 16:09:11 +0000
+++ src/acl/SourceDomain.h	2015-08-29 20:12:55 +0000
@@ -1,44 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSOURCEDOMAIN_H
 #define SQUID_ACLSOURCEDOMAIN_H
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
+#include "dns/forward.h"
 
 class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
     virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSourceDomainStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLSourceDomainStrategy(ACLSourceDomainStrategy const &);
 
 private:
     static ACLSourceDomainStrategy Instance_;
     ACLSourceDomainStrategy() {}
 
     ACLSourceDomainStrategy&operator=(ACLSourceDomainStrategy const &);
 };
 
 class SourceDomainLookup : public ACLChecklist::AsyncState
 {
 
 public:
     static SourceDomainLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
 
 private:
     static SourceDomainLookup instance_;
     static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };

=== modified file 'src/cbdata.h'
--- src/cbdata.h	2015-03-14 17:53:38 +0000
+++ src/cbdata.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,41 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_SRC_CBDATA_H
 #define SQUID_SRC_CBDATA_H
 
-#include "typedefs.h"
-
 /**
 \page CBDATA Callback Data Allocator API
 
  \section  Introduction
 
  \par
    Squid's extensive use of callback functions makes it very
    susceptible to memory access errors. To address this all callback
    functions make use of a construct called cbdata. This allows
    functions doing callbacks to verify that the caller is still
    valid before making the callback.
 
  \note cbdata is intended for callback data and is tailored specifically
        to make callbacks less dangerous leaving as few windows of errors as
        possible. It is not suitable or intended as a generic RefCount
        memory allocator.
 
  \par
    The AsyncJob/AsyncCall mechanism is preferred over CBDATA.
    It replaces cbdata with an AsyncCall::Pointer object which
    performs the same memory protection duties via other means.
 
  \section Examples Examples
  \par
    Here you can find some examples on how to use cbdata, and why.
 
  \subsection AsyncOpWithoutCBDATA Asynchronous operation without cbdata, showing why cbdata is needed
  \par
    For a asyncronous operation with callback functions, the normal
    sequence of events in programs NOT using cbdata is as follows:

=== modified file 'src/comm/Connection.h'
--- src/comm/Connection.h	2015-06-02 10:15:06 +0000
+++ src/comm/Connection.h	2015-08-29 20:12:55 +0000
@@ -1,49 +1,49 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 05    Socket Functions */
 
 #ifndef _SQUIDCONNECTIONDETAIL_H_
 #define _SQUIDCONNECTIONDETAIL_H_
 
 #include "comm/forward.h"
 #include "defines.h"
 #include "hier_code.h"
 #include "ip/Address.h"
 #include "mem/forward.h"
-#include "typedefs.h"
+#include "ip/forward.h"
 #if USE_SQUID_EUI
 #include "eui/Eui48.h"
 #include "eui/Eui64.h"
 #endif
 #include "SquidTime.h"
 
 #include <iosfwd>
 #include <ostream>
 
 class CachePeer;
 
 namespace Comm
 {
 
 /* TODO: make these a struct of boolean flags members in the connection instead of a bitmap.
  * we can't do that until all non-comm code uses Commm::Connection objects to create FD
  * currently there is code still using comm_open() and comm_openex() synchronously!!
  */
 #define COMM_UNSET              0x00
 #define COMM_NONBLOCKING        0x01  // default flag.
 #define COMM_NOCLOEXEC          0x02
 #define COMM_REUSEADDR          0x04  // shared FD may be both accept()ing and read()ing
 #define COMM_DOBIND             0x08  // requires a bind()
 #define COMM_TRANSPARENT        0x10  // arrived via TPROXY
 #define COMM_INTERCEPTION       0x20  // arrived via NAT
 
 /**
  * Store data about the physical and logical attributes of a connection.
  *
  * Some link state can be infered from the data, however this is not an

=== modified file 'src/comm/IoCallback.h'
--- src/comm/IoCallback.h	2015-01-13 07:25:36 +0000
+++ src/comm/IoCallback.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_COMM_IOCALLBACK_H
 #define _SQUID_COMM_IOCALLBACK_H
 
 #include "base/AsyncCall.h"
 #include "comm/Flag.h"
 #include "comm/forward.h"
-#include "typedefs.h"
+#include "mem/forward.h"
 
 class SBuf;
 
 namespace Comm
 {
 
 /// Type of IO callbacks the Comm layer deals with.
 typedef enum {
     IOCB_NONE,
     IOCB_READ,
     IOCB_WRITE
 } iocb_type;
 
 /// Details about a particular Comm IO callback event.
 class IoCallback
 {
 public:
     iocb_type type;
     Comm::ConnectionPointer conn;
     AsyncCall::Pointer callback;
     char *buf;
     FREE *freefunc;
     int size;
     int offset;
     Comm::Flag errcode;
     int xerrno;
 #if USE_DELAY_POOLS
     unsigned int quotaQueueReserv; ///< reservation ID from CommQuotaQueue
 #endif
 

=== modified file 'src/comm/Loops.h'
--- src/comm/Loops.h	2015-01-13 07:25:36 +0000
+++ src/comm/Loops.h	2015-08-29 20:12:55 +0000
@@ -1,45 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_SRC_COMM_LOOPS_H
 #define _SQUID_SRC_COMM_LOOPS_H
 
 #include "comm/Flag.h"
-
-// for PF
-#include "typedefs.h"
+#include "comm/forward.h"
 
 /* Comm layer select loops API.
  *
  * These API functions must be implemented by all FD IO loops used by Squid.
  * Defines are provided short-term for legacy code. These will disappear soon.
  */
 
 namespace Comm
 {
 
 /// Initialize the module on Squid startup
 void SelectLoopInit(void);
 
 /// Mark an FD to be watched for its IO status.
 void SetSelect(int, unsigned int, PF *, void *, time_t);
 
 /// reset/undo/unregister the watch for an FD which was set by Comm::SetSelect()
 void ResetSelect(int);
 
 /** Perform a select() or equivalent call.
  * This is used by the main select loop engine to check for FD with IO available.
  */
 Comm::Flag DoSelect(int);
 
 void QuickPollRequired(void);
 
 /**
  * Max number of UDP messages to receive per call to the UDP receive poller.
  * This is a per-port limit for ICP/HTCP ports.
  * DNS has a separate limit.

=== modified file 'src/comm/Write.h'
--- src/comm/Write.h	2015-01-13 07:25:36 +0000
+++ src/comm/Write.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_COMM_IOWRITE_H
 #define _SQUID_COMM_IOWRITE_H
 
 #include "base/AsyncCall.h"
 #include "comm/forward.h"
-#include "typedefs.h"
+#include "mem/forward.h"
 
 class MemBuf;
 namespace Comm
 {
 
 /**
  * Queue a write. callback is scheduled when the write
  * completes, on error, or on file descriptor close.
  *
  * free_func is used to free the passed buffer when the write has completed.
  */
 void Write(const Comm::ConnectionPointer &conn, const char *buf, int size, AsyncCall::Pointer &callback, FREE *free_func);
 
 /**
  * Queue a write. callback is scheduled when the write
  * completes, on error, or on file descriptor close.
  */
 void Write(const Comm::ConnectionPointer &conn, MemBuf *mb, AsyncCall::Pointer &callback);
 
 /// Cancel the write pending on FD. No action if none pending.
 void WriteCancel(const Comm::ConnectionPointer &conn, const char *reason);
 
 // callback handler to process an FD which is available for writing.
 extern PF HandleWrite;
 
 } // namespace Comm
 
 #endif /* _SQUID_COMM_IOWRITE_H */
 

=== modified file 'src/comm/forward.h'
--- src/comm/forward.h	2015-01-13 07:25:36 +0000
+++ src/comm/forward.h	2015-08-29 20:12:55 +0000
@@ -1,32 +1,34 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_COMM_FORWARD_H
 #define _SQUID_COMM_FORWARD_H
 
 #include "base/RefCount.h"
 
 #include <vector>
 
 /// Abstraction layer for TCP, UDP, TLS, UDS and filedescriptor sockets.
 namespace Comm
 {
 
 class Connection;
 class ConnOpener;
 
 typedef RefCount<Comm::Connection> ConnectionPointer;
 
 typedef std::vector<Comm::ConnectionPointer> ConnectionList;
 
 bool IsConnOpen(const Comm::ConnectionPointer &conn);
 
 }; // namespace Comm
 
+typedef void PF(int, void *);
+
 #endif /* _SQUID_COMM_FORWARD_H */
 

=== modified file 'src/disk.h'
--- src/disk.h	2015-01-13 07:25:36 +0000
+++ src/disk.h	2015-08-29 20:12:55 +0000
@@ -1,44 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 06    Disk I/O Routines */
 
 #ifndef SQUID_DISK_H_
 #define SQUID_DISK_H_
 
-#include "typedefs.h"
+#include "mem/forward.h"
+#include "typedefs.h" //DRCB, DWCB
 
 class MemBuf;
 
 // POD
 class dread_ctrl
 {
 public:
     int fd;
     off_t offset;
     int req_len;
     char *buf;
     int end_of_file;
     DRCB *handler;
     void *client_data;
 };
 
 // POD
 class dwrite_q
 {
 public:
     off_t file_offset;
     char *buf;
     size_t len;
     size_t buf_offset;
     dwrite_q *next;
     FREE *free_func;
 };
 
 int file_open(const char *path, int mode);
 void file_close(int fd);

=== modified file 'src/enums.h'
--- src/enums.h	2015-08-05 16:56:42 +0000
+++ src/enums.h	2015-08-29 20:12:55 +0000
@@ -1,91 +1,54 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ENUMS_H
 #define SQUID_ENUMS_H
 
-enum fd_type {
-    FD_NONE,
-    FD_LOG,
-    FD_FILE,
-    FD_SOCKET,
-    FD_PIPE,
-    FD_MSGHDR,
-    FD_UNKNOWN
-};
-
-enum {
-    FD_READ,
-    FD_WRITE
-};
-
 typedef enum {
     PEER_NONE,
     PEER_SIBLING,
     PEER_PARENT,
     PEER_MULTICAST
 } peer_t;
 
-typedef enum _mem_status_t {
-    NOT_IN_MEMORY,
-    IN_MEMORY
-} mem_status_t;
-
 typedef enum {
     PING_NONE,
     PING_WAITING,
     PING_DONE
 } ping_status_t;
 
-typedef enum {
-    STORE_OK,
-    STORE_PENDING
-} store_status_t;
-
-typedef enum {
-    SWAPOUT_NONE,
-    SWAPOUT_WRITING,
-    SWAPOUT_DONE
-} swap_status_t;
-
-typedef enum {
-    STORE_NON_CLIENT,
-    STORE_MEM_CLIENT,
-    STORE_DISK_CLIENT
-} store_client_t;
-
 /*
  * These are for StoreEntry->flag, which is defined as a SHORT
  *
  * NOTE: These flags are written to swap.state, so think very carefully
  * about deleting or re-assigning!
  */
 enum {
     ENTRY_SPECIAL,
     ENTRY_REVALIDATE,
     DELAY_SENDING,
     RELEASE_REQUEST,
     REFRESH_REQUEST,
     ENTRY_CACHABLE_RESERVED_FOR_FUTURE_USE,
     ENTRY_DISPATCHED,
     KEY_PRIVATE,
     ENTRY_FWD_HDR_WAIT,
     ENTRY_NEGCACHED,
     ENTRY_VALIDATED,
     ENTRY_BAD_LENGTH,
     ENTRY_ABORTED
 };
 
 /*
  * These are for client Streams. Each node in the stream can be queried for
  * its status
  */
 typedef enum {
     STREAM_NONE,        /* No particular status */
     STREAM_COMPLETE,        /* All data has been flushed, no more reads allowed */
     /* an unpredicted end has occured, no more

=== modified file 'src/errorpage.h'
--- src/errorpage.h	2015-01-13 07:25:36 +0000
+++ src/errorpage.h	2015-08-29 20:12:55 +0000
@@ -1,101 +1,106 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 04    Error Generation */
 
 #ifndef   SQUID_ERRORPAGE_H
 #define   SQUID_ERRORPAGE_H
 
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "err_detail_type.h"
 #include "err_type.h"
 #include "http/StatusCode.h"
 #include "ip/Address.h"
 #include "SquidString.h"
 /* auth/UserRequest.h is empty unless USE_AUTH is defined */
 #include "auth/UserRequest.h"
 #if USE_OPENSSL
 #include "ssl/ErrorDetail.h"
 #endif
 
+/// error page callback
+typedef void ERCB(int fd, void *, size_t);
+
 /**
  \defgroup ErrorPageAPI Error Pages API
  \ingroup Components
  \section ErrorPageStringCodes Error Page % codes for text insertion.
  *
  \verbatim
    a - User identity                            x
    B - URL with FTP %2f hack                    x
    c - Squid error code                         x
    d - seconds elapsed since request received   x
    D - Error details                            x
    e - errno                                    x
    E - strerror()                               x
    f - FTP request line                         x
    F - FTP reply line                           x
    g - FTP server message                       x
    h - cache hostname                           x
    H - server host name                         x
    i - client IP address                        x
    I - server IP address                        x
    l - HREF link for CSS stylesheet inclusion   x
    L - HREF link for more info/contact          x
    M - Request Method                           x
    m - Error message returned by auth helper    x
    o - Message returned external acl helper     x
    p - URL port #                               x
    P - Protocol                                 x
    R - Full HTTP Request                        x
    S - squid signature from ERR_SIGNATURE       x
    s - caching proxy software with version      x
    t - local time                               x
    T - UTC                                      x
    U - URL without password                     x
    u - URL with password                        x
    w - cachemgr email address                   x
    W - error data (to be included in the mailto links)
    x - error name                               x
    z - dns server error message                 x
    Z - Preformatted error message               x
  \endverbatim
  */
 
 class HttpReply;
 class HttpRequest;
 class MemBuf;
+class StoreEntry;
+class wordlist;
 
 /// \ingroup ErrorPageAPI
 class ErrorState
 {
     CBDATA_CLASS(ErrorState);
 
 public:
     ErrorState(err_type type, Http::StatusCode, HttpRequest * request);
     ErrorState(); // not implemented.
     ~ErrorState();
 
     /// Creates a general request forwarding error with the right http_status.
     static ErrorState *NewForwarding(err_type type, HttpRequest *request);
 
     /**
      * Allocates and initializes an error response
      */
     HttpReply *BuildHttpReply(void);
 
     /// set error type-specific detail code
     void detailError(int dCode) {detailCode = dCode;}
 
 private:
     /**
      * Locates error page template to be used for this error
      * and constructs the HTML page content from it.
      */
     MemBuf *BuildContent(void);
 
     /**

=== modified file 'src/fd.h'
--- src/fd.h	2015-01-13 07:25:36 +0000
+++ src/fd.h	2015-08-29 20:12:55 +0000
@@ -1,25 +1,40 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 51    Filedescriptor Functions */
 
 #ifndef SQUID_FD_H_
 #define SQUID_FD_H_
 
+enum fd_type {
+    FD_NONE,
+    FD_LOG,
+    FD_FILE,
+    FD_SOCKET,
+    FD_PIPE,
+    FD_MSGHDR,
+    FD_UNKNOWN
+};
+
+enum {
+    FD_READ,
+    FD_WRITE
+};
+
 void fd_close(int fd);
 void fd_open(int fd, unsigned int type, const char *);
 void fd_note(int fd, const char *);
 void fd_bytes(int fd, int len, unsigned int type);
 void fdDumpOpen(void);
 int fdUsageHigh(void);
 void fdAdjustReserved(void);
 int default_read_method(int, char *, int);
 int default_write_method(int, const char *, int);
 
 #endif /* SQUID_FD_H_ */
 

=== modified file 'src/fde.cc'
--- src/fde.cc	2015-01-13 07:25:36 +0000
+++ src/fde.cc	2015-08-29 20:12:55 +0000
@@ -1,42 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: none          FDE */
 
 #include "squid.h"
 #include "comm/Read.h"
+#include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "SquidTime.h"
 #include "Store.h"
 
 fde *fde::Table = NULL;
 
 bool
 fde::readPending(int fdNumber)
 {
     if (type == FD_SOCKET)
         return Comm::MonitorsRead(fdNumber);
 
     return read_handler ? true : false ;
 }
 
 void
 fde::dumpStats (StoreEntry &dumpEntry, int fdNumber)
 {
     if (!flags.open)
         return;
 
 #if _SQUID_WINDOWS_
 
     storeAppendPrintf(&dumpEntry, "%4d 0x%-8lX %-6.6s %4d %7" PRId64 "%c %7" PRId64 "%c %-21s %s\n",
                       fdNumber,
                       win32.handle,
 #else
     storeAppendPrintf(&dumpEntry, "%4d %-6.6s %4d %7" PRId64 "%c %7" PRId64 "%c %-21s %s\n",
                       fdNumber,

=== modified file 'src/fde.h'
--- src/fde.h	2015-07-13 16:04:07 +0000
+++ src/fde.h	2015-08-29 20:12:55 +0000
@@ -1,50 +1,64 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_FDE_H
 #define SQUID_FDE_H
 
 #include "comm.h"
 #include "defines.h"
 #include "ip/Address.h"
+#include "ip/forward.h"
 #include "security/forward.h"
+#include "typedefs.h" //DRCB, DWCB
 
 #if USE_DELAY_POOLS
 class ClientInfo;
 #endif
 
+/**
+ * READ_HANDLER functions return < 0 if, and only if, they fail with an error.
+ * On error, they must pass back an error code in 'errno'.
+ */
+typedef int READ_HANDLER(int, char *, int);
+
+/**
+ * WRITE_HANDLER functions return < 0 if, and only if, they fail with an error.
+ * On error, they must pass back an error code in 'errno'.
+ */
+typedef int WRITE_HANDLER(int, const char *, int);
+
 class dwrite_q;
 class _fde_disk
 {
 public:
     DWCB *wrt_handle;
     void *wrt_handle_data;
     dwrite_q *write_q;
     dwrite_q *write_q_tail;
     off_t offset;
     _fde_disk() { memset(this, 0, sizeof(_fde_disk)); }
 };
 
 class fde
 {
 
 public:
     fde() { clear(); };
 
     /// True if comm_close for this fd has been called
     bool closing() { return flags.close_request; }
 
     /* NOTE: memset is used on fdes today. 20030715 RBC */
     static void DumpStats (StoreEntry *);
 
     char const *remoteAddr() const;
     void dumpStats (StoreEntry &, int);
     bool readPending(int);
     void noteUse();
 
 public:
@@ -76,102 +90,100 @@
         bool nodelay;
         bool close_on_exec;
         bool read_pending;
         //bool write_pending; //XXX seems not to be used
         bool transparent;
     } flags;
 
     int64_t bytes_read;
     int64_t bytes_written;
 
     struct {
         int uses;                   /* ie # req's over persistent conn */
     } pconn;
 
 #if USE_DELAY_POOLS
     ClientInfo * clientInfo;/* pointer to client info used in client write limiter or NULL if not present */
 #endif
     unsigned epoll_state;
 
     _fde_disk disk;
     PF *read_handler;
     void *read_data;
     PF *write_handler;
     void *write_data;
     AsyncCall::Pointer timeoutHandler;
     time_t timeout;
     time_t writeStart;
     void *lifetime_data;
     AsyncCall::Pointer closeHandler;
     AsyncCall::Pointer halfClosedReader; /// read handler for half-closed fds
-    CommWriteStateData *wstate;         /* State data for comm_write */
     READ_HANDLER *read_method;
     WRITE_HANDLER *write_method;
     Security::SessionPointer ssl;
     Security::ContextPointer dynamicSslContext; ///< cached and then freed when fd is closed
 #if _SQUID_WINDOWS_
     struct {
         long handle;
     } win32;
 #endif
     tos_t tosFromServer;                /**< Stores the TOS flags of the packets from the remote server.
                                             See FwdState::dispatch(). Note that this differs to
                                             tosToServer in that this is the value we *receive* from the,
                                             connection, whereas tosToServer is the value to set on packets
                                             *leaving* Squid.  */
     unsigned int nfmarkFromServer;      /**< Stores the Netfilter mark value of the connection from the remote
                                             server. See FwdState::dispatch(). Note that this differs to
                                             nfmarkToServer in that this is the value we *receive* from the,
                                             connection, whereas nfmarkToServer is the value to set on packets
                                             *leaving* Squid.   */
 
 private:
     /** Clear the fde class back to NULL equivalent. */
     inline void clear() {
         type = 0;
         remote_port = 0;
         local_addr.setEmpty();
         tosToServer = '\0';
         nfmarkToServer = 0;
         sock_family = 0;
         memset(ipaddr, '\0', MAX_IPSTRLEN);
         memset(desc,'\0',FD_DESC_SZ);
         memset(&flags,0,sizeof(_fde_flags));
         bytes_read = 0;
         bytes_written = 0;
         pconn.uses = 0;
 #if USE_DELAY_POOLS
         clientInfo = NULL;
 #endif
         epoll_state = 0;
         read_handler = NULL;
         read_data = NULL;
         write_handler = NULL;
         write_data = NULL;
         timeoutHandler = NULL;
         timeout = 0;
         writeStart = 0;
         lifetime_data = NULL;
         closeHandler = NULL;
         halfClosedReader = NULL;
-        wstate = NULL;
         read_method = NULL;
         write_method = NULL;
         ssl = NULL;
         dynamicSslContext = NULL;
 #if _SQUID_WINDOWS_
         win32.handle = (long)NULL;
 #endif
         tosFromServer = '\0';
         nfmarkFromServer = 0;
     }
 };
 
 #define fd_table fde::Table
 
 int fdNFree(void);
 
 #define FD_READ_METHOD(fd, buf, len) (*fd_table[fd].read_method)(fd, buf, len)
 #define FD_WRITE_METHOD(fd, buf, len) (*fd_table[fd].write_method)(fd, buf, len)
 
 #endif /* SQUID_FDE_H */
 

=== modified file 'src/fqdncache.cc'
--- src/fqdncache.cc	2015-01-29 16:09:11 +0000
+++ src/fqdncache.cc	2015-08-29 20:12:55 +0000
@@ -1,46 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 35    FQDN Cache */
 
 #include "squid.h"
 #include "cbdata.h"
 #include "dns/forward.h"
 #include "dns/LookupDetails.h"
 #include "dns/rfc1035.h"
 #include "event.h"
+#include "fqdncache.h"
 #include "helper.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
 #include "util.h"
 #include "wordlist.h"
 
 #if SQUID_SNMP
 #include "snmp_core.h"
 #endif
 
 /**
  \defgroup FQDNCacheAPI FQDN Cache API
  \ingroup Components
  \section Introduction Introduction
  \par
  *  The FQDN cache is a built-in component of squid providing
  *  Hostname to IP-Number translation functionality and managing
  *  the involved data-structures. Efficiency concerns require
  *  mechanisms that allow non-blocking access to these mappings.
  *  The FQDN cache usually doesn't block on a request except for
  *  special cases where this is desired (see below).
  *
  \todo FQDN Cache should have its own API *.h file.
  */
 
 /**
  \defgroup FQDNCacheInternal FQDN Cache Internals

=== modified file 'src/fqdncache.h'
--- src/fqdncache.h	2015-01-13 07:25:36 +0000
+++ src/fqdncache.h	2015-08-29 20:12:55 +0000
@@ -1,31 +1,36 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 35    FQDN Cache */
 
 #ifndef SQUID_FQDNCACHE_H_
 #define SQUID_FQDNCACHE_H_
 
 #include "ip/Address.h"
-#include "typedefs.h"
 
 class StoreEntry;
 class wordlist;
+namespace Dns
+{
+class LookupDetails;
+}
+
+typedef void FQDNH(const char *, const Dns::LookupDetails &details, void *);
 
 void fqdncache_init(void);
 void fqdnStats(StoreEntry *);
 void fqdncacheFreeMemory(void);
 void fqdncache_restart(void);
 void fqdncache_purgelru(void *);
 void fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames);
 
 const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
 void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
 
 #endif /* SQUID_FQDNCACHE_H_ */
 

=== added file 'src/fs/forward.h'
--- src/fs/forward.h	1970-01-01 00:00:00 +0000
+++ src/fs/forward.h	2015-08-29 20:12:55 +0000
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+#ifndef SQUID_FORWARD_H_
+#define SQUID_FORWARD_H_
+
+typedef int32_t sfileno;
+typedef signed int sdirno;
+
+
+#endif /* SQUID_FORWARD_H_ */

=== modified file 'src/fs/rock/RockDbCell.h'
--- src/fs/rock/RockDbCell.h	2015-01-13 07:25:36 +0000
+++ src/fs/rock/RockDbCell.h	2015-08-29 20:12:55 +0000
@@ -1,42 +1,42 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_FS_ROCK_DB_CELL_H
 #define SQUID_FS_ROCK_DB_CELL_H
 
-#include "typedefs.h"
+#include "fs/forward.h"
 
 namespace Rock
 {
 
 /** \ingroup Rock
  * Meta-information at the beginning of every db cell.
  * Links multiple map slots belonging to the same entry into an entry chain.
  * Stored on disk and used as sizeof() argument so it must remain POD.
  */
 class DbCellHeader
 {
 public:
     DbCellHeader();
 
     /// true iff no entry occupies this slot
     bool empty() const { return !firstSlot && !nextSlot && !payloadSize; }
 
     /* members below are not meaningful if empty() */
 
     /// whether this slot is not corrupted
     bool sane(const size_t slotSize, int slotLimit) const {
         return
             0 <= firstSlot && firstSlot < slotLimit &&
             -1 <= nextSlot && nextSlot < slotLimit &&
             version > 0 &&
             0 < payloadSize && payloadSize <= slotSize - sizeof(DbCellHeader);
     }
 
     uint64_t key[2]; ///< StoreEntry key
     uint64_t entrySize; ///< total entry content size or zero if still unknown

=== modified file 'src/fs/rock/RockForward.h'
--- src/fs/rock/RockForward.h	2015-01-13 07:25:36 +0000
+++ src/fs/rock/RockForward.h	2015-08-29 20:12:55 +0000
@@ -1,41 +1,43 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_FS_ROCK_FORWARD_H
 #define SQUID_FS_ROCK_FORWARD_H
 
+#include "fs/forward.h"
+
 namespace Ipc
 {
 
 class StoreMapAnchor;
 class StoreMapSlice;
 
 namespace Mem
 {
 class PageId;
 }
 
 }
 
 namespace Rock
 {
 
 class SwapDir;
 
 /// db cell number, starting with cell 0 (always occupied by the db header)
 typedef sfileno SlotId;
 
 class Rebuild;
 
 class IoState;
 
 class DbCellHeader;
 
 }
 
 #endif /* SQUID_FS_ROCK_FORWARD_H */

=== modified file 'src/fs/rock/RockRebuild.cc'
--- src/fs/rock/RockRebuild.cc	2015-06-02 11:05:22 +0000
+++ src/fs/rock/RockRebuild.cc	2015-08-29 20:12:55 +0000
@@ -1,52 +1,52 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 79    Disk IO Routines */
 
 #include "squid.h"
 #include "disk.h"
+#include "fs/forward.h"
 #include "fs/rock/RockDbCell.h"
 #include "fs/rock/RockRebuild.h"
 #include "fs/rock/RockSwapDir.h"
 #include "globals.h"
 #include "ipc/StoreMap.h"
 #include "md5.h"
 #include "SquidTime.h"
 #include "store_rebuild.h"
 #include "tools.h"
-#include "typedefs.h"
 
 #include <cerrno>
 
 CBDATA_NAMESPACED_CLASS_INIT(Rock, Rebuild);
 
 /**
  \defgroup RockFsRebuild Rock Store Rebuild
  \ingroup Filesystems
  *
  \section Overview Overview
  *  Several layers of information are manipualted during the rebuild:
  \par
  *  Store Entry: Response message plus all the metainformation associated with
  *  it. Identified by store key. At any given time, from Squid point
  *  of view, there is only one entry with a given key, but several
  *  different entries with the same key can be observed in any historical
  *  archive (such as an access log or a store database).
  \par
  *  Slot chain: A sequence of db slots representing a Store Entry state at
  *  some point in time. Identified by key+version combination. Due to
  *  transaction aborts, crashes, and idle periods, some chains may contain
  *  incomplete or stale information. We assume that no two different chains
  *  have the same key and version. If that assumption fails, we may serve a
  *  hodgepodge entry during rebuild, until "extra" slots are loaded/noticed.
  \par
  *  Db slot: A db record containing a piece of a single store entry and linked
  *  to other slots with the same key and version fields, forming a chain.
  *  Slots are identified by their absolute position in the database file,
  *  which is naturally unique.
  \par

=== modified file 'src/fs/ufs/UFSSwapDir.cc'
--- src/fs/ufs/UFSSwapDir.cc	2015-08-29 18:01:56 +0000
+++ src/fs/ufs/UFSSwapDir.cc	2015-08-30 02:05:49 +0000
@@ -108,61 +108,60 @@
             unlink(newLog);
             sd->cleanLog = NULL;
             delete this;
             return;
         }
 
         outbuf_offset = 0;
     }
 }
 
 bool
 Fs::Ufs::UFSSwapDir::canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const
 {
     if (!SwapDir::canStore(e, diskSpaceNeeded, load))
         return false;
 
     if (IO->shedLoad())
         return false;
 
     load = IO->load();
     return true;
 }
 
 static void
 FreeObject(void *address)
 {
     StoreSwapLogData *anObject = static_cast <StoreSwapLogData *>(address);
     delete anObject;
 }
 
-static QS rev_int_sort;
 static int
 rev_int_sort(const void *A, const void *B)
 {
     const int *i1 = (const int *)A;
     const int *i2 = (const int *)B;
     return *i2 - *i1;
 }
 
 void
 Fs::Ufs::UFSSwapDir::parseSizeL1L2()
 {
     int i = GetInteger();
     if (i <= 0)
         fatal("UFSSwapDir::parseSizeL1L2: invalid size value");
 
     const uint64_t size = static_cast<uint64_t>(i) << 20; // MBytes to Bytes
 
     /* just reconfigure it */
     if (reconfiguring) {
         if (size == maxSize())
             debugs(3, 2, "Cache dir '" << path << "' size remains unchanged at " << i << " MB");
         else
             debugs(3, DBG_IMPORTANT, "Cache dir '" << path << "' size changed to " << i << " MB");
     }
 
     max_size = size;
 
     l1 = GetInteger();
 
     if (l1 <= 0)

=== modified file 'src/helper.cc'
--- src/helper.cc	2015-06-05 06:12:06 +0000
+++ src/helper.cc	2015-08-29 20:12:55 +0000
@@ -483,62 +483,60 @@
             StatefulEnqueue(this, r);
     }
 
     debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
            "', " << Raw("buf", buf, (!buf?0:strlen(buf))));
 
     if (!queueFull()) {
         full_time = 0;
     } else if (!full_time) {
         debugs(84, 3, id_name << " queue became full");
         full_time = squid_curtime;
     }
 }
 
 /**
  * DPW 2007-05-08
  *
  * helperStatefulReleaseServer tells the helper that whoever was
  * using it no longer needs its services.
  */
 void
 helperStatefulReleaseServer(helper_stateful_server * srv)
 {
     debugs(84, 3, HERE << "srv-" << srv->index << " flags.reserved = " << srv->flags.reserved);
     if (!srv->flags.reserved)
         return;
 
     ++ srv->stats.releases;
 
     srv->flags.reserved = false;
-    if (srv->parent->OnEmptyQueue != NULL && srv->data)
-        srv->parent->OnEmptyQueue(srv->data);
 
     helperStatefulServerDone(srv);
 }
 
 /** return a pointer to the stateful routines data area */
 void *
 helperStatefulServerGetData(helper_stateful_server * srv)
 {
     return srv->data;
 }
 
 void
 helper::packStatsInto(Packable *p, const char *label) const
 {
     if (label)
         p->appendf("%s:\n", label);
 
     p->appendf("  program: %s\n", cmdline->key);
     p->appendf("  number active: %d of %d (%d shutting down)\n", childs.n_active, childs.n_max, (childs.n_running - childs.n_active));
     p->appendf("  requests sent: %d\n", stats.requests);
     p->appendf("  replies received: %d\n", stats.replies);
     p->appendf("  requests timedout: %d\n", stats.timedout);
     p->appendf("  queue length: %d\n", stats.queue_size);
     p->appendf("  avg service time: %d msec\n", stats.avg_svc_time);
     p->append("\n",1);
     p->appendf("%7s\t%7s\t%7s\t%11s\t%11s\t%11s\t%6s\t%7s\t%7s\t%7s\n",
                "ID #",
                "FD",
                "PID",
                "# Requests",
@@ -1235,63 +1233,60 @@
         debugs(84, 3, "GetFirstAvailable: Least-loaded helper is overloaded!");
         return NULL;
     }
 
     debugs(84, 5, "GetFirstAvailable: returning srv-" << selected->index);
     return selected;
 }
 
 static helper_stateful_server *
 StatefulGetFirstAvailable(statefulhelper * hlp)
 {
     dlink_node *n;
     helper_stateful_server *srv = NULL;
     debugs(84, 5, "StatefulGetFirstAvailable: Running servers " << hlp->childs.n_running);
 
     if (hlp->childs.n_running == 0)
         return NULL;
 
     for (n = hlp->servers.head; n != NULL; n = n->next) {
         srv = (helper_stateful_server *)n->data;
 
         if (srv->stats.pending)
             continue;
 
         if (srv->flags.reserved)
             continue;
 
         if (srv->flags.shutdown)
             continue;
 
-        if ((hlp->IsAvailable != NULL) && (srv->data != NULL) && !(hlp->IsAvailable(srv->data)))
-            continue;
-
         debugs(84, 5, "StatefulGetFirstAvailable: returning srv-" << srv->index);
         return srv;
     }
 
     debugs(84, 5, "StatefulGetFirstAvailable: None available.");
     return NULL;
 }
 
 static void
 helperDispatchWriteDone(const Comm::ConnectionPointer &, char *, size_t, Comm::Flag flag, int, void *data)
 {
     helper_server *srv = (helper_server *)data;
 
     srv->writebuf->clean();
     delete srv->writebuf;
     srv->writebuf = NULL;
     srv->flags.writing = false;
 
     if (flag != Comm::OK) {
         /* Helper server has crashed */
         debugs(84, DBG_CRITICAL, "helperDispatch: Helper " << srv->parent->id_name << " #" << srv->index << " has crashed");
         return;
     }
 
     if (!srv->wqueue->isNull()) {
         srv->writebuf = srv->wqueue;
         srv->wqueue = new MemBuf;
         srv->flags.writing = true;
         AsyncCall::Pointer call = commCbCall(5,5, "helperDispatchWriteDone",
                                              CommIoCbPtrFun(helperDispatchWriteDone, srv));

=== modified file 'src/helper.h'
--- src/helper.h	2015-06-05 05:56:36 +0000
+++ src/helper.h	2015-08-29 20:12:55 +0000
@@ -1,57 +1,58 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 84    Helper process maintenance */
 
 #ifndef SQUID_HELPER_H
 #define SQUID_HELPER_H
 
 #include "base/AsyncCall.h"
 #include "base/InstanceId.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "dlink.h"
 #include "helper/ChildConfig.h"
 #include "helper/forward.h"
 #include "ip/Address.h"
 #include "SBuf.h"
 
 #include <list>
 #include <map>
 
 class Packable;
+class wordlist;
 
 /**
  * Managers a set of individual helper processes with a common queue of requests.
  *
  * With respect to load, a helper goes through these states (roughly):
  *   idle:   no processes are working on requests (and no requests are queued);
  *   normal: some, but not all processes are working (and no requests are queued);
  *   busy:   all processes are working (and some requests are possibly queued);
  *   full:   all processes are working and at least 2*#processes requests are queued.
  *
  * A "busy" helper queues new requests and issues a WARNING every 10 minutes or so.
  * A "full" helper either drops new requests or keeps queuing them, depending on
  *   whether the caller can handle dropped requests (trySubmit vs helperSubmit APIs).
  * An attempt to use a "full" helper that has been "full" for 3+ minutes kills worker.
  *   Given enough load, all helpers except for external ACL will make such attempts.
  */
 class helper
 {
     CBDATA_CLASS(helper);
 
 public:
     inline helper(const char *name) :
         cmdline(NULL),
         id_name(name),
         ipc_type(0),
         full_time(0),
         last_queue_warn(0),
         last_restart(0),
         timeout(0),
         retryTimedOut(false),
@@ -83,67 +84,65 @@
     int ipc_type;
     Ip::Address addr;
     time_t full_time; ///< when a full helper became full (zero for non-full helpers)
     time_t last_queue_warn;
     time_t last_restart;
     time_t timeout; ///< Requests timeout
     bool retryTimedOut; ///< Whether the timed-out requests must retried
     bool retryBrokenHelper; ///< Whether the requests must retried on BH replies
     SBuf onTimedOutResponse; ///< The response to use when helper response timedout
     char eom;   ///< The char which marks the end of (response) message, normally '\n'
 
     struct _stats {
         int requests;
         int replies;
         int timedout;
         int queue_size;
         int avg_svc_time;
     } stats;
 
 protected:
     friend void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data);
     void prepSubmit();
     void submit(const char *buf, HLPCB * callback, void *data);
 };
 
 class statefulhelper : public helper
 {
     CBDATA_CLASS(statefulhelper);
 
 public:
-    inline statefulhelper(const char *name) : helper(name), datapool(NULL), IsAvailable(NULL), OnEmptyQueue(NULL) {}
+    inline statefulhelper(const char *name) : helper(name), datapool(NULL) {}
     inline ~statefulhelper() {}
 
 public:
     MemAllocator *datapool;
-    HLPSAVAIL *IsAvailable;
-    HLPSONEQ *OnEmptyQueue;
 
 private:
     friend void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver);
     void submit(const char *buf, HLPCB * callback, void *data, helper_stateful_server *lastserver);
 };
 
 /**
  * Fields shared between stateless and stateful helper servers.
  */
 class HelperServerBase
 {
 public:
     /** Closes pipes to the helper safely.
      * Handles the case where the read and write pipes are the same FD.
      *
      * \param name displayed for the helper being shutdown if logging an error
      */
     void closePipesSafely(const char *name);
 
     /** Closes the reading pipe.
      * If the read and write sockets are the same the write pipe will
      * also be closed. Otherwise its left open for later handling.
      *
      * \param name displayed for the helper being shutdown if logging an error
      */
     void closeWritePipeSafely(const char *name);
 
 public:
     /// Helper program identifier; does not change when contents do,
     ///   including during assignment

=== modified file 'src/htcp.h'
--- src/htcp.h	2015-01-13 07:25:36 +0000
+++ src/htcp.h	2015-08-29 20:12:55 +0000
@@ -1,46 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_HTCP_H
 #define SQUID_HTCP_H
 
 #if USE_HTCP
 
 #include "http/forward.h"
 #include "HttpHeader.h"
 #include "ip/forward.h"
+#include "store_key_md5.h"
 
 /// \ingroup ServerProtocolHTCP
 class HtcpReplyData
 {
 
 public:
     HtcpReplyData();
     int hit;
     HttpHeader hdr;
     uint32_t msg_id;
     double version;
 
     struct cto_t {
         /* cache-to-origin */
         double rtt;
         int samp;
         int hops;
     } cto;
 };
 
 /// \ingroup ServerProtocolHTCP
 void neighborsHtcpReply(const cache_key *, HtcpReplyData *, const Ip::Address &);
 
 /// \ingroup ServerProtocolHTCP
 void htcpOpenPorts(void);
 
 /**
  * \ingroup ServerProtocolHTCP
  *
  * Generate and Send an HTCP query to the specified peer.

=== modified file 'src/icmp/net_db.cc'
--- src/icmp/net_db.cc	2015-07-19 13:23:01 +0000
+++ src/icmp/net_db.cc	2015-08-29 20:12:55 +0000
@@ -91,63 +91,60 @@
 
     CachePeer *p;
     StoreEntry *e;
     store_client *sc;
     HttpRequest *r;
     int64_t used;
     size_t buf_sz;
     char buf[NETDB_REQBUF_SZ];
     int buf_ofs;
     netdb_conn_state_t connstate;
 };
 
 CBDATA_CLASS_INIT(netdbExchangeState);
 
 static hash_table *addr_table = NULL;
 static hash_table *host_table = NULL;
 
 Ip::Address networkFromInaddr(const Ip::Address &a);
 static void netdbRelease(netdbEntry * n);
 
 static void netdbHashInsert(netdbEntry * n, Ip::Address &addr);
 static void netdbHashDelete(const char *key);
 static void netdbHostInsert(netdbEntry * n, const char *hostname);
 static void netdbHostDelete(const net_db_name * x);
 static void netdbPurgeLRU(void);
 static netdbEntry *netdbLookupHost(const char *key);
 static net_db_peer *netdbPeerByName(const netdbEntry * n, const char *);
 static net_db_peer *netdbPeerAdd(netdbEntry * n, CachePeer * e);
 static const char *netdbPeerName(const char *name);
 static IPH netdbSendPing;
-static QS sortPeerByRtt;
-static QS sortByRtt;
-static QS netdbLRU;
 static FREE netdbFreeNameEntry;
 static FREE netdbFreeNetdbEntry;
 static STCB netdbExchangeHandleReply;
 
 /* We have to keep a local list of CachePeer names.  The Peers structure
  * gets freed during a reconfigure.  We want this database to
  * remain persisitent, so _net_db_peer->peername points into this
  * linked list */
 static wordlist *peer_names = NULL;
 
 static void
 netdbHashInsert(netdbEntry * n, Ip::Address &addr)
 {
     networkFromInaddr(addr).toStr(n->network, MAX_IPSTRLEN);
     n->hash.key = n->network;
     assert(hash_lookup(addr_table, n->network) == NULL);
     hash_join(addr_table, &n->hash);
 }
 
 static void
 netdbHashDelete(const char *key)
 {
     hash_link *hptr = (hash_link *)hash_lookup(addr_table, key);
 
     if (hptr == NULL) {
         debug_trap("netdbHashDelete: key not found");
         return;
     }
 
     hash_remove_link(addr_table, hptr);

=== modified file 'src/ip/forward.h'
--- src/ip/forward.h	2015-01-13 07:25:36 +0000
+++ src/ip/forward.h	2015-08-29 20:12:55 +0000
@@ -1,21 +1,25 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 14    IP Storage and Handling */
 
 #ifndef _SQUID_IP_FORWARD_H
 #define _SQUID_IP_FORWARD_H
 
 // Forward-declare Ip classes needed by reference in other parts of the code
 // for passing objects around without actually touching them
 namespace Ip
 {
 class Address;
 }
+
+typedef uint32_t nfmark_t;
+typedef unsigned char tos_t;
+
 #endif /* _SQUID_IP_FORWARD_H */
 

=== modified file 'src/ipc/MemMap.h'
--- src/ipc/MemMap.h	2015-06-02 15:41:52 +0000
+++ src/ipc/MemMap.h	2015-08-29 20:12:55 +0000
@@ -1,48 +1,49 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_IPC_STORE_MAP_H
 #define SQUID_IPC_STORE_MAP_H
 
 #include "Debug.h"
 #include "ipc/mem/FlexibleArray.h"
 #include "ipc/mem/Pointer.h"
 #include "ipc/ReadWriteLock.h"
 #include "SBuf.h"
+#include "store_key_md5.h"
 #include "tools.h"
-#include "typedefs.h"
+#include "fs/forward.h"
 
 #include <atomic>
 
 namespace Ipc
 {
 
 // The MEMMAP_SLOT_KEY_SIZE and MEMMAP_SLOT_DATA_SIZE must be enough big
 // to hold cached keys and data. Currently MemMap used only to store SSL
 // shared session data which have keys of 32bytes and at most 10K data
 #define MEMMAP_SLOT_KEY_SIZE 32
 #define MEMMAP_SLOT_DATA_SIZE 10*1024
 
 /// a MemMap basic element, holding basic shareable memory block info
 class MemMapSlot
 {
 public:
     MemMapSlot();
     size_t size() const {return sizeof(MemMapSlot);}
     size_t keySize() const {return sizeof(key);}
     bool sameKey(const cache_key *const aKey) const;
     void set(const unsigned char *aKey, const void *block, size_t blockSize, time_t expire = 0);
     bool empty() const;
     bool reading() const { return lock.readers; }
     bool writing() const { return lock.writing; }
 
     std::atomic<uint8_t> waitingToBeFreed; ///< may be accessed w/o a lock
     mutable ReadWriteLock lock; ///< protects slot data below
     unsigned char key[MEMMAP_SLOT_KEY_SIZE]; ///< The entry key
     unsigned char p[MEMMAP_SLOT_DATA_SIZE]; ///< The memory block;
     size_t pSize;

=== modified file 'src/ipc/StoreMap.h'
--- src/ipc/StoreMap.h	2015-06-02 11:05:22 +0000
+++ src/ipc/StoreMap.h	2015-08-29 20:12:55 +0000
@@ -1,46 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_IPC_STORE_MAP_H
 #define SQUID_IPC_STORE_MAP_H
 
 #include "ipc/mem/FlexibleArray.h"
 #include "ipc/mem/Pointer.h"
 #include "ipc/ReadWriteLock.h"
 #include "SBuf.h"
-#include "typedefs.h"
+#include "fs/forward.h"
+#include "store_key_md5.h"
 
 namespace Ipc
 {
 
 typedef int32_t StoreMapSliceId;
 
 /// a piece of Store entry, linked to other pieces, forming a chain
 /// slices may be appended by writers while readers read the entry
 class StoreMapSlice
 {
 public:
     typedef uint32_t Size;
 
     StoreMapSlice(): size(0), next(-1) {}
     StoreMapSlice(const StoreMapSlice &o) {
         size.exchange(o.size);
         next.exchange(o.next);
     }
 
     StoreMapSlice &operator =(const StoreMapSlice &o) {
         size.store(o.size);
         next.store(o.next);
         return *this;
     }
 
     std::atomic<Size> size; ///< slice contents size
     std::atomic<StoreMapSliceId> next; ///< ID of the next entry slice
 };
 
 /// Maintains shareable information about a StoreEntry as a whole.

=== modified file 'src/mem/forward.h'
--- src/mem/forward.h	2015-08-27 21:44:42 +0000
+++ src/mem/forward.h	2015-08-29 20:12:55 +0000
@@ -1,66 +1,66 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 13    High Level Memory Pool Management */
 
 #ifndef _SQUID_SRC_MEM_FORWARD_H
 #define _SQUID_SRC_MEM_FORWARD_H
 
 #include "mem/AllocatorProxy.h"
-/* for FREE */
-#include "typedefs.h"
 
 #include <iosfwd>
 
 class StoreEntry;
 class MemPoolStats;
 class MemPoolMeter;
 
 /// Memory Management
 namespace Mem
 {
 void Init();
 void Report();
 void Stats(StoreEntry *);
 void CleanIdlePools(void *unused);
 void Report(std::ostream &);
 void PoolReport(const MemPoolStats * mp_st, const MemPoolMeter * AllMeter, std::ostream &);
 };
 
 extern const size_t squidSystemPageSize;
 
+typedef void FREE(void *);
+
 /// Types of memory pool which do not yet use MEMPROXY_CLASS() API
 typedef enum {
     MEM_NONE,
     MEM_2K_BUF,
     MEM_4K_BUF,
     MEM_8K_BUF,
     MEM_16K_BUF,
     MEM_32K_BUF,
     MEM_64K_BUF,
     MEM_ACL_DENY_INFO_LIST,
     MEM_ACL_NAME_LIST,
 #if USE_CACHE_DIGESTS
     MEM_CACHE_DIGEST,
 #endif
     MEM_CLIENT_INFO,
     MEM_LINK_LIST,
     MEM_DLINK_NODE,
     MEM_DREAD_CTRL,
     MEM_DWRITE_Q,
     MEM_HTTP_HDR_CONTENT_RANGE,
     MEM_MD5_DIGEST,
     MEM_NETDBENTRY,
     MEM_NET_DB_NAME,
     // IMPORTANT: leave this here. pools above are initialized early with memInit()
     MEM_DONTFREE,
     // following pools are initialized late by their component if needed (or never)
     MEM_FQDNCACHE_ENTRY,
     MEM_FWD_SERVER,
     MEM_IDNS_QUERY,
     MEM_IPCACHE_ENTRY,

=== modified file 'src/neighbors.h'
--- src/neighbors.h	2015-06-09 06:14:43 +0000
+++ src/neighbors.h	2015-08-29 20:12:55 +0000
@@ -1,46 +1,47 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 15    Neighbor Routines */
 
 #ifndef SQUID_NEIGHBORS_H_
 #define SQUID_NEIGHBORS_H_
 
 #include "enums.h"
 #include "ICP.h"
 #include "lookup_t.h"
+#include "typedefs.h" //for IRCB
 
 class HttpRequest;
 class HttpRequestMethod;
 class CachePeer;
 class StoreEntry;
 class URL;
 
 CachePeer *getFirstPeer(void);
 CachePeer *getFirstUpParent(HttpRequest *);
 CachePeer *getNextPeer(CachePeer *);
 CachePeer *getSingleParent(HttpRequest *);
 int neighborsCount(HttpRequest *);
 int neighborsUdpPing(HttpRequest *,
                      StoreEntry *,
                      IRCB * callback,
                      void *data,
                      int *exprep,
                      int *timeout);
 void neighborAddAcl(const char *, const char *);
 
 void neighborsUdpAck(const cache_key *, icp_common_t *, const Ip::Address &);
 void neighborAdd(const char *, const char *, int, int, int, int, int);
 void neighbors_init(void);
 #if USE_HTCP
 void neighborsHtcpClear(StoreEntry *, const char *, HttpRequest *, const HttpRequestMethod &, htcp_clr_reason);
 #endif
 CachePeer *peerFindByName(const char *);
 CachePeer *peerFindByNameAndPort(const char *, unsigned short);
 CachePeer *getDefaultParent(HttpRequest * request);
 CachePeer *getRoundRobinParent(HttpRequest * request);

=== modified file 'src/snmp_agent.h'
--- src/snmp_agent.h	2015-01-13 07:25:36 +0000
+++ src/snmp_agent.h	2015-08-29 20:12:55 +0000
@@ -1,30 +1,31 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 49    SNMP Interface */
 
 #ifndef SQUID_SNMP_AGENT_H_
 #define SQUID_SNMP_AGENT_H_
 
 #if SQUID_SNMP
 
+#include "cache_snmp.h"
 #include "snmp_vars.h"
 
 variable_list *snmp_confFn(variable_list *, snint *);
 variable_list *snmp_sysFn(variable_list *, snint *);
 variable_list *snmp_prfSysFn(variable_list *, snint *);
 variable_list *snmp_prfProtoFn(variable_list *, snint *);
 variable_list *snmp_netIpFn(variable_list *, snint *);
 variable_list *snmp_netFqdnFn(variable_list *, snint *);
 variable_list *snmp_netDnsFn(variable_list *, snint *);
 variable_list *snmp_meshPtblFn(variable_list *, snint *);
 variable_list *snmp_meshCtblFn(variable_list *, snint *);
 
 #endif /* SQUID_SNMP */
 #endif /* SQUID_SNMP_AGENT_H_ */
 

=== modified file 'src/snmp_core.h'
--- src/snmp_core.h	2015-01-13 07:25:36 +0000
+++ src/snmp_core.h	2015-08-29 20:12:55 +0000
@@ -1,56 +1,53 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 49    SNMP Interface */
 
 #ifndef SQUID_SNMP_CORE_H
 #define SQUID_SNMP_CORE_H
 
 #include "cache_snmp.h"
 #include "comm/forward.h"
-#include "typedefs.h"
+#include "ip/forward.h"
 
-namespace Ip
-{
-class Address;
-}
 class MemBuf;
 
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
 
+typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
 typedef struct _mib_tree_entry mib_tree_entry;
 typedef oid *(instance_Fn) (oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 typedef enum {atNone = 0, atSum, atAverage, atMax, atMin} AggrType;
 
 struct _mib_tree_entry {
     oid *name;
     int len;
     oid_ParseFn *parsefunction;
     instance_Fn *instancefunction;
     int children;
 
     struct _mib_tree_entry **leaves;
 
     struct _mib_tree_entry *parent;
     AggrType aggrType;
 };
 
 struct snmp_pdu* snmpAgentResponse(struct snmp_pdu* PDU);
 AggrType snmpAggrType(oid* Current, snint CurrentLen);
 
 extern Comm::ConnectionPointer snmpOutgoingConn;
 
 extern PF snmpHandleUdp;
 void snmpInit(void);
 void snmpOpenPorts(void);
 void snmpClosePorts(void);
 const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
 void addr2oid(Ip::Address &addr, oid *Dest);
 void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
 

=== modified file 'src/store_key_md5.h'
--- src/store_key_md5.h	2015-01-13 07:25:36 +0000
+++ src/store_key_md5.h	2015-08-29 20:12:55 +0000
@@ -1,37 +1,39 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 20    Storage Manager MD5 Cache Keys */
 
 #ifndef SQUID_STORE_KEY_MD5_H_
 #define SQUID_STORE_KEY_MD5_H_
 
 #include "hash.h"
-#include "typedefs.h"
 
 class HttpRequestMethod;
 class HttpRequest;
 
+/* MD5 cache keys */
+typedef unsigned char cache_key;
+
 cache_key *storeKeyDup(const cache_key *);
 cache_key *storeKeyCopy(cache_key *, const cache_key *);
 void storeKeyFree(const cache_key *);
 const cache_key *storeKeyScan(const char *);
 const char *storeKeyText(const cache_key *);
 const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
 const cache_key *storeKeyPublicByRequest(HttpRequest *);
 const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
 const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
 int storeKeyHashBuckets(int);
 int storeKeyNull(const cache_key *);
 void storeKeyInit(void);
 
 extern HASHHASH storeKeyHashHash;
 extern HASHCMP storeKeyHashCmp;
 
 #endif /* SQUID_STORE_KEY_MD5_H_ */
 

=== modified file 'src/store_rebuild.h'
--- src/store_rebuild.h	2015-07-09 15:15:02 +0000
+++ src/store_rebuild.h	2015-08-29 20:12:55 +0000
@@ -1,43 +1,45 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 20    Store Rebuild Routines */
 
 #ifndef SQUID_STORE_REBUILD_H_
 #define SQUID_STORE_REBUILD_H_
 
+#include "store_key_md5.h"
+
 class StoreRebuildData
 {
 public:
     StoreRebuildData() :
         objcount(0), expcount(0), scancount(0), clashcount(0),
         dupcount(0), cancelcount(0), invalid(0), badflags(0),
         bad_log_op(0), zero_object_sz(0)
     {}
 
     int objcount;       /* # objects successfully reloaded */
     int expcount;       /* # objects expired */
     int scancount;      /* # entries scanned or read from state file */
     int clashcount;     /* # swapfile clashes avoided */
     int dupcount;       /* # duplicates purged */
     int cancelcount;        /* # SWAP_LOG_DEL objects purged */
     int invalid;        /* # bad lines */
     int badflags;       /* # bad e->flags */
     int bad_log_op;
     int zero_object_sz;
 };
 
 void storeRebuildStart(void);
 void storeRebuildComplete(StoreRebuildData *);
 void storeRebuildProgress(int sd_index, int total, int sofar);
 
 /// loads entry from disk; fills supplied memory buffer on success
 bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, StoreRebuildData &counts);
 /// parses entry buffer and validates entry metadata; fills e on success
 bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, StoreRebuildData &counts, uint64_t expectedSize);
 /// checks whether the loaded entry should be kept; updates counters

=== modified file 'src/tests/stub_CacheDigest.cc'
--- src/tests/stub_CacheDigest.cc	2015-01-13 07:25:36 +0000
+++ src/tests/stub_CacheDigest.cc	2015-08-29 20:12:55 +0000
@@ -1,32 +1,32 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "typedefs.h" /* for cache_key */
+#include "store_key_md5.h" /* for cache_key */
 
 #define STUB_API "CacheDigest.cc"
 #include "tests/STUB.h"
 
 class CacheDigest;
 class CacheDigestGuessStats;
 class StoreEntry;
 
 CacheDigest * cacheDigestCreate(int, int) STUB_RETVAL(NULL)
 void cacheDigestDestroy(CacheDigest *) STUB
 CacheDigest * cacheDigestClone(const CacheDigest *) STUB_RETVAL(NULL)
 void cacheDigestClear(CacheDigest * ) STUB
 void cacheDigestChangeCap(CacheDigest *,int) STUB
 int cacheDigestTest(const CacheDigest *, const cache_key *) STUB_RETVAL(1)
 void cacheDigestAdd(CacheDigest *, const cache_key *) STUB
 void cacheDigestDel(CacheDigest *, const cache_key *) STUB
 int cacheDigestBitUtil(const CacheDigest *) STUB_RETVAL(0)
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats *, int, int) STUB
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats *, StoreEntry *, const char *) STUB
 void cacheDigestReport(CacheDigest *, const char *, StoreEntry *) STUB
 size_t cacheDigestCalcMaskSize(int, int) STUB_RETVAL(1)
 

=== modified file 'src/tools.h'
--- src/tools.h	2015-08-30 00:26:47 +0000
+++ src/tools.h	2015-08-30 02:05:49 +0000
@@ -8,60 +8,63 @@
 
 /* DEBUG: section 21    Misc Functions */
 
 #ifndef SQUID_TOOLS_H_
 #define SQUID_TOOLS_H_
 
 #include "SBuf.h"
 #include "typedefs.h"
 
 class MemBuf;
 
 extern int DebugSignal;
 
 /// The Squid -n parameter service name.
 /// Default is APP_SHORTNAME ('squid').
 extern SBuf service_name;
 
 void parseEtcHosts(void);
 int getMyPort(void);
 void setUmask(mode_t mask);
 void strwordquote(MemBuf * mb, const char *str);
 
 class Packable;
 
 /* a common objPackInto interface; used by debugObj */
 typedef void (*ObjPackMethod) (void *obj, Packable * p);
 
 /* packs, then prints an object using debugs() */
 void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm);
 
+/// callback type for signal handlers
+typedef void SIGHDLR(int sig);
+
 const char *getMyHostname(void);
 const char *uniqueHostname(void);
 
 void death(int sig);
 void sigusr2_handle(int sig);
 void sig_child(int sig);
 void sig_shutdown(int sig); ///< handles shutdown notifications from kids
 void leave_suid(void);
 void enter_suid(void);
 void no_suid(void);
 void writePidFile(void);
 void removePidFile();
 void setMaxFD(void);
 void setSystemLimits(void);
 void squid_signal(int sig, SIGHDLR *, int flags);
 pid_t readPidFile(void);
 void keepCapabilities(void);
 void BroadcastSignalIfAny(int& sig);
 
 /// whether the current process is the parent of all other Squid processes
 bool IamMasterProcess();
 /**
  *   whether the current process is dedicated to doing things that only
  *   a single process should do, such as PID file maintenance and WCCP
  */
 bool IamPrimaryProcess();
 /// whether the current process coordinates worker processes
 bool IamCoordinatorProcess();
 /// whether the current process handles HTTP transactions and such
 bool IamWorkerProcess();

=== modified file 'src/typedefs.h'
--- src/typedefs.h	2015-08-30 00:26:47 +0000
+++ src/typedefs.h	2015-08-30 02:06:46 +0000
@@ -1,88 +1,23 @@
 /*
  * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#include "enums.h"
-
 #ifndef SQUID_TYPEDEFS_H
 #define SQUID_TYPEDEFS_H
 
-typedef int32_t sfileno;
-typedef signed int sdirno;
-
-typedef uint32_t nfmark_t;
-typedef unsigned char tos_t;
-
-typedef struct _CommWriteStateData CommWriteStateData;
-
-#if SQUID_SNMP
-#include "cache_snmp.h"
-typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
-#endif
-
-typedef void FREE(void *);
-typedef void FOCB(void *, int fd, int errcode);
-typedef void PF(int, void *);
+#include "enums.h"
 
 /* disk.c / diskd.c callback typedefs */
 typedef void DRCB(int, const char *buf, int size, int errflag, void *data);
 /* Disk read CB */
 typedef void DWCB(int, int, size_t, void *);    /* disk write CB */
-typedef void DOCB(int, int errflag, void *data);    /* disk open CB */
-typedef void DCCB(int, int errflag, void *data);    /* disk close CB */
-typedef void DUCB(int errflag, void *data); /* disk unlink CB */
-typedef void DTCB(int errflag, void *data); /* disk trunc CB */
-
-namespace Dns
-{
-class LookupDetails;
-}
-typedef void FQDNH(const char *, const Dns::LookupDetails &details, void *);
 
 #include "anyp/ProtocolType.h"
 class CachePeer;
 typedef void IRCB(CachePeer *, peer_t, AnyP::ProtocolType, void *, void *data);
 
-/* in wordlist.h */
-
-class wordlist;
-typedef void UH(void *data, wordlist *);
-
-/**
- * READ_HANDLER functions return < 0 if, and only if, they fail with an error.
- * On error, they must pass back an error code in 'errno'.
- */
-typedef int READ_HANDLER(int, char *, int);
-
-/**
- * WRITE_HANDLER functions return < 0 if, and only if, they fail with an error.
- * On error, they must pass back an error code in 'errno'.
- */
-typedef int WRITE_HANDLER(int, const char *, int);
-
-typedef int QS(const void *, const void *); /* qsort */
-typedef void STABH(void *);
-typedef void ERCB(int fd, void *, size_t);
-class StoreEntry;
-typedef void SIGHDLR(int sig);
-typedef void STVLDCB(void *, int, int);
-typedef int HLPSAVAIL(void *);
-typedef void HLPSONEQ(void *);
-typedef void HLPCMDOPTS(int *argc, char **argv);
-
-/* MD5 cache keys */
-typedef unsigned char cache_key;
-
-/* in case we want to change it later */
-typedef ssize_t mb_size_t;
-
-typedef int STDIRSELECT(const StoreEntry *);
-
-/*Use uint64_t to store miliseconds*/
-typedef uint64_t time_msec_t;
 #endif /* SQUID_TYPEDEFS_H */
-

=== modified file 'src/urn.cc'
--- src/urn.cc	2015-08-04 19:57:07 +0000
+++ src/urn.cc	2015-08-29 20:12:55 +0000
@@ -42,61 +42,60 @@
 
     StoreEntry *entry;
     store_client *sc;
     StoreEntry *urlres_e;
     HttpRequest::Pointer request;
     HttpRequest::Pointer urlres_r;
 
     struct {
         bool force_menu;
     } flags;
     char reqbuf[URN_REQBUF_SZ];
     int reqofs;
 
 private:
     char *urlres;
 };
 
 typedef struct {
     char *url;
     char *host;
     int rtt;
 
     struct {
         int cached;
     } flags;
 } url_entry;
 
 static STCB urnHandleReply;
 static url_entry *urnParseReply(const char *inbuf, const HttpRequestMethod&);
 static const char *const crlf = "\r\n";
-static QS url_entry_sort;
 
 CBDATA_CLASS_INIT(UrnState);
 
 UrnState::~UrnState()
 {
     safe_free(urlres);
 }
 
 static url_entry *
 urnFindMinRtt(url_entry * urls, const HttpRequestMethod &, int *rtt_ret)
 {
     int min_rtt = 0;
     url_entry *u = NULL;
     url_entry *min_u = NULL;
     int i;
     int urlcnt = 0;
     debugs(52, 3, "urnFindMinRtt");
     assert(urls != NULL);
 
     for (i = 0; NULL != urls[i].url; ++i)
         ++urlcnt;
 
     debugs(53, 3, "urnFindMinRtt: Counted " << i << " URLs");
 
     if (1 == urlcnt) {
         debugs(52, 3, "urnFindMinRtt: Only one URL - return it!");
         return urls;
     }
 
     for (i = 0; i < urlcnt; ++i) {

