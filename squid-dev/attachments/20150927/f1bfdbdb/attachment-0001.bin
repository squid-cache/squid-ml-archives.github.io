=== modified file 'src/auth/digest/Config.cc'
--- src/auth/digest/Config.cc	2015-08-25 14:36:54 +0000
+++ src/auth/digest/Config.cc	2015-09-27 17:34:40 +0000
@@ -18,55 +18,49 @@
 #include "auth/digest/User.h"
 #include "auth/digest/UserRequest.h"
 #include "auth/Gadgets.h"
 #include "auth/State.h"
 #include "base/LookupTable.h"
 #include "base64.h"
 #include "cache_cf.h"
 #include "event.h"
 #include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "rfc2617.h"
 #include "SBuf.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
 #include "wordlist.h"
 
-/* digest_nonce_h still uses explicit alloc()/freeOne() MemPool calls.
- * XXX: convert to MEMPROXY_CLASS() API
- */
-#include "mem/Pool.h"
-
 #include <random>
 
 static AUTHSSTATS authenticateDigestStats;
 
 helper *digestauthenticators = NULL;
 
 static hash_table *digest_nonce_cache;
 
 static int authdigest_initialised = 0;
-static MemAllocator *digest_nonce_pool = NULL;
 
 enum http_digest_attr_type {
     DIGEST_USERNAME,
     DIGEST_REALM,
     DIGEST_QOP,
     DIGEST_ALGORITHM,
     DIGEST_URI,
     DIGEST_NONCE,
     DIGEST_NC,
     DIGEST_CNONCE,
     DIGEST_RESPONSE,
     DIGEST_INVALID_ATTR
 };
 
 static const LookupTable<http_digest_attr_type>::Record
 DigestAttrs[] = {
     {"username", DIGEST_USERNAME},
     {"realm", DIGEST_REALM},
     {"qop", DIGEST_QOP},
     {"algorithm", DIGEST_ALGORITHM},
@@ -100,166 +94,146 @@ static void authDigestNonceUserUnlink(di
 
 static void
 authDigestNonceEncode(digest_nonce_h * nonce)
 {
     if (!nonce)
         return;
 
     if (nonce->key)
         xfree(nonce->key);
 
     nonce->key = xcalloc(base64_encode_len(sizeof(digest_nonce_data)), 1);
     struct base64_encode_ctx ctx;
     base64_encode_init(&ctx);
     size_t blen = base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(nonce->key), sizeof(digest_nonce_data), reinterpret_cast<const uint8_t*>(&(nonce->noncedata)));
     blen += base64_encode_final(&ctx, reinterpret_cast<uint8_t*>(nonce->key)+blen);
 }
 
 digest_nonce_h *
 authenticateDigestNonceNew(void)
 {
-    digest_nonce_h *newnonce = static_cast < digest_nonce_h * >(digest_nonce_pool->alloc());
+    // NP: this will likely produce the same randomness sequences for each worker
+    // since they should all start within the 1-second resolution of seed value.
+    digest_nonce_h *newnonce = new digest_nonce_h();
 
     /* NONCE CREATION - NOTES AND REASONING. RBC 20010108
      * === EXCERPT FROM RFC 2617 ===
      * The contents of the nonce are implementation dependent. The quality
      * of the implementation depends on a good choice. A nonce might, for
      * example, be constructed as the base 64 encoding of
      *
      * time-stamp H(time-stamp ":" ETag ":" private-key)
      *
      * where time-stamp is a server-generated time or other non-repeating
      * value, ETag is the value of the HTTP ETag header associated with
      * the requested entity, and private-key is data known only to the
      * server.  With a nonce of this form a server would recalculate the
      * hash portion after receiving the client authentication header and
      * reject the request if it did not match the nonce from that header
      * or if the time-stamp value is not recent enough. In this way the
      * server can limit the time of the nonce's validity. The inclusion of
      * the ETag prevents a replay request for an updated version of the
      * resource.  (Note: including the IP address of the client in the
      * nonce would appear to offer the server the ability to limit the
      * reuse of the nonce to the same client that originally got it.
      * However, that would break proxy farms, where requests from a single
      * user often go through different proxies in the farm. Also, IP
      * address spoofing is not that hard.)
      * ====
      *
      * Now for my reasoning:
      * We will not accept a unrecognised nonce->we have all recognisable
      * nonces stored. If we send out unique base64 encodings we guarantee
      * that a given nonce applies to only one user (barring attacks or
      * really bad timing with expiry and creation).  Using a random
      * component in the nonce allows us to loop to find a unique nonce.
      * We use H(nonce_data) so the nonce is meaningless to the reciever.
      * So our nonce looks like base64(H(timestamp,pointertohash,randomdata))
      * And even if our randomness is not very random we don't really care
      * - the timestamp and memory pointer also guarantee local uniqueness
      * in the input to the hash function.
      */
-    // NP: this will likely produce the same randomness sequences for each worker
-    // since they should all start within the 1-second resolution of seed value.
-    static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
-    static xuniform_int_distribution<uint32_t> newRandomData;
-
-    /* create a new nonce */
-    newnonce->nc = 0;
-    newnonce->flags.valid = true;
-    newnonce->noncedata.self = newnonce;
-    newnonce->noncedata.creationtime = current_time.tv_sec;
-    newnonce->noncedata.randomdata = newRandomData(mt);
 
     authDigestNonceEncode(newnonce);
 
     // ensure temporal uniqueness by checking for existing nonce
     while (authenticateDigestNonceFindNonce((char const *) (newnonce->key))) {
         /* create a new nonce */
-        newnonce->noncedata.randomdata = newRandomData(mt);
+        newnonce->noncedata.refreshRandomData();
         authDigestNonceEncode(newnonce);
     }
 
     hash_join(digest_nonce_cache, newnonce);
     /* the cache's link */
     authDigestNonceLink(newnonce);
     newnonce->flags.incache = true;
     debugs(29, 5, "created nonce " << newnonce << " at " << newnonce->noncedata.creationtime);
     return newnonce;
 }
 
 static void
 authenticateDigestNonceDelete(digest_nonce_h * nonce)
 {
     if (nonce) {
         assert(nonce->references == 0);
 #if UNREACHABLECODE
 
         if (nonce->flags.incache)
             hash_remove_link(digest_nonce_cache, nonce);
 
 #endif
 
         assert(!nonce->flags.incache);
 
         safe_free(nonce->key);
 
-        digest_nonce_pool->freeOne(nonce);
     }
 }
 
 static void
 authenticateDigestNonceSetup(void)
 {
-    if (!digest_nonce_pool)
-        digest_nonce_pool = memPoolCreate("Digest Scheme nonce's", sizeof(digest_nonce_h));
-
     if (!digest_nonce_cache) {
         digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
         assert(digest_nonce_cache);
         eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->nonceGCInterval, 1);
     }
 }
 
 void
 authenticateDigestNonceShutdown(void)
 {
     /*
      * We empty the cache of any nonces left in there.
      */
     digest_nonce_h *nonce;
 
     if (digest_nonce_cache) {
         debugs(29, 2, "Shutting down nonce cache");
         hash_first(digest_nonce_cache);
 
         while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
             assert(nonce->flags.incache);
             authDigestNoncePurge(nonce);
         }
     }
 
-#if DEBUGSHUTDOWN
-    if (digest_nonce_pool) {
-        delete digest_nonce_pool;
-        digest_nonce_pool = NULL;
-    }
-
-#endif
     debugs(29, 2, "Nonce cache shutdown");
 }
 
 static void
 authenticateDigestNonceCacheCleanup(void *)
 {
     /*
      * We walk the hash by nonceb64 as that is the unique key we
      * use.  For big hash tables we could consider stepping through
      * the cache, 100/200 entries at a time. Lets see how it flies
      * first.
      */
     digest_nonce_h *nonce;
     debugs(29, 3, "Cleaning the nonce cache now");
     debugs(29, 3, "Current time: " << current_time.tv_sec);
     hash_first(digest_nonce_cache);
 
     while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
         debugs(29, 3, "nonce entry  : " << nonce << " '" << (char *) nonce->key << "'");
         debugs(29, 4, "Creation time: " << nonce->noncedata.creationtime);
@@ -1068,20 +1042,41 @@ Auth::Digest::Config::decode(char const
         digest_user = static_cast<Auth::Digest::User *>(auth_user.getRaw());
         digest_user->credentials(Auth::Unchecked);
         xfree(username);
     }
 
     /*link the request and the user */
     assert(digest_request != NULL);
 
     digest_request->user(digest_user);
     debugs(29, 9, "username = '" << digest_user->username() << "'\nrealm = '" <<
            digest_request->realm << "'\nqop = '" << digest_request->qop <<
            "'\nalgorithm = '" << digest_request->algorithm << "'\nuri = '" <<
            digest_request->uri << "'\nnonce = '" << digest_request->nonceb64 <<
            "'\nnc = '" << digest_request->nc << "'\ncnonce = '" <<
            digest_request->cnonce << "'\nresponse = '" <<
            digest_request->response << "'\ndigestnonce = '" << nonce << "'");
 
     return digest_request;
 }
 
+digest_nonce_data::digest_nonce_data(digest_nonce_h *digestNonceReference) :
+    creationtime(squid_curtime), self(digestNonceReference)
+{
+    refreshRandomData();
+}
+
+void
+digest_nonce_data::refreshRandomData() {
+    //intentionally set as static members instead of data members so that
+    // they get initialized on demand
+    static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
+    static xuniform_int_distribution<uint32_t> newRandomData;
+    randomdata = newRandomData(mt);
+}
+
+digest_nonce_h::digest_nonce_h() :
+    noncedata(this), nc(0), references(0), user(nullptr)
+{
+    flags.valid = true;
+    flags.incache = false;
+}

=== modified file 'src/auth/digest/Config.h'
--- src/auth/digest/Config.h	2015-08-04 19:57:07 +0000
+++ src/auth/digest/Config.h	2015-09-27 17:32:13 +0000
@@ -6,55 +6,60 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef __AUTH_DIGEST_H__
 #define __AUTH_DIGEST_H__
 
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
 #include "helper/forward.h"
 #include "rfc2617.h"
 
 namespace Auth
 {
 namespace Digest
 {
 class User;
 }
 }
 
-/* Generic */
-typedef struct _digest_nonce_data digest_nonce_data;
-typedef struct _digest_nonce_h digest_nonce_h;
+class digest_nonce_h;
 
 /* data to be encoded into the nonce's b64 representation */
-struct _digest_nonce_data {
+class digest_nonce_data {
+public:
     time_t creationtime;
     /* in memory address of the nonce struct (similar purpose to an ETag) */
     digest_nonce_h *self;
     uint32_t randomdata;
+    explicit digest_nonce_data(digest_nonce_h *digestNonceReference);
+    void refreshRandomData();
 };
 
 /* the nonce structure we'll pass around */
+// XXX refactor the nonce cache into this class
+class digest_nonce_h : public hash_link {
+    MEMPROXY_CLASS(digest_nonce_h);
 
-struct _digest_nonce_h : public hash_link {
+public:
+    digest_nonce_h();
     digest_nonce_data noncedata;
     /* number of uses we've seen of this nonce */
     unsigned long nc;
     /* reference count */
     short references;
     /* the auth_user this nonce has been tied to */
     Auth::Digest::User *user;
     /* has this nonce been invalidated ? */
 
     struct {
         bool valid;
         bool incache;
     } flags;
 };
 
 void authDigestNonceUnlink(digest_nonce_h * nonce);
 int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
 int authDigestNonceIsStale(digest_nonce_h * nonce);
 const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
 int authDigestNonceLastRequest(digest_nonce_h * nonce);

