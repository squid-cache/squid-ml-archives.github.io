=== modified file 'src/mem/Pool.cc'
--- src/mem/Pool.cc	2015-08-27 21:44:42 +0000
+++ src/mem/Pool.cc	2015-09-29 19:02:46 +0000
@@ -183,64 +183,66 @@
     MemPoolIterator *iter = memPoolIterate();
     while (MemImplementingAllocator *pool = memPoolIterateNext(iter)) {
         pool->flushMetersFull();
         // are these TheMeter grow() operations or accumulated volumes ?
         TheMeter.alloc += pool->getMeter().alloc.currentLevel() * pool->obj_size;
         TheMeter.inuse += pool->getMeter().inuse.currentLevel() * pool->obj_size;
         TheMeter.idle += pool->getMeter().idle.currentLevel() * pool->obj_size;
 
         TheMeter.gb_allocated.count += pool->getMeter().gb_allocated.count;
         TheMeter.gb_saved.count += pool->getMeter().gb_saved.count;
         TheMeter.gb_freed.count += pool->getMeter().gb_freed.count;
         TheMeter.gb_allocated.bytes += pool->getMeter().gb_allocated.bytes;
         TheMeter.gb_saved.bytes += pool->getMeter().gb_saved.bytes;
         TheMeter.gb_freed.bytes += pool->getMeter().gb_freed.bytes;
     }
     memPoolIterateDone(&iter);
 }
 
 void *
 MemImplementingAllocator::alloc()
 {
     if (++alloc_calls == FLUSH_LIMIT)
         flushMeters();
 
     return allocate();
 }
 
 void
 MemImplementingAllocator::freeOne(void *obj)
 {
-    assert(obj != NULL);
+    ++free_calls;
+    // ::delete(nullptr) is a NOP, implement same behavior
+    if (!obj)
+    	return;
     (void) VALGRIND_CHECK_MEM_IS_ADDRESSABLE(obj, obj_size);
     deallocate(obj, MemPools::GetInstance().mem_idle_limit == 0);
-    ++free_calls;
 }
 
 /*
  * Returns all cached frees to their home chunks
  * If chunks unreferenced age is over, destroys Idle chunk
  * Flushes meters for a pool
  * If pool is not specified, iterates through all pools.
  * When used for all pools, if new_idle_limit is above -1, new
  * idle memory limit is set before Cleanup. This allows to shrink
  * memPool memory usage to specified minimum.
  */
 void
 MemPools::clean(time_t maxage)
 {
     flushMeters();
     if (mem_idle_limit < 0) // no limit to enforce
         return;
 
     int shift = 1;
     if (TheMeter.idle.currentLevel() > mem_idle_limit)
         maxage = shift = 0;
 
     MemImplementingAllocator *pool;
     MemPoolIterator *iter;
     iter = memPoolIterate();
     while ((pool = memPoolIterateNext(iter)))
         if (pool->idleTrigger(shift))
             pool->clean(maxage);
     memPoolIterateDone(&iter);
 }

