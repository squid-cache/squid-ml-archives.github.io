To avoid crashes, prohibit pointless reconfiguration during shutdown.

Also consolidated and polished signal action handling code:

1. For any executed action X, clear do_X at the beginning of action X
   code because once we start X, we should accept/queue more X
   requests (or inform the admin if we reject them).

2. Delay any action X requested during startup or reconfiguration
   because the latter two actions modify global state that X depends
   on. Inform the admin that the requested action is being delayed.

3. Cancel any action X requested during shutdown. We cannot run X
   during shutdown because shutdown modifies global state that X
   depends on, and we never come back from shutdown so there is no
   point in delaying X. Inform the admin that the requested action is
   canceled.

Repeated failed attempts to fix crashes related to various overlapping
actions confirm that this code is a lot trickier than it looks. This
change introduces a more systematic/comprehensive approach to
resolving associated conflicts compared to previous ad hoc attempts.

=== modified file 'src/main.cc'
--- src/main.cc	2015-07-29 08:56:44 +0000
+++ src/main.cc	2015-10-26 07:52:10 +0000
@@ -196,82 +196,109 @@
 
 public:
     virtual int checkEvents(int timeout);
 
 private:
     static void StopEventLoop(void *) {
         if (EventLoop::Running)
             EventLoop::Running->stop();
     }
 
     static void FinalShutdownRunners(void *) {
         RunRegisteredHere(RegisteredRunner::endingShutdown);
 
         // XXX: this should be a Runner.
 #if USE_AUTH
         /* detach the auth components (only do this on full shutdown) */
         Auth::Scheme::FreeAll();
 #endif
 
         eventAdd("SquidTerminate", &StopEventLoop, NULL, 0, 1, false);
     }
 
     void doShutdown(time_t wait);
 };
 
 int
 SignalEngine::checkEvents(int timeout)
 {
     PROF_start(SignalEngine_checkEvents);
 
-    if (do_reconfigure) {
+    if (do_reconfigure)
         mainReconfigureStart();
-        do_reconfigure = 0;
-    } else if (do_rotate) {
+    else if (do_rotate)
         mainRotate();
-        do_rotate = 0;
-    } else if (do_shutdown) {
+    else if (do_shutdown)
         doShutdown(do_shutdown > 0 ? (int) Config.shutdownLifetime : 0);
-        do_shutdown = 0;
-    }
+
     BroadcastSignalIfAny(DebugSignal);
     BroadcastSignalIfAny(RotateSignal);
     BroadcastSignalIfAny(ReconfigureSignal);
     BroadcastSignalIfAny(ShutdownSignal);
 
     PROF_stop(SignalEngine_checkEvents);
     return EVENT_IDLE;
 }
 
+/// Decides whether the signal-controlled action X should be delayed, canceled,
+/// or executed immediately. Clears do_X (via signalVar) as needed.
+static bool
+AvoidSignalAction(const char *description, volatile int &signalVar)
+{
+    const char *avoiding = "delaying";
+    const char *currentEvent = "none";
+    if (shutting_down) {
+        currentEvent = "shutdown";
+        avoiding = "canceling";
+        signalVar = 0;
+    }
+    else if (!configured_once)
+        currentEvent = "startup";
+    else if (reconfiguring)
+        currentEvent = "reconfiguration";
+    else {
+        signalVar = 0;
+        return false; // do not avoid (i.e., execute immediately)
+        // the caller may produce a signal-specific debugging message
+    }
+
+    debugs(1, DBG_IMPORTANT, avoiding << ' ' << description <<
+           " request during " << currentEvent);
+    return true;
+}
+
 void
 SignalEngine::doShutdown(time_t wait)
 {
+    if (AvoidSignalAction("shutdown", do_shutdown))
+        return;
+
     debugs(1, DBG_IMPORTANT, "Preparing for shutdown after " << statCounter.client_http.requests << " requests");
     debugs(1, DBG_IMPORTANT, "Waiting " << wait << " seconds for active connections to finish");
 
     shutting_down = 1;
 
 #if USE_WIN32_SERVICE
     WIN32_svcstatusupdate(SERVICE_STOP_PENDING, (wait + 1) * 1000);
 #endif
 
     /* run the closure code which can be shared with reconfigure */
     serverConnectionsClose();
     RunRegisteredHere(RegisteredRunner::startShutdown);
     eventAdd("SquidShutdown", &FinalShutdownRunners, this, (double) (wait + 1), 1, false);
 }
 
 static void
 usage(void)
 {
     fprintf(stderr,
             "Usage: %s [-cdhvzCFNRVYX] [-n name] [-s | -l facility] [-f config-file] [-[au] port] [-k signal]"
 #if USE_WIN32_SERVICE
             "[-ir] [-O CommandLine]"
 #endif
             "\n"
             "       -a port   Specify HTTP port number (default: %d).\n"
             "       -d level  Write debugging to stderr also.\n"
             "       -f file   Use given config-file instead of\n"
             "                 %s\n"
             "       -h        Print help message.\n"
 #if USE_WIN32_SERVICE
@@ -706,60 +733,63 @@
 
     if (IamPrimaryProcess()) {
 #if USE_WCCP
 
         wccpConnectionClose();
 #endif
 #if USE_WCCPv2
 
         wccp2ConnectionClose();
 #endif
     }
     if (IamWorkerProcess()) {
         clientConnectionsClose();
         icpConnectionShutdown();
 #if USE_HTCP
         htcpSocketShutdown();
 #endif
 
         icmpEngine.Close();
 #if SQUID_SNMP
         snmpClosePorts();
 #endif
 
         asnFreeMemory();
     }
 }
 
 static void
 mainReconfigureStart(void)
 {
+    if (AvoidSignalAction("reconfiguration", do_reconfigure))
+        return;
+
     debugs(1, DBG_IMPORTANT, "Reconfiguring Squid Cache (version " << version_string << ")...");
     reconfiguring = 1;
 
     // Initiate asynchronous closing sequence
     serverConnectionsClose();
     icpClosePorts();
 #if USE_HTCP
     htcpClosePorts();
 #endif
     dnsShutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
 #if USE_OPENSSL
     if (Ssl::CertValidationHelper::GetInstance())
         Ssl::CertValidationHelper::GetInstance()->Shutdown();
     Ssl::TheGlobalContextStorage.reconfigureStart();
 #endif
     redirectShutdown();
 #if USE_AUTH
     authenticateReset();
 #endif
     externalAclShutdown();
     storeDirCloseSwapLogs();
     storeLogClose();
     accessLogClose();
 #if ICAP_CLIENT
     icapLogClose();
 #endif
 
@@ -867,60 +897,63 @@
 
     neighbors_init();
 
     storeDirOpenSwapLogs();
 
     mimeInit(Config.mimeTablePathname);
 
     if (unlinkdNeeded())
         unlinkdInit();
 
 #if USE_DELAY_POOLS
     Config.ClientDelay.finalize();
 #endif
 
     if (Config.onoff.announce) {
         if (!eventFind(start_announce, NULL))
             eventAdd("start_announce", start_announce, NULL, 3600.0, 1);
     } else {
         if (eventFind(start_announce, NULL))
             eventDelete(start_announce, NULL);
     }
 
     writePidFile();     /* write PID file */
 
     reconfiguring = 0;
 }
 
 static void
 mainRotate(void)
 {
+    if (AvoidSignalAction("log rotation", do_rotate))
+        return;
+
     icmpEngine.Close();
     redirectShutdown();
 #if USE_AUTH
     authenticateRotate();
 #endif
     externalAclShutdown();
 
     _db_rotate_log();       /* cache.log */
     storeDirWriteCleanLogs(1);
     storeLogRotate();       /* store.log */
     accessLogRotate();      /* access.log */
 #if ICAP_CLIENT
     icapLogRotate();               /*icap.log*/
 #endif
     icmpEngine.Open();
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
 #endif
     externalAclInit();
 }
 
 static void
 setEffectiveUser(void)
 {
     keepCapabilities();
     leave_suid();       /* Run as non privilegied user */
 #if _SQUID_OS2_
 
     return;

