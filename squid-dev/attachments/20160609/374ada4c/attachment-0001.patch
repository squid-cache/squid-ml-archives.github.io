Do not make bogus recvmsg(2) calls when closing UDS sockets.

comm_empty_os_read_buffers() assumes that all non-blocking
FD_READ_METHODs can read into an opaque buffer filled with random
characters. That assumption is wrong for UDS sockets that require an
initialized msghdr structure. Feeding random data to recvmsg(2) leads to
confusing errors, at best. Squid does not log those errors, but they
are visible in, for example, strace:

  recvmsg(17, 0x7fffbb, MSG_DONTWAIT) = -1 EMSGSIZE (Message too long)

comm_empty_os_read_buffers() is meant to prevent TCP RST packets. The
function now ignores UDS sockets that are not used for TCP.

=== modified file 'src/comm.cc'
--- src/comm.cc	2016-04-03 23:41:58 +0000
+++ src/comm.cc	2016-06-10 00:04:19 +0000
@@ -93,41 +93,41 @@ isOpen(const int fd)
 /**
  * Empty the read buffers
  *
  * This is a magical routine that empties the read buffers.
  * Under some platforms (Linux) if a buffer has data in it before
  * you call close(), the socket will hang and take quite a while
  * to timeout.
  */
 static void
 comm_empty_os_read_buffers(int fd)
 {
 #if _SQUID_LINUX_
 #if USE_OPENSSL
     // Bug 4146: SSL-Bump BIO does not release sockets on close.
     if (fd_table[fd].ssl)
         return;
 #endif
 
     /* prevent those nasty RST packets */
     char buf[SQUID_TCP_SO_RCVBUF];
-    if (fd_table[fd].flags.nonblocking) {
+    if (fd_table[fd].flags.nonblocking && fd_table[fd].type != FD_MSGHDR) {
         while (FD_READ_METHOD(fd, buf, SQUID_TCP_SO_RCVBUF) > 0) {};
     }
 #endif
 }
 
 /**
  * synchronous wrapper around udp socket functions
  */
 int
 comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
 {
     ++ statCounter.syscalls.sock.recvfroms;
     debugs(5,8, "comm_udp_recvfrom: FD " << fd << " from " << from);
     struct addrinfo *AI = NULL;
     Ip::Address::InitAddr(AI);
     int x = recvfrom(fd, buf, len, flags, AI->ai_addr, &AI->ai_addrlen);
     from = *AI;
     Ip::Address::FreeAddr(AI);
     return x;
 }

