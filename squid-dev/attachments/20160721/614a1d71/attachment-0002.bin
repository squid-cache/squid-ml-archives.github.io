Collapse internal revalidation requests (SMP-unaware caches).

... also address Bug 4311 and partially address Bug 2833 and Bug 4471.

Extend collapsed_forwarding functionality to internal revalidation
requests. This implementation does not support Vary-controlled cache
objects and is limited to SMP-unaware caching environments, where each
Squid worker knows nothing about requests and caches handled by other
workers. However, it also lays critical groundwork for future SMP-aware
collapsed revalidation support.

Prior to these changes, multiple concurrent HTTP requests for the same
stale cached object always resulted in multiple internal revalidation
requests sent by Squid to the origin server. Those internal requests
were likely to result in multiple competing Squid cache updates, causing
cache misses and/or more internal revalidation requests, negating
collapsed forwarding savings.

Internal cache revalidation requests are collapsed if and only if
collapsed_forwarding is enabled. There is no option to control just
revalidation collapsing because there is no known use case for it.

* Public revalidation keys

Each Store entry has a unique key. Keys are used to find entries in the
Store (both already cached/swapped_out entries and not). Public keys are
normally tied to the request method and target URI. Same request
properties normally lead to the same public key, making cache hits
possible. If we were to calculate a public key for an internal
revalidation request, it would have been the same as the public key of
the stale cache entry being revalidated. Adding a revalidation response
to Store would have purged that being-revalidated cached entry, even if
the revalidation response itself was not cachable.

To avoid purging being-revalidated cached entries, the old code used
private keys for internal revalidation requests. Private keys are always
unique and cannot accidentally purge a public entry. On the other hand,
for concurrent [revalidation] requests to find the store entry to
collapse on, that store entry has to have a public key!

We resolved this conflict by adding "scope" to public keys:

* Regular/old public keys have default empty scope (that does not affect
  key generation). The code not dealing with collapsed revalidation
  continues to work as before. All entries stored in caches continue to
  have the same keys (with an empty scope).

* When collapsed forwarding is enabled, collapsable internal
  revalidation requests get public keys with a "revalidation" scope
  (that is fed to the MD5 hash when the key is generated). Such a
  revalidation request can find a matching store entry created by
  another revalidation request (and collapse on it), but cannot clash
  with the entry being revalidated (because that entry key is using a
  different [empty] scope).

This change not only enables collapsing of internal revalidation
requests within one worker, but opens the way for SMP-aware workers to
share information about collapsed revalidation requests, similar to how
those workers already share information about being-swapped-out cache
entries.


After receiving the revalidation response, each collapsed revalidation
request may call updateOnNotModified() to update the stale entry [with
the same revalidation response!]. Concurrent entry updates would have
wasted many resources, especially for disk-cached entries that support
header updates, and may have purged being-revalidated entries due to
locking conflicts among updating transactions. To minimize these
problems, we adjusted header and entry metadata updating logic to skip
the update if nothing have changed since the last update.


Also fixed Bug 4311: Collapsed forwarding deadlocks for SMP Squids using
SMP-unaware caches. Collapsed transactions stalled without getting a
response because they were waiting for the shared "transients" table
updates. The table was created by Store::Controller but then abandoned (not
updated) by SMP-unaware caches. Now, the transients table is not created
at all unless SMP-aware caches are present. This fix should also address
complaints about shared memory being used for Squid instances without
SMP-aware caches.

A combination of SMP-aware and SMP-unaware caches is still not supported
and is likely to stall collapsed transactions if they are enabled. Note
that, by default, the memory cache is SMP-aware in SMP environments.

=== modified file 'src/HttpHeader.cc'
--- src/HttpHeader.cc	2016-01-01 00:14:27 +0000
+++ src/HttpHeader.cc	2016-07-15 16:16:09 +0000
@@ -423,76 +423,76 @@
 {
     assert(hs);
     assert(label);
     memset(hs, 0, sizeof(HttpHeaderStat));
     hs->label = label;
     hs->hdrUCountDistr.enumInit(32);    /* not a real enum */
     hs->fieldTypeDistr.enumInit(HDR_ENUM_END);
     hs->ccTypeDistr.enumInit(CC_ENUM_END);
     hs->scTypeDistr.enumInit(SC_ENUM_END);
 }
 
 /*
  * HttpHeader Implementation
  */
 
 HttpHeader::HttpHeader() : owner (hoNone), len (0), conflictingContentLength_(false)
 {
     httpHeaderMaskInit(&mask, 0);
 }
 
 HttpHeader::HttpHeader(const http_hdr_owner_type anOwner): owner(anOwner), len(0), conflictingContentLength_(false)
 {
     assert(anOwner > hoNone && anOwner < hoEnd);
     debugs(55, 7, "init-ing hdr: " << this << " owner: " << owner);
     httpHeaderMaskInit(&mask, 0);
 }
 
 HttpHeader::HttpHeader(const HttpHeader &other): owner(other.owner), len(other.len), conflictingContentLength_(false)
 {
     httpHeaderMaskInit(&mask, 0);
-    update(&other, NULL); // will update the mask as well
+    update(&other); // will update the mask as well
 }
 
 HttpHeader::~HttpHeader()
 {
     clean();
 }
 
 HttpHeader &
 HttpHeader::operator =(const HttpHeader &other)
 {
     if (this != &other) {
         // we do not really care, but the caller probably does
         assert(owner == other.owner);
         clean();
-        update(&other, NULL); // will update the mask as well
+        update(&other); // will update the mask as well
         len = other.len;
         conflictingContentLength_ = other.conflictingContentLength_;
     }
     return *this;
 }
 
 void
 HttpHeader::clean()
 {
 
     assert(owner > hoNone && owner < hoEnd);
     debugs(55, 7, "cleaning hdr: " << this << " owner: " << owner);
 
     PROF_start(HttpHeaderClean);
 
     if (owner <= hoReply) {
         /*
          * An unfortunate bug.  The entries array is initialized
          * such that count is set to zero.  httpHeaderClean() seems to
          * be called both when 'hdr' is created, and destroyed.  Thus,
          * we accumulate a large number of zero counts for 'hdr' before
          * it is ever used.  Can't think of a good way to fix it, except
          * adding a state variable that indicates whether or not 'hdr'
          * has been used.  As a hack, just never count zero-sized header
          * arrays.
          */
         if (!entries.empty())
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.size());
 
         ++ HttpHeaderStats[owner].destroyedCount;
@@ -508,99 +508,145 @@
             debugs(55, DBG_CRITICAL, "BUG: invalid entry (" << e->id << "). Ignored.");
         } else {
             if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
             delete e;
         }
     }
 
     entries.clear();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
     conflictingContentLength_ = false;
     PROF_stop(HttpHeaderClean);
 }
 
 /* append entries (also see httpHeaderUpdate) */
 void
 HttpHeader::append(const HttpHeader * src)
 {
     const HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
     assert(src);
     assert(src != this);
     debugs(55, 7, "appending hdr: " << this << " += " << src);
 
     while ((e = src->getEntry(&pos))) {
         addEntry(e->clone());
     }
 }
 
+/// check whether the fresh header has any new/changed updatable fields
+bool
+HttpHeader::needUpdate(HttpHeader const *fresh) const
+{
+    for (unsigned int i = 0; i < fresh->entries.size(); ++i) {
+        const HttpHeaderEntry *e = fresh->entries[i];
+        if (skipUpdateHeader(e->id))
+            continue;
+        String value;
+        const char *name = e->name.termedBuf();
+        if (!getByNameIfPresent(name, value) ||
+                (value != fresh->getByName(name)))
+            return true;
+    }
+    return false;
+}
+
 /* use fresh entries to replace old ones */
 void
 httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask)
 {
     assert (old);
-    old->update (fresh, denied_mask);
+    old->update(fresh);
 }
 
 void
-HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
+HttpHeader::updateWarnings()
 {
-    const HttpHeaderEntry *e;
+    int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
+
+    // RFC 7234, section 4.3.4: delete 1xx warnings and retain 2xx warnings
+    while (HttpHeaderEntry *e = getEntry(&pos)) {
+        if (e->id == HDR_WARNING && (e->getInt()/100 == 1) )
+            delAt(pos, count);
+    }
+}
+
+bool
+HttpHeader::skipUpdateHeader(const http_hdr_type id) const
+{
+    // RFC 7234, section 4.3.4: use fields other from Warning for update
+    return id == HDR_WARNING;
+}
+
+bool
+HttpHeader::update(HttpHeader const *fresh)
+{
     assert(fresh);
     assert(this != fresh);
 
+    // Optimization: Finding whether a header field changed is expensive
+    // and probably not worth it except for collapsed revalidation needs.
+    if (Config.onoff.collapsed_forwarding && !needUpdate(fresh))
+        return false;
+
+    updateWarnings();
+
+    const HttpHeaderEntry *e;
+    HttpHeaderPos pos = HttpHeaderInitPos;
+
     while ((e = fresh->getEntry(&pos))) {
         /* deny bad guys (ok to check for HDR_OTHER) here */
 
-        if (denied_mask && CBIT_TEST(*denied_mask, e->id))
+        if (skipUpdateHeader(e->id))
             continue;
 
         if (e->id != HDR_OTHER)
             delById(e->id);
         else
             delByName(e->name.termedBuf());
     }
 
     pos = HttpHeaderInitPos;
     while ((e = fresh->getEntry(&pos))) {
         /* deny bad guys (ok to check for HDR_OTHER) here */
 
-        if (denied_mask && CBIT_TEST(*denied_mask, e->id))
+        if (skipUpdateHeader(e->id))
             continue;
 
         debugs(55, 7, "Updating header '" << HeadersAttrs[e->id].name << "' in cached entry");
 
         addEntry(e->clone());
     }
+    return true;
 }
 
 /* just handy in parsing: resets and returns false */
 int
 HttpHeader::reset()
 {
     clean();
     return 0;
 }
 
 int
 HttpHeader::parse(const char *header_start, const char *header_end)
 {
     const char *field_ptr = header_start;
     HttpHeaderEntry *e, *e2;
     int warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
 
     PROF_start(HttpHeaderParse);
 
     assert(header_start && header_end);
     debugs(55, 7, "parsing hdr: (" << this << ")" << std::endl << getStringPrefix(header_start, header_end));
     ++ HttpHeaderStats[owner].parsedCount;
 
     char *nulpos;
     if ((nulpos = (char*)memchr(header_start, '\0', header_end - header_start))) {
         debugs(55, DBG_IMPORTANT, "WARNING: HTTP header contains NULL characters {" <<
                getStringPrefix(header_start, nulpos) << "}\nNULL\n{" << getStringPrefix(nulpos+1, header_end));
         PROF_stop(HttpHeaderParse);
         return reset();
     }
@@ -1693,75 +1739,73 @@
     /* set field value */
     value.limitInit(value_start, field_end - value_start);
 
     ++ Headers[id].stat.seenCount;
 
     debugs(55, 9, "parsed HttpHeaderEntry: '" << name << ": " << value << "'");
 
     return new HttpHeaderEntry(id, name.termedBuf(), value.termedBuf());
 }
 
 HttpHeaderEntry *
 HttpHeaderEntry::clone() const
 {
     return new HttpHeaderEntry(id, name.termedBuf(), value.termedBuf());
 }
 
 void
 HttpHeaderEntry::packInto(Packer * p) const
 {
     assert(p);
     packerAppend(p, name.rawBuf(), name.size());
     packerAppend(p, ": ", 2);
     packerAppend(p, value.rawBuf(), value.size());
     packerAppend(p, "\r\n", 2);
 }
 
 int
 HttpHeaderEntry::getInt() const
 {
     assert_eid (id);
-    assert (Headers[id].type == ftInt);
     int val = -1;
     int ok = httpHeaderParseInt(value.termedBuf(), &val);
     httpHeaderNoteParsedEntry(id, value, !ok);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
     return val;
 }
 
 int64_t
 HttpHeaderEntry::getInt64() const
 {
     assert_eid (id);
-    assert (Headers[id].type == ftInt64);
     int64_t val = -1;
     int ok = httpHeaderParseOffset(value.termedBuf(), &val);
     httpHeaderNoteParsedEntry(id, value, !ok);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
     return val;
 }
 
 static void
 httpHeaderNoteParsedEntry(http_hdr_type id, String const &context, int error)
 {
     ++ Headers[id].stat.parsCount;
 
     if (error) {
         ++ Headers[id].stat.errCount;
         debugs(55, 2, "cannot parse hdr field: '" << Headers[id].name << ": " << context << "'");
     }
 }
 
 /*
  * Reports
  */
 
 /* tmp variable used to pass stat info to dumpers */
 extern const HttpHeaderStat *dump_stat;     /* argh! */
 const HttpHeaderStat *dump_stat = NULL;
 
 void
 httpHeaderFieldStatDumper(StoreEntry * sentry, int idx, double val, double size, int count)

=== modified file 'src/HttpHeader.h'
--- src/HttpHeader.h	2016-01-01 00:14:27 +0000
+++ src/HttpHeader.h	2016-07-13 16:18:44 +0000
@@ -190,118 +190,121 @@
     static HttpHeaderEntry *parse(const char *field_start, const char *field_end);
     HttpHeaderEntry *clone() const;
     void packInto(Packer *p) const;
     int getInt() const;
     int64_t getInt64() const;
     MEMPROXY_CLASS(HttpHeaderEntry);
     http_hdr_type id;
     String name;
     String value;
 };
 
 MEMPROXY_CLASS_INLINE(HttpHeaderEntry);
 
 class ETag;
 class TimeOrTag;
 
 class HttpHeader
 {
 
 public:
     HttpHeader();
     explicit HttpHeader(const http_hdr_owner_type owner);
     HttpHeader(const HttpHeader &other);
     ~HttpHeader();
 
     HttpHeader &operator =(const HttpHeader &other);
 
     /* Interface functions */
     void clean();
     void append(const HttpHeader * src);
-    void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
+    bool update(HttpHeader const *fresh);
     void compact();
     int reset();
     int parse(const char *header_start, const char *header_end);
     void packInto(Packer * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
     HttpHeaderEntry *findEntry(http_hdr_type id) const;
     int delByName(const char *name);
     int delById(http_hdr_type id);
     void delAt(HttpHeaderPos pos, int &headers_deleted);
     void refreshMask();
     void addEntry(HttpHeaderEntry * e);
     void insertEntry(HttpHeaderEntry * e);
     String getList(http_hdr_type id) const;
     bool getList(http_hdr_type id, String *s) const;
     String getStrOrList(http_hdr_type id) const;
     bool conflictingContentLength() const { return conflictingContentLength_; }
     String getByName(const char *name) const;
     /// sets value and returns true iff a [possibly empty] named field is there
     bool getByNameIfPresent(const char *name, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(http_hdr_type id, const char *member, const char separator) const;
     int has(http_hdr_type id) const;
     void putInt(http_hdr_type id, int number);
     void putInt64(http_hdr_type id, int64_t number);
     void putTime(http_hdr_type id, time_t htime);
     void insertTime(http_hdr_type id, time_t htime);
     void putStr(http_hdr_type id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
     void putContRange(const HttpHdrContRange * cr);
     void putRange(const HttpHdrRange * range);
     void putSc(HttpHdrSc *sc);
     void putWarning(const int code, const char *const text); ///< add a Warning header
     void putExt(const char *name, const char *value);
     int getInt(http_hdr_type id) const;
     int64_t getInt64(http_hdr_type id) const;
     time_t getTime(http_hdr_type id) const;
     const char *getStr(http_hdr_type id) const;
     const char *getLastStr(http_hdr_type id) const;
     HttpHdrCc *getCc() const;
     HttpHdrRange *getRange() const;
     HttpHdrSc *getSc() const;
     HttpHdrContRange *getContRange() const;
     const char *getAuth(http_hdr_type id, const char *auth_scheme) const;
     ETag getETag(http_hdr_type id) const;
     TimeOrTag getTimeOrTag(http_hdr_type id) const;
     int hasListMember(http_hdr_type id, const char *member, const char separator) const;
     int hasByNameListMember(const char *name, const char *member, const char separator) const;
     void removeHopByHopEntries();
     inline bool chunked() const; ///< whether message uses chunked Transfer-Encoding
 
     /* protected, do not use these, use interface functions instead */
     std::vector<HttpHeaderEntry *> entries;     /**< parsed fields in raw format */
     HttpHeaderMask mask;    /**< bit set <=> entry present */
     http_hdr_owner_type owner;  /**< request or reply */
     int len;            /**< length when packed, not counting terminating null-byte */
 
 protected:
     /** \deprecated Public access replaced by removeHopByHopEntries() */
     void removeConnectionHeaderEntries();
+    bool needUpdate(const HttpHeader *fresh) const;
+    bool skipUpdateHeader(const http_hdr_type id) const;
+    void updateWarnings();
 
 private:
     HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
     bool conflictingContentLength_; ///< found different Content-Length fields
 };
 
 int httpHeaderParseQuotedString(const char *start, const int len, String *val);
 
 /// quotes string using RFC 7230 quoted-string rules
 SBuf httpHeaderQuoteString(const char *raw);
 
 int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
 void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
 void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
 {
     return has(HDR_TRANSFER_ENCODING) &&
            hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
 }
 
 void httpHeaderInitModule(void);
 void httpHeaderCleanModule(void);
 
 #endif /* SQUID_HTTPHEADER_H */
 

=== modified file 'src/HttpReply.cc'
--- src/HttpReply.cc	2016-03-23 15:36:45 +0000
+++ src/HttpReply.cc	2016-07-13 16:25:09 +0000
@@ -1,89 +1,56 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 58    HTTP Reply (Response) */
 
 #include "squid.h"
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "globals.h"
 #include "HttpBody.h"
 #include "HttpHdrCc.h"
 #include "HttpHdrContRange.h"
 #include "HttpHdrSc.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
 
-/* local constants */
-
-/* If we receive a 304 from the origin during a cache revalidation, we must
- * update the headers of the existing entry. Specifically, we need to update all
- * end-to-end headers and not any hop-by-hop headers (rfc2616 13.5.3).
- *
- * This is not the whole story though: since it is possible for a faulty/malicious
- * origin server to set headers it should not in a 304, we must explicitly ignore
- * these too. Specifically all entity-headers except those permitted in a 304
- * (rfc2616 10.3.5) must be ignored.
- *
- * The list of headers we don't update is made up of:
- *     all hop-by-hop headers
- *     all entity-headers except Expires and Content-Location
- */
-static HttpHeaderMask Denied304HeadersMask;
-static http_hdr_type Denied304HeadersArr[] = {
-    // hop-by-hop headers
-    HDR_CONNECTION, HDR_KEEP_ALIVE, HDR_PROXY_AUTHENTICATE, HDR_PROXY_AUTHORIZATION,
-    HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE,
-    // entity headers
-    HDR_ALLOW, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE, HDR_CONTENT_LENGTH,
-    HDR_CONTENT_MD5, HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_LAST_MODIFIED
-};
-
-/* module initialization */
-void
-httpReplyInitModule(void)
-{
-    assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
-    httpHeaderMaskInit(&Denied304HeadersMask, 0);
-    httpHeaderCalcMask(&Denied304HeadersMask, Denied304HeadersArr, countof(Denied304HeadersArr));
-}
 
 HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
     expires (0), surrogate_control (NULL), content_range (NULL), keep_alive (0),
     protoPrefix("HTTP/"), bodySizeMax(-2)
 {
     init();
 }
 
 HttpReply::~HttpReply()
 {
     if (do_clean)
         clean();
 }
 
 void
 HttpReply::init()
 {
     hdrCacheInit();
     sline.init();
     pstate = psReadyToParseStartLine;
     do_clean = true;
 }
 
 void HttpReply::reset()
 {
 
     // reset should not reset the protocol; could have made protoPrefix a
     // virtual function instead, but it is not clear whether virtual methods
     // are allowed with MEMPROXY_CLASS() and whether some cbdata void*
     // conversions are not going to kill virtual tables
@@ -244,74 +211,77 @@
         return 0;
 
     /* ETag */
     one = header.getStrOrList(HDR_ETAG);
 
     two = otherRep->header.getStrOrList(HDR_ETAG);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
         two.clean();
         return 0;
     }
 
     if (last_modified != otherRep->last_modified)
         return 0;
 
     /* MD5 */
     one = header.getStrOrList(HDR_CONTENT_MD5);
 
     two = otherRep->header.getStrOrList(HDR_CONTENT_MD5);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
         two.clean();
         return 0;
     }
 
     return 1;
 }
 
-void
+bool
 HttpReply::updateOnNotModified(HttpReply const * freshRep)
 {
     assert(freshRep);
 
+    /* update raw headers */
+    if (!header.update(&freshRep->header))
+        return false;
+
     /* clean cache */
     hdrCacheClean();
-    /* update raw headers */
-    header.update(&freshRep->header,
-                  (const HttpHeaderMask *) &Denied304HeadersMask);
 
     header.compact();
     /* init cache */
     hdrCacheInit();
+
+    return true;
 }
 
 /* internal routines */
 
 time_t
 HttpReply::hdrExpirationTime()
 {
     /* The s-maxage and max-age directive takes priority over Expires */
 
     if (cache_control) {
         if (date >= 0) {
             if (cache_control->hasSMaxAge())
                 return date + cache_control->sMaxAge();
 
             if (cache_control->hasMaxAge())
                 return date + cache_control->maxAge();
         } else {
             /*
              * Conservatively handle the case when we have a max-age
              * header, but no Date for reference?
              */
 
             if (cache_control->hasSMaxAge())
                 return squid_curtime;
 
             if (cache_control->hasMaxAge())
                 return squid_curtime;
         }
     }
 

=== modified file 'src/HttpReply.h'
--- src/HttpReply.h	2016-01-01 00:14:27 +0000
+++ src/HttpReply.h	2016-07-13 16:25:32 +0000
@@ -45,61 +45,61 @@
     time_t date;
 
     time_t last_modified;
 
     time_t expires;
 
     String content_type;
 
     HttpHdrSc *surrogate_control;
 
     HttpHdrContRange *content_range;
 
     short int keep_alive;
 
     /** \par public, writable, but use httpReply* interfaces when possible */
     Http::StatusLine sline;
 
     HttpBody body;      /**< for small constant memory-resident text bodies only */
 
     String protoPrefix;         /**< e.g., "HTTP/"  */
 
     bool do_clean;
 
 public:
     virtual int httpMsgParseError();
 
     virtual bool expectingBody(const HttpRequestMethod&, int64_t&) const;
 
     virtual bool inheritProperties(const HttpMsg *aMsg);
 
-    void updateOnNotModified(HttpReply const *other);
+    bool updateOnNotModified(HttpReply const *other);
 
     /** set commonly used info with one call */
     void setHeaders(Http::StatusCode status,
                     const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires);
 
     /** \return a ready to use mem buffer with a packed reply */
     MemBuf *pack();
 
     /** construct a 304 reply and return it */
     HttpReply *make304() const;
 
     void redirect(Http::StatusCode, const char *);
 
     int64_t bodySize(const HttpRequestMethod&) const;
 
     /** Checks whether received body exceeds known maximum size.
      * Requires a prior call to calcMaxBodySize().
      */
     bool receivedBodyTooLarge(HttpRequest&, int64_t receivedBodySize);
 
     /** Checks whether expected body exceeds known maximum size.
      * Requires a prior call to calcMaxBodySize().
      */
     bool expectedBodyTooLarge(HttpRequest& request);
 
     int validatorsMatch (HttpReply const *other) const;
 
     void packHeadersInto(Packer * p) const;
 
     /** Clone this reply.

=== modified file 'src/MemStore.h'
--- src/MemStore.h	2016-01-01 00:14:27 +0000
+++ src/MemStore.h	2016-07-14 08:02:47 +0000
@@ -36,60 +36,61 @@
     void write(StoreEntry &e);
 
     /// all data has been received; there will be no more write() calls
     void completeWriting(StoreEntry &e);
 
     /// remove from the cache
     void unlink(StoreEntry &e);
 
     /// called when the entry is about to forget its association with mem cache
     void disconnect(StoreEntry &e);
 
     /* Store API */
     virtual int callback();
     virtual StoreEntry * get(const cache_key *);
     virtual void get(String const key , STOREGETCLIENT callback, void *cbdata);
     virtual void init();
     virtual uint64_t maxSize() const;
     virtual uint64_t minSize() const;
     virtual uint64_t currentSize() const;
     virtual uint64_t currentCount() const;
     virtual int64_t maxObjectSize() const;
     virtual void getStats(StoreInfoStats &stats) const;
     virtual void stat(StoreEntry &) const;
     virtual StoreSearch *search(String const url, HttpRequest *);
     virtual void markForUnlink(StoreEntry &e);
     virtual void reference(StoreEntry &);
     virtual bool dereference(StoreEntry &, bool);
     virtual void maintain();
     virtual bool anchorCollapsed(StoreEntry &collapsed, bool &inSync);
     virtual bool updateCollapsed(StoreEntry &collapsed);
+    virtual bool smpAware() const { return true; }
 
     static int64_t EntryLimit();
 
 protected:
     bool shouldCache(StoreEntry &e) const;
     bool startCaching(StoreEntry &e);
 
     void copyToShm(StoreEntry &e);
     void copyToShmSlice(StoreEntry &e, Ipc::StoreMapAnchor &anchor);
     bool copyFromShm(StoreEntry &e, const sfileno index, const Ipc::StoreMapAnchor &anchor);
     bool copyFromShmSlice(StoreEntry &e, const StoreIOBuffer &buf, bool eof);
 
     void anchorEntry(StoreEntry &e, const sfileno index, const Ipc::StoreMapAnchor &anchor);
     bool updateCollapsedWith(StoreEntry &collapsed, const sfileno index, const Ipc::StoreMapAnchor &anchor);
 
     sfileno reserveSapForWriting(Ipc::Mem::PageId &page);
 
     // Ipc::StoreMapCleaner API
     virtual void noteFreeMapSlice(const Ipc::StoreMapSliceId sliceId);
 
 private:
     // TODO: move freeSlots into map
     Ipc::Mem::Pointer<Ipc::Mem::PageStack> freeSlots; ///< unused map slot IDs
     MemStoreMap *map; ///< index of mem-cached entries
 
     typedef MemStoreMapExtras Extras;
     Ipc::Mem::Pointer<Extras> extras; ///< IDs of pages with slice data
 
     /// the last allocate slice for writing a store entry (during copyToShm)
     sfileno lastWritingSlice;

=== modified file 'src/Store.h'
--- src/Store.h	2016-01-01 00:14:27 +0000
+++ src/Store.h	2016-07-21 08:22:08 +0000
@@ -1,56 +1,57 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_STORE_H
 #define SQUID_STORE_H
 
 /**
  \defgroup StoreAPI  Store API
  \ingroup FileSystems
  */
 
 #include "base/RefCount.h"
 #include "comm/forward.h"
 #include "CommRead.h"
 #include "hash.h"
 #include "HttpReply.h"
 #include "HttpRequestMethod.h"
 #include "MemObject.h"
 #include "Range.h"
 #include "RemovalPolicy.h"
 #include "StoreIOBuffer.h"
+#include "store_key_md5.h"
 #include "StoreStats.h"
 
 #if USE_SQUID_ESI
 #include "esi/Element.h"
 #endif
 
 #include <ostream>
 
 class AsyncCall;
 class HttpRequest;
 class Packer;
 class RequestFlags;
 class StoreClient;
 class StoreSearch;
 class SwapDir;
 
 extern StoreIoStats store_io_stats;
 
 /// maximum number of entries per cache_dir
 enum { SwapFilenMax = 0xFFFFFF }; // keep in sync with StoreEntry::swap_filen
 
 /**
  \ingroup StoreAPI
  */
 class StoreEntry : public hash_link
 {
 
 public:
     static DeferredRead::DeferrableRead DeferReader;
     bool checkDeferRead(int fd) const;
@@ -66,98 +67,102 @@
      * \retval true   Store contains 0 bytes of data.
      * \retval false  Store contains 1 or more bytes of data.
      * \retval false  Store contains negative content !!!!!!
      */
     virtual bool isEmpty() const {
         assert (mem_obj);
         return mem_obj->endOffset() == 0;
     }
     virtual bool isAccepting() const;
     virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const;
     /// flags [truncated or too big] entry with ENTRY_BAD_LENGTH and releases it
     void lengthWentBad(const char *reason);
     virtual void complete();
     virtual store_client_t storeClientType() const;
     virtual char const *getSerialisedMetaData();
     /// Store a prepared error response. MemObject locks the reply object.
     void storeErrorResponse(HttpReply *reply);
     void replaceHttpReply(HttpReply *, bool andStartWriting = true);
     void startWriting(); ///< pack and write reply headers and, maybe, body
     /// whether we may start writing to disk (now or in the future)
     virtual bool mayStartSwapOut();
     virtual void trimMemory(const bool preserveSwappable);
 
     // called when a decision to cache in memory has been made
     void memOutDecision(const bool willCacheInRam);
     // called when a decision to cache on disk has been made
     void swapOutDecision(const MemObject::SwapOut::Decision &decision);
 
     void abort();
     void unlink();
-    void makePublic();
+    void makePublic(const KeyScope keyScope = ksDefault);
     void makePrivate();
-    void setPublicKey();
+    void setPublicKey(const KeyScope keyScope = ksDefault);
+    /// Resets existing public key to a public key with default scope,
+    /// releasing the old default-scope entry (if any).
+    /// Does nothing if the existing public key already has default scope.
+    void clearPublicKeyScope();
     void setPrivateKey();
     void expireNow();
     void releaseRequest();
     void negativeCache();
     void cacheNegatively();     /** \todo argh, why both? */
     void invokeHandlers();
     void purgeMem();
     void cacheInMemory(); ///< start or continue storing in memory cache
     void swapOut();
     /// whether we are in the process of writing this entry to disk
     bool swappingOut() const { return swap_status == SWAPOUT_WRITING; }
     void swapOutFileClose(int how);
     const char *url() const;
     /// Satisfies cachability requirements shared among disk and RAM caches.
     /// Encapsulates common checks of mayStartSwapOut() and memoryCachable().
     /// TODO: Rename and make private so only those two methods can call this.
     bool checkCachable();
     int checkNegativeHit() const;
     int locked() const;
     int validToSend() const;
     bool memoryCachable(); ///< checkCachable() and can be cached in memory
 
     /// if needed, initialize mem_obj member w/o URI-related information
     MemObject *makeMemObject();
 
     /// initialize mem_obj member (if needed) and supply URI-related info
     void createMemObject(const char *storeId, const char *logUri, const HttpRequestMethod &aMethod);
 
     void dump(int debug_lvl) const;
     void hashDelete();
     void hashInsert(const cache_key *);
     void registerAbort(STABH * cb, void *);
     void reset();
     void setMemStatus(mem_status_t);
-    void timestampsSet();
+    bool timestampsSet();
     void unregisterAbort();
     void destroyMemObject();
     int checkTooSmall();
 
     void delayAwareRead(const Comm::ConnectionPointer &conn, char *buf, int len, AsyncCall::Pointer callback);
 
     void setNoDelay (bool const);
     bool modifiedSince(HttpRequest * request) const;
     /// has ETag matching at least one of the If-Match etags
     bool hasIfMatchEtag(const HttpRequest &request) const;
     /// has ETag matching at least one of the If-None-Match etags
     bool hasIfNoneMatchEtag(const HttpRequest &request) const;
     /// whether this entry has an ETag; if yes, puts ETag value into parameter
     bool hasEtag(ETag &etag) const;
 
     /** What store does this entry belong too ? */
     virtual RefCount<SwapDir> store() const;
 
     MemObject *mem_obj;
     RemovalPolicyNode repl;
     /* START OF ON-DISK STORE_META_STD TLV field */
     time_t timestamp;
     time_t lastref;
     time_t expires;
     time_t lastmod;
     uint64_t swap_file_sz;
     uint16_t refcount;
     uint16_t flags;
     /* END OF ON-DISK STORE_META_STD */
 
@@ -201,60 +206,63 @@
     virtual int64_t contentLen() const;
 
     /// claim shared ownership of this entry (for use in a given context)
     /// matching lock() and unlock() contexts eases leak triage but is optional
     void lock(const char *context);
 
     /// disclaim shared ownership; may remove entry from store and delete it
     /// returns remaning lock level (zero for unlocked and possibly gone entry)
     int unlock(const char *context);
 
     /// returns a local concurrent use counter, for debugging
     int locks() const { return static_cast<int>(lock_count); }
 
     /// update last reference timestamp and related Store metadata
     void touch();
 
     virtual void release();
 
 #if USE_ADAPTATION
     /// call back producer when more buffer space is available
     void deferProducer(const AsyncCall::Pointer &producer);
     /// calls back producer registered with deferProducer
     void kickProducer();
 #endif
 
 protected:
     void transientsAbandonmentCheck();
 
 private:
     bool checkTooBig() const;
+    void forcePublicKey(const cache_key *newkey);
+    void adjustVary();
+    const cache_key *calcPublicKey(const KeyScope keyScope);
 
     static MemAllocator *pool;
 
     unsigned short lock_count;      /* Assume < 65536! */
 
 #if USE_ADAPTATION
     /// producer callback registered with deferProducer
     AsyncCall::Pointer deferredProducer;
 #endif
 
     bool validLength() const;
     bool hasOneOfEtags(const String &reqETags, const bool allowWeakMatch) const;
 };
 
 std::ostream &operator <<(std::ostream &os, const StoreEntry &e);
 
 /// \ingroup StoreAPI
 class NullStoreEntry:public StoreEntry
 {
 
 public:
     static NullStoreEntry *getInstance();
     bool isNull() {
         return true;
     }
 
     const char *getMD5Text() const;
     HttpReply const *getReply() const { return NULL; }
     void write (StoreIOBuffer) {}
 
@@ -403,84 +411,89 @@
     /// calls Root().transients->abandon() if transients are tracked
     virtual void transientsAbandon(StoreEntry &e) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// number of the transient entry readers some time ago
     virtual int transientReaders(const StoreEntry &e) const { return 0; }
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// disassociates the entry from the intransit table
     virtual void transientsDisconnect(MemObject &mem_obj) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// removes the entry from the memory cache
     virtual void memoryUnlink(StoreEntry &e) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// disassociates the entry from the memory cache, preserving cached data
     virtual void memoryDisconnect(StoreEntry &e) {}
 
     /// If the entry is not found, return false. Otherwise, return true after
     /// tying the entry to this cache and setting inSync to updateCollapsed().
     virtual bool anchorCollapsed(StoreEntry &collapsed, bool &inSync) { return false; }
 
     /// update a local collapsed entry with fresh info from this cache (if any)
     virtual bool updateCollapsed(StoreEntry &collapsed) { return false; }
 
+    /// whether this storage is capable of serving multiple workers;
+    /// a true result does not imply [lack of] non-SMP support because
+    /// [only] some SMP-aware storages also support non-SMP configs
+    virtual bool smpAware() const = 0;
+
 private:
     static RefCount<Store> CurrentRoot;
 };
 
 /// \ingroup StoreAPI
 typedef RefCount<Store> StorePointer;
 
 /// \ingroup StoreAPI
 size_t storeEntryInUse();
 
 /// \ingroup StoreAPI
 const char *storeEntryFlags(const StoreEntry *);
 
 /// \ingroup StoreAPI
 void storeEntryReplaceObject(StoreEntry *, HttpReply *);
 
 /// \ingroup StoreAPI
 StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-StoreEntry *storeGetPublicByRequest(HttpRequest * request);
+StoreEntry *storeGetPublicByRequest(HttpRequest * request, const KeyScope keyScope = ksDefault);
 
 /// \ingroup StoreAPI
-StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method, const KeyScope keyScope = ksDefault);
 
 /// \ingroup StoreAPI
 /// Like storeCreatePureEntry(), but also locks the entry and sets entry key.
 StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&);
 
 /// \ingroup StoreAPI
 /// Creates a new StoreEntry with mem_obj and sets initial flags/states.
 StoreEntry *storeCreatePureEntry(const char *storeId, const char *logUrl, const RequestFlags &, const HttpRequestMethod&);
 
 /// \ingroup StoreAPI
 void storeInit(void);
 
 /// \ingroup StoreAPI
 void storeConfigure(void);
 
 /// \ingroup StoreAPI
 void storeFreeMemory(void);
 
 /// \ingroup StoreAPI
 int expiresMoreThan(time_t, time_t);
 
 /// \ingroup StoreAPI
 void storeAppendPrintf(StoreEntry *, const char *,...) PRINTF_FORMAT_ARG2;
 
 /// \ingroup StoreAPI
 void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
 
 /// \ingroup StoreAPI
 int storeTooManyDiskFilesOpen(void);
 

=== modified file 'src/StoreHashIndex.h'
--- src/StoreHashIndex.h	2016-01-01 00:14:27 +0000
+++ src/StoreHashIndex.h	2016-07-15 16:23:16 +0000
@@ -32,60 +32,62 @@
     (const cache_key *);
 
     virtual void get
     (String const, STOREGETCLIENT, void * cbdata);
 
     virtual void init();
 
     virtual void sync();
 
     virtual uint64_t maxSize() const;
 
     virtual uint64_t minSize() const;
 
     virtual uint64_t currentSize() const;
 
     virtual uint64_t currentCount() const;
 
     virtual int64_t maxObjectSize() const;
 
     virtual void getStats(StoreInfoStats &stats) const;
     virtual void stat(StoreEntry&) const;
 
     virtual void reference(StoreEntry&);
 
     virtual bool dereference(StoreEntry&, bool);
 
     virtual void maintain();
 
     virtual StoreSearch *search(String const url, HttpRequest *);
 
+    virtual bool smpAware() const;
+
 private:
     /* migration logic */
     StorePointer store(int const x) const;
     SwapDir &dir(int const idx) const;
 };
 
 class StoreHashIndexEntry : public StoreEntry
 {};
 
 class StoreSearchHashIndex : public StoreSearch
 {
 
 public:
     StoreSearchHashIndex(RefCount<StoreHashIndex> sd);
     StoreSearchHashIndex(StoreSearchHashIndex const &);
     virtual ~StoreSearchHashIndex();
     /* Iterator API - garh, wrong place */
     /* callback the client when a new StoreEntry is available
      * or an error occurs
      */
     virtual void next(void (callback)(void *cbdata), void *cbdata);
     /* return true if a new StoreEntry is immediately available */
     virtual bool next();
     virtual bool error() const;
     virtual bool isDone() const;
     virtual StoreEntry *currentItem();
 
     RefCount<StoreHashIndex> sd;
 
 private:

=== modified file 'src/SwapDir.h'
--- src/SwapDir.h	2016-01-01 00:14:27 +0000
+++ src/SwapDir.h	2016-07-15 18:28:26 +0000
@@ -24,60 +24,61 @@
 /* SwapDir *sd, char *path ( + char *opt later when the strtok mess is gone) */
 
 class ConfigOption;
 
 /// hides memory/disk cache distinction from callers
 class StoreController : public Store
 {
 
 public:
     StoreController();
     virtual ~StoreController();
     virtual int callback();
     virtual void create();
 
     virtual StoreEntry * get(const cache_key *);
 
     virtual void get(String const, STOREGETCLIENT, void * cbdata);
 
     /* Store parent API */
     virtual void markForUnlink(StoreEntry &e);
     virtual void handleIdleEntry(StoreEntry &e);
     virtual void transientsCompleteWriting(StoreEntry &e);
     virtual void transientsAbandon(StoreEntry &e);
     virtual int transientReaders(const StoreEntry &e) const;
     virtual void transientsDisconnect(MemObject &mem_obj);
     virtual void memoryOut(StoreEntry &e, const bool preserveSwappable);
     virtual void memoryUnlink(StoreEntry &e);
     virtual void memoryDisconnect(StoreEntry &e);
     virtual void allowCollapsing(StoreEntry *e, const RequestFlags &reqFlags, const HttpRequestMethod &reqMethod);
     virtual void syncCollapsed(const sfileno xitIndex);
+    virtual bool smpAware() const;
 
     virtual void init();
 
     virtual void maintain(); /* perform regular maintenance should be private and self registered ... */
 
     virtual uint64_t maxSize() const;
 
     virtual uint64_t minSize() const;
 
     virtual uint64_t currentSize() const;
 
     virtual uint64_t currentCount() const;
 
     virtual int64_t maxObjectSize() const;
 
     virtual void getStats(StoreInfoStats &stats) const;
     virtual void stat(StoreEntry &) const;
 
     virtual void sync();    /* Sync the store prior to shutdown */
 
     virtual StoreSearch *search(String const url, HttpRequest *);
 
     virtual void reference(StoreEntry &);   /* Reference this object */
 
     virtual bool dereference(StoreEntry &, bool);   /* Unreference this object */
 
     /* the number of store dirs being rebuilt. */
     static int store_dirs_rebuilding;
 
 private:
@@ -131,60 +132,61 @@
 
     virtual bool needsDiskStrand() const; ///< needs a dedicated kid process
     virtual bool active() const; ///< may be used in this strand
     /// whether stat should be reported by this SwapDir
     virtual bool doReportStat() const { return active(); }
     /// whether SwapDir may benefit from unlinkd
     virtual bool unlinkdUseful() const = 0;
 
     /* official Store interface functions */
     virtual void diskFull();
 
     virtual StoreEntry * get(const cache_key *);
 
     virtual void get(String const, STOREGETCLIENT, void * cbdata);
 
     virtual uint64_t maxSize() const { return max_size;}
 
     virtual uint64_t minSize() const;
 
     /// The maximum size of object which may be stored here.
     /// Larger objects will not be added and may be purged.
     virtual int64_t maxObjectSize() const;
 
     /// configure the maximum object size for this storage area.
     /// May be any size up to the total storage area.
     void maxObjectSize(int64_t newMax);
 
     virtual void getStats(StoreInfoStats &stats) const;
     virtual void stat (StoreEntry &anEntry) const;
     virtual StoreSearch *search(String const url, HttpRequest *) = 0;
+    virtual bool smpAware() const { return false; }
 
     /* migrated from store_dir.cc */
     bool objectSizeIsAcceptable(int64_t objsize) const;
 
     /// called when the entry is about to forget its association with cache_dir
     virtual void disconnect(StoreEntry &) {}
 
     /// called when entry swap out is complete
     virtual void swappedOut(const StoreEntry &e) = 0;
 
 protected:
     void parseOptions(int reconfiguring);
     void dumpOptions(StoreEntry * e) const;
     virtual ConfigOption *getOptionTree() const;
     virtual bool allowOptionReconfigure(const char *const) const { return true; }
 
     int64_t sizeInBlocks(const int64_t size) const { return (size + fs.blksize - 1) / fs.blksize; }
 
 private:
     bool optionReadOnlyParse(char const *option, const char *value, int reconfiguring);
     void optionReadOnlyDump(StoreEntry * e) const;
     bool optionObjectSizeParse(char const *option, const char *value, int reconfiguring);
     void optionObjectSizeDump(StoreEntry * e) const;
     char const *theType;
 
 protected:
     uint64_t max_size;        ///< maximum allocatable size of the storage area
     int64_t min_objsize;      ///< minimum size of any object stored here (-1 for no limit)
     int64_t max_objsize;      ///< maximum size of any object stored here (-1 for no limit)
 

=== modified file 'src/Transients.cc'
--- src/Transients.cc	2016-01-01 00:14:27 +0000
+++ src/Transients.cc	2016-07-13 17:17:11 +0000
@@ -170,61 +170,62 @@
     // If we already have a local entry, the store_table should have found it.
     // Since it did not, the local entry key must have changed from public to
     // private. We still need to keep the private entry around for syncing as
     // its clients depend on it, but we should not allow new clients to join.
     if (StoreEntry *oldE = locals->at(index)) {
         debugs(20, 3, "not joining private " << *oldE);
         assert(EBIT_TEST(oldE->flags, KEY_PRIVATE));
     } else if (StoreEntry *newE = copyFromShm(index)) {
         return newE; // keep read lock to receive updates from others
     }
 
     // private entry or loading failure
     map->closeForReading(index);
     return NULL;
 }
 
 StoreEntry *
 Transients::copyFromShm(const sfileno index)
 {
     const TransientsMapExtras::Item &extra = extras->items[index];
 
     // create a brand new store entry and initialize it with stored info
     StoreEntry *e = storeCreatePureEntry(extra.url, extra.url,
                                          extra.reqFlags, extra.reqMethod);
 
     assert(e->mem_obj);
     e->mem_obj->method = extra.reqMethod;
     e->mem_obj->xitTable.io = MemObject::ioReading;
     e->mem_obj->xitTable.index = index;
 
-    e->setPublicKey();
+    // TODO: Support collapsed revalidation for SMP-aware caches
+    e->setPublicKey(ksDefault);
     assert(e->key);
 
     // How do we know its SMP- and not just locally-collapsed? A worker gets
     // locally-collapsed entries from the local store_table, not Transients.
     // TODO: Can we remove smpCollapsed by not syncing non-transient entries?
     e->mem_obj->smpCollapsed = true;
 
     assert(!locals->at(index));
     // We do not lock e because we do not want to prevent its destruction;
     // e is tied to us via mem_obj so we will know when it is destructed.
     locals->at(index) = e;
     return e;
 }
 
 void
 Transients::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
 {
     // XXX: not needed but Store parent forces us to implement this
     fatal("Transients::get(key,callback,data) should not be called");
 }
 
 StoreEntry *
 Transients::findCollapsed(const sfileno index)
 {
     if (!map)
         return NULL;
 
     if (StoreEntry *oldE = locals->at(index)) {
         debugs(20, 5, "found " << *oldE << " at " << index << " in " << MapLabel);
         assert(oldE->mem_obj && oldE->mem_obj->xitTable.index == index);

=== modified file 'src/Transients.h'
--- src/Transients.h	2016-01-01 00:14:27 +0000
+++ src/Transients.h	2016-07-14 08:05:15 +0000
@@ -45,59 +45,60 @@
 
     /// the calling entry writer no longer expects to cache this entry
     void abandon(const StoreEntry &e);
 
     /// whether an in-transit entry is now abandoned by its writer
     bool abandoned(const StoreEntry &e) const;
 
     /// number of entry readers some time ago
     int readers(const StoreEntry &e) const;
 
     /// the caller is done writing or reading this entry
     void disconnect(MemObject &mem_obj);
 
     /* Store API */
     virtual int callback();
     virtual StoreEntry * get(const cache_key *);
     virtual void get(String const key , STOREGETCLIENT callback, void *cbdata);
     virtual void init();
     virtual uint64_t maxSize() const;
     virtual uint64_t minSize() const;
     virtual uint64_t currentSize() const;
     virtual uint64_t currentCount() const;
     virtual int64_t maxObjectSize() const;
     virtual void getStats(StoreInfoStats &stats) const;
     virtual void stat(StoreEntry &) const;
     virtual StoreSearch *search(String const url, HttpRequest *);
     virtual void reference(StoreEntry &);
     virtual bool dereference(StoreEntry &, bool);
     virtual void markForUnlink(StoreEntry &e);
     virtual void maintain();
+    virtual bool smpAware() const { return true; }
 
     static int64_t EntryLimit();
 
 protected:
     StoreEntry *copyFromShm(const sfileno index);
     bool copyToShm(const StoreEntry &e, const sfileno index, const RequestFlags &reqFlags, const HttpRequestMethod &reqMethod);
 
     bool abandonedAt(const sfileno index) const;
 
     // Ipc::StoreMapCleaner API
     virtual void noteFreeMapSlice(const Ipc::StoreMapSliceId sliceId);
 
 private:
     /// shared packed info indexed by Store keys, for creating new StoreEntries
     TransientsMap *map;
 
     /// shared packed info that standard StoreMap does not store for us
     typedef TransientsMapExtras Extras;
     Ipc::Mem::Pointer<Extras> extras;
 
     typedef std::vector<StoreEntry*> Locals;
     /// local collapsed entries indexed by transient ID, for syncing old StoreEntries
     Locals *locals;
 };
 
 // TODO: Why use Store as a base? We are not really a cache.
 
 #endif /* SQUID_TRANSIENTS_H */
 

=== modified file 'src/adaptation/History.cc'
--- src/adaptation/History.cc	2016-01-01 00:14:27 +0000
+++ src/adaptation/History.cc	2016-07-13 15:18:27 +0000
@@ -123,61 +123,61 @@
     if (theXxName.size() <= 0)
         return false;
 
     name = theXxName;
     value = theXxValue;
     return true;
 }
 
 void Adaptation::History::updateNextServices(const String &services)
 {
     if (theNextServices != TheNullServices)
         debugs(93,3, HERE << "old services: " << theNextServices);
     debugs(93,3, HERE << "new services: " << services);
     Must(services != TheNullServices);
     theNextServices = services;
 }
 
 bool Adaptation::History::extractNextServices(String &value)
 {
     if (theNextServices == TheNullServices)
         return false;
 
     value = theNextServices;
     theNextServices = TheNullServices; // prevents resetting the plan twice
     return true;
 }
 
 void Adaptation::History::recordMeta(const HttpHeader *lm)
 {
     lastMeta.clean();
-    lastMeta.update(lm, NULL);
+    lastMeta.update(lm);
 
-    allMeta.update(lm, NULL);
+    allMeta.update(lm);
     allMeta.compact();
 }
 
 void
 Adaptation::History::recordAdaptationService(SBuf &srvId)
 {
     theAdaptationServices.push_back(srvId);
 }
 
 void
 Adaptation::History::setFutureServices(const DynamicGroupCfg &services)
 {
     if (!theFutureServices.empty())
         debugs(93,3, HERE << "old future services: " << theFutureServices);
     debugs(93,3, HERE << "new future services: " << services);
     theFutureServices = services; // may be empty
 }
 
 bool Adaptation::History::extractFutureServices(DynamicGroupCfg &value)
 {
     if (theFutureServices.empty())
         return false;
 
     value = theFutureServices;
     theFutureServices.clear();
     return true;
 }
 

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2016-05-06 06:36:08 +0000
+++ src/cf.data.pre	2016-07-13 17:18:08 +0000
@@ -6059,71 +6059,83 @@
 
 	    note key value acl ...
 	    logformat myFormat ... %{key}note ...
 DOC_END
 
 NAME: relaxed_header_parser
 COMMENT: on|off|warn
 TYPE: tristate
 LOC: Config.onoff.relaxed_header_parser
 DEFAULT: on
 DOC_START
 	In the default "on" setting Squid accepts certain forms
 	of non-compliant HTTP messages where it is unambiguous
 	what the sending application intended even if the message
 	is not correctly formatted. The messages is then normalized
 	to the correct form when forwarded by Squid.
 
 	If set to "warn" then a warning will be emitted in cache.log
 	each time such HTTP error is encountered.
 
 	If set to "off" then such HTTP errors will cause the request
 	or response to be rejected.
 DOC_END
 
 NAME: collapsed_forwarding
 COMMENT: (on|off)
 TYPE: onoff
 LOC: Config.onoff.collapsed_forwarding
 DEFAULT: off
 DOC_START
-       This option controls whether Squid is allowed to merge multiple
-       potentially cachable requests for the same URI before Squid knows
-       whether the response is going to be cachable.
-
-       This feature is disabled by default: Enabling collapsed forwarding
-       needlessly delays forwarding requests that look cachable (when they are
-       collapsed) but then need to be forwarded individually anyway because
-       they end up being for uncachable content. However, in some cases, such
-       as accelleration of highly cachable content with periodic or groupped
-       expiration times, the gains from collapsing [large volumes of
-       simultenous refresh requests] outweigh losses from such delays.
+       When enabled, instead of forwarding each concurrent request for
+       the same URL, Squid just sends the first of them. The other, so
+       called "collapsed" requests, wait for the response to the first
+       request and, if it happens to be cachable, use that response.
+       Here, "concurrent requests" means "received after the first
+       request headers were parsed and before the corresponding response
+       headers were parsed".
+
+       This feature is disabled by default: enabling collapsed
+       forwarding needlessly delays forwarding requests that look
+       cachable (when they are collapsed) but then need to be forwarded
+       individually anyway because they end up being for uncachable
+       content. However, in some cases, such as acceleration of highly
+       cachable content with periodic or grouped expiration times, the
+       gains from collapsing [large volumes of simultaneous refresh
+       requests] outweigh losses from such delays.
+
+       Squid collapses two kinds of requests: regular client requests
+       received on one of the listening ports and internal "cache
+       revalidation" requests which are triggered by those regular
+       requests hitting a stale cached object. Revalidation collapsing
+       is currently disabled for Squid instances containing SMP-aware
+       disk or memory caches and for Vary-controlled cached objects.
 DOC_END
 
 COMMENT_START
  TIMEOUTS
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: forward_timeout
 COMMENT: time-units
 TYPE: time_t
 LOC: Config.Timeout.forward
 DEFAULT: 4 minutes
 DOC_START
 	This parameter specifies how long Squid should at most attempt in
 	finding a forwarding path for the request before giving up.
 DOC_END
 
 NAME: connect_timeout
 COMMENT: time-units
 TYPE: time_t
 LOC: Config.Timeout.connect
 DEFAULT: 1 minute
 DOC_START
 	This parameter specifies how long to wait for the TCP connect to
 	the requested server or peer to complete before Squid should
 	attempt to find another path where to forward the request.
 DOC_END
 
 NAME: peer_connect_timeout
 COMMENT: time-units

=== modified file 'src/client_side_reply.cc'
--- src/client_side_reply.cc	2016-04-01 06:15:31 +0000
+++ src/client_side_reply.cc	2016-07-16 20:33:23 +0000
@@ -45,61 +45,62 @@
 #endif
 #if USE_SQUID_ESI
 #include "esi/Esi.h"
 #endif
 
 #include <memory>
 
 CBDATA_CLASS_INIT(clientReplyContext);
 
 /* Local functions */
 extern "C" CSS clientReplyStatus;
 ErrorState *clientBuildError(err_type, Http::StatusCode, char const *, Ip::Address &, HttpRequest *);
 
 /* privates */
 
 clientReplyContext::~clientReplyContext()
 {
     deleting = true;
     /* This may trigger a callback back into SendMoreData as the cbdata
      * is still valid
      */
     removeClientStoreReference(&sc, http);
     /* old_entry might still be set if we didn't yet get the reply
      * code in HandleIMSReply() */
     removeStoreReference(&old_sc, &old_entry);
     safe_free(tempBuffer.data);
     cbdataReferenceDone(http);
     HTTPMSGUNLOCK(reply);
 }
 
-clientReplyContext::clientReplyContext(ClientHttpRequest *clientContext) : http (cbdataReference(clientContext)), old_entry (NULL), old_sc(NULL), deleting(false)
+clientReplyContext::clientReplyContext(ClientHttpRequest *clientContext) : http (cbdataReference(clientContext)), old_entry (NULL), old_sc(NULL), deleting(false),
+collapsedRevalidation(crNone)
 {}
 
 /** Create an error in the store awaiting the client side to read it.
  *
  * This may be better placed in the clientStream logic, but it has not been
  * relocated there yet
  */
 void
 clientReplyContext::setReplyToError(
     err_type err, Http::StatusCode status, const HttpRequestMethod& method, char const *uri,
     Ip::Address &addr, HttpRequest * failedrequest, const char *unparsedrequest,
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request
 #else
     void*
 #endif
 )
 {
     ErrorState *errstate = clientBuildError(err, status, uri, addr, failedrequest);
 
     if (unparsedrequest)
         errstate->request_hdrs = xstrdup(unparsedrequest);
 
 #if USE_AUTH
     errstate->auth_user_request = auth_user_request;
 #endif
     setReplyToError(method, errstate);
 }
 
 void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorState *errstate)
@@ -218,110 +219,138 @@
     errorAppendEntry(http->storeEntry(), err);
 }
 
 clientStreamNode *
 clientReplyContext::getNextNode() const
 {
     return (clientStreamNode *)ourNode->node.next->data;
 }
 
 /* This function is wrong - the client parameters don't include the
  * header offset
  */
 void
 clientReplyContext::triggerInitialStoreRead()
 {
     /* when confident, 0 becomes reqofs, and then this factors into
      * startSendProcess
      */
     assert(reqofs == 0);
     StoreIOBuffer localTempBuffer (next()->readBuffer.length, 0, next()->readBuffer.data);
     storeClientCopy(sc, http->storeEntry(), localTempBuffer, SendMoreData, this);
 }
 
 /* there is an expired entry in the store.
  * setup a temporary buffer area and perform an IMS to the origin
  */
 void
 clientReplyContext::processExpired()
 {
     const char *url = storeId();
-    StoreEntry *entry = NULL;
     debugs(88, 3, "clientReplyContext::processExpired: '" << http->uri << "'");
     assert(http->storeEntry()->lastmod >= 0);
     /*
      * check if we are allowed to contact other servers
      * @?@: Instead of a 504 (Gateway Timeout) reply, we may want to return
      *      a stale entry *if* it matches client requirements
      */
 
     if (http->onlyIfCached()) {
         processOnlyIfCachedMiss();
         return;
     }
 
     http->request->flags.refresh = true;
 #if STORE_CLIENT_LIST_DEBUG
     /* Prevent a race with the store client memory free routines
      */
     assert(storeClientIsThisAClient(sc, this));
 #endif
     /* Prepare to make a new temporary request */
     saveState();
-    entry = storeCreateEntry(url,
-                             http->log_uri, http->request->flags, http->request->method);
-    /* NOTE, don't call StoreEntry->lock(), storeCreateEntry() does it */
+
+    // TODO: support collapsed revalidation of Vary-controlled entries
+    const bool collapsingAllowed = Config.onoff.collapsed_forwarding &&
+                                   !Store::Root().smpAware() &&
+                                   http->request->vary_headers.isEmpty();
+
+    StoreEntry *entry = nullptr;
+    if (collapsingAllowed) {
+        if ((entry = storeGetPublicByRequest(http->request, ksRevalidation)))
+            entry->lock("clientReplyContext::processExpired#alreadyRevalidating");
+    }
+
+    if (entry) {
+        debugs(88, 5, "collapsed on existing revalidation entry: " << *entry);
+        collapsedRevalidation = crSlave;
+    } else {
+        entry = storeCreateEntry(url,
+                                 http->log_uri, http->request->flags, http->request->method);
+        /* NOTE, don't call StoreEntry->lock(), storeCreateEntry() does it */
+
+        if (collapsingAllowed) {
+            debugs(88, 5, "allow other revalidation requests to collapse on " << *entry);
+            Store::Root().allowCollapsing(entry, http->request->flags,
+                                          http->request->method);
+            collapsedRevalidation = crInitiator;
+        } else {
+            collapsedRevalidation = crNone;
+        }
+    }
+
     sc = storeClientListAdd(entry, this);
 #if USE_DELAY_POOLS
     /* delay_id is already set on original store client */
     sc->setDelayId(DelayId::DelayClient(http));
 #endif
 
     http->request->lastmod = old_entry->lastmod;
 
     if (!http->request->header.has(HDR_IF_NONE_MATCH)) {
         ETag etag = {NULL, -1}; // TODO: make that a default ETag constructor
         if (old_entry->hasEtag(etag) && !etag.weak)
             http->request->etag = etag.str;
     }
 
     debugs(88, 5, "clientReplyContext::processExpired : lastmod " << entry->lastmod );
     http->storeEntry(entry);
     assert(http->out.offset == 0);
     assert(http->request->clientConnectionManager == http->getConn());
 
-    /*
-     * A refcounted pointer so that FwdState stays around as long as
-     * this clientReplyContext does
-     */
-    Comm::ConnectionPointer conn = http->getConn() != NULL ? http->getConn()->clientConnection : NULL;
-    FwdState::Start(conn, http->storeEntry(), http->request, http->al);
+    if (collapsedRevalidation != crSlave) {
+        /*
+         * A refcounted pointer so that FwdState stays around as long as
+         * this clientReplyContext does
+         */
+        Comm::ConnectionPointer conn = http->getConn() != NULL ? http->getConn()->clientConnection : NULL;
+        FwdState::Start(conn, http->storeEntry(), http->request, http->al);
+    }
 
     /* Register with storage manager to receive updates when data comes in. */
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED))
         debugs(88, DBG_CRITICAL, "clientReplyContext::processExpired: Found ENTRY_ABORTED object");
 
     {
         /* start counting the length from 0 */
         StoreIOBuffer localTempBuffer(HTTP_REQBUF_SZ, 0, tempbuf);
         storeClientCopy(sc, entry, localTempBuffer, HandleIMSReply, this);
     }
 }
 
 void
 clientReplyContext::sendClientUpstreamResponse()
 {
     StoreIOBuffer tempresult;
     removeStoreReference(&old_sc, &old_entry);
     /* here the data to send is the data we just received */
     tempBuffer.offset = 0;
     old_reqsize = 0;
     /* sendMoreData tracks the offset as well.
      * Force it back to zero */
     reqofs = 0;
     assert(!EBIT_TEST(http->storeEntry()->flags, ENTRY_ABORTED));
     /* TODO: provide sendMoreData with the ready parsed reply */
     tempresult.length = reqsize;
     tempresult.data = tempbuf;
     sendMoreData(tempresult);
 }
@@ -381,60 +410,64 @@
     HttpReply *old_rep = (HttpReply *) old_entry->getReply();
 
     // origin replied 304
     if (status == Http::scNotModified) {
         http->logType = LOG_TCP_REFRESH_UNMODIFIED;
         http->request->flags.staleIfHit = false; // old_entry is no longer stale
 
         // update headers on existing entry
         old_rep->updateOnNotModified(http->storeEntry()->getReply());
         old_entry->timestampsSet();
 
         // if client sent IMS
 
         if (http->request->flags.ims && !old_entry->modifiedSince(http->request)) {
             // forward the 304 from origin
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and forwarding 304 to client");
             sendClientUpstreamResponse();
         } else {
             // send existing entry, it's still valid
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and sending " <<
                    old_rep->sline.status() << " to client");
             sendClientOldEntry();
         }
     }
 
     // origin replied with a non-error code
     else if (status > Http::scNone && status < Http::scInternalServerError) {
         // forward response from origin
         http->logType = LOG_TCP_REFRESH_MODIFIED;
         debugs(88, 3, "handleIMSReply: origin replied " << status << ", replacing existing entry and forwarding to client");
+
+        if (collapsedRevalidation)
+            http->storeEntry()->clearPublicKeyScope();
+
         sendClientUpstreamResponse();
     }
 
     // origin replied with an error
     else if (http->request->flags.failOnValidationError) {
         http->logType = LOG_TCP_REFRESH_FAIL_ERR;
         debugs(88, 3, "handleIMSReply: origin replied with error " << status <<
                ", forwarding to client due to fail_on_validation_err");
         sendClientUpstreamResponse();
     } else {
         // ignore and let client have old entry
         http->logType = LOG_TCP_REFRESH_FAIL_OLD;
         debugs(88, 3, "handleIMSReply: origin replied with error " <<
                status << ", sending old entry (" << old_rep->sline.status() << ") to client");
         sendClientOldEntry();
     }
 }
 
 SQUIDCEXTERN CSR clientGetMoreData;
 SQUIDCEXTERN CSD clientReplyDetach;
 
 /**
  * clientReplyContext::cacheHit Should only be called until the HTTP reply headers
  * have been parsed.  Normally this should be a single call, but
  * it might take more than one.  As soon as we have the headers,
  * we hand off to clientSendMoreData, processExpired, or
  * processMiss.
  */
 void
 clientReplyContext::CacheHit(void *data, StoreIOBuffer result)

=== modified file 'src/client_side_reply.h'
--- src/client_side_reply.h	2016-01-01 00:14:27 +0000
+++ src/client_side_reply.h	2016-07-13 19:19:08 +0000
@@ -106,35 +106,43 @@
     clientStreamNode * next() const;
     StoreIOBuffer holdingBuffer;
     HttpReply *reply;
     void processReplyAccess();
     static ACLCB ProcessReplyAccessResult;
     void processReplyAccessResult(const allow_t &accessAllowed);
     void cloneReply();
     void buildReplyHeader ();
     bool alwaysAllowResponse(Http::StatusCode sline) const;
     int checkTransferDone();
     void processOnlyIfCachedMiss();
     void processConditional(StoreIOBuffer &result);
     void cacheHit(StoreIOBuffer result);
     void handleIMSReply(StoreIOBuffer result);
     void sendMoreData(StoreIOBuffer result);
     void triggerInitialStoreRead();
     void sendClientOldEntry();
     void purgeAllCached();
     void forgetHit();
     bool blockedHit() const;
 
     void sendBodyTooLargeError();
     void sendPreconditionFailedError();
     void sendNotModified();
     void sendNotModifiedOrPreconditionFailedError();
 
     StoreEntry *old_entry;
     store_client *old_sc;   /* ... for entry to be validated */
     bool deleting;
 
+    typedef enum {
+        crNone = 0, ///< collapsed revalidation is not allowed for this context
+        crInitiator, ///< we initiated collapsed revalidation request
+        crSlave ///< we collapsed on the existing revalidation request
+    } CollapsedRevalidation;
+
+    CollapsedRevalidation collapsedRevalidation;
+
     CBDATA_CLASS2(clientReplyContext);
 };
 
 #endif /* SQUID_CLIENTSIDEREPLY_H */
 

=== modified file 'src/client_side_request.cc'
--- src/client_side_request.cc	2016-05-06 08:24:29 +0000
+++ src/client_side_request.cc	2016-07-13 15:18:56 +0000
@@ -309,61 +309,61 @@
         http->al->cache.start_time = current_time;
     /* this is only used to adjust the connection offset in client_side.c */
     http->req_sz = 0;
     tempBuffer.length = taillen;
     tempBuffer.data = tailbuf;
     /* client stream setup */
     clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, new clientReplyContext(http), streamcallback,
                      streamdetach, streamdata, tempBuffer);
     /* make it visible in the 'current acctive requests list' */
     /* Set flags */
     /* internal requests only makes sense in an
      * accelerator today. TODO: accept flags ? */
     http->flags.accel = true;
     /* allow size for url rewriting */
     url_sz = strlen(url) + Config.appendDomainLen + 5;
     http->uri = (char *)xcalloc(url_sz, 1);
     strcpy(http->uri, url);
 
     if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, method)) == NULL) {
         debugs(85, 5, "Invalid URL: " << http->uri);
         return -1;
     }
 
     /*
      * now update the headers in request with our supplied headers. urlParse
      * should return a blank header set, but we use Update to be sure of
      * correctness.
      */
     if (header)
-        request->header.update(header, NULL);
+        request->header.update(header);
 
     http->log_uri = xstrdup(urlCanonicalClean(request));
 
     /* http struct now ready */
 
     /*
      * build new header list *? TODO
      */
     request->flags.accelerated = http->flags.accel;
 
     request->flags.internalClient = true;
 
     /* this is an internally created
      * request, not subject to acceleration
      * target overrides */
     /*
      * FIXME? Do we want to detect and handle internal requests of internal
      * objects ?
      */
 
     /* Internally created requests cannot have bodies today */
     request->content_length = 0;
 
     request->client_addr.setNoAddr();
 
 #if FOLLOW_X_FORWARDED_FOR
     request->indirect_client_addr.setNoAddr();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
     request->my_addr.setNoAddr();   /* undefined for internal requests */

=== modified file 'src/esi/Include.cc'
--- src/esi/Include.cc	2016-01-01 00:14:27 +0000
+++ src/esi/Include.cc	2016-07-14 11:09:56 +0000
@@ -252,61 +252,61 @@
     if (resultI->srcurl)
         resultI->src = ESIStreamContextNew (resultI);
 
     if (resultI->alturl)
         resultI->alt = ESIStreamContextNew (resultI);
 
     return result;
 }
 
 ESIInclude::ESIInclude(ESIInclude const &old) :
     varState(NULL),
     srcurl(NULL),
     alturl(NULL),
     parent(NULL),
     started(false),
     sent(false)
 {
     memset(&flags, 0, sizeof(flags));
     flags.onerrorcontinue = old.flags.onerrorcontinue;
 
     if (old.srcurl)
         srcurl = xstrdup(old.srcurl);
 
     if (old.alturl)
         alturl = xstrdup(old.alturl);
 }
 
 void
 ESIInclude::prepareRequestHeaders(HttpHeader &tempheaders, ESIVarState *vars)
 {
-    tempheaders.update (&vars->header(), NULL);
+    tempheaders.update (&vars->header());
     tempheaders.removeHopByHopEntries();
 }
 
 void
 ESIInclude::Start (ESIStreamContext::Pointer stream, char const *url, ESIVarState *vars)
 {
     if (!stream.getRaw())
         return;
 
     HttpHeader tempheaders(hoRequest);
 
     prepareRequestHeaders(tempheaders, vars);
 
     /* Ensure variable state is clean */
     vars->feedData(url, strlen (url));
 
     /* tempUrl is eaten by the request */
     char const *tempUrl = vars->extractChar ();
 
     debugs(86, 5, "ESIIncludeStart: Starting subrequest with url '" << tempUrl << "'");
 
     if (clientBeginRequest(Http::METHOD_GET, tempUrl, esiBufferRecipient, esiBufferDetach, stream.getRaw(), &tempheaders, stream->localbuffer->buf, HTTP_REQBUF_SZ)) {
         debugs(86, DBG_CRITICAL, "starting new ESI subrequest failed");
     }
 
     tempheaders.clean();
 }
 
 ESIInclude::ESIInclude(esiTreeParentPtr aParent, int attrcount, char const **attr, ESIContext *aContext) :
     varState(NULL),

=== modified file 'src/fs/rock/RockSwapDir.h'
--- src/fs/rock/RockSwapDir.h	2016-01-01 00:14:27 +0000
+++ src/fs/rock/RockSwapDir.h	2016-07-15 16:55:46 +0000
@@ -21,60 +21,61 @@
 class DiskIOStrategy;
 class ReadRequest;
 class WriteRequest;
 
 namespace Rock
 {
 
 /// \ingroup Rock
 class SwapDir: public ::SwapDir, public IORequestor, public Ipc::StoreMapCleaner
 {
 public:
     typedef RefCount<SwapDir> Pointer;
     typedef Ipc::StoreMap DirMap;
 
     SwapDir();
     virtual ~SwapDir();
 
     /* public ::SwapDir API */
     virtual void reconfigure();
     virtual StoreSearch *search(String const url, HttpRequest *);
     virtual StoreEntry *get(const cache_key *key);
     virtual void get(String const, STOREGETCLIENT, void * cbdata);
     virtual void markForUnlink(StoreEntry &e);
     virtual void disconnect(StoreEntry &e);
     virtual uint64_t currentSize() const;
     virtual uint64_t currentCount() const;
     virtual bool doReportStat() const;
     virtual void swappedOut(const StoreEntry &e);
     virtual void create();
     virtual void parse(int index, char *path);
+    virtual bool smpAware() const { return true; }
 
     // temporary path to the shared memory map of first slots of cached entries
     SBuf inodeMapPath() const;
     // temporary path to the shared memory stack of free slots
     const char *freeSlotsPath() const;
 
     int64_t entryLimitAbsolute() const { return SwapFilenMax+1; } ///< Core limit
     int64_t entryLimitActual() const; ///< max number of possible entries in db
     int64_t slotLimitAbsolute() const; ///< Rock store implementation limit
     int64_t slotLimitActual() const; ///< total number of slots in this db
 
     /// removes a slot from a list of free slots or returns false
     bool useFreeSlot(Ipc::Mem::PageId &pageId);
     /// whether the given slot ID may point to a slot in this db
     bool validSlotId(const SlotId slotId) const;
     /// purges one or more entries to make full() false and free some slots
     void purgeSome();
 
     int64_t diskOffset(Ipc::Mem::PageId &pageId) const;
     int64_t diskOffset(int filen) const;
     void writeError(StoreEntry &e);
 
     /* StoreMapCleaner API */
     virtual void noteFreeMapSlice(const Ipc::StoreMapSliceId fileno);
 
     uint64_t slotSize; ///< all db slots are of this size
 
 protected:
     /* Store API */
     virtual bool anchorCollapsed(StoreEntry &collapsed, bool &inSync);

=== modified file 'src/fs/ufs/UFSSwapDir.h'
--- src/fs/ufs/UFSSwapDir.h	2016-01-01 00:14:27 +0000
+++ src/fs/ufs/UFSSwapDir.h	2016-07-15 18:33:56 +0000
@@ -63,60 +63,61 @@
      * UFS filesystems will happily store anything as long as
      * the LRU time isn't too small
      */
     virtual bool canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const;
     /** reference an object
      *
      * This routine is called whenever an object is referenced, so we can
      * maintain replacement information within the storage fs.
      */
     virtual void reference(StoreEntry &);
     /** de-reference an object
      *
      * This routine is called whenever the last reference to an object is
      * removed, to maintain replacement information within the storage fs.
      */
     virtual bool dereference(StoreEntry &, bool);
     virtual StoreIOState::Pointer createStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
     virtual StoreIOState::Pointer openStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
     virtual void openLog();
     virtual void closeLog();
     virtual int writeCleanStart();
     virtual void writeCleanDone();
     virtual void logEntry(const StoreEntry & e, int op) const;
     virtual void parse(int index, char *path); ///parse configuration and setup new SwapDir
     virtual void reconfigure(); ///reconfigure the SwapDir
     virtual int callback();
     virtual void sync();
     virtual void swappedOut(const StoreEntry &e);
     virtual uint64_t currentSize() const { return cur_size; }
     virtual uint64_t currentCount() const { return n_disk_objects; }
+    virtual bool smpAware() const { return false; }
 
     void unlinkFile(sfileno f);
     // move down when unlink is a virtual method
     //protected:
     Fs::Ufs::UFSStrategy *IO;
     char *fullPath(sfileno, char *) const;
     /* temp */
     void closeTmpSwapLog();
     FILE *openTmpSwapLog(int *clean_flag, int *zero_flag);
     char *swapSubDir(int subdirn) const;
     int mapBitTest(sfileno filn);
     void mapBitReset(sfileno filn);
     void mapBitSet(sfileno filn);
     /** Add a new object to the cache with empty memory copy and pointer to disk
      *
      * This method is used to rebuild a store from disk
      */
     StoreEntry *addDiskRestore(const cache_key * key,
                                sfileno file_number,
                                uint64_t swap_file_sz,
                                time_t expires,
                                time_t timestamp,
                                time_t lastref,
                                time_t lastmod,
                                uint32_t refcount,
                                uint16_t flags,
                                int clean);
     /// Undo the effects of UFSSwapDir::addDiskRestore().
     void undoAddDiskRestore(StoreEntry *e);
     int validFileno(sfileno filn, int flag) const;

=== modified file 'src/main.cc'
--- src/main.cc	2016-03-02 09:12:10 +0000
+++ src/main.cc	2016-07-13 15:19:52 +0000
@@ -1042,62 +1042,60 @@
         disk_init();        /* disk_init must go before ipcache_init() */
 
     ipcache_init();
 
     fqdncache_init();
 
     parseEtcHosts();
 
     dnsInit();
 
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
 #endif
 
 #if USE_OPENSSL
     if (!configured_once)
         Ssl::initialize_session_cache();
 
     if (Ssl::CertValidationHelper::GetInstance())
         Ssl::CertValidationHelper::GetInstance()->Init();
 #endif
 
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
 #endif
     externalAclInit();
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
-    httpReplyInitModule();  /* must go before accepting replies */
-
     errorInitialize();
 
     accessLogInit();
 
 #if ICAP_CLIENT
     icapLogOpen();
 #endif
 
 #if USE_IDENT
     Ident::Init();
 #endif
 
 #if SQUID_SNMP
 
     snmpInit();
 
 #endif
 #if MALLOC_DBG
 
     malloc_debug(0, malloc_debug_level);
 
 #endif
 
     if (!configured_once) {
         if (unlinkdNeeded())
             unlinkdInit();
 
         urlInitialize();
         statInit();
         storeInit();

=== modified file 'src/store.cc'
--- src/store.cc	2016-04-01 06:15:31 +0000
+++ src/store.cc	2016-07-21 08:20:17 +0000
@@ -135,66 +135,66 @@
 
 void
 Store::sync()
 {}
 
 void
 Store::unlink (StoreEntry &anEntry)
 {
     fatal("Store::unlink on invalid Store\n");
 }
 
 void *
 StoreEntry::operator new (size_t bytecount)
 {
     assert (bytecount == sizeof (StoreEntry));
 
     if (!pool) {
         pool = memPoolCreate ("StoreEntry", bytecount);
     }
 
     return pool->alloc();
 }
 
 void
 StoreEntry::operator delete (void *address)
 {
     pool->freeOne(address);
 }
 
 void
-StoreEntry::makePublic()
+StoreEntry::makePublic(const KeyScope scope)
 {
     /* This object can be cached for a long time */
 
     if (!EBIT_TEST(flags, RELEASE_REQUEST))
-        setPublicKey();
+        setPublicKey(scope);
 }
 
 void
 StoreEntry::makePrivate()
 {
     /* This object should never be cached at all */
     expireNow();
     releaseRequest(); /* delete object when not used */
 }
 
 void
 StoreEntry::cacheNegatively()
 {
     /* This object may be negatively cached */
     negativeCache();
     makePublic();
 }
 
 size_t
 StoreEntry::inUseCount()
 {
     if (!pool)
         return 0;
     return pool->getInUseCount();
 }
 
 const char *
 StoreEntry::getMD5Text() const
 {
     return storeKeyText((const cache_key *)key);
@@ -558,242 +558,277 @@
 StoreEntry::getPublicByRequest (StoreClient *aClient, HttpRequest * request)
 {
     assert (aClient);
     StoreEntry *result = storeGetPublicByRequest (request);
 
     if (!result)
         result = NullStoreEntry::getInstance();
 
     aClient->created (result);
 }
 
 void
 StoreEntry::getPublic (StoreClient *aClient, const char *uri, const HttpRequestMethod& method)
 {
     assert (aClient);
     StoreEntry *result = storeGetPublic (uri, method);
 
     if (!result)
         result = NullStoreEntry::getInstance();
 
     aClient->created (result);
 }
 
 StoreEntry *
 storeGetPublic(const char *uri, const HttpRequestMethod& method)
 {
     return Store::Root().get(storeKeyPublic(uri, method));
 }
 
 StoreEntry *
-storeGetPublicByRequestMethod(HttpRequest * req, const HttpRequestMethod& method)
+storeGetPublicByRequestMethod(HttpRequest * req, const HttpRequestMethod& method, const KeyScope keyScope)
 {
-    return Store::Root().get(storeKeyPublicByRequestMethod(req, method));
+    return Store::Root().get(storeKeyPublicByRequestMethod(req, method, keyScope));
 }
 
 StoreEntry *
-storeGetPublicByRequest(HttpRequest * req)
+storeGetPublicByRequest(HttpRequest * req, const KeyScope keyScope)
 {
-    StoreEntry *e = storeGetPublicByRequestMethod(req, req->method);
+    StoreEntry *e = storeGetPublicByRequestMethod(req, req->method, keyScope);
 
     if (e == NULL && req->method == Http::METHOD_HEAD)
         /* We can generate a HEAD reply from a cached GET object */
-        e = storeGetPublicByRequestMethod(req, Http::METHOD_GET);
+        e = storeGetPublicByRequestMethod(req, Http::METHOD_GET, keyScope);
 
     return e;
 }
 
 static int
 getKeyCounter(void)
 {
     static int key_counter = 0;
 
     if (++key_counter < 0)
         key_counter = 1;
 
     return key_counter;
 }
 
 /* RBC 20050104 AFAICT this should become simpler:
  * rather than reinserting with a special key it should be marked
  * as 'released' and then cleaned up when refcounting indicates.
  * the StoreHashIndex could well implement its 'released' in the
  * current manner.
  * Also, clean log writing should skip over ia,t
  * Otherwise, we need a 'remove from the index but not the store
  * concept'.
  */
 void
 StoreEntry::setPrivateKey()
 {
     const cache_key *newkey;
 
     if (key && EBIT_TEST(flags, KEY_PRIVATE))
         return;                 /* is already private */
 
     if (key) {
         setReleaseFlag(); // will markForUnlink(); all caches/workers will know
 
         // TODO: move into SwapDir::markForUnlink() already called by Root()
         if (swap_filen > -1)
             storeDirSwapLog(this, SWAP_LOG_DEL);
 
         hashDelete();
     }
 
     if (mem_obj && mem_obj->hasUris()) {
         mem_obj->id = getKeyCounter();
         newkey = storeKeyPrivate(mem_obj->storeId(), mem_obj->method, mem_obj->id);
     } else {
         newkey = storeKeyPrivate("JUNK", Http::METHOD_NONE, getKeyCounter());
     }
 
     assert(hash_lookup(store_table, newkey) == NULL);
     EBIT_SET(flags, KEY_PRIVATE);
     hashInsert(newkey);
 }
 
 void
-StoreEntry::setPublicKey()
+StoreEntry::setPublicKey(const KeyScope scope)
 {
-    const cache_key *newkey;
-
     if (key && !EBIT_TEST(flags, KEY_PRIVATE))
         return;                 /* is already public */
 
     assert(mem_obj);
 
     /*
      * We can't make RELEASE_REQUEST objects public.  Depending on
      * when RELEASE_REQUEST gets set, we might not be swapping out
      * the object.  If we're not swapping out, then subsequent
      * store clients won't be able to access object data which has
      * been freed from memory.
      *
      * If RELEASE_REQUEST is set, setPublicKey() should not be called.
      */
 #if MORE_DEBUG_OUTPUT
 
     if (EBIT_TEST(flags, RELEASE_REQUEST))
         debugs(20, DBG_IMPORTANT, "assertion failed: RELEASE key " << key << ", url " << mem_obj->url);
 
 #endif
 
     assert(!EBIT_TEST(flags, RELEASE_REQUEST));
 
-    if (mem_obj->request) {
-        HttpRequest *request = mem_obj->request;
-
-        if (mem_obj->vary_headers.isEmpty()) {
-            /* First handle the case where the object no longer varies */
-            request->vary_headers.clear();
-        } else {
-            if (!request->vary_headers.isEmpty() && request->vary_headers.cmp(mem_obj->vary_headers) != 0) {
-                /* Oops.. the variance has changed. Kill the base object
-                 * to record the new variance key
-                 */
-                request->vary_headers.clear();       /* free old "bad" variance key */
-                if (StoreEntry *pe = storeGetPublic(mem_obj->storeId(), mem_obj->method))
-                    pe->release();
-            }
-
-            /* Make sure the request knows the variance status */
-            if (request->vary_headers.isEmpty())
-                request->vary_headers = httpMakeVaryMark(request, mem_obj->getReply());
-        }
-
-        // TODO: storeGetPublic() calls below may create unlocked entries.
-        // We should add/use storeHas() API or lock/unlock those entries.
-        if (!mem_obj->vary_headers.isEmpty() && !storeGetPublic(mem_obj->storeId(), mem_obj->method)) {
-            /* Create "vary" base object */
-            String vary;
-            StoreEntry *pe = storeCreateEntry(mem_obj->storeId(), mem_obj->logUri(), request->flags, request->method);
-            /* We are allowed to do this typecast */
-            HttpReply *rep = new HttpReply;
-            rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
-            vary = mem_obj->getReply()->header.getList(HDR_VARY);
-
-            if (vary.size()) {
-                /* Again, we own this structure layout */
-                rep->header.putStr(HDR_VARY, vary.termedBuf());
-                vary.clean();
-            }
-
-#if X_ACCELERATOR_VARY
-            vary = mem_obj->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
-
-            if (vary.size() > 0) {
-                /* Again, we own this structure layout */
-                rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.termedBuf());
-                vary.clean();
-            }
-
-#endif
-            pe->replaceHttpReply(rep, false); // no write until key is public
-
-            pe->timestampsSet();
-
-            pe->makePublic();
-
-            pe->startWriting(); // after makePublic()
-
-            pe->complete();
-
-            pe->unlock("StoreEntry::setPublicKey+Vary");
-        }
-
-        newkey = storeKeyPublicByRequest(mem_obj->request);
-    } else
-        newkey = storeKeyPublic(mem_obj->storeId(), mem_obj->method);
-
+    adjustVary();
+    forcePublicKey(calcPublicKey(scope));
+}
+
+void
+StoreEntry::clearPublicKeyScope()
+{
+    if (!key || EBIT_TEST(flags, KEY_PRIVATE))
+        return; // probably the old public key was deleted or made private
+
+    // TODO: adjustVary() when collapsed revalidation supports that
+
+    const cache_key *newKey = calcPublicKey(ksDefault);
+    if (!storeKeyHashCmp(key, newKey))
+        return; // probably another collapsed revalidation beat us to this change
+
+    forcePublicKey(newKey);
+}
+
+/// Unconditionally sets public key for this store entry.
+/// Releases the old entry with the same public key (if any).
+void
+StoreEntry::forcePublicKey(const cache_key *newkey)
+{
     if (StoreEntry *e2 = (StoreEntry *)hash_lookup(store_table, newkey)) {
+        assert(e2 != this);
         debugs(20, 3, "Making old " << *e2 << " private.");
         e2->setPrivateKey();
         e2->release();
-
-        if (mem_obj->request)
-            newkey = storeKeyPublicByRequest(mem_obj->request);
-        else
-            newkey = storeKeyPublic(mem_obj->storeId(), mem_obj->method);
     }
 
     if (key)
         hashDelete();
 
     EBIT_CLR(flags, KEY_PRIVATE);
 
     hashInsert(newkey);
 
     if (swap_filen > -1)
         storeDirSwapLog(this, SWAP_LOG_ADD);
 }
 
+/// Calculates correct public key for feeding forcePublicKey().
+/// Assumes adjustVary() has been called for this entry already.
+const cache_key *
+StoreEntry::calcPublicKey(const KeyScope keyScope)
+{
+    assert(mem_obj);
+    return mem_obj->request ?  storeKeyPublicByRequest(mem_obj->request, keyScope) :
+           storeKeyPublic(mem_obj->storeId(), mem_obj->method, keyScope);
+}
+
+/// Updates mem_obj->request->vary_headers to reflect the current Vary.
+/// The vary_headers field is used to calculate the Vary marker key.
+/// Releases the old Vary marker with an outdated key (if any).
+void
+StoreEntry::adjustVary()
+{
+    assert(mem_obj);
+
+    if (!mem_obj->request)
+        return;
+
+    HttpRequest *request = mem_obj->request;
+
+    if (mem_obj->vary_headers.isEmpty()) {
+        /* First handle the case where the object no longer varies */
+        request->vary_headers.clear();
+    } else {
+        if (!request->vary_headers.isEmpty() && request->vary_headers.cmp(mem_obj->vary_headers) != 0) {
+            /* Oops.. the variance has changed. Kill the base object
+             * to record the new variance key
+             */
+            request->vary_headers.clear();       /* free old "bad" variance key */
+            if (StoreEntry *pe = storeGetPublic(mem_obj->storeId(), mem_obj->method))
+                pe->release();
+        }
+
+        /* Make sure the request knows the variance status */
+        if (request->vary_headers.isEmpty())
+            request->vary_headers = httpMakeVaryMark(request, mem_obj->getReply());
+    }
+
+    // TODO: storeGetPublic() calls below may create unlocked entries.
+    // We should add/use storeHas() API or lock/unlock those entries.
+    if (!mem_obj->vary_headers.isEmpty() && !storeGetPublic(mem_obj->storeId(), mem_obj->method)) {
+        /* Create "vary" base object */
+        String vary;
+        StoreEntry *pe = storeCreateEntry(mem_obj->storeId(), mem_obj->logUri(), request->flags, request->method);
+        /* We are allowed to do this typecast */
+        HttpReply *rep = new HttpReply;
+        rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
+        vary = mem_obj->getReply()->header.getList(HDR_VARY);
+
+        if (vary.size()) {
+            /* Again, we own this structure layout */
+            rep->header.putStr(HDR_VARY, vary.termedBuf());
+            vary.clean();
+        }
+
+#if X_ACCELERATOR_VARY
+        vary = mem_obj->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
+
+        if (vary.size() > 0) {
+            /* Again, we own this structure layout */
+            rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.termedBuf());
+            vary.clean();
+        }
+
+#endif
+        pe->replaceHttpReply(rep, false); // no write until key is public
+
+        pe->timestampsSet();
+
+        pe->makePublic();
+
+        pe->startWriting(); // after makePublic()
+
+        pe->complete();
+
+        pe->unlock("StoreEntry::forcePublicKey+Vary");
+    }
+}
+
 StoreEntry *
 storeCreatePureEntry(const char *url, const char *log_url, const RequestFlags &flags, const HttpRequestMethod& method)
 {
     StoreEntry *e = NULL;
     debugs(20, 3, "storeCreateEntry: '" << url << "'");
 
     e = new StoreEntry();
     e->makeMemObject();
     e->mem_obj->setUris(url, log_url, method);
 
     if (flags.cachable) {
         EBIT_CLR(e->flags, RELEASE_REQUEST);
     } else {
         e->releaseRequest();
     }
 
     e->store_status = STORE_PENDING;
     e->refcount = 0;
     e->lastref = squid_curtime;
     e->timestamp = -1;          /* set in StoreEntry::timestampsSet() */
     e->ping_status = PING_NONE;
     EBIT_SET(e->flags, ENTRY_VALIDATED);
     return e;
 }
 
 StoreEntry *
 storeCreateEntry(const char *url, const char *logUrl, const RequestFlags &flags, const HttpRequestMethod& method)
 {
     StoreEntry *e = storeCreatePureEntry(url, logUrl, flags, method);
     e->lock("storeCreateEntry");
@@ -1522,106 +1557,114 @@
     if (EBIT_TEST(flags, ENTRY_ABORTED))
         return 0;
 
     // now check that the entry has a cache backing or is collapsed
     if (swap_filen > -1) // backed by a disk cache
         return 1;
 
     if (swappingOut()) // will be backed by a disk cache
         return 1;
 
     if (!mem_obj) // not backed by a memory cache and not collapsed
         return 0;
 
     // StoreEntry::storeClientType() assumes DISK_CLIENT here, but there is no
     // disk cache backing that store_client constructor will assert. XXX: This
     // is wrong for range requests (that could feed off nibbled memory) and for
     // entries backed by the shared memory cache (that could, in theory, get
     // nibbled bytes from that cache, but there is no such "memoryIn" code).
     if (mem_obj->inmem_lo) // in memory cache, but got nibbled at
         return 0;
 
     // The following check is correct but useless at this position. TODO: Move
     // it up when the shared memory cache can either replenish locally nibbled
     // bytes or, better, does not use local RAM copy at all.
     // if (mem_obj->memCache.index >= 0) // backed by a shared memory cache
     //    return 1;
 
     return 1;
 }
 
-void
+bool
 StoreEntry::timestampsSet()
 {
     const HttpReply *reply = getReply();
     time_t served_date = reply->date;
     int age = reply->header.getInt(HDR_AGE);
     /* Compute the timestamp, mimicking RFC2616 section 13.2.3. */
     /* make sure that 0 <= served_date <= squid_curtime */
 
     if (served_date < 0 || served_date > squid_curtime)
         served_date = squid_curtime;
 
     /* Bug 1791:
      * If the returned Date: is more than 24 hours older than
      * the squid_curtime, then one of us needs to use NTP to set our
      * clock.  We'll pretend that our clock is right.
      */
     else if (served_date < (squid_curtime - 24 * 60 * 60) )
         served_date = squid_curtime;
 
     /*
      * Compensate with Age header if origin server clock is ahead
      * of us and there is a cache in between us and the origin
      * server.  But DONT compensate if the age value is larger than
      * squid_curtime because it results in a negative served_date.
      */
     if (age > squid_curtime - served_date)
         if (squid_curtime > age)
             served_date = squid_curtime - age;
 
     // compensate for Squid-to-server and server-to-Squid delays
     if (mem_obj && mem_obj->request) {
         const time_t request_sent =
             mem_obj->request->hier.peer_http_request_sent.tv_sec;
         if (0 < request_sent && request_sent < squid_curtime)
             served_date -= (squid_curtime - request_sent);
     }
 
+    time_t exp = 0;
     if (reply->expires > 0 && reply->date > -1)
-        expires = served_date + (reply->expires - reply->date);
+        exp = served_date + (reply->expires - reply->date);
     else
-        expires = reply->expires;
+        exp = reply->expires;
+
+    if (lastmod == reply->last_modified && timestamp == served_date && expires == exp)
+        return false;
+
+    expires = exp;
 
     lastmod = reply->last_modified;
 
     timestamp = served_date;
+
+    return true;
 }
 
 void
 StoreEntry::registerAbort(STABH * cb, void *data)
 {
     assert(mem_obj);
     assert(mem_obj->abort.callback == NULL);
     mem_obj->abort.callback = cb;
     mem_obj->abort.data = cbdataReference(data);
 }
 
 void
 StoreEntry::unregisterAbort()
 {
     assert(mem_obj);
     if (mem_obj->abort.callback) {
         mem_obj->abort.callback = NULL;
         cbdataReferenceDone(mem_obj->abort.data);
     }
 }
 
 void
 StoreEntry::dump(int l) const
 {
     debugs(20, l, "StoreEntry->key: " << getMD5Text());
     debugs(20, l, "StoreEntry->next: " << next);
     debugs(20, l, "StoreEntry->mem_obj: " << mem_obj);
     debugs(20, l, "StoreEntry->timestamp: " << timestamp);
     debugs(20, l, "StoreEntry->lastref: " << lastref);
     debugs(20, l, "StoreEntry->expires: " << expires);

=== modified file 'src/store_dir.cc'
--- src/store_dir.cc	2016-01-01 00:14:27 +0000
+++ src/store_dir.cc	2016-07-14 15:00:40 +0000
@@ -50,61 +50,61 @@
 StoreController::~StoreController()
 {
     delete memStore;
     delete transients;
 }
 
 /*
  * This function pointer is set according to 'store_dir_select_algorithm'
  * in squid.conf.
  */
 STDIRSELECT *storeDirSelectSwapDir = storeDirSelectSwapDirLeastLoad;
 
 void
 StoreController::init()
 {
     if (Config.memShared && IamWorkerProcess()) {
         memStore = new MemStore;
         memStore->init();
     }
 
     swapDir->init();
 
     if (0 == strcasecmp(Config.store_dir_select_algorithm, "round-robin")) {
         storeDirSelectSwapDir = storeDirSelectSwapDirRoundRobin;
         debugs(47, DBG_IMPORTANT, "Using Round Robin store dir selection");
     } else {
         storeDirSelectSwapDir = storeDirSelectSwapDirLeastLoad;
         debugs(47, DBG_IMPORTANT, "Using Least Load store dir selection");
     }
 
-    if (UsingSmp() && IamWorkerProcess() && Config.onoff.collapsed_forwarding) {
+    if (UsingSmp() && IamWorkerProcess() && Config.onoff.collapsed_forwarding && smpAware()) {
         transients = new Transients;
         transients->init();
     }
 }
 
 void
 StoreController::createOneStore(Store &aStore)
 {
     /*
      * On Windows, fork() is not available.
      * The following is a workaround for create store directories sequentially
      * when running on native Windows port.
      */
 #if !_SQUID_WINDOWS_
 
     if (fork())
         return;
 
 #endif
 
     aStore.create();
 
 #if !_SQUID_WINDOWS_
 
     exit(0);
 
 #endif
 }
 
 void
@@ -889,61 +889,62 @@
         // leave keepInLocalMemory false; memStore maintains its own cache
     } else {
         keepInLocalMemory = keepForLocalMemoryCache(e) && // in good shape and
                             // the local memory cache is not overflowing
                             (mem_node::InUseCount() <= store_pages_max);
     }
 
     // An idle, unlocked entry that only belongs to a SwapDir which controls
     // its own index, should not stay in the global store_table.
     if (!dereference(e, keepInLocalMemory)) {
         debugs(20, 5, HERE << "destroying unlocked entry: " << &e << ' ' << e);
         destroyStoreEntry(static_cast<hash_link*>(&e));
         return;
     }
 
     debugs(20, 5, HERE << "keepInLocalMemory: " << keepInLocalMemory);
 
     // TODO: move this into [non-shared] memory cache class when we have one
     if (keepInLocalMemory) {
         e.setMemStatus(IN_MEMORY);
         e.mem_obj->unlinkRequest();
     } else {
         e.purgeMem(); // may free e
     }
 }
 
 void
 StoreController::allowCollapsing(StoreEntry *e, const RequestFlags &reqFlags,
                                  const HttpRequestMethod &reqMethod)
 {
-    e->makePublic(); // this is needed for both local and SMP collapsing
+    const KeyScope keyScope = reqFlags.refresh ? ksRevalidation : ksDefault;
+    e->makePublic(keyScope); // this is needed for both local and SMP collapsing
     if (transients)
         transients->startWriting(e, reqFlags, reqMethod);
     debugs(20, 3, "may " << (transients && e->mem_obj->xitTable.index >= 0 ?
                              "SMP-" : "locally-") << "collapse " << *e);
 }
 
 void
 StoreController::syncCollapsed(const sfileno xitIndex)
 {
     assert(transients);
 
     StoreEntry *collapsed = transients->findCollapsed(xitIndex);
     if (!collapsed) { // the entry is no longer locally active, ignore update
         debugs(20, 7, "not SMP-syncing not-transient " << xitIndex);
         return;
     }
     assert(collapsed->mem_obj);
     assert(collapsed->mem_obj->smpCollapsed);
 
     debugs(20, 7, "syncing " << *collapsed);
 
     bool abandoned = transients->abandoned(*collapsed);
     bool found = false;
     bool inSync = false;
     if (memStore && collapsed->mem_obj->memCache.io == MemObject::ioDone) {
         found = true;
         inSync = true;
         debugs(20, 7, "fully mem-loaded " << *collapsed);
     } else if (memStore && collapsed->mem_obj->memCache.index >= 0) {
         found = true;
@@ -976,60 +977,66 @@
 /// For cached entries, return true after synchronizing them with their cache
 /// (making inSync true on success). For not-yet-cached entries, return false.
 bool
 StoreController::anchorCollapsed(StoreEntry &collapsed, bool &inSync)
 {
     // this method is designed to work with collapsed transients only
     assert(collapsed.mem_obj);
     assert(collapsed.mem_obj->xitTable.index >= 0);
     assert(collapsed.mem_obj->smpCollapsed);
 
     debugs(20, 7, "anchoring " << collapsed);
 
     bool found = false;
     if (memStore)
         found = memStore->anchorCollapsed(collapsed, inSync);
     if (!found && Config.cacheSwap.n_configured)
         found = anchorCollapsedOnDisk(collapsed, inSync);
 
     if (found) {
         if (inSync)
             debugs(20, 7, "anchored " << collapsed);
         else
             debugs(20, 5, "failed to anchor " << collapsed);
     } else {
         debugs(20, 7, "skipping not yet cached " << collapsed);
     }
 
     return found;
 }
 
+bool
+StoreController::smpAware() const
+{
+    return memStore || (swapDir.getRaw() && swapDir->smpAware());
+}
+
 StoreHashIndex::StoreHashIndex()
 {
     if (store_table)
         abort();
     assert (store_table == NULL);
 }
 
 StoreHashIndex::~StoreHashIndex()
 {
     if (store_table) {
         hashFreeItems(store_table, destroyStoreEntry);
         hashFreeMemory(store_table);
         store_table = NULL;
     }
 }
 
 int
 StoreHashIndex::callback()
 {
     int result = 0;
     int j;
     static int ndir = 0;
 
     do {
         j = 0;
 
         for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
             if (ndir >= Config.cacheSwap.n_configured)
                 ndir = ndir % Config.cacheSwap.n_configured;
 
@@ -1240,60 +1247,73 @@
 StoreHashIndex::maintain()
 {
     int i;
     /* walk each fs */
 
     for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         /* XXX FixMe: This should be done "in parallell" on the different
          * cache_dirs, not one at a time.
          */
         /* call the maintain function .. */
         store(i)->maintain();
     }
 }
 
 void
 StoreHashIndex::sync()
 {
     for (int i = 0; i < Config.cacheSwap.n_configured; ++i)
         store(i)->sync();
 }
 
 StoreSearch *
 StoreHashIndex::search(String const url, HttpRequest *)
 {
     if (url.size())
         fatal ("Cannot search by url yet\n");
 
     return new StoreSearchHashIndex (this);
 }
 
+bool
+StoreHashIndex::smpAware() const
+{
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
+        // A mix is not supported, but we conservatively check every
+        // dir because features like collapsed revalidation should
+        // currently be disabled if any dir is SMP-aware
+        if (dir(i).smpAware())
+            return true;
+    }
+    return false;
+}
+
 CBDATA_CLASS_INIT(StoreSearchHashIndex);
 
 StoreSearchHashIndex::StoreSearchHashIndex(RefCount<StoreHashIndex> aSwapDir) :
     sd(aSwapDir),
     callback(NULL),
     cbdata(NULL),
     _done(false),
     bucket(0)
 {}
 
 /* do not link
 StoreSearchHashIndex::StoreSearchHashIndex(StoreSearchHashIndex const &);
 */
 
 StoreSearchHashIndex::~StoreSearchHashIndex()
 {}
 
 void
 StoreSearchHashIndex::next(void (aCallback)(void *), void *aCallbackData)
 {
     next();
     aCallback (aCallbackData);
 }
 
 bool
 StoreSearchHashIndex::next()
 {
     if (!entries.empty())
         entries.pop_back();
 
@@ -1318,31 +1338,30 @@
 StoreEntry *
 StoreSearchHashIndex::currentItem()
 {
     if (!entries.size())
         return NULL;
 
     return entries.back();
 }
 
 void
 StoreSearchHashIndex::copyBucket()
 {
     /* probably need to lock the store entries...
      * we copy them all to prevent races on the links. */
     debugs(47, 3, "StoreSearchHashIndex::copyBucket #" << bucket);
     assert (!entries.size());
     hash_link *link_ptr = NULL;
     hash_link *link_next = NULL;
     link_next = hash_get_bucket(store_table, bucket);
 
     while (NULL != (link_ptr = link_next)) {
         link_next = link_ptr->next;
         StoreEntry *e = (StoreEntry *) link_ptr;
 
         entries.push_back(e);
     }
 
     ++bucket;
     debugs(47,3, "got entries: " << entries.size());
 }
-

=== modified file 'src/store_key_md5.cc'
--- src/store_key_md5.cc	2016-04-01 06:15:31 +0000
+++ src/store_key_md5.cc	2016-07-13 21:40:23 +0000
@@ -69,89 +69,94 @@
 }
 
 unsigned int
 storeKeyHashHash(const void *key, unsigned int n)
 {
     /* note, n must be a power of 2! */
     const unsigned char *digest = (const unsigned char *)key;
     unsigned int i = digest[0]
                      | digest[1] << 8
                      | digest[2] << 16
                      | digest[3] << 24;
     return (i & (--n));
 }
 
 const cache_key *
 storeKeyPrivate(const char *url, const HttpRequestMethod& method, int id)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     SquidMD5_CTX M;
     assert(id > 0);
     debugs(20, 3, "storeKeyPrivate: " << method << " " << url);
     SquidMD5Init(&M);
     SquidMD5Update(&M, (unsigned char *) &id, sizeof(id));
     SquidMD5Update(&M, (unsigned char *) &method, sizeof(method));
     SquidMD5Update(&M, (unsigned char *) url, strlen(url));
     SquidMD5Final(digest, &M);
     return digest;
 }
 
 const cache_key *
-storeKeyPublic(const char *url, const HttpRequestMethod& method)
+storeKeyPublic(const char *url, const HttpRequestMethod& method, const KeyScope keyScope)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     unsigned char m = (unsigned char) method.id();
     SquidMD5_CTX M;
     SquidMD5Init(&M);
     SquidMD5Update(&M, &m, sizeof(m));
     SquidMD5Update(&M, (unsigned char *) url, strlen(url));
+    if (keyScope)
+        SquidMD5Update(&M, &keyScope, sizeof(keyScope));
     SquidMD5Final(digest, &M);
     return digest;
 }
 
 const cache_key *
-storeKeyPublicByRequest(HttpRequest * request)
+storeKeyPublicByRequest(HttpRequest * request, const KeyScope keyScope)
 {
-    return storeKeyPublicByRequestMethod(request, request->method);
+    return storeKeyPublicByRequestMethod(request, request->method, keyScope);
 }
 
 const cache_key *
-storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method)
+storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method, const KeyScope keyScope)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     unsigned char m = (unsigned char) method.id();
     const char *url = request->storeId(); /* storeId returns the right storeID\canonical URL for the md5 calc */
     SquidMD5_CTX M;
     SquidMD5Init(&M);
     SquidMD5Update(&M, &m, sizeof(m));
     SquidMD5Update(&M, (unsigned char *) url, strlen(url));
 
+    if (keyScope)
+        SquidMD5Update(&M, &keyScope, sizeof(keyScope));
+
     if (!request->vary_headers.isEmpty()) {
         SquidMD5Update(&M, request->vary_headers.rawContent(), request->vary_headers.length());
         debugs(20, 3, "updating public key by vary headers: " << request->vary_headers << " for: " << url);
     }
 
     SquidMD5Final(digest, &M);
 
     return digest;
 }
 
 cache_key *
 storeKeyDup(const cache_key * key)
 {
     cache_key *dup = (cache_key *)memAllocate(MEM_MD5_DIGEST);
     memcpy(dup, key, SQUID_MD5_DIGEST_LENGTH);
     return dup;
 }
 
 cache_key *
 storeKeyCopy(cache_key * dst, const cache_key * src)
 {
     memcpy(dst, src, SQUID_MD5_DIGEST_LENGTH);
     return dst;
 }
 
 void
 storeKeyFree(const cache_key * key)
 {
     memFree((void *) key, MEM_MD5_DIGEST);
 }

=== modified file 'src/store_key_md5.h'
--- src/store_key_md5.h	2016-01-01 00:14:27 +0000
+++ src/store_key_md5.h	2016-07-21 08:20:33 +0000
@@ -1,37 +1,42 @@
 /*
  * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 20    Storage Manager MD5 Cache Keys */
 
 #ifndef SQUID_STORE_KEY_MD5_H_
 #define SQUID_STORE_KEY_MD5_H_
 
 #include "hash.h"
 #include "typedefs.h"
 
 class HttpRequestMethod;
 class HttpRequest;
 
+typedef enum {
+    ksDefault = 0,
+    ksRevalidation
+} KeyScope;
+
 cache_key *storeKeyDup(const cache_key *);
 cache_key *storeKeyCopy(cache_key *, const cache_key *);
 void storeKeyFree(const cache_key *);
 const cache_key *storeKeyScan(const char *);
 const char *storeKeyText(const cache_key *);
-const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
-const cache_key *storeKeyPublicByRequest(HttpRequest *);
-const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
+const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&, const KeyScope keyScope = ksDefault);
+const cache_key *storeKeyPublicByRequest(HttpRequest *, const KeyScope keyScope = ksDefault);
+const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&, const KeyScope keyScope = ksDefault);
 const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
 int storeKeyHashBuckets(int);
 int storeKeyNull(const cache_key *);
 void storeKeyInit(void);
 
 extern HASHHASH storeKeyHashHash;
 extern HASHCMP storeKeyHashCmp;
 
 #endif /* SQUID_STORE_KEY_MD5_H_ */
 

=== modified file 'src/tests/stub_store.cc'
--- src/tests/stub_store.cc	2016-01-01 00:14:27 +0000
+++ src/tests/stub_store.cc	2016-07-14 10:46:27 +0000
@@ -15,133 +15,133 @@
 const char *storeStatusStr[] = { };
 const char *pingStatusStr[] = { };
 const char *memStatusStr[] = { };
 const char *swapStatusStr[] = { };
 
 /* and code defined in the wrong .cc file */
 #include "SwapDir.h"
 void StoreController::maintain() STUB
 #include "RemovalPolicy.h"
 RemovalPolicy * createRemovalPolicy(RemovalPolicySettings * settings) STUB_RETVAL(NULL)
 
 #include "Store.h"
 StorePointer Store::CurrentRoot = NULL;
 StoreIoStats store_io_stats;
 bool StoreEntry::checkDeferRead(int fd) const STUB_RETVAL(false)
 const char *StoreEntry::getMD5Text() const STUB_RETVAL(NULL)
 StoreEntry::StoreEntry() STUB
 StoreEntry::~StoreEntry() STUB
 HttpReply const *StoreEntry::getReply() const STUB_RETVAL(NULL)
 void StoreEntry::write(StoreIOBuffer) STUB
 bool StoreEntry::isAccepting() const STUB_RETVAL(false)
 size_t StoreEntry::bytesWanted(Range<size_t> const, bool) const STUB_RETVAL(0)
 void StoreEntry::complete() STUB
 store_client_t StoreEntry::storeClientType() const STUB_RETVAL(STORE_NON_CLIENT)
 char const *StoreEntry::getSerialisedMetaData() STUB_RETVAL(NULL)
 void StoreEntry::replaceHttpReply(HttpReply *, bool andStartWriting) STUB
 bool StoreEntry::mayStartSwapOut() STUB_RETVAL(false)
 void StoreEntry::trimMemory(const bool preserveSwappable) STUB
 void StoreEntry::abort() STUB
 void StoreEntry::unlink() STUB
-void StoreEntry::makePublic() STUB
+void StoreEntry::makePublic(const KeyScope keyScope) STUB
 void StoreEntry::makePrivate() STUB
-void StoreEntry::setPublicKey() STUB
+void StoreEntry::setPublicKey(const KeyScope keyScope) STUB
 void StoreEntry::setPrivateKey() STUB
 void StoreEntry::expireNow() STUB
 void StoreEntry::releaseRequest() STUB
 void StoreEntry::negativeCache() STUB
 void StoreEntry::cacheNegatively() STUB
 void StoreEntry::purgeMem() STUB
 void StoreEntry::swapOut() STUB
 void StoreEntry::swapOutFileClose(int how) STUB
 const char *StoreEntry::url() const STUB_RETVAL(NULL)
 bool StoreEntry::checkCachable() STUB_RETVAL(false)
 int StoreEntry::checkNegativeHit() const STUB_RETVAL(0)
 int StoreEntry::locked() const STUB_RETVAL(0)
 int StoreEntry::validToSend() const STUB_RETVAL(0)
 bool StoreEntry::memoryCachable() STUB_RETVAL(false)
 MemObject *StoreEntry::makeMemObject() STUB_RETVAL(NULL)
 void StoreEntry::createMemObject(const char *, const char *, const HttpRequestMethod &aMethod) STUB
 void StoreEntry::dump(int debug_lvl) const STUB
 void StoreEntry::hashDelete() STUB
 void StoreEntry::hashInsert(const cache_key *) STUB
 void StoreEntry::registerAbort(STABH * cb, void *) STUB
 void StoreEntry::reset() STUB
 void StoreEntry::setMemStatus(mem_status_t) STUB
-void StoreEntry::timestampsSet() STUB
+bool StoreEntry::timestampsSet() STUB_RETVAL(false)
 void StoreEntry::unregisterAbort() STUB
 void StoreEntry::destroyMemObject() STUB
 int StoreEntry::checkTooSmall() STUB_RETVAL(0)
 void StoreEntry::delayAwareRead(const Comm::ConnectionPointer&, char *buf, int len, AsyncCall::Pointer callback) STUB
 void StoreEntry::setNoDelay (bool const) STUB
 bool StoreEntry::modifiedSince(HttpRequest * request) const STUB_RETVAL(false)
 bool StoreEntry::hasIfMatchEtag(const HttpRequest &request) const STUB_RETVAL(false)
 bool StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const STUB_RETVAL(false)
 RefCount<SwapDir> StoreEntry::store() const STUB_RETVAL(NULL)
 size_t StoreEntry::inUseCount() STUB_RETVAL(0)
 void StoreEntry::getPublicByRequestMethod(StoreClient * aClient, HttpRequest * request, const HttpRequestMethod& method) STUB
 void StoreEntry::getPublicByRequest(StoreClient * aClient, HttpRequest * request) STUB
 void StoreEntry::getPublic(StoreClient * aClient, const char *uri, const HttpRequestMethod& method) STUB
 void *StoreEntry::operator new(size_t byteCount)
 {
     STUB
     return new StoreEntry();
 }
 void StoreEntry::operator delete(void *address) STUB
 void StoreEntry::setReleaseFlag() STUB
 //#if USE_SQUID_ESI
 //ESIElement::Pointer StoreEntry::cachedESITree STUB_RETVAL(NULL)
 //#endif
 void StoreEntry::append(char const *, int len) STUB
 void StoreEntry::buffer() STUB
 void StoreEntry::flush() STUB
 int StoreEntry::unlock(const char *) STUB_RETVAL(0)
 int64_t StoreEntry::objectLen() const STUB_RETVAL(0)
 int64_t StoreEntry::contentLen() const STUB_RETVAL(0)
 void StoreEntry::lock(const char *) STUB
 void StoreEntry::touch() STUB
 void StoreEntry::release() STUB
 
 NullStoreEntry *NullStoreEntry::getInstance() STUB_RETVAL(NULL)
 const char *NullStoreEntry::getMD5Text() const STUB_RETVAL(NULL)
 void NullStoreEntry::operator delete(void *address) STUB
 // private virtual. Why is this linked from outside?
 const char *NullStoreEntry::getSerialisedMetaData() STUB_RETVAL(NULL)
 
 void Store::Root(Store *) STUB
 void Store::Root(RefCount<Store>) STUB
 void Store::Stats(StoreEntry * output) STUB
 void Store::Maintain(void *unused) STUB
 void Store::create() STUB
 void Store::diskFull() STUB
 void Store::sync() STUB
 void Store::unlink(StoreEntry &) STUB
 
 std::ostream &operator <<(std::ostream &os, const StoreEntry &)
 {
     STUB
     return os;
 }
 
 size_t storeEntryInUse() STUB_RETVAL(0)
 void storeEntryReplaceObject(StoreEntry *, HttpReply *) STUB
 StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method) STUB_RETVAL(NULL)
-StoreEntry *storeGetPublicByRequest(HttpRequest * request) STUB_RETVAL(NULL)
-StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method) STUB_RETVAL(NULL)
+StoreEntry *storeGetPublicByRequest(HttpRequest * request, const KeyScope keyScope) STUB_RETVAL(NULL)
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method, const KeyScope keyScope) STUB_RETVAL(NULL)
 StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&) STUB_RETVAL(NULL)
 StoreEntry *storeCreatePureEntry(const char *storeId, const char *logUrl, const RequestFlags &, const HttpRequestMethod&) STUB_RETVAL(NULL)
 void storeInit(void) STUB
 void storeConfigure(void) STUB
 void storeFreeMemory(void) STUB
 int expiresMoreThan(time_t, time_t) STUB_RETVAL(0)
 void storeAppendPrintf(StoreEntry *, const char *,...) STUB
 void storeAppendVPrintf(StoreEntry *, const char *, va_list ap) STUB
 int storeTooManyDiskFilesOpen(void) STUB_RETVAL(0)
 void storeHeapPositionUpdate(StoreEntry *, SwapDir *) STUB
 void storeSwapFileNumberSet(StoreEntry * e, sfileno filn) STUB
 void storeFsInit(void) STUB
 void storeFsDone(void) STUB
 void storeReplAdd(const char *, REMOVALPOLICYCREATE *) STUB
 void destroyStoreEntry(void *) STUB
 // in Packer.cc !? void packerToStoreInit(Packer * p, StoreEntry * e) STUB
 void storeGetMemSpace(int size) STUB
 

=== modified file 'src/tests/testRock.cc'
--- src/tests/testRock.cc	2016-02-23 15:52:04 +0000
+++ src/tests/testRock.cc	2016-07-13 15:20:59 +0000
@@ -116,62 +116,60 @@
 testRock::commonInit()
 {
     static bool inited = false;
 
     if (inited)
         return;
 
     StoreFileSystem::SetupAllFs();
 
     Config.Store.avgObjectSize = 1024;
     Config.Store.objectsPerBucket = 20;
     Config.Store.maxObjectSize = 2048;
 
     Config.store_dir_select_algorithm = xstrdup("round-robin");
 
     Config.replPolicy = new RemovalPolicySettings;
     Config.replPolicy->type = xstrdup("lru");
     Config.replPolicy->args = NULL;
 
     /* garh garh */
     storeReplAdd("lru", createRemovalPolicy_lru);
 
     visible_appname_string = xstrdup(APP_FULLNAME);
 
     Mem::Init();
 
     comm_init();
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
-    httpReplyInitModule();  /* must go before accepting replies */
-
     mem_policy = createRemovalPolicy(Config.replPolicy);
 
     inited = true;
 }
 
 void
 testRock::storeInit()
 {
     /* ok, ready to use */
     Store::Root().init();
 
     /* rebuild is a scheduled event */
     StockEventLoop loop;
 
     /* our swapdir must be scheduled to rebuild */
     CPPUNIT_ASSERT_EQUAL(2, StoreController::store_dirs_rebuilding);
 
     loop.run();
 
     /* cannot use loop.run(); as the loop will never idle: the store-dir
      * clean() scheduled event prevents it
      */
 
     /* nothing left to rebuild */
     CPPUNIT_ASSERT_EQUAL(0, StoreController::store_dirs_rebuilding);
 }
 
 static const char *
 storeId(const int i)
 {

=== modified file 'src/tests/testStore.h'
--- src/tests/testStore.h	2016-01-01 00:14:27 +0000
+++ src/tests/testStore.h	2016-07-14 10:13:28 +0000
@@ -49,36 +49,38 @@
 
     virtual int callback();
 
     virtual StoreEntry* get(const cache_key*);
 
     virtual void get(String, void (*)(StoreEntry*, void*), void*);
 
     virtual void init();
 
     virtual void maintain() {};
 
     virtual uint64_t maxSize() const;
 
     virtual uint64_t minSize() const;
 
     virtual uint64_t currentSize() const;
 
     virtual uint64_t currentCount() const;
 
     virtual int64_t maxObjectSize() const;
 
     virtual void getStats(StoreInfoStats &) const;
 
     virtual void stat(StoreEntry &) const; /* output stats to the provided store entry */
 
     virtual void reference(StoreEntry &) {} /* Reference this object */
 
     virtual bool dereference(StoreEntry &, bool) { return true; }
 
     virtual StoreSearch *search(String const url, HttpRequest *);
+
+    virtual bool smpAware() const { return false; }
 };
 
 typedef RefCount<TestStore> TestStorePointer;
 
 #endif
 

=== modified file 'src/tests/testUfs.cc'
--- src/tests/testUfs.cc	2016-01-01 00:14:27 +0000
+++ src/tests/testUfs.cc	2016-07-13 15:21:44 +0000
@@ -48,62 +48,60 @@
 {
     cbcalled = true;
 }
 
 void
 testUfs::commonInit()
 {
     static bool inited = false;
 
     if (inited)
         return;
 
     Config.Store.avgObjectSize = 1024;
     Config.Store.objectsPerBucket = 20;
     Config.Store.maxObjectSize = 2048;
 
     Config.store_dir_select_algorithm = xstrdup("round-robin");
 
     Config.replPolicy = new RemovalPolicySettings;
     Config.replPolicy->type = xstrdup("lru");
 
     /* garh garh */
     storeReplAdd("lru", createRemovalPolicy_lru);
 
     Mem::Init();
 
     comm_init();
 
     httpHeaderInitModule(); /* must go before any header processing (e.g. the one in errorInitialize) */
 
-    httpReplyInitModule();  /* must go before accepting replies */
-
     inited = true;
 }
 
 void
 testUfs::testUfsSearch()
 {
     /* test sequence
      * make a valid working ufs swapdir
      * put two entries in it and sync logs
      * search the ufs dir
      * check the entries we find are what we want
      */
 
     if (0 > system ("rm -rf " TESTDIR))
         throw std::runtime_error("Failed to clean test work directory");
 
     Store::Root(new StoreController);
 
     SwapDirPointer aStore (new Fs::Ufs::UFSSwapDir("ufs", "Blocking"));
 
     aStore->IO = new Fs::Ufs::UFSStrategy(DiskIOModule::Find("Blocking")->createStrategy());
 
     addSwapDir(aStore);
 
     commonInit();
     mem_policy = createRemovalPolicy(Config.replPolicy);
 
     char *path=xstrdup(TESTDIR);
 
     char *config_line=xstrdup("100 1 1");

