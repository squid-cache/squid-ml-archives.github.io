Fix logged request size (%http::>st), other size-related %codes.

The %[http::]>st logformat code should log the actual number of
[dechunked] bytes received from the client. However, for requests with
Content-Length, Squid was logging the sum of the request header size and
the Content-Length header field value instead. The logged value was
wrong when the client sent fewer than Content-Length body bytes.

Also:

* Fixed %http::>h and %http::<h format codes for icap_log. The old code
  was focusing on preserving the "request header" (i.e. not "response
  header") meaning of the %http::>h logformat code, but since ICAP
  services deal with (and log) both HTTP requests and responses, that
  focus on the HTTP message kind actually complicates ICAP logging
  configuration and will eventually require introduction of new %http
  logformat codes that would be meaningless in access.log context.

  - In ICAP context, %http::>h should log to-be-adapted HTTP message
    headers embedded in an ICAP request (HTTP request headers in REQMOD;
    HTTP response headers in RESPMOD). Before this change, %http::>h
    logged constant/"FYI" HTTP request headers in RESPMOD.

  - Similarly, %http::<h should log adapted HTTP message headers
    embedded in an ICAP response (HTTP request headers in regular
    REQMOD; HTTP response headers in RESPMOD and during request
    satisfaction in REQMOD). Before this change, %http::<h logged "-" in
    REQMOD.

  In other words, in ICAP logging context, the ">" and "<" characters
  should indicate ICAP message kind (where the being-logged HTTP message
  is embedded), not HTTP message kind, even for %http codes.

  TODO: %http::>h code logs "-" in RESPMOD because AccessLogEntry does
  not store virgin HTTP response headers.

* Correctly initialize ICAP ALE HTTP fields related to HTTP message
  sizes for icap_log, including %http::>st, %http::<st, %http::>sh, and
  %http::>sh format codes.

* Initialize HttpMsg::hdr_sz in HTTP header parsing code. Among other
  uses, this field is needed to initialize HTTP fields inside ICAP ALE.

* Synced default icap_log format documentation with the current code.

=== modified file 'src/HttpMsg.cc'
--- src/HttpMsg.cc	2016-03-21 04:48:44 +0000
+++ src/HttpMsg.cc	2016-07-30 14:48:54 +0000
@@ -287,60 +287,62 @@
 
         if (!header.parse(blk_start, blk_end-blk_start)) {
             PROF_stop(HttpMsg_httpMsgParseStep);
             return httpMsgParseError();
         }
 
         hdrCacheInit();
 
         *parse_end_ptr = parse_start;
 
         hdr_sz = *parse_end_ptr - buf;
 
         ++pstate;
     }
 
     PROF_stop(HttpMsg_httpMsgParseStep);
     return 1;
 }
 
 bool
 HttpMsg::parseHeader(Http1::Parser &hp)
 {
     // HTTP/1 message contains "zero or more header fields"
     // zero does not need parsing
     // XXX: c_str() reallocates. performance regression.
     if (hp.headerBlockSize() && !header.parse(hp.mimeHeader().c_str(), hp.headerBlockSize())) {
         pstate = psError;
         return false;
     }
 
+    // XXX: we are just parsing HTTP headers, not the whole message prefix here
+    hdr_sz = hp.messageHeaderSize();
     pstate = psParsed;
     hdrCacheInit();
     return true;
 }
 
 /* handy: resets and returns -1 */
 int
 HttpMsg::httpMsgParseError()
 {
     reset();
     return -1;
 }
 
 void
 HttpMsg::setContentLength(int64_t clen)
 {
     header.delById(Http::HdrType::CONTENT_LENGTH); // if any
     header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     content_length = clen;
 }
 
 bool
 HttpMsg::persistent() const
 {
     if (http_ver > Http::ProtocolVersion(1,0)) {
         /*
          * for modern versions of HTTP: persistent unless there is
          * a "Connection: close" header.
          */
         return !httpHeaderHasConnDir(&header, "close");

=== modified file 'src/adaptation/icap/ModXact.cc'
--- src/adaptation/icap/ModXact.cc	2016-01-13 12:12:11 +0000
+++ src/adaptation/icap/ModXact.cc	2016-07-30 14:48:54 +0000
@@ -1238,121 +1238,126 @@
 }
 
 Adaptation::Icap::ModXact::~ModXact()
 {
     delete bodyParser;
 }
 
 // internal cleanup
 void Adaptation::Icap::ModXact::swanSong()
 {
     debugs(93, 5, HERE << "swan sings" << status());
 
     stopWriting(false);
     stopSending(false);
 
     if (theInitiator.set()) // we have not sent the answer to the initiator
         detailError(ERR_DETAIL_ICAP_XACT_OTHER);
 
     // update adaptation history if start was called and we reserved a slot
     Adaptation::History::Pointer ah = virginRequest().adaptLogHistory();
     if (ah != NULL && adaptHistoryId >= 0)
         ah->recordXactFinish(adaptHistoryId);
 
     Adaptation::Icap::Xaction::swanSong();
 }
 
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 
 void Adaptation::Icap::ModXact::finalizeLogInfo()
 {
-    HttpRequest * request_ = NULL;
-    HttpRequest * adapted_request_ = NULL;
-    HttpReply * reply_ = NULL;
-    request_ = (virgin.cause? virgin.cause: dynamic_cast<HttpRequest*>(virgin.header));
+    HttpRequest *adapted_request_ = nullptr;
+    HttpReply *adapted_reply_ = nullptr;
+    HttpRequest *virgin_request_ = (virgin.cause ? virgin.cause : dynamic_cast<HttpRequest*>(virgin.header));
     if (!(adapted_request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
-        adapted_request_ = request_;
-        reply_ = dynamic_cast<HttpReply*>(adapted.header);
+        // if the request was not adapted, use virgin request to simplify
+        // the code further below
+        adapted_request_ = virgin_request_;
+        adapted_reply_ = dynamic_cast<HttpReply*>(adapted.header);
     }
 
-    Adaptation::Icap::History::Pointer h = (request_ ? request_->icapHistory() : NULL);
+    Adaptation::Icap::History::Pointer h = (virgin_request_ ? virgin_request_->icapHistory() : NULL);
     Must(h != NULL); // ICAPXaction::maybeLog calls only if there is a log
     al.icp.opcode = ICP_INVALID;
     al.url = h->log_uri.termedBuf();
     const Adaptation::Icap::ServiceRep  &s = service();
     al.icap.reqMethod = s.cfg().method;
 
-    al.cache.caddr = request_->client_addr;
+    al.cache.caddr = virgin_request_->client_addr;
 
-    al.request = request_;
+    al.request = virgin_request_;
     HTTPMSGLOCK(al.request);
     al.adapted_request = adapted_request_;
     HTTPMSGLOCK(al.adapted_request);
 
-    if (reply_) {
-        al.reply = reply_;
+    if (adapted_reply_) {
+        al.reply = adapted_reply_;
         HTTPMSGLOCK(al.reply);
     } else
         al.reply = NULL;
 
     if (h->rfc931.size())
         al.cache.rfc931 = h->rfc931.termedBuf();
 
 #if USE_OPENSSL
     if (h->ssluser.size())
         al.cache.ssluser = h->ssluser.termedBuf();
 #endif
     al.cache.code = h->logType;
-    // XXX: should use icap-specific counters instead ?
-    al.http.clientRequestSz.payloadData = h->req_sz;
+
+    const HttpMsg *virgin_msg = dynamic_cast<HttpReply*>(virgin.header);
+    if (!virgin_msg)
+        virgin_msg = virgin_request_;
+    assert(virgin_msg != virgin.cause);
+    al.http.clientRequestSz.header = virgin_msg->hdr_sz;
+    al.http.clientRequestSz.payloadData = virgin_msg->body_pipe->producedSize();
 
     // leave al.icap.bodyBytesRead negative if no body
     if (replyHttpHeaderSize >= 0 || replyHttpBodySize >= 0) {
         const int64_t zero = 0; // to make max() argument types the same
-        al.icap.bodyBytesRead =
-            max(zero, replyHttpHeaderSize) + max(zero, replyHttpBodySize);
+        const uint64_t headerSize = max(zero, replyHttpHeaderSize);
+        const uint64_t bodySize =  max(zero, replyHttpBodySize);
+        al.icap.bodyBytesRead = headerSize + bodySize;
+        al.http.clientReplySz.header = headerSize;
+        al.http.clientReplySz.payloadData = bodySize;
     }
 
-    if (reply_) {
-        al.http.code = reply_->sline.status();
-        al.http.content_type = reply_->content_type.termedBuf();
-        if (replyHttpBodySize >= 0) {
-            // XXX: should use icap-specific counters instead ?
-            al.http.clientReplySz.payloadData = replyHttpBodySize;
-            al.http.clientReplySz.header =  reply_->hdr_sz;
+    if (adapted_reply_) {
+        al.http.code = adapted_reply_->sline.status();
+        al.http.content_type = adapted_reply_->content_type.termedBuf();
+        if (replyHttpBodySize >= 0)
             al.cache.highOffset = replyHttpBodySize;
-        }
         //don't set al.cache.objectSize because it hasn't exist yet
 
         MemBuf mb;
         mb.init();
-        reply_->header.packInto(&mb);
+        adapted_reply_->header.packInto(&mb);
         al.headers.reply = xstrdup(mb.buf);
         mb.clean();
     }
     prepareLogWithRequestDetails(adapted_request_, alep);
     Xaction::finalizeLogInfo();
 }
 
 void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 {
     char ntoabuf[MAX_IPSTRLEN];
     /*
      * XXX These should use HttpHdr interfaces instead of Printfs
      */
     const Adaptation::ServiceConfig &s = service().cfg();
     buf.appendf("%s " SQUIDSTRINGPH " ICAP/1.0\r\n", s.methodStr(), SQUIDSTRINGPRINT(s.uri));
     buf.appendf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
     buf.appendf("Date: %s\r\n", mkrfc1123(squid_curtime));
 
     if (!TheConfig.reuse_connections)
         buf.appendf("Connection: close\r\n");
 
     const HttpRequest *request = &virginRequest();
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHENTICATE);
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 

=== modified file 'src/cf.data.pre'
--- src/cf.data.pre	2016-07-02 06:47:55 +0000
+++ src/cf.data.pre	2016-07-31 09:35:38 +0000
@@ -4474,125 +4474,144 @@
 		Lines may be accumulated before sending (see buffered_logs).
 		Place: The destination host name or IP and port.
 		Place Format:   //host:port
 
 	Default:
 		access_log daemon:@DEFAULT_ACCESS_LOG@ squid
 DOC_END
 
 NAME: icap_log
 TYPE: access_log
 IFDEF: ICAP_CLIENT
 LOC: Config.Log.icaplogs
 DEFAULT: none
 DOC_START
 	ICAP log files record ICAP transaction summaries, one line per
 	transaction.
 
 	The icap_log option format is:
 	icap_log <filepath> [<logformat name> [acl acl ...]]
 	icap_log none [acl acl ...]]
 	
 	Please see access_log option documentation for details. The two
 	kinds of logs share the overall configuration approach and many
 	features.
 
 	ICAP processing of a single HTTP message or transaction may
 	require multiple ICAP transactions.  In such cases, multiple
 	ICAP transaction log lines will correspond to a single access
 	log line.
 
-	ICAP log uses logformat codes that make sense for an ICAP
-	transaction. Header-related codes are applied to the HTTP header
-	embedded in an ICAP server response, with the following caveats:
-	For REQMOD, there is no HTTP response header unless the ICAP
-	server performed request satisfaction. For RESPMOD, the HTTP
-	request header is the header sent to the ICAP server. For
-	OPTIONS, there are no HTTP headers.
+	ICAP log supports many access.log logformat %codes. In ICAP context,
+	HTTP message-related %codes are applied to the HTTP message embedded
+	in an ICAP message. Logformat "%http::>..." codes are used for HTTP
+	messages embedded in ICAP requests while "%http::<..." codes are used
+	for HTTP messages embedded in ICAP responses. For example:
+
+		http::>h	To-be-adapted HTTP message headers sent by Squid to
+				the ICAP service (HTTP request headers in REQMOD; HTTP
+				response headers in RESPMOD). Please note that Squid
+				currently does not support logging of HTTP response
+				headers in RESPMOD for this format code.
+
+		http::<h	Adapted HTTP message headers sent by the ICAP service
+				to Squid (HTTP request headers in regular REQMOD; HTTP
+				response headers in RESPMOD and during request
+				satisfaction in REQMOD).
+
+		ICAP OPTIONS transactions do not embed HTTP messages.
+
+	Several logformat codes below deal with ICAP message bodies. An ICAP
+	message body, if any, typically includes a complete HTTP message
+	(required HTTP headers plus optional HTTP message body). When
+	computing HTTP message body size for these logformat codes, Squid
+	either includes or excludes chunked encoding overheads; see
+	code-specific documentation for details.
+
+	For Secure ICAP services, all size-related information is currently
+	computed before/after TLS encryption/decryption, as if TLS was not
+	in use at all.
 
 	The following format codes are also available for ICAP logs:
 
 		icap::<A	ICAP server IP address. Similar to <A.
 
 		icap::<service_name	ICAP service name from the icap_service
 				option in Squid configuration file.
 
 		icap::ru	ICAP Request-URI. Similar to ru.
 
 		icap::rm	ICAP request method (REQMOD, RESPMOD, or 
 				OPTIONS). Similar to existing rm.
 
-		icap::>st	Bytes sent to the ICAP server (TCP payload
-				only; i.e., what Squid writes to the socket).
-
-		icap::<st	Bytes received from the ICAP server (TCP
-				payload only; i.e., what Squid reads from
-				the socket).
-
-		icap::<bs	Number of message body bytes received from the
-				ICAP server. ICAP message body, if any, usually
-				includes encapsulated HTTP message headers and
-				possibly encapsulated HTTP message body. The
-				HTTP body part is dechunked before its size is
-				computed.
+		icap::>st	The total size of the ICAP request sent to the ICAP
+				server (ICAP headers + ICAP body), including chunking
+				metadata (if any).
+
+		icap::<st	The total size of the ICAP response received from the
+				ICAP server (ICAP headers + ICAP body), including
+				chunking metadata (if any).
+
+		icap::<bs	The size of the ICAP response body received from the
+				ICAP server, excluding chunking metadata (if any).
 
 		icap::tr 	Transaction response time (in
 				milliseconds).  The timer starts when
 				the ICAP transaction is created and
 				stops when the transaction is completed.
 				Similar to tr.
 
 		icap::tio	Transaction I/O time (in milliseconds). The
 				timer starts when the first ICAP request
 				byte is scheduled for sending. The timers
 				stops when the last byte of the ICAP response
 				is received.
 
 		icap::to 	Transaction outcome: ICAP_ERR* for all
 				transaction errors, ICAP_OPT for OPTION
 				transactions, ICAP_ECHO for 204
 				responses, ICAP_MOD for message
 				modification, and ICAP_SAT for request
 				satisfaction. Similar to Ss.
 
 		icap::Hs	ICAP response status code. Similar to Hs.
 
 		icap::>h	ICAP request header(s). Similar to >h.
 
 		icap::<h	ICAP response header(s). Similar to <h.
 
 	The default ICAP log format, which can be used without an explicit
 	definition, is called icap_squid:
 
-logformat icap_squid %ts.%03tu %6icap::tr %>a %icap::to/%03icap::Hs %icap::<size %icap::rm %icap::ru% %un -/%icap::<A -
+logformat icap_squid %ts.%03tu %6icap::tr %>A %icap::to/%03icap::Hs %icap::<st %icap::rm %icap::ru %un -/%icap::<A -
 
-	See also: logformat, log_icap, and %adapt::<last_h 
+	See also: logformat and %adapt::<last_h
 DOC_END
 
 NAME: logfile_daemon
 TYPE: string
 DEFAULT: @DEFAULT_LOGFILED@
 LOC: Log::TheConfig.logfile_daemon
 DOC_START
 	Specify the path to the logfile-writing daemon. This daemon is
 	used to write the access and store logs, if configured.
 
 	Squid sends a number of commands to the log daemon:
 	  L<data>\n - logfile data
 	  R\n - rotate file
 	  T\n - truncate file
 	  O\n - reopen file
 	  F\n - flush file
 	  r<n>\n - set rotate count to <n>
 	  b<n>\n - 1 = buffer output, 0 = don't buffer output
 
 	No responses is expected.
 DOC_END
 
 NAME: stats_collection
 TYPE: acl_access
 LOC: Config.accessList.stats_collection
 DEFAULT: none
 DEFAULT_DOC: Allow logging for all transactions.
 COMMENT: allow|deny acl acl...
 DOC_START
 	This options allows you to control which requests gets accounted

=== modified file 'src/client_side.cc'
--- src/client_side.cc	2016-07-18 12:36:38 +0000
+++ src/client_side.cc	2016-07-30 14:48:54 +0000
@@ -335,98 +335,99 @@
         aLogEntry->headers.adapted_request = xstrdup(mb.buf);
 
         // the virgin request is saved to aLogEntry->request
         if (aLogEntry->request) {
             mb.reset();
             aLogEntry->request->header.packInto(&mb);
             aLogEntry->headers.request = xstrdup(mb.buf);
         }
 
 #if USE_ADAPTATION
         const Adaptation::History::Pointer ah = request->adaptLogHistory();
         if (ah != NULL) {
             mb.reset();
             ah->lastMeta.packInto(&mb);
             aLogEntry->adapt.last_meta = xstrdup(mb.buf);
         }
 #endif
 
         mb.clean();
     }
 
 #if ICAP_CLIENT
     const Adaptation::Icap::History::Pointer ih = request->icapHistory();
     if (ih != NULL)
         ih->processingTime(aLogEntry->icap.processingTime);
 #endif
 
     aLogEntry->http.method = request->method;
     aLogEntry->http.version = request->http_ver;
     aLogEntry->hier = request->hier;
-    if (request->content_length > 0) // negative when no body or unknown length
-        aLogEntry->http.clientRequestSz.payloadData += request->content_length; // XXX: actually adaptedRequest payload size ??
     aLogEntry->cache.extuser = request->extacl_user.termedBuf();
 
     // Adapted request, if any, inherits and then collects all the stats, but
     // the virgin request gets logged instead; copy the stats to log them.
     // TODO: avoid losses by keeping these stats in a shared history object?
     if (aLogEntry->request) {
         aLogEntry->request->dnsWait = request->dnsWait;
         aLogEntry->request->errType = request->errType;
         aLogEntry->request->errDetail = request->errDetail;
     }
 }
 
 void
 ClientHttpRequest::logRequest()
 {
     if (!out.size && logType.oldType == LOG_TAG_NONE)
         debugs(33, 5, "logging half-baked transaction: " << log_uri);
 
     al->icp.opcode = ICP_INVALID;
     al->url = log_uri;
     debugs(33, 9, "clientLogRequest: al.url='" << al->url << "'");
 
     if (al->reply) {
         al->http.code = al->reply->sline.status();
         al->http.content_type = al->reply->content_type.termedBuf();
     } else if (loggingEntry() && loggingEntry()->mem_obj) {
         al->http.code = loggingEntry()->mem_obj->getReply()->sline.status();
         al->http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
     }
 
     debugs(33, 9, "clientLogRequest: http.code='" << al->http.code << "'");
 
     if (loggingEntry() && loggingEntry()->mem_obj && loggingEntry()->objectLen() >= 0)
         al->cache.objectSize = loggingEntry()->contentLen(); // payload duplicate ?? with or without TE ?
 
     al->http.clientRequestSz.header = req_sz;
+    // the virgin request is saved to al->request
+    if (al->request && al->request->body_pipe)
+        al->http.clientRequestSz.payloadData = al->request->body_pipe->producedSize();
     al->http.clientReplySz.header = out.headers_sz;
     // XXX: calculate without payload encoding or headers !!
     al->http.clientReplySz.payloadData = out.size - out.headers_sz; // pretend its all un-encoded data for now.
 
     al->cache.highOffset = out.offset;
 
     al->cache.code = logType;
 
     tvSub(al->cache.trTime, al->cache.start_time, current_time);
 
     if (request)
         prepareLogWithRequestDetails(request, al);
 
     if (getConn() != NULL && getConn()->clientConnection != NULL && getConn()->clientConnection->rfc931[0])
         al->cache.rfc931 = getConn()->clientConnection->rfc931;
 
 #if USE_OPENSSL && 0
 
     /* This is broken. Fails if the connection has been closed. Needs
      * to snarf the ssl details some place earlier..
      */
     if (getConn() != NULL)
         al->cache.ssluser = sslGetUserEmail(fd_table[getConn()->fd].ssl);
 
 #endif
 
     /* Add notes (if we have a request to annotate) */
     if (request) {
         // The al->notes and request->notes must point to the same object.
         (void)SyncNotes(*al, *request);

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2016-03-25 13:03:30 +0000
+++ src/format/Format.cc	2016-07-31 09:21:02 +0000
@@ -302,60 +302,79 @@
         case '\t':
             *p = '\\';
             ++p;
             *p = 't';
             ++p;
             ++str;
             break;
 
         default:
             *p = '\\';
             ++p;
             *p = *str;
             ++p;
             ++str;
             break;
         }
     }
 
     *p = '\0';
 }
 
 #if USE_OPENSSL
 static char *
 sslErrorName(Ssl::ssl_error_t err, char *buf, size_t size)
 {
     snprintf(buf, size, "SSL_ERR=%d", err);
     return buf;
 }
 #endif
 
+static const HttpMsg *
+actualReplyHeader(const AccessLogEntry::Pointer &al)
+{
+    const HttpMsg *msg = al->reply;
+    if (!msg && al->icap.reqMethod == Adaptation::methodReqmod)
+        msg = al->adapted_request;
+    return msg;
+}
+
+static const HttpMsg *
+actualRequestHeader(const AccessLogEntry::Pointer &al)
+{
+    if (al->icap.reqMethod == Adaptation::methodRespmod) {
+        // XXX: for now AccessLogEntry lacks virgin response headers
+        return nullptr;
+    }
+    return al->request;
+}
+
 void
 Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logSequenceNumber) const
 {
     char tmp[1024];
     String sb;
 
     for (Token *fmt = format; fmt != NULL; fmt = fmt->next) {   /* for each token */
         const char *out = NULL;
         int quote = 0;
         long int outint = 0;
         int doint = 0;
         int dofree = 0;
         int64_t outoff = 0;
         int dooff = 0;
         struct timeval outtv = {0, 0};
         int doMsec = 0;
         int doSec = 0;
 
         switch (fmt->type) {
 
         case LFT_NONE:
             out = "";
             break;
 
         case LFT_STRING:
             out = fmt->data.string;
             break;
 
         case LFT_CLIENT_IP_ADDRESS:
             al->getLogClientIp(tmp, sizeof(tmp));
@@ -565,90 +584,89 @@
                 out = "-";
             } else {
                 outtv = al->hier.peer_response_time;
                 doMsec = 1;
             }
             break;
 
         case LFT_TOTAL_SERVER_SIDE_RESPONSE_TIME: {
             timeval total_response_time;
             al->hier.totalResponseTime(total_response_time);
             if (total_response_time.tv_sec == -1) {
                 out = "-";
             } else {
                 outtv = total_response_time;
                 doMsec = 1;
             }
         }
         break;
 
         case LFT_DNS_WAIT_TIME:
             if (al->request && al->request->dnsWait >= 0) {
                 // TODO: microsecond precision for dns wait time.
                 // Convert miliseconds to timeval struct:
                 outtv.tv_sec = al->request->dnsWait / 1000;
                 outtv.tv_usec = (al->request->dnsWait % 1000) * 1000;
                 doMsec = 1;
             }
             break;
 
         case LFT_REQUEST_HEADER:
-
-            if (al->request)
-                sb = al->request->header.getByName(fmt->data.header.header);
+            if (const HttpMsg *msg = actualRequestHeader(al))
+                sb = msg->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_ADAPTED_REQUEST_HEADER:
 
             if (al->adapted_request)
                 sb = al->adapted_request->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
-        case LFT_REPLY_HEADER:
-            if (al->reply)
-                sb = al->reply->header.getByName(fmt->data.header.header);
+        case LFT_REPLY_HEADER: {
+            if (const HttpMsg *msg = actualReplyHeader(al))
+                sb = msg->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
 
             quote = 1;
-
-            break;
+        }
+        break;
 
 #if USE_ADAPTATION
         case LFT_ADAPTATION_SUM_XACT_TIMES:
             if (al->request) {
                 Adaptation::History::Pointer ah = al->request->adaptHistory();
                 if (ah != NULL)
                     ah->sumLogString(fmt->data.string, sb);
                 out = sb.termedBuf();
             }
             break;
 
         case LFT_ADAPTATION_ALL_XACT_TIMES:
             if (al->request) {
                 Adaptation::History::Pointer ah = al->request->adaptHistory();
                 if (ah != NULL)
                     ah->allLogString(fmt->data.string, sb);
                 out = sb.termedBuf();
             }
             break;
 
         case LFT_ADAPTATION_LAST_HEADER:
             if (al->request) {
                 const Adaptation::History::Pointer ah = al->request->adaptHistory();
                 if (ah != NULL) // XXX: add adapt::<all_h but use lastMeta here
                     sb = ah->allMeta.getByName(fmt->data.header.header);
             }
 
             // XXX: here and elsewhere: move such code inside the if guard
             out = sb.termedBuf();
 
@@ -776,105 +794,113 @@
                 out = sb.termedBuf();
                 quote = 1;
             }
             break;
 
         case LFT_ICAP_TR_RESPONSE_TIME:
             outtv = al->icap.trTime;
             doMsec = 1;
             break;
 
         case LFT_ICAP_IO_TIME:
             outtv = al->icap.ioTime;
             doMsec = 1;
             break;
 
         case LFT_ICAP_STATUS_CODE:
             outint = al->icap.resStatus;
             doint  = 1;
             break;
 
         case LFT_ICAP_OUTCOME:
             out = al->icap.outcome;
             break;
 
         case LFT_ICAP_TOTAL_TIME:
             outtv = al->icap.processingTime;
             doMsec = 1;
             break;
 #endif
         case LFT_REQUEST_HEADER_ELEM:
-            if (al->request)
-                sb = al->request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
+            if (const HttpMsg *msg = actualRequestHeader(al))
+                sb = msg->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_ADAPTED_REQUEST_HEADER_ELEM:
             if (al->adapted_request)
                 sb = al->adapted_request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
-        case LFT_REPLY_HEADER_ELEM:
-            if (al->reply)
-                sb = al->reply->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
+        case LFT_REPLY_HEADER_ELEM: {
+            if (const HttpMsg *msg = actualReplyHeader(al))
+                sb = msg->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
-
-            break;
+        }
+        break;
 
         case LFT_REQUEST_ALL_HEADERS:
-            out = al->headers.request;
+            if (al->icap.reqMethod == Adaptation::methodRespmod) {
+                // XXX: since AccessLogEntry::Headers lacks virgin response
+                // headers, do nothing for now
+                out = nullptr;
+            } else {
+                out = al->headers.request;
+            }
 
             quote = 1;
 
             break;
 
         case LFT_ADAPTED_REQUEST_ALL_HEADERS:
             out = al->headers.adapted_request;
 
             quote = 1;
 
             break;
 
         case LFT_REPLY_ALL_HEADERS:
             out = al->headers.reply;
+            if (!out && al->icap.reqMethod == Adaptation::methodReqmod)
+                out = al->headers.adapted_request;
 
             quote = 1;
 
             break;
 
         case LFT_USER_NAME:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->username());
 #endif
             if (!out && al->request && al->request->extacl_user.size()) {
                 if (const char *t = al->request->extacl_user.termedBuf())
                     out = t;
             }
 
             if (!out)
                 out = strOrNull(al->cache.extuser);
 
 #if USE_OPENSSL
             if (!out)
                 out = strOrNull(al->cache.ssluser);
 #endif
             if (!out)
                 out = strOrNull(al->cache.rfc931);
             break;
 
         case LFT_USER_LOGIN:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->username());

