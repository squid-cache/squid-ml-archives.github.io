=== modified file 'src/ip/Intercept.cc'
--- src/ip/Intercept.cc	2016-04-07 12:03:53 +0000
+++ src/ip/Intercept.cc	2016-09-29 21:44:35 +0000
@@ -16,6 +16,7 @@
 #include "fde.h"
 #include "ip/Intercept.h"
 #include "src/tools.h"
+#include "parser/Tokenizer.h"
 
 #include <cerrno>
 
@@ -300,6 +301,97 @@
 #if PF_TRANSPARENT  /* --enable-pf-transparent */
 
 #if !USE_NAT_DEVPF
+
+#if _SQUID_APPLE_ /* _SQUID_APPLE_ */
+
+    static bool perfWarning = false;
+    if (!perfWarning) {
+        debugs(89, DBG_CRITICAL, 
+            HERE << "WARNING: Transparent Proxy on Apple OSX will impact performance. "
+                 << "Use only for development.");
+        perfWarning = true;
+    }
+
+    char saddr[MAX_IPSTRLEN + 9];
+    char daddr[MAX_IPSTRLEN + 9];
+
+    newConn->remote.toUrl(saddr, sizeof(saddr));
+    newConn->local.toUrl(daddr, sizeof(daddr));
+
+    SBuf cmd("/sbin/pfctl -s state | /usr/bin/awk '$3 == \"");
+    cmd.append(daddr);
+    cmd.append("\" && $7 == \"");
+    cmd.append(saddr);
+    cmd.append("\" && $8 == \"");
+    cmd.append("ESTABLISHED:ESTABLISHED\" {print $5}'");
+
+    int pipefd[2];
+    if (pipe(pipefd) == -1) {
+        int xerrno = errno;
+        debugs(89, DBG_IMPORTANT, HERE << "PFCTL pipe creation failed: " << xstrerr(xerrno));
+        return false;
+    }
+    pid_t pid = fork();
+    if (pid == 0) {
+        close(pipefd[0]);
+        close(STDIN_FILENO);
+        close(STDERR_FILENO);
+        dup2(pipefd[1], STDOUT_FILENO);
+        enter_suid();
+        execl("/bin/sh", "/bin/sh", "-c", cmd.rawContent(), NULL);
+        leave_suid();
+        exit(EXIT_FAILURE);
+    }
+    else if (pid == -1) {
+        int xerrno = errno;
+        debugs(89, DBG_IMPORTANT, HERE << "PFCTL fork failed: " << xstrerr(xerrno));
+        return false;
+    }
+    close(pipefd[1]);
+
+    SBuf state;
+    char buf[4096];
+    int n;
+    while ((n = read(pipefd[0], buf, sizeof(buf))) > 0) {
+        state.append(buf, n);
+    }
+
+    if (n == -1) {
+        int xerrno = errno;
+        debugs(89, DBG_IMPORTANT, HERE << "Reading from PFCTL failed: " << xstrerr(xerrno));
+        return false;
+    }
+
+    close(pipefd[0]);
+    Parser::Tokenizer tk(state);
+
+    while (!tk.atEnd()) {
+
+        static const CharacterSet bracket("bracket", "[]");
+        static const CharacterSet colon("colon", ":");
+        static const CharacterSet lf("lf", "\n");
+        static const CharacterSet ws("ws", " \t\r\n");
+
+        SBuf host;
+        int64_t port;
+
+        if (tk.token(host, bracket) || tk.token(host, colon)) {
+            if (tk.int64(port)) {
+                newConn->local = host.c_str();
+                newConn->local.port(port);
+                debugs(89, 5, HERE << "address NAT: " << newConn);
+                return true;
+            }
+        }
+
+        tk.skip('\n');
+
+    }
+
+    return false;
+
+#else /* _SQUID_APPLE_ */
+
     /* On recent PF versions the getsockname() call performed already provided
      * the required TCP packet details.
      * There is no way to identify whether they came from NAT or not.
@@ -309,6 +401,7 @@
     debugs(89, 5, HERE << "address NAT divert-to: " << newConn);
     return true;
 
+#endif /* _SQUID_APPLE_ */
 #else /* USE_NAT_DEVPF / --with-nat-devpf */
 
     struct pfioc_natlook nl;

