=== modified file 'src/ip/Intercept.cc'
--- src/ip/Intercept.cc	2016-04-07 12:03:53 +0000
+++ src/ip/Intercept.cc	2016-10-03 14:47:33 +0000
@@ -16,6 +16,7 @@
 #include "fde.h"
 #include "ip/Intercept.h"
 #include "src/tools.h"
+#include "parser/Tokenizer.h"
 
 #include <cerrno>
 
@@ -300,6 +301,94 @@
 #if PF_TRANSPARENT  /* --enable-pf-transparent */
 
 #if !USE_NAT_DEVPF
+
+#if _SQUID_APPLE_ /* _SQUID_APPLE_ */
+
+    static bool perfWarning = false;
+    if (!perfWarning) {
+        debugs(89, DBG_CRITICAL, 
+            "WARNING: Transparent Proxy on Apple OSX will impact performance. "
+            << "Use only for development.");
+        perfWarning = true;
+    }
+
+    char saddr[MAX_IPSTRLEN + 9];
+    char daddr[MAX_IPSTRLEN + 9];
+
+    newConn->remote.toUrl(saddr, sizeof(saddr));
+    newConn->local.toUrl(daddr, sizeof(daddr));
+
+    SBuf cmd("/sbin/pfctl -s state | /usr/bin/awk '$3 == \"");
+    cmd.append(daddr);
+    cmd.append("\" && $7 == \"");
+    cmd.append(saddr);
+    cmd.append("\" && $8 == \"ESTABLISHED:ESTABLISHED\" {print $5}'");
+
+    int pipefd[2];
+    if (pipe(pipefd) == -1) {
+        const int xerrno = errno;
+        debugs(89, DBG_IMPORTANT, "PFCTL pipe creation failed: " << xstrerr(xerrno));
+        return false;
+    }
+    const pid_t pid = fork();
+    if (pid == 0) {
+        close(pipefd[0]);
+        close(STDIN_FILENO);
+        close(STDERR_FILENO);
+        dup2(pipefd[1], STDOUT_FILENO);
+        enter_suid();
+        const int rc = execl("/bin/sh", "/bin/sh", "-c", cmd.rawContent(), NULL);
+        leave_suid();
+        exit(rc);
+    }
+    else if (pid == -1) {
+        int xerrno = errno;
+        debugs(89, DBG_IMPORTANT, "PFCTL fork failed: " << xstrerr(xerrno));
+        return false;
+    }
+    close(pipefd[1]);
+
+    SBuf state;
+    char buf[4096];
+    int n;
+    while ((n = read(pipefd[0], buf, sizeof(buf))) > 0) {
+        state.append(buf, n);
+    }
+
+    if (n == -1) {
+        int xerrno = errno;
+        debugs(89, DBG_IMPORTANT, "Reading from PFCTL failed: " << xstrerr(xerrno));
+        close(pipefd[0]);
+        return false;
+    }
+
+    close(pipefd[0]);
+
+    static const CharacterSet bracket("bracket", "[]");
+    static const CharacterSet colon("colon", ":");
+
+    Parser::Tokenizer tk(state);
+    SBuf host;
+    if (tk.token(host, bracket) || tk.token(host, colon)) {
+        int64_t port = 0;
+        if (tk.int64(port)) {
+            newConn->local = host.c_str();
+            newConn->local.port(port);
+            debugs(89, 5, "address NAT: " << newConn);
+            return true;
+        }
+    }
+
+    debugs(89, 3, "no address in" << Raw("PFCTL output", state.rawContent(), 
+        state.length()));
+    int status;
+    if (waitpid(pid, &status, WNOHANG) > 0 && WIFEXITED(status)) {
+        debugs(89, 3, "PFCTL exec failed: " << xstrerr(WEXITSTATUS(status)));
+    }
+    return false;
+
+#else /* _SQUID_APPLE_ */
+
     /* On recent PF versions the getsockname() call performed already provided
      * the required TCP packet details.
      * There is no way to identify whether they came from NAT or not.
@@ -309,6 +398,7 @@
     debugs(89, 5, HERE << "address NAT divert-to: " << newConn);
     return true;
 
+#endif /* _SQUID_APPLE_ */
 #else /* USE_NAT_DEVPF / --with-nat-devpf */
 
     struct pfioc_natlook nl;

