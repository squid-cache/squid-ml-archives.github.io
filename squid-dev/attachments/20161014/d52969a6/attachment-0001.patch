Fixed v3.5 r14082 build with eCAP but without ICAP support.

That is, when ./configured with --enable-ecap --disable-icap-client.

AccessLogEntry::icap requires ICAP_CLIENT, not just USE_ADAPTATION.

=== modified file 'src/format/Format.cc'
--- src/format/Format.cc	2016-09-16 11:53:28 +0000
+++ src/format/Format.cc	2016-10-15 00:14:10 +0000
@@ -301,54 +301,54 @@ log_quoted_string(const char *str, char
             ++p;
             *p = *str;
             ++p;
             ++str;
             break;
         }
     }
 
     *p = '\0';
 }
 
 /// XXX: Misnamed. TODO: Split <h (and this function) to distinguish received
 /// headers from sent headers rather than failing to distinguish requests from responses.
 /// \retval HttpReply sent to the HTTP client (access.log and default context).
 /// \retval HttpReply received (encapsulated) from the ICAP server (icap.log context).
 /// \retval HttpRequest received (encapsulated) from the ICAP server (icap.log context).
 static const HttpMsg *
 actualReplyHeader(const AccessLogEntry::Pointer &al)
 {
     const HttpMsg *msg = al->reply;
-#if USE_ADAPTATION
+#if ICAP_CLIENT
     // al->icap.reqMethod is methodNone in access.log context
     if (!msg && al->icap.reqMethod == Adaptation::methodReqmod)
         msg = al->adapted_request;
 #endif
     return msg;
 }
 
 /// XXX: Misnamed. See actualReplyHeader().
 /// \return HttpRequest or HttpReply for %http::>h.
 static const HttpMsg *
 actualRequestHeader(const AccessLogEntry::Pointer &al)
 {
-#if USE_ADAPTATION
+#if ICAP_CLIENT
     // al->icap.reqMethod is methodNone in access.log context
     if (al->icap.reqMethod == Adaptation::methodRespmod) {
         // XXX: for now AccessLogEntry lacks virgin response headers
         return NULL;
     }
 #endif
     return al->request;
 }
 
 void
 Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logSequenceNumber) const
 {
     char tmp[1024];
     String sb;
 
     for (Token *fmt = format; fmt != NULL; fmt = fmt->next) {   /* for each token */
         const char *out = NULL;
         int quote = 0;
         long int outint = 0;
         int doint = 0;
@@ -802,65 +802,65 @@ Format::Format::assemble(MemBuf &mb, con
             if (al->adapted_request)
                 sb = al->adapted_request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
 
             break;
 
         case LFT_REPLY_HEADER_ELEM: {
             if (const HttpMsg *msg = actualReplyHeader(al))
                 sb = msg->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
 
             quote = 1;
         }
         break;
 
         case LFT_REQUEST_ALL_HEADERS:
-#if USE_ADAPTATION
+#if ICAP_CLIENT
             if (al->icap.reqMethod == Adaptation::methodRespmod) {
                 // XXX: since AccessLogEntry::Headers lacks virgin response
                 // headers, do nothing for now
                 out = NULL;
             } else
 #endif
             {
                 out = al->headers.request;
             }
 
             quote = 1;
 
             break;
 
         case LFT_ADAPTED_REQUEST_ALL_HEADERS:
             out = al->headers.adapted_request;
 
             quote = 1;
 
             break;
 
         case LFT_REPLY_ALL_HEADERS:
             out = al->headers.reply;
-#if USE_ADAPTATION
+#if ICAP_CLIENT
             if (!out && al->icap.reqMethod == Adaptation::methodReqmod)
                 out = al->headers.adapted_request;
 #endif
 
             quote = 1;
 
             break;
 
         case LFT_USER_NAME:
 #if USE_AUTH
             if (al->request && al->request->auth_user_request != NULL)
                 out = strOrNull(al->request->auth_user_request->username());
 #endif
             if (!out && al->request && al->request->extacl_user.size()) {
                 if (const char *t = al->request->extacl_user.termedBuf())
                     out = t;
             }
 
             if (!out)
                 out = strOrNull(al->cache.extuser);

