# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20161026201134-08x57nniqdjawou1
# target_branch: ../trunk/
# testament_sha1: fd835fd8097c968d17ae236905abe0cc0b1a4d88
# timestamp: 2016-10-26 21:11:50 +0100
# base_revision_id: squid3@treenet.co.nz-20161019211413-\
#   6x8ygebubq745sa0
# 
# Begin patch
=== modified file 'src/acl/RegexData.cc'
--- src/acl/RegexData.cc	2016-01-01 00:12:18 +0000
+++ src/acl/RegexData.cc	2016-10-26 20:11:34 +0000
@@ -21,7 +21,7 @@
 #include "base/RegexPattern.h"
 #include "ConfigParser.h"
 #include "Debug.h"
-#include "wordlist.h"
+#include "sbuf/List.h"
 
 ACLRegexData::~ACLRegexData()
 {
@@ -101,7 +101,7 @@
 }
 
 static bool
-compileRE(std::list<RegexPattern> &curlist, char * RE, int flags)
+compileRE(std::list<RegexPattern> &curlist, const char * RE, int flags)
 {
     if (RE == NULL || *RE == '\0')
         return curlist.empty(); // XXX: old code did this. It looks wrong.
@@ -127,7 +127,7 @@
  * called only once per ACL.
  */
 static int
-compileOptimisedREs(std::list<RegexPattern> &curlist, wordlist * wl)
+compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
     std::list<RegexPattern> newlist;
     int numREs = 0;
@@ -136,11 +136,13 @@
     char largeRE[BUFSIZ];
     *largeRE = 0;
 
-    while (wl != NULL) {
+    for (SBuf i : sl) {
         int RElen;
-        RElen = strlen( wl->key );
+        RElen = i.length();
 
-        if (strcmp(wl->key, "-i") == 0) {
+        static const SBuf minus_i("-i");
+        static const SBuf plus_i("+i");
+        if (i == minus_i) {
             if (flags & REG_ICASE) {
                 /* optimisation of  -i ... -i */
                 debugs(28, 2, "compileOptimisedREs: optimisation of -i ... -i" );
@@ -151,7 +153,7 @@
                 flags |= REG_ICASE;
                 largeRE[largeREindex=0] = '\0';
             }
-        } else if (strcmp(wl->key, "+i") == 0) {
+        } else if (i == plus_i) {
             if ((flags & REG_ICASE) == 0) {
                 /* optimisation of  +i ... +i */
                 debugs(28, 2, "compileOptimisedREs: optimisation of +i ... +i");
@@ -163,17 +165,15 @@
                 largeRE[largeREindex=0] = '\0';
             }
         } else if (RElen + largeREindex + 3 < BUFSIZ-1) {
-            debugs(28, 2, "compileOptimisedREs: adding RE '" << wl->key << "'");
+            debugs(28, 2, "compileOptimisedREs: adding RE '" << i << "'");
             if (largeREindex > 0) {
                 largeRE[largeREindex] = '|';
                 ++largeREindex;
             }
             largeRE[largeREindex] = '(';
             ++largeREindex;
-            for (char * t = wl->key; *t != '\0'; ++t) {
-                largeRE[largeREindex] = *t;
-                ++largeREindex;
-            }
+            i.copy(largeRE+largeREindex, BUFSIZ-largeREindex);
+            largeREindex += i.length();
             largeRE[largeREindex] = ')';
             ++largeREindex;
             largeRE[largeREindex] = '\0';
@@ -185,7 +185,6 @@
             largeRE[largeREindex=0] = '\0';
             continue;    /* do the loop again to add the RE to largeRE */
         }
-        wl = wl->next;
     }
 
     if (!compileRE(newlist, largeRE, flags))
@@ -205,20 +204,20 @@
 }
 
 static void
-compileUnoptimisedREs(std::list<RegexPattern> &curlist, wordlist * wl)
+compileUnoptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
     int flags = REG_EXTENDED | REG_NOSUB;
 
-    while (wl != NULL) {
-        if (strcmp(wl->key, "-i") == 0) {
+    static const SBuf minus_i("-i"), plus_i("+i");
+    for (auto i : sl) {
+        if (i == minus_i) {
             flags |= REG_ICASE;
-        } else if (strcmp(wl->key, "+i") == 0) {
+        } else if (i == plus_i) {
             flags &= ~REG_ICASE;
         } else {
-            if (!compileRE(curlist, wl->key , flags))
-                debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Compile failed: '" << wl->key << "'");
+            if (!compileRE(curlist, i.c_str() , flags))
+                debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Compile failed: '" << i << "'");
         }
-        wl = wl->next;
     }
 }
 
@@ -227,7 +226,7 @@
 {
     debugs(28, 2, "new Regex line or file");
 
-    wordlist *wl = NULL;
+    SBufList sl;
     while (char *t = ConfigParser::RegexStrtokFile()) {
         const char *clean = removeUnnecessaryWildcards(t);
         if (strlen(clean) > BUFSIZ-1) {
@@ -235,16 +234,14 @@
             debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Larger than " << BUFSIZ-1 << " characters: '" << clean << "'");
         } else {
             debugs(28, 3, "buffering RE '" << clean << "'");
-            wordlistAdd(&wl, clean);
+            sl.push_back(SBuf(clean));
         }
     }
 
-    if (!compileOptimisedREs(data, wl)) {
+    if (!compileOptimisedREs(data, sl)) {
         debugs(28, DBG_IMPORTANT, "WARNING: optimisation of regular expressions failed; using fallback method without optimisation");
-        compileUnoptimisedREs(data, wl);
+        compileUnoptimisedREs(data, sl);
     }
-
-    wordlistDestroy(&wl);
 }
 
 bool

# Begin bundle
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
3JFOFCQaxluAAA==
