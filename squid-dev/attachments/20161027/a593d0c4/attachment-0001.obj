# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: kinkie@squid-cache.org-20161026231742-707ak2pb3bqzepbo
# target_branch: ../trunk/
# testament_sha1: 478217485a8e5be5143871904944e6f74c0fc45a
# timestamp: 2016-10-27 00:17:52 +0100
# base_revision_id: squid3@treenet.co.nz-20161019211413-\
#   6x8ygebubq745sa0
# 
# Begin patch
=== modified file 'src/acl/RegexData.cc'
--- src/acl/RegexData.cc	2016-01-01 00:12:18 +0000
+++ src/acl/RegexData.cc	2016-10-26 23:17:42 +0000
@@ -21,7 +21,7 @@
 #include "base/RegexPattern.h"
 #include "ConfigParser.h"
 #include "Debug.h"
-#include "wordlist.h"
+#include "sbuf/List.h"
 
 ACLRegexData::~ACLRegexData()
 {
@@ -38,7 +38,7 @@
     // walk the list of patterns to see if one matches
     for (auto &i : data) {
         if (i.match(word)) {
-            debugs(28, 2, "'" << i.c_str() << "' found in '" << word << "'");
+            debugs(28, 2, '\'' << i.c_str() << "' found in '" << word << '\'');
             // TODO: old code also popped the pattern to second place of the list
             // in order to reduce patterns search times.
             return 1;
@@ -59,14 +59,14 @@
     for (auto &i : data) {
         if (i.flags != flags) {
             if ((i.flags&REG_ICASE) != 0) {
-                sl.push_back(SBuf("-i"));
+                sl.emplace_back("-i");
             } else {
-                sl.push_back(SBuf("+i"));
+                sl.emplace_back("+i");
             }
             flags = i.flags;
         }
 
-        sl.push_back(SBuf(i.c_str()));
+        sl.emplace_back(i.c_str());
     }
 
     return sl;
@@ -88,12 +88,12 @@
     }
 
     if (*t == '\0') {
-        debugs(28, DBG_IMPORTANT, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_IMPORTANT, cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_IMPORTANT, "WARNING: regular expression '" << orig << "' has only wildcards and matches all strings. Using '.*' instead.");
         return ".*";
     }
     if (t != orig) {
-        debugs(28, DBG_IMPORTANT, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_IMPORTANT, cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_IMPORTANT, "WARNING: regular expression '" << orig << "' has unnecessary wildcard(s). Using '" << t << "' instead.");
     }
 
@@ -101,7 +101,7 @@
 }
 
 static bool
-compileRE(std::list<RegexPattern> &curlist, char * RE, int flags)
+compileRE(std::list<RegexPattern> &curlist, const char * RE, int flags)
 {
     if (RE == NULL || *RE == '\0')
         return curlist.empty(); // XXX: old code did this. It looks wrong.
@@ -110,7 +110,7 @@
     if (int errcode = regcomp(&comp, RE, flags)) {
         char errbuf[256];
         regerror(errcode, &comp, errbuf, sizeof errbuf);
-        debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_CRITICAL, cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': " << errbuf);
         return false;
     }
@@ -127,7 +127,7 @@
  * called only once per ACL.
  */
 static int
-compileOptimisedREs(std::list<RegexPattern> &curlist, wordlist * wl)
+compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
     std::list<RegexPattern> newlist;
     int numREs = 0;
@@ -136,56 +136,55 @@
     char largeRE[BUFSIZ];
     *largeRE = 0;
 
-    while (wl != NULL) {
+    for (SBuf i : sl) {
         int RElen;
-        RElen = strlen( wl->key );
+        RElen = i.length();
 
-        if (strcmp(wl->key, "-i") == 0) {
+        static const SBuf minus_i("-i");
+        static const SBuf plus_i("+i");
+        if (i == minus_i) {
             if (flags & REG_ICASE) {
                 /* optimisation of  -i ... -i */
-                debugs(28, 2, "compileOptimisedREs: optimisation of -i ... -i" );
+                debugs(28, 2, "optimisation of -i ... -i" );
             } else {
-                debugs(28, 2, "compileOptimisedREs: -i" );
+                debugs(28, 2, "-i" );
                 if (!compileRE(newlist, largeRE, flags))
                     return 0;
                 flags |= REG_ICASE;
                 largeRE[largeREindex=0] = '\0';
             }
-        } else if (strcmp(wl->key, "+i") == 0) {
+        } else if (i == plus_i) {
             if ((flags & REG_ICASE) == 0) {
                 /* optimisation of  +i ... +i */
-                debugs(28, 2, "compileOptimisedREs: optimisation of +i ... +i");
+                debugs(28, 2, "optimisation of +i ... +i");
             } else {
-                debugs(28, 2, "compileOptimisedREs: +i");
+                debugs(28, 2, "+i");
                 if (!compileRE(newlist, largeRE, flags))
                     return 0;
                 flags &= ~REG_ICASE;
                 largeRE[largeREindex=0] = '\0';
             }
         } else if (RElen + largeREindex + 3 < BUFSIZ-1) {
-            debugs(28, 2, "compileOptimisedREs: adding RE '" << wl->key << "'");
+            debugs(28, 2, "adding RE '" << i << "'");
             if (largeREindex > 0) {
                 largeRE[largeREindex] = '|';
                 ++largeREindex;
             }
             largeRE[largeREindex] = '(';
             ++largeREindex;
-            for (char * t = wl->key; *t != '\0'; ++t) {
-                largeRE[largeREindex] = *t;
-                ++largeREindex;
-            }
+            i.copy(largeRE+largeREindex, BUFSIZ-largeREindex);
+            largeREindex += i.length();
             largeRE[largeREindex] = ')';
             ++largeREindex;
             largeRE[largeREindex] = '\0';
             ++numREs;
         } else {
-            debugs(28, 2, "compileOptimisedREs: buffer full, generating new optimised RE..." );
+            debugs(28, 2, "buffer full, generating new optimised RE..." );
             if (!compileRE(newlist, largeRE, flags))
                 return 0;
             largeRE[largeREindex=0] = '\0';
             continue;    /* do the loop again to add the RE to largeRE */
         }
-        wl = wl->next;
     }
 
     if (!compileRE(newlist, largeRE, flags))
@@ -194,9 +193,9 @@
     /* all was successful, so put the new list at the tail */
     curlist.splice(curlist.end(), newlist);
 
-    debugs(28, 2, "compileOptimisedREs: " << numREs << " REs are optimised into one RE.");
+    debugs(28, 2, numREs << " REs are optimised into one RE.");
     if (numREs > 100) {
-        debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), "WARNING: there are more than 100 regular expressions. " <<
                "Consider using less REs or use rules without expressions like 'dstdomain'.");
     }
@@ -205,20 +204,20 @@
 }
 
 static void
-compileUnoptimisedREs(std::list<RegexPattern> &curlist, wordlist * wl)
+compileUnoptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
     int flags = REG_EXTENDED | REG_NOSUB;
 
-    while (wl != NULL) {
-        if (strcmp(wl->key, "-i") == 0) {
+    static const SBuf minus_i("-i"), plus_i("+i");
+    for (auto i : sl) {
+        if (i == minus_i) {
             flags |= REG_ICASE;
-        } else if (strcmp(wl->key, "+i") == 0) {
+        } else if (i == plus_i) {
             flags &= ~REG_ICASE;
         } else {
-            if (!compileRE(curlist, wl->key , flags))
-                debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Compile failed: '" << wl->key << "'");
+            if (!compileRE(curlist, i.c_str() , flags))
+                debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Compile failed: '" << i << "'");
         }
-        wl = wl->next;
     }
 }
 
@@ -227,24 +226,22 @@
 {
     debugs(28, 2, "new Regex line or file");
 
-    wordlist *wl = NULL;
+    SBufList sl;
     while (char *t = ConfigParser::RegexStrtokFile()) {
         const char *clean = removeUnnecessaryWildcards(t);
         if (strlen(clean) > BUFSIZ-1) {
-            debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+            debugs(28, DBG_CRITICAL, cfg_filename << " line " << config_lineno << ": " << config_input_line);
             debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Larger than " << BUFSIZ-1 << " characters: '" << clean << "'");
         } else {
             debugs(28, 3, "buffering RE '" << clean << "'");
-            wordlistAdd(&wl, clean);
+            sl.emplace_back(clean);
         }
     }
 
-    if (!compileOptimisedREs(data, wl)) {
+    if (!compileOptimisedREs(data, sl)) {
         debugs(28, DBG_IMPORTANT, "WARNING: optimisation of regular expressions failed; using fallback method without optimisation");
-        compileUnoptimisedREs(data, wl);
+        compileUnoptimisedREs(data, sl);
     }
-
-    wordlistDestroy(&wl);
 }
 
 bool

# Begin bundle
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
U4UJCnVj0qA=
