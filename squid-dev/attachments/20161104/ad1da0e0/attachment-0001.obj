=== modified file 'src/sbuf/Algorithms.h'
--- src/sbuf/Algorithms.h	2016-02-29 10:11:37 +0000
+++ src/sbuf/Algorithms.h	2016-11-04 06:23:44 +0000
@@ -54,31 +54,49 @@
     SBuf::size_type separatorLen_;
 };
 
-/// join all the SBuf in a container of SBuf into a single SBuf, separating with separator
-template <class Container>
+/** Join container of SBufs and append to supplied target
+ *
+ * append to the target SBuf all elements in the [begin,end) range from
+ * an iterable container, prefixed by prefix, separated by separator and
+ * followed by suffix. Prefix and suffix are added also in case of empty
+ * iterable
+ *
+ * \return the modified dest
+ */
+template <class ContainerIterator>
 SBuf
-SBufContainerJoin(const Container &items, const SBuf& separator)
+JoinContainerIntoSBuf(SBuf &dest, const ContainerIterator &begin,
+		const ContainerIterator &end, const SBuf& separator,
+		const SBuf& prefix = SBuf(), const SBuf& suffix = SBuf())
 {
+    if (begin == end) {
+    	dest.append(prefix).append(suffix);
+        return dest;
+    }
+
     // optimization: pre-calculate needed storage
-    const SBuf::size_type sz = std::accumulate(items.begin(), items.end(), 0, SBufAddLength(separator));
-
-    // sz can be zero in two cases: either items is empty, or all items
-    //  are zero-length. In the former case, we must protect against
-    //  dereferencing the iterator later on, and checking sz is more efficient
-    //  than checking items.size(). This check also provides an optimization
-    //  for the latter case without adding complexity.
-    if (sz == 0)
-        return SBuf();
-
-    SBuf rv;
-    rv.reserveSpace(sz);
-
-    typename Container::const_iterator i(items.begin());
-    rv.append(*i);
+    const SBuf::size_type sz = std::accumulate(begin, end, 0, SBufAddLength(separator));
+    dest.reserveSpace(sz + prefix.length() + suffix.length());
+
+    auto i = begin;
+    dest.append(prefix);
+    dest.append(*i);
     ++i;
-    for (; i != items.end(); ++i)
-        rv.append(separator).append(*i);
-    return rv;
+    for (; i != end; ++i)
+        dest.append(separator).append(*i);
+    dest.append(suffix);
+    return dest;
+}
+
+/// variant of JoinContainerIntoSBuf not needing a SBuf lvalue
+template <class ContainerIterator>
+SBuf
+JoinContainerToSBuf(const ContainerIterator &begin,
+		const ContainerIterator &end, const SBuf& separator,
+		const SBuf& prefix = SBuf(), const SBuf& suffix = SBuf())
+{
+	SBuf rv;
+	return JoinContainerIntoSBuf(rv, begin, end, separator, prefix, suffix);
 }
 
 namespace std {

=== modified file 'src/tests/testSBufList.cc'
--- src/tests/testSBufList.cc	2016-03-01 09:58:44 +0000
+++ src/tests/testSBufList.cc	2016-11-04 06:28:43 +0000
@@ -37,11 +37,17 @@
 testSBufList::testSBufListJoin()
 {
     SBufList foo;
-    CPPUNIT_ASSERT_EQUAL(SBuf(""),SBufContainerJoin(foo,SBuf()));
-    CPPUNIT_ASSERT_EQUAL(SBuf(""),SBufContainerJoin(foo,SBuf()));
+    CPPUNIT_ASSERT_EQUAL(SBuf(""),JoinContainerToSBuf(foo.begin(), foo.end(),SBuf()));
     for (int j = 0; j < sbuf_tokens_number; ++j)
         foo.push_back(tokens[j]);
-    SBuf joined=SBufContainerJoin(foo,SBuf(" "));
+    SBuf joined=JoinContainerToSBuf(foo.begin(), foo.end(),SBuf(" "));
     CPPUNIT_ASSERT_EQUAL(literal,joined);
+    SBuf s1("1"), s2("2"), s3("3"), full("(1,2,3)");
+    SBufList sl{s1,s2,s3};
+    CPPUNIT_ASSERT_EQUAL(full, JoinContainerToSBuf(sl.begin(),
+    		sl.end(), SBuf(","), SBuf("("), SBuf(")")));
+
+    CPPUNIT_ASSERT_EQUAL(SBuf(""),JoinContainerToSBuf(foo.begin(), foo.begin(),SBuf()));
+
 }
 

