=== modified file 'src/Makefile.am'
--- src/Makefile.am	2017-01-03 13:27:40 +0000
+++ src/Makefile.am	2017-01-04 12:42:22 +0000
@@ -504,7 +504,6 @@
 noinst_HEADERS = \
 	client_side_request.cci \
 	MemBuf.h \
-	String.cci \
 	SquidString.h \
 	SquidTime.h
 

=== modified file 'src/SquidString.h'
--- src/SquidString.h	2017-01-01 00:12:22 +0000
+++ src/SquidString.h	2017-01-04 14:00:45 +0000
@@ -11,6 +11,8 @@
 #ifndef SQUID_STRING_H
 #define SQUID_STRING_H
 
+#include "base/TextException.h"
+
 #include <ostream>
 
 /* squid string placeholder (for printf) */
@@ -23,7 +25,7 @@
 {
 
 public:
-    _SQUID_INLINE_ String();
+    String();
     String(char const *);
     String(String const &);
     ~String();
@@ -38,25 +40,34 @@
 
     /**
      * Retrieve a single character in the string.
-     \param pos Position of character to retrieve.
+     \param aPos Position of character to retrieve.
      */
-    _SQUID_INLINE_ char operator [](unsigned int pos) const;
-
-    _SQUID_INLINE_ size_type size() const;
+    char operator [](unsigned int aPos) const {
+        assert(aPos < size_);
+        return buf_[aPos];
+    }
+
+    size_type size() const { return len_; }
+
     /// variant of size() suited to be used for printf-alikes.
-    /// throws when size() > MAXINT
-    int psize() const;
+    /// throws when size() > INT_MAX
+    int psize() const {
+        Must(size() < INT_MAX);
+        return size();
+    }
 
     /**
      * Returns a raw pointer to the underlying backing store. The caller has been
      * verified not to make any assumptions about null-termination
      */
-    _SQUID_INLINE_ char const * rawBuf() const;
+    char const * rawBuf() const { return buf_; }
+
     /**
      * Returns a raw pointer to the underlying backing store.
      * The caller requires it to be null-terminated.
      */
-    _SQUID_INLINE_ char const * termedBuf() const;
+    char const * termedBuf() const { return buf_; }
+
     void limitInit(const char *str, int len); // TODO: rename to assign()
     void clean();
     void reset(char const *str);
@@ -73,12 +84,14 @@
     size_type find(char const *aString) const;
     const char * rpos(char const ch) const;
     size_type rfind(char const ch) const;
-    _SQUID_INLINE_ int cmp(char const *) const;
-    _SQUID_INLINE_ int cmp(char const *, size_type count) const;
-    _SQUID_INLINE_ int cmp(String const &) const;
-    _SQUID_INLINE_ int caseCmp(char const *) const;
-    _SQUID_INLINE_ int caseCmp(char const *, size_type count) const;
-    _SQUID_INLINE_ int caseCmp(String const &) const;
+    int cmp(char const *) const;
+    int cmp(char const *, size_type count) const;
+    int cmp(String const &) const;
+    int caseCmp(char const *) const;
+    int caseCmp(char const *, size_type count) const;
+    int caseCmp(String const &str) const {
+        return caseCmp(str.rawBuf(),str.size());
+    }
 
     /// Whether creating a totalLen-character string is safe (i.e., unlikely to assert).
     /// Optional extras can be used for overflow-safe length addition.
@@ -89,7 +102,7 @@
 
     String substr(size_type from, size_type to) const;
 
-    _SQUID_INLINE_ void cut(size_type newLength);
+    void cut(size_type newLength);
 
 private:
     void allocAndFill(const char *str, int len);
@@ -99,31 +112,41 @@
     bool defined() const {return buf_!=NULL;}
     bool undefined() const {return !defined();}
 
-    _SQUID_INLINE_ bool nilCmp(bool, bool, int &) const;
-
     /* never reference these directly! */
-    size_type size_; /* buffer size; limited by SizeMax_ */
+    size_type size_ = 0; /* buffer size; limited by SizeMax_ */
 
-    size_type len_;  /* current length  */
+    size_type len_ = 0;  /* current length  */
 
     static const size_type SizeMax_ = 65535; ///< 64K limit protects some fixed-size buffers
     /// returns true after increasing the first argument by extra if the sum does not exceed SizeMax_
     static bool SafeAdd(size_type &base, size_type extra) { if (extra <= SizeMax_ && base <= SizeMax_ - extra) { base += extra; return true; } return false; }
 
-    char *buf_;
-
-    _SQUID_INLINE_ void set(char const *loc, char const ch);
-    _SQUID_INLINE_ void cutPointer(char const *loc);
-
+    char *buf_ = nullptr;
+
+    void set(char const *loc, char const ch) {
+        if (loc < buf_ || loc > (buf_ + size_))
+            return;
+        buf_[loc-buf_] = ch;
+    }
+
+    void cutPointer(char const *loc) {
+        if (loc < buf_ || loc > (buf_ + size_))
+            return;
+        len_ = loc-buf_;
+        buf_[len_] = '\0';
+    }
 };
 
-_SQUID_INLINE_ std::ostream & operator<<(std::ostream& os, String const &aString);
-
-_SQUID_INLINE_ bool operator<(const String &a, const String &b);
-
-#if _USE_INLINE_
-#include "String.cci"
-#endif
+inline std::ostream & operator<<(std::ostream &os, String const &aString)
+{
+    os.write(aString.rawBuf(),aString.size());
+    return os;
+}
+
+inline bool operator<(const String &a, const String &b)
+{
+    return a.cmp(b) < 0;
+}
 
 const char *checkNullString(const char *p);
 int stringHasWhitespace(const char *);

=== modified file 'src/String.cc'
--- src/String.cc	2017-01-01 00:12:22 +0000
+++ src/String.cc	2017-01-04 14:27:16 +0000
@@ -16,13 +16,6 @@
 
 #include <climits>
 
-int
-String::psize() const
-{
-    Must(size() < INT_MAX);
-    return size();
-}
-
 // low-level buffer allocation,
 // does not free old buffer and does not adjust or look at len_
 void
@@ -46,12 +39,18 @@
     size_ = aSize;
 }
 
-String::String(char const *aString) : size_(0), len_(0), buf_(NULL)
+String::String()
+{
+#if DEBUGSTRINGS
+    StringRegistry::Instance().add(this);
+#endif
+}
+
+String::String(char const *aString)
 {
     if (aString)
         allocAndFill(aString, strlen(aString));
 #if DEBUGSTRINGS
-
     StringRegistry::Instance().add(this);
 #endif
 }
@@ -233,6 +232,89 @@
     return rv;
 }
 
+void
+String::cut(String::size_type newLength)
+{
+    // size_type is size_t, unsigned. No need to check for newLength <0
+    if (newLength > len_) return;
+
+    len_ = newLength;
+
+    // buf_ may be nullptr on zero-length strings.
+    if (len_ == 0 && !buf_)
+        return;
+
+    buf_[newLength] = '\0';
+}
+
+/// compare NULL and empty strings because str*cmp() may fail on NULL strings
+/// and because we need to return consistent results for strncmp(count == 0).
+static bool
+nilCmp(const bool thisIsNilOrEmpty, const bool otherIsNilOrEmpty, int &result)
+{
+    if (!thisIsNilOrEmpty && !otherIsNilOrEmpty)
+        return false; // result does not matter
+
+    if (thisIsNilOrEmpty && otherIsNilOrEmpty)
+        result = 0;
+    else if (thisIsNilOrEmpty)
+        result = -1;
+    else // otherIsNilOrEmpty
+        result = +1;
+
+    return true;
+}
+
+int
+String::cmp(char const *aString) const
+{
+    int result = 0;
+    if (nilCmp(!size(), (!aString || !*aString), result))
+        return result;
+
+    return strcmp(termedBuf(), aString);
+}
+
+int
+String::cmp(char const *aString, String::size_type count) const
+{
+    int result = 0;
+    if (nilCmp((!size() || !count), (!aString || !*aString || !count), result))
+        return result;
+
+    return strncmp(termedBuf(), aString, count);
+}
+
+int
+String::cmp(String const &aString) const
+{
+    int result = 0;
+    if (nilCmp(!size(), !aString.size(), result))
+        return result;
+
+    return strcmp(termedBuf(), aString.termedBuf());
+}
+
+int
+String::caseCmp(char const *aString) const
+{
+    int result = 0;
+    if (nilCmp(!size(), (!aString || !*aString), result))
+        return result;
+
+    return strcasecmp(termedBuf(), aString);
+}
+
+int
+String::caseCmp(char const *aString, String::size_type count) const
+{
+    int result = 0;
+    if (nilCmp((!size() || !count), (!aString || !*aString || !count), result))
+        return result;
+
+    return strncasecmp(termedBuf(), aString, count);
+}
+
 #if DEBUGSTRINGS
 void
 String::stat(StoreEntry *entry) const
@@ -466,7 +548,3 @@
     return c-rawBuf();
 }
 
-#if !_USE_INLINE_
-#include "String.cci"
-#endif
-

=== removed file 'src/String.cci'
--- src/String.cci	2017-01-01 00:12:22 +0000
+++ src/String.cci	1970-01-01 00:00:00 +0000
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 67    String */
-
-#include <cstring>
-
-String::String() : size_(0), len_(0), buf_(NULL)
-{
-#if DEBUGSTRINGS
-    StringRegistry::Instance().add(this);
-#endif
-}
-
-String::size_type
-String::size() const
-{
-    return len_;
-}
-
-char const *
-String::rawBuf() const
-{
-    return buf_;
-}
-
-char const *
-String::termedBuf() const
-{
-    return buf_;
-}
-
-char
-String::operator [](unsigned int aPos) const
-{
-    assert(aPos < size_);
-
-    return buf_[aPos];
-}
-
-/// compare NULL and empty strings because str*cmp() may fail on NULL strings
-/// and because we need to return consistent results for strncmp(count == 0).
-bool
-String::nilCmp(const bool thisIsNilOrEmpty, const bool otherIsNilOrEmpty, int &result) const
-{
-    if (!thisIsNilOrEmpty && !otherIsNilOrEmpty)
-        return false; // result does not matter
-
-    if (thisIsNilOrEmpty && otherIsNilOrEmpty)
-        result = 0;
-    else if (thisIsNilOrEmpty)
-        result = -1;
-    else // otherIsNilOrEmpty
-        result = +1;
-
-    return true;
-}
-
-int
-String::cmp(char const *aString) const
-{
-    int result = 0;
-    if (nilCmp(!size(), (!aString || !*aString), result))
-        return result;
-
-    return strcmp(termedBuf(), aString);
-}
-
-int
-String::cmp(char const *aString, String::size_type count) const
-{
-    int result = 0;
-    if (nilCmp((!size() || !count), (!aString || !*aString || !count), result))
-        return result;
-
-    return strncmp(termedBuf(), aString, count);
-}
-
-int
-String::cmp(String const &aString) const
-{
-    int result = 0;
-    if (nilCmp(!size(), !aString.size(), result))
-        return result;
-
-    return strcmp(termedBuf(), aString.termedBuf());
-}
-
-int
-String::caseCmp(char const *aString) const
-{
-    int result = 0;
-    if (nilCmp(!size(), (!aString || !*aString), result))
-        return result;
-
-    return strcasecmp(termedBuf(), aString);
-}
-
-int
-String::caseCmp(char const *aString, String::size_type count) const
-{
-    int result = 0;
-    if (nilCmp((!size() || !count), (!aString || !*aString || !count), result))
-        return result;
-
-    return strncasecmp(termedBuf(), aString, count);
-}
-
-int
-String::caseCmp(const String &str) const
-{
-    return caseCmp(str.rawBuf(),str.size());
-}
-
-void
-String::set(char const *loc, char const ch)
-{
-    if (loc < buf_ || loc > (buf_ + size_) ) return;
-
-    buf_[loc-buf_] = ch;
-}
-
-void
-String::cut(String::size_type newLength)
-{
-    // size_type is size_t, unsigned. No need to check for newLength <0
-    if (newLength > len_) return;
-
-    len_ = newLength;
-
-    // buf_ may be NULL on zero-length strings.
-    if (len_ == 0 && buf_ == NULL) return;
-
-    buf_[newLength] = '\0';
-}
-
-void
-String::cutPointer(char const *loc)
-{
-    if (loc < buf_ || loc > (buf_ + size_) ) return;
-
-    len_ = loc-buf_;
-    buf_[len_] = '\0';
-}
-
-std::ostream &
-operator<<(std::ostream& os, String const &aString)
-{
-    os.write(aString.rawBuf(),aString.size());
-    return os;
-}
-
-bool
-operator<(const String &a, const String &b)
-{
-    return a.cmp(b) < 0;
-}
-

