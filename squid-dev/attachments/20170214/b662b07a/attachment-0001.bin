Fixed bugs introduced by r15024.

* Do not leak Note::Value::Value::valueFormat.
* Throw if annotation value parsing failures.

Detected by Coverity Scan:
 * CID 1399758:  Error handling issues (CHECKED_RETURN)
 * CID 1399759:  Resource leaks (CTOR_DTOR_LEAK)

=== modified file 'src/Notes.cc'
--- src/Notes.cc	2017-01-31 00:12:18 +0000
+++ src/Notes.cc	2017-02-13 22:00:50 +0000
@@ -1,68 +1,74 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "client_side.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "parser/Tokenizer.h"
 #include "sbuf/StringConvert.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StrList.h"
 
 #include <algorithm>
 #include <string>
 
 Note::Value::~Value()
 {
     aclDestroyAclList(&aclList);
+    delete valueFormat;
 }
 
 Note::Value::Value(const char *aVal, const bool quoted, const char *descr, const Method m)
     : aclList(nullptr), valueFormat(nullptr), theValue(aVal), theMethod(m)
 {
     if (quoted) {
         valueFormat = new Format::Format(descr ? descr : "Notes");
-        valueFormat->parse(theValue.c_str());
+        if (!valueFormat->parse(theValue.c_str())) {
+            delete valueFormat;
+            SBuf exceptionMsg;
+            exceptionMsg.Printf("failed to parse annotation value %s", theValue.c_str());
+            throw TexcHere(exceptionMsg.c_str());
+        }
     }
 }
 
 const SBuf &
 Note::Value::format(const AccessLogEntryPointer &al)
 {
     if (al && valueFormat) {
         static MemBuf mb;
         mb.reset();
         valueFormat->assemble(mb, al, 0);
         theFormattedValue.assign(mb.content());
         return theFormattedValue;
     }
     return theValue;
 }
 
 Note::Value::Pointer
 Note::addValue(const char *value, const bool quoted, const char *descr, const Value::Method m)
 {
     values.push_back(new Value(value, quoted, descr, m));
     return values.back();
 }
 
 bool
 Note::match(HttpRequest *request, HttpReply *reply, const AccessLogEntry::Pointer &al, SBuf &matched)
 {
     ACLFilledChecklist ch(nullptr, request, nullptr);
     ch.reply = reply;
     if (reply)
         HTTPMSGLOCK(ch.reply);

