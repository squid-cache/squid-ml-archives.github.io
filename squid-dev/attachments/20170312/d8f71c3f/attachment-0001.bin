diff --git a/src/ConfigOption.cc b/src/ConfigOption.cc
index 4f4eb15..023d078 100644
--- a/src/ConfigOption.cc
+++ b/src/ConfigOption.cc
@@ -37,8 +37,7 @@ ConfigOptionVector::parse(char const *option, const char *value, int isaReconfig
 void
 ConfigOptionVector::dump(StoreEntry * e) const
 {
-    for (std::vector<ConfigOption *>::const_iterator i = options.begin();
-            i != options.end(); ++i)
-        (*i)->dump(e);
+    for (auto option : options)
+        option->dump(e);
 }
 
diff --git a/src/DiskIO/DiskIOModule.cc b/src/DiskIO/DiskIOModule.cc
index 031e3da..6ee97a3 100644
--- a/src/DiskIO/DiskIOModule.cc
+++ b/src/DiskIO/DiskIOModule.cc
@@ -63,9 +63,9 @@ DiskIOModule::SetupAllModules()
     MmappedDiskIOModule::GetInstance();
 #endif
 
-    for (iterator i = GetModules().begin(); i != GetModules().end(); ++i)
+    for (auto & i : GetModules())
         /* Call the FS to set up capabilities and initialize the FS driver */
-        (*i)->init();
+        i->init();
 }
 
 void
@@ -113,9 +113,9 @@ DiskIOModule::FreeAllModules()
 DiskIOModule *
 DiskIOModule::Find(char const *type)
 {
-    for (iterator i = GetModules().begin(); i != GetModules().end(); ++i)
-        if (strcasecmp(type, (*i)->type()) == 0)
-            return *i;
+    for (auto & i : GetModules())
+        if (strcasecmp(type, i->type()) == 0)
+            return i;
 
     return NULL;
 }
diff --git a/src/EventLoop.cc b/src/EventLoop.cc
index 5fce061..35a982d 100644
--- a/src/EventLoop.cc
+++ b/src/EventLoop.cc
@@ -99,10 +99,9 @@ EventLoop::runOnce()
 
     do {
         // generate calls and events
-        typedef engine_vector::iterator EVI;
-        for (EVI i = engines.begin(); i != engines.end(); ++i) {
-            if (*i != waitingEngine)
-                checkEngine(*i, false);
+        for (auto & engine : engines) {
+            if (engine != waitingEngine)
+                checkEngine(engine, false);
         }
 
         // dispatch calls accumulated so far
@@ -148,9 +147,8 @@ EventLoop::dispatchCalls()
 void
 EventLoop::setPrimaryEngine(AsyncEngine * engine)
 {
-    for (engine_vector::iterator i = engines.begin();
-            i != engines.end(); ++i)
-        if (*i == engine) {
+    for (auto & i : engines)
+        if (i == engine) {
             primaryEngine = engine;
             return;
         }
diff --git a/src/HttpHdrRange.cc b/src/HttpHdrRange.cc
index baf9656..8dd854e 100644
--- a/src/HttpHdrRange.cc
+++ b/src/HttpHdrRange.cc
@@ -272,8 +272,8 @@ HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) :
 {
     specs.reserve(old.specs.size());
 
-    for (const_iterator i = old.begin(); i != old.end(); ++i)
-        specs.push_back(new HttpHdrRangeSpec ( **i));
+    for (auto i : old)
+        specs.push_back(new HttpHdrRangeSpec ( *i));
 
     assert(old.specs.size() == specs.size());
 }
@@ -348,11 +348,11 @@ HttpHdrRange::getCanonizedSpecs(std::vector<HttpHdrRangeSpec *> &copy)
 {
     /* canonize each entry and destroy bad ones if any */
 
-    for (iterator pos (begin()); pos != end(); ++pos) {
-        if ((*pos)->canonize(clen))
-            copy.push_back (*pos);
+    for (auto & pos : *this) {
+        if (pos->canonize(clen))
+            copy.push_back (pos);
         else
-            delete (*pos);
+            delete pos;
     }
 
     debugs(64, 3, "found " << specs.size() - copy.size() << " bad specs");
@@ -429,20 +429,20 @@ HttpHdrRange::willBeComplex() const
     /* as far as we can tell without the content length */
     int64_t offset = 0;
 
-    for (const_iterator pos (begin()); pos != end(); ++pos) {
-        if (!known_spec((*pos)->offset))    /* ignore unknowns */
+    for (auto pos : *this) {
+        if (!known_spec(pos->offset))    /* ignore unknowns */
             continue;
 
         /* Ensure typecasts is safe */
-        assert ((*pos)->offset >= 0);
+        assert (pos->offset >= 0);
 
-        if ((*pos)->offset < offset)
+        if (pos->offset < offset)
             return true;
 
-        offset = (*pos)->offset;
+        offset = pos->offset;
 
-        if (known_spec((*pos)->length)) /* avoid  unknowns */
-            offset += (*pos)->length;
+        if (known_spec(pos->length)) /* avoid  unknowns */
+            offset += pos->length;
     }
 
     return false;
@@ -532,8 +532,8 @@ HttpHdrRange::contains(HttpHdrRangeSpec& r) const
     assert(r.length >= 0);
     HttpHdrRangeSpec::HttpRange rrange(r.offset, r.offset + r.length);
 
-    for (const_iterator i = begin(); i != end(); ++i) {
-        HttpHdrRangeSpec::HttpRange irange((*i)->offset, (*i)->offset + (*i)->length);
+    for (auto i : *this) {
+        HttpHdrRangeSpec::HttpRange irange(i->offset, i->offset + i->length);
         HttpHdrRangeSpec::HttpRange intersection = rrange.intersection(irange);
 
         if (intersection.start == irange.start && intersection.size() == irange.size())
diff --git a/src/StoreFileSystem.cc b/src/StoreFileSystem.cc
index c6587f3..6d65331 100644
--- a/src/StoreFileSystem.cc
+++ b/src/StoreFileSystem.cc
@@ -16,16 +16,16 @@ std::vector<StoreFileSystem*> *StoreFileSystem::_FileSystems = NULL;
 void
 StoreFileSystem::RegisterAllFsWithCacheManager(void)
 {
-    for (iterator i = GetFileSystems().begin(); i != GetFileSystems().end(); ++i)
-        (*i)->registerWithCacheManager();
+    for (auto & i : GetFileSystems())
+        i->registerWithCacheManager();
 }
 
 void
 StoreFileSystem::SetupAllFs()
 {
-    for (iterator i = GetFileSystems().begin(); i != GetFileSystems().end(); ++i)
+    for (auto & i : GetFileSystems())
         /* Call the FS to set up capabilities and initialize the FS driver */
-        (*i)->setup();
+        i->setup();
 }
 
 void
diff --git a/src/acl/Acl.cc b/src/acl/Acl.cc
index 78111e3..aabd924 100644
--- a/src/acl/Acl.cc
+++ b/src/acl/Acl.cc
@@ -545,8 +545,8 @@ ACL::Prototype::Registered(char const *aType)
 {
     debugs(28, 7, "ACL::Prototype::Registered: invoked for type " << aType);
 
-    for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-        if (!strcmp (aType, (*i)->typeString)) {
+    for (auto & i : *Registry)
+        if (!strcmp (aType, i->typeString)) {
             debugs(28, 7, "ACL::Prototype::Registered:    yes");
             return true;
         }
@@ -581,10 +581,10 @@ ACL::Prototype::Factory (char const *typeToClone)
 {
     debugs(28, 4, "ACL::Prototype::Factory: cloning an object for type '" << typeToClone << "'");
 
-    for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-        if (!strcmp (typeToClone, (*i)->typeString)) {
-            ACL *A = (*i)->prototype->clone();
-            A->flags = (*i)->prototype->flags;
+    for (auto & i : *Registry)
+        if (!strcmp (typeToClone, i->typeString)) {
+            ACL *A = i->prototype->clone();
+            A->flags = i->prototype->flags;
             return A;
         }
 
diff --git a/src/acl/Arp.cc b/src/acl/Arp.cc
index 9ceabde..14ee3bc 100644
--- a/src/acl/Arp.cc
+++ b/src/acl/Arp.cc
@@ -129,9 +129,9 @@ SBufList
 ACLARP::dump() const
 {
     SBufList sl;
-    for (auto i = aclArpData.begin(); i != aclArpData.end(); ++i) {
+    for (const auto & i : aclArpData) {
         char buf[48];
-        i->encode(buf,48);
+        i.encode(buf,48);
         sl.push_back(SBuf(buf));
     }
     return sl;
diff --git a/src/acl/AtStepData.cc b/src/acl/AtStepData.cc
index 6e78d16..77e648b 100644
--- a/src/acl/AtStepData.cc
+++ b/src/acl/AtStepData.cc
@@ -43,10 +43,10 @@ SBufList
 ACLAtStepData::dump() const
 {
     SBufList sl;
-    for (std::list<Ssl::BumpStep>::const_iterator it = values.begin(); it != values.end(); ++it) {
-        sl.push_back(SBuf(*it == Ssl::bumpStep1 ? "SslBump1" :
-                          *it == Ssl::bumpStep2 ? "SslBump2" :
-                          *it == Ssl::bumpStep3 ? "SslBump3" : "???"));
+    for (auto value : values) {
+        sl.push_back(SBuf(value == Ssl::bumpStep1 ? "SslBump1" :
+                          value == Ssl::bumpStep2 ? "SslBump2" :
+                          value == Ssl::bumpStep3 ? "SslBump3" : "???"));
     }
     return sl;
 }
diff --git a/src/acl/Eui64.cc b/src/acl/Eui64.cc
index 56b8c9e..347e91b 100644
--- a/src/acl/Eui64.cc
+++ b/src/acl/Eui64.cc
@@ -107,9 +107,9 @@ SBufList
 ACLEui64::dump() const
 {
     SBufList sl;
-    for (auto i = eui64Data.begin(); i != eui64Data.end(); ++i) {
+    for (const auto & i : eui64Data) {
         static char buf[48];
-        i->encode(buf,48);
+        i.encode(buf,48);
         sl.push_back(SBuf(buf));
     }
     return sl;
diff --git a/src/acl/InnerNode.cc b/src/acl/InnerNode.cc
index 33ca0cb..7cf82a2 100644
--- a/src/acl/InnerNode.cc
+++ b/src/acl/InnerNode.cc
@@ -77,8 +77,8 @@ SBufList
 Acl::InnerNode::dump() const
 {
     SBufList rv;
-    for (Nodes::const_iterator i = nodes.begin(); i != nodes.end(); ++i)
-        rv.push_back(SBuf((*i)->name));
+    for (auto node : nodes)
+        rv.push_back(SBuf(node->name));
     return rv;
 }
 
diff --git a/src/acl/IntRange.cc b/src/acl/IntRange.cc
index 557aa92..b3fdf7a 100644
--- a/src/acl/IntRange.cc
+++ b/src/acl/IntRange.cc
@@ -82,10 +82,8 @@ SBufList
 ACLIntRange::dump() const
 {
     SBufList sl;
-    for (std::list<RangeType>::const_iterator iter = ranges.begin(); iter != ranges.end(); ++iter) {
+    for (auto element : ranges) {
         SBuf sb;
-        const RangeType & element = *iter;
-
         if (element.size() == 1)
             sb.Printf("%d", element.start);
         else
diff --git a/src/acl/MethodData.cc b/src/acl/MethodData.cc
index 2144ca6..a5c2f6d 100644
--- a/src/acl/MethodData.cc
+++ b/src/acl/MethodData.cc
@@ -44,8 +44,8 @@ SBufList
 ACLMethodData::dump() const
 {
     SBufList sl;
-    for (std::list<HttpRequestMethod>::const_iterator i = values.begin(); i != values.end(); ++i) {
-        sl.push_back((*i).image());
+    for (const auto & value : values) {
+        sl.push_back(value.image());
     }
 
     return sl;
diff --git a/src/acl/ProtocolData.cc b/src/acl/ProtocolData.cc
index c10ac6d..7409290 100644
--- a/src/acl/ProtocolData.cc
+++ b/src/acl/ProtocolData.cc
@@ -43,8 +43,8 @@ SBufList
 ACLProtocolData::dump() const
 {
     SBufList sl;
-    for (std::list<AnyP::ProtocolType>::const_iterator itr = values.begin(); itr != values.end(); ++itr) {
-        sl.push_back(SBuf(AnyP::ProtocolType_str[*itr]));
+    for (auto value : values) {
+        sl.push_back(SBuf(AnyP::ProtocolType_str[value]));
     }
 
     return sl;
diff --git a/src/adaptation/AccessCheck.cc b/src/adaptation/AccessCheck.cc
index 6ce6d91..ddea04b 100644
--- a/src/adaptation/AccessCheck.cc
+++ b/src/adaptation/AccessCheck.cc
@@ -105,9 +105,7 @@ Adaptation::AccessCheck::check()
 {
     debugs(93, 4, HERE << "start checking");
 
-    typedef AccessRules::iterator ARI;
-    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        AccessRule *r = *i;
+    for (auto r : AllRules()) {
         if (isCandidate(*r)) {
             debugs(93, 5, HERE << "check: rule '" << r->id << "' is a candidate");
             candidates.push_back(r->id);
diff --git a/src/adaptation/AccessRule.cc b/src/adaptation/AccessRule.cc
index 2378d57..00cd977 100644
--- a/src/adaptation/AccessRule.cc
+++ b/src/adaptation/AccessRule.cc
@@ -68,10 +68,9 @@ Adaptation::AllRules()
 Adaptation::AccessRule *
 Adaptation::FindRule(const AccessRule::Id &id)
 {
-    typedef AccessRules::iterator ARI;
-    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        if ((*i)->id == id)
-            return *i;
+    for (auto & Rule : AllRules()) {
+        if (Rule->id == id)
+            return Rule;
     }
 
     return NULL;
@@ -80,10 +79,9 @@ Adaptation::FindRule(const AccessRule::Id &id)
 Adaptation::AccessRule *
 Adaptation::FindRuleByGroupId(const String &groupId)
 {
-    typedef AccessRules::iterator ARI;
-    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        if ((*i)->groupId == groupId)
-            return *i;
+    for (auto & Rule : AllRules()) {
+        if (Rule->groupId == groupId)
+            return Rule;
     }
 
     return NULL;
diff --git a/src/adaptation/Config.cc b/src/adaptation/Config.cc
index 536b5a3..e55b4b4 100644
--- a/src/adaptation/Config.cc
+++ b/src/adaptation/Config.cc
@@ -62,9 +62,8 @@ Adaptation::Config::removeService(const String& service)
     for (unsigned int i = 0; i < groups.size(); ) {
         const ServiceGroupPointer group = groups[i];
         const ServiceGroup::Store& services = group->services;
-        typedef ServiceGroup::Store::const_iterator SGSI;
-        for (SGSI it = services.begin(); it != services.end(); ++it) {
-            if (*it == service) {
+        for (const auto & it : services) {
+            if (it == service) {
                 group->removedServices.push_back(service);
                 ServiceGroup::Store::iterator newend;
                 newend = std::remove(group->services.begin(), group->services.end(), service);
@@ -88,11 +87,10 @@ Adaptation::Config::removeService(const String& service)
 Adaptation::ServiceConfigPointer
 Adaptation::Config::findServiceConfig(const String &service)
 {
-    typedef ServiceConfigs::const_iterator SCI;
     const ServiceConfigs& configs = serviceConfigs;
-    for (SCI cfg = configs.begin(); cfg != configs.end(); ++cfg) {
-        if ((*cfg)->key == service)
-            return *cfg;
+    for (const auto & config : configs) {
+        if (config->key == service)
+            return config;
     }
     return NULL;
 }
@@ -100,10 +98,8 @@ Adaptation::Config::findServiceConfig(const String &service)
 void
 Adaptation::Config::removeRule(const String& id)
 {
-    typedef AccessRules::const_iterator ARI;
     const AccessRules& rules = AllRules();
-    for (ARI it = rules.begin(); it != rules.end(); ++it) {
-        AccessRule* rule = *it;
+    for (auto rule : rules) {
         if (rule->groupId == id) {
             debugs(93, 5, "removing access rules for:" << id);
             AccessRules::iterator newend;
@@ -120,10 +116,9 @@ Adaptation::Config::clear()
 {
     debugs(93, 3, HERE << "rules: " << AllRules().size() << ", groups: " <<
            AllGroups().size() << ", services: " << serviceConfigs.size());
-    typedef ServiceConfigs::const_iterator SCI;
     const ServiceConfigs& configs = serviceConfigs;
-    for (SCI cfg = configs.begin(); cfg != configs.end(); ++cfg)
-        removeService((*cfg)->key);
+    for (const auto & config : configs)
+        removeService(config->key);
     serviceConfigs.clear();
     debugs(93, 3, HERE << "rules: " << AllRules().size() << ", groups: " <<
            AllGroups().size() << ", services: " << serviceConfigs.size());
@@ -154,9 +149,8 @@ Adaptation::Config::freeService()
 void
 Adaptation::Config::dumpService(StoreEntry *entry, const char *name) const
 {
-    typedef Services::iterator SCI;
-    for (SCI i = AllServices().begin(); i != AllServices().end(); ++i) {
-        const ServiceConfig &cfg = (*i)->cfg();
+    for (auto & i : AllServices()) {
+        const ServiceConfig &cfg = i->cfg();
         bool isEcap = cfg.protocol.caseCmp("ecap") == 0;
         bool isIcap = !isEcap;
         const char *optConnectionEncryption = "";
@@ -189,10 +183,8 @@ Adaptation::Config::finalize()
     // create service reps from service configs
     int created = 0;
 
-    typedef ServiceConfigs::const_iterator VISCI;
     const ServiceConfigs &configs = serviceConfigs;
-    for (VISCI i = configs.begin(); i != configs.end(); ++i) {
-        const ServiceConfigPointer cfg = *i;
+    for (auto cfg : configs) {
         if (FindService(cfg->key) != NULL) {
             debugs(93, DBG_CRITICAL, "ERROR: Duplicate adaptation service name: " <<
                    cfg->key);
@@ -267,9 +259,8 @@ Adaptation::Config::FreeServiceGroups()
 void
 Adaptation::Config::DumpServiceGroups(StoreEntry *entry, const char *name)
 {
-    typedef Groups::iterator GI;
-    for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i)
-        storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "\n", name, SQUIDSTRINGPRINT((*i)->id));
+    for (auto & i : AllGroups())
+        storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "\n", name, SQUIDSTRINGPRINT(i->id));
 }
 
 void
@@ -298,10 +289,9 @@ Adaptation::Config::DumpAccess(StoreEntry *entry, const char *name)
 {
     LOCAL_ARRAY(char, nom, 64);
 
-    typedef AccessRules::iterator CI;
-    for (CI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        snprintf(nom, 64, "%s " SQUIDSTRINGPH, name, SQUIDSTRINGPRINT((*i)->groupId));
-        dump_acl_access(entry, nom, (*i)->acl);
+    for (auto & Rule : AllRules()) {
+        snprintf(nom, 64, "%s " SQUIDSTRINGPH, name, SQUIDSTRINGPRINT(Rule->groupId));
+        dump_acl_access(entry, nom, Rule->acl);
     }
 }
 
diff --git a/src/adaptation/Service.cc b/src/adaptation/Service.cc
index fb3ff77..05d565e 100644
--- a/src/adaptation/Service.cc
+++ b/src/adaptation/Service.cc
@@ -67,10 +67,9 @@ Adaptation::AllServices()
 Adaptation::ServicePointer
 Adaptation::FindService(const Service::Id& key)
 {
-    typedef Services::iterator SI;
-    for (SI i = AllServices().begin(); i != AllServices().end(); ++i) {
-        if ((*i)->cfg().key == key)
-            return *i;
+    for (auto & i : AllServices()) {
+        if (i->cfg().key == key)
+            return i;
     }
     return NULL;
 }
diff --git a/src/adaptation/ServiceGroups.cc b/src/adaptation/ServiceGroups.cc
index 070a2d1..88d252a 100644
--- a/src/adaptation/ServiceGroups.cc
+++ b/src/adaptation/ServiceGroups.cc
@@ -50,8 +50,8 @@ Adaptation::ServiceGroup::finalize()
     // TODO: optimize by remembering ServicePointers rather than IDs
     if (!removedServices.empty()) {
         String s;
-        for (Store::iterator it = removedServices.begin(); it != removedServices.end(); ++it) {
-            s.append(*it);
+        for (auto & removedService : removedServices) {
+            s.append(removedService);
             s.append(',');
         }
         s.cut(s.size() - 1);
@@ -330,10 +330,9 @@ Adaptation::AllGroups()
 Adaptation::ServiceGroupPointer
 Adaptation::FindGroup(const ServiceGroup::Id &id)
 {
-    typedef Groups::iterator GI;
-    for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i) {
-        if ((*i)->id == id)
-            return *i;
+    for (auto & Groups : AllGroups()) {
+        if (Groups->id == id)
+            return Groups;
     }
 
     return NULL;
diff --git a/src/adaptation/ecap/ServiceRep.cc b/src/adaptation/ecap/ServiceRep.cc
index 7983d06..3203f27 100644
--- a/src/adaptation/ecap/ServiceRep.cc
+++ b/src/adaptation/ecap/ServiceRep.cc
@@ -82,9 +82,9 @@ Adaptation::Ecap::ConfigRep::option(const libecap::Name &name) const
     // TODO: We could build a by-name index, but is it worth it? Good adapters
     // should use visitEachOption() instead, to check for name typos/errors.
     typedef Master::Extensions::const_iterator MECI;
-    for (MECI i = master.extensions.begin(); i != master.extensions.end(); ++i) {
-        if (name == i->first)
-            return Area(i->second.data(), i->second.size());
+    for (const auto & extension : master.extensions) {
+        if (name == extension.first)
+            return Area(extension.second.data(), extension.second.size());
     }
 
     return Area();
@@ -98,8 +98,8 @@ Adaptation::Ecap::ConfigRep::visitEachOption(libecap::NamedValueVisitor &visitor
 
     // visit adapter-specific options (i.e., those not recognized by Squid)
     typedef Master::Extensions::const_iterator MECI;
-    for (MECI i = master.extensions.begin(); i != master.extensions.end(); ++i)
-        visitor.visit(Name(i->first), Area::FromTempString(i->second));
+    for (const auto & extension : master.extensions)
+        visitor.visit(Name(extension.first), Area::FromTempString(extension.second));
 }
 
 /* Adaptation::Ecap::Engine */
@@ -144,8 +144,8 @@ Adaptation::Ecap::Engine::kickAsyncServices(timeval &timeout)
     }
 
     // Give services a chance to decrease the default timeout.
-    for (ASI s = AsyncServices.begin(); s != AsyncServices.end(); ++s) {
-        s->second->suspend(timeout);
+    for (auto & AsyncService : AsyncServices) {
+        AsyncService.second->suspend(timeout);
     }
 }
 
diff --git a/src/auth/Scheme.cc b/src/auth/Scheme.cc
index 8ac6959..ca46a45 100644
--- a/src/auth/Scheme.cc
+++ b/src/auth/Scheme.cc
@@ -32,9 +32,9 @@ Auth::Scheme::AddScheme(Auth::Scheme::Pointer instance)
 Auth::Scheme::Pointer
 Auth::Scheme::Find(const char *typestr)
 {
-    for (iterator i = GetSchemes().begin(); i != GetSchemes().end(); ++i) {
-        if (strcmp((*i)->type(), typestr) == 0)
-            return *i;
+    for (auto & i : GetSchemes()) {
+        if (strcmp(i->type(), typestr) == 0)
+            return i;
     }
 
     return Auth::Scheme::Pointer(NULL);
diff --git a/src/cf_gen.cc b/src/cf_gen.cc
index 0f76c0e..aea3410 100644
--- a/src/cf_gen.cc
+++ b/src/cf_gen.cc
@@ -139,10 +139,10 @@ static const char *gen_quote_escape(const std::string &var);
 static void
 checkDepend(const std::string &directive, const char *name, const TypeList &types, const EntryList &entries)
 {
-    for (TypeList::const_iterator t = types.begin(); t != types.end(); ++t) {
-        if (t->name.compare(name) != 0)
+    for (const auto & type : types) {
+        if (type.name.compare(name) != 0)
             continue;
-        for (TypeDepList::const_iterator dep = t->depend.begin(); dep != t->depend.end(); ++dep) {
+        for (TypeDepList::const_iterator dep = type.depend.begin(); dep != type.depend.end(); ++dep) {
             EntryList::const_iterator entry = entries.begin();
             for (; entry != entries.end(); ++entry) {
                 if (entry->name.compare(*dep) == 0)
@@ -615,9 +615,9 @@ Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
     fout << "        ";
     if (type.compare("obsolete") == 0) {
         fout << "debugs(0, DBG_CRITICAL, \"ERROR: Directive '" << aName << "' is obsolete.\");\n";
-        for (LineList::const_iterator l = doc.begin(); l != doc.end(); ++l) {
+        for (const auto & l : doc) {
             // offset line to strip initial whitespace tab byte
-            fout << "        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), \"" << aName << " : " << &(*l)[1] << "\");" << std::endl;
+            fout << "        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), \"" << aName << " : " << &l[1] << "\");" << std::endl;
         }
         fout << "        parse_obsolete(token);";
     } else if (!loc.size() || loc.compare("none") == 0) {
@@ -647,8 +647,8 @@ Entry::genParse(std::ostream &fout) const
     genParseAlias(name, fout);
 
     // All accepted aliases
-    for (EntryAliasList::const_iterator a = alias.begin(); a != alias.end(); ++a) {
-        genParseAlias(*a, fout);
+    for (const auto & alia : alias) {
+        genParseAlias(alia, fout);
     }
 }
 
@@ -664,8 +664,8 @@ gen_parse(const EntryList &head, std::ostream &fout)
          "\t\treturn 1;\t/* ignore empty lines */\n"
          "\tConfigParser::SetCfgLine(strtok(NULL, \"\"));\n";
 
-    for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e)
-        e->genParse(fout);
+    for (const auto & e : head)
+        e.genParse(fout);
 
     fout << "\treturn 0; /* failure */\n"
          "}\n\n";
@@ -681,20 +681,20 @@ gen_dump(const EntryList &head, std::ostream &fout)
          "{" << std::endl <<
          "    debugs(5, 4, HERE);" << std::endl;
 
-    for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e) {
+    for (const auto & e : head) {
 
-        if (!e->loc.size() || e->loc.compare("none") == 0)
+        if (!e.loc.size() || e.loc.compare("none") == 0)
             continue;
 
-        if (e->name.compare("comment") == 0)
+        if (e.name.compare("comment") == 0)
             continue;
 
-        if (e->ifdef.size())
-            fout << "#if " << e->ifdef << std::endl;
+        if (e.ifdef.size())
+            fout << "#if " << e.ifdef << std::endl;
 
-        fout << "    dump_" << e->type << "(entry, \"" << e->name << "\", " << e->loc << ");" << std::endl;
+        fout << "    dump_" << e.type << "(entry, \"" << e.name << "\", " << e.loc << ");" << std::endl;
 
-        if (e->ifdef.size())
+        if (e.ifdef.size())
             fout << "#endif" << std::endl;
     }
 
@@ -710,19 +710,19 @@ gen_free(const EntryList &head, std::ostream &fout)
          "{" << std::endl <<
          "    debugs(5, 4, HERE);" << std::endl;
 
-    for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e) {
-        if (!e->loc.size() || e->loc.compare("none") == 0)
+    for (const auto & e : head) {
+        if (!e.loc.size() || e.loc.compare("none") == 0)
             continue;
 
-        if (e->name.compare("comment") == 0)
+        if (e.name.compare("comment") == 0)
             continue;
 
-        if (e->ifdef.size())
-            fout << "#if " << e->ifdef << std::endl;
+        if (e.ifdef.size())
+            fout << "#if " << e.ifdef << std::endl;
 
-        fout << "    free_" << e->type << "(&" << e->loc << (e->array_flag ? "[0]" : "") << ");" << std::endl;
+        fout << "    free_" << e.type << "(&" << e.loc << (e.array_flag ? "[0]" : "") << ");" << std::endl;
 
-        if (e->ifdef.size())
+        if (e.ifdef.size())
             fout << "#endif" << std::endl;
     }
 
@@ -759,63 +759,63 @@ available_if(const std::string &name)
 static void
 gen_conf(const EntryList &head, std::ostream &fout, bool verbose_output)
 {
-    for (EntryList::const_iterator entry = head.begin(); entry != head.end(); ++entry) {
+    for (const auto & entry : head) {
         char buf[8192];
         LineList def;
         int enabled = 1;
 
         // Display TAG: line
-        if (!entry->name.compare("comment"))
+        if (!entry.name.compare("comment"))
             (void) 0;
-        else if (!entry->name.compare("obsolete"))
+        else if (!entry.name.compare("obsolete"))
             (void) 0;
         else if (verbose_output) {
-            fout << "#  TAG: " << entry->name;
+            fout << "#  TAG: " << entry.name;
 
-            if (entry->comment.size())
-                fout << "\t" << entry->comment;
+            if (entry.comment.size())
+                fout << "\t" << entry.comment;
 
             fout << std::endl;
         }
 
         // Display --enable/--disable disclaimer
-        if (!isDefined(entry->ifdef)) {
+        if (!isDefined(entry.ifdef)) {
             if (verbose_output) {
                 fout << "# Note: This option is only available if Squid is rebuilt with the" << std::endl <<
-                     "#       " << available_if(entry->ifdef) << std::endl <<
+                     "#       " << available_if(entry.ifdef) << std::endl <<
                      "#" << std::endl;
             }
             enabled = 0;
         }
 
         // Display DOC_START section
-        if (verbose_output && entry->doc.size()) {
-            for (LineList::const_iterator line = entry->doc.begin(); line != entry->doc.end(); ++line) {
+        if (verbose_output && entry.doc.size()) {
+            for (LineList::const_iterator line = entry.doc.begin(); line != entry.doc.end(); ++line) {
                 fout << "#" << *line << std::endl;
             }
         }
 
-        if (entry->defaults.docs.size()) {
+        if (entry.defaults.docs.size()) {
             // Display the DEFAULT_DOC line(s)
-            def = entry->defaults.docs;
+            def = entry.defaults.docs;
         } else {
-            if (entry->defaults.preset.size() && entry->defaults.preset.front().compare("none") != 0) {
+            if (entry.defaults.preset.size() && entry.defaults.preset.front().compare("none") != 0) {
                 // Display DEFAULT: line(s)
-                for (LineList::const_iterator l = entry->defaults.preset.begin(); l != entry->defaults.preset.end(); ++l) {
-                    snprintf(buf, sizeof(buf), "%s %s", entry->name.c_str(), l->c_str());
+                for (LineList::const_iterator l = entry.defaults.preset.begin(); l != entry.defaults.preset.end(); ++l) {
+                    snprintf(buf, sizeof(buf), "%s %s", entry.name.c_str(), l->c_str());
                     def.push_back(buf);
                 }
-            } else if (entry->defaults.if_none.size()) {
+            } else if (entry.defaults.if_none.size()) {
                 // Display DEFAULT_IF_NONE: line(s)
-                for (LineList::const_iterator l = entry->defaults.if_none.begin(); l != entry->defaults.if_none.end(); ++l) {
-                    snprintf(buf, sizeof(buf), "%s %s", entry->name.c_str(), l->c_str());
+                for (LineList::const_iterator l = entry.defaults.if_none.begin(); l != entry.defaults.if_none.end(); ++l) {
+                    snprintf(buf, sizeof(buf), "%s %s", entry.name.c_str(), l->c_str());
                     def.push_back(buf);
                 }
             }
         }
 
         // Display "none" if no default is set or comments to display
-        if (def.empty() && entry->nocomment.empty() && entry->name.compare("comment") != 0)
+        if (def.empty() && entry.nocomment.empty() && entry.name.compare("comment") != 0)
             def.push_back("none");
 
         if (verbose_output && def.size()) {
@@ -824,22 +824,22 @@ gen_conf(const EntryList &head, std::ostream &fout, bool verbose_output)
                 fout << "# " << def.front() << std::endl;
                 def.pop_front();
             }
-            if (entry->doc.empty() && entry->nocomment.empty())
+            if (entry.doc.empty() && entry.nocomment.empty())
                 fout << std::endl;
         }
 
-        if (verbose_output && entry->nocomment.size())
+        if (verbose_output && entry.nocomment.size())
             fout << "#" << std::endl;
 
         if (enabled || verbose_output) {
-            for (LineList::const_iterator line = entry->nocomment.begin(); line != entry->nocomment.end(); ++line) {
+            for (LineList::const_iterator line = entry.nocomment.begin(); line != entry.nocomment.end(); ++line) {
                 if (!enabled && line->at(0) != '#')
                     fout << "#";
                 fout << *line << std::endl;
             }
         }
 
-        if (verbose_output && entry->doc.size()) {
+        if (verbose_output && entry.doc.size()) {
             fout << std::endl;
         }
     }
@@ -851,13 +851,13 @@ gen_quote_escape(const std::string &var)
     static std::string esc;
     esc.clear();
 
-    for (int i = 0; i < var.length(); ++i) {
-        switch (var[i]) {
+    for (char i : var) {
+        switch (i) {
         case '"':
         case '\\':
             esc += '\\';
         default:
-            esc += var[i];
+            esc += i;
         }
     }
 
diff --git a/src/ip/QosConfig.cc b/src/ip/QosConfig.cc
index d84de2a..452d0d6 100644
--- a/src/ip/QosConfig.cc
+++ b/src/ip/QosConfig.cc
@@ -531,12 +531,12 @@ Ip::Qos::Config::isAclNfmarkActive() const
 {
     acl_nfmark * nfmarkAcls [] = { nfmarkToServer, nfmarkToClient };
 
-    for (int i=0; i<2; ++i) {
-        while (nfmarkAcls[i]) {
-            acl_nfmark *l = nfmarkAcls[i];
+    for (auto & nfmarkAcl : nfmarkAcls) {
+        while (nfmarkAcl) {
+            acl_nfmark *l = nfmarkAcl;
             if (l->nfmark > 0)
                 return true;
-            nfmarkAcls[i] = l->next;
+            nfmarkAcl = l->next;
         }
     }
 
@@ -548,12 +548,12 @@ Ip::Qos::Config::isAclTosActive() const
 {
     acl_tos * tosAcls [] = { tosToServer, tosToClient };
 
-    for (int i=0; i<2; ++i) {
-        while (tosAcls[i]) {
-            acl_tos *l = tosAcls[i];
+    for (auto & tosAcl : tosAcls) {
+        while (tosAcl) {
+            acl_tos *l = tosAcl;
             if (l->tos > 0)
                 return true;
-            tosAcls[i] = l->next;
+            tosAcl = l->next;
         }
     }
 
diff --git a/src/ipc/Coordinator.cc b/src/ipc/Coordinator.cc
index fc913b1..92be181 100644
--- a/src/ipc/Coordinator.cc
+++ b/src/ipc/Coordinator.cc
@@ -43,10 +43,9 @@ void Ipc::Coordinator::start()
 
 Ipc::StrandCoord* Ipc::Coordinator::findStrand(int kidId)
 {
-    typedef StrandCoords::iterator SI;
-    for (SI iter = strands_.begin(); iter != strands_.end(); ++iter) {
-        if (iter->kidId == kidId)
-            return &(*iter);
+    for (auto & strand : strands_) {
+        if (strand.kidId == kidId)
+            return &strand;
     }
     return NULL;
 }
diff --git a/src/ipc/Kids.cc b/src/ipc/Kids.cc
index 7cb5704..7b61765 100644
--- a/src/ipc/Kids.cc
+++ b/src/ipc/Kids.cc
@@ -58,9 +58,9 @@ Kid* Kids::find(pid_t pid)
     assert(pid > 0);
     assert(count() > 0);
 
-    for (size_t i = 0; i < storage.size(); ++i) {
-        if (storage[i].getPid() == pid)
-            return &storage[i];
+    for (auto & i : storage) {
+        if (i.getPid() == pid)
+            return &i;
     }
     return NULL;
 }
@@ -75,8 +75,8 @@ Kid& Kids::get(size_t i)
 /// whether all kids are hopeless
 bool Kids::allHopeless() const
 {
-    for (size_t i = 0; i < storage.size(); ++i) {
-        if (!storage[i].hopeless())
+    for (const auto & i : storage) {
+        if (!i.hopeless())
             return false;
     }
     return true;
@@ -85,8 +85,8 @@ bool Kids::allHopeless() const
 /// whether all kids called exited happy
 bool Kids::allExitedHappy() const
 {
-    for (size_t i = 0; i < storage.size(); ++i) {
-        if (!storage[i].exitedHappy())
+    for (const auto & i : storage) {
+        if (!i.exitedHappy())
             return false;
     }
     return true;
@@ -95,8 +95,8 @@ bool Kids::allExitedHappy() const
 /// whether some kids died from a given signal
 bool Kids::someSignaled(const int sgnl) const
 {
-    for (size_t i = 0; i < storage.size(); ++i) {
-        if (storage[i].signaled(sgnl))
+    for (const auto & i : storage) {
+        if (i.signaled(sgnl))
             return true;
     }
     return false;
@@ -105,8 +105,8 @@ bool Kids::someSignaled(const int sgnl) const
 /// whether some kids are running
 bool Kids::someRunning() const
 {
-    for (size_t i = 0; i < storage.size(); ++i) {
-        if (storage[i].running())
+    for (const auto & i : storage) {
+        if (i.running())
             return true;
     }
     return false;
@@ -115,8 +115,8 @@ bool Kids::someRunning() const
 /// whether some kids should be restarted by master
 bool Kids::shouldRestartSome() const
 {
-    for (size_t i = 0; i < storage.size(); ++i) {
-        if (storage[i].shouldRestart())
+    for (const auto & i : storage) {
+        if (i.shouldRestart())
             return true;
     }
     return false;
diff --git a/src/mgr/BasicActions.cc b/src/mgr/BasicActions.cc
index 3ab1bbd..992739e 100644
--- a/src/mgr/BasicActions.cc
+++ b/src/mgr/BasicActions.cc
@@ -53,13 +53,12 @@ Mgr::MenuAction::dump(StoreEntry* entry)
     debugs(16, 5, HERE);
     Must(entry != NULL);
 
-    typedef CacheManager::Menu::const_iterator Iterator;
     const CacheManager::Menu& menu = CacheManager::GetInstance()->menu();
 
-    for (Iterator a = menu.begin(); a != menu.end(); ++a) {
+    for (const auto & a : menu) {
         storeAppendPrintf(entry, " %-22s\t%-32s\t%s\n",
-                          (*a)->name, (*a)->desc,
-                          CacheManager::GetInstance()->ActionProtection(*a));
+                          a->name, a->desc,
+                          CacheManager::GetInstance()->ActionProtection(a));
     }
 }
 
diff --git a/src/mgr/Inquirer.cc b/src/mgr/Inquirer.cc
index 85212b1..2939c71 100644
--- a/src/mgr/Inquirer.cc
+++ b/src/mgr/Inquirer.cc
@@ -152,10 +152,9 @@ Mgr::Inquirer::applyQueryParams(const Ipc::StrandCoords& aStrands, const QueryPa
             IntParam* param = dynamic_cast<IntParam*>(processesParam.getRaw());
             if (param != NULL && param->type == QueryParam::ptInt) {
                 const std::vector<int>& processes = param->value();
-                for (Ipc::StrandCoords::const_iterator iter = aStrands.begin();
-                        iter != aStrands.end(); ++iter) {
-                    if (std::find(processes.begin(), processes.end(), iter->kidId) != processes.end())
-                        sc.push_back(*iter);
+                for (const auto & aStrand : aStrands) {
+                    if (std::find(processes.begin(), processes.end(), aStrand.kidId) != processes.end())
+                        sc.push_back(aStrand);
                 }
             }
         } else if (workersParam != NULL) {
diff --git a/src/mgr/IntParam.cc b/src/mgr/IntParam.cc
index 8e0adfd..28acf5e 100644
--- a/src/mgr/IntParam.cc
+++ b/src/mgr/IntParam.cc
@@ -28,9 +28,8 @@ Mgr::IntParam::pack(Ipc::TypedMsgHdr& msg) const
 {
     msg.putPod(type);
     msg.putInt(array.size());
-    typedef std::vector<int>::const_iterator Iterator;
-    for (Iterator iter = array.begin(); iter != array.end(); ++iter)
-        msg.putInt(*iter);
+    for (int e : array)
+        msg.putInt(e);
 }
 
 void
diff --git a/src/peer_select.cc b/src/peer_select.cc
index 807d43a..72044f6 100644
--- a/src/peer_select.cc
+++ b/src/peer_select.cc
@@ -278,15 +278,15 @@ peerSelectDnsPaths(ps_state *psstate)
     debugs(44, 2, "  always_direct = " << psstate->always_direct);
     debugs(44, 2, "   never_direct = " << psstate->never_direct);
     if (psstate->paths) {
-        for (size_t i = 0; i < psstate->paths->size(); ++i) {
-            if ((*psstate->paths)[i]->peerType == HIER_DIRECT)
-                debugs(44, 2, "         DIRECT = " << (*psstate->paths)[i]);
-            else if ((*psstate->paths)[i]->peerType == ORIGINAL_DST)
-                debugs(44, 2, "   ORIGINAL_DST = " << (*psstate->paths)[i]);
-            else if ((*psstate->paths)[i]->peerType == PINNED)
-                debugs(44, 2, "         PINNED = " << (*psstate->paths)[i]);
+        for (auto & path : *psstate->paths) {
+            if (path->peerType == HIER_DIRECT)
+                debugs(44, 2, "         DIRECT = " << path);
+            else if (path->peerType == ORIGINAL_DST)
+                debugs(44, 2, "   ORIGINAL_DST = " << path);
+            else if (path->peerType == PINNED)
+                debugs(44, 2, "         PINNED = " << path);
             else
-                debugs(44, 2, "     cache_peer = " << (*psstate->paths)[i]);
+                debugs(44, 2, "     cache_peer = " << path);
         }
     }
     debugs(44, 2, "       timedout = " << psstate->ping.timedout);
diff --git a/src/ssl/cert_validate_message.cc b/src/ssl/cert_validate_message.cc
index 74d9840..e4b32a2 100644
--- a/src/ssl/cert_validate_message.cc
+++ b/src/ssl/cert_validate_message.cc
@@ -173,10 +173,9 @@ Ssl::CertValidationMsg::parseResponse(CertValidationResponse &resp, STACK_OF(X50
 X509 *
 Ssl::CertValidationMsg::getCertByName(std::vector<CertItem> const &certs, std::string const & name)
 {
-    typedef std::vector<CertItem>::const_iterator SVCI;
-    for (SVCI ci = certs.begin(); ci != certs.end(); ++ci) {
-        if (ci->name.compare(name) == 0)
-            return ci->cert.get();
+    for (const auto & cert : certs) {
+        if (cert.name.compare(name) == 0)
+            return cert.cert.get();
     }
     return NULL;
 }
@@ -184,10 +183,9 @@ Ssl::CertValidationMsg::getCertByName(std::vector<CertItem> const &certs, std::s
 Ssl::CertValidationResponse::RecvdError &
 Ssl::CertValidationResponse::getError(int errorId)
 {
-    typedef Ssl::CertValidationResponse::RecvdErrors::iterator SVCREI;
-    for (SVCREI i = errors.begin(); i != errors.end(); ++i) {
-        if (i->id == errorId)
-            return *i;
+    for (auto & error : errors) {
+        if (error.id == errorId)
+            return error;
     }
     Ssl::CertValidationResponse::RecvdError errItem;
     errItem.id = errorId;
diff --git a/src/ssl/context_storage.cc b/src/ssl/context_storage.cc
index 68c80e6..13b36a1 100644
--- a/src/ssl/context_storage.cc
+++ b/src/ssl/context_storage.cc
@@ -38,9 +38,9 @@ void Ssl::CertificateStorageAction::dump (StoreEntry *sentry)
     stream << "Port" << delimiter << "Max mem(KB)" << delimiter << "Cert number" << delimiter << "KB/cert" << delimiter << "Mem used(KB)" << delimiter << "Mem free(KB)" << endString;
 
     // Add info for each port.
-    for (std::map<Ip::Address, LocalContextStorage *>::iterator i = TheGlobalContextStorage.storage.begin(); i != TheGlobalContextStorage.storage.end(); ++i) {
-        stream << i->first << delimiter;
-        LocalContextStorage & ssl_store_policy(*(i->second));
+    for (auto & i : TheGlobalContextStorage.storage) {
+        stream << i.first << delimiter;
+        LocalContextStorage & ssl_store_policy(*(i.second));
         stream << ssl_store_policy.memLimit() / 1024 << delimiter;
         stream << ssl_store_policy.entries() << delimiter;
         stream << SSL_CTX_SIZE / 1024 << delimiter;
@@ -61,8 +61,8 @@ Ssl::GlobalContextStorage::GlobalContextStorage()
 
 Ssl::GlobalContextStorage::~GlobalContextStorage()
 {
-    for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); ++i) {
-        delete i->second;
+    for (auto & i : storage) {
+        delete i.second;
     }
 }
 
@@ -107,9 +107,9 @@ void Ssl::GlobalContextStorage::reconfigureFinish()
         }
 
         // add new local storages.
-        for (std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.begin(); conf_i != configureStorage.end(); ++conf_i ) {
-            if (storage.find(conf_i->first) == storage.end() && conf_i->second > 0) {
-                storage.insert(std::pair<Ip::Address, LocalContextStorage *>(conf_i->first, new LocalContextStorage(-1, conf_i->second)));
+        for (auto & conf_i : configureStorage) {
+            if (storage.find(conf_i.first) == storage.end() && conf_i.second > 0) {
+                storage.insert(std::pair<Ip::Address, LocalContextStorage *>(conf_i.first, new LocalContextStorage(-1, conf_i.second)));
             }
         }
     }
diff --git a/src/ssl/support.cc b/src/ssl/support.cc
index 12d0cc1..6a525b0 100644
--- a/src/ssl/support.cc
+++ b/src/ssl/support.cc
@@ -1127,8 +1127,8 @@ findCertIssuerFast(Ssl::CertsIndexedList &list, X509 *cert)
 static bool
 findCertIssuer(Security::CertList const &list, X509 *cert)
 {
-    for (Security::CertList::const_iterator it = list.begin(); it != list.end(); ++it) {
-        if (X509_check_issued(it->get(), cert) == X509_V_OK)
+    for (const auto & it : list) {
+        if (X509_check_issued(it.get(), cert) == X509_V_OK)
             return true;
     }
     return false;
@@ -1285,8 +1285,8 @@ void
 Ssl::unloadSquidUntrusted()
 {
     if (SquidUntrustedCerts.size()) {
-        for (Ssl::CertsIndexedList::iterator it = SquidUntrustedCerts.begin(); it != SquidUntrustedCerts.end(); ++it) {
-            X509_free(it->second);
+        for (auto & SquidUntrustedCert : SquidUntrustedCerts) {
+            X509_free(SquidUntrustedCert.second);
         }
         SquidUntrustedCerts.clear();
     }
