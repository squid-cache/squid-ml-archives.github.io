diff --git a/src/adaptation/AccessCheck.cc b/src/adaptation/AccessCheck.cc
index 6ce6d91..ddf88f8 100644
--- a/src/adaptation/AccessCheck.cc
+++ b/src/adaptation/AccessCheck.cc
@@ -47,11 +47,11 @@ Adaptation::AccessCheck::AccessCheck(const ServiceFilter &aFilter,
                                      Adaptation::Initiator *initiator):
     AsyncJob("AccessCheck"), filter(aFilter),
     theInitiator(initiator),
-    acl_checklist(NULL)
+    acl_checklist(nullptr)
 {
 #if ICAP_CLIENT
     Adaptation::Icap::History::Pointer h = filter.request->icapHistory();
-    if (h != NULL)
+    if (h != nullptr)
         h->start("ACL");
 #endif
 
@@ -63,7 +63,7 @@ Adaptation::AccessCheck::~AccessCheck()
 {
 #if ICAP_CLIENT
     Adaptation::Icap::History::Pointer h = filter.request->icapHistory();
-    if (h != NULL)
+    if (h != nullptr)
         h->stop("ACL");
 #endif
 }
@@ -105,12 +105,10 @@ Adaptation::AccessCheck::check()
 {
     debugs(93, 4, HERE << "start checking");
 
-    typedef AccessRules::iterator ARI;
-    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        AccessRule *r = *i;
-        if (isCandidate(*r)) {
-            debugs(93, 5, HERE << "check: rule '" << r->id << "' is a candidate");
-            candidates.push_back(r->id);
+    for (auto rule_ptr : AllRules()) {
+        if (isCandidate(*rule_ptr)) {
+            debugs(93, 5, HERE << "check: rule '" << rule_ptr->id << "' is a candidate");
+            candidates.push_back(rule_ptr->id);
         }
     }
 
@@ -143,7 +141,7 @@ Adaptation::AccessCheck::checkCandidates()
     }
 
     debugs(93, 4, HERE << "NO candidates left");
-    callBack(NULL);
+    callBack(nullptr);
     Must(done());
 }
 
@@ -151,7 +149,7 @@ void
 Adaptation::AccessCheck::AccessCheckCallbackWrapper(allow_t answer, void *data)
 {
     debugs(93, 8, HERE << "callback answer=" << answer);
-    AccessCheck *ac = (AccessCheck*)data;
+    auto *ac = (AccessCheck*)data;
 
     /** \todo AYJ 2008-06-12: If answer == ACCESS_AUTH_REQUIRED
      * we should be kicking off an authentication before continuing
@@ -176,7 +174,7 @@ Adaptation::AccessCheck::noteAnswer(allow_t answer)
 
     if (answer == ACCESS_ALLOWED) { // the rule matched
         ServiceGroupPointer g = topGroup();
-        if (g != NULL) { // the corresponding group found
+        if (g != nullptr) { // the corresponding group found
             callBack(g);
             Must(done());
             return;
diff --git a/src/adaptation/AccessRule.cc b/src/adaptation/AccessRule.cc
index 2378d57..2baa59a 100644
--- a/src/adaptation/AccessRule.cc
+++ b/src/adaptation/AccessRule.cc
@@ -17,7 +17,7 @@
 
 int Adaptation::AccessRule::LastId = 0;
 
-Adaptation::AccessRule::AccessRule(const String &aGroupId): id(++LastId), groupId(aGroupId), acl(NULL)
+Adaptation::AccessRule::AccessRule(const String &aGroupId): id(++LastId), groupId(aGroupId), acl(nullptr)
 {
 }
 
@@ -38,7 +38,7 @@ Adaptation::AccessRule::finalize()
     if (!group()) { // no explicit group
         debugs(93,7, HERE << "no service group: " << groupId);
         // try to add a one-service group
-        if (FindService(groupId) != NULL) {
+        if (FindService(groupId) != nullptr) {
             ServiceGroupPointer g = new SingleService(groupId);
             g->finalize(); // explicit groups were finalized before rules
             AllGroups().push_back(g);
@@ -60,7 +60,7 @@ Adaptation::AccessRule::group()
 Adaptation::AccessRules &
 Adaptation::AllRules()
 {
-    static AccessRules *TheRules = new AccessRules;
+    static auto *TheRules = new AccessRules;
     return *TheRules;
 }
 
@@ -68,24 +68,22 @@ Adaptation::AllRules()
 Adaptation::AccessRule *
 Adaptation::FindRule(const AccessRule::Id &id)
 {
-    typedef AccessRules::iterator ARI;
-    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        if ((*i)->id == id)
-            return *i;
+    for (const auto & rule_ptr : AllRules()) {
+        if (rule_ptr->id == id)
+            return rule_ptr;
     }
 
-    return NULL;
+    return nullptr;
 }
 
 Adaptation::AccessRule *
 Adaptation::FindRuleByGroupId(const String &groupId)
 {
-    typedef AccessRules::iterator ARI;
-    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        if ((*i)->groupId == groupId)
-            return *i;
+    for (const auto & rule_ptr : AllRules()) {
+        if (rule_ptr->groupId == groupId)
+            return rule_ptr;
     }
 
-    return NULL;
+    return nullptr;
 }
 
diff --git a/src/adaptation/Config.cc b/src/adaptation/Config.cc
index 536b5a3..6795b98 100644
--- a/src/adaptation/Config.cc
+++ b/src/adaptation/Config.cc
@@ -23,7 +23,7 @@
 #include <algorithm>
 
 bool Adaptation::Config::Enabled = false;
-char *Adaptation::Config::masterx_shared_name = NULL;
+char *Adaptation::Config::masterx_shared_name = nullptr;
 int Adaptation::Config::service_iteration_limit = 16;
 int Adaptation::Config::send_client_ip = false;
 int Adaptation::Config::send_username = false;
@@ -43,7 +43,7 @@ const char *metasBlacklist[] = {
     "Transfer-Preview",
     "Transfer-Ignore",
     "Transfer-Complete",
-    NULL
+    nullptr
 };
 Notes Adaptation::Config::metaHeaders("ICAP header", metasBlacklist);
 bool Adaptation::Config::needHistory = false;
@@ -62,9 +62,8 @@ Adaptation::Config::removeService(const String& service)
     for (unsigned int i = 0; i < groups.size(); ) {
         const ServiceGroupPointer group = groups[i];
         const ServiceGroup::Store& services = group->services;
-        typedef ServiceGroup::Store::const_iterator SGSI;
-        for (SGSI it = services.begin(); it != services.end(); ++it) {
-            if (*it == service) {
+        for (const auto & currentService : services) {
+            if (currentService == service) {
                 group->removedServices.push_back(service);
                 ServiceGroup::Store::iterator newend;
                 newend = std::remove(group->services.begin(), group->services.end(), service);
@@ -88,22 +87,19 @@ Adaptation::Config::removeService(const String& service)
 Adaptation::ServiceConfigPointer
 Adaptation::Config::findServiceConfig(const String &service)
 {
-    typedef ServiceConfigs::const_iterator SCI;
     const ServiceConfigs& configs = serviceConfigs;
-    for (SCI cfg = configs.begin(); cfg != configs.end(); ++cfg) {
-        if ((*cfg)->key == service)
-            return *cfg;
+    for (const auto & config : configs) {
+        if (config->key == service)
+            return config;
     }
-    return NULL;
+    return nullptr;
 }
 
 void
 Adaptation::Config::removeRule(const String& id)
 {
-    typedef AccessRules::const_iterator ARI;
     const AccessRules& rules = AllRules();
-    for (ARI it = rules.begin(); it != rules.end(); ++it) {
-        AccessRule* rule = *it;
+    for (auto rule : rules) {
         if (rule->groupId == id) {
             debugs(93, 5, "removing access rules for:" << id);
             AccessRules::iterator newend;
@@ -120,10 +116,9 @@ Adaptation::Config::clear()
 {
     debugs(93, 3, HERE << "rules: " << AllRules().size() << ", groups: " <<
            AllGroups().size() << ", services: " << serviceConfigs.size());
-    typedef ServiceConfigs::const_iterator SCI;
     const ServiceConfigs& configs = serviceConfigs;
-    for (SCI cfg = configs.begin(); cfg != configs.end(); ++cfg)
-        removeService((*cfg)->key);
+    for (const auto & config : configs)
+        removeService(config->key);
     serviceConfigs.clear();
     debugs(93, 3, HERE << "rules: " << AllRules().size() << ", groups: " <<
            AllGroups().size() << ", services: " << serviceConfigs.size());
@@ -154,9 +149,8 @@ Adaptation::Config::freeService()
 void
 Adaptation::Config::dumpService(StoreEntry *entry, const char *name) const
 {
-    typedef Services::iterator SCI;
-    for (SCI i = AllServices().begin(); i != AllServices().end(); ++i) {
-        const ServiceConfig &cfg = (*i)->cfg();
+    for (const auto & service : AllServices()) {
+        const ServiceConfig &cfg = service->cfg();
         bool isEcap = cfg.protocol.caseCmp("ecap") == 0;
         bool isIcap = !isEcap;
         const char *optConnectionEncryption = "";
@@ -189,17 +183,15 @@ Adaptation::Config::finalize()
     // create service reps from service configs
     int created = 0;
 
-    typedef ServiceConfigs::const_iterator VISCI;
     const ServiceConfigs &configs = serviceConfigs;
-    for (VISCI i = configs.begin(); i != configs.end(); ++i) {
-        const ServiceConfigPointer cfg = *i;
-        if (FindService(cfg->key) != NULL) {
+    for (auto cfg : configs) {
+        if (FindService(cfg->key) != nullptr) {
             debugs(93, DBG_CRITICAL, "ERROR: Duplicate adaptation service name: " <<
                    cfg->key);
             continue; // TODO: make fatal
         }
         ServicePointer s = createService(cfg);
-        if (s != NULL) {
+        if (s != nullptr) {
             AllServices().push_back(s);
             ++created;
         }
@@ -217,8 +209,7 @@ template <class Collection>
 static void
 FinalizeEach(Collection &collection, const char *label)
 {
-    typedef typename Collection::iterator CI;
-    for (CI i = collection.begin(); i != collection.end(); ++i)
+    for (auto i = collection.begin(); i != collection.end(); ++i)
         (*i)->finalize();
 
     debugs(93,2, HERE << "Initialized " << collection.size() << ' ' << label);
@@ -250,7 +241,7 @@ Adaptation::Config::ParseServiceChain()
 void
 Adaptation::Config::ParseServiceGroup(ServiceGroupPointer g)
 {
-    assert(g != NULL);
+    assert(g != nullptr);
     g->parse();
     AllGroups().push_back(g);
 }
@@ -267,9 +258,8 @@ Adaptation::Config::FreeServiceGroups()
 void
 Adaptation::Config::DumpServiceGroups(StoreEntry *entry, const char *name)
 {
-    typedef Groups::iterator GI;
-    for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i)
-        storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "\n", name, SQUIDSTRINGPRINT((*i)->id));
+    for (const auto & group : AllGroups())
+        storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "\n", name, SQUIDSTRINGPRINT(group->id));
 }
 
 void
@@ -298,10 +288,9 @@ Adaptation::Config::DumpAccess(StoreEntry *entry, const char *name)
 {
     LOCAL_ARRAY(char, nom, 64);
 
-    typedef AccessRules::iterator CI;
-    for (CI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        snprintf(nom, 64, "%s " SQUIDSTRINGPH, name, SQUIDSTRINGPRINT((*i)->groupId));
-        dump_acl_access(entry, nom, (*i)->acl);
+    for (const auto & rule : AllRules()) {
+        snprintf(nom, 64, "%s " SQUIDSTRINGPH, name, SQUIDSTRINGPRINT(rule->groupId));
+        dump_acl_access(entry, nom, rule->acl);
     }
 }
 
diff --git a/src/adaptation/Initiate.cc b/src/adaptation/Initiate.cc
index 10df0ce..6aa986d 100644
--- a/src/adaptation/Initiate.cc
+++ b/src/adaptation/Initiate.cc
@@ -30,7 +30,7 @@ public:
         AsyncCallT<AnswerDialer>::fire();
     }
     virtual ~AnswerCall() {
-        if (!fired && dialer.arg1.message != NULL && dialer.arg1.message->body_pipe != NULL)
+        if (!fired && dialer.arg1.message != nullptr && dialer.arg1.message->body_pipe != nullptr)
             dialer.arg1.message->body_pipe->expectNoConsumption();
     }
 
diff --git a/src/adaptation/Iterator.cc b/src/adaptation/Iterator.cc
index 3c37879..f775b8d 100644
--- a/src/adaptation/Iterator.cc
+++ b/src/adaptation/Iterator.cc
@@ -29,14 +29,14 @@ Adaptation::Iterator::Iterator(
     theMsg(aMsg),
     theCause(aCause),
     al(alp),
-    theLauncher(0),
+    theLauncher(nullptr),
     iterations(0),
     adapted(false)
 {
-    if (theCause != NULL)
+    if (theCause != nullptr)
         HTTPMSGLOCK(theCause);
 
-    if (theMsg != NULL)
+    if (theMsg != nullptr)
         HTTPMSGLOCK(theMsg);
 }
 
@@ -56,7 +56,7 @@ void Adaptation::Iterator::start()
     // Add adaptation group name once and now, before
     // dynamic groups change it at step() time.
     if (Adaptation::Config::needHistory && !thePlan.exhausted() && (dynamic_cast<ServiceSet *>(theGroup.getRaw()) || dynamic_cast<ServiceChain *>(theGroup.getRaw()))) {
-        HttpRequest *request = dynamic_cast<HttpRequest*>(theMsg);
+        auto *request = dynamic_cast<HttpRequest*>(theMsg);
         if (!request)
             request = theCause;
         Must(request);
@@ -81,7 +81,7 @@ void Adaptation::Iterator::step()
         return;
     }
 
-    HttpRequest *request = dynamic_cast<HttpRequest*>(theMsg);
+    auto *request = dynamic_cast<HttpRequest*>(theMsg);
     if (!request)
         request = theCause;
     assert(request);
@@ -96,7 +96,7 @@ void Adaptation::Iterator::step()
     }
 
     ServicePointer service = thePlan.current();
-    Must(service != NULL);
+    Must(service != nullptr);
     debugs(93,5, HERE << "using adaptation service: " << service->cfg().key);
 
     if (Adaptation::Config::needHistory) {
@@ -135,10 +135,10 @@ Adaptation::Iterator::handleAdaptedHeader(Http::Message *aMsg)
     // set theCause if we switched to request satisfaction mode
     if (!theCause) { // probably sent a request message
         if (dynamic_cast<HttpReply*>(aMsg)) { // we got a response message
-            if (HttpRequest *cause = dynamic_cast<HttpRequest*>(theMsg)) {
+            if (auto *cause = dynamic_cast<HttpRequest*>(theMsg)) {
                 // definately sent request, now use it as the cause
                 theCause = cause; // moving the lock
-                theMsg = 0;
+                theMsg = nullptr;
                 debugs(93,3, HERE << "in request satisfaction mode");
             }
         }
@@ -187,7 +187,7 @@ void Adaptation::Iterator::handleAdaptationError(bool final)
     debugs(85,5, HERE << "flags: " << srcIntact << canIgnore << adapted);
 
     if (srcIntact) {
-        if (thePlan.replacement(filter()) != NULL) {
+        if (thePlan.replacement(filter()) != nullptr) {
             debugs(93,3, HERE << "trying a replacement service");
             step();
             return;
@@ -268,14 +268,14 @@ Adaptation::ServiceFilter Adaptation::Iterator::filter() const
     // the method may differ from theGroup->method due to request satisfaction
     Method method = methodNone;
     // temporary variables, no locking needed
-    HttpRequest *req = NULL;
-    HttpReply *rep = NULL;
+    HttpRequest *req = nullptr;
+    HttpReply *rep = nullptr;
 
-    if (HttpRequest *r = dynamic_cast<HttpRequest*>(theMsg)) {
+    if (auto *r = dynamic_cast<HttpRequest*>(theMsg)) {
         method = methodReqmod;
         req = r;
-        rep = NULL;
-    } else if (HttpReply *theReply = dynamic_cast<HttpReply*>(theMsg)) {
+        rep = nullptr;
+    } else if (auto *theReply = dynamic_cast<HttpReply*>(theMsg)) {
         method = methodRespmod;
         req = theCause;
         rep = theReply;
diff --git a/src/adaptation/Message.cc b/src/adaptation/Message.cc
index 1e7791d..3c7632e 100644
--- a/src/adaptation/Message.cc
+++ b/src/adaptation/Message.cc
@@ -14,11 +14,11 @@
 #include "BodyPipe.h"
 #include "http/Message.h"
 
-Adaptation::Message::Message(): header(NULL)
+Adaptation::Message::Message(): header(nullptr)
 {
 }
 
-Adaptation::Message::Message(Header *aHeader): header(NULL)
+Adaptation::Message::Message(Header *aHeader): header(nullptr)
 {
     set(aHeader);
 }
@@ -32,7 +32,7 @@ void
 Adaptation::Message::clear()
 {
     HTTPMSGUNLOCK(header);
-    body_pipe = NULL;
+    body_pipe = nullptr;
 }
 
 void
@@ -53,7 +53,7 @@ Adaptation::Message::ShortCircuit(Message &src, Message &dest)
     Must(!dest.body_pipe); // can relax if needed, but need !body_pipe->used()
     Must(src.header); // or there is nothing to shortcircuit
 
-    if (src.header->body_pipe != NULL) {
+    if (src.header->body_pipe != nullptr) {
         // check that it would not be too late to shortcircuit the pipe
         Must(!src.header->body_pipe->consumedSize());
         src.header->body_pipe->clearConsumer(); // if any
diff --git a/src/adaptation/Service.cc b/src/adaptation/Service.cc
index fb3ff77..6aa466c 100644
--- a/src/adaptation/Service.cc
+++ b/src/adaptation/Service.cc
@@ -15,7 +15,7 @@
 
 Adaptation::Service::Service(const ServiceConfigPointer &aConfig): theConfig(aConfig)
 {
-    Must(theConfig != NULL);
+    Must(theConfig != nullptr);
     debugs(93,3, HERE << "creating adaptation service " << cfg().key);
 }
 
@@ -60,19 +60,18 @@ Adaptation::Service::wants(const ServiceFilter &filter) const
 Adaptation::Services &
 Adaptation::AllServices()
 {
-    static Services *TheServices = new Services;
+    static auto *TheServices = new Services;
     return *TheServices;
 }
 
 Adaptation::ServicePointer
 Adaptation::FindService(const Service::Id& key)
 {
-    typedef Services::iterator SI;
-    for (SI i = AllServices().begin(); i != AllServices().end(); ++i) {
-        if ((*i)->cfg().key == key)
-            return *i;
+    for (const auto & service : AllServices()) {
+        if (service->cfg().key == key)
+            return service;
     }
-    return NULL;
+    return nullptr;
 }
 
 void Adaptation::DetachServices()
diff --git a/src/adaptation/ServiceConfig.cc b/src/adaptation/ServiceConfig.cc
index 1d4697b..ab350d7 100644
--- a/src/adaptation/ServiceConfig.cc
+++ b/src/adaptation/ServiceConfig.cc
@@ -221,22 +221,22 @@ Adaptation::ServiceConfig::grokUri(const char *value)
     int len = 0;
     if (*s == '[') {
         const char *t;
-        if ((t = strchr(s, ']')) == NULL)
+        if ((t = strchr(s, ']')) == nullptr)
             return false;
 
         ++s;
         len = t - s;
-        if ((e = strchr(t, ':')) != NULL) {
+        if ((e = strchr(t, ':')) != nullptr) {
             have_port = true;
-        } else if ((e = strchr(t, '/')) != NULL) {
+        } else if ((e = strchr(t, '/')) != nullptr) {
             have_port = false;
         } else {
             return false;
         }
     } else {
-        if ((e = strchr(s, ':')) != NULL) {
+        if ((e = strchr(s, ':')) != nullptr) {
             have_port = true;
-        } else if ((e = strchr(s, '/')) != NULL) {
+        } else if ((e = strchr(s, '/')) != nullptr) {
             have_port = false;
         } else {
             return false;
@@ -255,7 +255,7 @@ Adaptation::ServiceConfig::grokUri(const char *value)
     if (have_port) {
         ++s;
 
-        if ((e = strchr(s, '/')) != NULL) {
+        if ((e = strchr(s, '/')) != nullptr) {
             char *t;
             const unsigned long p = strtoul(s, &t, 0);
 
@@ -309,7 +309,7 @@ Adaptation::ServiceConfig::grokBool(bool &var, const char *name, const char *val
 bool
 Adaptation::ServiceConfig::grokLong(long &var, const char *name, const char *value)
 {
-    char *bad = NULL;
+    char *bad = nullptr;
     const long p = strtol(value, &bad, 0);
     if (p < 0 || bad == value) {
         debugs(3, DBG_CRITICAL, "ERROR: " << cfg_filename << ':' <<
diff --git a/src/adaptation/ServiceGroups.cc b/src/adaptation/ServiceGroups.cc
index 070a2d1..aa2d58b 100644
--- a/src/adaptation/ServiceGroups.cc
+++ b/src/adaptation/ServiceGroups.cc
@@ -33,7 +33,7 @@ Adaptation::ServiceGroup::parse()
 {
     id = ConfigParser::NextToken();
 
-    wordlist *names = NULL;
+    wordlist *names = nullptr;
     ConfigParser::ParseWordList(&names);
     for (wordlist *i = names; i; i = i->next)
         services.push_back(i->key);
@@ -50,8 +50,8 @@ Adaptation::ServiceGroup::finalize()
     // TODO: optimize by remembering ServicePointers rather than IDs
     if (!removedServices.empty()) {
         String s;
-        for (Store::iterator it = removedServices.begin(); it != removedServices.end(); ++it) {
-            s.append(*it);
+        for (auto & removedService : removedServices) {
+            s.append(removedService);
             s.append(',');
         }
         s.cut(s.size() - 1);
@@ -65,7 +65,7 @@ Adaptation::ServiceGroup::finalize()
         // TODO: quit on all errors
         const String &serviceId = services[pos];
         ServicePointer service = at(pos);
-        if (service != NULL) {
+        if (service != nullptr) {
             if (method == methodNone) {
                 // optimization: cache values that should be the same
                 method = service->cfg().method;
@@ -106,9 +106,9 @@ Adaptation::ServiceGroup::checkUniqueness(const Pos checkedPos) const
 
     for (Pos p = checkedPos + 1; has(p); ++p) {
         ServicePointer s = at(p);
-        if (s != NULL && s->cfg().key == checkedService->cfg().key)
+        if (s != nullptr && s->cfg().key == checkedService->cfg().key)
             finalizeMsg("duplicate service name", s->cfg().key, false);
-        else if (s != NULL && s->cfg().uri == checkedService->cfg().uri)
+        else if (s != nullptr && s->cfg().uri == checkedService->cfg().uri)
             finalizeMsg("duplicate service URI", s->cfg().uri, false);
     }
 }
@@ -247,9 +247,9 @@ Adaptation::DynamicServiceChain::Split(const ServiceFilter &filter,
     // walk the list of services and split it into two parts:
     // services that are applicable now and future services
     bool doingCurrent = true;
-    const char *item = NULL;
+    const char *item = nullptr;
     int ilen = 0;
-    const char *pos = NULL;
+    const char *pos = nullptr;
     while (strListGetItem(&ids, ',', &item, &ilen, &pos)) {
         String id;
         id.limitInit(item, ilen);
@@ -323,19 +323,18 @@ Adaptation::ServicePlan::print(std::ostream &os) const
 Adaptation::Groups &
 Adaptation::AllGroups()
 {
-    static Groups *TheGroups = new Groups;
+    static auto *TheGroups = new Groups;
     return *TheGroups;
 }
 
 Adaptation::ServiceGroupPointer
 Adaptation::FindGroup(const ServiceGroup::Id &id)
 {
-    typedef Groups::iterator GI;
-    for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i) {
-        if ((*i)->id == id)
-            return *i;
+    for (const auto & group : AllGroups()) {
+        if (group->id == id)
+            return group;
     }
 
-    return NULL;
+    return nullptr;
 }
 
diff --git a/src/adaptation/ecap/MessageRep.cc b/src/adaptation/ecap/MessageRep.cc
index fdd890c..1275476 100644
--- a/src/adaptation/ecap/MessageRep.cc
+++ b/src/adaptation/ecap/MessageRep.cc
@@ -347,7 +347,7 @@ void
 Adaptation::Ecap::BodyRep::tie(const BodyPipe::Pointer &aBody)
 {
     Must(!theBody);
-    Must(aBody != NULL);
+    Must(aBody != nullptr);
     theBody = aBody;
 }
 
@@ -360,21 +360,21 @@ Adaptation::Ecap::BodyRep::bodySize() const
 /* MessageRep */
 
 Adaptation::Ecap::MessageRep::MessageRep(Http::Message *rawHeader):
-    theMessage(rawHeader), theFirstLineRep(NULL),
-    theHeaderRep(NULL), theBodyRep(NULL)
+    theMessage(rawHeader), theFirstLineRep(nullptr),
+    theHeaderRep(nullptr), theBodyRep(nullptr)
 {
     Must(theMessage.header); // we do not want to represent a missing message
 
-    if (HttpRequest *req = dynamic_cast<HttpRequest*>(theMessage.header))
+    if (auto *req = dynamic_cast<HttpRequest*>(theMessage.header))
         theFirstLineRep = new RequestLineRep(*req);
-    else if (HttpReply *rep = dynamic_cast<HttpReply*>(theMessage.header))
+    else if (auto *rep = dynamic_cast<HttpReply*>(theMessage.header))
         theFirstLineRep = new StatusLineRep(*rep);
     else
         Must(false); // unknown message header type
 
     theHeaderRep = new HeaderRep(*theMessage.header);
 
-    if (theMessage.body_pipe != NULL)
+    if (theMessage.body_pipe != nullptr)
         theBodyRep = new BodyRep(theMessage.body_pipe);
 }
 
@@ -389,11 +389,11 @@ libecap::shared_ptr<libecap::Message>
 Adaptation::Ecap::MessageRep::clone() const
 {
     Http::Message *hdr = theMessage.header->clone();
-    hdr->body_pipe = NULL; // if any; TODO: remove pipe cloning from ::clone?
+    hdr->body_pipe = nullptr; // if any; TODO: remove pipe cloning from ::clone?
     libecap::shared_ptr<libecap::Message> res(new MessageRep(hdr));
 
     // restore indication of a body if needed, but not the pipe
-    if (theMessage.header->body_pipe != NULL)
+    if (theMessage.header->body_pipe != nullptr)
         res->addBody();
 
     return res;
@@ -434,13 +434,13 @@ Adaptation::Ecap::MessageRep::addBody()
 {
     Must(!theBodyRep);
     Must(!theMessage.body_pipe); // set in tieBody()
-    theBodyRep = new BodyRep(NULL);
+    theBodyRep = new BodyRep(nullptr);
 }
 
 void
 Adaptation::Ecap::MessageRep::tieBody(Adaptation::Ecap::XactionRep *x)
 {
-    Must(theBodyRep != NULL); // addBody must be called first
+    Must(theBodyRep != nullptr); // addBody must be called first
     Must(!theMessage.header->body_pipe);
     Must(!theMessage.body_pipe);
     theMessage.header->body_pipe = new BodyPipe(x);
diff --git a/src/adaptation/ecap/ServiceRep.cc b/src/adaptation/ecap/ServiceRep.cc
index 7983d06..1576f23 100644
--- a/src/adaptation/ecap/ServiceRep.cc
+++ b/src/adaptation/ecap/ServiceRep.cc
@@ -82,9 +82,9 @@ Adaptation::Ecap::ConfigRep::option(const libecap::Name &name) const
     // TODO: We could build a by-name index, but is it worth it? Good adapters
     // should use visitEachOption() instead, to check for name typos/errors.
     typedef Master::Extensions::const_iterator MECI;
-    for (MECI i = master.extensions.begin(); i != master.extensions.end(); ++i) {
-        if (name == i->first)
-            return Area(i->second.data(), i->second.size());
+    for (const auto & extension : master.extensions) {
+        if (name == extension.first)
+            return Area(extension.second.data(), extension.second.size());
     }
 
     return Area();
@@ -98,8 +98,8 @@ Adaptation::Ecap::ConfigRep::visitEachOption(libecap::NamedValueVisitor &visitor
 
     // visit adapter-specific options (i.e., those not recognized by Squid)
     typedef Master::Extensions::const_iterator MECI;
-    for (MECI i = master.extensions.begin(); i != master.extensions.end(); ++i)
-        visitor.visit(Name(i->first), Area::FromTempString(i->second));
+    for (const auto & extension : master.extensions)
+        visitor.visit(Name(extension.first), Area::FromTempString(extension.second));
 }
 
 /* Adaptation::Ecap::Engine */
@@ -138,14 +138,14 @@ Adaptation::Ecap::Engine::kickAsyncServices(timeval &timeout)
 
     // Activate waiting async transactions, if any.
     typedef AdapterServices::iterator ASI;
-    for (ASI s = AsyncServices.begin(); s != AsyncServices.end(); ++s) {
+    for (auto s = AsyncServices.begin(); s != AsyncServices.end(); ++s) {
         assert(s->second);
         s->second->resume(); // may call Ecap::Xaction::resume()
     }
 
     // Give services a chance to decrease the default timeout.
-    for (ASI s = AsyncServices.begin(); s != AsyncServices.end(); ++s) {
-        s->second->suspend(timeout);
+    for (auto & AsyncService : AsyncServices) {
+        AsyncService.second->suspend(timeout);
     }
 }
 
@@ -255,7 +255,7 @@ Adaptation::Ecap::ServiceRep::makeXactLauncher(Http::Message *virgin,
 
     // register now because (a) we need EventLoop::Running and (b) we do not
     // want to add more main loop overheads unless an async service is used.
-    static AsyncEngine *TheEngine = NULL;
+    static AsyncEngine *TheEngine = nullptr;
     if (AsyncServices.size() && !TheEngine && EventLoop::Running) {
         TheEngine = new Engine;
         EventLoop::Running->registerEngine(TheEngine);
@@ -338,7 +338,7 @@ Adaptation::Ecap::CheckUnusedAdapterServices(const Adaptation::Services& cfgs)
     for (ASCI loaded = TheServices.begin(); loaded != TheServices.end();
             ++loaded) {
         bool found = false;
-        for (Services::const_iterator cfged = cfgs.begin();
+        for (auto cfged = cfgs.begin();
                 cfged != cfgs.end() && !found; ++cfged) {
             found = (*cfged)->cfg().uri == loaded->second->uri().c_str();
         }
diff --git a/src/adaptation/ecap/XactionRep.cc b/src/adaptation/ecap/XactionRep.cc
index 0645a71..cda1088 100644
--- a/src/adaptation/ecap/XactionRep.cc
+++ b/src/adaptation/ecap/XactionRep.cc
@@ -50,7 +50,7 @@ Adaptation::Ecap::XactionRep::XactionRep(
     AsyncJob("Adaptation::Ecap::XactionRep"),
     Adaptation::Initiate("Adaptation::Ecap::XactionRep"),
     theService(aService),
-    theVirginRep(virginHeader), theCauseRep(NULL),
+    theVirginRep(virginHeader), theCauseRep(nullptr),
     makingVb(opUndecided), proxyingAb(opUndecided),
     adaptHistoryId(-1),
     vbProductionFinished(false),
@@ -79,7 +79,7 @@ Adaptation::Ecap::XactionRep::master(const AdapterXaction &x)
 Adaptation::Service &
 Adaptation::Ecap::XactionRep::service()
 {
-    Must(theService != NULL);
+    Must(theService != nullptr);
     return *theService;
 }
 
@@ -121,7 +121,7 @@ Adaptation::Ecap::XactionRep::visitEachOption(libecap::NamedValueVisitor &visito
 const libecap::Area
 Adaptation::Ecap::XactionRep::clientIpValue() const
 {
-    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+    const auto *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
                                  theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     // TODO: move this logic into HttpRequest::clientIp(bool) and
@@ -147,10 +147,10 @@ const libecap::Area
 Adaptation::Ecap::XactionRep::usernameValue() const
 {
 #if USE_AUTH
-    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+    const auto *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
                                  theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
-    if (request->auth_user_request != NULL) {
+    if (request->auth_user_request != nullptr) {
         if (char const *name = request->auth_user_request->username())
             return libecap::Area::FromTempBuffer(name, strlen(name));
         else if (request->extacl_user.size() > 0)
@@ -164,12 +164,12 @@ Adaptation::Ecap::XactionRep::usernameValue() const
 const libecap::Area
 Adaptation::Ecap::XactionRep::masterxSharedValue(const libecap::Name &name) const
 {
-    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+    const auto *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
                                  theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     if (name.known()) { // must check to avoid empty names matching unset cfg
         Adaptation::History::Pointer ah = request->adaptHistory(false);
-        if (ah != NULL) {
+        if (ah != nullptr) {
             String name, value;
             if (ah->getXxRecord(name, value))
                 return libecap::Area::FromTempBuffer(value.rawBuf(), value.size());
@@ -181,10 +181,10 @@ Adaptation::Ecap::XactionRep::masterxSharedValue(const libecap::Name &name) cons
 const libecap::Area
 Adaptation::Ecap::XactionRep::metaValue(const libecap::Name &name) const
 {
-    HttpRequest *request = dynamic_cast<HttpRequest*>(theCauseRep ?
+    auto *request = dynamic_cast<HttpRequest*>(theCauseRep ?
                            theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
-    HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
+    auto *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
     if (name.known()) { // must check to avoid empty names matching unset cfg
         typedef Notes::iterator ACAMLI;
@@ -205,10 +205,10 @@ Adaptation::Ecap::XactionRep::metaValue(const libecap::Name &name) const
 void
 Adaptation::Ecap::XactionRep::visitEachMetaHeader(libecap::NamedValueVisitor &visitor) const
 {
-    HttpRequest *request = dynamic_cast<HttpRequest*>(theCauseRep ?
+    auto *request = dynamic_cast<HttpRequest*>(theCauseRep ?
                            theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
-    HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
+    auto *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
     for (auto h: Adaptation::Config::metaHeaders) {
         SBuf matched;
@@ -228,20 +228,20 @@ Adaptation::Ecap::XactionRep::start()
     if (!theVirginRep.raw().body_pipe)
         makingVb = opNever; // there is nothing to deliver
 
-    HttpRequest *request = dynamic_cast<HttpRequest*> (theCauseRep ?
+    auto *request = dynamic_cast<HttpRequest*> (theCauseRep ?
                            theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
 
-    HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
+    auto *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
     Adaptation::History::Pointer ah = request->adaptLogHistory();
-    if (ah != NULL) {
+    if (ah != nullptr) {
         // retrying=false because ecap never retries transactions
         adaptHistoryId = ah->recordXactStart(service().cfg().key, current_time, false);
         SBuf matched;
         for (auto h: Adaptation::Config::metaHeaders) {
             if (h->match(request, reply, al, matched)) {
-                if (ah->metaHeaders == NULL)
+                if (ah->metaHeaders == nullptr)
                     ah->metaHeaders = new NotePairs();
                 if (!ah->metaHeaders->hasPair(h->key(), matched))
                     ah->metaHeaders->add(h->key(), matched);
@@ -260,23 +260,23 @@ Adaptation::Ecap::XactionRep::swanSong()
 
     if (theAnswerRep) {
         BodyPipe::Pointer body_pipe = answer().body_pipe;
-        if (body_pipe != NULL) {
+        if (body_pipe != nullptr) {
             Must(body_pipe->stillProducing(this));
             stopProducingFor(body_pipe, false);
         }
     }
 
     BodyPipe::Pointer &body_pipe = theVirginRep.raw().body_pipe;
-    if (body_pipe != NULL && body_pipe->stillConsuming(this))
+    if (body_pipe != nullptr && body_pipe->stillConsuming(this))
         stopConsumingFrom(body_pipe);
 
     terminateMaster();
 
-    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+    const auto *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
                                  theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     Adaptation::History::Pointer ah = request->adaptLogHistory();
-    if (ah != NULL && adaptHistoryId >= 0)
+    if (ah != nullptr && adaptHistoryId >= 0)
         ah->recordXactFinish(adaptHistoryId);
 
     Adaptation::Initiate::swanSong();
@@ -310,7 +310,7 @@ Adaptation::Ecap::XactionRep::virgin()
 const libecap::Message &
 Adaptation::Ecap::XactionRep::cause()
 {
-    Must(theCauseRep != NULL);
+    Must(theCauseRep != nullptr);
     return *theCauseRep;
 }
 
@@ -324,7 +324,7 @@ Adaptation::Ecap::XactionRep::adapted()
 Adaptation::Message &
 Adaptation::Ecap::XactionRep::answer()
 {
-    MessageRep *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
+    auto *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
     Must(rep);
     return rep->raw();
 }
@@ -354,7 +354,7 @@ Adaptation::Ecap::XactionRep::sinkVb(const char *reason)
 
     // we reset raw().body_pipe when we are done, so use this one for checking
     const BodyPipePointer &permPipe = theVirginRep.raw().header->body_pipe;
-    if (permPipe != NULL)
+    if (permPipe != nullptr)
         permPipe->enableAutoConsumption();
 
     forgetVb(reason);
@@ -368,7 +368,7 @@ Adaptation::Ecap::XactionRep::preserveVb(const char *reason)
 
     // we reset raw().body_pipe when we are done, so use this one for checking
     const BodyPipePointer &permPipe = theVirginRep.raw().header->body_pipe;
-    if (permPipe != NULL) {
+    if (permPipe != nullptr) {
         // if libecap consumed, we cannot preserve
         Must(!permPipe->consumedSize());
     }
@@ -383,7 +383,7 @@ Adaptation::Ecap::XactionRep::forgetVb(const char *reason)
     debugs(93,9, HERE << "forget vb " << reason << "; status:" << status());
 
     BodyPipePointer &p = theVirginRep.raw().body_pipe;
-    if (p != NULL && p->stillConsuming(this))
+    if (p != nullptr && p->stillConsuming(this))
         stopConsumingFrom(p);
 
     if (makingVb == opUndecided)
@@ -427,10 +427,10 @@ Adaptation::Ecap::XactionRep::useAdapted(const libecap::shared_ptr<libecap::Mess
     } else { // got answer headers but need to handle body
         proxyingAb = opOn;
         Must(!msg->body_pipe); // only host can set body pipes
-        MessageRep *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
+        auto *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
         Must(rep);
         rep->tieBody(this); // sets us as a producer
-        Must(msg->body_pipe != NULL); // check tieBody
+        Must(msg->body_pipe != nullptr); // check tieBody
 
         updateHistory(msg);
         sendAnswer(Answer::Forward(msg));
@@ -449,7 +449,7 @@ Adaptation::Ecap::XactionRep::blockVirgin()
 
     sinkVb("blockVirgin");
 
-    updateHistory(NULL);
+    updateHistory(nullptr);
     sendAnswer(Answer::Block(service().cfg().key));
     Must(done());
 }
@@ -462,7 +462,7 @@ Adaptation::Ecap::XactionRep::updateHistory(Http::Message *adapted)
     if (!theMaster) // all updates rely on being able to query the adapter
         return;
 
-    const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
+    const auto *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
                                  theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
 
@@ -472,7 +472,7 @@ Adaptation::Ecap::XactionRep::updateHistory(Http::Message *adapted)
     // update the cross-transactional database if needed
     if (const char *xxNameStr = Adaptation::Config::masterx_shared_name) {
         Adaptation::History::Pointer ah = request->adaptHistory(true);
-        if (ah != NULL) {
+        if (ah != nullptr) {
             libecap::Name xxName(xxNameStr); // TODO: optimize?
             if (const libecap::Area val = theMaster->option(xxName))
                 ah->updateXxRecord(xxNameStr, val.toString().c_str());
@@ -484,7 +484,7 @@ Adaptation::Ecap::XactionRep::updateHistory(Http::Message *adapted)
         String services;
         if (const libecap::Area services = theMaster->option(libecap::metaNextServices)) {
             Adaptation::History::Pointer ah = request->adaptHistory(true);
-            if (ah != NULL)
+            if (ah != nullptr)
                 ah->updateNextServices(services.toString().c_str());
         }
     } // TODO: else warn (occasionally!) if we got libecap::metaNextServices
@@ -493,7 +493,7 @@ Adaptation::Ecap::XactionRep::updateHistory(Http::Message *adapted)
     // If we already have stored headers from a previous adaptation transaction
     // related to the same master transction, they will be replaced.
     Adaptation::History::Pointer ah = request->adaptLogHistory();
-    if (ah != NULL) {
+    if (ah != nullptr) {
         HttpHeader meta(hoReply);
         OptionsExtractor extractor(meta);
         theMaster->visitEachOption(extractor);
@@ -501,7 +501,7 @@ Adaptation::Ecap::XactionRep::updateHistory(Http::Message *adapted)
     }
 
     // Add just-created history to the adapted/cloned request that lacks it.
-    if (HttpRequest *adaptedReq = dynamic_cast<HttpRequest*>(adapted))
+    if (auto *adaptedReq = dynamic_cast<HttpRequest*>(adapted))
         adaptedReq->adaptHistoryImport(*request);
 }
 
@@ -519,7 +519,7 @@ Adaptation::Ecap::XactionRep::vbMake()
 {
     Must(makingVb == opUndecided);
     BodyPipePointer &p = theVirginRep.raw().body_pipe;
-    Must(p != NULL);
+    Must(p != nullptr);
     Must(p->setConsumerIfNotLate(this)); // to deliver vb, we must receive vb
     makingVb = opOn;
 }
@@ -539,7 +539,7 @@ Adaptation::Ecap::XactionRep::vbMakeMore()
     Must(makingVb == opOn); // cannot make more if done proxying
     // we cannot guarantee more vb, but we can check that there is a chance
     const BodyPipePointer &p = theVirginRep.raw().body_pipe;
-    Must(p != NULL && p->stillConsuming(this)); // we are plugged in
+    Must(p != nullptr && p->stillConsuming(this)); // we are plugged in
     Must(!p->productionEnded() && p->mayNeedMoreData()); // and may get more
 }
 
@@ -549,13 +549,13 @@ Adaptation::Ecap::XactionRep::vbContent(libecap::size_type o, libecap::size_type
     // We may not be makingVb yet. It should be OK, but see vbContentShift().
 
     const BodyPipePointer &p = theVirginRep.raw().body_pipe;
-    Must(p != NULL);
+    Must(p != nullptr);
 
     // TODO: make MemBuf use size_t?
-    const size_t haveSize = static_cast<size_t>(p->buf().contentSize());
+    const auto haveSize = static_cast<size_t>(p->buf().contentSize());
 
     // convert to Squid types; XXX: check for overflow
-    const uint64_t offset = static_cast<uint64_t>(o);
+    const auto offset = static_cast<uint64_t>(o);
     Must(offset <= haveSize); // equal iff at the end of content
 
     // nsize means no size limit: all content starting from offset
@@ -575,9 +575,9 @@ Adaptation::Ecap::XactionRep::vbContentShift(libecap::size_type n)
     // until the adapter registers as a consumer
 
     BodyPipePointer &p = theVirginRep.raw().body_pipe;
-    Must(p != NULL);
-    const size_t size = static_cast<size_t>(n); // XXX: check for overflow
-    const size_t haveSize = static_cast<size_t>(p->buf().contentSize()); // TODO: make MemBuf use size_t?
+    Must(p != nullptr);
+    const auto size = static_cast<size_t>(n); // XXX: check for overflow
+    const auto haveSize = static_cast<size_t>(p->buf().contentSize()); // TODO: make MemBuf use size_t?
     p->consume(min(size, haveSize));
 }
 
@@ -715,7 +715,7 @@ Adaptation::Ecap::XactionRep::status() const
     buf.appendf(" A%d", static_cast<int>(proxyingAb));
 
     if (proxyingAb == opOn) {
-        MessageRep *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
+        auto *rep = dynamic_cast<MessageRep*>(theAnswerRep.get());
         Must(rep);
         const BodyPipePointer &ap = rep->raw().body_pipe;
         if (!ap)
diff --git a/src/adaptation/icap/Config.cc b/src/adaptation/icap/Config.cc
index 5590350..d40914d 100644
--- a/src/adaptation/icap/Config.cc
+++ b/src/adaptation/icap/Config.cc
@@ -22,7 +22,7 @@ Adaptation::Icap::Config::Config() :
     default_options_ttl(0),
     preview_enable(0), preview_size(0), allow206_enable(0),
     connect_timeout_raw(0), io_timeout_raw(0), reuse_connections(0),
-    client_username_header(NULL), client_username_encode(0), repeat(NULL),
+    client_username_header(nullptr), client_username_encode(0), repeat(nullptr),
     repeat_limit(0)
 {
 }
diff --git a/src/adaptation/icap/InOut.h b/src/adaptation/icap/InOut.h
index b768906..bbe37e2 100644
--- a/src/adaptation/icap/InOut.h
+++ b/src/adaptation/icap/InOut.h
@@ -28,7 +28,7 @@ public:
     // TODO: s/Header/Message/i ?
     typedef Http::Message Header;
 
-    InOut(): header(0), cause(0) {}
+    InOut(): header(nullptr), cause(nullptr) {}
 
     ~InOut() {
         HTTPMSGUNLOCK(cause);
diff --git a/src/adaptation/icap/Launcher.cc b/src/adaptation/icap/Launcher.cc
index 4b9c51d..e862820 100644
--- a/src/adaptation/icap/Launcher.cc
+++ b/src/adaptation/icap/Launcher.cc
@@ -23,7 +23,7 @@ Adaptation::Icap::Launcher::Launcher(const char *aTypeName,
                                      Adaptation::ServicePointer &aService):
     AsyncJob(aTypeName),
     Adaptation::Initiate(aTypeName),
-    theService(aService), theXaction(0), theLaunches(0)
+    theService(aService), theXaction(nullptr), theLaunches(0)
 {
 }
 
@@ -140,7 +140,7 @@ bool Adaptation::Icap::Launcher::canRepeat(Adaptation::Icap::XactAbortInfo &info
     if (info.icapReply->sline.status() == Http::scNone) // failed to parse the reply; I/O err
         return true;
 
-    ACLFilledChecklist *cl =
+    auto *cl =
         new ACLFilledChecklist(TheConfig.repeat, info.icapRequest, dash_str);
     cl->reply = info.icapReply;
     HTTPMSGLOCK(cl->reply);
diff --git a/src/adaptation/icap/ModXact.cc b/src/adaptation/icap/ModXact.cc
index b182b1b..4c4a054 100644
--- a/src/adaptation/icap/ModXact.cc
+++ b/src/adaptation/icap/ModXact.cc
@@ -52,7 +52,7 @@ Adaptation::Icap::ModXact::ModXact(Http::Message *virginHeader,
     AsyncJob("Adaptation::Icap::ModXact"),
     Adaptation::Icap::Xaction("Adaptation::Icap::ModXact", aService),
     virginConsumed(0),
-    bodyParser(NULL),
+    bodyParser(nullptr),
     canStartBypass(false), // too early
     protectGroupBypass(true),
     replyHttpHeaderSize(-1),
@@ -87,7 +87,7 @@ void Adaptation::Icap::ModXact::start()
 
     // reserve an adaptation history slot (attempts are known at this time)
     Adaptation::History::Pointer ah = virginRequest().adaptLogHistory();
-    if (ah != NULL)
+    if (ah != nullptr)
         adaptHistoryId = ah->recordXactStart(service().cfg().key, icap_tr_start, attempts > 1);
 
     estimateVirginBody(); // before virgin disappears!
@@ -236,7 +236,7 @@ void Adaptation::Icap::ModXact::writeMore()
 {
     debugs(93, 5, HERE << "checking whether to write more" << status());
 
-    if (writer != NULL) // already writing something
+    if (writer != nullptr) // already writing something
         return;
 
     switch (state.writing) {
@@ -275,9 +275,9 @@ void Adaptation::Icap::ModXact::writePreviewBody()
     debugs(93, 8, HERE << "will write Preview body from " <<
            virgin.body_pipe << status());
     Must(state.writing == State::writingPreview);
-    Must(virgin.body_pipe != NULL);
+    Must(virgin.body_pipe != nullptr);
 
-    const size_t sizeMax = (size_t)virgin.body_pipe->buf().contentSize();
+    const auto sizeMax = (size_t)virgin.body_pipe->buf().contentSize();
     const size_t size = min(preview.debt(), sizeMax);
     writeSomeBody("preview body", size);
 
@@ -306,7 +306,7 @@ void Adaptation::Icap::ModXact::writePrimeBody()
     Must(state.writing == State::writingPrime);
     Must(virginBodyWriting.active());
 
-    const size_t size = (size_t)virgin.body_pipe->buf().contentSize();
+    const auto size = (size_t)virgin.body_pipe->buf().contentSize();
     writeSomeBody("prime virgin body", size);
 
     if (virginBodyEndReached(virginBodyWriting)) {
@@ -318,7 +318,7 @@ void Adaptation::Icap::ModXact::writePrimeBody()
 void Adaptation::Icap::ModXact::writeSomeBody(const char *label, size_t size)
 {
     Must(!writer && state.writing < state.writingAlmostDone);
-    Must(virgin.body_pipe != NULL);
+    Must(virgin.body_pipe != nullptr);
     debugs(93, 8, HERE << "will write up to " << size << " bytes of " <<
            label);
 
@@ -446,7 +446,7 @@ void Adaptation::Icap::ModXact::virginConsume()
         return;
     }
 
-    const size_t have = static_cast<size_t>(bp.buf().contentSize());
+    const auto have = static_cast<size_t>(bp.buf().contentSize());
     const uint64_t end = virginConsumed + have;
     uint64_t offset = end;
 
@@ -463,7 +463,7 @@ void Adaptation::Icap::ModXact::virginConsume()
 
     Must(virginConsumed <= offset && offset <= end);
 
-    if (const size_t size = static_cast<size_t>(offset - virginConsumed)) {
+    if (const auto size = static_cast<size_t>(offset - virginConsumed)) {
         debugs(93, 8, HERE << "consuming " << size << " out of " << have <<
                " virgin body bytes");
         bp.consume(size);
@@ -487,7 +487,7 @@ void Adaptation::Icap::ModXact::stopWriting(bool nicely)
     if (state.writing == State::writingReallyDone)
         return;
 
-    if (writer != NULL) {
+    if (writer != nullptr) {
         if (nicely) {
             debugs(93, 7, HERE << "will wait for the last write" << status());
             state.writing = State::writingAlmostDone; // may already be set
@@ -544,13 +544,13 @@ void Adaptation::Icap::ModXact::startReading()
 
 void Adaptation::Icap::ModXact::readMore()
 {
-    if (reader != NULL || doneReading()) {
+    if (reader != nullptr || doneReading()) {
         debugs(93,3,HERE << "returning from readMore because reader or doneReading()");
         return;
     }
 
     // do not fill readBuf if we have no space to store the result
-    if (adapted.body_pipe != NULL &&
+    if (adapted.body_pipe != nullptr &&
             !adapted.body_pipe->buf().hasPotentialSpace()) {
         debugs(93,3,HERE << "not reading because ICAP reply pipe is full");
         return;
@@ -574,7 +574,7 @@ void Adaptation::Icap::ModXact::handleCommRead(size_t)
 void Adaptation::Icap::ModXact::echoMore()
 {
     Must(state.sending == State::sendingVirgin);
-    Must(adapted.body_pipe != NULL);
+    Must(adapted.body_pipe != nullptr);
     Must(virginBodySending.active());
 
     const size_t sizeMax = virginContentSize(virginBodySending);
@@ -619,7 +619,7 @@ void Adaptation::Icap::ModXact::stopSending(bool nicely)
 
     if (state.sending != State::sendingUndecided) {
         debugs(93, 7, HERE << "will no longer send" << status());
-        if (adapted.body_pipe != NULL) {
+        if (adapted.body_pipe != nullptr) {
             virginBodySending.disable();
             // we may leave debts if we were echoing and the virgin
             // body_pipe got exhausted before we echoed all planned bytes
@@ -665,7 +665,7 @@ void Adaptation::Icap::ModXact::callException(const std::exception &e)
 {
     if (!canStartBypass || isRetriable) {
         if (!isRetriable) {
-            if (const TextException *te = dynamic_cast<const TextException *>(&e))
+            if (const auto *te = dynamic_cast<const TextException *>(&e))
                 detailError(ERR_DETAIL_EXCEPTION_START + te->id());
             else
                 detailError(ERR_DETAIL_EXCEPTION_OTHER);
@@ -840,7 +840,7 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // update the cross-transactional database if needed (all status codes!)
     if (const char *xxName = Adaptation::Config::masterx_shared_name) {
         Adaptation::History::Pointer ah = request->adaptHistory(true);
-        if (ah != NULL) { // TODO: reorder checks to avoid creating history
+        if (ah != nullptr) { // TODO: reorder checks to avoid creating history
             const String val = icapReply->header.getByName(xxName);
             if (val.size() > 0) // XXX: HttpHeader lacks empty value detection
                 ah->updateXxRecord(xxName, val);
@@ -852,7 +852,7 @@ void Adaptation::Icap::ModXact::parseIcapHead()
         String services;
         if (icapReply->header.getList(Http::HdrType::X_NEXT_SERVICES, &services)) {
             Adaptation::History::Pointer ah = request->adaptHistory(true);
-            if (ah != NULL)
+            if (ah != nullptr)
                 ah->updateNextServices(services);
         }
     } // TODO: else warn (occasionally!) if we got Http::HdrType::X_NEXT_SERVICES
@@ -862,7 +862,7 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // request, old headers will be replaced with the new one.
 
     Adaptation::History::Pointer ah = request->adaptLogHistory();
-    if (ah != NULL)
+    if (ah != nullptr)
         ah->recordMeta(&icapReply->header);
 
     // handle100Continue() manages state.writing on its own.
@@ -994,7 +994,7 @@ void Adaptation::Icap::ModXact::prepEchoing()
            adapted.header);
 
     // setup adapted body pipe if needed
-    if (oldHead->body_pipe != NULL) {
+    if (oldHead->body_pipe != nullptr) {
         debugs(93, 7, HERE << "will echo virgin body from " <<
                oldHead->body_pipe);
         if (!virginBodySending.active())
@@ -1020,7 +1020,7 @@ void Adaptation::Icap::ModXact::prepEchoing()
 void Adaptation::Icap::ModXact::prepPartialBodyEchoing(uint64_t pos)
 {
     Must(virginBodySending.active());
-    Must(virgin.header->body_pipe != NULL);
+    Must(virgin.header->body_pipe != nullptr);
 
     setOutcome(xoPartEcho);
 
@@ -1069,7 +1069,7 @@ void Adaptation::Icap::ModXact::parseHttpHead()
             replyHttpHeaderSize = adapted.header->hdr_sz;
 
         if (dynamic_cast<HttpRequest*>(adapted.header)) {
-            const HttpRequest *oldR = dynamic_cast<const HttpRequest*>(virgin.header);
+            const auto *oldR = dynamic_cast<const HttpRequest*>(virgin.header);
             Must(oldR);
             // TODO: the adapted request did not really originate from the
             // client; give proxy admin an option to prevent copying of
@@ -1298,7 +1298,7 @@ void Adaptation::Icap::ModXact::swanSong()
 
     // update adaptation history if start was called and we reserved a slot
     Adaptation::History::Pointer ah = virginRequest().adaptLogHistory();
-    if (ah != NULL && adaptHistoryId >= 0)
+    if (ah != nullptr && adaptHistoryId >= 0)
         ah->recordXactFinish(adaptHistoryId);
 
     Adaptation::Icap::Xaction::swanSong();
@@ -1310,7 +1310,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
 {
     HttpRequest *adapted_request_ = nullptr;
     HttpReply *adapted_reply_ = nullptr;
-    HttpRequest *virgin_request_ = const_cast<HttpRequest*>(&virginRequest());
+    auto *virgin_request_ = const_cast<HttpRequest*>(&virginRequest());
     if (!(adapted_request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
         // if the request was not adapted, use virgin request to simplify
         // the code further below
@@ -1319,7 +1319,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
     }
 
     Adaptation::Icap::History::Pointer h = virgin_request_->icapHistory();
-    Must(h != NULL); // ICAPXaction::maybeLog calls only if there is a log
+    Must(h != nullptr); // ICAPXaction::maybeLog calls only if there is a log
     al.icp.opcode = ICP_INVALID;
     al.url = h->log_uri.termedBuf();
     const Adaptation::Icap::ServiceRep  &s = service();
@@ -1336,7 +1336,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         al.reply = adapted_reply_;
         HTTPMSGLOCK(al.reply);
     } else
-        al.reply = NULL;
+        al.reply = nullptr;
 
     if (h->rfc931.size())
         al.cache.rfc931 = h->rfc931.termedBuf();
@@ -1352,7 +1352,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         virgin_msg = virgin_request_;
     assert(virgin_msg != virgin.cause);
     al.http.clientRequestSz.header = virgin_msg->hdr_sz;
-    if (virgin_msg->body_pipe != NULL)
+    if (virgin_msg->body_pipe != nullptr)
         al.http.clientRequestSz.payloadData = virgin_msg->body_pipe->producedSize();
 
     // leave al.icap.bodyBytesRead negative if no body
@@ -1422,7 +1422,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     // share the cross-transactional database records if needed
     if (Adaptation::Config::masterx_shared_name) {
         Adaptation::History::Pointer ah = request->adaptHistory(false);
-        if (ah != NULL) {
+        if (ah != nullptr) {
             String name, value;
             if (ah->getXxRecord(name, value)) {
                 buf.appendf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
@@ -1490,7 +1490,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
                          virgin.cause : dynamic_cast<HttpRequest*>(virgin.header);
         Must(r);
 
-        HttpReply *reply = dynamic_cast<HttpReply*>(virgin.header);
+        auto *reply = dynamic_cast<HttpReply*>(virgin.header);
 
         SBuf matched;
         if (h->match(r, reply, alMaster, matched)) {
@@ -1499,8 +1499,8 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
             buf.append(matched.rawContent(), matched.length());
             buf.append("\r\n", 2);
             Adaptation::History::Pointer ah = request->adaptHistory(false);
-            if (ah != NULL) {
-                if (ah->metaHeaders == NULL)
+            if (ah != nullptr) {
+                if (ah->metaHeaders == nullptr)
                     ah->metaHeaders = new NotePairs;
                 if (!ah->metaHeaders->hasPair(h->key(), matched))
                     ah->metaHeaders->add(h->key(), matched);
@@ -1564,8 +1564,8 @@ void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, M
     struct base64_encode_ctx ctx;
     base64_encode_init(&ctx);
 
-    const char *value = NULL;
-    if (request->auth_user_request != NULL) {
+    const char *value = nullptr;
+    if (request->auth_user_request != nullptr) {
         value = request->auth_user_request->username();
     } else if (request->extacl_user.size() > 0) {
         value = request->extacl_user.termedBuf();
@@ -1592,14 +1592,14 @@ Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section,
     // begin cloning
     Http::MessagePointer headClone;
 
-    if (const HttpRequest* old_request = dynamic_cast<const HttpRequest*>(head)) {
+    if (const auto* old_request = dynamic_cast<const HttpRequest*>(head)) {
         HttpRequest::Pointer new_request(new HttpRequest);
         // copy the request-line details
         new_request->method = old_request->method;
         new_request->url = old_request->url;
         new_request->http_ver = old_request->http_ver;
         headClone = new_request.getRaw();
-    } else if (const HttpReply *old_reply = dynamic_cast<const HttpReply*>(head)) {
+    } else if (const auto *old_reply = dynamic_cast<const HttpReply*>(head)) {
         HttpReply::Pointer new_reply(new HttpReply);
         new_reply->sline = old_reply->sline;
         headClone = new_reply.getRaw();
@@ -1748,7 +1748,7 @@ void Adaptation::Icap::ModXact::fillPendingStatus(MemBuf &buf) const
     if (state.serviceWaiting)
         buf.append("U", 1);
 
-    if (virgin.body_pipe != NULL)
+    if (virgin.body_pipe != nullptr)
         buf.append("R", 1);
 
     if (haveConnection() && !doneReading())
@@ -1826,7 +1826,7 @@ void Adaptation::Icap::ModXact::estimateVirginBody()
 
     if (virgin.cause)
         method = virgin.cause->method;
-    else if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
+    else if (auto *req = dynamic_cast<HttpRequest*>(msg))
         method = req->method;
     else
         method = Http::METHOD_NONE;
@@ -1842,7 +1842,7 @@ void Adaptation::Icap::ModXact::estimateVirginBody()
         virginBodyWriting.plan();
 
         // sign up as a body consumer
-        Must(msg->body_pipe != NULL);
+        Must(msg->body_pipe != nullptr);
         Must(msg->body_pipe == virgin.body_pipe);
         Must(virgin.body_pipe->setConsumerIfNotLate(this));
 
@@ -1850,7 +1850,7 @@ void Adaptation::Icap::ModXact::estimateVirginBody()
         Must(TheBackupLimit <= static_cast<size_t>(msg->body_pipe->buf().max_capacity));
     } else {
         debugs(93, 6, HERE << "does not expect virgin body");
-        Must(msg->body_pipe == NULL);
+        Must(msg->body_pipe == nullptr);
         checkConsuming();
     }
 }
@@ -1980,7 +1980,7 @@ void Adaptation::Icap::Preview::wrote(size_t size, bool wroteEof)
 
 bool Adaptation::Icap::ModXact::fillVirginHttpHeader(MemBuf &mb) const
 {
-    if (virgin.header == NULL)
+    if (virgin.header == nullptr)
         return false;
 
     virgin.header->firstLineBuf(mb);
@@ -1990,7 +1990,7 @@ bool Adaptation::Icap::ModXact::fillVirginHttpHeader(MemBuf &mb) const
 
 void Adaptation::Icap::ModXact::detailError(int errDetail)
 {
-    HttpRequest *request = dynamic_cast<HttpRequest*>(adapted.header);
+    auto *request = dynamic_cast<HttpRequest*>(adapted.header);
     // if no adapted request, update virgin (and inherit its properties later)
     // TODO: make this and HttpRequest::detailError constant, like adaptHistory
     if (!request)
@@ -2002,7 +2002,7 @@ void Adaptation::Icap::ModXact::detailError(int errDetail)
 
 void Adaptation::Icap::ModXact::clearError()
 {
-    HttpRequest *request = dynamic_cast<HttpRequest*>(adapted.header);
+    auto *request = dynamic_cast<HttpRequest*>(adapted.header);
     // if no adapted request, update virgin (and inherit its properties later)
     if (!request)
         request = const_cast<HttpRequest*>(&virginRequest());
@@ -2033,7 +2033,7 @@ Adaptation::Icap::Xaction *Adaptation::Icap::ModXactLauncher::createXaction()
 {
     Adaptation::Icap::ServiceRep::Pointer s =
         dynamic_cast<Adaptation::Icap::ServiceRep*>(theService.getRaw());
-    Must(s != NULL);
+    Must(s != nullptr);
     return new Adaptation::Icap::ModXact(virgin.header, virgin.cause, al, s);
 }
 
@@ -2052,7 +2052,7 @@ void Adaptation::Icap::ModXactLauncher::updateHistory(bool doStart)
     // r should never be NULL but we play safe; TODO: add Should()
     if (r) {
         Adaptation::Icap::History::Pointer h = r->icapHistory();
-        if (h != NULL) {
+        if (h != nullptr) {
             if (doStart)
                 h->start("ICAPModXactLauncher");
             else
diff --git a/src/adaptation/icap/OptXact.cc b/src/adaptation/icap/OptXact.cc
index 7ea7465..44116d1 100644
--- a/src/adaptation/icap/OptXact.cc
+++ b/src/adaptation/icap/OptXact.cc
@@ -83,7 +83,7 @@ void Adaptation::Icap::OptXact::handleCommWrote(size_t size)
 void Adaptation::Icap::OptXact::handleCommRead(size_t)
 {
     if (parseResponse()) {
-        Must(icapReply != NULL);
+        Must(icapReply != nullptr);
         // We read everything if there is no response body. If there is a body,
         // we cannot parse it because we do not support any opt-body-types, so
         // we leave readAll false which forces connection closure.
@@ -128,7 +128,7 @@ void Adaptation::Icap::OptXact::finalizeLogInfo()
     //    al.cache.caddr = 0;
     al.icap.reqMethod = Adaptation::methodOptions;
 
-    if (icapReply != NULL && al.icap.bytesRead > icapReply->hdr_sz)
+    if (icapReply != nullptr && al.icap.bytesRead > icapReply->hdr_sz)
         al.icap.bodyBytesRead = al.icap.bytesRead - icapReply->hdr_sz;
 
     Adaptation::Icap::Xaction::finalizeLogInfo();
@@ -146,7 +146,7 @@ Adaptation::Icap::Xaction *Adaptation::Icap::OptXactLauncher::createXaction()
 {
     Adaptation::Icap::ServiceRep::Pointer s =
         dynamic_cast<Adaptation::Icap::ServiceRep*>(theService.getRaw());
-    Must(s != NULL);
+    Must(s != nullptr);
     return new Adaptation::Icap::OptXact(s);
 }
 
diff --git a/src/adaptation/icap/Options.cc b/src/adaptation/icap/Options.cc
index f0b8e2b..bbeb930 100644
--- a/src/adaptation/icap/Options.cc
+++ b/src/adaptation/icap/Options.cc
@@ -84,7 +84,7 @@ time_t Adaptation::Icap::Options::expire() const
 
 void Adaptation::Icap::Options::configure(const HttpReply *reply)
 {
-    error = NULL; // reset initial "unconfigured" value (or an old error?)
+    error = nullptr; // reset initial "unconfigured" value (or an old error?)
 
     const HttpHeader *h = &reply->header;
 
@@ -170,7 +170,7 @@ void Adaptation::Icap::Options::cfgTransferList(const HttpHeader *h, TransferLis
 
 /* Adaptation::Icap::Options::TransferList */
 
-Adaptation::Icap::Options::TransferList::TransferList(): extensions(NULL), name(NULL),
+Adaptation::Icap::Options::TransferList::TransferList(): extensions(nullptr), name(nullptr),
     kind(xferNone)
 {
 };
@@ -211,7 +211,7 @@ void Adaptation::Icap::Options::TransferList::parse(const String &buf, bool &fou
     foundStar = false;
 
     const char *item;
-    const char *pos = NULL;
+    const char *pos = nullptr;
     int ilen;
     while (strListGetItem(&buf, ',', &item, &ilen, &pos)) {
         if (ilen == 1 && *item == '*')
diff --git a/src/adaptation/icap/ServiceRep.cc b/src/adaptation/icap/ServiceRep.cc
index d9fd5a8..4c154f7 100644
--- a/src/adaptation/icap/ServiceRep.cc
+++ b/src/adaptation/icap/ServiceRep.cc
@@ -33,18 +33,18 @@ CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &svcCfg):
     AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(svcCfg),
-    theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
+    theOptions(nullptr), theOptionsFetcher(nullptr), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
     connOverloadReported(false),
-    theIdleConns(NULL),
-    isSuspended(0), notifying(false),
+    theIdleConns(nullptr),
+    isSuspended(nullptr), notifying(false),
     updateScheduled(false),
     wasAnnouncedUp(true), // do not announce an "up" service at startup
     isDetached(false)
 {
     setMaxConnections();
-    theIdleConns = new IdleConnList("ICAP Service", NULL);
+    theIdleConns = new IdleConnList("ICAP Service", nullptr);
 }
 
 Adaptation::Icap::ServiceRep::~ServiceRep()
@@ -270,7 +270,7 @@ void Adaptation::Icap::ServiceRep::busyCheckpoint()
         Client i = theNotificationWaiters.front();
         theNotificationWaiters.pop_front();
         ScheduleCallHere(i.callback);
-        i.callback = NULL;
+        i.callback = nullptr;
         --freed;
     }
 }
@@ -358,7 +358,7 @@ bool Adaptation::Icap::ServiceRep::allows206() const
 static
 void ServiceRep_noteTimeToUpdate(void *data)
 {
-    Adaptation::Icap::ServiceRep *service = static_cast<Adaptation::Icap::ServiceRep*>(data);
+    auto *service = static_cast<Adaptation::Icap::ServiceRep*>(data);
     Must(service);
     service->noteTimeToUpdate();
 }
@@ -396,13 +396,13 @@ void Adaptation::Icap::ServiceRep::noteTimeToNotify()
 
     // note: we must notify even if we are invalidated
 
-    Pointer us = NULL;
+    Pointer us = nullptr;
 
     while (!theClients.empty()) {
         Client i = theClients.back();
         theClients.pop_back();
         ScheduleCallHere(i.callback);
-        i.callback = 0;
+        i.callback = nullptr;
     }
 
     notifying = false;
@@ -411,7 +411,7 @@ void Adaptation::Icap::ServiceRep::noteTimeToNotify()
 void Adaptation::Icap::ServiceRep::callWhenAvailable(AsyncCall::Pointer &cb, bool priority)
 {
     debugs(93,8, "ICAPServiceRep::callWhenAvailable");
-    Must(cb!=NULL);
+    Must(cb!=nullptr);
     Must(up());
     Must(!theIdleConns->count()); // or we should not be waiting
 
@@ -428,7 +428,7 @@ void Adaptation::Icap::ServiceRep::callWhenAvailable(AsyncCall::Pointer &cb, boo
 
 void Adaptation::Icap::ServiceRep::callWhenReady(AsyncCall::Pointer &cb)
 {
-    Must(cb!=NULL);
+    Must(cb!=nullptr);
 
     debugs(93,5, HERE << "Adaptation::Icap::Service is asked to call " << *cb <<
            " when ready " << status());
@@ -468,7 +468,7 @@ void Adaptation::Icap::ServiceRep::changeOptions(Adaptation::Icap::Options *newO
     delete theOptions;
     theOptions = newOptions;
     theSessionFailures.clear();
-    isSuspended = 0;
+    isSuspended = nullptr;
     theLastUpdate = squid_curtime;
 
     checkOptions();
@@ -477,7 +477,7 @@ void Adaptation::Icap::ServiceRep::changeOptions(Adaptation::Icap::Options *newO
 
 void Adaptation::Icap::ServiceRep::checkOptions()
 {
-    if (theOptions == NULL)
+    if (theOptions == nullptr)
         return;
 
     if (!theOptions->valid()) {
@@ -494,7 +494,7 @@ void Adaptation::Icap::ServiceRep::checkOptions()
     if (!theOptions->methods.empty()) {
         bool method_found = false;
         String method_list;
-        std::vector <ICAP::Method>::iterator iter = theOptions->methods.begin();
+        auto iter = theOptions->methods.begin();
 
         while (iter != theOptions->methods.end()) {
 
@@ -519,7 +519,7 @@ void Adaptation::Icap::ServiceRep::checkOptions()
     /*
      *  Check the ICAP server's date header for clock skew
      */
-    const int skew = (int)(theOptions->timestamp() - squid_curtime);
+    const auto skew = (int)(theOptions->timestamp() - squid_curtime);
     if (abs(skew) > theOptions->ttl()) {
         // TODO: If skew is negative, the option will be considered down
         // because of stale options. We should probably change this.
@@ -550,7 +550,7 @@ void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(const Answer &answer)
 
     if (answer.kind == Answer::akError) {
         debugs(93,3, HERE << "failed to fetch options " << status());
-        handleNewOptions(0);
+        handleNewOptions(nullptr);
         return;
     }
 
@@ -560,8 +560,8 @@ void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(const Answer &answer)
 
     debugs(93,5, HERE << "is interpreting new options " << status());
 
-    Adaptation::Icap::Options *newOptions = NULL;
-    if (const HttpReply *r = dynamic_cast<const HttpReply*>(msg)) {
+    Adaptation::Icap::Options *newOptions = nullptr;
+    if (const auto *r = dynamic_cast<const HttpReply*>(msg)) {
         newOptions = new Adaptation::Icap::Options;
         newOptions->configure(r);
     } else {
@@ -578,7 +578,7 @@ void Adaptation::Icap::ServiceRep::callException(const std::exception &e)
     clearAdaptation(theOptionsFetcher);
     debugs(93,2, "ICAP probably failed to fetch options (" << e.what() <<
            ")" << status());
-    handleNewOptions(0);
+    handleNewOptions(nullptr);
 }
 
 void Adaptation::Icap::ServiceRep::handleNewOptions(Adaptation::Icap::Options *newOptions)
diff --git a/src/adaptation/icap/Xaction.cc b/src/adaptation/icap/Xaction.cc
index cb15486..feeca98 100644
--- a/src/adaptation/icap/Xaction.cc
+++ b/src/adaptation/icap/Xaction.cc
@@ -76,24 +76,24 @@ CBDATA_NAMESPACED_CLASS_INIT(Ssl, IcapPeerConnector);
 Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::ServiceRep::Pointer &aService):
     AsyncJob(aTypeName),
     Adaptation::Initiate(aTypeName),
-    icapRequest(NULL),
-    icapReply(NULL),
+    icapRequest(nullptr),
+    icapReply(nullptr),
     attempts(0),
-    connection(NULL),
+    connection(nullptr),
     theService(aService),
     commEof(false),
     reuseConnection(true),
     isRetriable(true),
     isRepeatable(true),
     ignoreLastWrite(false),
-    stopReason(NULL),
-    connector(NULL),
-    reader(NULL),
-    writer(NULL),
-    closer(NULL),
+    stopReason(nullptr),
+    connector(nullptr),
+    reader(nullptr),
+    writer(nullptr),
+    closer(nullptr),
     alep(new AccessLogEntry),
     al(*alep),
-    cs(NULL)
+    cs(nullptr)
 {
     debugs(93,3, typeName << " constructed, this=" << this <<
            " [icapx" << id << ']'); // we should not call virtual status() here
@@ -121,7 +121,7 @@ Adaptation::Icap::Xaction::masterLogEntry()
 Adaptation::Icap::ServiceRep &
 Adaptation::Icap::Xaction::service()
 {
-    Must(theService != NULL);
+    Must(theService != nullptr);
     return *theService;
 }
 
@@ -147,7 +147,7 @@ void Adaptation::Icap::Xaction::start()
 static void
 icapLookupDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
-    Adaptation::Icap::Xaction *xa = static_cast<Adaptation::Icap::Xaction *>(data);
+    auto *xa = static_cast<Adaptation::Icap::Xaction *>(data);
     xa->dnsLookupDone(ia);
 }
 
@@ -194,7 +194,7 @@ Adaptation::Icap::Xaction::dnsLookupDone(const ipcache_addrs *ia)
 {
     Adaptation::Icap::ServiceRep &s = service();
 
-    if (ia == NULL) {
+    if (ia == nullptr) {
         debugs(44, DBG_IMPORTANT, "ICAP: Unknown service host: " << s.cfg().host);
 
 #if WHEN_IPCACHE_NBGETHOSTBYNAME_USES_ASYNC_CALLS
@@ -218,7 +218,7 @@ Adaptation::Icap::Xaction::dnsLookupDone(const ipcache_addrs *ia)
     connection = new Comm::Connection;
     connection->remote = ia->in_addrs[ia->cur];
     connection->remote.port(s.cfg().port);
-    getOutgoingAddress(NULL, connection);
+    getOutgoingAddress(nullptr, connection);
 
     // TODO: service bypass status may differ from that of a transaction
     typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> ConnectDialer;
@@ -246,9 +246,9 @@ void Adaptation::Icap::Xaction::closeConnection()
 {
     if (haveConnection()) {
 
-        if (closer != NULL) {
+        if (closer != nullptr) {
             comm_remove_close_handler(connection->fd, closer);
-            closer = NULL;
+            closer = nullptr;
         }
 
         cancelRead(); // may not work
@@ -268,25 +268,25 @@ void Adaptation::Icap::Xaction::closeConnection()
         Adaptation::Icap::ServiceRep &s = service();
         s.putConnection(connection, reuseConnection, reset, status());
 
-        writer = NULL;
-        reader = NULL;
-        connector = NULL;
-        connection = NULL;
+        writer = nullptr;
+        reader = nullptr;
+        connector = nullptr;
+        connection = nullptr;
     }
 }
 
 // connection with the ICAP service established
 void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
 {
-    cs = NULL;
+    cs = nullptr;
 
     if (io.flag == Comm::TIMEOUT) {
         handleCommTimedout();
         return;
     }
 
-    Must(connector != NULL);
-    connector = NULL;
+    Must(connector != nullptr);
+    connector = nullptr;
 
     if (io.flag != Comm::OK)
         dieOnConnectionFailure(); // throws
@@ -344,8 +344,8 @@ void Adaptation::Icap::Xaction::scheduleWrite(MemBuf &buf)
 
 void Adaptation::Icap::Xaction::noteCommWrote(const CommIoCbParams &io)
 {
-    Must(writer != NULL);
-    writer = NULL;
+    Must(writer != nullptr);
+    writer = nullptr;
 
     if (ignoreLastWrite) {
         // a hack due to comm inability to cancel a pending write
@@ -371,7 +371,7 @@ void Adaptation::Icap::Xaction::handleCommTimedout()
            theService->cfg().methodStr() << " " <<
            theService->cfg().uri << status());
     reuseConnection = false;
-    const bool whileConnecting = connector != NULL;
+    const bool whileConnecting = connector != nullptr;
     if (whileConnecting) {
         assert(!haveConnection());
         theService->noteConnectionFailed("timedout");
@@ -385,11 +385,11 @@ void Adaptation::Icap::Xaction::handleCommTimedout()
 // unexpected connection close while talking to the ICAP service
 void Adaptation::Icap::Xaction::noteCommClosed(const CommCloseCbParams &)
 {
-    if (securer != NULL) {
+    if (securer != nullptr) {
         securer->cancel("Connection closed before SSL negotiation finished");
-        securer = NULL;
+        securer = nullptr;
     }
-    closer = NULL;
+    closer = nullptr;
     handleCommClosed();
 }
 
@@ -424,7 +424,7 @@ void Adaptation::Icap::Xaction::updateTimeout()
 {
     Must(haveConnection());
 
-    if (reader != NULL || writer != NULL) {
+    if (reader != nullptr || writer != nullptr) {
         // restart the timeout before each I/O
         // XXX: why does Config.Timeout lacks a write timeout?
         // TODO: service bypass status may differ from that of a transaction
@@ -453,8 +453,8 @@ void Adaptation::Icap::Xaction::scheduleRead()
 // comm module read a portion of the ICAP response for us
 void Adaptation::Icap::Xaction::noteCommRead(const CommIoCbParams &io)
 {
-    Must(reader != NULL);
-    reader = NULL;
+    Must(reader != nullptr);
+    reader = nullptr;
 
     Must(io.flag == Comm::OK);
 
@@ -513,10 +513,10 @@ void Adaptation::Icap::Xaction::noteCommRead(const CommIoCbParams &io)
 
 void Adaptation::Icap::Xaction::cancelRead()
 {
-    if (reader != NULL) {
+    if (reader != nullptr) {
         Must(haveConnection());
         Comm::ReadCancel(connection->fd, reader);
-        reader = NULL;
+        reader = nullptr;
     }
 }
 
@@ -566,7 +566,7 @@ bool Adaptation::Icap::Xaction::doneWithIo() const
 
 bool Adaptation::Icap::Xaction::haveConnection() const
 {
-    return connection != NULL && connection->isOpen();
+    return connection != nullptr && connection->isOpen();
 }
 
 // initiator aborted
@@ -603,7 +603,7 @@ void Adaptation::Icap::Xaction::swanSong()
     if (cs.valid()) {
         debugs(93,6, HERE << id << " about to notify ConnOpener!");
         CallJobHere(93, 3, cs, Comm::ConnOpener, noteAbort);
-        cs = NULL;
+        cs = nullptr;
         service().noteConnectionFailed("abort");
     }
 
@@ -623,7 +623,7 @@ void Adaptation::Icap::Xaction::tellQueryAborted()
     if (theInitiator.set()) {
         Adaptation::Icap::XactAbortInfo abortInfo(icapRequest, icapReply.getRaw(),
                 retriable(), repeatable());
-        Launcher *launcher = dynamic_cast<Launcher*>(theInitiator.get());
+        auto *launcher = dynamic_cast<Launcher*>(theInitiator.get());
         // launcher may be nil if initiator is invalid
         CallJobHere1(91,5, CbcPointer<Launcher>(launcher),
                      Launcher, noteXactAbort, abortInfo);
@@ -654,7 +654,7 @@ void Adaptation::Icap::Xaction::finalizeLogInfo()
 
     al.icap.request = icapRequest;
     HTTPMSGLOCK(al.icap.request);
-    if (icapReply != NULL) {
+    if (icapReply != nullptr) {
         al.icap.reply = icapReply.getRaw();
         HTTPMSGLOCK(al.icap.reply);
         al.icap.resStatus = icapReply->sline.status();
@@ -681,10 +681,10 @@ void Adaptation::Icap::Xaction::fillPendingStatus(MemBuf &buf) const
     if (haveConnection()) {
         buf.appendf("FD %d", connection->fd);
 
-        if (writer != NULL)
+        if (writer != nullptr)
             buf.append("w", 1);
 
-        if (reader != NULL)
+        if (reader != nullptr)
             buf.append("r", 1);
 
         buf.append(";", 1);
@@ -696,7 +696,7 @@ void Adaptation::Icap::Xaction::fillDoneStatus(MemBuf &buf) const
     if (haveConnection() && commEof)
         buf.appendf("Comm(%d)", connection->fd);
 
-    if (stopReason != NULL)
+    if (stopReason != nullptr)
         buf.append("Stopped", 7);
 }
 
@@ -713,10 +713,10 @@ Ssl::IcapPeerConnector::initialize(Security::SessionPointer &serverSession)
 
     assert(!icapService->cfg().secure.sslDomain.isEmpty());
 #if USE_OPENSSL
-    SBuf *host = new SBuf(icapService->cfg().secure.sslDomain);
+    auto *host = new SBuf(icapService->cfg().secure.sslDomain);
     SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
 
-    ACLFilledChecklist *check = static_cast<ACLFilledChecklist *>(SSL_get_ex_data(serverSession.get(), ssl_ex_index_cert_error_check));
+    auto *check = static_cast<ACLFilledChecklist *>(SSL_get_ex_data(serverSession.get(), ssl_ex_index_cert_error_check));
     if (check)
         check->dst_peer_name = *host;
 #endif
@@ -738,19 +738,19 @@ Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
 void
 Adaptation::Icap::Xaction::handleSecuredPeer(Security::EncryptorAnswer &answer)
 {
-    Must(securer != NULL);
-    securer = NULL;
+    Must(securer != nullptr);
+    securer = nullptr;
 
-    if (closer != NULL) {
-        if (answer.conn != NULL)
+    if (closer != nullptr) {
+        if (answer.conn != nullptr)
             comm_remove_close_handler(answer.conn->fd, closer);
         else
             closer->cancel("securing completed");
-        closer = NULL;
+        closer = nullptr;
     }
 
     if (answer.error.get()) {
-        if (answer.conn != NULL)
+        if (answer.conn != nullptr)
             answer.conn->close();
         debugs(93, 2, typeName <<
                " TLS negotiation to " << service().cfg().uri << " failed");
diff --git a/src/adaptation/icap/icap_log.cc b/src/adaptation/icap/icap_log.cc
index 77b1d86..03209e7 100644
--- a/src/adaptation/icap/icap_log.cc
+++ b/src/adaptation/icap/icap_log.cc
@@ -42,7 +42,7 @@ icapLogClose()
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
             logfileClose(log->logfile);
-            log->logfile = NULL;
+            log->logfile = nullptr;
         }
     }
 }
@@ -60,7 +60,7 @@ icapLogRotate()
 void icapLogLog(AccessLogEntry::Pointer &al)
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
-        ACLFilledChecklist checklist(NULL, al->adapted_request, NULL);
+        ACLFilledChecklist checklist(nullptr, al->adapted_request, nullptr);
         if (al->reply) {
             checklist.reply = al->reply;
             HTTPMSGLOCK(checklist.reply);
