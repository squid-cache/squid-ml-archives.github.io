=== modified file 'src/adaptation/icap/Xaction.cc'
--- src/adaptation/icap/Xaction.cc	2017-02-16 11:51:56 +0000
+++ src/adaptation/icap/Xaction.cc	2017-04-21 11:13:20 +0000
@@ -712,13 +712,14 @@
         return false;
 
     assert(!icapService->cfg().secure.sslDomain.isEmpty());
+    auto *extras = Security::Extras::From(serverSession);
+    assert(extras);
+    extras->serverName = icapService->cfg().secure.sslDomain;
+
 #if USE_OPENSSL
-    SBuf *host = new SBuf(icapService->cfg().secure.sslDomain);
-    SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
-
     ACLFilledChecklist *check = static_cast<ACLFilledChecklist *>(SSL_get_ex_data(serverSession.get(), ssl_ex_index_cert_error_check));
     if (check)
-        check->dst_peer_name = *host;
+        check->dst_peer_name = extras->serverName;
 #endif
 
     Security::SetSessionResumeData(serverSession, icapService->sslSession);

=== modified file 'src/globals.h'
--- src/globals.h	2017-01-01 00:12:22 +0000
+++ src/globals.h	2017-04-19 06:38:34 +0000
@@ -98,7 +98,6 @@
 extern unsigned int WIN32_run_mode;     /* _WIN_SQUID_RUN_MODE_INTERACTIVE */
 #endif
 
-extern int ssl_ex_index_server; /* -1 */
 extern int ssl_ctx_ex_index_dont_verify_domain; /* -1 */
 extern int ssl_ex_index_cert_error_check;   /* -1 */
 extern int ssl_ex_index_ssl_error_detail;      /* -1 */

=== modified file 'src/security/BlindPeerConnector.cc'
--- src/security/BlindPeerConnector.cc	2017-01-12 13:26:45 +0000
+++ src/security/BlindPeerConnector.cc	2017-04-21 11:13:35 +0000
@@ -37,22 +37,19 @@
         return false;
     }
 
+    auto *extras = Security::Extras::From(serverSession);
+    assert(extras);
+
     if (const CachePeer *peer = serverConnection()->getPeer()) {
         assert(peer);
 
         // NP: domain may be a raw-IP but it is now always set
         assert(!peer->secure.sslDomain.isEmpty());
-
-#if USE_OPENSSL
-        // const loss is okay here, ssl_ex_index_server is only read and not assigned a destructor
-        SBuf *host = new SBuf(peer->secure.sslDomain);
-        SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
+        extras->serverName = peer->secure.sslDomain;
 
         Security::SetSessionResumeData(serverSession, peer->sslSession);
     } else {
-        SBuf *hostName = new SBuf(request->url.host());
-        SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, (void*)hostName);
-#endif
+        extras->serverName = request->url.host();
     }
 
     debugs(83, 5, "success");

=== modified file 'src/security/PeerConnector.cc'
--- src/security/PeerConnector.cc	2017-02-15 03:10:55 +0000
+++ src/security/PeerConnector.cc	2017-04-22 10:49:44 +0000
@@ -233,8 +233,10 @@
         // Ssl::CertValidationRequest object used only to pass data to
         // Ssl::CertValidationHelper::submit method.
         validationRequest.ssl = session;
-        if (SBuf *dName = (SBuf *)SSL_get_ex_data(session.get(), ssl_ex_index_server))
-            validationRequest.domainName = dName->c_str();
+        if (auto *extras = Security::Extras::From(session)) {
+            if (!extras->serverName.isEmpty())
+                validationRequest.domainName = extras->serverName.c_str();
+        }
         if (Security::CertErrors *errs = static_cast<Security::CertErrors *>(SSL_get_ex_data(session.get(), ssl_ex_index_ssl_errors)))
             // validationRequest disappears on return so no need to cbdataReference
             validationRequest.errors = errs;
@@ -277,8 +279,8 @@
 
     if (Debug::Enabled(83, 5)) {
         Security::SessionPointer ssl(fd_table[serverConnection()->fd].ssl);
-        SBuf *server = static_cast<SBuf *>(SSL_get_ex_data(ssl.get(), ssl_ex_index_server));
-        debugs(83,5, RawPointer("host", server) << " cert validation result: " << validationResponse->resultCode);
+        const auto *extras = Security::Extras::From(ssl);
+        debugs(83,5, "host=" << extras->serverName << " cert validation result: " << validationResponse->resultCode);
     }
 
     if (validationResponse->resultCode == ::Helper::Error) {

=== modified file 'src/ssl/PeekingPeerConnector.cc'
--- src/ssl/PeekingPeerConnector.cc	2017-02-05 05:57:32 +0000
+++ src/ssl/PeekingPeerConnector.cc	2017-04-22 03:37:18 +0000
@@ -143,27 +143,26 @@
         // client connection is required in the case we need to splice
         // or terminate client and server connections
         assert(clientConn != NULL);
-        SBuf *hostName = NULL;
+
+        auto *extras = Security::Extras::From(serverSession);
+        SBuf &hostName = extras->serverName;
 
         //Enable Status_request TLS extension, required to bump some clients
         SSL_set_tlsext_status_type(serverSession.get(), TLSEXT_STATUSTYPE_ocsp);
 
         const Security::TlsDetails::Pointer details = csd->tlsParser.details;
         if (details && !details->serverName.isEmpty())
-            hostName = new SBuf(details->serverName);
+            hostName = details->serverName;
 
-        if (!hostName) {
+        if (hostName.isEmpty()) {
             // While we are peeking at the certificate, we may not know the server
             // name that the client will request (after interception or CONNECT)
             // unless it was the CONNECT request with a user-typed address.
             const bool isConnectRequest = !csd->port->flags.isIntercepted();
             if (!request->flags.sslPeek || isConnectRequest)
-                hostName = new SBuf(request->url.host());
+                hostName = request->url.host();
         }
 
-        if (hostName)
-            SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, (void*)hostName);
-
         Must(!csd->serverBump() || csd->serverBump()->step <= Ssl::bumpStep2);
         if (csd->sslBumpMode == Ssl::bumpPeek || csd->sslBumpMode == Ssl::bumpStare) {
             auto clientSession = fd_table[clientConn->fd].ssl.get();
@@ -189,10 +188,10 @@
             // to the origin server and we know the server host name.
             const char *sniServer = NULL;
             const bool redirected = request->flags.redirected && ::Config.onoff.redir_rewrites_host;
-            if (!hostName || redirected)
+            if (hostName.isEmpty() || redirected)
                 sniServer = !request->url.hostIsNumeric() ? request->url.host() : NULL;
             else
-                sniServer = hostName->c_str();
+                sniServer = hostName.c_str();
 
             if (sniServer)
                 Ssl::setClientSNI(serverSession.get(), sniServer);

=== modified file 'src/ssl/support.cc'
--- src/ssl/support.cc	2017-02-05 05:57:32 +0000
+++ src/ssl/support.cc	2017-04-21 11:12:24 +0000
@@ -253,7 +253,8 @@
     char buffer[256] = "";
     SSL *ssl = (SSL *)X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
     SSL_CTX *sslctx = SSL_get_SSL_CTX(ssl);
-    SBuf *server = (SBuf *)SSL_get_ex_data(ssl, ssl_ex_index_server);
+    Security::SessionPointer session(ssl, [](SSL *){/* do not destroy */});
+    auto *extras = Security::Extras::From(session);
     void *dont_verify_domain = SSL_CTX_get_ex_data(sslctx, ssl_ctx_ex_index_dont_verify_domain);
     ACLChecklist *check = (ACLChecklist*)SSL_get_ex_data(ssl, ssl_ex_index_cert_error_check);
     X509 *peeked_cert = (X509 *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_peeked_cert);
@@ -283,9 +284,9 @@
         debugs(83, 5, "SSL Certificate signature OK: " << buffer);
 
         // Check for domain mismatch only if the current certificate is the peer certificate.
-        if (!dont_verify_domain && server && peer_cert.get() == X509_STORE_CTX_get_current_cert(ctx)) {
-            if (!Ssl::checkX509ServerValidity(peer_cert.get(), server->c_str())) {
-                debugs(83, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " << buffer << " does not match domainname " << server);
+        if (!dont_verify_domain && !extras->serverName.isEmpty() && peer_cert.get() == X509_STORE_CTX_get_current_cert(ctx)) {
+            if (!Ssl::checkX509ServerValidity(peer_cert.get(), extras->serverName.c_str())) {
+                debugs(83, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " << buffer << " does not match domainname " << extras->serverName);
                 ok = 0;
                 error_no = SQUID_X509_V_ERR_DOMAIN_MISMATCH;
             }
@@ -450,15 +451,6 @@
     X509_free(cert);
 }
 
-// "free" function for SBuf
-static void
-ssl_free_SBuf(void *, void *ptr, CRYPTO_EX_DATA *,
-              int, long, void *)
-{
-    SBuf  *buf = static_cast <SBuf *>(ptr);
-    delete buf;
-}
-
 void
 Ssl::Initialize(void)
 {
@@ -491,7 +483,6 @@
     if (!Ssl::DefaultSignHash)
         fatalf("Sign hash '%s' is not supported\n", defName);
 
-    ssl_ex_index_server = SSL_get_ex_new_index(0, (void *) "server", NULL, NULL, ssl_free_SBuf);
     ssl_ctx_ex_index_dont_verify_domain = SSL_CTX_get_ex_new_index(0, (void *) "dont_verify_domain", NULL, NULL, NULL);
     ssl_ex_index_cert_error_check = SSL_get_ex_new_index(0, (void *) "cert_error_check", NULL, &ssl_dupAclChecklist, &ssl_freeAclChecklist);
     ssl_ex_index_ssl_error_detail = SSL_get_ex_new_index(0, (void *) "ssl_error_detail", NULL, NULL, &ssl_free_ErrorDetail);

