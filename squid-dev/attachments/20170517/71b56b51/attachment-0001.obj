diff -U 30 --show-c-function -r ./src/ssl/PeerConnector.cc ../../BUILD_PATCHED/squid-3.5.20/src/ssl/PeerConnector.cc
--- ./src/ssl/PeerConnector.cc	2016-07-01 11:37:50.000000000 +0000
+++ ../../BUILD_PATCHED/squid-3.5.20/src/ssl/PeerConnector.cc	2017-05-17 17:42:01.954616703 +0000
@@ -624,60 +624,68 @@ Ssl::PeerConnector::handleNegotiateError
 
         // If we are in peek-and-splice mode and still we did not write to
         // server yet, try to see if we should splice.
         // In this case the connection can be saved.
         // If the checklist decision is do not splice a new error will
         // occure in the next SSL_connect call, and we will fail again.
         // Abort on certificate validation errors to avoid splicing and
         // thus hiding them.
         // Abort if no certificate found probably because of malformed or
         // unsupported server Hello message (TODO: make configurable).
 #if 1
         if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) &&
                 (srvBio->bumpMode() == Ssl::bumpPeek  || srvBio->bumpMode() == Ssl::bumpStare) && srvBio->holdWrite()) {
             Ssl::X509_Pointer serverCert(SSL_get_peer_certificate(ssl));
             if (serverCert.get()) {
                 debugs(81, 3, "Error ("  << ERR_error_string(ssl_lib_error, NULL) <<  ") but, hold write on SSL connection on FD " << fd);
                 checkForPeekAndSplice();
                 return;
             }
         }
 #endif
 
         // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
         if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
             sysErrNo = errno;
 
         debugs(83, DBG_IMPORTANT, "Error negotiating SSL on FD " << fd <<
                ": " << ERR_error_string(ssl_lib_error, NULL) << " (" <<
                ssl_error << "/" << ret << "/" << errno << ")");
 
+        // HACK - We don't care if openssl doesn't recognise a newer cipher
+        // because we are just going to splice the connection.
+        // TODO We need to know if the certificate otherwise validates!
+        if(srvBio->bumpMode() == Ssl::bumpPeek && ERR_GET_REASON(ssl_lib_error) == SSL_R_UNKNOWN_CIPHER_RETURNED) {
+            checkForPeekAndSplice();
+            return;
+        }
+
         break; // proceed to the general error handling code
 
     default:
         break; // no special error handling for all other errors
     }
 
     ErrorState *const anErr = ErrorState::NewForwarding(ERR_SECURE_CONNECT_FAIL, request.getRaw());
     anErr->xerrno = sysErrNo;
 
     Ssl::ErrorDetail *errFromFailure = (Ssl::ErrorDetail *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail);
     if (errFromFailure != NULL) {
         // The errFromFailure is attached to the ssl object
         // and will be released when ssl object destroyed.
         // Copy errFromFailure to a new Ssl::ErrorDetail object
         anErr->detail = new Ssl::ErrorDetail(*errFromFailure);
     } else {
         // server_cert can be NULL here
         X509 *server_cert = SSL_get_peer_certificate(ssl);
         anErr->detail = new Ssl::ErrorDetail(SQUID_ERR_SSL_HANDSHAKE, server_cert, NULL);
         X509_free(server_cert);
     }
 
     if (ssl_lib_error != SSL_ERROR_NONE)
         anErr->detail->setLibError(ssl_lib_error);
 
     if (request->clientConnectionManager.valid()) {
         // remember the server certificate from the ErrorDetail object
         if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump())
             serverBump->serverCert.resetAndLock(anErr->detail->peerCert());
 
