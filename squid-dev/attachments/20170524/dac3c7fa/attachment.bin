Adds support for --long-acl-options

This patch adds support for --long-acl-options. The old single-letter
ACL "flags" code was refactored to support long option
names (with option-specific value types) without significant
per-ACL-object performance/RAM overheads and without creating a global
registry for all possible options. This refactoring (unexpectedly)
resulted in removal of a lot of unreliable static initialization code.

Refactoring fixed ACL flags parsing code that was dangerously misinterpreting
-i and +i flags in several contexts. For example, each of the three cases
below was misinterpreted as if three domains were configured (e.g., "+i",
"-z", and "example.com") on each line instead of one domain ("example.com"):

        acl parsedAsThreeDomains dstdomain +i -i .example.com
        acl parsedAsThreeDomains dstdomain -i +i .example.com
        acl parsedAsThreeDomains dstdomain +i -z .example.com

TODO: Finish ACL::clone() removal. Then consider removing any unused
ACLData::clone() and associated ACL/ACLData copying methods.

This is a Measurement Factory project.

=== modified file 'src/AclRegs.cc'
--- src/AclRegs.cc	2017-01-30 12:46:15 +0000
+++ src/AclRegs.cc	2017-05-14 17:55:12 +0000
@@ -1,246 +1,192 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 
-/** This file exists to provide satic registration code to executables
-    that need ACLs. We cannot place this code in acl/lib*.la because it
-    does not get linked in, because nobody is using these classes by name.
-*/
-
 #if USE_ADAPTATION
 #include "acl/AdaptationService.h"
 #include "acl/AdaptationServiceData.h"
 #endif
 #include "acl/AllOf.h"
 #include "acl/AnnotateClient.h"
 #include "acl/AnnotateTransaction.h"
 #include "acl/AnnotationData.h"
 #include "acl/AnyOf.h"
 #if USE_SQUID_EUI
 #include "acl/Arp.h"
 #include "acl/Eui64.h"
 #endif
 #if USE_OPENSSL
 #include "acl/AtStep.h"
 #include "acl/AtStepData.h"
 #endif
 #include "acl/Asn.h"
-#include "acl/Browser.h"
 #include "acl/Checklist.h"
 #include "acl/ConnectionsEncrypted.h"
 #include "acl/Data.h"
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationDomain.h"
 #include "acl/DestinationIp.h"
 #include "acl/DomainData.h"
 #if USE_AUTH
 #include "acl/ExtUser.h"
 #endif
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "acl/HierCode.h"
 #include "acl/HierCodeData.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/HttpRepHeader.h"
 #include "acl/HttpReqHeader.h"
 #include "acl/HttpStatus.h"
 #include "acl/IntRange.h"
 #include "acl/Ip.h"
 #include "acl/LocalIp.h"
 #include "acl/LocalPort.h"
 #include "acl/MaxConnection.h"
 #include "acl/Method.h"
 #include "acl/MethodData.h"
 #include "acl/MyPortName.h"
 #include "acl/Note.h"
 #include "acl/NoteData.h"
 #include "acl/PeerName.h"
 #include "acl/Protocol.h"
 #include "acl/ProtocolData.h"
 #include "acl/Random.h"
-#include "acl/Referer.h"
 #include "acl/RegexData.h"
 #include "acl/ReplyHeaderStrategy.h"
 #include "acl/ReplyMimeType.h"
 #include "acl/RequestHeaderStrategy.h"
 #include "acl/RequestMimeType.h"
 #include "acl/SourceAsn.h"
 #include "acl/SourceDomain.h"
 #include "acl/SourceIp.h"
 #include "acl/SquidError.h"
 #include "acl/SquidErrorData.h"
 #if USE_OPENSSL
 #include "acl/Certificate.h"
 #include "acl/CertificateData.h"
 #include "acl/ServerName.h"
 #include "acl/SslError.h"
 #include "acl/SslErrorData.h"
 #endif
 #include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "acl/StringData.h"
 #if USE_OPENSSL
 #include "acl/ServerCertificate.h"
 #endif
 #include "acl/Tag.h"
 #include "acl/Time.h"
 #include "acl/TimeData.h"
 #include "acl/Url.h"
 #include "acl/UrlLogin.h"
 #include "acl/UrlPath.h"
 #include "acl/UrlPort.h"
 #include "acl/UserData.h"
+#include "AclRegs.h"
 #if USE_AUTH
 #include "auth/AclMaxUserIp.h"
 #include "auth/AclProxyAuth.h"
 #endif
 #include "base/RegexPattern.h"
+#include "ExternalACL.h"
 #if USE_IDENT
 #include "ident/AclIdent.h"
 #endif
+#if SQUID_SNMP
+#include "snmp_core.h"
+#endif
 
-ACL::Prototype ACLBrowser::RegistryProtoype(&ACLBrowser::RegistryEntry_, "browser");
-ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>::Instance(), "browser");
-ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
-ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&ACLDestinationDomain::LiteralRegistryEntry_, "dstdomain");
-ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain", DestinationDomainFlags);
-ACL::Prototype ACLDestinationDomain::RegexRegistryProtoype(&ACLDestinationDomain::RegexRegistryEntry_, "dstdom_regex");
-ACLFlag  DestinationDomainRegexFlags[] = {ACL_F_NO_LOOKUP, ACL_F_REGEX_CASE, ACL_F_END};
-ACLStrategised<char const *> ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,"dstdom_regex", DestinationDomainRegexFlags);
-ACL::Prototype ACLDestinationIP::RegistryProtoype(&ACLDestinationIP::RegistryEntry_, "dst");
-ACLDestinationIP ACLDestinationIP::RegistryEntry_;
-#if USE_AUTH
-ACL::Prototype ACLExtUser::UserRegistryProtoype(&ACLExtUser::UserRegistryEntry_, "ext_user");
-ACLExtUser ACLExtUser::UserRegistryEntry_(new ACLUserData, "ext_user");
-ACL::Prototype ACLExtUser::RegexRegistryProtoype(&ACLExtUser::RegexRegistryEntry_, "ext_user_regex" );
-ACLExtUser ACLExtUser::RegexRegistryEntry_(new ACLRegexData, "ext_user_regex");
-#endif
-ACL::Prototype ACLHierCode::RegistryProtoype(&ACLHierCode::RegistryEntry_, "hier_code");
-ACLStrategised<hier_code> ACLHierCode::RegistryEntry_(new ACLHierCodeData, ACLHierCodeStrategy::Instance(), "hier_code");
-ACL::Prototype ACLHTTPRepHeader::RegistryProtoype(&ACLHTTPRepHeader::RegistryEntry_, "rep_header");
-ACLStrategised<HttpHeader*> ACLHTTPRepHeader::RegistryEntry_(new ACLHTTPHeaderData, ACLHTTPRepHeaderStrategy::Instance(), "rep_header");
-ACL::Prototype ACLHTTPReqHeader::RegistryProtoype(&ACLHTTPReqHeader::RegistryEntry_, "req_header");
-ACLStrategised<HttpHeader*> ACLHTTPReqHeader::RegistryEntry_(new ACLHTTPHeaderData, ACLHTTPReqHeaderStrategy::Instance(), "req_header");
-ACL::Prototype ACLHTTPStatus::RegistryProtoype(&ACLHTTPStatus::RegistryEntry_, "http_status");
-ACLHTTPStatus ACLHTTPStatus::RegistryEntry_("http_status");
-ACL::Prototype ACLMaxConnection::RegistryProtoype(&ACLMaxConnection::RegistryEntry_, "maxconn");
-ACLMaxConnection ACLMaxConnection::RegistryEntry_("maxconn");
-ACL::Prototype ACLMethod::RegistryProtoype(&ACLMethod::RegistryEntry_, "method");
-ACLStrategised<HttpRequestMethod> ACLMethod::RegistryEntry_(new ACLMethodData, ACLMethodStrategy::Instance(), "method");
-ACL::Prototype ACLLocalIP::RegistryProtoype(&ACLLocalIP::RegistryEntry_, "localip");
-ACLLocalIP ACLLocalIP::RegistryEntry_;
-ACL::Prototype ACLLocalPort::RegistryProtoype(&ACLLocalPort::RegistryEntry_, "localport");
-ACLStrategised<int> ACLLocalPort::RegistryEntry_(new ACLIntRange, ACLLocalPortStrategy::Instance(), "localport");
-ACL::Prototype ACLMyPortName::RegistryProtoype(&ACLMyPortName::RegistryEntry_, "myportname");
-ACLStrategised<const char *> ACLMyPortName::RegistryEntry_(new ACLStringData, ACLMyPortNameStrategy::Instance(), "myportname");
-ACL::Prototype ACLPeerName::RegistryProtoype(&ACLPeerName::RegistryEntry_, "peername");
-ACLStrategised<const char *> ACLPeerName::RegistryEntry_(new ACLStringData, ACLPeerNameStrategy::Instance(), "peername");
-ACL::Prototype ACLPeerName::RegexRegistryProtoype(&ACLPeerName::RegexRegistryEntry_, "peername_regex");
-ACLStrategised<char const *> ACLPeerName::RegexRegistryEntry_(new ACLRegexData, ACLPeerNameStrategy::Instance(), "peername_regex");
-ACL::Prototype ACLProtocol::RegistryProtoype(&ACLProtocol::RegistryEntry_, "proto");
-ACLStrategised<AnyP::ProtocolType> ACLProtocol::RegistryEntry_(new ACLProtocolData, ACLProtocolStrategy::Instance(), "proto");
-ACL::Prototype ACLRandom::RegistryProtoype(&ACLRandom::RegistryEntry_, "random");
-ACLRandom ACLRandom::RegistryEntry_("random");
-ACL::Prototype ACLReferer::RegistryProtoype(&ACLReferer::RegistryEntry_, "referer_regex");
-ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::REFERER>::Instance(), "referer_regex");
-ACL::Prototype ACLReplyMIMEType::RegistryProtoype(&ACLReplyMIMEType::RegistryEntry_, "rep_mime_type");
-ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "rep_mime_type");
-ACL::Prototype ACLRequestMIMEType::RegistryProtoype(&ACLRequestMIMEType::RegistryEntry_, "req_mime_type");
-ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "req_mime_type");
-ACL::Prototype ACLSourceDomain::LiteralRegistryProtoype(&ACLSourceDomain::LiteralRegistryEntry_, "srcdomain");
-ACLStrategised<char const *> ACLSourceDomain::LiteralRegistryEntry_(new ACLDomainData, ACLSourceDomainStrategy::Instance(), "srcdomain");
-ACL::Prototype ACLSourceDomain::RegexRegistryProtoype(&ACLSourceDomain::RegexRegistryEntry_, "srcdom_regex");
-ACLStrategised<char const *> ACLSourceDomain::RegexRegistryEntry_(new ACLRegexData,ACLSourceDomainStrategy::Instance() ,"srcdom_regex");
-ACL::Prototype ACLSourceIP::RegistryProtoype(&ACLSourceIP::RegistryEntry_, "src");
-ACLSourceIP ACLSourceIP::RegistryEntry_;
-ACL::Prototype ACLTime::RegistryProtoype(&ACLTime::RegistryEntry_, "time");
-ACLStrategised<time_t> ACLTime::RegistryEntry_(new ACLTimeData, ACLTimeStrategy::Instance(), "time");
-ACL::Prototype ACLUrl::RegistryProtoype(&ACLUrl::RegistryEntry_, "url_regex");
-ACLStrategised<char const *> ACLUrl::RegistryEntry_(new ACLRegexData, ACLUrlStrategy::Instance(), "url_regex");
-ACL::Prototype ACLUrlLogin::RegistryProtoype(&ACLUrlLogin::RegistryEntry_, "urllogin");
-ACLStrategised<char const *> ACLUrlLogin::RegistryEntry_(new ACLRegexData, ACLUrlLoginStrategy::Instance(), "urllogin");
-ACL::Prototype ACLUrlPath::LegacyRegistryProtoype(&ACLUrlPath::RegistryEntry_, "pattern");
-ACL::Prototype ACLUrlPath::RegistryProtoype(&ACLUrlPath::RegistryEntry_, "urlpath_regex");
-ACLStrategised<char const *> ACLUrlPath::RegistryEntry_(new ACLRegexData, ACLUrlPathStrategy::Instance(), "urlpath_regex");
-ACL::Prototype ACLUrlPort::RegistryProtoype(&ACLUrlPort::RegistryEntry_, "port");
-ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrategy::Instance(), "port");
+// Not in src/acl/ because some of the ACLs it registers are not in src/acl/.
+void
+Acl::Init()
+{
+    /* the registration order does not matter */
+
+    // The explicit return type (ACL*) for lambdas is needed because the type
+    // of the return expression inside lambda is not ACL* but AclFoo* while
+    // Acl::Maker is defined to return ACL*.
+
+    RegisterMaker("all-of", [](TypeName)->ACL* { return new Acl::AllOf; }); // XXX: Add name parameter to ctor
+    RegisterMaker("any-of", [](TypeName)->ACL* { return new Acl::AnyOf; }); // XXX: Add name parameter to ctor
+    RegisterMaker("random", [](TypeName name)->ACL* { return new ACLRandom(name); });
+    RegisterMaker("time", [](TypeName name)->ACL* { return new ACLStrategised<time_t>(new ACLTimeData, new ACLTimeStrategy, name); });
+    RegisterMaker("src_as", [](TypeName name)->ACL* { return new ACLStrategised<Ip::Address>(new ACLASN, new ACLSourceASNStrategy, name); });
+    RegisterMaker("dst_as", [](TypeName name)->ACL* { return new ACLStrategised<Ip::Address>(new ACLASN, new ACLDestinationASNStrategy, name); });
+    RegisterMaker("browser", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>, name); });
+    RegisterMaker("dstdomain", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLDomainData, new ACLDestinationDomainStrategy, name); });
+    RegisterMaker("dstdom_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLDestinationDomainStrategy , name); });
+    RegisterMaker("dst", [](TypeName)->ACL* { return new ACLDestinationIP; }); // XXX: Add name parameter to ctor
+    RegisterMaker("hier_code", [](TypeName name)->ACL* { return new ACLStrategised<hier_code>(new ACLHierCodeData, new ACLHierCodeStrategy, name); });
+    RegisterMaker("rep_header", [](TypeName name)->ACL* { return new ACLStrategised<HttpHeader*>(new ACLHTTPHeaderData, new ACLHTTPRepHeaderStrategy, name); });
+    RegisterMaker("req_header", [](TypeName name)->ACL* { return new ACLStrategised<HttpHeader*>(new ACLHTTPHeaderData, new ACLHTTPReqHeaderStrategy, name); });
+    RegisterMaker("http_status", [](TypeName name)->ACL* { return new ACLHTTPStatus(name); });
+    RegisterMaker("maxconn", [](TypeName name)->ACL* { return new ACLMaxConnection(name); });
+    RegisterMaker("method", [](TypeName name)->ACL* { return new ACLStrategised<HttpRequestMethod>(new ACLMethodData, new ACLMethodStrategy, name); });
+    RegisterMaker("localip", [](TypeName)->ACL* { return new ACLLocalIP; }); // XXX: Add name parameter to ctor
+    RegisterMaker("localport", [](TypeName name)->ACL* { return new ACLStrategised<int>(new ACLIntRange, new ACLLocalPortStrategy, name); });
+    RegisterMaker("myportname", [](TypeName name)->ACL* { return new ACLStrategised<const char *>(new ACLStringData, new ACLMyPortNameStrategy, name); });
+    RegisterMaker("peername", [](TypeName name)->ACL* { return new ACLStrategised<const char *>(new ACLStringData, new ACLPeerNameStrategy, name); });
+    RegisterMaker("peername_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLPeerNameStrategy, name); });
+    RegisterMaker("proto", [](TypeName name)->ACL* { return new ACLStrategised<AnyP::ProtocolType>(new ACLProtocolData, new ACLProtocolStrategy, name); });
+    RegisterMaker("referer_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLRequestHeaderStrategy<Http::HdrType::REFERER>, name); });
+    RegisterMaker("rep_mime_type", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>, name); });
+    RegisterMaker("req_mime_type", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>, name); });
+    RegisterMaker("srcdomain", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLDomainData, new ACLSourceDomainStrategy, name); });
+    RegisterMaker("srcdom_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLSourceDomainStrategy, name); });
+    RegisterMaker("src", [](TypeName)->ACL* { return new ACLSourceIP; }); // XXX: Add name parameter to ctor
+    RegisterMaker("url_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLUrlStrategy, name); });
+    RegisterMaker("urllogin", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLUrlLoginStrategy, name); });
+    RegisterMaker("urlpath_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLUrlPathStrategy, name); });
+    RegisterMaker("port", [](TypeName name)->ACL* { return new ACLStrategised<int>(new ACLIntRange, new ACLUrlPortStrategy, name); });
+    RegisterMaker("external", [](TypeName name)->ACL* { return new ACLExternal(name); });
+    RegisterMaker("squid_error", [](TypeName name)->ACL* { return new ACLStrategised<err_type>(new ACLSquidErrorData, new ACLSquidErrorStrategy, name); });
+    RegisterMaker("connections_encrypted", [](TypeName name)->ACL* { return new Acl::ConnectionsEncrypted(name); });
+    RegisterMaker("tag", [](TypeName name)->ACL* { return new ACLStrategised<const char *>(new ACLStringData, new ACLTagStrategy, name); });
+    RegisterMaker("note", [](TypeName name)->ACL* { return new ACLStrategised<NotePairs::Entry*>(new ACLNoteData, new ACLNoteStrategy, name); });
+    RegisterMaker("annotate_client", [](TypeName name)->ACL* { return new ACLStrategised<NotePairs::Entry*>(new ACLAnnotationData, new ACLAnnotateClientStrategy, name); });
+    RegisterMaker("annotate_transaction", [](TypeName name)->ACL* { return new ACLStrategised<NotePairs::Entry*>(new ACLAnnotationData, new ACLAnnotateTransactionStrategy, name); });
 
 #if USE_OPENSSL
-ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
-ACLStrategised<const Security::CertErrors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
-ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
-ACLStrategised<X509 *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (Ssl::GetX509UserAttribute, "*"), ACLCertificateStrategy::Instance(), "user_cert");
-ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
-ACLStrategised<X509 *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (Ssl::GetX509CAAttribute, "*"), ACLCertificateStrategy::Instance(), "ca_cert");
-ACL::Prototype ACLServerCertificate::X509FingerprintRegistryProtoype(&ACLServerCertificate::X509FingerprintRegistryEntry_, "server_cert_fingerprint");
-ACLStrategised<X509 *> ACLServerCertificate::X509FingerprintRegistryEntry_(new ACLCertificateData(Ssl::GetX509Fingerprint, "-sha1", true), ACLServerCertificateStrategy::Instance(), "server_cert_fingerprint");
-
-ACL::Prototype ACLAtStep::RegistryProtoype(&ACLAtStep::RegistryEntry_, "at_step");
-ACLStrategised<Ssl::BumpStep> ACLAtStep::RegistryEntry_(new ACLAtStepData, ACLAtStepStrategy::Instance(), "at_step");
-
-ACL::Prototype ACLServerName::LiteralRegistryProtoype(&ACLServerName::LiteralRegistryEntry_, "ssl::server_name");
-ACLStrategised<char const *> ACLServerName::LiteralRegistryEntry_(new ACLServerNameData, ACLServerNameStrategy::Instance(), "ssl::server_name");
-ACL::Prototype ACLServerName::RegexRegistryProtoype(&ACLServerName::RegexRegistryEntry_, "ssl::server_name_regex");
-ACLFlag  ServerNameRegexFlags[] = {ACL_F_REGEX_CASE, ACL_F_END};
-ACLStrategised<char const *> ACLServerName::RegexRegistryEntry_(new ACLRegexData, ACLServerNameStrategy::Instance(), "ssl::server_name_regex", ServerNameRegexFlags);
+    RegisterMaker("ssl_error", [](TypeName name)->ACL* { return new ACLStrategised<const Security::CertErrors *>(new ACLSslErrorData, new ACLSslErrorStrategy, name); });
+    RegisterMaker("user_cert", [](TypeName name)->ACL* { return new ACLStrategised<X509*>(new ACLCertificateData(Ssl::GetX509UserAttribute, "*"), new ACLCertificateStrategy, name); });
+    RegisterMaker("ca_cert", [](TypeName name)->ACL* { return new ACLStrategised<X509*>(new ACLCertificateData(Ssl::GetX509CAAttribute, "*"), new ACLCertificateStrategy, name); });
+    RegisterMaker("server_cert_fingerprint", [](TypeName name)->ACL* { return new ACLStrategised<X509*>(new ACLCertificateData(Ssl::GetX509Fingerprint, "-sha1", true), new ACLServerCertificateStrategy, name); });
+    RegisterMaker("at_step", [](TypeName name)->ACL* { return new ACLStrategised<Ssl::BumpStep>(new ACLAtStepData, new ACLAtStepStrategy, name); });
+    RegisterMaker("ssl::server_name", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLServerNameData, new ACLServerNameStrategy, name); });
+    RegisterMaker("ssl::server_name_regex", [](TypeName name)->ACL* { return new ACLStrategised<char const *>(new ACLRegexData, new ACLServerNameStrategy, name); });
 #endif
 
 #if USE_SQUID_EUI
-ACL::Prototype ACLARP::RegistryProtoype(&ACLARP::RegistryEntry_, "arp");
-ACLARP ACLARP::RegistryEntry_("arp");
-ACL::Prototype ACLEui64::RegistryProtoype(&ACLEui64::RegistryEntry_, "eui64");
-ACLEui64 ACLEui64::RegistryEntry_("eui64");
+    RegisterMaker("arp", [](TypeName name)->ACL* { return new ACLARP(name); });
+    RegisterMaker("eui64", [](TypeName name)->ACL* { return new ACLEui64(name); });
 #endif
 
 #if USE_IDENT
-ACL::Prototype ACLIdent::UserRegistryProtoype(&ACLIdent::UserRegistryEntry_, "ident");
-ACLIdent ACLIdent::UserRegistryEntry_(new ACLUserData, "ident");
-ACL::Prototype ACLIdent::RegexRegistryProtoype(&ACLIdent::RegexRegistryEntry_, "ident_regex" );
-ACLIdent ACLIdent::RegexRegistryEntry_(new ACLRegexData, "ident_regex");
+    RegisterMaker("ident", [](TypeName name)->ACL* { return new ACLIdent(new ACLUserData, name); });
+    RegisterMaker("ident_regex", [](TypeName name)->ACL* { return new ACLIdent(new ACLRegexData, name); });
 #endif
 
 #if USE_AUTH
-ACL::Prototype ACLProxyAuth::UserRegistryProtoype(&ACLProxyAuth::UserRegistryEntry_, "proxy_auth");
-ACLProxyAuth ACLProxyAuth::UserRegistryEntry_(new ACLUserData, "proxy_auth");
-ACL::Prototype ACLProxyAuth::RegexRegistryProtoype(&ACLProxyAuth::RegexRegistryEntry_, "proxy_auth_regex" );
-ACLProxyAuth ACLProxyAuth::RegexRegistryEntry_(new ACLRegexData, "proxy_auth_regex");
-
-ACL::Prototype ACLMaxUserIP::RegistryProtoype(&ACLMaxUserIP::RegistryEntry_, "max_user_ip");
-ACLMaxUserIP ACLMaxUserIP::RegistryEntry_("max_user_ip");
+    RegisterMaker("ext_user", [](TypeName name)->ACL* { return new ACLExtUser(new ACLUserData, name); });
+    RegisterMaker("ext_user_regex", [](TypeName name)->ACL* { return new ACLExtUser(new ACLRegexData, name); });
+    RegisterMaker("proxy_auth", [](TypeName name)->ACL* { return new ACLProxyAuth(new ACLUserData, name); });
+    RegisterMaker("proxy_auth_regex", [](TypeName name)->ACL* { return new ACLProxyAuth(new ACLRegexData, name); });
+    RegisterMaker("max_user_ip", [](TypeName name)->ACL* { return new ACLMaxUserIP(name); });
 #endif
 
-ACL::Prototype ACLTag::RegistryProtoype(&ACLTag::RegistryEntry_, "tag");
-ACLStrategised<const char *> ACLTag::RegistryEntry_(new ACLStringData, ACLTagStrategy::Instance(), "tag");
-
-ACL::Prototype Acl::AnyOf::RegistryProtoype(&Acl::AnyOf::RegistryEntry_, "any-of");
-Acl::AnyOf Acl::AnyOf::RegistryEntry_;
-
-ACL::Prototype Acl::AllOf::RegistryProtoype(&Acl::AllOf::RegistryEntry_, "all-of");
-Acl::AllOf Acl::AllOf::RegistryEntry_;
-
-ACL::Prototype ACLNote::RegistryProtoype(&ACLNote::RegistryEntry_, "note");
-ACLStrategised<NotePairs::Entry *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteStrategy::Instance(), "note");
-
-ACL::Prototype ACLAnnotateClient::RegistryProtoype(&ACLAnnotateClient::RegistryEntry_, "annotate_client");
-ACLStrategised<NotePairs::Entry *> ACLAnnotateClient::RegistryEntry_(new ACLAnnotationData, ACLAnnotateClientStrategy::Instance(), "annotate_client");
-
-ACL::Prototype ACLAnnotateTransaction::RegistryProtoype(&ACLAnnotateTransaction::RegistryEntry_, "annotate_transaction");
-ACLStrategised<NotePairs::Entry *> ACLAnnotateTransaction::RegistryEntry_(new ACLAnnotationData, ACLAnnotateTransactionStrategy::Instance(), "annotate_transaction");
-
 #if USE_ADAPTATION
-ACL::Prototype ACLAdaptationService::RegistryProtoype(&ACLAdaptationService::RegistryEntry_, "adaptation_service");
-ACLStrategised<const char *> ACLAdaptationService::RegistryEntry_(new ACLAdaptationServiceData, ACLAdaptationServiceStrategy::Instance(), "adaptation_service");
+    RegisterMaker("adaptation_service", [](TypeName name)->ACL* { return new ACLStrategised<const char *>(new ACLAdaptationServiceData, new ACLAdaptationServiceStrategy, name); });
 #endif
 
-ACL::Prototype ACLSquidError::RegistryProtoype(&ACLSquidError::RegistryEntry_, "squid_error");
-ACLStrategised<err_type> ACLSquidError::RegistryEntry_(new ACLSquidErrorData, ACLSquidErrorStrategy::Instance(), "squid_error");
-
-ACL::Prototype Acl::ConnectionsEncrypted::RegistryProtoype(&Acl::ConnectionsEncrypted::RegistryEntry_, "connections_encrypted");
-Acl::ConnectionsEncrypted Acl::ConnectionsEncrypted::RegistryEntry_("connections_encrypted");
+#if SQUID_SNMP
+    RegisterMaker("snmp_community", [](TypeName name)->ACL* { return new ACLStrategised<const char *>(new ACLStringData, new ACLSNMPCommunityStrategy, name); });
+#endif
+}
 

=== added file 'src/AclRegs.h'
--- src/AclRegs.h	1970-01-01 00:00:00 +0000
+++ src/AclRegs.h	2017-05-14 17:55:12 +0000
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_ACLREGS_H_
+#define SQUID_ACLREGS_H_
+
+namespace Acl
+{
+/// prepares to parse ACLs configuration
+void Init(void);
+}
+
+#endif /* SQUID_ACLREGS_H_ */
+

=== modified file 'src/ExternalACL.h'
--- src/ExternalACL.h	2017-01-01 00:12:22 +0000
+++ src/ExternalACL.h	2017-05-14 17:55:12 +0000
@@ -45,36 +45,34 @@
     ACLExternal(ACLExternal const &);
     ~ACLExternal();
     ACLExternal&operator=(ACLExternal const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     /* This really should be dynamic based on the external class defn */
     virtual bool requiresAle() const {return true;}
     virtual bool requiresRequest() const {return true;}
 
     /* when requiresRequest is made dynamic, review this too */
     //    virtual bool requiresReply() const {return true;}
     virtual bool isProxyAuth() const;
     virtual SBufList dump() const;
     virtual bool valid () const;
     virtual bool empty () const;
 
 protected:
-    static Prototype RegistryProtoype;
-    static ACLExternal RegistryEntry_;
     external_acl_data *data;
     char const *class_;
 };
 
 void parse_externalAclHelper(external_acl **);
 void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 void free_externalAclHelper(external_acl **);
 typedef void EAH(void *data, const ExternalACLEntryPointer &result);
 void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
 void externalAclInit(void);
 void externalAclShutdown(void);
 
 #endif /* SQUID_EXTERNALACL_H */
 

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2017-02-19 17:13:27 +0000
+++ src/Makefile.am	2017-05-14 17:55:12 +0000
@@ -184,41 +184,41 @@
 	cf_gen
 
 sbin_PROGRAMS = \
 	squid
 
 bin_PROGRAMS =
 
 libexec_PROGRAMS = \
 	$(UNLINKD)
 
 cf_gen_SOURCES = cf_gen.cc
 nodist_cf_gen_HEADER = cf_gen_defines.cci
 ## cf_gen must be stand-alone executable. It is a purely build-time executable.
 cf_gen_LDADD=
 cf_gen.$(OBJEXT): cf_gen_defines.cci
 
 ## cf_gen.cc needs src/cf_gen_defines.cci
 AM_CPPFLAGS += -I$(top_builddir)/src
 
 
-ACL_REGISTRATION_SOURCES = AclRegs.cc AuthReg.cc
+ACL_REGISTRATION_SOURCES = AclRegs.cc AclRegs.h AuthReg.cc
 
 # common library for all the binaries and tests. This is kindof a catch all
 # and smaller libraries split from this are encouraged. Using lt convenience
 # libraries, dependencies should not be a problem either.
 libsquid_la_SOURCES = \
 	comm.cc \
 	comm.h \
 	CommCalls.cc \
 	CommCalls.h \
 	DescriptorSet.cc \
 	DescriptorSet.h \
 	SquidConfig.h \
 	SquidConfig.cc
 
 squid_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	AccessLogEntry.cc \
 	AccessLogEntry.h \
 	AsyncEngine.cc \
 	AsyncEngine.h \

=== modified file 'src/MessageDelayPools.h'
--- src/MessageDelayPools.h	2017-02-19 17:13:27 +0000
+++ src/MessageDelayPools.h	2017-05-14 17:55:12 +0000
@@ -1,37 +1,38 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef MESSAGEDELAYPOOLS_H
 #define MESSAGEDELAYPOOLS_H
 
 #if USE_DELAY_POOLS
 
 #include "acl/Acl.h"
 #include "base/RefCount.h"
 #include "DelayBucket.h"
 #include "DelayPools.h"
+#include "sbuf/SBuf.h"
 
 class MessageBucket;
 typedef RefCount<MessageBucket> MessageBucketPointer;
 
 /// \ingroup DelayPoolsAPI
 /// Represents one 'response' delay pool, creates individual response
 /// buckets and performes aggregate limiting for them
 class MessageDelayPool : public RefCountable
 {
 public:
     typedef RefCount<MessageDelayPool> Pointer;
 
     MessageDelayPool(const SBuf &name, int64_t bucketSpeed, int64_t bucketSize,
                      int64_t aggregateSpeed, int64_t aggregateSize, uint16_t initialBucketPercent);
     ~MessageDelayPool();
     MessageDelayPool(const MessageDelayPool &) = delete;
     MessageDelayPool &operator=(const MessageDelayPool &) = delete;
 
     /// Increases the aggregate bucket level with the aggregateRestore speed.
     void refillBucket();

=== modified file 'src/acl/Acl.cc'
--- src/acl/Acl.cc	2017-01-30 12:46:15 +0000
+++ src/acl/Acl.cc	2017-05-14 17:55:12 +0000
@@ -1,281 +1,134 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Gadgets.h"
+#include "acl/Options.h"
 #include "anyp/PortCfg.h"
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
-#include "dlink.h"
 #include "fatal.h"
 #include "globals.h"
 #include "profiler/Profiler.h"
+#include "sbuf/List.h"
+#include "sbuf/Stream.h"
 #include "SquidConfig.h"
 
-#include <vector>
-
-#define abortFlags(CONTENT) \
-   do { \
-    debugs(28, 0, CONTENT); \
-    self_destruct(); \
-   } while (0)
-
-const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
+#include <algorithm>
+#include <map>
 
 const char *AclMatchedName = NULL;
 
-ACLFlags::FlagsTokenizer::FlagsTokenizer()
-    : tokPos(nullptr), Parameter(nullptr) {}
+namespace Acl {
 
-ACLFlag
-ACLFlags::FlagsTokenizer::nextFlag()
-{
-    if (needNextToken()) {
-        if (!nextToken())
-            return 0;
-    } else
-        ++tokPos;
-    return *tokPos;
-}
-
-bool
-ACLFlags::FlagsTokenizer::hasParameter() const
-{
-    return tokPos && tokPos[0] && !tokPos[1] && Parameter;
-}
+/// ACL type name comparison functor
+class TypeNameCmp {
+public:
+    bool operator()(TypeName a, TypeName b) const { return strcmp(a, b) < 0; }
+};
 
-SBuf
-ACLFlags::FlagsTokenizer::getParameter() const
-{
-    return hasParameter() ? SBuf(Parameter) : SBuf();
-}
+/// ACL makers indexed by ACL type name
+typedef std::map<TypeName, Maker, TypeNameCmp> Makers;
 
-bool
-ACLFlags::FlagsTokenizer::needNextToken() const
+/// registered ACL Makers
+static Makers &
+TheMakers()
 {
-    return !tokPos || !tokPos[0] || !tokPos[1];
+    static Makers Registry;
+    return Registry;
 }
 
-bool
-ACLFlags::FlagsTokenizer::nextToken()
+/// creates an ACL object of the named (and already registered) ACL child type
+static
+ACL *
+Make(TypeName typeName)
 {
-    char *t = ConfigParser::PeekAtToken();
-    if (t == NULL || t[0] != '-' || !t[1])
-        return false;
-    if (strchr(t, '=')) {
-        if(!ConfigParser::NextKvPair(tokPos, Parameter))
-            abortFlags("Invalid formatting for flag '" << t << "'");
-        assert(tokPos[0] == '-');
-        tokPos++;
-    } else {
-        (void)ConfigParser::NextToken();
-        if (!strcmp(t, "--"))
-            return false;
-        tokPos = t + 1;
+    const auto pos = TheMakers().find(typeName);
+    if (pos == TheMakers().end()) {
+        debugs(28, DBG_CRITICAL, "FATAL: Invalid ACL type '" << typeName << "'");
+        self_destruct();
+        assert(false); // not reached
     }
-    return true;
-}
-
-ACLFlags::~ACLFlags()
-{
-    delete delimiters_;
-}
-
-ACLFlags::Status
-ACLFlags::flagStatus(const ACLFlag f) const
-{
-    if (f == ACL_F_REGEX_CASE)
-        return noParameter;
-    if (f == ACL_F_SUBSTRING)
-        return parameterOptional;
-    if (supported_.find(f) != std::string::npos)
-        return noParameter;
-    return notSupported;
-}
-
-bool
-ACLFlags::parameterSupported(const ACLFlag f, const SBuf &val) const
-{
-    if (f == ACL_F_SUBSTRING)
-        return val.findFirstOf(CharacterSet::ALPHA + CharacterSet::DIGIT) == SBuf::npos;
-    return true;
-}
 
-void
-ACLFlags::makeSet(const ACLFlag f, const SBuf &param)
-{
-    flags_ |= flagToInt(f);
-    if (!param.isEmpty())
-        flagParameters_[f].append(param);
+    ACL *result = (pos->second)(pos->first);
+    debugs(28, 4, typeName << '=' << result);
+    assert(result);
+    return result;
 }
 
-void
-ACLFlags::makeUnSet(const ACLFlag f)
-{
-    flags_ &= ~flagToInt(f);
-    flagParameters_[f].clear();
-}
+} // namespace Acl
 
 void
-ACLFlags::parseFlags()
-{
-    FlagsTokenizer tokenizer;
-    ACLFlag flag('\0');
-    while ((flag = tokenizer.nextFlag())) {
-        switch (flagStatus(flag))
-        {
-        case notSupported:
-            abortFlags("Flag '" << flag << "' not supported");
-            break;
-        case noParameter:
-            makeSet(flag);
-            break;
-        case parameterRequired:
-            if (!tokenizer.hasParameter()) {
-                abortFlags("Flag '" << flag << "' must have a parameter");
-                break;
-            }
-        case parameterOptional:
-            SBuf param;
-            if (tokenizer.hasParameter()) {
-                param = tokenizer.getParameter();
-                if (!parameterSupported(flag, param))
-                    abortFlags("Parameter '" << param << "' for flag '" << flag << "' not supported");
-            }
-            makeSet(flag, param);
-            break;
-        }
-    }
-
-    /*Regex code needs to parse -i file*/
-    if ( isSet(ACL_F_REGEX_CASE)) {
-        ConfigParser::TokenPutBack("-i");
-        makeUnSet('i');
-    }
-}
-
-SBuf
-ACLFlags::parameter(const ACLFlag f) const
+Acl::RegisterMaker(TypeName typeName, Maker maker)
 {
-    assert(static_cast<uint32_t>(f - 'A') < FlagIndexMax);
-    auto p = flagParameters_.find(f);
-    return p == flagParameters_.end() ? SBuf() : p->second;
-}
-
-const CharacterSet *
-ACLFlags::delimiters()
-{
-    if (isSet(ACL_F_SUBSTRING) && !delimiters_) {
-        static const SBuf defaultParameter(",");
-        SBuf rawParameter = parameter(ACL_F_SUBSTRING);
-        if (rawParameter.isEmpty())
-            rawParameter = defaultParameter;
-        delimiters_ = new CharacterSet("ACLFlags::delimiters", rawParameter.c_str());
-    }
-    return delimiters_;
-}
-
-const char *
-ACLFlags::flagsStr() const
-{
-    static char buf[64];
-    if (flags_ == 0)
-        return "";
-
-    char *s = buf;
-    *s++ = '-';
-    for (ACLFlag f = 'A'; f <= 'z'; f++) {
-        // ACL_F_REGEX_CASE (-i) flag handled by ACLRegexData class, ignore
-        if (isSet(f) && f != ACL_F_REGEX_CASE)
-            *s++ = f;
-    }
-    *s = '\0';
-    return buf;
+    assert(typeName);
+    assert(*typeName);
+    TheMakers().emplace(typeName, maker);
 }
 
 void *
 ACL::operator new (size_t)
 {
     fatal ("unusable ACL::new");
     return (void *)1;
 }
 
 void
 ACL::operator delete (void *)
 {
     fatal ("unusable ACL::delete");
 }
 
 ACL *
 ACL::FindByName(const char *name)
 {
     ACL *a;
     debugs(28, 9, "ACL::FindByName '" << name << "'");
 
     for (a = Config.aclList; a; a = a->next)
         if (!strcasecmp(a->name, name))
             return a;
 
     debugs(28, 9, "ACL::FindByName found no match");
 
     return NULL;
 }
 
-ACL *
-ACL::Factory (char const *type)
-{
-    ACL *result = Prototype::Factory (type);
-
-    if (!result)
-        fatal ("Unknown acl type in ACL::Factory");
-
-    return result;
-}
-
 ACL::ACL() :
     cfgline(nullptr),
     next(nullptr),
     registered(false)
 {
     *name = 0;
 }
 
-ACL::ACL(const ACLFlag flgs[]) :
-    cfgline(NULL),
-    next(NULL),
-    flags(flgs),
-    registered(false)
-{
-    *name = 0;
-}
-
 bool ACL::valid () const
 {
     return true;
 }
 
 bool
 ACL::matches(ACLChecklist *checklist) const
 {
     PROF_start(ACL_matches);
     debugs(28, 5, "checking " << name);
 
     // XXX: AclMatchedName does not contain a matched ACL name when the acl
     // does not match. It contains the last (usually leaf) ACL name checked
     // (or is NULL if no ACLs were checked).
     AclMatchedName = name;
 
     int result = 0;
     if (!checklist->hasAle() && requiresAle()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an ALE state. Assuming mismatch.");
@@ -356,106 +209,123 @@
         }
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myip' type is has been renamed to 'localip' and matches the IP the client connected to.");
         theType = "localip";
     } else if (strcmp(theType, "myport") == 0) {
         AnyP::PortCfgPointer p = HttpPortList;
         while (p != NULL) {
             // Bug 3239: not reliable when there is interception traffic coming
             // Bug 3239: myport - not reliable (yet) when there is interception traffic coming
             if (p->flags.natIntercept)
                 debugs(28, DBG_CRITICAL, "WARNING: 'myport' ACL is not reliable for interception proxies. Please use 'myportname' instead.");
             p = p->next;
         }
         theType = "localport";
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myport' type is has been renamed to 'localport' and matches the port the client connected to.");
     } else if (strcmp(theType, "proto") == 0 && strcmp(aclname, "manager") == 0) {
         // ACL manager is now a built-in and has a different type.
         debugs(28, DBG_PARSE_NOTE(DBG_IMPORTANT), "UPGRADE: ACL 'manager' is now a built-in ACL. Remove it from your config file.");
         return; // ignore the line
     }
 
-    if (!Prototype::Registered(theType)) {
-        debugs(28, DBG_CRITICAL, "FATAL: Invalid ACL type '" << theType << "'");
-        // XXX: make this an ERROR and skip the ACL creation. We *may* die later when its use is attempted. Or may not.
-        parser.destruct();
-        return;
-    }
-
     if ((A = FindByName(aclname)) == NULL) {
         debugs(28, 3, "aclParseAclLine: Creating ACL '" << aclname << "'");
-        A = ACL::Factory(theType);
+        A = Acl::Make(theType);
         A->context(aclname, config_input_line);
         new_acl = 1;
     } else {
         if (strcmp (A->typeString(),theType) ) {
             debugs(28, DBG_CRITICAL, "aclParseAclLine: ACL '" << A->name << "' already exists with different type.");
             parser.destruct();
             return;
         }
 
         debugs(28, 3, "aclParseAclLine: Appending to '" << aclname << "'");
         new_acl = 0;
     }
 
     /*
      * Here we set AclMatchedName in case we need to use it in a
      * warning message in aclDomainCompare().
      */
     AclMatchedName = A->name;   /* ugly */
 
-    A->flags.parseFlags();
+    A->parseFlags();
 
     /*split the function here */
     A->parse();
 
     /*
      * Clear AclMatchedName from our temporary hack
      */
     AclMatchedName = NULL;  /* ugly */
 
     if (!new_acl)
         return;
 
     if (A->empty()) {
         debugs(28, DBG_CRITICAL, "Warning: empty ACL: " << A->cfgline);
     }
 
     if (!A->valid()) {
         fatalf("ERROR: Invalid ACL: %s\n",
                A->cfgline);
     }
 
     // add to the global list for searching explicit ACLs by name
     assert(head && *head == Config.aclList);
     A->next = *head;
     *head = A;
 
     // register for centralized cleanup
     aclRegister(A);
 }
 
 bool
 ACL::isProxyAuth() const
 {
     return false;
 }
 
+void
+ACL::parseFlags()
+{
+    // ACL kids that carry ACLData which supports parameter flags override this
+    Acl::ParseFlags(options(), Acl::NoFlags());
+}
+
+SBufList
+ACL::dumpOptions()
+{
+    SBufList result;
+    const auto &myOptions = options();
+    // optimization: most ACLs do not have myOptions
+    // this check also works around dump_SBufList() adding ' ' after empty items
+    if (!myOptions.empty()) {
+        SBufStream stream;
+        stream << myOptions;
+        const SBuf optionsImage = stream.buf();
+        if (!optionsImage.isEmpty())
+            result.push_back(optionsImage);
+    }
+    return result;
+}
+
 /* ACL result caching routines */
 
 int
 ACL::matchForCache(ACLChecklist *)
 {
     /* This is a fatal to ensure that cacheMatchAcl calls are _only_
      * made for supported acl types */
     fatal("aclCacheMatchAcl: unknown or unexpected ACL type");
     return 0;       /* NOTREACHED */
 }
 
 /*
  * we lookup an acl's cached results, and if we cannot find the acl being
  * checked we check it and cache the result. This function is a template
  * method to support caching of multiple acl types.
  * Note that caching of time based acl's is not
  * wise in long lived caches (i.e. the auth_user proxy match cache)
  * RBC
  * TODO: does a dlink_list perform well enough? Kinkie
  */
@@ -513,95 +383,32 @@
     return false;
 }
 
 bool
 ACL::requiresRequest() const
 {
     return false;
 }
 
 /*********************/
 /* Destroy functions */
 /*********************/
 
 ACL::~ACL()
 {
     debugs(28, 3, "freeing ACL " << name);
     safe_free(cfgline);
     AclMatchedName = NULL; // in case it was pointing to our name
 }
 
-ACL::Prototype::Prototype() : prototype (NULL), typeString (NULL) {}
-
-ACL::Prototype::Prototype (ACL const *aPrototype, char const *aType) : prototype (aPrototype), typeString (aType)
-{
-    registerMe ();
-}
-
-std::vector<ACL::Prototype const *> * ACL::Prototype::Registry;
-void *ACL::Prototype::Initialized;
-
-bool
-ACL::Prototype::Registered(char const *aType)
-{
-    debugs(28, 7, "ACL::Prototype::Registered: invoked for type " << aType);
-
-    for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-        if (!strcmp (aType, (*i)->typeString)) {
-            debugs(28, 7, "ACL::Prototype::Registered:    yes");
-            return true;
-        }
-
-    debugs(28, 7, "ACL::Prototype::Registered:    no");
-    return false;
-}
-
-void
-ACL::Prototype::registerMe ()
-{
-    if (!Registry || (Initialized != ((char *)Registry - 5))  ) {
-        /* TODO: extract this */
-        /* Not initialised */
-        Registry = new std::vector<ACL::Prototype const *>;
-        Initialized = (char *)Registry - 5;
-    }
-
-    if (Registered (typeString))
-        fatalf ("Attempt to register %s twice", typeString);
-
-    Registry->push_back (this);
-}
-
-ACL::Prototype::~Prototype()
-{
-    // TODO: unregister me
-}
-
-ACL *
-ACL::Prototype::Factory (char const *typeToClone)
-{
-    debugs(28, 4, "ACL::Prototype::Factory: cloning an object for type '" << typeToClone << "'");
-
-    for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-        if (!strcmp (typeToClone, (*i)->typeString)) {
-            ACL *A = (*i)->prototype->clone();
-            A->flags = (*i)->prototype->flags;
-            return A;
-        }
-
-    debugs(28, 4, "ACL::Prototype::Factory: cloning failed, no type '" << typeToClone << "' available");
-
-    return NULL;
-}
-
 void
 ACL::Initialize()
 {
     ACL *a = Config.aclList;
     debugs(53, 3, "ACL::Initialize");
 
     while (a) {
         a->prepareForUse();
         a = a->next;
     }
 }
 

=== modified file 'src/acl/Acl.h'
--- src/acl/Acl.h	2017-01-30 12:46:15 +0000
+++ src/acl/Acl.h	2017-05-14 17:55:12 +0000
@@ -1,211 +1,106 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACL_H
 #define SQUID_ACL_H
 
 #include "acl/forward.h"
-#include "base/CharacterSet.h"
+#include "acl/Options.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
-#include "sbuf/List.h"
+#include "sbuf/forward.h"
 
-#include <map>
 #include <ostream>
-#include <string>
-#include <vector>
 
 class ConfigParser;
 
-typedef char ACLFlag;
-// ACLData Flags
-#define ACL_F_REGEX_CASE 'i'
-#define ACL_F_NO_LOOKUP 'n'
-#define ACL_F_STRICT 's'
-#define ACL_F_SUBSTRING 'm'
-#define ACL_F_END '\0'
-
-/**
- * \ingroup ACLAPI
- * Used to hold a list of one-letter flags which can be passed as parameters
- * to acls  (eg '-i', '-n' etc)
- */
-class ACLFlags
-{
-public:
-    enum Status
-    {
-        notSupported,
-        noParameter,
-        parameterOptional,
-        parameterRequired
-    };
-
-    explicit ACLFlags(const ACLFlag flags[]) : supported_(flags), flags_(0), delimiters_(nullptr) {}
-    ACLFlags() : flags_(0), delimiters_(nullptr) {}
-    ~ACLFlags();
-    /// \return a Status for the given ACLFlag.
-    Status flagStatus(const ACLFlag f) const;
-    /// \return true if the parameter for the given flag is acceptable.
-    bool parameterSupported(const ACLFlag f, const SBuf &val) const;
-    /// Set the given flag
-    void makeSet(const ACLFlag f, const SBuf &param = SBuf(""));
-    void makeUnSet(const ACLFlag f); ///< Unset the given flag
-    /// \return true if the given flag is set.
-    bool isSet(const ACLFlag f) const { return flags_ & flagToInt(f);}
-    /// \return the parameter value of the given flag if set.
-    SBuf parameter(const ACLFlag f) const;
-    /// \return ACL_F_SUBSTRING parameter value(if set) converted to CharacterSet.
-    const CharacterSet *delimiters();
-    /// Parse optional flags given in the form -[A..Z|a..z]
-    void parseFlags();
-    const char *flagsStr() const; ///< Convert the flags to a string representation
-    /**
-     * Lexical analyzer for ACL flags
-     *
-     * Support tokens in the form:
-     *   flag := '-' [A-Z|a-z]+ ['=' parameter ]
-     * Each token consist by one or more single-letter flags, which may
-     * followed by a parameter string.
-     * The parameter can belongs only to the last flag in token.
-     */
-    class FlagsTokenizer
-    {
-    public:
-        FlagsTokenizer();
-        ACLFlag nextFlag(); ///< The next flag or '\0' if finished
-        /// \return true if a parameter follows the last parsed flag.
-        bool hasParameter() const;
-        /// \return the parameter of last parsed flag, if exist.
-        SBuf getParameter() const;
-
-    private:
-        /// \return true if the current token parsing is finished.
-        bool needNextToken() const;
-        /// Peeks at the next token and return false if the next token
-        /// is not flag, or a '--' is read.
-        bool nextToken();
-
-        char *tokPos;
-        char *Parameter;
-    };
+namespace Acl {
 
-private:
-    /// Convert a flag to a 64bit unsigned integer.
-    /// The characters from 'A' to 'z' represented by the values from 65 to 122.
-    /// They are 57 different characters which can be fit to the bits of an 64bit
-    /// integer.
-    uint64_t flagToInt(const ACLFlag f) const {
-        assert('A' <= f && f <= 'z');
-        return ((uint64_t)1 << (f - 'A'));
-    }
-
-    std::string supported_; ///< The supported character flags
-    uint64_t flags_; ///< The flags which are set
-    static const uint32_t FlagIndexMax = 'z' - 'A';
-    std::map<ACLFlag, SBuf> flagParameters_;
-    CharacterSet *delimiters_;
-public:
-    static const ACLFlag NoFlags[1]; ///< An empty flags list
-};
+/// the ACL type name known to admins
+typedef const char *TypeName;
+/// a "factory" function for making ACL objects (of some ACL child type)
+typedef ACL *(*Maker)(TypeName typeName);
+/// use the given ACL Maker for all ACLs of the named type
+void RegisterMaker(TypeName typeName, Maker maker);
+
+} // namespace Acl
 
 /// A configurable condition. A node in the ACL expression tree.
 /// Can evaluate itself in FilledChecklist context.
 /// Does not change during evaluation.
 /// \ingroup ACLAPI
 class ACL
 {
 
 public:
     void *operator new(size_t);
     void operator delete(void *);
 
-    static ACL *Factory(char const *);
     static void ParseAclLine(ConfigParser &parser, ACL ** head);
     static void Initialize();
     static ACL *FindByName(const char *name);
 
     ACL();
-    explicit ACL(const ACLFlag flgs[]);
     virtual ~ACL();
 
     /// sets user-specified ACL name and squid.conf context
     void context(const char *name, const char *configuration);
 
     /// Orchestrates matching checklist against the ACL using match(),
     /// after checking preconditions and while providing debugging.
     /// \return true if and only if there was a successful match.
     /// Updates the checklist state on match, async, and failure.
     bool matches(ACLChecklist *checklist) const;
 
-    virtual ACL *clone() const = 0;
+    /// \returns (linked) Options supported by this ACL
+    virtual const Acl::Options &options() { return Acl::NoOptions(); }
+
+    /// configures ACL options, throwing on configuration errors
+    virtual void parseFlags();
 
     /// parses node represenation in squid.conf; dies on failures
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
     virtual SBufList dump() const = 0;
     virtual bool empty() const = 0;
     virtual bool valid() const;
 
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
 
     virtual void prepareForUse() {}
 
+    SBufList dumpOptions(); ///< \returns approximate options configuration
+
     char name[ACL_NAME_SZ];
     char *cfgline;
     ACL *next; // XXX: remove or at least use refcounting
-    ACLFlags flags; ///< The list of given ACL flags
     bool registered; ///< added to the global list of ACLs via aclRegister()
 
-public:
-
-    class Prototype
-    {
-
-    public:
-        Prototype();
-        Prototype(ACL const *, char const *);
-        ~Prototype();
-        static bool Registered(char const *);
-        static ACL *Factory(char const *);
-
-    private:
-        ACL const *prototype;
-        char const *typeString;
-
-    private:
-        static std::vector<Prototype const *> * Registry;
-        static void *Initialized;
-        typedef std::vector<Prototype const*>::iterator iterator;
-        typedef std::vector<Prototype const*>::const_iterator const_iterator;
-        void registerMe();
-    };
-
 private:
     /// Matches the actual data in checklist against this ACL.
     virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
 
     /// whether our (i.e. shallow) match() requires checklist to have a AccessLogEntry
     virtual bool requiresAle() const;
     /// whether our (i.e. shallow) match() requires checklist to have a request
     virtual bool requiresRequest() const;
     /// whether our (i.e. shallow) match() requires checklist to have a reply
     virtual bool requiresReply() const;
 };
 
 /// \ingroup ACLAPI
 typedef enum {
     // Authorization ACL result states
     ACCESS_DENIED,
     ACCESS_ALLOWED,
     ACCESS_DUNNO,
 
     // Authentication ACL result states

=== modified file 'src/acl/AdaptationService.cc'
--- src/acl/AdaptationService.cc	2017-01-01 00:12:22 +0000
+++ src/acl/AdaptationService.cc	2017-05-14 17:55:12 +0000
@@ -1,43 +1,35 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "acl/AdaptationService.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/IntRange.h"
 #include "adaptation/Config.h"
 #include "adaptation/History.h"
 #include "HttpRequest.h"
 
 int
-ACLAdaptationServiceStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLAdaptationServiceStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     HttpRequest::Pointer request = checklist->request;
     if (request == NULL)
         return 0;
     Adaptation::History::Pointer ah = request->adaptHistory();
     if (ah == NULL)
         return 0;
 
     Adaptation::History::AdaptationServices::iterator it;
     for (it = ah->theAdaptationServices.begin(); it != ah->theAdaptationServices.end(); ++it) {
         if (data->match(it->c_str()))
             return 1;
     }
 
     return 0;
 }
 
-ACLAdaptationServiceStrategy *
-ACLAdaptationServiceStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLAdaptationServiceStrategy ACLAdaptationServiceStrategy::Instance_;
-

=== modified file 'src/acl/AdaptationService.h'
--- src/acl/AdaptationService.h	2017-01-01 00:12:22 +0000
+++ src/acl/AdaptationService.h	2017-05-23 14:55:44 +0000
@@ -1,44 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLADAPTATIONSERVICE_H
 #define SQUID_ACLADAPTATIONSERVICE_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 
 /// \ingroup ACLAPI
 class ACLAdaptationServiceStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLAdaptationServiceStrategy *Instance();
-    /**
-     * Not implemented to prevent copies of the instance.
-     */
-    ACLAdaptationServiceStrategy(ACLAdaptationServiceStrategy const &);
-
-private:
-    static ACLAdaptationServiceStrategy Instance_;
-    ACLAdaptationServiceStrategy() {}
-
-    ACLAdaptationServiceStrategy &operator = (ACLAdaptationServiceStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLAdaptationService
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const char *> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLADAPTATIONSERVICE_H */
 

=== modified file 'src/acl/AllOf.h'
--- src/acl/AllOf.h	2017-01-01 00:12:22 +0000
+++ src/acl/AllOf.h	2017-05-14 17:55:12 +0000
@@ -14,29 +14,26 @@
 namespace Acl
 {
 
 /// Configurable all-of ACL. Each ACL line is a conjuction of ACLs.
 /// Uses AndNode and OrNode to handle squid.conf configuration where multiple
 /// acl all-of lines are always ORed together.
 class AllOf: public Acl::InnerNode
 {
     MEMPROXY_CLASS(AllOf);
 
 public:
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
     virtual void parse();
     virtual SBufList dump() const;
 
 private:
     /* Acl::InnerNode API */
     virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
-
-    static Prototype RegistryProtoype;
-    static AllOf RegistryEntry_;
 };
 
 } // namespace Acl
 
 #endif /* SQUID_ACL_ALL_OF_H */
 

=== modified file 'src/acl/AnnotateClient.cc'
--- src/acl/AnnotateClient.cc	2017-01-31 00:12:18 +0000
+++ src/acl/AnnotateClient.cc	2017-05-14 17:55:12 +0000
@@ -1,37 +1,30 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "acl/AnnotateClient.h"
 #include "acl/AnnotationData.h"
+#include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "http/Stream.h"
 #include "Notes.h"
 
 int
-ACLAnnotateClientStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
+ACLAnnotateClientStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (const auto conn = checklist->conn()) {
         ACLAnnotationData *tdata = dynamic_cast<ACLAnnotationData*>(data);
         assert(tdata);
-        tdata->annotate(conn->notes(), flags.delimiters(), checklist->al);
+        tdata->annotate(conn->notes(), &delimiters.value, checklist->al);
         if (const auto request = checklist->request)
-            tdata->annotate(request->notes(), flags.delimiters(), checklist->al);
+            tdata->annotate(request->notes(), &delimiters.value, checklist->al);
         return 1;
     }
     return 0;
 }
 
-ACLAnnotateClientStrategy *
-ACLAnnotateClientStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLAnnotateClientStrategy ACLAnnotateClientStrategy::Instance_;
-

=== modified file 'src/acl/AnnotateClient.h'
--- src/acl/AnnotateClient.h	2017-01-31 00:12:18 +0000
+++ src/acl/AnnotateClient.h	2017-05-23 14:22:59 +0000
@@ -1,40 +1,24 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLANNOTATECLIENT
 #define SQUID_ACLANNOTATECLIENT
 
-#include "acl/Strategised.h"
-#include "acl/Strategy.h"
+#include "acl/Note.h"
+#include "Notes.h"
 
 /// \ingroup ACLAPI
-class ACLAnnotateClientStrategy : public ACLStrategy<NotePairs::Entry *>
+class ACLAnnotateClientStrategy : public Acl::AnnotationStrategy
 {
 public:
-    static ACLAnnotateClientStrategy *Instance();
-    ACLAnnotateClientStrategy(ACLAnnotateClientStrategy const &) = delete;
-    ACLAnnotateClientStrategy& operator=(ACLAnnotateClientStrategy const &) = delete;
-
     virtual bool requiresRequest() const { return true; }
-    virtual int match(ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-
-private:
-    static ACLAnnotateClientStrategy Instance_;
-    ACLAnnotateClientStrategy() { }
-};
-
-/// \ingroup ACLAPI
-class ACLAnnotateClient
-{
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<NotePairs::Entry *> RegistryEntry_;
+    virtual int match(ACLData<MatchType> * &, ACLFilledChecklist *);
 };
 
 #endif /* SQUID_ACLANNOTATECLIENT */
 

=== modified file 'src/acl/AnnotateTransaction.cc'
--- src/acl/AnnotateTransaction.cc	2017-01-31 00:12:18 +0000
+++ src/acl/AnnotateTransaction.cc	2017-05-14 17:55:12 +0000
@@ -1,35 +1,27 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "acl/AnnotateTransaction.h"
 #include "acl/AnnotationData.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "HttpRequest.h"
 #include "Notes.h"
 
 int
-ACLAnnotateTransactionStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
+ACLAnnotateTransactionStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (const auto request = checklist->request) {
         ACLAnnotationData *tdata = dynamic_cast<ACLAnnotationData*>(data);
         assert(tdata);
-        tdata->annotate(request->notes(), flags.delimiters(), checklist->al);
+        tdata->annotate(request->notes(), &delimiters.value, checklist->al);
         return 1;
     }
     return 0;
 }
 
-ACLAnnotateTransactionStrategy *
-ACLAnnotateTransactionStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLAnnotateTransactionStrategy ACLAnnotateTransactionStrategy::Instance_;
-

=== modified file 'src/acl/AnnotateTransaction.h'
--- src/acl/AnnotateTransaction.h	2017-01-31 00:12:18 +0000
+++ src/acl/AnnotateTransaction.h	2017-05-14 17:55:12 +0000
@@ -1,40 +1,24 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLANNOTATETRANSACTION
 #define SQUID_ACLANNOTATETRANSACTION
 
-#include "acl/Strategised.h"
-#include "acl/Strategy.h"
+#include "acl/Note.h"
+#include "Notes.h"
 
 /// \ingroup ACLAPI
-class ACLAnnotateTransactionStrategy : public ACLStrategy<NotePairs::Entry *>
+class ACLAnnotateTransactionStrategy: public Acl::AnnotationStrategy
 {
 public:
-    virtual int match(ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match(ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const { return true; }
-
-    static ACLAnnotateTransactionStrategy *Instance();
-    ACLAnnotateTransactionStrategy(ACLAnnotateTransactionStrategy const &) = delete;
-    ACLAnnotateTransactionStrategy& operator=(ACLAnnotateTransactionStrategy const &) = delete;
-
-private:
-    static ACLAnnotateTransactionStrategy Instance_;
-    ACLAnnotateTransactionStrategy() {}
-};
-
-/// \ingroup ACLAPI
-class ACLAnnotateTransaction
-{
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<NotePairs::Entry *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLANNOTATETRANSACTION */
 

=== modified file 'src/acl/AnyOf.h'
--- src/acl/AnyOf.h	2017-01-01 00:12:22 +0000
+++ src/acl/AnyOf.h	2017-05-14 17:55:12 +0000
@@ -7,30 +7,26 @@
  */
 
 #ifndef SQUID_ACL_ANY_OF_H
 #define SQUID_ACL_ANY_OF_H
 
 #include "acl/BoolOps.h"
 
 namespace Acl
 {
 
 /// Configurable any-of ACL. Each ACL line is a disjuction of ACLs.
 class AnyOf: public Acl::OrNode
 {
     MEMPROXY_CLASS(AnyOf);
 
 public:
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
     virtual void parse();
-
-private:
-    static Prototype RegistryProtoype;
-    static AnyOf RegistryEntry_;
 };
 
 } // namespace Acl
 
 #endif /* SQUID_ACL_ANY_OF_H */
 

=== modified file 'src/acl/Arp.h'
--- src/acl/Arp.h	2017-01-01 00:12:22 +0000
+++ src/acl/Arp.h	2017-05-14 17:55:12 +0000
@@ -1,49 +1,46 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLARP_H
 #define SQUID_ACLARP_H
 
 #include "acl/Acl.h"
-#include "acl/Checklist.h"
 
 #include <set>
 
 namespace Eui
 {
 class Eui48;
 };
 
 /// \ingroup ACLAPI
 class ACLARP : public ACL
 {
     MEMPROXY_CLASS(ACLARP);
 
 public:
     ACLARP(char const *);
     ACLARP(ACLARP const &);
     ~ACLARP() {}
     ACLARP&operator=(ACLARP const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
-    static Prototype RegistryProtoype;
-    static ACLARP RegistryEntry_;
     char const *class_;
     typedef std::set<Eui::Eui48> AclArpData_t;
     AclArpData_t aclArpData;
 };
 
 #endif /* SQUID_ACLARP_H */
 

=== modified file 'src/acl/Asn.cc'
--- src/acl/Asn.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Asn.cc	2017-05-14 17:55:12 +0000
@@ -1,37 +1,38 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 53    AS Number handling */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/Asn.h"
 #include "acl/Checklist.h"
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
+#include "acl/Strategised.h"
 #include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "mgr/Registration.h"
 #include "radix.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
 #define WHOIS_PORT 43
 #define AS_REQBUF_SZ    4096
 
 /* BEGIN of definitions for radix tree entries */
 
 /* 32/128 bits address in memory with length */
 class m_ADDR
 {
 public:
@@ -560,75 +561,51 @@
     while ((t = ConfigParser::strtokFile())) {
         q = new CbDataList<int> (atoi(t));
         *(Tail) = q;
         Tail = &q->next;
     }
 }
 
 ACLData<Ip::Address> *
 ACLASN::clone() const
 {
     if (data)
         fatal ("cloning of ACLASN not implemented");
 
     return new ACLASN(*this);
 }
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<Ip::Address>;
 
-ACL::Prototype ACLASN::SourceRegistryProtoype(&ACLASN::SourceRegistryEntry_, "src_as");
-
-ACLStrategised<Ip::Address> ACLASN::SourceRegistryEntry_(new ACLASN, ACLSourceASNStrategy::Instance(), "src_as");
-
-ACL::Prototype ACLASN::DestinationRegistryProtoype(&ACLASN::DestinationRegistryEntry_, "dst_as");
-
-ACLStrategised<Ip::Address> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
-
 int
-ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist)
 {
     return data->match(checklist->src_addr);
 }
 
-ACLSourceASNStrategy *
-ACLSourceASNStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLSourceASNStrategy ACLSourceASNStrategy::Instance_;
-
 int
-ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->url.host(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
         for (int k = 0; k < (int) ia->count; ++k) {
             if (data->match(ia->in_addrs[k]))
                 return 1;
         }
 
         return 0;
 
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         debugs(28, 3, "can't yet compare '" << AclMatchedName << "' ACL for " << checklist->request->url.host());
         if (checklist->goAsync(DestinationIPLookup::Instance()))
             return -1;
         // else fall through to noaddr match, hiding the lookup failure (XXX)
     }
     Ip::Address noaddr;
     noaddr.setNoAddr();
     return data->match(noaddr);
 }
 
-ACLDestinationASNStrategy *
-ACLDestinationASNStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLDestinationASNStrategy ACLDestinationASNStrategy::Instance_;
-

=== modified file 'src/acl/Asn.h'
--- src/acl/Asn.h	2017-01-01 00:12:22 +0000
+++ src/acl/Asn.h	2017-05-14 17:55:12 +0000
@@ -1,51 +1,45 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLASN_H
 #define SQUID_ACLASN_H
 
-#include "acl/Checklist.h"
 #include "acl/Data.h"
-#include "acl/Strategised.h"
 #include "base/CbDataList.h"
 #include "ip/Address.h"
 
 int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
 void asnInit(void);
 
 /// \ingroup ACLAPI
 void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
 {
     MEMPROXY_CLASS(ACLASN);
 
 public:
     ACLASN() : data(nullptr) {}
     virtual ~ACLASN();
 
     virtual bool match(Ip::Address);
     virtual SBufList dump() const;
     virtual void parse();
     bool empty() const;
     virtual ACLData<Ip::Address> *clone() const;
     virtual void prepareForUse();
 
 private:
-    static ACL::Prototype SourceRegistryProtoype;
-    static ACLStrategised<Ip::Address> SourceRegistryEntry_;
-    static ACL::Prototype DestinationRegistryProtoype;
-    static ACLStrategised<Ip::Address> DestinationRegistryEntry_;
     CbDataList<int> *data;
 };
 
 #endif /* SQUID_ACLASN_H */
 

=== modified file 'src/acl/AtStep.cc'
--- src/acl/AtStep.cc	2017-01-01 00:12:22 +0000
+++ src/acl/AtStep.cc	2017-05-14 17:55:12 +0000
@@ -1,40 +1,32 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 
 #if USE_OPENSSL
 
 #include "acl/AtStep.h"
 #include "acl/AtStepData.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "http/Stream.h"
 #include "ssl/ServerBump.h"
 
 int
-ACLAtStepStrategy::match (ACLData<Ssl::BumpStep> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLAtStepStrategy::match (ACLData<Ssl::BumpStep> * &data, ACLFilledChecklist *checklist)
 {
     Ssl::ServerBump *bump = NULL;
     if (checklist->conn() != NULL && (bump = checklist->conn()->serverBump()))
         return data->match(bump->step);
     else
         return data->match(Ssl::bumpStep1);
     return 0;
 }
 
-ACLAtStepStrategy *
-ACLAtStepStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLAtStepStrategy ACLAtStepStrategy::Instance_;
-
 #endif /* USE_OPENSSL */
 

=== modified file 'src/acl/AtStep.h'
--- src/acl/AtStep.h	2017-01-01 00:12:22 +0000
+++ src/acl/AtStep.h	2017-05-23 14:16:40 +0000
@@ -1,47 +1,28 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLATSTEP_H
 #define SQUID_ACLATSTEP_H
 
 #if USE_OPENSSL
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "ssl/support.h"
 
 /// \ingroup ACLAPI
 class ACLAtStepStrategy : public ACLStrategy<Ssl::BumpStep>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLAtStepStrategy *Instance();
-
-    // Not implemented to prevent copies of the instance.
-    ACLAtStepStrategy(ACLAtStepStrategy const &);
-
-private:
-    static ACLAtStepStrategy Instance_;
-    ACLAtStepStrategy() {}
-
-    ACLAtStepStrategy&operator=(ACLAtStepStrategy const &);
-};
-
-class ACLAtStep
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<Ssl::BumpStep> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* USE_OPENSSL */
 
 #endif /* SQUID_ACLATSTEP_H */
 

=== modified file 'src/acl/BoolOps.cc'
--- src/acl/BoolOps.cc	2017-01-01 00:12:22 +0000
+++ src/acl/BoolOps.cc	2017-05-14 17:55:12 +0000
@@ -1,32 +1,33 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "acl/BoolOps.h"
 #include "acl/Checklist.h"
 #include "Debug.h"
+#include "sbuf/SBuf.h"
 
 /* Acl::NotNode */
 
 Acl::NotNode::NotNode(ACL *acl)
 {
     assert(acl);
     name[0] = '!';
     name[1] = '\0';
     strncat(&name[1], acl->name, sizeof(name)-1-1);
     add(acl);
 }
 
 void
 Acl::NotNode::parse()
 {
     // Not implemented: by the time an upper level parser discovers
     // an '!' operator, there is nothing left for us to parse.
     assert(false);
 }
 

=== removed file 'src/acl/Browser.cc'
--- src/acl/Browser.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Browser.cc	1970-01-01 00:00:00 +0000
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 28    Access Control */
-
-#include "squid.h"
-#include "acl/Browser.h"
-#include "acl/Checklist.h"
-#include "acl/RegexData.h"
-
-/* explicit template instantiation required for some systems */
-
-template class ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>;
-

=== removed file 'src/acl/Browser.h'
--- src/acl/Browser.h	2017-01-01 00:12:22 +0000
+++ src/acl/Browser.h	1970-01-01 00:00:00 +0000
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_ACLBROWSER_H
-#define SQUID_ACLBROWSER_H
-
-#include "acl/Acl.h"
-#include "acl/Data.h"
-#include "acl/RequestHeaderStrategy.h"
-#include "acl/Strategised.h"
-
-/// \ingroup ACLAPI
-class ACLBrowser
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
-};
-
-#endif /* SQUID_ACLBROWSER_H */
-

=== modified file 'src/acl/Certificate.cc'
--- src/acl/Certificate.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Certificate.cc	2017-05-14 17:55:12 +0000
@@ -8,41 +8,33 @@
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 
 /* MS Visual Studio Projects are monolithic, so we need the following
  * #if to exclude the SSL code from compile process when not needed.
  */
 #if USE_OPENSSL
 
 #include "acl/Certificate.h"
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
 #include "client_side.h"
 #include "fde.h"
 #include "globals.h"
 #include "http/Stream.h"
 #include "HttpRequest.h"
 
 int
-ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     const int fd = checklist->fd();
     const bool goodDescriptor = 0 <= fd && fd <= Biggest_FD;
     auto ssl = goodDescriptor ? fd_table[fd].ssl.get() : nullptr;
     X509 *cert = SSL_get_peer_certificate(ssl);
     const bool res = data->match (cert);
     X509_free(cert);
     return res;
 }
 
-ACLCertificateStrategy *
-ACLCertificateStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLCertificateStrategy ACLCertificateStrategy::Instance_;
-
 #endif /* USE_OPENSSL */
 

=== modified file 'src/acl/Certificate.h'
--- src/acl/Certificate.h	2017-01-01 00:12:22 +0000
+++ src/acl/Certificate.h	2017-05-14 17:55:12 +0000
@@ -3,47 +3,25 @@
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLCERTIFICATE_H
 #define SQUID_ACLCERTIFICATE_H
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 #include "ssl/support.h"
 
 /// \ingroup ACLAPI
 class ACLCertificateStrategy : public ACLStrategy<X509 *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLCertificateStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLCertificateStrategy(ACLCertificateStrategy const &);
-
-private:
-    static ACLCertificateStrategy Instance_;
-    ACLCertificateStrategy() {}
-
-    ACLCertificateStrategy&operator=(ACLCertificateStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLCertificate
-{
-
-private:
-    static ACL::Prototype UserRegistryProtoype;
-    static ACLStrategised<X509*> UserRegistryEntry_;
-    static ACL::Prototype CARegistryProtoype;
-    static ACLStrategised<X509 *> CARegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
 };
 
 #endif /* SQUID_ACLCERTIFICATE_H */
 

=== added file 'src/acl/CharacterSetOption.h'
--- src/acl/CharacterSetOption.h	1970-01-01 00:00:00 +0000
+++ src/acl/CharacterSetOption.h	2017-05-14 17:55:12 +0000
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_ACL_CHARACTER_SET_OPTION_H
+#define SQUID_ACL_CHARACTER_SET_OPTION_H
+
+#include "acl/Options.h"
+#include "base/CharacterSet.h"
+#include "sbuf/SBuf.h"
+
+namespace Acl {
+
+typedef OptionValue<CharacterSet> CharacterSetOptionValue;
+
+/* TypedOption<CharacterSetOptionValue> specializations */
+
+template <>
+inline
+void
+TypedOption<CharacterSetOptionValue>::import(const SBuf &rawValue) const
+{
+    SBuf chars = rawValue; // because c_str() is not constant
+    recipient_->value = CharacterSet(__FILE__, chars.c_str());
+}
+
+template <>
+inline
+void
+TypedOption<CharacterSetOptionValue>::print(std::ostream &os) const
+{
+    recipient_->value.printChars(os); // TODO: Quote if needed.
+}
+
+/// option value to configure one or more characters (e.g., -m=",;")
+class CharacterSetOption: public TypedOption<CharacterSetOptionValue>
+{
+public:
+    typedef TypedOption<CharacterSetOptionValue> Parent;
+    CharacterSetOption(): Parent(valueOptional) {}
+};
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_CHARACTER_SET_OPTION_H */
+

=== modified file 'src/acl/ConnectionsEncrypted.h'
--- src/acl/ConnectionsEncrypted.h	2017-01-01 00:12:22 +0000
+++ src/acl/ConnectionsEncrypted.h	2017-05-14 17:55:12 +0000
@@ -16,29 +16,27 @@
 {
 
 class ConnectionsEncrypted : public ACL
 {
     MEMPROXY_CLASS(ConnectionsEncrypted);
 
 public:
     ConnectionsEncrypted(char const *);
     ConnectionsEncrypted(ConnectionsEncrypted const &);
     virtual ~ConnectionsEncrypted();
     ConnectionsEncrypted &operator =(ConnectionsEncrypted const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
-    static Prototype RegistryProtoype;
-    static ConnectionsEncrypted RegistryEntry_;
     char const *class_;
 };
 
 } // namespace Acl
 
 #endif /* SQUID_ACL_CONNECTIONS_ENCRYPTED_H */
 

=== modified file 'src/acl/Data.h'
--- src/acl/Data.h	2017-01-01 00:12:22 +0000
+++ src/acl/Data.h	2017-05-14 17:55:12 +0000
@@ -1,33 +1,37 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLDATA_H
 #define SQUID_ACLDATA_H
 
+#include "acl/Options.h"
 #include "sbuf/List.h"
 
-/// \ingroup ACLAPI
+/// Configured ACL parameter(s) (e.g., domain names in dstdomain ACL).
 template <class M>
 class ACLData
 {
 
 public:
 
     virtual ~ACLData() {}
 
+    /// \returns the flags supported by these ACL parameters (e.g., "-i")
+    virtual const Acl::ParameterFlags &supportedFlags() const { return Acl::NoFlags(); }
+
     virtual bool match(M) =0;
     virtual SBufList dump() const =0;
     virtual void parse() =0;
     virtual ACLData *clone() const =0;
     virtual void prepareForUse() {}
 
     virtual bool empty() const =0;
 };
 
 #endif /* SQUID_ACLDATA_H */
 

=== modified file 'src/acl/DestinationAsn.h'
--- src/acl/DestinationAsn.h	2017-01-01 00:12:22 +0000
+++ src/acl/DestinationAsn.h	2017-05-14 17:55:12 +0000
@@ -1,42 +1,26 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLDESTINATIONASN_H
 #define SQUID_ACLDESTINATIONASN_H
 
 #include "acl/Asn.h"
 #include "acl/Strategy.h"
 #include "ip/Address.h"
 
 /// \ingroup ACLAPI
 class ACLDestinationASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLDestinationASNStrategy *Instance();
-
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g++ warnings about
-     * private constructors with no friends
-     */
-    ACLDestinationASNStrategy(ACLDestinationASNStrategy const &);
-
-private:
-    static ACLDestinationASNStrategy Instance_;
-    ACLDestinationASNStrategy() {}
-
-    ACLDestinationASNStrategy&operator=(ACLDestinationASNStrategy const &);
 };
 
 #endif /* SQUID_ACLDESTINATIONASN_H */
 

=== modified file 'src/acl/DestinationDomain.cc'
--- src/acl/DestinationDomain.cc	2017-01-01 00:12:22 +0000
+++ src/acl/DestinationDomain.cc	2017-05-14 17:55:12 +0000
@@ -24,78 +24,81 @@
 {
     return &instance_;
 }
 
 void
 DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
     fqdncache_nbgethostbyaddr(checklist->dst_addr, LookupDone, checklist);
 }
 
 void
 DestinationDomainLookup::LookupDone(const char *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markDestinationDomainChecked();
     checklist->request->recordLookup(details);
     checklist->resumeNonBlockingCheck(DestinationDomainLookup::Instance());
 }
 
+/* ACLDestinationDomainStrategy */
+
+const Acl::Options &
+ACLDestinationDomainStrategy::options()
+{
+    static const Acl::BooleanOption LookupBanFlag;
+    static const Acl::Options MyOptions = { { "-n", &LookupBanFlag } };
+    LookupBanFlag.linkWith(&lookupBanned);
+    return MyOptions;
+}
+
 int
-ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
+ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     assert(checklist != NULL && checklist->request != NULL);
 
     if (data->match(checklist->request->url.host())) {
         return 1;
     }
 
-    if (flags.isSet(ACL_F_NO_LOOKUP)) {
+    if (lookupBanned) {
         debugs(28, 3, "No-lookup DNS ACL '" << AclMatchedName << "' for " << checklist->request->url.host());
         return 0;
     }
 
     /* numeric IPA? no, trust the above result. */
     if (!checklist->request->url.hostIsNumeric()) {
         return 0;
     }
 
     /* do we already have the rDNS? match on it if we do. */
     if (checklist->dst_rdns) {
         debugs(28, 3, "'" << AclMatchedName << "' match with stored rDNS '" << checklist->dst_rdns << "' for " << checklist->request->url.host());
         return data->match(checklist->dst_rdns);
     }
 
     /* raw IP without rDNS? look it up and wait for the result */
     const ipcache_addrs *ia = ipcacheCheckNumeric(checklist->request->url.host());
     if (!ia) {
         /* not a valid IPA */
         checklist->dst_rdns = xstrdup("invalid");
         return 0;
     }
 
     checklist->dst_addr = ia->in_addrs[0];
     const char *fqdn = fqdncache_gethostbyaddr(checklist->dst_addr, FQDN_LOOKUP_IF_MISS);
 
     if (fqdn) {
         checklist->dst_rdns = xstrdup(fqdn);
         return data->match(fqdn);
     } else if (!checklist->destinationDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "Can't yet compare '" << AclMatchedName << "' ACL for " << checklist->request->url.host());
         if (checklist->goAsync(DestinationDomainLookup::Instance()))
             return -1;
         // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
 }
 
-ACLDestinationDomainStrategy *
-ACLDestinationDomainStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLDestinationDomainStrategy ACLDestinationDomainStrategy::Instance_;
-

=== modified file 'src/acl/DestinationDomain.h'
--- src/acl/DestinationDomain.h	2017-01-01 00:12:22 +0000
+++ src/acl/DestinationDomain.h	2017-05-14 17:55:12 +0000
@@ -3,65 +3,44 @@
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLDESTINATIONDOMAIN_H
 #define SQUID_ACLDESTINATIONDOMAIN_H
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 #include "dns/forward.h"
 
 /// \ingroup ACLAPI
 class ACLDestinationDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLDestinationDomainStrategy *Instance();
+    /* ACLStrategy API */
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends
-     */
-    ACLDestinationDomainStrategy(ACLDestinationDomainStrategy const &);
+    virtual const Acl::Options &options();
 
 private:
-    static ACLDestinationDomainStrategy Instance_;
-    ACLDestinationDomainStrategy() {}
-
-    ACLDestinationDomainStrategy&operator=(ACLDestinationDomainStrategy const &);
+    Acl::BooleanOptionValue lookupBanned; ///< Are DNS lookups allowed?
 };
 
 /// \ingroup ACLAPI
 class DestinationDomainLookup : public ACLChecklist::AsyncState
 {
 
 public:
     static DestinationDomainLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
 
 private:
     static DestinationDomainLookup instance_;
     static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };
 
-/// \ingroup ACLAPI
-class ACLDestinationDomain
-{
-
-private:
-    static ACL::Prototype LiteralRegistryProtoype;
-    static ACLStrategised<char const *> LiteralRegistryEntry_;
-    static ACL::Prototype RegexRegistryProtoype;
-    static ACLStrategised<char const *> RegexRegistryEntry_;
-};
-
 #endif /* SQUID_ACLDESTINATIONDOMAIN_H */
 

=== modified file 'src/acl/DestinationIp.cc'
--- src/acl/DestinationIp.cc	2017-01-01 00:12:22 +0000
+++ src/acl/DestinationIp.cc	2017-05-14 17:55:12 +0000
@@ -1,67 +1,74 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/DestinationIp.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "http/Stream.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
-ACLFlag ACLDestinationIP::SupportedFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
-
 char const *
 ACLDestinationIP::typeString() const
 {
     return "dst";
 }
 
+const Acl::Options &
+ACLDestinationIP::options()
+{
+    static const Acl::BooleanOption LookupBan;
+    static const Acl::Options MyOptions = { { "-n", &LookupBan } };
+    LookupBan.linkWith(&lookupBanned);
+    return MyOptions;
+}
+
 int
 ACLDestinationIP::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
     // if there is no HTTP request details fallback to the dst_addr
     if (!checklist->request)
         return ACLIP::match(checklist->dst_addr);
 
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
     if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.interceptTproxy)) {
         const auto conn = checklist->conn();
         return (conn && conn->clientConnection) ?
                ACLIP::match(conn->clientConnection->local) : -1;
     }
 
-    if (flags.isSet(ACL_F_NO_LOOKUP)) {
+    if (lookupBanned) {
         if (!checklist->request->url.hostIsNumeric()) {
             debugs(28, 3, "No-lookup DNS ACL '" << AclMatchedName << "' for " << checklist->request->url.host());
             return 0;
         }
 
         if (ACLIP::match(checklist->request->url.hostIP()))
             return 1;
         return 0;
     }
 
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->url.host(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
         /* Entry in cache found */
 
         for (int k = 0; k < (int) ia->count; ++k) {
             if (ACLIP::match(ia->in_addrs[k]))
                 return 1;
         }
 

=== modified file 'src/acl/DestinationIp.h'
--- src/acl/DestinationIp.h	2017-01-01 00:12:22 +0000
+++ src/acl/DestinationIp.h	2017-05-14 17:55:12 +0000
@@ -13,34 +13,32 @@
 #include "acl/Ip.h"
 #include "ipcache.h"
 
 class DestinationIPLookup : public ACLChecklist::AsyncState
 {
 
 public:
     static DestinationIPLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
 
 private:
     static DestinationIPLookup instance_;
     static IPH LookupDone;
 };
 
 class ACLDestinationIP : public ACLIP
 {
     MEMPROXY_CLASS(ACLDestinationIP);
 
 public:
-    ACLDestinationIP(): ACLIP(ACLDestinationIP::SupportedFlags) {}
     virtual char const *typeString() const;
+    virtual const Acl::Options &options();
     virtual int match(ACLChecklist *checklist);
 
     virtual ACL *clone()const;
 
-    static ACLFlag SupportedFlags[];
 private:
-    static Prototype RegistryProtoype;
-    static ACLDestinationIP RegistryEntry_;
+    Acl::BooleanOptionValue lookupBanned; ///< are DNS lookups allowed?
 };
 
 #endif /* SQUID_ACLDESTINATIONIP_H */
 

=== modified file 'src/acl/Eui64.h'
--- src/acl/Eui64.h	2017-01-01 00:12:22 +0000
+++ src/acl/Eui64.h	2017-05-14 17:55:12 +0000
@@ -1,48 +1,45 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLEUI64_H
 #define SQUID_ACLEUI64_H
 
 #include "acl/Acl.h"
-#include "acl/Checklist.h"
 
 #include <set>
 
 namespace Eui
 {
 class Eui64;
 };
 
 class ACLEui64 : public ACL
 {
     MEMPROXY_CLASS(ACLEui64);
 
 public:
     ACLEui64(char const *);
     ACLEui64(ACLEui64 const &);
     ~ACLEui64() {}
     ACLEui64&operator=(ACLEui64 const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
-    static Prototype RegistryProtoype;
-    static ACLEui64 RegistryEntry_;
     typedef std::set<Eui::Eui64> Eui64Data_t;
     Eui64Data_t eui64Data;
     char const *class_;
 };
 
 #endif /* SQUID_ACLEUI64_H */
 

=== modified file 'src/acl/ExtUser.cc'
--- src/acl/ExtUser.cc	2017-01-01 00:12:22 +0000
+++ src/acl/ExtUser.cc	2017-05-14 17:55:12 +0000
@@ -27,40 +27,46 @@
 ACLExtUser::ACLExtUser(ACLData<char const *> *newData, char const *newType) : data (newData), type_ (newType) {}
 
 ACLExtUser::ACLExtUser (ACLExtUser const &old) : data (old.data->clone()), type_ (old.type_)
 {}
 
 ACLExtUser &
 ACLExtUser::operator= (ACLExtUser const &rhs)
 {
     data = rhs.data->clone();
     type_ = rhs.type_;
     return *this;
 }
 
 char const *
 ACLExtUser::typeString() const
 {
     return type_;
 }
 
 void
+ACLExtUser::parseFlags()
+{
+    ParseFlags(Acl::NoOptions(), data->supportedFlags());
+}
+
+void
 ACLExtUser::parse()
 {
     data->parse();
 }
 
 int
 ACLExtUser::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->request->extacl_user.size()) {
         return data->match(checklist->request->extacl_user.termedBuf());
     } else {
         return -1;
     }
 }
 
 SBufList
 ACLExtUser::dump() const
 {
     return data->dump();

=== modified file 'src/acl/ExtUser.h'
--- src/acl/ExtUser.h	2017-01-01 00:12:22 +0000
+++ src/acl/ExtUser.h	2017-05-14 17:55:12 +0000
@@ -8,40 +8,37 @@
 
 #ifndef SQUID_EXTUSER_H
 #define SQUID_EXTUSER_H
 
 #if USE_AUTH
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 
 class ACLExtUser : public ACL
 {
     MEMPROXY_CLASS(ACLExtUser);
 
 public:
     ACLExtUser(ACLData<char const *> *newData, char const *);
     ACLExtUser (ACLExtUser const &old);
     ACLExtUser & operator= (ACLExtUser const &rhs);
     ~ACLExtUser();
 
+    /* ACL API */
     virtual char const *typeString() const;
     virtual void parse();
-
+    virtual void parseFlags();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual ACL *clone()const;
 
 private:
-    static Prototype UserRegistryProtoype;
-    static ACLExtUser UserRegistryEntry_;
-    static Prototype RegexRegistryProtoype;
-    static ACLExtUser RegexRegistryEntry_;
     ACLData<char const *> *data;
     char const *type_;
 };
 
 #endif /* USE_AUTH */
 #endif /* SQUID_EXTUSER_H */
 

=== modified file 'src/acl/HierCode.cc'
--- src/acl/HierCode.cc	2017-01-01 00:12:22 +0000
+++ src/acl/HierCode.cc	2017-05-14 17:55:12 +0000
@@ -1,32 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/HierCode.h"
 #include "acl/HierCodeData.h"
+#include "acl/Strategised.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<hier_code>;
 
 int
-ACLHierCodeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLHierCodeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->request->hier.code);
 }
 
-ACLHierCodeStrategy *
-ACLHierCodeStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLHierCodeStrategy ACLHierCodeStrategy::Instance_;
-

=== modified file 'src/acl/HierCode.h'
--- src/acl/HierCode.h	2017-01-01 00:12:22 +0000
+++ src/acl/HierCode.h	2017-05-14 17:55:12 +0000
@@ -1,51 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLHIERCODE_H
 #define SQUID_ACLHIERCODE_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "hier_code.h"
 
 /// \ingroup ACLAPI
 class ACLHierCodeStrategy : public ACLStrategy<hier_code>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLHierCodeStrategy *Instance();
-
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends
-     */
-    ACLHierCodeStrategy(ACLHierCodeStrategy const &);
-
-private:
-    static ACLHierCodeStrategy Instance_;
-    ACLHierCodeStrategy() {}
-
-    ACLHierCodeStrategy &operator=(ACLHierCodeStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLHierCode
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<hier_code> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLHIERCODE_H */
 

=== modified file 'src/acl/HttpRepHeader.cc'
--- src/acl/HttpRepHeader.cc	2017-01-01 00:12:22 +0000
+++ src/acl/HttpRepHeader.cc	2017-05-14 17:55:12 +0000
@@ -1,28 +1,20 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/HttpRepHeader.h"
 #include "HttpReply.h"
 
 int
-ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (&checklist->reply->header);
 }
 
-ACLHTTPRepHeaderStrategy *
-ACLHTTPRepHeaderStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLHTTPRepHeaderStrategy ACLHTTPRepHeaderStrategy::Instance_;
-

=== modified file 'src/acl/HttpRepHeader.h'
--- src/acl/HttpRepHeader.h	2017-01-01 00:12:22 +0000
+++ src/acl/HttpRepHeader.h	2017-05-14 17:55:12 +0000
@@ -1,50 +1,26 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLHTTPREPHEADER_H
 #define SQUID_ACLHTTPREPHEADER_H
 
 #include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "HttpHeader.h"
 
 /// \ingroup ACLAPI
 class ACLHTTPRepHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresReply() const { return true; }
-
-    static ACLHTTPRepHeaderStrategy *Instance();
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends
-     */
-    ACLHTTPRepHeaderStrategy(ACLHTTPRepHeaderStrategy const &);
-
-private:
-    static ACLHTTPRepHeaderStrategy Instance_;
-    ACLHTTPRepHeaderStrategy() { }
-
-    ACLHTTPRepHeaderStrategy&operator = (ACLHTTPRepHeaderStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLHTTPRepHeader
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<HttpHeader*> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLHTTPREPHEADER_H */
 

=== modified file 'src/acl/HttpReqHeader.cc'
--- src/acl/HttpReqHeader.cc	2017-01-01 00:12:22 +0000
+++ src/acl/HttpReqHeader.cc	2017-05-14 17:55:12 +0000
@@ -1,28 +1,20 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/HttpReqHeader.h"
 #include "HttpRequest.h"
 
 int
-ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (&checklist->request->header);
 }
 
-ACLHTTPReqHeaderStrategy *
-ACLHTTPReqHeaderStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLHTTPReqHeaderStrategy ACLHTTPReqHeaderStrategy::Instance_;
-

=== modified file 'src/acl/HttpReqHeader.h'
--- src/acl/HttpReqHeader.h	2017-01-01 00:12:22 +0000
+++ src/acl/HttpReqHeader.h	2017-05-14 17:55:12 +0000
@@ -1,47 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLHTTPREQHEADER_H
 #define SQUID_ACLHTTPREQHEADER_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "HttpHeader.h"
 
 /// \ingroup ACLAPI
 class ACLHTTPReqHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const { return true; }
-
-    static ACLHTTPReqHeaderStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLHTTPReqHeaderStrategy(ACLHTTPReqHeaderStrategy const &);
-
-private:
-    static ACLHTTPReqHeaderStrategy Instance_;
-    ACLHTTPReqHeaderStrategy() { }
-
-    ACLHTTPReqHeaderStrategy&operator = (ACLHTTPReqHeaderStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLHTTPReqHeader
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<HttpHeader*> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLHTTPREQHEADER_H */
 

=== modified file 'src/acl/HttpStatus.h'
--- src/acl/HttpStatus.h	2017-01-01 00:12:22 +0000
+++ src/acl/HttpStatus.h	2017-05-14 17:55:12 +0000
@@ -26,28 +26,26 @@
 /// \ingroup ACLAPI
 class ACLHTTPStatus : public ACL
 {
     MEMPROXY_CLASS(ACLHTTPStatus);
 
 public:
     ACLHTTPStatus(char const *);
     ACLHTTPStatus(ACLHTTPStatus const &);
     ~ACLHTTPStatus();
     ACLHTTPStatus&operator=(ACLHTTPStatus const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool requiresReply() const { return true; }
 
 protected:
-    static Prototype RegistryProtoype;
-    static ACLHTTPStatus RegistryEntry_;
     Splay<acl_httpstatus_data*> *data;
     char const *class_;
 };
 
 #endif /* SQUID_ACLHTTPSTATUS_H */
 

=== modified file 'src/acl/Ip.cc'
--- src/acl/Ip.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Ip.cc	2017-05-14 17:55:12 +0000
@@ -460,42 +460,40 @@
     changed = 0;
     changed += q->addr1.applyMask(q->mask);
     changed += q->addr2.applyMask(q->mask);
 
     if (changed)
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: WARNING: Netmask masks away part of the specified IP in '" << t << "'");
 
     debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.cidr() <<")");
 
     /* 1.2.3.4/255.255.255.0  --> 1.2.3.0 */
     /* Same as IPv6 (not so trivial to depict) */
     return q;
 }
 
 void
 ACLIP::parse()
 {
     if (data == NULL)
         data = new IPSplay();
 
-    flags.parseFlags();
-
     while (char *t = ConfigParser::strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
             /* pop each result off the list and add it to the data tree individually */
             acl_ip_data *next_node = q->next;
             q->next = NULL;
             if (!data->find(q,acl_ip_data::NetworkCompare))
                 data->insert(q, acl_ip_data::NetworkCompare);
             q = next_node;
         }
     }
 }
 
 ACLIP::~ACLIP()
 {
     if (data) {
         data->destroy();
         delete data;
     }

=== modified file 'src/acl/Ip.h'
--- src/acl/Ip.h	2017-01-01 00:12:22 +0000
+++ src/acl/Ip.h	2017-05-14 17:55:12 +0000
@@ -31,42 +31,40 @@
     Ip::Address addr1;
 
     Ip::Address addr2;
 
     Ip::Address mask; /**< \todo This should perhapse be stored as a CIDR range now instead of a full IP mask. */
 
     acl_ip_data *next;      /**< used for parsing, not for storing */
 
 private:
 
     static bool DecodeMask(const char *asc, Ip::Address &mask, int string_format_type);
 };
 
 class ACLIP : public ACL
 {
 public:
     void *operator new(size_t);
     void operator delete(void *);
 
     ACLIP() : data(NULL) {}
-    explicit ACLIP(const ACLFlag flgs[]) : ACL(flgs), data(NULL) {}
-
     ~ACLIP();
 
     typedef Splay<acl_ip_data *> IPSplay;
 
     virtual char const *typeString() const = 0;
     virtual void parse();
     //    virtual bool isProxyAuth() const {return true;}
     virtual int match(ACLChecklist *checklist) = 0;
     virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
 
     int match(const Ip::Address &);
     IPSplay *data;
 
 };
 
 #endif /* SQUID_ACLIP_H */
 

=== modified file 'src/acl/LocalIp.h'
--- src/acl/LocalIp.h	2017-01-01 00:12:22 +0000
+++ src/acl/LocalIp.h	2017-05-14 17:55:12 +0000
@@ -1,32 +1,26 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLLOCALIP_H
 #define SQUID_ACLLOCALIP_H
 
 #include "acl/Ip.h"
 
 /// \ingroup ACLAPI
 class ACLLocalIP : public ACLIP
 {
     MEMPROXY_CLASS(ACLLocalIP);
 
 public:
-    static ACLLocalIP const &RegistryEntry();
-
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
-
-private:
-    static Prototype RegistryProtoype;
-    static ACLLocalIP RegistryEntry_;
 };
 
 #endif /* SQUID_ACLLOCALIP_H */
 

=== modified file 'src/acl/LocalPort.cc'
--- src/acl/LocalPort.cc	2017-01-01 00:12:22 +0000
+++ src/acl/LocalPort.cc	2017-05-14 17:55:12 +0000
@@ -1,27 +1,18 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
-#include "acl/IntRange.h"
+#include "acl/FilledChecklist.h"
 #include "acl/LocalPort.h"
 
 int
-ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->my_addr.port());
 }
 
-ACLLocalPortStrategy *
-ACLLocalPortStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLLocalPortStrategy ACLLocalPortStrategy::Instance_;
-

=== modified file 'src/acl/LocalPort.h'
--- src/acl/LocalPort.h	2017-01-01 00:12:22 +0000
+++ src/acl/LocalPort.h	2017-05-23 14:28:36 +0000
@@ -1,47 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLLOCALPORT_H
 #define SQUID_ACLLOCALPORT_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 
 /// \ingroup ACLAPI
 class ACLLocalPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLLocalPortStrategy *Instance();
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends
-     */
-    ACLLocalPortStrategy(ACLLocalPortStrategy const &);
-
-private:
-    static ACLLocalPortStrategy Instance_;
-    ACLLocalPortStrategy() {}
-
-    ACLLocalPortStrategy&operator=(ACLLocalPortStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLLocalPort
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<int> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLLOCALPORT_H */
 

=== modified file 'src/acl/Makefile.am'
--- src/acl/Makefile.am	2017-01-30 12:46:15 +0000
+++ src/acl/Makefile.am	2017-05-14 17:55:12 +0000
@@ -6,81 +6,82 @@
 ##
 
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
 SUBDIRS= external
 
 noinst_LTLIBRARIES = libapi.la libstate.la libacls.la
 
 ## General data-independent ACL API
 libapi_la_SOURCES = \
 	Acl.cc \
 	Acl.h \
 	BoolOps.cc \
 	BoolOps.h \
 	Checklist.cc \
 	Checklist.h \
 	forward.h \
 	InnerNode.cc \
 	InnerNode.h \
+	Options.h \
+	Options.cc \
 	Tree.cc \
 	Tree.h
 
 ## Data-dependent Squid/transaction state used by specific ACLs.
 ## Does not refer to specific ACLs to avoid circular dependencies.
 libstate_la_SOURCES = \
+	CharacterSetOption.h \
 	Data.h \
 	Strategy.h \
 	Strategised.cc \
 	Strategised.h \
 	FilledChecklist.cc \
 	FilledChecklist.h \
 	Address.h \
 	Address.cc
 
 ## data-specific ACLs
 libacls_la_SOURCES = \
 	IntRange.cc \
 	IntRange.h \
 	RegexData.cc \
 	RegexData.h \
 	StringData.cc \
 	StringData.h \
 	Time.cc \
 	Time.h \
 	TimeData.cc \
 	TimeData.h \
 	AllOf.cc \
 	AllOf.h \
 	AnnotateClient.cc \
 	AnnotateClient.h \
 	AnnotateTransaction.cc \
 	AnnotateTransaction.h \
 	AnnotationData.cc \
 	AnnotationData.h \
 	AnyOf.cc \
 	AnyOf.h \
 	Asn.cc \
 	Asn.h \
-	Browser.cc \
-	Browser.h \
 	ConnectionsEncrypted.cc \
 	ConnectionsEncrypted.h \
 	DestinationAsn.h \
 	DestinationDomain.cc \
 	DestinationDomain.h \
 	DestinationIp.cc \
 	DestinationIp.h \
 	DomainData.cc \
 	DomainData.h \
 	ExtUser.cc \
 	ExtUser.h \
 	HierCodeData.cc \
 	HierCodeData.h \
 	HierCode.cc \
 	HierCode.h \
 	HttpHeaderData.cc \
 	HttpHeaderData.h \
 	HttpRepHeader.cc \
 	HttpRepHeader.h \
 	HttpReqHeader.cc \
@@ -96,47 +97,43 @@
 	MaxConnection.cc \
 	MaxConnection.h \
 	Method.cc \
 	MethodData.cc \
 	MethodData.h \
 	Method.h \
 	MyPortName.cc \
 	MyPortName.h \
 	Note.h \
 	Note.cc \
 	NoteData.h \
 	NoteData.cc \
 	PeerName.cc \
 	PeerName.h \
 	Protocol.cc \
 	ProtocolData.cc \
 	ProtocolData.h \
 	Protocol.h \
 	Random.cc \
 	Random.h \
-	Referer.cc \
-	Referer.h \
 	ReplyHeaderStrategy.h \
-	ReplyMimeType.cc \
 	ReplyMimeType.h \
 	RequestHeaderStrategy.h \
-	RequestMimeType.cc \
 	RequestMimeType.h \
 	SourceAsn.h \
 	SourceDomain.cc \
 	SourceDomain.h \
 	SourceIp.cc \
 	SourceIp.h \
 	SquidError.h \
 	SquidError.cc \
 	SquidErrorData.cc \
 	SquidErrorData.h \
 	Tag.cc \
 	Tag.h \
 	Url.cc \
 	Url.h \
 	UrlLogin.cc \
 	UrlLogin.h \
 	UrlPath.cc \
 	UrlPath.h \
 	UrlPort.cc \
 	UrlPort.h \

=== modified file 'src/acl/MaxConnection.h'
--- src/acl/MaxConnection.h	2017-01-01 00:12:22 +0000
+++ src/acl/MaxConnection.h	2017-05-14 17:55:12 +0000
@@ -1,43 +1,40 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMAXCONNECTION_H
 #define SQUID_ACLMAXCONNECTION_H
 
 #include "acl/Acl.h"
-#include "acl/Checklist.h"
 
 /// \ingroup ACLAPI
 class ACLMaxConnection : public ACL
 {
     MEMPROXY_CLASS(ACLMaxConnection);
 
 public:
     ACLMaxConnection(char const *);
     ACLMaxConnection(ACLMaxConnection const &);
     ~ACLMaxConnection();
     ACLMaxConnection&operator=(ACLMaxConnection const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool valid () const;
     virtual void prepareForUse();
 
 protected:
-    static Prototype RegistryProtoype;
-    static ACLMaxConnection RegistryEntry_;
     char const *class_;
     int limit;
 };
 
 #endif /* SQUID_ACLMAXCONNECTION_H */
 

=== modified file 'src/acl/Method.cc'
--- src/acl/Method.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Method.cc	2017-05-14 17:55:12 +0000
@@ -1,32 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/Method.h"
 #include "acl/MethodData.h"
+#include "acl/Strategised.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<HttpRequestMethod>;
 
 int
-ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->request->method);
 }
 
-ACLMethodStrategy *
-ACLMethodStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLMethodStrategy ACLMethodStrategy::Instance_;
-

=== modified file 'src/acl/Method.h'
--- src/acl/Method.h	2017-01-01 00:12:22 +0000
+++ src/acl/Method.h	2017-05-14 17:55:12 +0000
@@ -1,51 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMETHOD_H
 #define SQUID_ACLMETHOD_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "http/RequestMethod.h"
 
 /// \ingroup ACLAPI
 class ACLMethodStrategy : public ACLStrategy<HttpRequestMethod>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLMethodStrategy *Instance();
-
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends
-     */
-    ACLMethodStrategy(ACLMethodStrategy const &);
-
-private:
-    static ACLMethodStrategy Instance_;
-    ACLMethodStrategy() {}
-
-    ACLMethodStrategy&operator=(ACLMethodStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLMethod
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<HttpRequestMethod> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLMETHOD_H */
 

=== modified file 'src/acl/MyPortName.cc'
--- src/acl/MyPortName.cc	2017-01-01 00:12:22 +0000
+++ src/acl/MyPortName.cc	2017-05-14 17:55:12 +0000
@@ -1,35 +1,27 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
 #include "anyp/PortCfg.h"
 #include "client_side.h"
 #include "http/Stream.h"
 #include "HttpRequest.h"
 
 int
-ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->conn() != NULL && checklist->conn()->port != NULL)
         return data->match(checklist->conn()->port->name);
     if (checklist->request != NULL)
         return data->match(checklist->request->myportname.termedBuf());
     return 0;
 }
 
-ACLMyPortNameStrategy *
-ACLMyPortNameStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLMyPortNameStrategy ACLMyPortNameStrategy::Instance_;
-

=== modified file 'src/acl/MyPortName.h'
--- src/acl/MyPortName.h	2017-01-01 00:12:22 +0000
+++ src/acl/MyPortName.h	2017-05-23 14:28:51 +0000
@@ -1,41 +1,21 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMYPORTNAME_H
 #define SQUID_ACLMYPORTNAME_H
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 
 class ACLMyPortNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLMyPortNameStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLMyPortNameStrategy(ACLMyPortNameStrategy const &);
-
-private:
-    static ACLMyPortNameStrategy Instance_;
-    ACLMyPortNameStrategy() {}
-
-    ACLMyPortNameStrategy&operator=(ACLMyPortNameStrategy const &);
-};
-
-class ACLMyPortName
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const char *> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLMYPORTNAME_H */
 

=== modified file 'src/acl/Note.cc'
--- src/acl/Note.cc	2017-01-30 12:46:15 +0000
+++ src/acl/Note.cc	2017-05-14 17:55:12 +0000
@@ -1,51 +1,55 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/Note.h"
 #include "acl/NoteData.h"
 #include "HttpRequest.h"
-#include "Notes.h"
-#include "parser/Tokenizer.h"
-#include "sbuf/StringConvert.h"
+
+/* Acl::AnnotationStrategy */
+
+const Acl::Options &
+Acl::AnnotationStrategy::options()
+{
+    static const Acl::CharacterSetOption Delimiters;
+    static const Acl::Options MyOptions = {
+        { "-m", &Delimiters }
+    };
+    Delimiters.linkWith(&delimiters);
+    return MyOptions;
+}
+
+/* ACLNoteStrategy */
 
 int
-ACLNoteStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
+ACLNoteStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (const auto request = checklist->request) {
-        if (request->hasNotes() && matchNotes(data, request->notes().getRaw(), flags.delimiters()))
+        if (request->hasNotes() && matchNotes(data, request->notes().getRaw()))
             return 1;
 #if USE_ADAPTATION
         const Adaptation::History::Pointer ah = request->adaptLogHistory();
-        if (ah != NULL && ah->metaHeaders != NULL && matchNotes(data, ah->metaHeaders.getRaw(), flags.delimiters()))
+        if (ah != NULL && ah->metaHeaders != NULL && matchNotes(data, ah->metaHeaders.getRaw()))
             return 1;
 #endif
     }
     return 0;
 }
 
 bool
-ACLNoteStrategy::matchNotes(ACLData<MatchType> *noteData, const NotePairs *note, const CharacterSet *delimiters) const
+ACLNoteStrategy::matchNotes(ACLData<MatchType> *noteData, const NotePairs *note) const
 {
-    const NotePairs::Entries &entries = note->expandListEntries(delimiters);
+    const NotePairs::Entries &entries = note->expandListEntries(&delimiters.value);
     for (auto e: entries)
         if (noteData->match(e.getRaw()))
             return true;
     return false;
 }
 
-ACLNoteStrategy *
-ACLNoteStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLNoteStrategy ACLNoteStrategy::Instance_;
-

=== modified file 'src/acl/Note.h'
--- src/acl/Note.h	2017-01-01 00:12:22 +0000
+++ src/acl/Note.h	2017-05-23 14:22:09 +0000
@@ -1,51 +1,45 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLNOTE_H
 #define SQUID_ACLNOTE_H
 
-#include "acl/Strategised.h"
+#include "acl/CharacterSetOption.h"
+#include "acl/Data.h"
 #include "acl/Strategy.h"
+#include "Notes.h"
 
-class ACLNoteData;
-class CharacterSet;
-class HttpRequest;
+namespace Acl {
 
-/// \ingroup ACLAPI
-class ACLNoteStrategy : public ACLStrategy<NotePairs::Entry *>
+/// common parent of several ACLs dealing with transaction annotations
+class AnnotationStrategy: public ACLStrategy<NotePairs::Entry *>
 {
-
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    virtual bool requiresRequest() const { return true; }
+    AnnotationStrategy(): delimiters(CharacterSet(__FILE__, ",")) {}
 
-    static ACLNoteStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLNoteStrategy(ACLNoteStrategy const &);
-
-private:
-    static ACLNoteStrategy Instance_;
-    ACLNoteStrategy() { }
+    virtual const Acl::Options &options() override;
 
-    ACLNoteStrategy& operator = (ACLNoteStrategy const &);
-    bool matchNotes(ACLData<MatchType> *, const NotePairs *, const CharacterSet *) const;
+    Acl::CharacterSetOptionValue delimiters; ///< annotation separators
 };
 
+} // namespace Acl
+
 /// \ingroup ACLAPI
-class ACLNote
+class ACLNoteStrategy: public Acl::AnnotationStrategy
 {
 
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual bool requiresRequest() const { return true; }
+
 private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<NotePairs::Entry *> RegistryEntry_;
+    bool matchNotes(ACLData<MatchType> *, const NotePairs *) const;
 };
 
 #endif /* SQUID_ACLNOTE_H */
 

=== added file 'src/acl/Options.cc'
--- src/acl/Options.cc	1970-01-01 00:00:00 +0000
+++ src/acl/Options.cc	2017-05-14 17:55:12 +0000
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "acl/Options.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "sbuf/Stream.h"
+
+#include <iostream>
+#include <vector>
+
+namespace Acl {
+
+/// low-level parser that extracts but does not interpret ACL options
+class OptionExtractor
+{
+public:
+    /// parses the next option and fills public members with its details
+    /// \returns whether option extraction was successful
+    bool extractOne();
+
+    /* extracted option details (after successful extraction */
+    SBuf name; ///< extracted option name, including dash(es)
+    bool hasValue = false; ///< whether the option has a value (-x=value)
+    const SBuf &value() const; ///< extracted option value (requires hasValue)
+
+protected:
+    bool advance();
+    void extractWhole();
+    void extractShort();
+
+private:
+    SBuf prefix_; ///< option name(s), including leading dash(es)
+    SBuf value_; ///< the last seen value of some option
+    SBuf::size_type letterPos_ = 0; ///< letter position inside an -xyz sequence
+    bool sawValue_ = false; ///< the current option sequence had a value
+};
+
+/// parses/validates/stores ACL options; skips/preserves parameter flags
+class OptionsParser
+{
+public:
+    OptionsParser(const Options &options, const ParameterFlags &flags);
+
+    // fill previously supplied options container, throwing on errors
+    void parse();
+
+private:
+    const Option *findOption(/* const */ SBuf &rawName);
+
+    /// ACL parameter flags in parsing order
+    typedef std::vector<OptionName> Names;
+    /// parsed ACL parameter flags that must be preserved for ACLData::parse()
+    static Names flagsToSkip;
+
+    const Options &options_; ///< caller-supported, linked options
+    const ParameterFlags &parameterFlags_; ///< caller-supported parameter flags
+};
+
+} // namespace Acl
+
+/* Acl::OptionNameCmp */
+
+bool
+Acl::OptionNameCmp::operator()(const OptionName a, const OptionName b) const
+{
+    return strcmp(a, b) < 0;
+}
+
+/* Acl::OptionExtractor */
+
+const SBuf &
+Acl::OptionExtractor::value() const
+{
+    Must(hasValue);
+    return value_;
+}
+
+bool
+Acl::OptionExtractor::extractOne()
+{
+    if (!prefix_.isEmpty()) {
+        extractShort(); // continue with the previously extracted flags
+        return true;
+    }
+
+    if (!advance())
+        return false; // end of options (and, possibly, the whole "acl" directive)
+
+    if (prefix_.length() < 2)
+        throw TexcHere(ToSBuf("truncated(?) ACL flag: ", prefix_)); // single - or +
+
+    if (prefix_[0] == '-' && prefix_[1] == '-') {
+        if (prefix_.length() == 2)
+            return false; // skipped "--", an explicit end-of-options marker
+        extractWhole();
+        return true;
+    }
+
+    if (prefix_.length() == 2) { // common trivial case: -x or +y
+        extractWhole();
+        return true;
+    }
+
+    // -xyz or +xyz
+    letterPos_ = 1;
+    extractShort();
+    return true;
+}
+
+/// extracts a token with the next option/flag(s) or returns false
+bool
+Acl::OptionExtractor::advance()
+{
+    const char *next = ConfigParser::PeekAtToken();
+    if (!next)
+        return false; // end of the "acl" line
+
+    const char nextChar = *next;
+    if (!(nextChar == '-' || nextChar == '+'))
+        return false; // start of ACL parameters
+
+    sawValue_ = strchr(next, '='); // TODO: Make ConfigParser reject '^=.*' tokens
+    if (sawValue_) {
+        char *rawPrefix = nullptr;
+        char *rawValue = nullptr;
+        if (!ConfigParser::NextKvPair(rawPrefix, rawValue))
+            throw TexcHere(ToSBuf("Malformed acl option=value: ", next));
+        prefix_.assign(rawPrefix);
+        value_.assign(rawValue);
+    } else {
+        prefix_.assign(next);
+        ConfigParser::NextToken(); // consume what we have peeked at
+    }
+    return true;
+}
+
+/// handles -x[=option] or --foo[=option]
+void
+Acl::OptionExtractor::extractWhole()
+{
+    debugs(28, 8, "from " << prefix_ << " value: " << sawValue_);
+    hasValue = sawValue_;
+    name = prefix_;
+    prefix_.clear();
+}
+
+/// handles one flag letter inside an -xyx[=option] or +xyz[=option] sequence
+void
+Acl::OptionExtractor::extractShort()
+{
+    debugs(28, 8, "from " << prefix_ << " at " << letterPos_ << " value: " << sawValue_);
+    name.assign(prefix_.rawContent(), 1); // leading - or +
+    name.append(prefix_.at(letterPos_++));
+    if (letterPos_ >= prefix_.length()) { // got last flag in the sequence
+        hasValue = sawValue_;
+        prefix_.clear();
+    } else {
+        hasValue = false;
+    }
+}
+
+/* Acl::OptionsParser */
+
+// being "static" is an optimization to avoid paying for vector creation/growth
+Acl::OptionsParser::Names Acl::OptionsParser::flagsToSkip;
+
+Acl::OptionsParser::OptionsParser(const Options &options, const ParameterFlags &flags):
+    options_(options),
+    parameterFlags_(flags)
+{
+}
+
+const Acl::Option *
+Acl::OptionsParser::findOption(/* const */ SBuf &rawNameBuf)
+{
+    // TODO: new std::map::find() in C++14 does not require this conversion
+    const auto rawName = rawNameBuf.c_str();
+
+    const auto optionPos = options_.find(rawName);
+    if (optionPos != options_.end())
+        return optionPos->second;
+
+    const auto flagPos = parameterFlags_.find(rawName);
+    if (flagPos != parameterFlags_.end()) {
+        flagsToSkip.push_back(*flagPos); // *flagPos is permanent unlike rawName
+        return nullptr;
+    }
+
+    throw TexcHere(ToSBuf("unsupported ACL option: ", rawNameBuf));
+}
+
+void
+Acl::OptionsParser::parse()
+{
+    flagsToSkip.clear();
+
+    OptionExtractor oex;
+    while (oex.extractOne()) {
+        /* const */ auto rawName = oex.name;
+        if (const Option *optionPtr = findOption(rawName)) {
+            const Option &option = *optionPtr;
+            if (option.configured())
+                debugs(28, 7, "acl uses multiple " << rawName << " options");
+            switch (option.valueExpectation)
+            {
+            case Option::valueNone:
+                if (oex.hasValue)
+                    throw TexcHere(ToSBuf("unexpected value for an ACL option: ", rawName, '=', oex.value()));
+                option.configureDefault();
+                break;
+            case Option::valueRequired:
+                if (!oex.hasValue)
+                    throw TexcHere(ToSBuf("missing required value for ACL option ", rawName));
+                option.configureWith(oex.value());
+                break;
+            case Option::valueOptional:
+                if (oex.hasValue)
+                    option.configureWith(oex.value());
+                else
+                    option.configureDefault();
+                break;
+            }
+        }
+        // else skip supported parameter flag
+    }
+
+    /* hack: regex code wants to parse all -i and +i flags itself */
+    for (const auto name: flagsToSkip)
+        ConfigParser::TokenPutBack(name);
+}
+
+void
+Acl::ParseFlags(const Options &options, const ParameterFlags &flags)
+{
+    OptionsParser parser(options, flags);
+    parser.parse();
+}
+
+const Acl::Options &
+Acl::NoOptions()
+{
+    static const Options none;
+    return none;
+}
+
+const Acl::ParameterFlags &
+Acl::NoFlags()
+{
+    static const ParameterFlags none;
+    return none;
+}
+
+std::ostream &
+operator <<(std::ostream &os, const Acl::Option &option)
+{
+    if (option.valued()) {
+        os << '=';
+        option.print(os);
+    }
+    return os;
+}
+
+std::ostream &
+operator <<(std::ostream &os, const Acl::Options &options)
+{
+    for (const auto pos: options) {
+        assert(pos.second);
+        const auto &option = *pos.second;
+        if (option.configured())
+            os << pos.first << option;
+    }
+    // TODO: Remember "--" presence and print that delimiter when present.
+    // Detecting its need is difficult because parameter flags start with "-".
+    return os;
+}
+

=== added file 'src/acl/Options.h'
--- src/acl/Options.h	1970-01-01 00:00:00 +0000
+++ src/acl/Options.h	2017-05-23 14:51:59 +0000
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_ACL_OPTIONS_H
+#define SQUID_ACL_OPTIONS_H
+
+#include "acl/forward.h"
+#include "sbuf/forward.h"
+
+#include <iosfwd>
+#include <map>
+#include <set>
+
+// After all same-name acl configuration lines are merged into one ACL:
+//   configuration = acl name type [option...] [[flag...] parameter...]
+//   option = -x[=value] | --name[=value]
+//   flag = option
+//
+// Options and flags use the same syntax, but differ in scope and handling code:
+// * ACL options appear before all parameters and apply to all parameters.
+//   They are handled by ACL kids (or equivalent).
+// * Parameter flags may appear after some other parameters and apply only to
+//   the subsequent parameters (until they are overwritten by later flags).
+//   They are handled by ACLData kids.
+// ACL options parsing code skips and leaves leading parameter flags (if any)
+// for ACLData code to process.
+
+namespace Acl {
+
+typedef const char *OptionName;
+
+/// A single option supported by an ACL: -x[=value] or --name[=value]
+/// Unlike a parameter flag, this option applies to all ACL parameters.
+class Option
+{
+public:
+    typedef enum { valueNone, valueOptional, valueRequired } ValueExpectation;
+    explicit Option(ValueExpectation vex = valueNone): valueExpectation(vex) {}
+    virtual ~Option() {}
+
+    /// whether the admin explicitly specified this option
+    /// (i.e., whether configureWith() or configureDefault() has been called)
+    virtual bool configured() const = 0;
+
+    /// called after parsing -x or --name
+    virtual void configureDefault() const = 0;
+
+    /// called after parsing -x=value or --name=value
+    virtual void configureWith(const SBuf &rawValue) const = 0;
+
+    virtual bool valued() const = 0;
+
+    /// prints a configuration snippet (as an admin could have typed)
+    virtual void print(std::ostream &os) const = 0;
+
+    ValueExpectation valueExpectation = valueNone; ///< expect "=value" part?
+};
+
+/// Stores configuration of a typical boolean flag or a single-value Option.
+template <class Value>
+class OptionValue
+{
+public:
+    typedef Value value_type;
+
+    OptionValue(): value {} {}
+    explicit OptionValue(const Value &aValue): value(aValue) {}
+
+    explicit operator bool() const { return configured; }
+
+    Value value; ///< final value storage, possibly after conversions
+    bool configured = false; ///< whether the option was present in squid.conf
+    bool valued = false; ///< whether a configured option had a value
+};
+
+/// a type-specific Option (e.g., a boolean --toggle or -m=SBuf)
+template <class Recipient>
+class TypedOption: public Option
+{
+public:
+    //typedef typename Recipient::value_type value_type;
+    explicit TypedOption(ValueExpectation vex = valueNone): Option(vex) {}
+
+    /// who to tell when this option is enabled
+    void linkWith(Recipient *recipient) const
+    {
+        assert(recipient);
+        recipient_ = recipient;
+    }
+
+    /* Option API */
+
+    virtual bool configured() const override { return recipient_ && recipient_->configured; }
+    virtual bool valued() const override { return recipient_ && recipient_->valued; }
+
+    /// sets the default value when option is used without a value
+    virtual void configureDefault() const override
+    {
+        assert(recipient_);
+        recipient_->configured = true;
+        recipient_->valued = false;
+        // sets recipient_->value to default
+        setDefault();
+    }
+
+    /// sets the option value from rawValue
+    virtual void configureWith(const SBuf &rawValue) const override
+    {
+        assert(recipient_);
+        recipient_->configured = true;
+        recipient_->valued = true;
+        import(rawValue);
+    }
+
+    virtual void print(std::ostream &os) const override { if (valued()) os << recipient_->value; }
+
+private:
+    void import(const SBuf &rawValue) const { recipient_->value = rawValue; }
+    void setDefault() const { /*leave recipient_->value as is*/}
+
+    // The "mutable" specifier demarcates set-once Option kind/behavior from the
+    // ever-changing recipient of the actual admin-configured option value.
+    mutable Recipient *recipient_ = nullptr; ///< parsing results storage
+};
+
+/* two typical option kinds: --foo and --bar=text  */
+typedef OptionValue<bool> BooleanOptionValue;
+typedef OptionValue<SBuf> TextOptionValue;
+typedef TypedOption<BooleanOptionValue> BooleanOption;
+typedef TypedOption<TextOptionValue> TextOption;
+
+// this specialization should never be called until we start supporting
+// boolean option values like --name=enable or --name=false
+template <>
+inline void
+BooleanOption::import(const SBuf &) const
+{
+    assert(!"boolean options do not have ...=values (for now)");
+}
+
+template <>
+inline void
+BooleanOption::setDefault() const
+{
+    recipient_->value = true;
+}
+
+/// option name comparison functor
+class OptionNameCmp {
+public:
+    bool operator()(const OptionName a, const OptionName b) const;
+};
+/// name:option map
+typedef std::map<OptionName, const Option*, OptionNameCmp> Options;
+
+/// a set of parameter flag names
+typedef std::set<OptionName, OptionNameCmp> ParameterFlags;
+
+/// parses the flags part of the being-parsed ACL, filling Option values
+/// \param options options supported by the ACL as a whole (e.g., -n)
+/// \param flags options supported by ACL parameter(s) (e.g., -i)
+void ParseFlags(const Options &options, const ParameterFlags &flags);
+
+/* handy for Class::options() and Class::supportedFlags() defaults */
+const Options &NoOptions(); ///< \returns an empty Options container
+const ParameterFlags &NoFlags(); ///< \returns an empty ParameterFlags container
+
+} // namespace Acl
+
+std::ostream &operator <<(std::ostream &os, const Acl::Option &option);
+std::ostream &operator <<(std::ostream &os, const Acl::Options &options);
+
+#endif /* SQUID_ACL_OPTIONS_H */
+

=== modified file 'src/acl/PeerName.cc'
--- src/acl/PeerName.cc	2017-01-01 00:12:22 +0000
+++ src/acl/PeerName.cc	2017-05-14 17:55:12 +0000
@@ -1,31 +1,22 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/PeerName.h"
 #include "acl/RegexData.h"
 #include "acl/StringData.h"
-#include "CachePeer.h"
 
 int
-ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (!checklist->dst_peer_name.isEmpty())
         return data->match(checklist->dst_peer_name.c_str());
     return 0;
 }
 
-ACLPeerNameStrategy *
-ACLPeerNameStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLPeerNameStrategy ACLPeerNameStrategy::Instance_;
-

=== modified file 'src/acl/PeerName.h'
--- src/acl/PeerName.h	2017-01-01 00:12:22 +0000
+++ src/acl/PeerName.h	2017-05-23 14:36:02 +0000
@@ -1,44 +1,22 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLPEERNAME_H
 #define SQUID_ACLPEERNAME_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 
 class ACLPeerNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLPeerNameStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLPeerNameStrategy(ACLPeerNameStrategy const &);
-
-private:
-    static ACLPeerNameStrategy Instance_;
-    ACLPeerNameStrategy() {}
-
-    ACLPeerNameStrategy&operator=(ACLPeerNameStrategy const &);
-};
-
-class ACLPeerName
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const char *> RegistryEntry_;
-    static ACL::Prototype RegexRegistryProtoype;
-    static ACLStrategised<char const *> RegexRegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLPEERNAME_H */
 

=== modified file 'src/acl/Protocol.cc'
--- src/acl/Protocol.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Protocol.cc	2017-05-14 17:55:12 +0000
@@ -1,32 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/Protocol.h"
 #include "acl/ProtocolData.h"
+#include "acl/Strategised.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<AnyP::ProtocolType>;
 
 int
-ACLProtocolStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLProtocolStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match(checklist->request->url.getScheme());
 }
 
-ACLProtocolStrategy *
-ACLProtocolStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLProtocolStrategy ACLProtocolStrategy::Instance_;
-

=== modified file 'src/acl/Protocol.h'
--- src/acl/Protocol.h	2017-01-01 00:12:22 +0000
+++ src/acl/Protocol.h	2017-05-14 17:55:12 +0000
@@ -1,45 +1,24 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLPROTOCOL_H
 #define SQUID_ACLPROTOCOL_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "anyp/ProtocolType.h"
 
 class ACLProtocolStrategy : public ACLStrategy<AnyP::ProtocolType>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLProtocolStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLProtocolStrategy(ACLProtocolStrategy const &);
-
-private:
-    static ACLProtocolStrategy Instance_;
-    ACLProtocolStrategy() {}
-
-    ACLProtocolStrategy&operator=(ACLProtocolStrategy const &);
-};
-
-class ACLProtocol
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<AnyP::ProtocolType> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLPROTOCOL_H */
 

=== modified file 'src/acl/Random.h'
--- src/acl/Random.h	2017-01-01 00:12:22 +0000
+++ src/acl/Random.h	2017-05-14 17:55:12 +0000
@@ -1,42 +1,39 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACL_RANDOM_H
 #define SQUID_ACL_RANDOM_H
 
 #include "acl/Acl.h"
-#include "acl/Checklist.h"
 
 class ACLRandom : public ACL
 {
     MEMPROXY_CLASS(ACLRandom);
 
 public:
     ACLRandom(char const *);
     ACLRandom(ACLRandom const &);
     ~ACLRandom();
     ACLRandom&operator=(ACLRandom const &);
 
     virtual ACL *clone()const;
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool valid() const;
 
 protected:
-    static Prototype RegistryProtoype;
-    static ACLRandom RegistryEntry_;
     double data;        // value to be exceeded before this ACL will match
     char pattern[256];  // pattern from config file. Used to generate 'data'
     char const *class_;
 };
 
 #endif /* SQUID_ACL_RANDOM_H */
 

=== removed file 'src/acl/Referer.cc'
--- src/acl/Referer.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Referer.cc	1970-01-01 00:00:00 +0000
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 28    Access Control */
-
-#include "squid.h"
-#include "acl/Checklist.h"
-#include "acl/Referer.h"
-#include "acl/RegexData.h"
-
-/* explicit template instantiation required for some systems */
-
-template class ACLRequestHeaderStrategy<Http::HdrType::REFERER>;
-

=== removed file 'src/acl/Referer.h'
--- src/acl/Referer.h	2017-01-01 00:12:22 +0000
+++ src/acl/Referer.h	1970-01-01 00:00:00 +0000
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_ACLREFERER_H
-#define SQUID_ACLREFERER_H
-#include "acl/Acl.h"
-#include "acl/Data.h"
-#include "acl/RequestHeaderStrategy.h"
-#include "acl/Strategised.h"
-
-class ACLReferer
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
-};
-
-#endif /* SQUID_ACLREFERER_H */
-

=== modified file 'src/acl/RegexData.cc'
--- src/acl/RegexData.cc	2017-01-01 00:12:22 +0000
+++ src/acl/RegexData.cc	2017-05-14 17:55:12 +0000
@@ -11,40 +11,47 @@
  * Copyright (c) 2011, Marcus Kool
  * Please add new claims to the CONTRIBUTORS file instead.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
 #include "base/RegexPattern.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "sbuf/Algorithms.h"
 #include "sbuf/List.h"
 
 ACLRegexData::~ACLRegexData()
 {
 }
 
+const Acl::ParameterFlags &
+ACLRegexData::supportedFlags() const
+{
+    static const Acl::ParameterFlags flags = { "-i", "+i" };
+    return flags;
+}
+
 bool
 ACLRegexData::match(char const *word)
 {
     if (!word)
         return 0;
 
     debugs(28, 3, "checking '" << word << "'");
 
     // walk the list of patterns to see if one matches
     for (auto &i : data) {
         if (i.match(word)) {
             debugs(28, 2, '\'' << i.c_str() << "' found in '" << word << '\'');
             // TODO: old code also popped the pattern to second place of the list
             // in order to reduce patterns search times.
             return 1;
         }
     }
 
     return 0;
 }

=== modified file 'src/acl/RegexData.h'
--- src/acl/RegexData.h	2017-01-01 00:12:22 +0000
+++ src/acl/RegexData.h	2017-05-14 17:55:12 +0000
@@ -7,29 +7,30 @@
  */
 
 #ifndef SQUID_ACLREGEXDATA_H
 #define SQUID_ACLREGEXDATA_H
 
 #include "acl/Data.h"
 
 #include <list>
 
 class RegexPattern;
 
 class ACLRegexData : public ACLData<char const *>
 {
     MEMPROXY_CLASS(ACLRegexData);
 
 public:
     virtual ~ACLRegexData();
     virtual bool match(char const *user);
     virtual SBufList dump() const;
     virtual void parse();
+    virtual const Acl::ParameterFlags &supportedFlags() const;
     virtual bool empty() const;
     virtual ACLData<char const *> *clone() const;
 
 private:
     std::list<RegexPattern> data;
 };
 
 #endif /* SQUID_ACLREGEXDATA_H */
 

=== modified file 'src/acl/ReplyHeaderStrategy.h'
--- src/acl/ReplyHeaderStrategy.h	2017-01-01 00:12:22 +0000
+++ src/acl/ReplyHeaderStrategy.h	2017-05-14 17:55:12 +0000
@@ -1,67 +1,40 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLREPLYHEADERSTRATEGY_H
 #define SQUID_ACLREPLYHEADERSTRATEGY_H
 
-class ACLChecklist;
-
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Strategy.h"
 #include "HttpReply.h"
 
 template <Http::HdrType header>
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresReply() const {return true;}
-
-    static ACLReplyHeaderStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLReplyHeaderStrategy(ACLReplyHeaderStrategy const &);
-
-private:
-    static ACLReplyHeaderStrategy *Instance_;
-    ACLReplyHeaderStrategy() {}
-
-    ACLReplyHeaderStrategy&operator=(ACLReplyHeaderStrategy const &);
 };
 
 template <Http::HdrType header>
 int
-ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->reply->header.getStr(header);
 
     if (NULL == theHeader)
         return 0;
 
     return data->match(theHeader);
 }
 
-template <Http::HdrType header>
-ACLReplyHeaderStrategy<header> *
-ACLReplyHeaderStrategy<header>::Instance()
-{
-    if (!Instance_)
-        Instance_ = new ACLReplyHeaderStrategy<header>;
-
-    return Instance_;
-}
-
-template <Http::HdrType header>
-ACLReplyHeaderStrategy<header> * ACLReplyHeaderStrategy<header>::Instance_ = NULL;
-
 #endif /* SQUID_REPLYHEADERSTRATEGY_H */
 

=== removed file 'src/acl/ReplyMimeType.cc'
--- src/acl/ReplyMimeType.cc	2017-01-01 00:12:22 +0000
+++ src/acl/ReplyMimeType.cc	1970-01-01 00:00:00 +0000
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 28    Access Control */
-
-#include "squid.h"
-#include "acl/Checklist.h"
-#include "acl/RegexData.h"
-#include "acl/ReplyMimeType.h"
-
-/* explicit template instantiation required for some systems */
-
-template class ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
-

=== modified file 'src/acl/ReplyMimeType.h'
--- src/acl/ReplyMimeType.h	2017-01-01 00:12:22 +0000
+++ src/acl/ReplyMimeType.h	2017-05-14 17:55:12 +0000
@@ -1,42 +1,31 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLREPLYMIMETYPE_H
 #define SQUID_ACLREPLYMIMETYPE_H
 
-#include "acl/Acl.h"
-#include "acl/Strategised.h"
-
-class ACLReplyMIMEType
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
-};
-
-/* partial specialisation */
-
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/Data.h"
 #include "acl/ReplyHeaderStrategy.h"
 
+/* partial specialisation */
+
 template <>
 inline int
-ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->reply->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
 
     return data->match(theHeader);
 }
 
 #endif /* SQUID_ACLREPLYMIMETYPE_H */
 

=== modified file 'src/acl/RequestHeaderStrategy.h'
--- src/acl/RequestHeaderStrategy.h	2017-01-01 00:12:22 +0000
+++ src/acl/RequestHeaderStrategy.h	2017-05-14 17:55:12 +0000
@@ -2,63 +2,38 @@
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLREQUESTHEADERSTRATEGY_H
 #define SQUID_ACLREQUESTHEADERSTRATEGY_H
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Strategy.h"
 #include "HttpRequest.h"
 
 template <Http::HdrType header>
 class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLRequestHeaderStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLRequestHeaderStrategy(ACLRequestHeaderStrategy const &);
-
-private:
-    static ACLRequestHeaderStrategy *Instance_;
-    ACLRequestHeaderStrategy() {}
-
-    ACLRequestHeaderStrategy&operator=(ACLRequestHeaderStrategy const &);
 };
 
 template <Http::HdrType header>
 int
-ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->request->header.getStr(header);
 
     if (NULL == theHeader)
         return 0;
 
     return data->match(theHeader);
 }
 
-template <Http::HdrType header>
-ACLRequestHeaderStrategy<header> *
-ACLRequestHeaderStrategy<header>::Instance()
-{
-    if (!Instance_)
-        Instance_ = new ACLRequestHeaderStrategy<header>;
-
-    return Instance_;
-}
-
-template <Http::HdrType header>
-ACLRequestHeaderStrategy<header> * ACLRequestHeaderStrategy<header>::Instance_ = NULL;
-
 #endif /* SQUID_REQUESTHEADERSTRATEGY_H */
 

=== removed file 'src/acl/RequestMimeType.cc'
--- src/acl/RequestMimeType.cc	2017-01-01 00:12:22 +0000
+++ src/acl/RequestMimeType.cc	1970-01-01 00:00:00 +0000
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 28    Access Control */
-
-#include "squid.h"
-#include "acl/Checklist.h"
-#include "acl/RegexData.h"
-#include "acl/RequestMimeType.h"
-
-/* explicit template instantiation required for some systems */
-
-template class ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
-

=== modified file 'src/acl/RequestMimeType.h'
--- src/acl/RequestMimeType.h	2017-01-01 00:12:22 +0000
+++ src/acl/RequestMimeType.h	2017-05-14 17:55:12 +0000
@@ -1,42 +1,31 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLREQUESTMIMETYPE_H
 #define SQUID_ACLREQUESTMIMETYPE_H
 
-#include "acl/Acl.h"
-#include "acl/Strategised.h"
-
-class ACLRequestMIMEType
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
-};
-
-/* partial specialisation */
-
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/Data.h"
 #include "acl/RequestHeaderStrategy.h"
 
+/* partial specialisation */
+
 template <>
 inline int
-ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->request->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
 
     return data->match(theHeader);
 }
 
 #endif /* SQUID_ACLREQUESTMIMETYPE_H */
 

=== modified file 'src/acl/ServerCertificate.cc'
--- src/acl/ServerCertificate.cc	2017-01-01 00:12:22 +0000
+++ src/acl/ServerCertificate.cc	2017-05-14 17:55:12 +0000
@@ -2,44 +2,36 @@
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 
 #if USE_OPENSSL
 
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
 #include "acl/ServerCertificate.h"
 #include "client_side.h"
 #include "fde.h"
 #include "http/Stream.h"
 #include "ssl/ServerBump.h"
 
 int
-ACLServerCertificateStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLServerCertificateStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     Security::CertPointer cert;
     if (checklist->serverCert)
         cert = checklist->serverCert;
     else if (checklist->conn() != NULL && checklist->conn()->serverBump())
         cert = checklist->conn()->serverBump()->serverCert;
 
     if (!cert)
         return 0;
 
     return data->match(cert.get());
 }
 
-ACLServerCertificateStrategy *
-ACLServerCertificateStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLServerCertificateStrategy ACLServerCertificateStrategy::Instance_;
-
 #endif /* USE_OPENSSL */
 

=== modified file 'src/acl/ServerCertificate.h'
--- src/acl/ServerCertificate.h	2017-01-01 00:12:22 +0000
+++ src/acl/ServerCertificate.h	2017-05-23 14:36:19 +0000
@@ -2,44 +2,25 @@
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSERVERCERTIFICATE_H
 #define SQUID_ACLSERVERCERTIFICATE_H
 
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 #include "ssl/support.h"
 
 /// \ingroup ACLAPI
 class ACLServerCertificateStrategy : public ACLStrategy<X509 *>
 {
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLServerCertificateStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLServerCertificateStrategy(ACLServerCertificateStrategy const &);
-
-private:
-    static ACLServerCertificateStrategy Instance_;
-    ACLServerCertificateStrategy() {}
-
-    ACLServerCertificateStrategy&operator=(ACLServerCertificateStrategy const &);
-};
-
-/// \ingroup ACLAPI
-class ACLServerCertificate
-{
-private:
-    static ACL::Prototype X509FingerprintRegistryProtoype;
-    static ACLStrategised<X509*> X509FingerprintRegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLSERVERCERTIFICATE_H */
 

=== modified file 'src/acl/ServerName.cc'
--- src/acl/ServerName.cc	2017-01-01 00:12:22 +0000
+++ src/acl/ServerName.cc	2017-05-14 18:07:55 +0000
@@ -1,33 +1,33 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
-#include "acl/Checklist.h"
 #include "acl/DomainData.h"
+#include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/ServerName.h"
 #include "client_side.h"
 #include "fde.h"
 #include "http/Stream.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "SquidString.h"
 #include "ssl/bio.h"
 #include "ssl/ServerBump.h"
 #include "ssl/support.h"
 #include "URL.h"
 
 // Compare function for tree search algorithms
 static int
 aclHostDomainCompare( char *const &a, char * const &b)
 {
     const char *h = static_cast<const char *>(a);
     const char *d = static_cast<const char *>(b);
     debugs(28, 7, "Match:" << h << " <>  " << d);
@@ -70,57 +70,49 @@
     ACLData<MatchType> * data = (ACLData<MatchType> *)check_data;
 
     if (cn_data->length > (int)sizeof(cn) - 1)
         return 1; // ignore data that does not fit our buffer
 
     char *s = reinterpret_cast<char *>(cn_data->data);
     char *d = cn;
     for (int i = 0; i < cn_data->length; ++i, ++d, ++s) {
         if (*s == '\0')
             return 1; // always a domain mismatch. contains 0x00
         *d = *s;
     }
     cn[cn_data->length] = '\0';
     debugs(28, 4, "Verifying certificate name/subjectAltName " << cn);
     if (data->match(cn))
         return 0;
     return 1;
 }
 
 int
-ACLServerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
+ACLServerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     assert(checklist != NULL && checklist->request != NULL);
 
     const char *serverName = nullptr;
     SBuf serverNameKeeper; // because c_str() is not constant
     if (ConnStateData *conn = checklist->conn()) {
 
         if (conn->serverBump()) {
             if (X509 *peer_cert = conn->serverBump()->serverCert.get())
                 return Ssl::matchX509CommonNames(peer_cert, (void *)data, check_cert_domain<MatchType>);
         }
 
         if (conn->sslCommonName().isEmpty()) {
             const char *host = checklist->request->url.host();
             if (host && *host) // paranoid first condition: host() is never nil
                 serverName = host;
         } else {
             serverNameKeeper = conn->sslCommonName();
             serverName = serverNameKeeper.c_str();
         }
     }
 
     if (!serverName)
         serverName = "none";
 
     return data->match(serverName);
 }
 
-ACLServerNameStrategy *
-ACLServerNameStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLServerNameStrategy ACLServerNameStrategy::Instance_;
-

=== modified file 'src/acl/ServerName.h'
--- src/acl/ServerName.h	2017-01-01 00:12:22 +0000
+++ src/acl/ServerName.h	2017-05-14 17:58:41 +0000
@@ -1,60 +1,35 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSERVERNAME_H
 #define SQUID_ACLSERVERNAME_H
 
 #include "acl/Acl.h"
-#include "acl/Checklist.h"
-#include "acl/Data.h"
 #include "acl/DomainData.h"
-#include "acl/Strategised.h"
+#include "acl/Strategy.h"
 
 class ACLServerNameData : public ACLDomainData {
     MEMPROXY_CLASS(ACLServerNameData);
 public:
     ACLServerNameData() : ACLDomainData() {}
     virtual bool match(const char *);
     virtual ACLData<char const *> *clone() const;
 };
 
 class ACLServerNameStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLServerNameStrategy *Instance();
+    /* ACLStrategy API */
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
-    /**
-     * Not implemented to prevent copies of the instance.
-     \par
-     * Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends
-     */
-    ACLServerNameStrategy(ACLServerNameStrategy const &);
-
-private:
-    static ACLServerNameStrategy Instance_;
-    ACLServerNameStrategy() {}
-
-    ACLServerNameStrategy&operator=(ACLServerNameStrategy const &);
-};
-
-class ACLServerName
-{
-
-private:
-    static ACL::Prototype LiteralRegistryProtoype;
-    static ACLStrategised<char const *> LiteralRegistryEntry_;
-    static ACL::Prototype RegexRegistryProtoype;
-    static ACLStrategised<char const *> RegexRegistryEntry_;
 };
 
 #endif /* SQUID_ACLSERVERNAME_H */
 

=== modified file 'src/acl/SourceAsn.h'
--- src/acl/SourceAsn.h	2017-01-01 00:12:22 +0000
+++ src/acl/SourceAsn.h	2017-05-23 14:36:34 +0000
@@ -1,36 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACL_SOURCEASN_H
 #define SQUID_ACL_SOURCEASN_H
 
 #include "acl/Strategy.h"
 #include "ip/Address.h"
 
 class ACLChecklist;
 
 class ACLSourceASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLSourceASNStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLSourceASNStrategy(ACLSourceASNStrategy const &);
-
-private:
-    static ACLSourceASNStrategy Instance_;
-    ACLSourceASNStrategy() {}
-
-    ACLSourceASNStrategy&operator=(ACLSourceASNStrategy const &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACL_SOURCEASN_H */
 

=== modified file 'src/acl/SourceDomain.cc'
--- src/acl/SourceDomain.cc	2017-01-01 00:12:22 +0000
+++ src/acl/SourceDomain.cc	2017-05-14 17:55:12 +0000
@@ -1,68 +1,61 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/DomainData.h"
+#include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/SourceDomain.h"
 #include "fqdncache.h"
 #include "HttpRequest.h"
 
 SourceDomainLookup SourceDomainLookup::instance_;
 
 SourceDomainLookup *
 SourceDomainLookup::Instance()
 {
     return &instance_;
 }
 
 void
 SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 {
     fqdncache_nbgethostbyaddr(Filled(checklist)->src_addr, LookupDone, checklist);
 }
 
 void
 SourceDomainLookup::LookupDone(const char *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markSourceDomainChecked();
     checklist->request->recordLookup(details);
     checklist->resumeNonBlockingCheck(SourceDomainLookup::Instance());
 }
 
 int
-ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     const char *fqdn = NULL;
     fqdn = fqdncache_gethostbyaddr(checklist->src_addr, FQDN_LOOKUP_IF_MISS);
 
     if (fqdn) {
         return data->match(fqdn);
     } else if (!checklist->sourceDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->src_addr << "'");
         if (checklist->goAsync(SourceDomainLookup::Instance()))
             return -1;
         // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
 }
 
-ACLSourceDomainStrategy *
-ACLSourceDomainStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLSourceDomainStrategy ACLSourceDomainStrategy::Instance_;
-

=== modified file 'src/acl/SourceDomain.h'
--- src/acl/SourceDomain.h	2017-01-01 00:12:22 +0000
+++ src/acl/SourceDomain.h	2017-05-23 14:36:47 +0000
@@ -1,58 +1,37 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSOURCEDOMAIN_H
 #define SQUID_ACLSOURCEDOMAIN_H
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "acl/Data.h"
-#include "acl/Strategised.h"
+#include "acl/Strategy.h"
 #include "dns/forward.h"
 
 class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLSourceDomainStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLSourceDomainStrategy(ACLSourceDomainStrategy const &);
-
-private:
-    static ACLSourceDomainStrategy Instance_;
-    ACLSourceDomainStrategy() {}
-
-    ACLSourceDomainStrategy&operator=(ACLSourceDomainStrategy const &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 class SourceDomainLookup : public ACLChecklist::AsyncState
 {
 
 public:
     static SourceDomainLookup *Instance();
     virtual void checkForAsync(ACLChecklist *)const;
 
 private:
     static SourceDomainLookup instance_;
     static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };
 
-class ACLSourceDomain
-{
-
-private:
-    static ACL::Prototype LiteralRegistryProtoype;
-    static ACLStrategised<char const *> LiteralRegistryEntry_;
-    static ACL::Prototype RegexRegistryProtoype;
-    static ACLStrategised<char const *> RegexRegistryEntry_;
-};
-
 #endif /* SQUID_ACLSOURCEDOMAIN_H */
 

=== modified file 'src/acl/SourceIp.h'
--- src/acl/SourceIp.h	2017-01-01 00:12:22 +0000
+++ src/acl/SourceIp.h	2017-05-14 17:55:12 +0000
@@ -2,28 +2,24 @@
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSOURCEIP_H
 #define SQUID_ACLSOURCEIP_H
 
 #include "acl/Ip.h"
 
 class ACLSourceIP : public ACLIP
 {
     MEMPROXY_CLASS(ACLSourceIP);
 
 public:
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
-
-private:
-    static Prototype RegistryProtoype;
-    static ACLSourceIP RegistryEntry_;
 };
 
 #endif /* SQUID_ACLSOURCEIP_H */
 

=== modified file 'src/acl/SquidError.cc'
--- src/acl/SquidError.cc	2017-01-01 00:12:22 +0000
+++ src/acl/SquidError.cc	2017-05-14 17:55:12 +0000
@@ -1,31 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/SquidError.h"
 #include "HttpRequest.h"
 
 int
-ACLSquidErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLSquidErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->requestErrorType != ERR_MAX)
         return data->match(checklist->requestErrorType);
     else if (checklist->request)
         return data->match(checklist->request->errType);
     return 0;
 }
 
-ACLSquidErrorStrategy *
-ACLSquidErrorStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLSquidErrorStrategy ACLSquidErrorStrategy::Instance_;
-

=== modified file 'src/acl/SquidError.h'
--- src/acl/SquidError.h	2017-01-01 00:12:22 +0000
+++ src/acl/SquidError.h	2017-05-23 14:37:10 +0000
@@ -1,44 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSQUIDERROR_H
 #define SQUID_ACLSQUIDERROR_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "err_type.h"
 
 class ACLSquidErrorStrategy : public ACLStrategy<err_type>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-
-    static ACLSquidErrorStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLSquidErrorStrategy(ACLSquidErrorStrategy const &);
-
-private:
-    static ACLSquidErrorStrategy Instance_;
-    ACLSquidErrorStrategy() {}
-
-    ACLSquidErrorStrategy&operator=(ACLSquidErrorStrategy const &);
-};
-
-class ACLSquidError
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<err_type> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLSQUIDERROR_H */
 

=== modified file 'src/acl/SslError.cc'
--- src/acl/SslError.cc	2017-01-01 00:12:22 +0000
+++ src/acl/SslError.cc	2017-05-14 17:55:12 +0000
@@ -1,27 +1,19 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/SslError.h"
 #include "acl/SslErrorData.h"
 
 int
-ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->sslErrors);
 }
 
-ACLSslErrorStrategy *
-ACLSslErrorStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLSslErrorStrategy ACLSslErrorStrategy::Instance_;
-

=== modified file 'src/acl/SslError.h'
--- src/acl/SslError.h	2017-01-01 00:12:22 +0000
+++ src/acl/SslError.h	2017-05-23 14:37:23 +0000
@@ -1,42 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSSL_ERROR_H
 #define SQUID_ACLSSL_ERROR_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
+#include "security/forward.h"
 
 class ACLSslErrorStrategy : public ACLStrategy<const Security::CertErrors *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLSslErrorStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLSslErrorStrategy(ACLSslErrorStrategy const &);
-
-private:
-    static ACLSslErrorStrategy Instance_;
-    ACLSslErrorStrategy() {}
-
-    ACLSslErrorStrategy&operator=(ACLSslErrorStrategy const &);
-};
-
-class ACLSslError
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const Security::CertErrors *> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLSSL_ERROR_H */
 

=== modified file 'src/acl/Strategised.h'
--- src/acl/Strategised.h	2017-01-01 00:12:22 +0000
+++ src/acl/Strategised.h	2017-05-14 17:55:12 +0000
@@ -1,135 +1,132 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSTRATEGISED_H
 #define SQUID_ACLSTRATEGISED_H
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Strategy.h"
 
+// XXX: Replace with a much simpler abstract ACL child class without the
+// ACLStrategy parameter (and associated call forwarding). Duplicating key
+// portions of the ACL class API in ACLStrategy is not needed because
+// ACLStrategy is unused outside the ACLStrategised context. Existing classes
+// like ACLExtUser, ACLProxyAuth, and ACLIdent seem to confirm this assertion.
+// It also requires forwarding ACL info to ACLStrategy as method parameters.
+
+/// Splits the ACL API into two individually configurable components:
+/// * ACLStrategy that usually extracts information from the current transaction
+/// * ACLData that usually matches information against admin-configured values
 template <class M>
 class ACLStrategised : public ACL
 {
     MEMPROXY_CLASS(ACLStrategised);
 
 public:
     typedef M MatchType;
 
     ~ACLStrategised();
-    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *, const ACLFlag flags[] = ACLFlags::NoFlags);
-    ACLStrategised (ACLStrategised const &);
-    ACLStrategised &operator= (ACLStrategised const &);
+    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *);
+    ACLStrategised(ACLStrategised const &&) = delete;
 
     virtual char const *typeString() const;
+    virtual void parseFlags();
+
     virtual bool requiresRequest() const {return matcher->requiresRequest();}
 
     virtual bool requiresReply() const {return matcher->requiresReply();}
 
     virtual void prepareForUse() { data->prepareForUse();}
-
+    virtual const Acl::Options &options() { return matcher->options(); }
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual int match (M const &);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool valid () const;
-    virtual ACL *clone()const;
 
 private:
     ACLData<MatchType> *data;
     char const *type_;
     ACLStrategy<MatchType> *matcher;
 };
 
 /* implementation follows */
 
 template <class MatchType>
 ACLStrategised<MatchType>::~ACLStrategised()
 {
     delete data;
 }
 
 template <class MatchType>
-ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType, const ACLFlag flgs[]) : ACL(flgs), data (newData), type_(theType), matcher(theStrategy) {}
-
-template <class MatchType>
-ACLStrategised<MatchType>::ACLStrategised (ACLStrategised const &old) : data (old.data->clone()), type_(old.type_), matcher (old.matcher)
+ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType): data(newData), type_(theType), matcher(theStrategy)
 {}
 
 template <class MatchType>
-ACLStrategised<MatchType> &
-ACLStrategised<MatchType>::operator= (ACLStrategised const &rhs)
+char const *
+ACLStrategised<MatchType>::typeString() const
 {
-    data = rhs.data->clone();
-    type_ = rhs.type_;
-    matcher = rhs.matcher;
-    return *this;
+    return type_;
 }
 
 template <class MatchType>
-char const *
-ACLStrategised<MatchType>::typeString() const
+void
+ACLStrategised<MatchType>::parseFlags()
 {
-    return type_;
+    ParseFlags(options(), data->supportedFlags());
 }
 
 template <class MatchType>
 void
 ACLStrategised<MatchType>::parse()
 {
     data->parse();
 }
 
 template <class MatchType>
 bool
 ACLStrategised<MatchType>::empty() const
 {
     return data->empty();
 }
 
 template <class MatchType>
 int
 ACLStrategised<MatchType>::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = dynamic_cast<ACLFilledChecklist*>(cl);
     assert(checklist);
-    return matcher->match(data, checklist, flags);
+    return matcher->match(data, checklist);
 }
 
 template <class MatchType>
 int
 ACLStrategised<MatchType>::match(MatchType const &toFind)
 {
     return data->match(toFind);
 }
 
 template <class MatchType>
 SBufList
 ACLStrategised<MatchType>::dump() const
 {
     return data->dump();
 }
 
 template <class MatchType>
 bool
 ACLStrategised<MatchType>::valid () const
 {
     return matcher->valid();
 }
 
-template <class MatchType>
-ACL *
-ACLStrategised<MatchType>::clone() const
-{
-    return new ACLStrategised(*this);
-}
-
 #endif /* SQUID_ACLSTRATEGISED_H */
 

=== modified file 'src/acl/Strategy.h'
--- src/acl/Strategy.h	2017-01-01 00:12:22 +0000
+++ src/acl/Strategy.h	2017-05-14 17:55:12 +0000
@@ -1,35 +1,40 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLSTRATEGY_H
 #define SQUID_ACLSTRATEGY_H
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
+#include "acl/Options.h"
 
 class ACLFilledChecklist;
 
 template<class M>
 
+/// A matching algorithm.
 class ACLStrategy
 {
 
 public:
     typedef M MatchType;
-    virtual int match (ACLData<M> * &, ACLFilledChecklist *, ACLFlags &) = 0;
+
+    /* Replicate ACL API parts relevant to the matching algorithm. */
+    virtual const Acl::Options &options() { return Acl::NoOptions(); }
+    virtual int match (ACLData<M> * &, ACLFilledChecklist *) = 0;
     virtual bool requiresRequest() const {return false;}
 
     virtual bool requiresReply() const {return false;}
 
     virtual bool valid() const {return true;}
 
     virtual ~ACLStrategy() {}
 };
 
 #endif /* SQUID_ACLSTRATEGY_H */
 

=== modified file 'src/acl/Tag.cc'
--- src/acl/Tag.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Tag.cc	2017-05-14 17:55:12 +0000
@@ -1,30 +1,22 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/StringData.h"
 #include "acl/Tag.h"
 #include "HttpRequest.h"
 
 int
-ACLTagStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLTagStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->request != NULL)
         return data->match (checklist->request->tag.termedBuf());
     return 0;
 }
 
-ACLTagStrategy *
-ACLTagStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLTagStrategy ACLTagStrategy::Instance_;
-

=== modified file 'src/acl/Tag.h'
--- src/acl/Tag.h	2017-01-01 00:12:22 +0000
+++ src/acl/Tag.h	2017-05-23 14:37:35 +0000
@@ -1,42 +1,22 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLTAG_H
 #define SQUID_ACLTAG_H
 
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 
 class ACLTagStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLTagStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLTagStrategy(ACLTagStrategy const &);
-
-private:
-    static ACLTagStrategy Instance_;
-    ACLTagStrategy() {}
-
-    ACLTagStrategy&operator=(ACLTagStrategy const &);
-};
-
-class ACLTag
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const char *> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLMYPORTNAME_H */
 

=== modified file 'src/acl/Time.cc'
--- src/acl/Time.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Time.cc	2017-05-14 17:55:12 +0000
@@ -1,29 +1,21 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/Time.h"
 #include "acl/TimeData.h"
 #include "SquidTime.h"
 
 int
-ACLTimeStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *, ACLFlags &)
+ACLTimeStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *)
 {
     return data->match(squid_curtime);
 }
 
-ACLTimeStrategy *
-ACLTimeStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLTimeStrategy ACLTimeStrategy::Instance_;
-

=== modified file 'src/acl/Time.h'
--- src/acl/Time.h	2017-01-01 00:12:22 +0000
+++ src/acl/Time.h	2017-05-23 14:37:47 +0000
@@ -1,44 +1,22 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLTIME_H
 #define SQUID_ACLTIME_H
-#include "acl/Acl.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 
-class ACLChecklist; // XXX: we do not need it
-
 class ACLTimeStrategy : public ACLStrategy<time_t>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLTimeStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLTimeStrategy(ACLTimeStrategy const &);
-
-private:
-    static ACLTimeStrategy Instance_;
-    ACLTimeStrategy() {}
-
-    ACLTimeStrategy&operator=(ACLTimeStrategy const &);
-};
-
-class ACLTime
-{
-
-public:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<time_t> RegistryEntry_;
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *) override;
 };
 
 #endif /* SQUID_ACLTIME_H */
 

=== modified file 'src/acl/Url.cc'
--- src/acl/Url.cc	2017-01-01 00:12:22 +0000
+++ src/acl/Url.cc	2017-05-14 17:55:12 +0000
@@ -1,36 +1,28 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/Url.h"
 #include "HttpRequest.h"
 #include "rfc1738.h"
 #include "src/URL.h"
 
 int
-ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char *esc_buf = SBufToCstring(checklist->request->effectiveRequestUri());
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
     xfree(esc_buf);
     return result;
 }
 
-ACLUrlStrategy *
-ACLUrlStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLUrlStrategy ACLUrlStrategy::Instance_;
-

=== modified file 'src/acl/Url.h'
--- src/acl/Url.h	2017-01-01 00:12:22 +0000
+++ src/acl/Url.h	2017-05-14 17:55:12 +0000
@@ -1,45 +1,24 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLURL_H
 #define SQUID_ACLURL_H
-#include "acl/Acl.h"
+
 #include "acl/Data.h"
 #include "acl/Strategised.h"
 
 class ACLUrlStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLUrlStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLUrlStrategy(ACLUrlStrategy const &);
-
-private:
-    static ACLUrlStrategy Instance_;
-    ACLUrlStrategy() {}
-
-    ACLUrlStrategy&operator=(ACLUrlStrategy const &);
-};
-
-class ACLUrl
-{
-
-public:
-    static ACL::Prototype RegistryProtoype;
-    static ACL::Prototype LegacyRegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLURL_H */
 

=== modified file 'src/acl/UrlLogin.cc'
--- src/acl/UrlLogin.cc	2017-01-01 00:12:22 +0000
+++ src/acl/UrlLogin.cc	2017-05-14 17:55:12 +0000
@@ -1,41 +1,33 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/UrlLogin.h"
 #include "HttpRequest.h"
 #include "rfc1738.h"
 
 int
-ACLUrlLoginStrategy::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLUrlLoginStrategy::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->request->url.userInfo().isEmpty()) {
         debugs(28, 5, "URL has no user-info details. cannot match");
         return 0; // nothing can match
     }
 
     static char str[MAX_URL]; // should be big enough for a single URI segment
 
     const SBuf::size_type len = checklist->request->url.userInfo().copy(str, sizeof(str)-1);
     str[len] = '\0';
     rfc1738_unescape(str);
     return data->match(str);
 }
 
-ACLUrlLoginStrategy *
-ACLUrlLoginStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLUrlLoginStrategy ACLUrlLoginStrategy::Instance_;
-

=== modified file 'src/acl/UrlLogin.h'
--- src/acl/UrlLogin.h	2017-01-01 00:12:22 +0000
+++ src/acl/UrlLogin.h	2017-05-14 17:55:12 +0000
@@ -1,47 +1,25 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLURLLOGIN_H
 #define SQUID_ACLURLLOGIN_H
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "acl/Strategised.h"
 #include "acl/Strategy.h"
 
 class ACLUrlLoginStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLUrlLoginStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLUrlLoginStrategy(ACLUrlLoginStrategy const &);
-
-private:
-    static ACLUrlLoginStrategy Instance_;
-    ACLUrlLoginStrategy() {}
-
-    ACLUrlLoginStrategy&operator=(ACLUrlLoginStrategy const &);
-};
-
-class ACLUrlLogin
-{
-
-public:
-    static ACL::Prototype RegistryProtoype;
-    static ACL::Prototype LegacyRegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLURLLOGIN_H */
 

=== modified file 'src/acl/UrlPath.cc'
--- src/acl/UrlPath.cc	2017-01-01 00:12:22 +0000
+++ src/acl/UrlPath.cc	2017-05-14 17:55:12 +0000
@@ -1,38 +1,30 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
-#include "acl/Checklist.h"
+#include "acl/FilledChecklist.h"
 #include "acl/RegexData.h"
 #include "acl/UrlPath.h"
 #include "HttpRequest.h"
 #include "rfc1738.h"
 
 int
-ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->request->url.path().isEmpty())
         return -1;
 
     char *esc_buf = SBufToCstring(checklist->request->url.path());
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
     xfree(esc_buf);
     return result;
 }
 
-ACLUrlPathStrategy *
-ACLUrlPathStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLUrlPathStrategy ACLUrlPathStrategy::Instance_;
-

=== modified file 'src/acl/UrlPath.h'
--- src/acl/UrlPath.h	2017-01-01 00:12:22 +0000
+++ src/acl/UrlPath.h	2017-05-14 17:55:12 +0000
@@ -1,46 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLURLPATH_H
 #define SQUID_ACLURLPATH_H
-#include "acl/Acl.h"
-#include "acl/Data.h"
-#include "acl/Strategised.h"
+
 #include "acl/Strategy.h"
 
 class ACLUrlPathStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLUrlPathStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLUrlPathStrategy(ACLUrlPathStrategy const &);
-
-private:
-    static ACLUrlPathStrategy Instance_;
-    ACLUrlPathStrategy() {}
-
-    ACLUrlPathStrategy&operator=(ACLUrlPathStrategy const &);
-};
-
-class ACLUrlPath
-{
-
-public:
-    static ACL::Prototype RegistryProtoype;
-    static ACL::Prototype LegacyRegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLURLPATH_H */
 

=== modified file 'src/acl/UrlPort.cc'
--- src/acl/UrlPort.cc	2017-01-01 00:12:22 +0000
+++ src/acl/UrlPort.cc	2017-05-14 17:55:12 +0000
@@ -1,28 +1,19 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
-#include "acl/Checklist.h"
-#include "acl/IntRange.h"
+#include "acl/FilledChecklist.h"
 #include "acl/UrlPort.h"
 #include "HttpRequest.h"
 
 int
-ACLUrlPortStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLUrlPortStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match(checklist->request->url.port());
 }
 
-ACLUrlPortStrategy *
-ACLUrlPortStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLUrlPortStrategy ACLUrlPortStrategy::Instance_;
-

=== modified file 'src/acl/UrlPort.h'
--- src/acl/UrlPort.h	2017-01-01 00:12:22 +0000
+++ src/acl/UrlPort.h	2017-05-14 17:55:12 +0000
@@ -1,43 +1,23 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLURLPORT_H
 #define SQUID_ACLURLPORT_H
-#include "acl/Strategised.h"
+
 #include "acl/Strategy.h"
 
 class ACLUrlPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
-
-    static ACLUrlPortStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
-     * private constructors with no friends */
-    ACLUrlPortStrategy(ACLUrlPortStrategy const &);
-
-private:
-    static ACLUrlPortStrategy Instance_;
-    ACLUrlPortStrategy() {}
-
-    ACLUrlPortStrategy&operator=(ACLUrlPortStrategy const &);
-};
-
-class ACLUrlPort
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<int> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLURLPORT_H */
 

=== modified file 'src/auth/AclMaxUserIp.cc'
--- src/auth/AclMaxUserIp.cc	2017-01-01 00:12:22 +0000
+++ src/auth/AclMaxUserIp.cc	2017-05-14 17:55:12 +0000
@@ -1,82 +1,78 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "auth/Acl.h"
 #include "auth/AclMaxUserIp.h"
 #include "auth/UserRequest.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "Parsing.h"
 #include "wordlist.h"
 
-ACLFlag ACLMaxUserIP::SupportedFlags[] = {ACL_F_STRICT, ACL_F_END};
-
 ACLMaxUserIP::ACLMaxUserIP(char const *theClass) :
-    ACL(SupportedFlags),
     class_(theClass),
     maximum(0)
 {}
 
-ACLMaxUserIP::ACLMaxUserIP(ACLMaxUserIP const &old) :
-    class_(old.class_),
-    maximum(old.maximum)
-{
-    flags = old.flags;
-}
-
-ACLMaxUserIP::~ACLMaxUserIP()
-{}
-
 ACL *
 ACLMaxUserIP::clone() const
 {
     return new ACLMaxUserIP(*this);
 }
 
 char const *
 ACLMaxUserIP::typeString() const
 {
     return class_;
 }
 
 bool
 ACLMaxUserIP::empty() const
 {
     return false;
 }
 
 bool
 ACLMaxUserIP::valid() const
 {
     return maximum > 0;
 }
 
+const Acl::Options &
+ACLMaxUserIP::options()
+{
+    static const Acl::BooleanOption BeStrict;
+    static const Acl::Options MyOptions = { { "-s", &BeStrict } };
+    BeStrict.linkWith(&beStrict);
+    return MyOptions;
+}
+
 void
 ACLMaxUserIP::parse()
 {
     if (maximum) {
         debugs(28, DBG_IMPORTANT, "Attempting to alter already set User max IP acl");
         return;
     }
 
     char *t = ConfigParser::strtokFile();
 
     if (!t)
         return;
 
     debugs(28, 5, "aclParseUserMaxIP: First token is " << t);
 
     maximum = xatoi(t);
 
     debugs(28, 5, "aclParseUserMaxIP: Max IP address's " << maximum);
 
     return;
@@ -85,41 +81,41 @@
 /*
  * aclMatchUserMaxIP - check for users logging in from multiple IP's
  * 0 : No match
  * 1 : Match
  */
 int
 ACLMaxUserIP::match(Auth::UserRequest::Pointer auth_user_request, Ip::Address const &src_addr)
 {
     /*
      * the logic for flush the ip list when the limit is hit vs keep
      * it sorted in most recent access order and just drop the oldest
      * one off is currently undecided (RBC)
      */
 
     if (authenticateAuthUserRequestIPCount(auth_user_request) <= maximum)
         return 0;
 
     debugs(28, DBG_IMPORTANT, "aclMatchUserMaxIP: user '" << auth_user_request->username() << "' tries to use too many IP addresses (max " << maximum << " allowed)!");
 
     /* this is a match */
-    if (flags.isSet(ACL_F_STRICT)) {
+    if (beStrict) {
         /*
          * simply deny access - the user name is already associated with
          * the request
          */
         /* remove _this_ ip, as it is the culprit for going over the limit */
         authenticateAuthUserRequestRemoveIp(auth_user_request, src_addr);
         debugs(28, 4, "aclMatchUserMaxIP: Denying access in strict mode");
     } else {
         /*
          * non-strict - remove some/all of the cached entries
          * ie to allow the user to move machines easily
          */
         authenticateAuthUserRequestClearIp(auth_user_request);
         debugs(28, 4, "aclMatchUserMaxIP: Denying access in non-strict mode - flushing the user ip cache");
     }
 
     return 1;
 }
 
 int

=== modified file 'src/auth/AclMaxUserIp.h'
--- src/auth/AclMaxUserIp.h	2017-01-01 00:12:22 +0000
+++ src/auth/AclMaxUserIp.h	2017-05-23 10:31:03 +0000
@@ -1,53 +1,49 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_ACLMAXUSERIP_H
 #define SQUID_ACLMAXUSERIP_H
 
 #if USE_AUTH
 
 #include "acl/Acl.h"
-#include "acl/Checklist.h"
 #include "auth/UserRequest.h"
 
 class ACLMaxUserIP : public ACL
 {
     MEMPROXY_CLASS(ACLMaxUserIP);
 
 public:
-    ACLMaxUserIP(char const *theClass);
-    ACLMaxUserIP(ACLMaxUserIP const &old);
-    ~ACLMaxUserIP();
-    ACLMaxUserIP &operator =(ACLMaxUserIP const &);
+    explicit ACLMaxUserIP(char const *theClass);
 
     virtual ACL *clone() const;
     virtual char const *typeString() const;
+    virtual const Acl::Options &options();
     virtual void parse();
     virtual int match(ACLChecklist *cl);
     virtual SBufList dump() const;
     virtual bool empty() const;
     virtual bool valid() const;
     virtual bool requiresRequest() const {return true;}
 
     int getMaximum() const {return maximum;}
 
-    bool getStrict() const {return flags.isSet(ACL_F_STRICT);}
-
 private:
-    static Prototype RegistryProtoype;
-    static ACLMaxUserIP RegistryEntry_;
-    static ACLFlag SupportedFlags[];
-
     int match(Auth::UserRequest::Pointer auth_user_request, Ip::Address const &src_addr);
+
+public:
+    Acl::BooleanOptionValue beStrict; ///< Enforce "one user, one device" policy?
+
+private:
     char const *class_;
     int maximum;
 };
 
 #endif /* USE_AUTH */
 #endif /* SQUID_ACLMAXUSERIP_H */
 

=== modified file 'src/auth/AclProxyAuth.cc'
--- src/auth/AclProxyAuth.cc	2017-01-01 00:12:22 +0000
+++ src/auth/AclProxyAuth.cc	2017-05-14 17:55:12 +0000
@@ -34,40 +34,46 @@
 ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) :
     data(old.data->clone()),
     type_(old.type_)
 {}
 
 ACLProxyAuth &
 ACLProxyAuth::operator=(ACLProxyAuth const &rhs)
 {
     data = rhs.data->clone();
     type_ = rhs.type_;
     return *this;
 }
 
 char const *
 ACLProxyAuth::typeString() const
 {
     return type_;
 }
 
 void
+ACLProxyAuth::parseFlags()
+{
+    ParseFlags(Acl::NoOptions(), data->supportedFlags());
+}
+
+void
 ACLProxyAuth::parse()
 {
     data->parse();
 }
 
 int
 ACLProxyAuth::match(ACLChecklist *checklist)
 {
     allow_t answer = AuthenticateAcl(checklist);
 
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:
         // check for a match
         return matchProxyAuth(checklist);
 
     case ACCESS_DENIED:
         return 0; // non-match
 
     case ACCESS_DUNNO:

=== modified file 'src/auth/AclProxyAuth.h'
--- src/auth/AclProxyAuth.h	2017-01-01 00:12:22 +0000
+++ src/auth/AclProxyAuth.h	2017-05-14 17:55:12 +0000
@@ -20,46 +20,42 @@
 
 public:
     static ProxyAuthLookup *Instance();
     virtual void checkForAsync(ACLChecklist *) const;
 
 private:
     static ProxyAuthLookup instance_;
     static void LookupDone(void *data);
 };
 
 class ACLProxyAuth : public ACL
 {
     MEMPROXY_CLASS(ACLProxyAuth);
 
 public:
     ~ACLProxyAuth();
     ACLProxyAuth(ACLData<char const *> *, char const *);
     ACLProxyAuth(ACLProxyAuth const &);
     ACLProxyAuth &operator =(ACLProxyAuth const &);
 
+    /* ACL API */
     virtual char const *typeString() const;
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
-
+    virtual void parseFlags();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool valid() const;
     virtual bool empty() const;
     virtual bool requiresRequest() const {return true;}
-
     virtual ACL *clone() const;
     virtual int matchForCache(ACLChecklist *checklist);
 
 private:
-    static Prototype UserRegistryProtoype;
-    static ACLProxyAuth UserRegistryEntry_;
-    static Prototype RegexRegistryProtoype;
-    static ACLProxyAuth RegexRegistryEntry_;
     int matchProxyAuth(ACLChecklist *);
     ACLData<char const *> *data;
     char const *type_;
 };
 
 #endif /* USE_AUTH */
 #endif /* SQUID_ACLPROXYAUTH_H */
 

=== modified file 'src/base/CharacterSet.cc'
--- src/base/CharacterSet.cc	2017-01-01 00:12:22 +0000
+++ src/base/CharacterSet.cc	2017-05-14 17:55:12 +0000
@@ -80,40 +80,49 @@
     const size_t clen = strlen(c);
     for (size_t i = 0; i < clen; ++i)
         add(c[i]);
 }
 
 CharacterSet::CharacterSet(const char *label, unsigned char low, unsigned char high) :
     name(label ? label: "anonymous"),
     chars_(Storage(256,0))
 {
     addRange(low,high);
 }
 
 CharacterSet::CharacterSet(const char *label, std::initializer_list<std::pair<uint8_t, uint8_t>> ranges) :
     name(label ? label: "anonymous"),
     chars_(Storage(256,0))
 {
     for (auto range: ranges)
         addRange(range.first, range.second);
 }
 
+void
+CharacterSet::printChars(std::ostream &os) const
+{
+    for (size_t idx = 0; idx < 256; ++idx) {
+        if (chars_[idx])
+            os << static_cast<char>(idx);
+    }
+}
+
 CharacterSet
 operator+ (CharacterSet lhs, const CharacterSet &rhs)
 {
     lhs += rhs;
     return lhs;
 }
 
 CharacterSet
 operator- (CharacterSet lhs, const CharacterSet &rhs)
 {
     lhs -= rhs;
     return lhs;
 }
 
 std::ostream&
 operator <<(std::ostream &s, const CharacterSet &c)
 {
     s << "CharacterSet(" << c.name << ')';
     return s;
 }

=== modified file 'src/base/CharacterSet.h'
--- src/base/CharacterSet.h	2017-01-01 00:12:22 +0000
+++ src/base/CharacterSet.h	2017-05-14 17:55:12 +0000
@@ -2,81 +2,86 @@
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef _SQUID_SRC_PARSER_CHARACTERSET_H
 #define _SQUID_SRC_PARSER_CHARACTERSET_H
 
 #include <initializer_list>
 #include <iosfwd>
 #include <vector>
 
 /// optimized set of C chars, with quick membership test and merge support
 class CharacterSet
 {
 public:
     typedef std::vector<uint8_t> Storage;
 
-    /// define a character set with the given label ("anonymous" if nullptr)
-    ///  with specified initial contents
-    CharacterSet(const char *label, const char * const initial);
+    /// a character set with a given label and contents
+    explicit CharacterSet(const char *label = "anonymous", const char * const chars = "");
 
     /// define a character set with the given label ("anonymous" if nullptr)
     ///  containing characters defined in the supplied ranges
     /// \see addRange
     CharacterSet(const char *label, unsigned char low, unsigned char high);
 
     /// define a character set with the given label ("anonymous" if nullptr)
     ///  containing characters defined in the supplied list of low-high ranges
     /// \see addRange
     CharacterSet(const char *label, std::initializer_list<std::pair<uint8_t,uint8_t>> ranges);
 
+    /// whether the set lacks any members
+    bool isEmpty() const { return chars_.empty(); }
+
     /// whether a given character exists in the set
     bool operator[](unsigned char c) const {return chars_[static_cast<uint8_t>(c)] != 0;}
 
     /// add a given character to the character set
     CharacterSet & add(const unsigned char c);
 
     /// add a list of character ranges, expressed as pairs [low,high], including both ends
     CharacterSet & addRange(unsigned char low, unsigned char high);
 
     /// set addition: add to this set all characters that are also in rhs
     CharacterSet &operator +=(const CharacterSet &rhs);
 
     /// set subtraction: remove all characters that are also in rhs
     CharacterSet &operator -=(const CharacterSet &rhs);
 
     /// return a new CharacterSet containing characters not in this set
     ///  use the supplied label if provided, default is "complement_of_some_other_set"
     CharacterSet complement(const char *complementLabel = nullptr) const;
 
     /// change name; handy in const declarations that use operators
     CharacterSet &rename(const char *label) { name = label; return *this; }
 
     /// \note Ignores label
     bool operator == (const CharacterSet &cs) const { return chars_ == cs.chars_; }
     /// \note Ignores label
     bool operator != (const CharacterSet &cs) const { return !operator==(cs); }
 
+    /// prints all chars in arbitrary order, without any quoting/escaping
+    void printChars(std::ostream &os) const;
+
     /// optional set label for debugging (default: "anonymous")
     const char * name;
 
     // common character sets, RFC 5234
     // A-Za-z
     static const CharacterSet ALPHA;
     // 0-1
     static const CharacterSet BIT;
     // carriage return
     static const CharacterSet CR;
     // controls
     static const CharacterSet CTL;
     // 0-9
     static const CharacterSet DIGIT;
     // double quote
     static const CharacterSet DQUOTE;
     // 0-9aAbBcCdDeEfF
     static const CharacterSet HEXDIG;
     // horizontal tab
     static const CharacterSet HTAB;

=== modified file 'src/base/TextException.cc'
--- src/base/TextException.cc	2017-01-01 00:12:22 +0000
+++ src/base/TextException.cc	2017-05-14 17:55:12 +0000
@@ -1,50 +1,55 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 #include "base/TextException.h"
 #include "Debug.h"
+#include "sbuf/SBuf.h"
 #include "util.h"
 
 TextException::TextException()
 {
     message=NULL;
     theFileName=NULL;
     theLineNo=0;
     theId=0;
 }
 
 TextException::TextException(const TextException& right) :
     message((right.message?xstrdup(right.message):NULL)), theFileName(right.theFileName), theLineNo(right.theLineNo), theId(right.theId)
 {
 }
 
 TextException::TextException(const char *aMsg, const char *aFileName, int aLineNo, unsigned int anId):
     message(aMsg?xstrdup(aMsg):NULL), theFileName(aFileName), theLineNo(aLineNo), theId(anId)
 {}
 
+TextException::TextException(SBuf msg, const char *aFileName, int aLineNo, unsigned int anId):
+    TextException(msg.c_str(), aFileName, aLineNo, anId)
+{}
+
 TextException::~TextException() throw()
 {
     if (message) xfree(message);
 }
 
 TextException& TextException::operator=(const TextException &right)
 {
     if (this==&right) return *this;
     if (message) xfree(message);
     message=(right.message?xstrdup(right.message):NULL);
     theFileName=right.theFileName;
     theLineNo=right.theLineNo;
     theId=right.theId;
     return *this;
 }
 
 const char *TextException::what() const throw()
 {
     /// \todo add file:lineno
     return message ? message : "TextException without a message";

=== modified file 'src/base/TextException.h'
--- src/base/TextException.h	2017-01-01 00:12:22 +0000
+++ src/base/TextException.h	2017-05-14 17:55:12 +0000
@@ -1,46 +1,49 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID__TEXTEXCEPTION_H
 #define SQUID__TEXTEXCEPTION_H
 
 // Origin: xstd/TextException
 
 #include <exception>
 
+class SBuf;
+
 static unsigned int FileNameHashCached(const char *fname);
 
 // simple exception to report custom errors
 // we may want to change the interface to be able to report system errors
 
 class TextException: public std::exception
 {
 
 public:
     TextException();
     TextException(const char *aMessage, const char *aFileName = 0, int aLineNo = -1, unsigned int anId =0);
+    TextException(SBuf aMessage, const char *aFileName = 0, int aLineNo = -1, unsigned int anId =0);
     TextException(const TextException& right);
     virtual ~TextException() throw();
 
     // unique exception ID for transaction error detail logging
     unsigned int id() const { return theId; }
 
     virtual const char *what() const throw();
 
     TextException& operator=(const TextException &right);
 
 public:
     char *message; // read-only
 
 protected:
     /// a small integer hash value to semi-uniquely identify the source file
     static unsigned int FileNameHash(const char *fname);
 
     // optional location information
     const char *theFileName;
     int theLineNo;

=== modified file 'src/cache_cf.cc'
--- src/cache_cf.cc	2017-02-19 17:13:27 +0000
+++ src/cache_cf.cc	2017-05-14 17:55:12 +0000
@@ -550,82 +550,97 @@
     }
     if (!if_states.empty())
         fatalf("if-statement without 'endif'\n");
 
     if (is_pipe) {
         int ret = pclose(fp);
 
         if (ret != 0)
             fatalf("parseConfigFile: '%s' failed with exit code %d\n", file_name, ret);
     } else {
         fclose(fp);
     }
 
     SetConfigFilename(orig_cfg_filename, false);
     config_lineno = orig_config_lineno;
 
     xfree(tmp_line);
     return err_count;
 }
 
+static
 int
-parseConfigFile(const char *file_name)
+parseConfigFileOrThrow(const char *file_name)
 {
     int err_count = 0;
 
     debugs(5, 4, HERE);
 
     configFreeMemory();
 
     ACLMethodData::ThePurgeCount = 0;
     default_all();
 
     err_count = parseOneConfigFile(file_name, 0);
 
     defaults_if_none();
 
     defaults_postscriptum();
 
     /*
      * We must call configDoConfigure() before leave_suid() because
      * configDoConfigure() is where we turn username strings into
      * uid values.
      */
     configDoConfigure();
 
     if (!Config.chroot_dir) {
         leave_suid();
         setUmask(Config.umask);
         _db_init(Debug::cache_log, Debug::debugOptions);
         enter_suid();
     }
 
     if (opt_send_signal == -1) {
         Mgr::RegisterAction("config",
                             "Current Squid Configuration",
                             dump_config,
                             1, 1);
     }
 
     return err_count;
 }
 
+// TODO: Refactor main.cc to centrally handle (and report) all exceptions.
+int
+parseConfigFile(const char *file_name)
+{
+    try {
+        return parseConfigFileOrThrow(file_name);
+    }
+    catch (const std::exception &ex) {
+        debugs(3, DBG_CRITICAL, "FATAL: bad configuration: " << ex.what());
+        self_destruct();
+        return 1; // not reached
+    }
+}
+
 static void
 configDoConfigure(void)
 {
     Config2.clear();
     /* init memory as early as possible */
     memConfigure();
     /* Sanity checks */
 
     Config.cacheSwap.n_strands = 0; // no diskers by default
     if (Config.cacheSwap.swapDirs == NULL) {
         /* Memory-only cache probably in effect. */
         /* turn off the cache rebuild delays... */
         StoreController::store_dirs_rebuilding = 0;
     } else if (InDaemonMode()) { // no diskers in non-daemon mode
         for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
             const RefCount<SwapDir> sd = Config.cacheSwap.swapDirs[i];
             if (sd->needsDiskStrand())
                 sd->disker = Config.workers + (++Config.cacheSwap.n_strands);
         }
     }
@@ -1325,46 +1340,48 @@
 {
     if (!list.empty()) {
         entry->append(name, strlen(name));
         entry->append(" ", 1);
         dump_SBufList(entry, list);
     }
 }
 
 static void
 free_SBufList(SBufList *list)
 {
     if (list)
         list->clear();
 }
 
 static void
 dump_acl(StoreEntry * entry, const char *name, ACL * ae)
 {
     while (ae != NULL) {
         debugs(3, 3, "dump_acl: " << name << " " << ae->name);
-        storeAppendPrintf(entry, "%s %s %s %s ",
+        storeAppendPrintf(entry, "%s %s %s ",
                           name,
                           ae->name,
-                          ae->typeString(),
-                          ae->flags.flagsStr());
-        dump_SBufList(entry, ae->dump());
+                          ae->typeString());
+        SBufList tail;
+        tail.splice(tail.end(), ae->dumpOptions());
+        tail.splice(tail.end(), ae->dump()); // ACL parameters
+        dump_SBufList(entry, tail);
         ae = ae->next;
     }
 }
 
 static void
 parse_acl(ACL ** ae)
 {
     ACL::ParseAclLine(LegacyParser, ae);
 }
 
 static void
 free_acl(ACL ** ae)
 {
     aclDestroyAcls(ae);
 }
 
 void
 dump_acl_list(StoreEntry * entry, ACLList * head)
 {
     dump_SBufList(entry, head->dump());

=== modified file 'src/external_acl.cc'
--- src/external_acl.cc	2017-01-11 19:06:57 +0000
+++ src/external_acl.cc	2017-05-14 17:55:12 +0000
@@ -1132,51 +1132,40 @@
 ExternalACLLookup::checkForAsync(ACLChecklist *checklist)const
 {
     /* TODO: optimise this - we probably have a pointer to this
      * around somewhere */
     ACL *acl = ACL::FindByName(AclMatchedName);
     assert(acl);
     ACLExternal *me = dynamic_cast<ACLExternal *> (acl);
     assert (me);
     ACLExternal::ExternalAclLookup(checklist, me);
 }
 
 /// Called when an async lookup returns
 void
 ExternalACLLookup::LookupDone(void *data, const ExternalACLEntryPointer &result)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
     checklist->extacl_entry = result;
     checklist->resumeNonBlockingCheck(ExternalACLLookup::Instance());
 }
 
-/* This registers "external" in the registry. To do dynamic definitions
- * of external ACL's, rather than a static prototype, have a Prototype instance
- * prototype in the class that defines each external acl 'class'.
- * Then, then the external acl instance is created, it self registers under
- * it's name.
- * Be sure that clone is fully functional for that acl class though!
- */
-ACL::Prototype ACLExternal::RegistryProtoype(&ACLExternal::RegistryEntry_, "external");
-
-ACLExternal ACLExternal::RegistryEntry_("external");
-
 ACL *
 ACLExternal::clone() const
 {
     return new ACLExternal(*this);
 }
 
 ACLExternal::ACLExternal(char const *theClass) : data(NULL), class_(xstrdup(theClass))
 {}
 
 ACLExternal::ACLExternal(ACLExternal const & old) : data(NULL), class_(old.class_ ? xstrdup(old.class_) : NULL)
 {
     /* we don't have copy constructors for the data yet */
     assert(!old.data);
 }
 
 char const *
 ACLExternal::typeString() const
 {
     return class_;
 }

=== modified file 'src/ident/AclIdent.cc'
--- src/ident/AclIdent.cc	2017-01-01 00:12:22 +0000
+++ src/ident/AclIdent.cc	2017-05-14 17:55:12 +0000
@@ -30,40 +30,46 @@
 ACLIdent::ACLIdent(ACLData<char const *> *newData, char const *newType) : data (newData), type_ (newType) {}
 
 ACLIdent::ACLIdent (ACLIdent const &old) : data (old.data->clone()), type_ (old.type_)
 {}
 
 ACLIdent &
 ACLIdent::operator= (ACLIdent const &rhs)
 {
     data = rhs.data->clone();
     type_ = rhs.type_;
     return *this;
 }
 
 char const *
 ACLIdent::typeString() const
 {
     return type_;
 }
 
 void
+ACLIdent::parseFlags()
+{
+    ParseFlags(Acl::NoOptions(), data->supportedFlags());
+}
+
+void
 ACLIdent::parse()
 {
     if (!data) {
         debugs(28, 3, HERE << "current is null. Creating");
         data = new ACLUserData;
     }
 
     data->parse();
 }
 
 int
 ACLIdent::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->rfc931[0]) {
         return data->match(checklist->rfc931);
     } else if (checklist->conn() != NULL && checklist->conn()->clientConnection != NULL && checklist->conn()->clientConnection->rfc931[0]) {
         return data->match(checklist->conn()->clientConnection->rfc931);
     } else if (checklist->conn() != NULL && Comm::IsConnOpen(checklist->conn()->clientConnection)) {
         if (checklist->goAsync(IdentLookup::Instance())) {

=== modified file 'src/ident/AclIdent.h'
--- src/ident/AclIdent.h	2017-01-01 00:12:22 +0000
+++ src/ident/AclIdent.h	2017-05-14 17:55:12 +0000
@@ -23,41 +23,38 @@
 
 private:
     static IdentLookup instance_;
     static void LookupDone(const char *ident, void *data);
 };
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
 
 /// \ingroup ACLAPI
 class ACLIdent : public ACL
 {
     MEMPROXY_CLASS(ACLIdent);
 
 public:
     ACLIdent(ACLData<char const *> *newData, char const *);
     ACLIdent (ACLIdent const &old);
     ACLIdent & operator= (ACLIdent const &rhs);
     ~ACLIdent();
 
+    /* ACL API */
     virtual char const *typeString() const;
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
-
+    virtual void parseFlags();
     virtual int match(ACLChecklist *checklist);
     virtual SBufList dump() const;
     virtual bool empty () const;
     virtual ACL *clone()const;
 
 private:
-    static Prototype UserRegistryProtoype;
-    static ACLIdent UserRegistryEntry_;
-    static Prototype RegexRegistryProtoype;
-    static ACLIdent RegexRegistryEntry_;
     ACLData<char const *> *data;
     char const *type_;
 };
 
 #endif /* USE_IDENT */
 #endif /* SQUID_IDENT_ACLIDENT_H */
 

=== modified file 'src/main.cc'
--- src/main.cc	2017-03-03 23:18:25 +0000
+++ src/main.cc	2017-05-14 17:55:12 +0000
@@ -1,34 +1,35 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 01    Startup and Main Loop */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "acl/Acl.h"
+//#include "acl/Acl.h"
 #include "acl/Asn.h"
+#include "AclRegs.h"
 #include "anyp/UriScheme.h"
 #include "auth/Config.h"
 #include "auth/Gadgets.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
 #include "base/Subscription.h"
 #include "base/TextException.h"
 #include "cache_cf.h"
 #include "CachePeer.h"
 #include "carp.h"
 #include "client_db.h"
 #include "client_side.h"
 #include "comm.h"
 #include "ConfigParser.h"
 #include "CpuAffinity.h"
 #include "DiskIO/DiskIOModule.h"
 #include "dns/forward.h"
 #include "errorpage.h"
 #include "event.h"
 #include "EventLoop.h"
@@ -1498,40 +1499,41 @@
 
         assert(!configured_once);
 
         Mem::Init();
 
         AnyP::UriScheme::Init();
 
         storeFsInit();      /* required for config parsing */
 
         /* TODO: call the FS::Clean() in shutdown to do Fs cleanups */
         Fs::Init();
 
         /* May not be needed for parsing, have not audited for such */
         DiskIOModule::SetupAllModules();
 
         /* Shouldn't be needed for config parsing, but have not audited for such */
         StoreFileSystem::SetupAllFs();
 
         /* we may want the parsing process to set this up in the future */
         Store::Init();
+        Acl::Init();
         Auth::Init();      /* required for config parsing. NOP if !USE_AUTH */
         Ip::ProbeTransport(); // determine IPv4 or IPv6 capabilities before parsing.
 
         Format::Token::Init(); // XXX: temporary. Use a runners registry of pre-parse runners instead.
 
         try {
             parse_err = parseConfigFile(ConfigFile);
         } catch (...) {
             // for now any errors are a fatal condition...
             debugs(1, DBG_CRITICAL, "FATAL: Unhandled exception parsing config file." <<
                    (opt_parse_cfg_only ? " Run squid -k parse and check for errors." : ""));
             parse_err = 1;
         }
 
         Mem::Report();
 
         if (opt_parse_cfg_only || parse_err > 0)
             return parse_err;
     }
     setUmask(Config.umask);

=== modified file 'src/sbuf/Stream.h'
--- src/sbuf/Stream.h	2017-01-01 00:12:22 +0000
+++ src/sbuf/Stream.h	2017-05-14 17:55:12 +0000
@@ -101,22 +101,34 @@
         clear(); //clear badbit set by calling init(0)
     }
 
     /// Retrieve a copy of the current stream status
     SBuf buf() {
         flush();
         return theBuffer.getBuf();
     }
 
     /// Clear the stream's backing store
     SBufStream& clearBuf() {
         flush();
         theBuffer.clearBuf();
         return *this;
     }
 
 private:
     SBufStreamBuf theBuffer;
 };
 
+/// slowly stream-prints all arguments into a freshly allocated SBuf
+template <typename... Args>
+inline
+SBuf ToSBuf(Args&&... args)
+{
+    // TODO: Make this code readable after requiring C++17.
+    SBufStream out;
+    using expander = int[];
+    (void)expander {0, (void(out << std::forward<Args>(args)),0)...};
+    return out.buf();
+}
+
 #endif /* SQUID_SBUFSTREAM_H */
 

=== modified file 'src/snmp_core.cc'
--- src/snmp_core.cc	2017-01-01 00:12:22 +0000
+++ src/snmp_core.cc	2017-05-14 17:55:12 +0000
@@ -1113,68 +1113,26 @@
 {
     struct in_addr i4addr;
     struct in6_addr i6addr;
     u_int i;
     u_char *cp;
     if ( size == sizeof(struct in_addr) )
         cp = (u_char *) &(i4addr.s_addr);
     else
         cp = (u_char *) &(i6addr);
     MemBuf tmp;
     debugs(49, 7, "oid2addr: id : " << snmpDebugOid(id, size, tmp) );
     for (i=0 ; i<size; ++i) {
         cp[i] = id[i];
     }
     if ( size == sizeof(struct in_addr) )
         addr = i4addr;
     else
         addr = i6addr;
 }
 
-/* SNMP checklists */
-#include "acl/Strategised.h"
-#include "acl/Strategy.h"
-#include "acl/StringData.h"
-
-class ACLSNMPCommunityStrategy : public ACLStrategy<char const *>
-{
-
-public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
-    static ACLSNMPCommunityStrategy *Instance();
-    /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g++ warnings about
-     * private constructors with no friends */
-    ACLSNMPCommunityStrategy(ACLSNMPCommunityStrategy const &);
-
-private:
-    static ACLSNMPCommunityStrategy Instance_;
-    ACLSNMPCommunityStrategy() {}
-
-    ACLSNMPCommunityStrategy&operator=(ACLSNMPCommunityStrategy const &);
-};
-
-class ACLSNMPCommunity
-{
-
-private:
-    static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<char const *> RegistryEntry_;
-};
-
-ACL::Prototype ACLSNMPCommunity::RegistryProtoype(&ACLSNMPCommunity::RegistryEntry_, "snmp_community");
-ACLStrategised<char const *> ACLSNMPCommunity::RegistryEntry_(new ACLStringData, ACLSNMPCommunityStrategy::Instance(), "snmp_community");
-
 int
-ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->snmp_community);
 }
 
-ACLSNMPCommunityStrategy *
-ACLSNMPCommunityStrategy::Instance()
-{
-    return &Instance_;
-}
-
-ACLSNMPCommunityStrategy ACLSNMPCommunityStrategy::Instance_;
-

=== modified file 'src/snmp_core.h'
--- src/snmp_core.h	2017-01-01 00:12:22 +0000
+++ src/snmp_core.h	2017-05-14 17:55:12 +0000
@@ -1,55 +1,62 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 /* DEBUG: section 49    SNMP Interface */
 
 #ifndef SQUID_SNMP_CORE_H
 #define SQUID_SNMP_CORE_H
 
+#include "acl/Strategy.h"
 #include "cache_snmp.h"
 #include "comm/forward.h"
 #include "ip/forward.h"
 
 class MemBuf;
 
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
 
 typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
 typedef struct _mib_tree_entry mib_tree_entry;
 typedef oid *(instance_Fn) (oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 typedef enum {atNone = 0, atSum, atAverage, atMax, atMin} AggrType;
 
 struct _mib_tree_entry {
     oid *name;
     int len;
     oid_ParseFn *parsefunction;
     instance_Fn *instancefunction;
     int children;
 
     struct _mib_tree_entry **leaves;
 
     struct _mib_tree_entry *parent;
     AggrType aggrType;
 };
 
 struct snmp_pdu* snmpAgentResponse(struct snmp_pdu* PDU);
 AggrType snmpAggrType(oid* Current, snint CurrentLen);
 
 extern Comm::ConnectionPointer snmpOutgoingConn;
 
 extern PF snmpHandleUdp;
 void snmpInit(void);
 void snmpOpenPorts(void);
 void snmpClosePorts(void);
 const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
 void addr2oid(Ip::Address &addr, oid *Dest);
 void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
 
+class ACLSNMPCommunityStrategy: public ACLStrategy<char const *>
+{
+public:
+    virtual int match (ACLData<MatchType> *&data, ACLFilledChecklist *checklist) override;
+};
+
 #endif /* SQUID_SNMP_CORE_H */
 

=== modified file 'src/tests/stub_libauth_acls.cc'
--- src/tests/stub_libauth_acls.cc	2017-01-01 00:12:22 +0000
+++ src/tests/stub_libauth_acls.cc	2017-05-14 17:55:12 +0000
@@ -3,50 +3,50 @@
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 
 #define STUB_API "auth/libacls.la"
 #include "STUB.h"
 
 #if USE_AUTH
 #include "acl/Acl.h" /* for allow_t */
 
 #include "auth/Acl.h"
 allow_t AuthenticateAcl(ACLChecklist *) STUB_RETVAL(ACCESS_DENIED)
 
 #include "auth/AclMaxUserIp.h"
 ACL * ACLMaxUserIP::clone() const STUB_RETVAL(NULL)
 ACLMaxUserIP::ACLMaxUserIP (char const *) STUB
-ACLMaxUserIP::ACLMaxUserIP (ACLMaxUserIP const &) STUB
-ACLMaxUserIP::~ACLMaxUserIP() STUB
 char const * ACLMaxUserIP::typeString() const STUB_RETVAL(NULL)
 bool ACLMaxUserIP::empty () const STUB_RETVAL(false)
 bool ACLMaxUserIP::valid () const STUB_RETVAL(false)
 void ACLMaxUserIP::parse() STUB
 int ACLMaxUserIP::match(Auth::UserRequest::Pointer, Ip::Address const &) STUB_RETVAL(0)
 int ACLMaxUserIP::match(ACLChecklist *) STUB_RETVAL(0)
 SBufList ACLMaxUserIP::dump() const STUB_RETVAL(SBufList())
+const Acl::Options &ACLMaxUserIP::options() STUB_RETVAL(Acl::NoOptions())
 
 #include "auth/AclProxyAuth.h"
 ACLProxyAuth::~ACLProxyAuth() STUB
 ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *, char const *) STUB
 ACLProxyAuth::ACLProxyAuth (ACLProxyAuth const &) STUB
 ACLProxyAuth & ACLProxyAuth::operator= (ACLProxyAuth const & a) STUB_RETVAL(const_cast<ACLProxyAuth &>(a))
 char const * ACLProxyAuth::typeString() const STUB_RETVAL(NULL)
 void ACLProxyAuth::parse() STUB
 int ACLProxyAuth::match(ACLChecklist *) STUB_RETVAL(0)
 SBufList ACLProxyAuth::dump() const STUB_RETVAL(SBufList())
 bool ACLProxyAuth::empty () const STUB_RETVAL(false)
 bool ACLProxyAuth::valid () const STUB_RETVAL(false)
 ProxyAuthLookup * ProxyAuthLookup::Instance() STUB_RETVAL(NULL)
 void ProxyAuthLookup::checkForAsync(ACLChecklist *) const STUB
 void ProxyAuthLookup::LookupDone(void *) STUB
 ACL * ACLProxyAuth::clone() const STUB_RETVAL(NULL)
 int ACLProxyAuth::matchForCache(ACLChecklist *) STUB_RETVAL(0)
 int ACLProxyAuth::matchProxyAuth(ACLChecklist *) STUB_RETVAL(0)
+void ACLProxyAuth::parseFlags() STUB
 
 #endif /* USE_AUTH */
 

=== modified file 'src/tests/testACLMaxUserIP.cc'
--- src/tests/testACLMaxUserIP.cc	2017-01-01 00:12:22 +0000
+++ src/tests/testACLMaxUserIP.cc	2017-05-23 10:32:31 +0000
@@ -1,61 +1,67 @@
 /*
  * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
 
 #if USE_AUTH
 
+#include "acl/Acl.h"
 #include "auth/AclMaxUserIp.h"
+#include "auth/UserRequest.h"
 #include "ConfigParser.h"
 #include "testACLMaxUserIP.h"
 #include "unitTestMain.h"
 
 #include <stdexcept>
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testACLMaxUserIP );
 
 void
 testACLMaxUserIP::testDefaults()
 {
     ACLMaxUserIP anACL("max_user_ip");
     /* 0 is not a valid maximum, so we start at 0 */
     CPPUNIT_ASSERT_EQUAL(0,anACL.getMaximum());
     /* and we have no option to turn strict OFF, so start ON. */
-    CPPUNIT_ASSERT_EQUAL(false,anACL.getStrict());
+    CPPUNIT_ASSERT_EQUAL(false, static_cast<bool>(anACL.beStrict));
     /* an unparsed acl must not be valid - there is no sane default */
     CPPUNIT_ASSERT_EQUAL(false,anACL.valid());
 }
 
-ACL::Prototype ACLMaxUserIP::RegistryProtoype(&ACLMaxUserIP::RegistryEntry_, "max_user_ip");
-ACLMaxUserIP ACLMaxUserIP::RegistryEntry_("max_user_ip");
+void
+testACLMaxUserIP::setUp()
+{
+    CPPUNIT_NS::TestFixture::setUp();
+    Acl::RegisterMaker("max_user_ip", [](Acl::TypeName name)->ACL* { return new ACLMaxUserIP(name); });
+}
 
 void
 testACLMaxUserIP::testParseLine()
 {
     /* a config line to pass with a lead-in token to seed the parser. */
     char * line = xstrdup("test max_user_ip -s 1");
     /* seed the parser */
     ConfigParser::SetCfgLine(line);
     ACL *anACL = NULL;
     ConfigParser LegacyParser;
     ACL::ParseAclLine(LegacyParser, &anACL);
     ACLMaxUserIP *maxUserIpACL = dynamic_cast<ACLMaxUserIP *>(anACL);
     CPPUNIT_ASSERT(maxUserIpACL);
     if (maxUserIpACL) {
         /* we want a maximum of one, and strict to be true */
         CPPUNIT_ASSERT_EQUAL(1, maxUserIpACL->getMaximum());
-        CPPUNIT_ASSERT_EQUAL(true, maxUserIpACL->getStrict());
+        CPPUNIT_ASSERT_EQUAL(true, static_cast<bool>(maxUserIpACL->beStrict));
         /* the acl must be vaid */
         CPPUNIT_ASSERT_EQUAL(true, maxUserIpACL->valid());
     }
     delete anACL;
     xfree(line);
 }
 
 #endif /* USE_AUTH */
 

=== modified file 'src/tests/testACLMaxUserIP.h'
--- src/tests/testACLMaxUserIP.h	2017-01-01 00:12:22 +0000
+++ src/tests/testACLMaxUserIP.h	2017-05-23 10:35:53 +0000
@@ -10,29 +10,30 @@
 #define SQUID_SRC_TEST_ACLMAXUSERIP_H
 
 #if USE_AUTH
 
 #include <cppunit/extensions/HelperMacros.h>
 
 /*
  * demonstration test file, as new idioms are made they will
  * be shown in the testBoilerplate source.
  */
 
 class testACLMaxUserIP : public CPPUNIT_NS::TestFixture
 {
     CPPUNIT_TEST_SUITE( testACLMaxUserIP );
     /* note the statement here and then the actual prototype below */
     CPPUNIT_TEST( testDefaults );
     CPPUNIT_TEST( testParseLine );
     CPPUNIT_TEST_SUITE_END();
 
 public:
+    virtual void setUp() override;
 
 protected:
     void testDefaults();
     void testParseLine();
 };
 
 #endif /* USE_AUTH */
 #endif /* SQUID_SRC_TEST_ACLMAXUSERIP_H */
 

