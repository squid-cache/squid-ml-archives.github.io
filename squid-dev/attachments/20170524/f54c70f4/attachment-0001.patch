=== modified file 'src/FwdState.cc'
--- src/FwdState.cc	2017-05-22 20:14:41 +0000
+++ src/FwdState.cc	2017-05-24 20:12:18 +0000
@@ -95,41 +95,41 @@ public:
     virtual Security::EncryptorAnswer &answer() { return answer_; }
 
 private:
     Method method_;
     CbcPointer<FwdState> fwd_;
     Security::EncryptorAnswer answer_;
 };
 
 void
 FwdState::abort(void* d)
 {
     FwdState* fwd = (FwdState*)d;
     Pointer tmp = fwd; // Grab a temporary pointer to keep the object alive during our scope.
 
     if (Comm::IsConnOpen(fwd->serverConnection())) {
         fwd->closeServerConnection("store entry aborted");
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
     fwd->serverDestinations.clear();
-    fwd->self = NULL;
+    fwd->stopAndDestroy("store entry aborted");
 }
 
 void
 FwdState::closeServerConnection(const char *reason)
 {
     debugs(17, 3, "because " << reason << "; " << serverConn);
     comm_remove_close_handler(serverConn->fd, closeHandler);
     closeHandler = NULL;
     fwdPconnPool->noteUses(fd_table[serverConn->fd].pconn.uses);
     serverConn->close();
 }
 
 /**** PUBLIC INTERFACE ********************************************************/
 
 FwdState::FwdState(const Comm::ConnectionPointer &client, StoreEntry * e, HttpRequest * r, const AccessLogEntryPointer &alp):
     entry(e),
     request(r),
     al(alp),
     err(NULL),
     clientConn(client),
@@ -167,40 +167,50 @@ void FwdState::start(Pointer aSelf)
 
 #if STRICT_ORIGINAL_DST
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must force DIRECT and only to the original client destination.
     const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || (request && !request->flags.hostVerified);
     if (isIntercepted && useOriginalDst) {
         selectPeerForIntercepted();
         // 3.2 does not suppro re-wrapping inside CONNECT.
         // our only alternative is to fake destination "found" and continue with the forwarding.
         startConnectionOrFail();
         return;
     }
 #endif
 
     // do full route options selection
     startSelectingDestinations(request, al, entry);
 }
 
+/// ends forwarding; relies on refcounting so the effect may not be immediate
+void
+FwdState::stopAndDestroy(const char *reason)
+{
+    debugs(17, 3, "for " << reason);
+    PeerSelectionInitiator::subscribed = false; // may already be false
+    self = nullptr; // we hope refcounting destroys us soon; may already be nil
+    /* do not place any code here as this object may be gone by now */
+}
+
 #if STRICT_ORIGINAL_DST
 /// bypasses peerSelect() when dealing with intercepted requests
 void
 FwdState::selectPeerForIntercepted()
 {
     // use pinned connection if available
     Comm::ConnectionPointer p;
     if (ConnStateData *client = request->pinnedConnection()) {
         p = client->validatePinnedConnection(request, NULL);
         if (Comm::IsConnOpen(p)) {
             /* duplicate peerSelectPinned() effects */
             p->peerType = PINNED;
             entry->ping_status = PING_DONE;     /* Skip ICP */
 
             debugs(17, 3, "reusing a pinned conn: " << *p);
             serverDestinations.push_back(p);
         } else {
             debugs(17,2, "Pinned connection is not valid: " << p);
             ErrorState *anErr = new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, request);
             fail(anErr);
@@ -412,46 +422,52 @@ FwdState::EnoughTimeToReForward(const ti
 void
 FwdState::startConnectionOrFail()
 {
     debugs(17, 3, HERE << entry->url());
 
     if (serverDestinations.size() > 0) {
         // Ditch error page if it was created before.
         // A new one will be created if there's another problem
         delete err;
         err = NULL;
 
         // Update the logging information about this new server connection.
         // Done here before anything else so the errors get logged for
         // this server link regardless of what happens when connecting to it.
         // IF sucessfuly connected this top destination will become the serverConnection().
         syncHierNote(serverDestinations[0], request->url.host());
         request->clearError();
 
         connectStart();
     } else {
+        if (PeerSelectionInitiator::subscribed) {
+            debugs(17, 4, "wait for more destinations to try");
+            return; // expect a noteDestination*() call
+        }
+
         debugs(17, 3, HERE << "Connection failed: " << entry->url());
         if (!err) {
             ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scInternalServerError, request);
             fail(anErr);
         } // else use actual error from last connection attempt
-        self = NULL;       // refcounted
+
+        stopAndDestroy("tried all destinations");
     }
 }
 
 void
 FwdState::fail(ErrorState * errorState)
 {
     debugs(17, 3, err_type_str[errorState->type] << " \"" << Http::StatusCodeString(errorState->httpStatus) << "\"\n\t" << entry->url());
 
     delete err;
     err = errorState;
 
     if (!errorState->request)
         errorState->request = request;
 
     if (err->type != ERR_ZERO_SIZE_OBJECT)
         return;
 
     if (pconnRace == racePossible) {
         debugs(17, 5, HERE << "pconn race happened");
         pconnRace = raceHappened;
@@ -496,55 +512,56 @@ FwdState::unregister(int fd)
 void
 FwdState::complete()
 {
     debugs(17, 3, HERE << entry->url() << "\n\tstatus " << entry->getReply()->sline.status());
 #if URL_CHECKSUM_DEBUG
 
     entry->mem_obj->checkUrlChecksum();
 #endif
 
     logReplyStatus(n_tries, entry->getReply()->sline.status());
 
     if (reforward()) {
         debugs(17, 3, HERE << "re-forwarding " << entry->getReply()->sline.status() << " " << entry->url());
 
         if (Comm::IsConnOpen(serverConn))
             unregister(serverConn);
 
         entry->reset();
 
         // drop the last path off the selection list. try the next one.
-        serverDestinations.erase(serverDestinations.begin());
+        if (!serverDestinations.empty()) // paranoid
+            serverDestinations.erase(serverDestinations.begin());
         startConnectionOrFail();
 
     } else {
         if (Comm::IsConnOpen(serverConn))
             debugs(17, 3, HERE << "server FD " << serverConnection()->fd << " not re-forwarding status " << entry->getReply()->sline.status());
         else
             debugs(17, 3, HERE << "server (FD closed) not re-forwarding status " << entry->getReply()->sline.status());
         EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
         entry->complete();
 
         if (!Comm::IsConnOpen(serverConn))
             completed();
 
-        self = NULL; // refcounted
+        stopAndDestroy("forwarding completed");
     }
 }
 
 void
 FwdState::noteDestination(Comm::ConnectionPointer path)
 {
     const bool wasBlocked = serverDestinations.empty();
     serverDestinations.push_back(path);
     if (wasBlocked)
         startConnectionOrFail();
     // else continue to use one of the previously noted destinations;
     // if all of them fail, we may try this path
 }
 
 void
 FwdState::noteDestinationsEnd(ErrorState *selectionError)
 {
     PeerSelectionInitiator::subscribed = false;
     if (const bool wasBlocked = serverDestinations.empty()) {
 
@@ -663,41 +680,41 @@ FwdState::retryOrBail()
         debugs(17, 3, HERE << "re-forwarding (" << n_tries << " tries, " << (squid_curtime - start_t) << " secs)");
         // we should retry the same destination if it failed due to pconn race
         if (pconnRace == raceHappened)
             debugs(17, 4, HERE << "retrying the same destination");
         else
             serverDestinations.erase(serverDestinations.begin()); // last one failed. try another.
         startConnectionOrFail();
         return;
     }
 
     // TODO: should we call completed() here and move doneWithRetries there?
     doneWithRetries();
 
     request->hier.stopPeerClock(false);
 
     if (self != NULL && !err && shutting_down && entry->isEmpty()) {
         ErrorState *anErr = new ErrorState(ERR_SHUTTING_DOWN, Http::scServiceUnavailable, request);
         errorAppendEntry(entry, anErr);
     }
 
-    self = NULL;    // refcounted
+    stopAndDestroy("cannot retry");
 }
 
 // If the Server quits before nibbling at the request body, the body sender
 // will not know (so that we can retry). Call this if we will not retry. We
 // will notify the sender so that it does not get stuck waiting for space.
 void
 FwdState::doneWithRetries()
 {
     if (request && request->body_pipe != NULL)
         request->body_pipe->expectNoConsumption();
 }
 
 // called by the server that failed after calling unregister()
 void
 FwdState::handleUnregisteredServerEnd()
 {
     debugs(17, 2, HERE << "self=" << self << " err=" << err << ' ' << entry->url());
     assert(!Comm::IsConnOpen(serverConn));
     retryOrBail();
 }
@@ -841,75 +858,75 @@ FwdState::syncHierNote(const Comm::Conne
 /**
  * Called after forwarding path selection (via peer select) has taken place
  * and whenever forwarding needs to attempt a new connection (routing failover).
  * We have a vector of possible localIP->remoteIP paths now ready to start being connected.
  */
 void
 FwdState::connectStart()
 {
     assert(serverDestinations.size() > 0);
 
     debugs(17, 3, "fwdConnectStart: " << entry->url());
 
     request->hier.startPeerClock();
 
     // Do not fowrward bumped connections to parent proxy unless it is an
     // origin server
     if (serverDestinations[0]->getPeer() && !serverDestinations[0]->getPeer()->options.originserver && request->flags.sslBumped) {
         debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request);
         fail(anErr);
-        self = NULL; // refcounted
+        stopAndDestroy("SslBump misconfiguration");
         return;
     }
 
     request->flags.pinned = false; // XXX: what if the ConnStateData set this to flag existing credentials?
     // XXX: answer: the peer selection *should* catch it and give us only the pinned peer. so we reverse the =0 step below.
     // XXX: also, logs will now lie if pinning is broken and leads to an error message.
     if (serverDestinations[0]->peerType == PINNED) {
         ConnStateData *pinned_connection = request->pinnedConnection();
         debugs(17,7, "pinned peer connection: " << pinned_connection);
         // pinned_connection may become nil after a pconn race
         serverConn = pinned_connection ? pinned_connection->borrowPinnedConnection(request, serverDestinations[0]->getPeer()) : nullptr;
         if (Comm::IsConnOpen(serverConn)) {
             flags.connected_okay = true;
             ++n_tries;
             request->flags.pinned = true;
 
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = true;
 
             closeHandler = comm_add_close_handler(serverConn->fd,  fwdServerClosedWrapper, this);
 
             syncWithServerConn(pinned_connection->pinning.host);
 
             // the server may close the pinned connection before this request
             pconnRace = racePossible;
             dispatch();
             return;
         }
 
         // Pinned connection failure.
         debugs(17,2,HERE << "Pinned connection failed: " << pinned_connection);
         ErrorState *anErr = new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, request);
         fail(anErr);
-        self = NULL; // refcounted
+        stopAndDestroy("pinned connection failure");
         return;
     }
 
     // Use pconn to avoid opening a new connection.
     const char *host = NULL;
     if (!serverDestinations[0]->getPeer())
         host = request->url.host();
 
     Comm::ConnectionPointer temp;
     // Avoid pconns after races so that the same client does not suffer twice.
     // This does not increase the total number of connections because we just
     // closed the connection that failed the race. And re-pinning assumes this.
     if (pconnRace != raceHappened)
         temp = pconnPop(serverDestinations[0], host);
 
     const bool openedPconn = Comm::IsConnOpen(temp);
     pconnRace = openedPconn ? racePossible : raceImpossible;
 
     // if we found an open persistent connection to use. use it.
     if (openedPconn) {
@@ -1083,41 +1100,41 @@ FwdState::reforward()
     assert(e->store_status == STORE_PENDING);
     assert(e->mem_obj);
 #if URL_CHECKSUM_DEBUG
 
     e->mem_obj->checkUrlChecksum();
 #endif
 
     debugs(17, 3, HERE << e->url() << "?" );
 
     if (!EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT)) {
         debugs(17, 3, HERE << "No, ENTRY_FWD_HDR_WAIT isn't set");
         return 0;
     }
 
     if (n_tries > Config.forward_max_tries)
         return 0;
 
     if (request->bodyNibbled())
         return 0;
 
-    if (serverDestinations.size() <= 1) {
+    if (serverDestinations.size() <= 1 && !PeerSelectionInitiator::subscribed) {
         // NP: <= 1 since total count includes the recently failed one.
         debugs(17, 3, HERE << "No alternative forwarding paths left");
         return 0;
     }
 
     const Http::StatusCode s = e->getReply()->sline.status();
     debugs(17, 3, HERE << "status " << s);
     return reforwardableStatus(s);
 }
 
 /**
  * Create "503 Service Unavailable" or "504 Gateway Timeout" error depending
  * on whether this is a validation request. RFC 2616 says that we MUST reply
  * with "504 Gateway Timeout" if validation fails and cached reply has
  * proxy-revalidate, must-revalidate or s-maxage Cache-Control directive.
  */
 ErrorState *
 FwdState::makeConnectingError(const err_type type) const
 {
     return new ErrorState(type, request->flags.needValidation ?

=== modified file 'src/FwdState.h'
--- src/FwdState.h	2017-05-22 20:14:41 +0000
+++ src/FwdState.h	2017-05-24 20:00:14 +0000
@@ -93,40 +93,41 @@ public:
     void connectTimeout(int fd);
     bool checkRetry();
     bool checkRetriable();
     void dispatch();
     /// Pops a connection from connection pool if available. If not
     /// checks the peer stand-by connection pool for available connection.
     Comm::ConnectionPointer pconnPop(const Comm::ConnectionPointer &dest, const char *domain);
     void pconnPush(Comm::ConnectionPointer & conn, const char *domain);
 
     bool dontRetry() { return flags.dont_retry; }
 
     void dontRetry(bool val) { flags.dont_retry = val; }
 
     /** return a ConnectionPointer to the current server connection (may or may not be open) */
     Comm::ConnectionPointer const & serverConnection() const { return serverConn; };
 
 private:
     // hidden for safer management of self; use static fwdStart
     FwdState(const Comm::ConnectionPointer &client, StoreEntry *, HttpRequest *, const AccessLogEntryPointer &alp);
     void start(Pointer aSelf);
+    void stopAndDestroy(const char *reason);
 
     /* PeerSelectionInitiator API */
     virtual void noteDestination(Comm::ConnectionPointer conn) override;
     virtual void noteDestinationsEnd(ErrorState *selectionError) override;
 
 #if STRICT_ORIGINAL_DST
     void selectPeerForIntercepted();
 #endif
     static void logReplyStatus(int tries, const Http::StatusCode status);
     void doneWithRetries();
     void completed();
     void retryOrBail();
     ErrorState *makeConnectingError(const err_type type) const;
     void connectedToPeer(Security::EncryptorAnswer &answer);
     static void RegisterWithCacheManager(void);
 
     /// stops monitoring server connection for closure and updates pconn stats
     void closeServerConnection(const char *reason);
 
     void syncWithServerConn(const char *host);

------------------------------------------------------------
revno: 15136
committer: Alex Rousskov <rousskov@measurement-factory.com>
branch nick: happy-eyeballs
timestamp: Wed 2017-05-24 14:20:32 -0600
message:
  Fixed FwdState serverDestinations checking logic.
  
  When serverDestinations is empty (or equivalent), we must check
  PeerSelectionInitiator::subscribed to know whether more destinations
  might be coming.
=== modified file 'src/FwdState.cc'
--- src/FwdState.cc	2017-05-22 20:14:41 +0000
+++ src/FwdState.cc	2017-05-24 20:20:32 +0000
@@ -95,41 +95,41 @@ public:
     virtual Security::EncryptorAnswer &answer() { return answer_; }
 
 private:
     Method method_;
     CbcPointer<FwdState> fwd_;
     Security::EncryptorAnswer answer_;
 };
 
 void
 FwdState::abort(void* d)
 {
     FwdState* fwd = (FwdState*)d;
     Pointer tmp = fwd; // Grab a temporary pointer to keep the object alive during our scope.
 
     if (Comm::IsConnOpen(fwd->serverConnection())) {
         fwd->closeServerConnection("store entry aborted");
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
     fwd->serverDestinations.clear();
-    fwd->self = NULL;
+    fwd->stopAndDestroy("store entry aborted");
 }
 
 void
 FwdState::closeServerConnection(const char *reason)
 {
     debugs(17, 3, "because " << reason << "; " << serverConn);
     comm_remove_close_handler(serverConn->fd, closeHandler);
     closeHandler = NULL;
     fwdPconnPool->noteUses(fd_table[serverConn->fd].pconn.uses);
     serverConn->close();
 }
 
 /**** PUBLIC INTERFACE ********************************************************/
 
 FwdState::FwdState(const Comm::ConnectionPointer &client, StoreEntry * e, HttpRequest * r, const AccessLogEntryPointer &alp):
     entry(e),
     request(r),
     al(alp),
     err(NULL),
     clientConn(client),
@@ -167,40 +167,50 @@ void FwdState::start(Pointer aSelf)
 
 #if STRICT_ORIGINAL_DST
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must force DIRECT and only to the original client destination.
     const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || (request && !request->flags.hostVerified);
     if (isIntercepted && useOriginalDst) {
         selectPeerForIntercepted();
         // 3.2 does not suppro re-wrapping inside CONNECT.
         // our only alternative is to fake destination "found" and continue with the forwarding.
         startConnectionOrFail();
         return;
     }
 #endif
 
     // do full route options selection
     startSelectingDestinations(request, al, entry);
 }
 
+/// ends forwarding; relies on refcounting so the effect may not be immediate
+void
+FwdState::stopAndDestroy(const char *reason)
+{
+    debugs(17, 3, "for " << reason);
+    PeerSelectionInitiator::subscribed = false; // may already be false
+    self = nullptr; // we hope refcounting destroys us soon; may already be nil
+    /* do not place any code here as this object may be gone by now */
+}
+
 #if STRICT_ORIGINAL_DST
 /// bypasses peerSelect() when dealing with intercepted requests
 void
 FwdState::selectPeerForIntercepted()
 {
     // use pinned connection if available
     Comm::ConnectionPointer p;
     if (ConnStateData *client = request->pinnedConnection()) {
         p = client->validatePinnedConnection(request, NULL);
         if (Comm::IsConnOpen(p)) {
             /* duplicate peerSelectPinned() effects */
             p->peerType = PINNED;
             entry->ping_status = PING_DONE;     /* Skip ICP */
 
             debugs(17, 3, "reusing a pinned conn: " << *p);
             serverDestinations.push_back(p);
         } else {
             debugs(17,2, "Pinned connection is not valid: " << p);
             ErrorState *anErr = new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, request);
             fail(anErr);
@@ -412,46 +422,52 @@ FwdState::EnoughTimeToReForward(const ti
 void
 FwdState::startConnectionOrFail()
 {
     debugs(17, 3, HERE << entry->url());
 
     if (serverDestinations.size() > 0) {
         // Ditch error page if it was created before.
         // A new one will be created if there's another problem
         delete err;
         err = NULL;
 
         // Update the logging information about this new server connection.
         // Done here before anything else so the errors get logged for
         // this server link regardless of what happens when connecting to it.
         // IF sucessfuly connected this top destination will become the serverConnection().
         syncHierNote(serverDestinations[0], request->url.host());
         request->clearError();
 
         connectStart();
     } else {
+        if (PeerSelectionInitiator::subscribed) {
+            debugs(17, 4, "wait for more destinations to try");
+            return; // expect a noteDestination*() call
+        }
+
         debugs(17, 3, HERE << "Connection failed: " << entry->url());
         if (!err) {
             ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scInternalServerError, request);
             fail(anErr);
         } // else use actual error from last connection attempt
-        self = NULL;       // refcounted
+
+        stopAndDestroy("tried all destinations");
     }
 }
 
 void
 FwdState::fail(ErrorState * errorState)
 {
     debugs(17, 3, err_type_str[errorState->type] << " \"" << Http::StatusCodeString(errorState->httpStatus) << "\"\n\t" << entry->url());
 
     delete err;
     err = errorState;
 
     if (!errorState->request)
         errorState->request = request;
 
     if (err->type != ERR_ZERO_SIZE_OBJECT)
         return;
 
     if (pconnRace == racePossible) {
         debugs(17, 5, HERE << "pconn race happened");
         pconnRace = raceHappened;
@@ -496,55 +512,56 @@ FwdState::unregister(int fd)
 void
 FwdState::complete()
 {
     debugs(17, 3, HERE << entry->url() << "\n\tstatus " << entry->getReply()->sline.status());
 #if URL_CHECKSUM_DEBUG
 
     entry->mem_obj->checkUrlChecksum();
 #endif
 
     logReplyStatus(n_tries, entry->getReply()->sline.status());
 
     if (reforward()) {
         debugs(17, 3, HERE << "re-forwarding " << entry->getReply()->sline.status() << " " << entry->url());
 
         if (Comm::IsConnOpen(serverConn))
             unregister(serverConn);
 
         entry->reset();
 
         // drop the last path off the selection list. try the next one.
-        serverDestinations.erase(serverDestinations.begin());
+        if (!serverDestinations.empty()) // paranoid
+            serverDestinations.erase(serverDestinations.begin());
         startConnectionOrFail();
 
     } else {
         if (Comm::IsConnOpen(serverConn))
             debugs(17, 3, HERE << "server FD " << serverConnection()->fd << " not re-forwarding status " << entry->getReply()->sline.status());
         else
             debugs(17, 3, HERE << "server (FD closed) not re-forwarding status " << entry->getReply()->sline.status());
         EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
         entry->complete();
 
         if (!Comm::IsConnOpen(serverConn))
             completed();
 
-        self = NULL; // refcounted
+        stopAndDestroy("forwarding completed");
     }
 }
 
 void
 FwdState::noteDestination(Comm::ConnectionPointer path)
 {
     const bool wasBlocked = serverDestinations.empty();
     serverDestinations.push_back(path);
     if (wasBlocked)
         startConnectionOrFail();
     // else continue to use one of the previously noted destinations;
     // if all of them fail, we may try this path
 }
 
 void
 FwdState::noteDestinationsEnd(ErrorState *selectionError)
 {
     PeerSelectionInitiator::subscribed = false;
     if (const bool wasBlocked = serverDestinations.empty()) {
 
@@ -663,41 +680,41 @@ FwdState::retryOrBail()
         debugs(17, 3, HERE << "re-forwarding (" << n_tries << " tries, " << (squid_curtime - start_t) << " secs)");
         // we should retry the same destination if it failed due to pconn race
         if (pconnRace == raceHappened)
             debugs(17, 4, HERE << "retrying the same destination");
         else
             serverDestinations.erase(serverDestinations.begin()); // last one failed. try another.
         startConnectionOrFail();
         return;
     }
 
     // TODO: should we call completed() here and move doneWithRetries there?
     doneWithRetries();
 
     request->hier.stopPeerClock(false);
 
     if (self != NULL && !err && shutting_down && entry->isEmpty()) {
         ErrorState *anErr = new ErrorState(ERR_SHUTTING_DOWN, Http::scServiceUnavailable, request);
         errorAppendEntry(entry, anErr);
     }
 
-    self = NULL;    // refcounted
+    stopAndDestroy("cannot retry");
 }
 
 // If the Server quits before nibbling at the request body, the body sender
 // will not know (so that we can retry). Call this if we will not retry. We
 // will notify the sender so that it does not get stuck waiting for space.
 void
 FwdState::doneWithRetries()
 {
     if (request && request->body_pipe != NULL)
         request->body_pipe->expectNoConsumption();
 }
 
 // called by the server that failed after calling unregister()
 void
 FwdState::handleUnregisteredServerEnd()
 {
     debugs(17, 2, HERE << "self=" << self << " err=" << err << ' ' << entry->url());
     assert(!Comm::IsConnOpen(serverConn));
     retryOrBail();
 }
@@ -841,75 +858,75 @@ FwdState::syncHierNote(const Comm::Conne
 /**
  * Called after forwarding path selection (via peer select) has taken place
  * and whenever forwarding needs to attempt a new connection (routing failover).
  * We have a vector of possible localIP->remoteIP paths now ready to start being connected.
  */
 void
 FwdState::connectStart()
 {
     assert(serverDestinations.size() > 0);
 
     debugs(17, 3, "fwdConnectStart: " << entry->url());
 
     request->hier.startPeerClock();
 
     // Do not fowrward bumped connections to parent proxy unless it is an
     // origin server
     if (serverDestinations[0]->getPeer() && !serverDestinations[0]->getPeer()->options.originserver && request->flags.sslBumped) {
         debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request);
         fail(anErr);
-        self = NULL; // refcounted
+        stopAndDestroy("SslBump misconfiguration");
         return;
     }
 
     request->flags.pinned = false; // XXX: what if the ConnStateData set this to flag existing credentials?
     // XXX: answer: the peer selection *should* catch it and give us only the pinned peer. so we reverse the =0 step below.
     // XXX: also, logs will now lie if pinning is broken and leads to an error message.
     if (serverDestinations[0]->peerType == PINNED) {
         ConnStateData *pinned_connection = request->pinnedConnection();
         debugs(17,7, "pinned peer connection: " << pinned_connection);
         // pinned_connection may become nil after a pconn race
         serverConn = pinned_connection ? pinned_connection->borrowPinnedConnection(request, serverDestinations[0]->getPeer()) : nullptr;
         if (Comm::IsConnOpen(serverConn)) {
             flags.connected_okay = true;
             ++n_tries;
             request->flags.pinned = true;
 
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = true;
 
             closeHandler = comm_add_close_handler(serverConn->fd,  fwdServerClosedWrapper, this);
 
             syncWithServerConn(pinned_connection->pinning.host);
 
             // the server may close the pinned connection before this request
             pconnRace = racePossible;
             dispatch();
             return;
         }
 
         // Pinned connection failure.
         debugs(17,2,HERE << "Pinned connection failed: " << pinned_connection);
         ErrorState *anErr = new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, request);
         fail(anErr);
-        self = NULL; // refcounted
+        stopAndDestroy("pinned connection failure");
         return;
     }
 
     // Use pconn to avoid opening a new connection.
     const char *host = NULL;
     if (!serverDestinations[0]->getPeer())
         host = request->url.host();
 
     Comm::ConnectionPointer temp;
     // Avoid pconns after races so that the same client does not suffer twice.
     // This does not increase the total number of connections because we just
     // closed the connection that failed the race. And re-pinning assumes this.
     if (pconnRace != raceHappened)
         temp = pconnPop(serverDestinations[0], host);
 
     const bool openedPconn = Comm::IsConnOpen(temp);
     pconnRace = openedPconn ? racePossible : raceImpossible;
 
     // if we found an open persistent connection to use. use it.
     if (openedPconn) {
@@ -1083,41 +1100,41 @@ FwdState::reforward()
     assert(e->store_status == STORE_PENDING);
     assert(e->mem_obj);
 #if URL_CHECKSUM_DEBUG
 
     e->mem_obj->checkUrlChecksum();
 #endif
 
     debugs(17, 3, HERE << e->url() << "?" );
 
     if (!EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT)) {
         debugs(17, 3, HERE << "No, ENTRY_FWD_HDR_WAIT isn't set");
         return 0;
     }
 
     if (n_tries > Config.forward_max_tries)
         return 0;
 
     if (request->bodyNibbled())
         return 0;
 
-    if (serverDestinations.size() <= 1) {
+    if (serverDestinations.size() <= 1 && !PeerSelectionInitiator::subscribed) {
         // NP: <= 1 since total count includes the recently failed one.
         debugs(17, 3, HERE << "No alternative forwarding paths left");
         return 0;
     }
 
     const Http::StatusCode s = e->getReply()->sline.status();
     debugs(17, 3, HERE << "status " << s);
     return reforwardableStatus(s);
 }
 
 /**
  * Create "503 Service Unavailable" or "504 Gateway Timeout" error depending
  * on whether this is a validation request. RFC 2616 says that we MUST reply
  * with "504 Gateway Timeout" if validation fails and cached reply has
  * proxy-revalidate, must-revalidate or s-maxage Cache-Control directive.
  */
 ErrorState *
 FwdState::makeConnectingError(const err_type type) const
 {
     return new ErrorState(type, request->flags.needValidation ?

=== modified file 'src/FwdState.h'
--- src/FwdState.h	2017-05-22 20:14:41 +0000
+++ src/FwdState.h	2017-05-24 20:20:32 +0000
@@ -93,40 +93,41 @@ public:
     void connectTimeout(int fd);
     bool checkRetry();
     bool checkRetriable();
     void dispatch();
     /// Pops a connection from connection pool if available. If not
     /// checks the peer stand-by connection pool for available connection.
     Comm::ConnectionPointer pconnPop(const Comm::ConnectionPointer &dest, const char *domain);
     void pconnPush(Comm::ConnectionPointer & conn, const char *domain);
 
     bool dontRetry() { return flags.dont_retry; }
 
     void dontRetry(bool val) { flags.dont_retry = val; }
 
     /** return a ConnectionPointer to the current server connection (may or may not be open) */
     Comm::ConnectionPointer const & serverConnection() const { return serverConn; };
 
 private:
     // hidden for safer management of self; use static fwdStart
     FwdState(const Comm::ConnectionPointer &client, StoreEntry *, HttpRequest *, const AccessLogEntryPointer &alp);
     void start(Pointer aSelf);
+    void stopAndDestroy(const char *reason);
 
     /* PeerSelectionInitiator API */
     virtual void noteDestination(Comm::ConnectionPointer conn) override;
     virtual void noteDestinationsEnd(ErrorState *selectionError) override;
 
 #if STRICT_ORIGINAL_DST
     void selectPeerForIntercepted();
 #endif
     static void logReplyStatus(int tries, const Http::StatusCode status);
     void doneWithRetries();
     void completed();
     void retryOrBail();
     ErrorState *makeConnectingError(const err_type type) const;
     void connectedToPeer(Security::EncryptorAnswer &answer);
     static void RegisterWithCacheManager(void);
 
     /// stops monitoring server connection for closure and updates pconn stats
     void closeServerConnection(const char *reason);
 
     void syncWithServerConn(const char *host);

