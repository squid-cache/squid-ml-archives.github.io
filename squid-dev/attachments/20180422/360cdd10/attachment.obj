diff --git a/src/acl/external/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8 b/src/acl/external/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8
index 4c74092f6c..9aeeb45e52 100644
--- a/src/acl/external/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8
+++ b/src/acl/external/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8
@@ -7,7 +7,7 @@ Version 1.3.0sq
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_kerberos_ldap_group_acl
-.if !'po4a'hide' .B [\-h] [\-d] [\-i] [\-s] [\-a] [\-D Realm ] [\-N Netbios\-Realm\-List] [\-m Max\-Depth] [\-u Ldap\-User] [\-p Ldap\-Password] [\-b Ldap\-Bind\-Path] [\-l Ldap\-URL] [\-S ldap server list] \-g Group\-Realm\-List \-t  Hex\-Group\-Realm\-List \-T Hex\-Group\-Hex\-Realm\-List 
+.if !'po4a'hide' .B [\-h] [\-d] [\-i] [\-s] [\-a] [\-D Realm ] [\-N Netbios\-Realm\-List] [\-P service principal name] [\-m Max\-Depth] [\-u Ldap\-User] [\-p Ldap\-Password] [\-b Ldap\-Bind\-Path] [\-l Ldap\-URL] [\-S ldap server list] \-g Group\-Realm\-List \-t  Hex\-Group\-Realm\-List \-T Hex\-Group\-Hex\-Realm\-List
 .
 .SH DESCRIPTION
 .B ext_kerberos_ldap_group_acl
@@ -89,6 +89,8 @@ information (e.g. for users using basic authentication).
 A list of Netbios name mappings to Kerberos domain names of the form 
 Netbios\-Name@Kerberos\-Realm[:Netbios\-Name@Kerberos\-Realm] (e.g. for users 
 using NTLM authentication).
+.if !'po4a'hide' .B \-P service principal name
+The principal name in the keytab to use. Avoids automated selection of name.
 .if !'po4a'hide' .TP 12
 .if !'po4a'hide' .B \-m Max\-Depth
 Maximal depth of recursive group search.
diff --git a/src/acl/external/kerberos_ldap_group/kerberos_ldap_group.cc b/src/acl/external/kerberos_ldap_group/kerberos_ldap_group.cc
index fc548da35d..5807134b1c 100644
--- a/src/acl/external/kerberos_ldap_group/kerberos_ldap_group.cc
+++ b/src/acl/external/kerberos_ldap_group/kerberos_ldap_group.cc
@@ -83,6 +83,7 @@ init_args(struct main_args *margs)
     margs->groups = NULL;
     margs->ndoms = NULL;
     margs->lservs = NULL;
+    margs->princ = NULL;
 }
 
 void clean_gd(struct gdstruct *gdsp);
@@ -178,6 +179,7 @@ clean_args(struct main_args *margs)
         clean_ls(margs->lservs);
         margs->lservs = NULL;
     }
+    safe_free(margs->princ);
 }
 
 void strup(char *s);
@@ -202,7 +204,7 @@ main(int argc, char *const argv[])
 
     init_args(&margs);
 
-    while (-1 != (opt = getopt(argc, argv, "diasng:D:N:S:u:U:t:T:p:l:b:m:h"))) {
+    while (-1 != (opt = getopt(argc, argv, "diasng:D:N:P:S:u:U:t:T:p:l:b:m:h"))) {
         switch (opt) {
         case 'd':
             debug_enabled = 1;
@@ -228,6 +230,9 @@ main(int argc, char *const argv[])
         case 'N':
             margs.nlist = xstrdup(optarg);
             break;
+        case 'P':
+            margs.princ = xstrdup(optarg);
+            break;
         case 'u':
             margs.luser = xstrdup(optarg);
             break;
@@ -259,7 +264,7 @@ main(int argc, char *const argv[])
             break;
         case 'h':
             fprintf(stderr, "Usage: \n");
-            fprintf(stderr, "squid_kerb_ldap [-d] [-i] -g group list [-D domain] [-N netbios domain map] [-s] [-u ldap user] [-p ldap user password] [-l ldap url] [-b ldap bind path] [-a] [-m max depth] [-h]\n");
+            fprintf(stderr, "squid_kerb_ldap [-d] [-i] -g group list [-D domain] [-N netbios domain map] [-P service principal name] [-s] [-u ldap user] [-p ldap user password] [-l ldap url] [-b ldap bind path] [-a] [-m max depth] [-h]\n");
             fprintf(stderr, "-d full debug\n");
             fprintf(stderr, "-i informational messages\n");
             fprintf(stderr, "-n do not use Kerberos to authenticate to AD. Requires -u , -p and -l option\n");
@@ -268,6 +273,7 @@ main(int argc, char *const argv[])
             fprintf(stderr, "-T group list (all in hex UTF-8 format - except separator @)\n");
             fprintf(stderr, "-D default domain\n");
             fprintf(stderr, "-N netbios to dns domain map\n");
+            fprintf(stderr, "-P service principal name to be used from keytab\n");
             fprintf(stderr, "-S ldap server to dns domain map\n");
             fprintf(stderr, "-u ldap user\n");
             fprintf(stderr, "-p ldap user password\n");
diff --git a/src/acl/external/kerberos_ldap_group/support.h b/src/acl/external/kerberos_ldap_group/support.h
index 14e9decacb..3bda9facef 100644
--- a/src/acl/external/kerberos_ldap_group/support.h
+++ b/src/acl/external/kerberos_ldap_group/support.h
@@ -110,6 +110,7 @@ struct main_args {
     struct gdstruct *groups;
     struct ndstruct *ndoms;
     struct lsstruct *lservs;
+    char *princ;
 };
 
 SQUIDCEXTERN int log_enabled;
@@ -181,7 +182,7 @@ struct kstruct {
     char* mem_ccache[MAX_DOMAINS];
     int ncache;
 };
-int krb5_create_cache(char *domain);
+int krb5_create_cache(char *domain, char* princ);
 void krb5_cleanup(void);
 #endif
 
diff --git a/src/acl/external/kerberos_ldap_group/support_krb5.cc b/src/acl/external/kerberos_ldap_group/support_krb5.cc
index e87bab8a1f..cf2d66d4d8 100644
--- a/src/acl/external/kerberos_ldap_group/support_krb5.cc
+++ b/src/acl/external/kerberos_ldap_group/support_krb5.cc
@@ -71,6 +71,21 @@ k5_error2(const char* msg, char* msg2, krb5_error_code code)
 }
 
 static void
+k5_debug(const char* msg, krb5_error_code code)
+{
+    const char *errmsg;
+    errmsg = krb5_get_error_message(kparam.context, code);
+    debug((char *) "%s| %s: DEBUG: %s : %s\n", LogTime(), PROGRAM, msg, errmsg);
+#if HAVE_KRB5_FREE_ERROR_MESSAGE
+    krb5_free_error_message(kparam.context, errmsg);
+#elif HAVE_KRB5_FREE_ERROR_STRING
+    krb5_free_error_string(kparam.context, (char *)errmsg);
+#else
+    xfree(errmsg);
+#endif
+}
+
+static void
 k5_error(const char* msg, krb5_error_code code)
 {
     k5_error2(msg, (char *)"", code);
@@ -80,7 +95,7 @@ k5_error(const char* msg, krb5_error_code code)
  * create Kerberos memory cache
  */
 int
-krb5_create_cache(char *domain)
+krb5_create_cache(char *domain,char *service_principal_name)
 {
 
     krb5_keytab keytab = NULL;
@@ -145,7 +160,7 @@ krb5_create_cache(char *domain)
         if (principal)
             krb5_free_principal(kparam.context, principal);
         principal = NULL;
-        k5_error("No default principal found in ccache",code);
+        k5_debug("No default principal found in ccache",code);
     } else {
         /*
          * Look for krbtgt and check if it is expired (or soon to be expired)
@@ -181,7 +196,7 @@ krb5_create_cache(char *domain)
                     debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
                     code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
                     if (code) {
-                        k5_error("Error  while resolving memory ccache",code);
+                        k5_error("Error while resolving memory ccache",code);
                         retval = 1;
                         goto cleanup;
                     }
@@ -234,7 +249,7 @@ krb5_create_cache(char *domain)
             creds = NULL;
             code2 = krb5_cc_end_seq_get(kparam.context, kparam.cc[ccindex], &ccursor);
             if (code2) {
-                k5_error("Error  while ending ccache scan",code2);
+                k5_error("Error while ending ccache scan",code2);
                 retval = 1;
                 goto cleanup;
             }
@@ -290,6 +305,11 @@ krb5_create_cache(char *domain)
                 } else {
                     debug((char *) "%s| %s: DEBUG: Found principal name: %s\n", LogTime(), PROGRAM, principal_name);
                     found = 1;
+                    if (service_principal_name != NULL && strcasecmp(principal_name,service_principal_name)) {
+                        debug((char *) "%s| %s: DEBUG: principal name does not match parameter: %s\n", LogTime(), PROGRAM, service_principal_name);
+                        safe_free(principal_name);
+                        found = 0;
+                    }
                 }
             }
 #if USE_HEIMDAL_KRB5 || ( HAVE_KRB5_KT_FREE_ENTRY && HAVE_DECL_KRB5_KT_FREE_ENTRY )
@@ -345,7 +365,7 @@ krb5_create_cache(char *domain)
                 }
                 code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal);
                 if (code) {
-                    k5_error("Error while initialising  memory caches",code);
+                    k5_error("Error while initialising cache",code);
                     safe_free(principal_name);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
@@ -387,7 +407,7 @@ krb5_create_cache(char *domain)
         /*
          * if no principal name found in keytab for domain use the prinipal name which can get a TGT
          */
-        if (!principal_name) {
+        if (!principal_name && !service_principal_name) {
             size_t i;
             debug((char *) "%s| %s: DEBUG: Did not find a principal in keytab for domain %s.\n", LogTime(), PROGRAM, domain);
             debug((char *) "%s| %s: DEBUG: Try to get principal of trusted domain.\n", LogTime(), PROGRAM);
diff --git a/src/acl/external/kerberos_ldap_group/support_ldap.cc b/src/acl/external/kerberos_ldap_group/support_ldap.cc
index 057b19d788..b7132fd910 100644
--- a/src/acl/external/kerberos_ldap_group/support_ldap.cc
+++ b/src/acl/external/kerberos_ldap_group/support_ldap.cc
@@ -1013,7 +1013,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                   "%s| %s: DEBUG: Kerberos is disabled. Use username/password with ldap url instead\n",
                   LogTime(), PROGRAM);
         } else {
-            kc = krb5_create_cache(domain);
+            kc = krb5_create_cache(domain,margs->princ);
             if (kc) {
                 error((char *)
                       "%s| %s: ERROR: Error during setup of Kerberos credential cache\n",
