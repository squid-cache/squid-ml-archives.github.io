<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Splicing a connection if server cert cannot be verified
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Splicing%20a%20connection%20if%20server%20cert%20cannot%20be%0A%20verified&In-Reply-To=%3CBY2PR03MB36452C552811D9EA7A09372D56F0%40BY2PR03MB364.namprd03.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001115.html">
   <LINK REL="Next"  HREF="001124.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Splicing a connection if server cert cannot be verified</H1>
    <B>Soren Madsen (DREIJER)</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Splicing%20a%20connection%20if%20server%20cert%20cannot%20be%0A%20verified&In-Reply-To=%3CBY2PR03MB36452C552811D9EA7A09372D56F0%40BY2PR03MB364.namprd03.prod.outlook.com%3E"
       TITLE="[squid-users] Splicing a connection if server cert cannot be verified">sdreijer at microsoft.com
       </A><BR>
    <I>Mon Dec 15 21:20:13 UTC 2014</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="001115.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
        <LI>Next message (by thread): <A HREF="001124.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1116">[ date ]</a>
              <a href="thread.html#1116">[ thread ]</a>
              <a href="subject.html#1116">[ subject ]</a>
              <a href="author.html#1116">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the quick reply, Amos.

&gt;<i> Offering SSLv3 from a server is suicide these days. Those sites should
</I>&gt;<i> be on the fast decline, or at very least shunned like plague victims.
</I>&gt;<i> Lookup POODLE if you dont know why already.
</I>
That's correct. That's why I don't want to bump such connections and instead fall back to splicing. In other words, if I can't trust the server, I want to get out of the way and defer the decision to the client.

&gt;<i> &gt; or self-signed certificates,
</I>&gt;<i> 
</I>&gt;<i> Nothing wrong with self-signed though. Much *more* secure than CA
</I>&gt;<i> validated certs when used in DANE protocol.
</I>
Yes, but Squid has no way of trusting a self-signed cert. When Squid mints a server cert on the fly and sends it to the client, the client won't have any idea that the cert was originally self-signed. Like the previous scenario, I'd want to step out of the way and defer the decision to the client.

&gt;<i> &gt; in which case I'd like to fall back to TLS passthrough mode and let
</I>&gt;<i> &gt; the client decide whether it wants to trust the server or not. In
</I>&gt;<i> &gt; other words, if Squid cannot successfully bump a connection, I
</I>&gt;<i> &gt; don't want to fail the connection, but rather step out of the way
</I>&gt;<i> &gt; and let the client decide what to do.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The ideal solution, I think, would be to optimistically attempt to
</I>&gt;<i> &gt; bump the connection, but if it fails due to e.g. a bad server cert,
</I>&gt;<i> &gt; a new connection can be established with the original client
</I>&gt;<i> &gt; hello.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I was hoping the new peek and splice functionality would be able
</I>&gt;<i> &gt; to help me in this regard:
</I>&gt;<i> &gt; <A HREF="http://wiki.squid-cache.org/Features/SslPeekAndSplice">http://wiki.squid-cache.org/Features/SslPeekAndSplice</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As far as I can tell, the 'stare' action is what I'm interested in
</I>&gt;<i> &gt; here although it appears it's not a focus of the current
</I>&gt;<i> &gt; implementation, and the 'peek' action has the following limitation
</I>&gt;<i> &gt; note about 'Peeking at the server often precludes bumping': &quot;We
</I>&gt;<i> &gt; could teach Squid to abandon the current server connection and then
</I>&gt;<i> &gt; bump a newly open one. This is something we do not want to do as it
</I>&gt;<i> &gt; is likely to create an even worse operational problems with Squids
</I>&gt;<i> &gt; being auto-blocked for opening and closing connections in vein.&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm confused about this. Couldn't Squid just cache the information
</I>&gt;<i> &gt; about whether it has previously refrained from bumping a
</I>&gt;<i> &gt; connection due to a bad server cert (or other errors) and only
</I>&gt;<i> &gt; check with the server once the cache expires? That should avoid
</I>&gt;<i> &gt; triggering any alarms on the server.
</I>&gt;<i> 
</I>&gt;<i> Happy eyeballs clients open multiple connections in parallel, causing
</I>&gt;<i> Squid to be seen opening just as many. Adding the above behaviour
</I>&gt;<i> would make the number of connections hammering the server multiply by
</I>&gt;<i> *at least* 2.
</I>
I don't think I see the big problem here. If you hit a web server with 10 connections, but Squid decides to splice the connection after all and therefore closes the connections and create 10 new ones, that's hardly going to cause any alarms to go off. After that point, Squid will cache the fact that connections to that hostname shouldn't be bumped and subsequent attempts at hitting that hostname (based on the SNI, for instance) won't be bumped again until the cache expires.

&gt;<i> 
</I>&gt;<i> Also, with modern HTTPS load balancers every since connection is
</I>&gt;<i> potentially going to a different real backend server, with different
</I>&gt;<i> TLS settings even if the domain, IP, and port details are exactly
</I>&gt;<i> identical. Things could also change with no notice as admin fix
</I>&gt;<i> transient problems.
</I>
Sure, and that's the point of the cache I mentioned above. If there happens to be a transient problem with the server, it's okay that Squid doesn't bump the connection for, say, an hour until it checks the host again. I see this as optimistic bumping, i.e. bump if you can but under no circumstances break the connectivity between the user and the server.

&gt;<i> If you are going to bypass bumping based on vague-ish criteria then
</I>&gt;<i> you might as well just not bump. That gets you away from all those
</I>&gt;<i> technical probems, and a host of legal issues as well.
</I>
I don't follow what you're saying here. How is looking at a server cert and determining that Squid cannot trust it &quot;vague-ish&quot; criteria? And a host of legal issues?

&gt;<i> AIUI, the basic problem that &quot;precludes bumping&quot; is that in order to
</I>&gt;<i> peek at the serverHello some clientHello has to already have been
</I>&gt;<i> sent. Squid is already locked into using the features advertised in
</I>&gt;<i> that clientHello or dying - with no middle ground. Most times the
</I>&gt;<i> client and Squid do not actually have identical capabilities so
</I>&gt;<i> peeking the serverHello then either bump or splice actions will break
</I>&gt;<i> depending on which clientHello Squid sent.
</I>
I don't see why that is a problem if you just recreate the connection to the server. That is, you first try bumping the connection by sending a new clientHello to the server, and if the server cert cannot be verified, a new connection is established and the original clientHello is sent to the server.

&gt;<i> &gt; Maybe I'm misreading the document. I was hoping somebody here on
</I>&gt;<i> &gt; the list could explain to me if I can achieve the above behavior.
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>&gt;<i> I suspect you actually need the certificate mimic behaviour. Where
</I>&gt;<i> Squid generates a server cert as close as possible to the original,
</I>&gt;<i> including errors so the client can decide how to handle them.
</I>
How would you propose supporting self-signed certs in this scenario? 
This also means that in order to allow the client to use SSLv3, I'm going to have to allow Squid to bump SSLv3 connections, which I'm not keen on for the reason you mentioned yourself above.

Thanks,
Soren
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="001115.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
	<LI>Next message (by thread): <A HREF="001124.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1116">[ date ]</a>
              <a href="thread.html#1116">[ thread ]</a>
              <a href="subject.html#1116">[ subject ]</a>
              <a href="author.html#1116">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
