<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Splicing a connection if server cert cannot be verified
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Splicing%20a%20connection%20if%20server%20cert%20cannot%20be%0A%20verified&In-Reply-To=%3C54903FC7.9020905%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001116.html">
   <LINK REL="Next"  HREF="001139.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Splicing a connection if server cert cannot be verified</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Splicing%20a%20connection%20if%20server%20cert%20cannot%20be%0A%20verified&In-Reply-To=%3C54903FC7.9020905%40treenet.co.nz%3E"
       TITLE="[squid-users] Splicing a connection if server cert cannot be verified">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Dec 16 14:20:55 UTC 2014</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="001116.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
        <LI>Next message (by thread): <A HREF="001139.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1124">[ date ]</a>
              <a href="thread.html#1124">[ thread ]</a>
              <a href="subject.html#1124">[ subject ]</a>
              <a href="author.html#1124">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 16/12/2014 10:20 a.m., Soren Madsen (DREIJER) wrote:
&gt;<i> Thanks for the quick reply, Amos.
</I>&gt;<i> 
</I>&gt;&gt;<i> Offering SSLv3 from a server is suicide these days. Those sites
</I>&gt;&gt;<i> should be on the fast decline, or at very least shunned like
</I>&gt;&gt;<i> plague victims. Lookup POODLE if you dont know why already.
</I>&gt;<i> 
</I>&gt;<i> That's correct. That's why I don't want to bump such connections
</I>&gt;<i> and instead fall back to splicing. In other words, if I can't trust
</I>&gt;<i> the server, I want to get out of the way and defer the decision to
</I>&gt;<i> the client.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> or self-signed certificates,
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Nothing wrong with self-signed though. Much *more* secure than
</I>&gt;&gt;<i> CA validated certs when used in DANE protocol.
</I>&gt;<i> 
</I>&gt;<i> Yes, but Squid has no way of trusting a self-signed cert. When
</I>&gt;<i> Squid mints a server cert on the fly and sends it to the client,
</I>&gt;<i> the client won't have any idea that the cert was originally
</I>&gt;<i> self-signed. Like the previous scenario, I'd want to step out of
</I>&gt;<i> the way and defer the decision to the client.
</I>&gt;<i> 
</I>
The global list of CAs which non-self-signed certs validate against is
explicitly loaded into the SSL library. It is not a built-in list.

All you have to do to trust a &quot;self-signed&quot; cert is add the CA signing
it to your trusted set.


&gt;&gt;&gt;<i> in which case I'd like to fall back to TLS passthrough mode and
</I>&gt;&gt;&gt;<i> let the client decide whether it wants to trust the server or
</I>&gt;&gt;&gt;<i> not. In other words, if Squid cannot successfully bump a
</I>&gt;&gt;&gt;<i> connection, I don't want to fail the connection, but rather
</I>&gt;&gt;&gt;<i> step out of the way and let the client decide what to do.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> The ideal solution, I think, would be to optimistically attempt
</I>&gt;&gt;&gt;<i> to bump the connection, but if it fails due to e.g. a bad
</I>&gt;&gt;&gt;<i> server cert, a new connection can be established with the
</I>&gt;&gt;&gt;<i> original client hello.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> I was hoping the new peek and splice functionality would be
</I>&gt;&gt;&gt;<i> able to help me in this regard: 
</I>&gt;&gt;&gt;<i> <A HREF="http://wiki.squid-cache.org/Features/SslPeekAndSplice">http://wiki.squid-cache.org/Features/SslPeekAndSplice</A>
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> As far as I can tell, the 'stare' action is what I'm interested
</I>&gt;&gt;&gt;<i> in here although it appears it's not a focus of the current 
</I>&gt;&gt;&gt;<i> implementation, and the 'peek' action has the following
</I>&gt;&gt;&gt;<i> limitation note about 'Peeking at the server often precludes
</I>&gt;&gt;&gt;<i> bumping': &quot;We could teach Squid to abandon the current server
</I>&gt;&gt;&gt;<i> connection and then bump a newly open one. This is something we
</I>&gt;&gt;&gt;<i> do not want to do as it is likely to create an even worse
</I>&gt;&gt;&gt;<i> operational problems with Squids being auto-blocked for opening
</I>&gt;&gt;&gt;<i> and closing connections in vein.&quot;
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> I'm confused about this. Couldn't Squid just cache the
</I>&gt;&gt;&gt;<i> information about whether it has previously refrained from
</I>&gt;&gt;&gt;<i> bumping a connection due to a bad server cert (or other errors)
</I>&gt;&gt;&gt;<i> and only check with the server once the cache expires? That
</I>&gt;&gt;&gt;<i> should avoid triggering any alarms on the server.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Happy eyeballs clients open multiple connections in parallel,
</I>&gt;&gt;<i> causing Squid to be seen opening just as many. Adding the above
</I>&gt;&gt;<i> behaviour would make the number of connections hammering the
</I>&gt;&gt;<i> server multiply by *at least* 2.
</I>&gt;<i> 
</I>&gt;<i> I don't think I see the big problem here. If you hit a web server
</I>&gt;<i> with 10 connections, but Squid decides to splice the connection
</I>&gt;<i> after all and therefore closes the connections and create 10 new
</I>&gt;<i> ones, that's hardly going to cause any alarms to go off. After that
</I>&gt;<i> point, Squid will cache the fact that connections to that hostname
</I>&gt;<i> shouldn't be bumped and subsequent attempts at hitting that
</I>&gt;<i> hostname (based on the SNI, for instance) won't be bumped again
</I>&gt;<i> until the cache expires.
</I>&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Also, with modern HTTPS load balancers every since connection is 
</I>&gt;&gt;<i> potentially going to a different real backend server, with
</I>&gt;&gt;<i> different TLS settings even if the domain, IP, and port details
</I>&gt;&gt;<i> are exactly identical. Things could also change with no notice as
</I>&gt;&gt;<i> admin fix transient problems.
</I>&gt;<i> 
</I>&gt;<i> Sure, and that's the point of the cache I mentioned above. If there
</I>&gt;<i> happens to be a transient problem with the server, it's okay that
</I>&gt;<i> Squid doesn't bump the connection for, say, an hour until it checks
</I>&gt;<i> the host again. I see this as optimistic bumping, i.e. bump if you
</I>&gt;<i> can but under no circumstances break the connectivity between the
</I>&gt;<i> user and the server.
</I>&gt;<i> 
</I>&gt;&gt;<i> If you are going to bypass bumping based on vague-ish criteria
</I>&gt;&gt;<i> then you might as well just not bump. That gets you away from all
</I>&gt;&gt;<i> those technical probems, and a host of legal issues as well.
</I>&gt;<i> 
</I>&gt;<i> I don't follow what you're saying here. How is looking at a server
</I>&gt;<i> cert and determining that Squid cannot trust it &quot;vague-ish&quot;
</I>&gt;<i> criteria? And a host of legal issues?
</I>&gt;<i> 
</I>
The vagueness is in how long the cache will be presenting accurate
representation of the cert state. Given the LB situation and other
intermediaries like Squid generatign certs per-connection there is no
reliability on it being accurate from one use to the next.


&gt;&gt;<i> AIUI, the basic problem that &quot;precludes bumping&quot; is that in order
</I>&gt;&gt;<i> to peek at the serverHello some clientHello has to already have
</I>&gt;&gt;<i> been sent. Squid is already locked into using the features
</I>&gt;&gt;<i> advertised in that clientHello or dying - with no middle ground.
</I>&gt;&gt;<i> Most times the client and Squid do not actually have identical
</I>&gt;&gt;<i> capabilities so peeking the serverHello then either bump or
</I>&gt;&gt;<i> splice actions will break depending on which clientHello Squid
</I>&gt;&gt;<i> sent.
</I>&gt;<i> 
</I>&gt;<i> I don't see why that is a problem if you just recreate the
</I>&gt;<i> connection to the server. That is, you first try bumping the
</I>&gt;<i> connection by sending a new clientHello to the server, and if the
</I>&gt;<i> server cert cannot be verified, a new connection is established and
</I>&gt;<i> the original clientHello is sent to the server.
</I>&gt;<i> 
</I>
&quot;just&quot; recreating the connection to the server means discarding the
old one. Which is not anywhere near as nice a proposition once you
look beyond the single proxy.

The details, you can skip if you want to avoid...

* Each aborted connection means 15 minutes TCP TIME_WAIT delay before
that TCP socket can be re-used.

* TCP/IP limits software to 63K sockets per IP address (64K total with
1024 reserved).

Using multiple outbound connections to discover some behaviour is what
the browser &quot;happy eyeballs&quot; algoithm is all about. They are just
looking for connectino handshake speed rather than cert properties.

- - Browsers are operating on rate of 10's to hundreds of single
requests per minute. With all 64K per-IP sockets on that machine
dedicated to the one end user.

- - Proxies are individually dealing with requests on the rate of 10's
or 100's of thousand requests per minute. Sharing socets between
hundreds or thousands of end-users.

At that speed 64K sockets per IP address are consumed very quickly
already. Squid is limited to a very few over 10K new
connections/minute per IP address on the machine. We get away with
higher rates by having HITs, collapsed-forwarding and by multiplexing
requests onto server connections.
 =&gt; multiplex is the biggest gainer which is not possible with HTTPS
traffic, despite bumping.

Then you have to consider the Internet-wide scale which all these
things are operating on. Internet is not a simple client-&gt;server or
even client-&gt;proxy-&gt;server connection. The reality is that the general
architecture is more like: users browser, ISP load balancer, ISP
cache, content provider CDN router/load balancer, content provider CDN
cache, origin server load balancer and finally origin server. approx 6
&quot;hops&quot; that each HTTP connnection goes through. Sometimes worse,
sometimes better. But the common situation for users is being on a big
ISP visiting popular so called &quot;Big content&quot; website.

What you are asking is that we effectively do happy-eyeballs for
outbound server connections in proxies. With each of the above hops
the number of TCP sockets consumed doubles, and all but 1 in that hop
will be discarded by the end of the handshake process.


* Browser people love their happy-eyeballs and prefetch algorithms. So
it starts everything by opening 2 sockets to see which connects
fastest and only using that one. (and probably not just 2, but 4 or 8
but I shall simplify).

By the end of the doubling at each proxy, (2^6) -&gt; 64 sockets per
client connection hitting the origin server in worst-case. Thats
limiting it to serving only 1000 end users every 15 minutes. Or
serving just 1 *single* HTTP request per second.

Sites like Facebook load several hundreds of objects per page. Imagine
how badly the site would be if it took a few minutes to load after
each click.

Or how much the hardware they would have to purchase would cost at a
rate of 2-3 whole servers per user (at 100's million of users) for a
half-decent response rate.


I know those last two conclusions are OTT worst-case extreme of the
problem. However, the main point is that all that stands between
worst-case from becoming common-case is how much we *avoid* joining in
on the browser happy-eyeballs behaviour you are suggesting.
 And remember that I got to those nasty numbers quickly despite
conservatively assuming the browser only oppened 2 connections at the
start.


&gt;&gt;&gt;<i> Maybe I'm misreading the document. I was hoping somebody here
</I>&gt;&gt;&gt;<i> on the list could explain to me if I can achieve the above
</I>&gt;&gt;&gt;<i> behavior.
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I suspect you actually need the certificate mimic behaviour.
</I>&gt;&gt;<i> Where Squid generates a server cert as close as possible to the
</I>&gt;&gt;<i> original, including errors so the client can decide how to handle
</I>&gt;&gt;<i> them.
</I>&gt;<i> 
</I>&gt;<i> How would you propose supporting self-signed certs in this
</I>&gt;<i> scenario?
</I>
A truely self-signed cert is a CA cert and must never be used to
encrypt a connection directly. What is seen on the wire and called
&quot;self-signed&quot; is actually a cert signed by some CA (the servers admin)
who is not in your trusted CA set.

So...

... if a lot of your traffic comes from a few sites you can add those
sites CA cert to your proxies trusted CA set.
 - maybe check and see if the CA-certificates set used by your proxy
machines SSL library is up to date. If that is outdated a bunch of
those self-signed claims may be false-nagatives.

... or you can replace the helper program Squid uses to validate the
certs with one that accepts self-signed.

I am interested in getting a helper that does TLSA/DANE validation. A
lot of sites are starting to use TLSA cert instead of the global
corporate CAs.


&gt;<i> This also means that in order to allow the client to use SSLv3, I'm
</I>&gt;<i> going to have to allow Squid to bump SSLv3 connections, which I'm
</I>&gt;<i> not keen on for the reason you mentioned yourself above.
</I>&gt;<i> 
</I>
Nod.

It is a little bit safer to allow Squid to use SSLv3 to servers which
are still broken, than to allow clients to SSLv3 to Squid. At least
half of the connectivity you have soemthign to do with becomes
trustworthy even though the overall end-2-end security is no better (yet).

Amos
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUkD/HAAoJELJo5wb/XPRj0bEH/jMKe7M/CJPMUgUDlIkdzJyU
zWn8mnv80cpoz2TdFd71vcGFT3wDLLlOleGLu6RyFWI3ikGHcAa1jdeAOJhbBk5v
dQlx7nWYiIV5rkFYHYgkl2lNBFdI9ETX4SakPWrLksf/6XGvascP8mNNDI8987XB
Vk2HXSUnA9dRiWUvmc4bOc4inMSqdjwoFR8uKQmsG6PQftNGrmrtfUcqi3fLXwMU
k8RpIPDiczCf2FzjXMk8VbfnTHEGtodDGKtjmRQk0zrc7NeO5LmyGgCbficqsmWM
PqcSKVi6pI5Rl/CrWAfgZiSlrlKnShItA5uZOIxHroLYo0gslW0BvAwT86xX/fo=
=Gwkq
-----END PGP SIGNATURE-----

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="001116.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
	<LI>Next message (by thread): <A HREF="001139.html">[squid-users] Splicing a connection if server cert cannot be verified
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1124">[ date ]</a>
              <a href="thread.html#1124">[ thread ]</a>
              <a href="subject.html#1124">[ subject ]</a>
              <a href="author.html#1124">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
