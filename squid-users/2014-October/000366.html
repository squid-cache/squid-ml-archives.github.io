<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] peek and splice and splice()
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20peek%20and%20splice%20and%20splice%28%29&In-Reply-To=%3C4fe752550fe6475bb4ff55ec7c3849ae%40HKNPR04MB0388.apcprd04.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000364.html">
   <LINK REL="Next"  HREF="000363.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] peek and splice and splice()</H1>
    <B>James Harper</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20peek%20and%20splice%20and%20splice%28%29&In-Reply-To=%3C4fe752550fe6475bb4ff55ec7c3849ae%40HKNPR04MB0388.apcprd04.prod.outlook.com%3E"
       TITLE="[squid-users] peek and splice and splice()">james at ejbdigital.com.au
       </A><BR>
    <I>Fri Oct 17 10:27:13 UTC 2014</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000364.html">[squid-users] peek and splice and splice()
</A></li>
        <LI>Next message (by thread): <A HREF="000363.html">[squid-users] acl time not work
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#366">[ date ]</a>
              <a href="thread.html#366">[ thread ]</a>
              <a href="subject.html#366">[ subject ]</a>
              <a href="author.html#366">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> 
</I>&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;<i> Hash: SHA1
</I>&gt;<i> 
</I>&gt;<i> On 17/10/2014 9:47 p.m., James Harper wrote:
</I>&gt;<i> &gt; Just reading up on this, the Feature page
</I>&gt;<i> &gt; <A HREF="http://wiki.squid-cache.org/Features/SslPeekAndSplice">http://wiki.squid-cache.org/Features/SslPeekAndSplice</A> says:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &quot;... with Squid shoveling TCP bytes back and forth without any
</I>&gt;<i> &gt; decryption&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I can't see that squid actually uses the splice() system call, so
</I>&gt;<i> &gt; that would mean squid would actually read the data into userspace
</I>&gt;<i> &gt; then write it out again, is that right? I assume once this happens
</I>&gt;<i> &gt; it's the same code as a CONNECT.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; What if there was a way to actually splice the two TCP connections
</I>&gt;<i> &gt; at the kernel level so that Squid didn't actually need to be
</I>&gt;<i> &gt; involved anymore, except when the connection closes to do the
</I>&gt;<i> &gt; accounting? There appear to be a few historic attempts to implement
</I>&gt;<i> &gt; this in the Linux kernel but I suspect they haven't been
</I>&gt;<i> &gt; maintained.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; And would this be a worthwhile optimisation anyway or is shunting
</I>&gt;<i> &gt; data not a significant part of squid load?
</I>&gt;<i> 
</I>&gt;<i> There is sendfile() IIUIC. Probably worthwhile, but to do it we have
</I>&gt;<i> to first drop the delay_pools feature which relies on each byte being
</I>&gt;<i> accounted as it is delivered.
</I>&gt;<i> 
</I>
splice() would be a reasonable compromise then - it involves squid servicing the connection each time data is available, but avoids the read-into-userspace-buffer/write-from-userspace-buffer.

&gt;<i> For now I am working on it from a publicity standpoint, encouraging
</I>&gt;<i> people to go to the more efficient QoS controls outside of Squid. So
</I>&gt;<i> the popularity of delay pools drops down to a level we can start to
</I>&gt;<i> seriously consider alternatives to the current tunnel code.
</I>&gt;<i> 
</I>
Yes Linux and BSD both have very good QoS, but you can only see half the connection (client&lt;-&gt;squid or squid&lt;-&gt;server) at that level so you can't do it for all cases.

It would be awesome if squid could intercept connections without breaking them. You can kind of do it with the ULOG/NFQUEUE target in netfilter, but you get fed packets, not streams, so you'd have to implement your own TCP stack (so... no). Such a thing would allow better outcomes in the &quot;can't connect to server&quot; case though.

An ideal interface would allow you to be notified of an incoming connection, reject it (icmp port unreachable, reset, etc) if you can determine that the destination is down, accept it if you can determine that the destination is up, do what you need to do, then just give it back to the kernel if no more processing is required, then be notified when the connection has finished for accounting.

James

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000364.html">[squid-users] peek and splice and splice()
</A></li>
	<LI>Next message (by thread): <A HREF="000363.html">[squid-users] acl time not work
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#366">[ date ]</a>
              <a href="thread.html#366">[ thread ]</a>
              <a href="subject.html#366">[ subject ]</a>
              <a href="author.html#366">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
