<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] HTTPS Filtering by Certificate Subject Name
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20HTTPS%20Filtering%20by%20Certificate%20Subject%20Name&In-Reply-To=%3C6b35d4eebe3840039cd706f4265a72d4%40HKNPR04MB0388.apcprd04.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000376.html">
   <LINK REL="Next"  HREF="000379.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] HTTPS Filtering by Certificate Subject Name</H1>
    <B>James Harper</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20HTTPS%20Filtering%20by%20Certificate%20Subject%20Name&In-Reply-To=%3C6b35d4eebe3840039cd706f4265a72d4%40HKNPR04MB0388.apcprd04.prod.outlook.com%3E"
       TITLE="[squid-users] HTTPS Filtering by Certificate Subject Name">james at ejbdigital.com.au
       </A><BR>
    <I>Sat Oct 18 07:22:14 UTC 2014</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000376.html">[squid-users] HTTPS Filtering by Certificate Subject Name
</A></li>
        <LI>Next message (by thread): <A HREF="000379.html">[squid-users] windowsupdate and ssl_bump
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#377">[ date ]</a>
              <a href="thread.html#377">[ thread ]</a>
              <a href="subject.html#377">[ subject ]</a>
              <a href="author.html#377">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> 
</I>&gt;<i> It looks like this question has come up before, but I'm hoping to get some
</I>&gt;<i> further details on it.
</I>&gt;<i> 
</I>&gt;<i> I've used a couple of firewalls (Watchguard &amp; Fortigate) that allow me to do a
</I>&gt;<i> level of HTTPS site filtering without decryption. I believe that it works by
</I>&gt;<i> requesting and examining the certificate sent from the remote server. If the
</I>&gt;<i> subject name or subject alternate names on the certificate match a whitelist
</I>&gt;<i> of domains that we have specified then access to the site is allowed. As far as
</I>&gt;<i> I know, it does not require decrypting the SSL connection and I'm positive
</I>&gt;<i> that it doesn't return self generated certificates.
</I>&gt;<i> 
</I>&gt;<i> It would not be very effective for someone trying to use Squid for blocking
</I>&gt;<i> end users access to every site on the Internet. But, it works great for our use
</I>&gt;<i> case where we want to allow our servers to only access a handful of sites.
</I>&gt;<i> 
</I>&gt;<i> From everything I've read, it looks like the only option is for Squid to decrypt
</I>&gt;<i> the connection. Is there a particular reason why this feature could not be
</I>&gt;<i> implemented in Squid if it's available in these other devices? Or if it is
</I>&gt;<i> available, could I get some direction.
</I>&gt;<i> 
</I>
I assume you are doing this for transparent proxying, otherwise you already have the hostname the user is trying to access, which is better than the cert name.

You could wait for this <A HREF="http://wiki.squid-cache.org/Features/SslPeekAndSplice">http://wiki.squid-cache.org/Features/SslPeekAndSplice</A> which might eventually be able to do what you want.

In the meantime, you could try using an external acl. I didn't have a lot of luck... it works but has some limitations. Basically I threw together some php (see end of email), then used the following configuration:

# actual cert doesn't matter as it isn't used, but squid insists on it being there
https_port 0.0.0.0:33129 intercept name=transparentssl cert=/etc/squid/dummy.pem ssl-bump
...
ssl_bump none all
...
external_acl_type check_ssl %DST %PORT /usr/lib/squid3/check_ssl_cert_name
...
acl ssl_bad external check_ssl facebook.com
...
http_access deny transproxyssl ssl_bad
deny_info TCP_RESET transproxyssl

That's blacklist, not whitelist, but easy enough to invert. The problem I had is that I couldn't find a way to specify multiple 'acl ssl_bad external ...' lines, so you'd need a different acl + http_access for every certificate name you wanted to check against.

You'll find cases that will cause you trouble though, eg the certificate for &quot;google.com&quot; is also for &quot;youtube.com&quot;, so you can't allow one without allowing the other.

About the code - I basically just threw it together using a few examples of ssl cert identification that google found for me. I don't sanitise any input. It almost certainly leaks memory and doesn't handle error conditions well, or at all. And the actual comparison to the value being tested is very basic. And I make the assumption that the certificate has a san, and that the cn is in the san list, which isn't always correct. Hopefully you will derive some inspiration from it though. One additional thing it could do is log the cn to the logfile - append &quot;log=$cn&quot; to the OK or ERR output, then use %ea (I think) in the squid log directive to log that value. Also PHP is probably a poor choice of language - I don't really know PHP it just happened to be the language my google search returned the best examples in.

I think squid caches the result of the external acl so performance shouldn't be too bad. If squid didn't cache the result you'd probably need to build some caching yourself otherwise it would do a callout every time.

James

#!/usr/bin/php
&lt;?
stream_set_timeout(STDIN, -1);
while (!feof(STDIN)) {
  $line = trim(fgets(STDIN));
  if (substr_count($line, ' ') &lt; 1) {
    continue;
  }
  $params = explode(' ', $line);
  $host = $params[0];
  $port = $params[1];
  $test = $params[2];

  $g = stream_context_create (array(&quot;ssl&quot; =&gt; array(&quot;capture_peer_cert&quot; =&gt; true)));
  $r = stream_socket_client(&quot;<A HREF="ssl://$host:$port">ssl://$host:$port</A>&quot;, $errno, $errstr, 30, STREAM_CLIENT_CONNECT, $g);
  $cont = stream_context_get_params($r);
  $cert = openssl_x509_parse($cont[&quot;options&quot;][&quot;ssl&quot;][&quot;peer_certificate&quot;]);
  $cn = $cert[&quot;subject&quot;][&quot;CN&quot;];
  $san = $cert[&quot;extensions&quot;][&quot;subjectAltName&quot;];
  $match = false;
  foreach (explode(', ', $san) as $name) {
    if (substr($name, -strlen($test)) == $test) {
      $match = true;
      break;
    }
  }
  if ($match) {
    fwrite(STDOUT, &quot;OK\n&quot;);
  } else {
    fwrite(STDOUT, &quot;ERR\n&quot;);
  }
}
?&gt;

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000376.html">[squid-users] HTTPS Filtering by Certificate Subject Name
</A></li>
	<LI>Next message (by thread): <A HREF="000379.html">[squid-users] windowsupdate and ssl_bump
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#377">[ date ]</a>
              <a href="thread.html#377">[ thread ]</a>
              <a href="subject.html#377">[ subject ]</a>
              <a href="author.html#377">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
