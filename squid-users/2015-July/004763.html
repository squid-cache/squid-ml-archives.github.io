<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] SIGTERM SIGKILL causes issues with squid shutdown during reboot
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20SIGTERM%20SIGKILL%20causes%20issues%20with%20squid%20shutdown%0A%20during%20reboot&In-Reply-To=%3CCANLNtGTTKV%2BcYDpUU4%2BkAs41SC1DdtYGkPHaP76vNwb1TQF7qg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004752.html">
   <LINK REL="Next"  HREF="004726.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] SIGTERM SIGKILL causes issues with squid shutdown during reboot</H1>
    <B>Stanford Prescott</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20SIGTERM%20SIGKILL%20causes%20issues%20with%20squid%20shutdown%0A%20during%20reboot&In-Reply-To=%3CCANLNtGTTKV%2BcYDpUU4%2BkAs41SC1DdtYGkPHaP76vNwb1TQF7qg%40mail.gmail.com%3E"
       TITLE="[squid-users] SIGTERM SIGKILL causes issues with squid shutdown during reboot">stan.prescott at gmail.com
       </A><BR>
    <I>Fri Jul 24 15:23:15 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="004752.html">[squid-users] SIGTERM SIGKILL causes issues with squid shutdown during reboot
</A></li>
        <LI>Next message (by thread): <A HREF="004726.html">[squid-users] error windbind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4763">[ date ]</a>
              <a href="thread.html#4763">[ thread ]</a>
              <a href="subject.html#4763">[ subject ]</a>
              <a href="author.html#4763">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks, Amos. That was very helpful. Smoothwall Express does not and never
has used systemd, precisely because of the reasons you mention. It does use
udev and we are considering bumping to eudev, but that is a fairly large
change, but likely worth it.

We have some things to think about now with possibly redesigning the system
shutdown.

Regards.

Stan


On Fri, Jul 24, 2015 at 8:10 AM, Amos Jeffries &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid3 at treenet.co.nz</A>&gt; wrote:

&gt;<i> Response inline.
</I>&gt;<i>
</I>&gt;<i> On 24/07/2015 8:21 a.m., Stanford Prescott wrote:
</I>&gt;<i> &gt; After bumping Squid from 3.4.x to 3.5.x in our implementation of Squid in
</I>&gt;<i> &gt; the Smoothwall Express v3.1 firewall distro we have begun to have
</I>&gt;<i> &gt; complaints from our users about &quot;erratic behavior&quot; of Squid shutting down
</I>&gt;<i> &gt; during reboots or network drops causing reboots.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It appears that squid (v3.5.[5-6]) does not respond well to SIGTERM
</I>&gt;<i> during
</I>&gt;<i> &gt; system shutdown; the cache index almost invariably needs to be rebuilt on
</I>&gt;<i> &gt; next boot. It is suggested that we use squid to shut squid down. While
</I>&gt;<i> &gt; using squid to stop the squid daemon is very doable, this requirement
</I>&gt;<i> runs
</I>&gt;<i> &gt; contrary to the longstanding, traditional UNIX method of &quot;SIGTERM, pause,
</I>&gt;<i> &gt; SIGKILL&quot;.
</I>&gt;<i>
</I>&gt;<i> Squid is designed to operate in UNIX style. It contains its own daemon
</I>&gt;<i> manager, and a worker process.
</I>&gt;<i>
</I>&gt;<i> When SIGTERM is received by the manager process, it relays that to the
</I>&gt;<i> worker which begins shutdown immediately but with shutdown_lifetime
</I>&gt;<i> grace period for active clients to finish. A second SIGTERM will act
</I>&gt;<i> like shutdown_lifetime having expired, everything gets closed immediately.
</I>&gt;<i>
</I>&gt;<i> SIGKILL causes the OS init system to erase the Squid processes from
</I>&gt;<i> system memory, aborts all the open sockets and disk I/O, etc. The
</I>&gt;<i> nuclear option as some often called it.
</I>&gt;<i>
</I>&gt;<i> This causes issues with systemd, openrc, or upstart where the init
</I>&gt;<i> system insists on being a daemon manager itself. IIRC there was an
</I>&gt;<i> excellent tutorial somewhere (by DJB?) that explained in great detail
</I>&gt;<i> why having a daemon manager to operate other daemon managers was a
</I>&gt;<i> terrible idea. Squid hits pretty much all the relevant nasty side
</I>&gt;<i> effects as each piece of the system makes bad assumptions or gets
</I>&gt;<i> confused about other bits activities.
</I>&gt;<i>
</I>&gt;<i> Meanwhile if just left alone the worker is still trying to gracefully
</I>&gt;<i> close client transactions for shutdown_lifetime (30sec default). Then
</I>&gt;<i> abort those and save the final cache index to a new swap.state file on
</I>&gt;<i> disk.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; During normal system operation, squid *ought* to be able to take as much
</I>&gt;<i> &gt; time as it wants to shut down. But it still shouldn't take more than
</I>&gt;<i> 10-20
</I>&gt;<i> &gt; seconds; 'shutdown' is a command, not a request to be honored at squid's
</I>&gt;<i> &gt; leisure. After all, the CPU could be on fire....
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This raises a few questions that are intended to foster fresh discussion,
</I>&gt;<i> &gt; not to re-hash old arguments. They are really more rhetorical in nature;
</I>&gt;<i> &gt; the goal is to find the root cause of the problem.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    - Why do these latest versions of Squid 3 behave oddly in this
</I>&gt;<i> respect?
</I>&gt;<i>
</I>&gt;<i> systemd is becoming popular. See above. Impatience and incorrect init
</I>&gt;<i> scripts using SIGKIL instead of SIGTERM does seem to be the main pathway
</I>&gt;<i> to having issues.
</I>&gt;<i>
</I>&gt;<i> Squid-3 has become a SMP multi-process thing. Which increases the number
</I>&gt;<i> of workers, and things they are still doing during shtutdown.
</I>&gt;<i>
</I>&gt;<i> Squid-3.1 &amp; 3.2 added various checksums to swap.state format protecting
</I>&gt;<i> against file corruption propigating into the memory index of next
</I>&gt;<i> started Squid process.
</I>&gt;<i>
</I>&gt;<i> &gt;    - What is it about shutting squid down that corrupts the cache index?
</I>&gt;<i>
</I>&gt;<i> &quot;corruption&quot; in the cache index means the swap.state file for each cache
</I>&gt;<i> has not been completely written. On next load the file checksum does not
</I>&gt;<i> match the contents checksum. So reverts to a relatively slow scan of the
</I>&gt;<i> disk to see what is there.
</I>&gt;<i>
</I>&gt;<i> SIGKILL being used during the time that index is being written to disk
</I>&gt;<i> FD will cause it nearly 100% of the time. Being used before old
</I>&gt;<i> swap.state is replaced will lead to a lot of SWAPFAIL as objects on disk
</I>&gt;<i> today dont match what was on disk when Squid restarted a week ago.
</I>&gt;<i>
</I>&gt;<i> What corruption happens also varies between disk controllers. Some
</I>&gt;<i> controllers complete already scheduled writes. Some drop them. SIGKILL
</I>&gt;<i> may be relevant in that decision too. The ones that complete all
</I>&gt;<i> scheduled writes and close the file hit corruption less often, or less
</I>&gt;<i> badly.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Does it take more than a few seconds to write the index to disk?
</I>&gt;<i>
</I>&gt;<i> No. But it can take days for active clients to finish off long-polling
</I>&gt;<i> HTTP requests or CONNECT tunnels. shutdown_lifetime is what they are
</I>&gt;<i> allowed. IME, Squid workers usually completely exit within 5 seconds of
</I>&gt;<i> that grace period being over. It takes under a ms to close a socket, but
</I>&gt;<i> many tens of thousands of sockets may be open on a busy proxy.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Does squid use the very slow 'writethrough' method instead of
</I>&gt;<i> trusting
</I>&gt;<i> &gt;    the Linux disk cache to properly save the cache?
</I>&gt;<i>
</I>&gt;<i> Squid is generating new content and writing it to a file with write(2)
</I>&gt;<i> API. That content is anything up to 68MB in size *per cache_dir*. How
</I>&gt;<i> fast can your disk save that much data when its passed in ~100 byte IO
</I>&gt;<i> chunks?
</I>&gt;<i>  Whatever OS filesystem does to optimize I/O happens on top of that
</I>&gt;<i> process-level activity.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As mentioned above SIGKILL also does not shutdown the process (that
</I>&gt;<i> would be SIGTERM). Just drops it all on the floor. Using SIGKILL on a
</I>&gt;<i> process currently writing to disk has varying results from the disk
</I>&gt;<i> driver layers - usually not good.
</I>&gt;<i>
</I>&gt;<i> SIGTERM will almost guarantee the files complete writing and things get
</I>&gt;<i> gracefully resolved.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If you haven't guessed already IMO you should at worst use SIGTERM twice
</I>&gt;<i> on Squid instead of SIGKILL even once. If Squid is actually operational
</I>&gt;<i> a second SIGTERM will have the same effect as shutdown_lifetime having
</I>&gt;<i> finished early.
</I>&gt;<i>
</I>&gt;<i> Sadly systemd and init scripts can be rather friendly with SIGKILL.
</I>&gt;<i> Which can be problematic.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Should squid write the cache index to disk more often?
</I>&gt;<i>
</I>&gt;<i> The cache index is extremely volatile. Every single request through it
</I>&gt;<i> adds or removes an entry. Which is a lot of disk overhead on a very busy
</I>&gt;<i> proxy.
</I>&gt;<i>
</I>&gt;<i> The compromise is to write it only once on shutdown/restart when all
</I>&gt;<i> updates have been finished. Or on &quot;-k rotate&quot; (SIGHUP) when explicitly
</I>&gt;<i> asked to auto-save all state for log file rotations.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Should squid track its own 'dirty pages' in its in-core index to
</I>&gt;<i> &gt;    reduce the time it takes to write the index?
</I>&gt;<i>
</I>&gt;<i> There is not much to track. The &quot;pages&quot; as it were are little marker
</I>&gt;<i> records a few hundred bytes stating what HTTP message is contained in
</I>&gt;<i> any given on-disk file. The memory copy gets erased as soon as the disk
</I>&gt;<i> controller has been asked to delete the file. The running worker does
</I>&gt;<i> not track whether the delete worked or not, just that all index entries
</I>&gt;<i> are supposedly valid HTTP objects. Whatever files get left undeleted on
</I>&gt;<i> disk can be overwritten with new content. [enter a few race condition
</I>&gt;<i> bugs].
</I>&gt;<i>
</I>&gt;<i> On shutdown the (up to 2^27 x 512 bytes) set of then-valid records are
</I>&gt;<i> dumped to disk in a new swap.state.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Should squid implement a journal (akin to EXT/ReiserFS and others)
</I>&gt;<i> so
</I>&gt;<i> &gt;    the on-disk index structure is always OK?
</I>&gt;<i>
</I>&gt;<i> Been tried. store_log is the journal. You can turn it on if you have any
</I>&gt;<i> need for external software to track what Squid cache contains in near
</I>&gt;<i> real-time.
</I>&gt;<i>
</I>&gt;<i> Overall it slows Squid down and it is not useful to remember objects
</I>&gt;<i> that were saved X days ago and deleted a few seconds later.
</I>&gt;<i>
</I>&gt;<i> Wont protect against swap.state corruption anyway, since the journal/log
</I>&gt;<i> file would get truncated/corrupted in the same ways as swap.state.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Is the problem related to clients actively receiving web pages from
</I>&gt;<i> &gt;    squid?
</I>&gt;<i>
</I>&gt;<i> Indirectly. They delay added by waiting for them increases the
</I>&gt;<i> impatience of external daemon managers and admins chance of using
</I>&gt;<i> SIGKILL on the worker.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Could squid's signal handling be adjusted to treat those clients
</I>&gt;<i> more
</I>&gt;<i> &gt;    harshly? That is, terminate the transfers early because squid
</I>&gt;<i> shutting down
</I>&gt;<i> &gt;    is much the same as the network interface going down.
</I>&gt;<i>
</I>&gt;<i> It could. I have actually just applied a patch to Squid-4 that makes
</I>&gt;<i> Squid abort idle client connections on teh first SIGTERM and more
</I>&gt;<i> cleanly close *all* client FDs at the end of the shutdown_lifetime (or
</I>&gt;<i> second SIGTERM) before it uses abort() on whats left. That will probably
</I>&gt;<i> be in 3.5.7 as well.
</I>&gt;<i>
</I>&gt;<i> Hopefully that will result in less SWAPFAIL corruption issues in future
</I>&gt;<i> for some people. It may or may not help with swap.fail corruption since
</I>&gt;<i> thet is a step later.
</I>&gt;<i>
</I>&gt;<i> Long term plan is to handle shutdown in such a way that non-busy Squid
</I>&gt;<i> may even exit before shutdown_lifetime is over. Which should definitely
</I>&gt;<i> include proper swap.state closure.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Is the only viable solution to use squid to stop the daemon? Does
</I>&gt;<i> &gt;    'squid -k shutdown' exit only after the daemon is dead? The squid man
</I>&gt;<i> page
</I>&gt;<i> &gt;    indicates that it sends the shutdown 'signal' but does not await a
</I>&gt;<i> reply;
</I>&gt;<i> &gt;    thus a potentially lengthy pause in system shutdown may be required
</I>&gt;<i> anyway.
</I>&gt;<i>
</I>&gt;<i> The man page is correct. &quot;squid -k shutdown&quot; sends a SIGTERM signal to
</I>&gt;<i> the process listed in squids PID file.
</I>&gt;<i>  NP: any other UNIX style process could happily do the same to control
</I>&gt;<i> Squid.
</I>&gt;<i>
</I>&gt;<i> The -k process itself exits immediately when that signal is sent.
</I>&gt;<i>
</I>&gt;<i> The running squid daemon manager (or coordinator) process handles that
</I>&gt;<i> signal as mentioned above.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;    - Is pausing the system shutdown for 10-15 seconds the only really
</I>&gt;<i> &gt;    viable shutdown solution?
</I>&gt;<i>
</I>&gt;<i> In current Squid releases yes. The alternative is to risk the corruption
</I>&gt;<i> problems.
</I>&gt;<i>
</I>&gt;<i> &gt;    - Or is it best to delete and rebuild the cache index on every system
</I>&gt;<i> &gt;    startup?
</I>&gt;<i>
</I>&gt;<i> No. Just configure shutdown_lifetime to a few seconds, and require the
</I>&gt;<i> init scripts system to wait that long plus 2-3 more sec for the whole
</I>&gt;<i> bunch of Squid processes to complete normally. Use SIGTERM if really
</I>&gt;<i> necessary to speed things up.
</I>&gt;<i>
</I>&gt;<i> There are a occasional exceptions, you may be one, but for most
</I>&gt;<i> installations it seems to still work fine that way.
</I>&gt;<i>
</I>&gt;<i> HTH
</I>&gt;<i> Amos
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20150724/6617c229/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20150724/6617c229/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="004752.html">[squid-users] SIGTERM SIGKILL causes issues with squid shutdown during reboot
</A></li>
	<LI>Next message (by thread): <A HREF="004726.html">[squid-users] error windbind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4763">[ date ]</a>
              <a href="thread.html#4763">[ thread ]</a>
              <a href="subject.html#4763">[ subject ]</a>
              <a href="author.html#4763">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
