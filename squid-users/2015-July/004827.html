<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Possible bug in 3.5.5 or a store change from 2.7?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Possible%20bug%20in%203.5.5%20or%20a%20store%20change%20from%202.7%3F&In-Reply-To=%3C55B7DDF0.3070006%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004824.html">
   <LINK REL="Next"  HREF="004831.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Possible bug in 3.5.5 or a store change from 2.7?</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Possible%20bug%20in%203.5.5%20or%20a%20store%20change%20from%202.7%3F&In-Reply-To=%3C55B7DDF0.3070006%40treenet.co.nz%3E"
       TITLE="[squid-users] Possible bug in 3.5.5 or a store change from 2.7?">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Jul 28 19:54:24 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="004824.html">[squid-users] Possible bug in 3.5.5 or a store change from 2.7?
</A></li>
        <LI>Next message (by thread): <A HREF="004831.html">[squid-users] Possible bug in 3.5.5 or a store change from 2.7?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4827">[ date ]</a>
              <a href="thread.html#4827">[ thread ]</a>
              <a href="subject.html#4827">[ subject ]</a>
              <a href="author.html#4827">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 29/07/2015 5:53 a.m., Tory M Blue wrote:
&gt;<i> squid-3.5.5-1.el6.x86_64
</I>&gt;<i> 
</I>&gt;<i> CentOS 6.6
</I>&gt;<i> 
</I>&gt;<i>  This looks like a bug in Squid v3 or a difference from 2.7.  Our monitor
</I>&gt;<i> couldn't be simpler.  It requests the SAME URL twice (identical in every
</I>&gt;<i> way, same hostname too), and expects the 2nd response to contain the
</I>&gt;<i> X-Squid hit header.  If it does not, then Squid has some sort of race
</I>&gt;<i> condition going on its code.
</I>&gt;<i> 
</I>
No HTTP does not work that way, and Squid certainly does not.

Squid is event driven and Squid-3 is also asynchronously interleaving
processing of those events sub-steps where Squid-2 was just using a huge
stack / call chain per-event. When operating under load there is always
a slight delay between asynchronous operations being scheduled, and
being run.

You may as well sends a request to two completely separate pieces of
hardware and try to draw a conclusion based on one of those being a HIT.


In Squid *every* transaction processed is racing against everything else
that needs to happen *all* of the time.

A code &quot;race condition&quot; under those circumstances means that the steps
of a *single* transaction are running against each other. Or two things
that should not interact are clobbering each others state data. Anything
else Squid may be doing in parallel is irrelvant.


HTTP itself is stateless, always has been stateless. Any stateful
interaction between *different* transactions has always been an
illusion. Caching brings that illusion a bit closer to solidity, but its
still an illusion.

For example your &quot;fail&quot; result does not distinguish between the second
&quot;MISS&quot; being a cache near-HIT, a full MISS, or a revalidation MISS.

HTTP/1.1 can do some funky stuff sometimes. Picture a
Cache-Control:no-cache header causing replies with auth credentials
embeded to be stored for later HITs by other users. Yes thats right, and
its actually one of the desirable features - we just have to fetch new
headers from the server to attach to the object on later HIT. (Thats a
near-HIT BTW).


&gt;<i>  I just reproduced this by hand, using an HTTP sniffer tool.  I requested
</I>&gt;<i> the same URL twice, with about a 0.25 second delay between fetches, and the
</I>&gt;<i> 2nd attempt was ALSO A MISS.  Then I waited 1 second and tried a 3rd time,
</I>&gt;<i> and it was FINALLY a hit.
</I>
Had the first request finished being delivered to your testing tool
before the second request was sent?

If the answer is no, then this test itself in invalid. Because of the
next thing ...

&gt;<i> 
</I>&gt;<i> Squid v3 seems to have changed the way it stores objects.  Maybe it is
</I>&gt;<i> doing some sort of &quot;asynchronous&quot; background store now, so if you send in
</I>&gt;<i> sequential requests without a delay between, it may not actually have
</I>&gt;<i> finished storing it yet, so it doesn't report a &quot;hit&quot;.  Meaning, the first
</I>&gt;<i> &quot;miss&quot; response may have fired off a thread to store the object, and not
</I>&gt;<i> doing it in the main thread anymore like in v2, if you get my meaning.
</I>
Squid-3 in-transit objects are not listed as existing in cache_mem
storage until they have completely (and successfully) finished their
first use.


You can configure &quot;collapsed_forwarding on&quot; to enable the Squid-2.7
behaviour. Treating the in-transit objects list as if it were another
cache area.

But be aware that speed of the first client reading the object is
applied, even if later clients require faster delivery. The way HTTP/1.1
variant objects work also means some clients may have added lag waiting
for an object they discover to be unusable, so then have to go fetch
their correct one - resulting in 2x normal MISS latency.
 These are not new problems though 2.7 had them in its own way.


&gt;<i> 
</I>&gt;<i> For the Squid dev team, here are the headers we are sending back from the
</I>&gt;<i> origin App VIP:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Accept-Ranges: none
</I>&gt;<i> 
</I>&gt;<i> Access-Control-Allow-Origin: *
</I>&gt;<i> 
</I>&gt;<i> *Cache-Control: max-age=300*
</I>&gt;<i> 
</I>&gt;<i> Connection: close
</I>&gt;<i> 
</I>&gt;<i> Content-Length: 403
</I>&gt;<i> 
</I>&gt;<i> Content-Type: image/jpeg
</I>&gt;<i> 
</I>&gt;<i> Date: Tue, 28 Jul 2015 17:25:36 GMT
</I>&gt;<i> 
</I>&gt;<i> Expires: Tue, 28 Jul 2015 17:30:36 GMT
</I>&gt;<i> 
</I>&gt;<i> Last-Modified: Mon, 11 Jun 2012 04:25:18 GMT
</I>&gt;<i> 
</I>&gt;<i> Server: Apache/2.2.26 (Unix)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> This should very much be cached right away and it's a simple tiny image.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> One thing we also notice is this only occurs doing load, meaning when we
</I>&gt;<i> have production load traffic this fails, but if there is no other
</I>&gt;<i> connections to the box, no other queries, this does not fail. Is it
</I>&gt;<i> possible that squid is ejecting this that fast or is there another
</I>&gt;<i> possibility here? Not sure what other data I can provide but will if asked.
</I>&gt;<i> 
</I>

Timing between *completion* of the first request and starting of the
second is the critical. If the first request has not finished, theres no
hope of a HIT.

Also size of memory cache relative to the churn currently going on also
matters. If you wait too long between the test requests it will be
pushed out and get a MISS again anyway. But I dont think that is a
factor with 250ms being your timing.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="004824.html">[squid-users] Possible bug in 3.5.5 or a store change from 2.7?
</A></li>
	<LI>Next message (by thread): <A HREF="004831.html">[squid-users] Possible bug in 3.5.5 or a store change from 2.7?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4827">[ date ]</a>
              <a href="thread.html#4827">[ thread ]</a>
              <a href="subject.html#4827">[ subject ]</a>
              <a href="author.html#4827">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
