<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Ssl-bump deep dive (intercept last post and final thoughts)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Ssl-bump%20deep%20dive%20%28intercept%20last%20post%20and%20final%0A%20thoughts%29&In-Reply-To=%3C556BAE9D.4040700%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003853.html">
   <LINK REL="Next"  HREF="003798.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Ssl-bump deep dive (intercept last post and final thoughts)</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Ssl-bump%20deep%20dive%20%28intercept%20last%20post%20and%20final%0A%20thoughts%29&In-Reply-To=%3C556BAE9D.4040700%40treenet.co.nz%3E"
       TITLE="[squid-users] Ssl-bump deep dive (intercept last post and final thoughts)">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Jun  1 01:00:13 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="003853.html">[squid-users] TOS squid-3.5.0.4
</A></li>
        <LI>Next message (by thread): <A HREF="003798.html">[squid-users] Ssl-bump deep dive (intercept last post and final thoughts)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3796">[ date ]</a>
              <a href="thread.html#3796">[ thread ]</a>
              <a href="subject.html#3796">[ subject ]</a>
              <a href="author.html#3796">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 1/06/2015 11:56 a.m., James Lay wrote:
&gt;<i> So this has been REALLY good!  The tl;dr:  ssl-bumping is pretty easy
</I>&gt;<i> even with intercept, ssl-bumping with access control is a little more
</I>&gt;<i> difficult...jump to the config to skip the chit chat.
</I>&gt;<i> 
</I>&gt;<i> My goal has always been to a content filter based on url regex.  This
</I>&gt;<i> works just fine for http traffic, but is much more difficult for https
</I>&gt;<i> traffic just for the case of you may or may not know the host you're
</I>&gt;<i> going to, depending on the site/app.  I'll be real honest here....I'm
</I>&gt;<i> only doing this to protect/filter the traffic of two kids, on laptops,
</I>&gt;<i> iPhone, and Android phone, so it's a mixed bag of content and, since
</I>&gt;<i> it's just the two of them in a home environment, I get to play around
</I>&gt;<i> and see what works and what doesn't.
</I>&gt;<i> 
</I>&gt;<i> Below is a close as I can get transparent intercept ssl-bump with
</I>&gt;<i> content filtering with using a list of domains/urls with both http and
</I>&gt;<i> https.  I still have to use a list of broken sites, which are large
</I>&gt;<i> netblocks (17.0.0.0/8..Apple anyone?) because some of these I just can't
</I>&gt;<i> seem to get host/domain information during the ssl handshake.  As I
</I>&gt;<i> discovered after attempting to put this into &quot;production&quot;, I have not
</I>&gt;<i> been able to emulate using wget or curl an https session that doesn't
</I>&gt;<i> have any SNI information, so that threw me for a loop.  TextNow is a
</I>&gt;<i> great example (I'm including a packet capture of this in this post).
</I>&gt;<i> There's no host information in the client hello....there's no host
</I>&gt;<i> information in the server hello.....buried deep in the certificate ONLY
</I>&gt;<i> is the &quot;commonName=.*textnow.me&quot;...that's it.  This dashed my hopes of
</I>&gt;<i> using an url_regex for access control with all https sessions.  I have
</I>&gt;<i> &quot;%ssl::&gt;cert_subject&quot; in my logging, and I never did see this log in any
</I>&gt;<i> of my tests...and I tested a BUNCH of different peek/stare/splice/bump
</I>&gt;<i> cominations..so I don't think squid is actually seeing this from the
</I>&gt;<i> certificate.
</I>&gt;<i> 
</I>&gt;<i> Another challenge is getting http url_regex filtering to work with https
</I>&gt;<i> filtering.  My method of filtering means not having an &quot;http_access
</I>&gt;<i> allow localnet&quot;, which directly conflicted with also trying to filter
</I>&gt;<i> https.  The solution was to add an acl for port 443, then http_access to
</I>&gt;<i> just allow it, as our filtering was going to happen for https further
</I>&gt;<i> down.
</I>&gt;<i> 
</I>&gt;<i> I know there's a fair amount of people who just want to plop in some
</I>&gt;<i> config files, run a few commands, and be up and running.  The below
</I>&gt;<i> configuration has two additional files it references, http_url.txt,
</I>&gt;<i> which is an a list of domains/urls (\.apple\.com for example), and the
</I>&gt;<i> aptly named broken, which is a IP list (17.0.0.0/8).  The broken list
</I>&gt;<i> should be (semi) trusted and are sites that we just can't get SNI or
</I>&gt;<i> hostname information from.  If you've created a single cert/key pair
</I>&gt;<i> from the Squid documentation, you won't need the key= line in your
</I>&gt;<i> https_port directive.  If you've followed along in my posts, you already
</I>&gt;<i> have the configure line from my previous posts.  Change the
</I>&gt;<i> commands/config to fir where your squid config and ssl_db are.  So after
</I>&gt;<i> configuring, make sure you:
</I>&gt;<i> 
</I>&gt;<i> sudo /opt/libexec/ssl_crtd -c -s /opt/var/ssl_db
</I>&gt;<i> sudo chown -R nobody /opt/var/ssl_db/
</I>&gt;<i> 
</I>&gt;<i> As I believe in a lot of logging, and actually looking at said logging,
</I>&gt;<i> below is what you can expect to see in your logs (mine logs to syslog,
</I>&gt;<i> again, change this if you log to a different file):
</I>&gt;<i> 
</I>&gt;<i> Allowed http to .apple.com in http_url.txt:
</I>&gt;<i> May 31 17:03:48 gateway (squid-1): 192.168.1.100 - -
</I>&gt;<i> [31/May/2015:17:03:48 -0600] &quot;GET
</I>&gt;<i> <A HREF="http://init.ess.apple.com/WebObjects/VCInit.woa/wa/getBag?">http://init.ess.apple.com/WebObjects/VCInit.woa/wa/getBag?</A> HTTP/1.1&quot; - -
</I>&gt;<i> 200 5243 TCP_MISS:ORIGINAL_DST -
</I>&gt;<i> Denied http to symcb.com not in http_url.txt
</I>&gt;<i> May 31 17:03:48 gateway (squid-1): 192.168.1.100 - -
</I>&gt;<i> [31/May/2015:17:03:48 -0600] &quot;GET <A HREF="http://sd.symcb.com/sd.crt">http://sd.symcb.com/sd.crt</A> HTTP/1.1&quot; -
</I>&gt;<i> - 403 3618 TCP_DENIED:HIER_NONE -
</I>&gt;<i> Spliced https IP in broken.txt (google block 216.58.192.0/19)
</I>&gt;<i> May 31 17:04:34 gateway (squid-1): 192.168.1.101 - -
</I>&gt;<i> [31/May/2015:17:04:34 -0600] &quot;CONNECT 216.58.216.138:443 HTTP/1.1&quot; - -
</I>&gt;<i> 200 568 TCP_TUNNEL:ORIGINAL_DST peek
</I>&gt;<i> Spliced https IP in broken.txt that we got SNI or bumped site in
</I>&gt;<i> http_url.txt look exactly the same
</I>&gt;<i> May 31 17:09:45 gateway (squid-1): 192.168.1.100 - -
</I>&gt;<i> [31/May/2015:17:09:45 -0600] &quot;CONNECT 23.222.157.21:443 HTTP/1.1&quot;
</I>&gt;<i> init.itunes.apple.com - 200 30314 TCP_TUNNEL:ORIGINAL_DST peek
</I>&gt;<i> 
</I>&gt;<i> The only drag with the configuration is you won't see when an https
</I>&gt;<i> session is terminated when the IP/url is not in the broken.txt, or the
</I>&gt;<i> http_url.txt:
</I>&gt;<i> 
</I>&gt;<i> [17:20:53 <A HREF="https://lists.squid-cache.org/listinfo/squid-users">jlay at analysis</A>:~$] wget -d
</I>&gt;<i> --ca-certificate=/etc/ssl/certs/sslsplit.crt <A HREF="https://www.yahoo.com">https://www.yahoo.com</A>
</I>&gt;<i> Setting --ca-certificate (cacertificate) to /etc/ssl/certs/sslsplit.crt
</I>&gt;<i> DEBUG output created by Wget 1.16.1 on linux-gnu.
</I>&gt;<i> 
</I>&gt;<i> URI encoding = &#8216;UTF-8&#8217;
</I>&gt;<i> --2015-05-31 17:20:59--  <A HREF="https://www.yahoo.com/">https://www.yahoo.com/</A>
</I>&gt;<i> Resolving www.yahoo.com (www.yahoo.com)... 206.190.36.45,
</I>&gt;<i> 206.190.36.105, 2001:4998:c:a06::2:4008
</I>&gt;<i> Caching www.yahoo.com =&gt; 206.190.36.45 206.190.36.105
</I>&gt;<i> 2001:4998:c:a06::2:4008
</I>&gt;<i> Connecting to www.yahoo.com (www.yahoo.com)|206.190.36.45|:443...
</I>&gt;<i> connected.
</I>&gt;<i> Created socket 3.
</I>&gt;<i> Releasing 0x00007fdf67eecdd0 (new refcount 1).
</I>&gt;<i> Initiating SSL handshake.
</I>&gt;<i> SSL handshake failed.
</I>&gt;<i> Closed fd 3
</I>&gt;<i> Unable to establish SSL connection.
</I>&gt;<i> 
</I>&gt;<i> May 31 17:20:59 gateway (squid-1): 192.168.1.6 - - [31/May/2015:17:20:59
</I>&gt;<i> -0600] &quot;CONNECT 206.190.36.45:443 HTTP/1.1&quot; www.yahoo.com - 200 0
</I>&gt;<i> TAG_NONE:ORIGINAL_DST peek 
</I>&gt;<i> 
</I>&gt;<i> Full config below:
</I>&gt;<i> ####################################
</I>&gt;<i> acl localnet src 192.168.1.0/24
</I>&gt;<i> 
</I>&gt;<i> acl SSL_ports port 443
</I>&gt;<i> acl Safe_ports port 80
</I>&gt;<i> acl Safe_ports port 443
</I>&gt;<i> 
</I>&gt;<i> acl CONNECT method CONNECT
</I>&gt;<i> 
</I>&gt;<i> acl allowed_http_sites url_regex &quot;/opt/etc/squid/http_url.txt&quot;
</I>&gt;<i> acl allow_https port 443
</I>
Note how SSL_ports and allow_https ACL definitions are identical apart
from the name.

You can replace all uses of &quot;allow_https&quot; ACL in the rest of your config
with &quot;SSL_Ports&quot;.


&gt;<i> acl broken dst &quot;/opt/etc/squid/broken.txt&quot;
</I>&gt;<i> 
</I>&gt;<i> http_access deny !Safe_ports
</I>&gt;<i> http_access deny CONNECT !SSL_Ports
</I>&gt;<i> 
</I>&gt;<i> http_access allow allow_https
</I>&gt;<i> http_access allow allowed_http_sites
</I>&gt;<i> http_access deny !allowed_http_sites
</I>&gt;<i> 
</I>&gt;<i> http_access deny all
</I>
Two deny lines in a row are redundant when one is &quot;deny all&quot;.

You can drop the &quot;deny !allowed_http_sites&quot;.


&gt;<i> 
</I>&gt;<i> acl step1 at_step SslBump1
</I>&gt;<i> acl step2 at_step SslBump2
</I>&gt;<i> acl step3 at_step SslBump3
</I>&gt;<i> 
</I>&gt;<i> ssl_bump peek step1 broken
</I>&gt;<i> ssl_bump peek step2 broken
</I>&gt;<i> ssl_bump splice broken
</I>&gt;<i> ssl_bump peek step1 all
</I>&gt;<i> ssl_bump peek step2 all
</I>
The above lines are logically the same as:

 ssl_bump splice step3 broken
 ssl_bump peek all

&gt;<i> acl allowed_https_sites ssl::server_name_regex
</I>&gt;<i> &quot;/opt/etc/squid/http_url.txt&quot;
</I>&gt;<i> ssl_bump bump allowed_https_sites
</I>&gt;<i> ssl_bump terminate !allowed_https_sites
</I>
If you used reject instead of terminate on this rule, you should get the
log entries you mentioned wanting when connections are terminated.

The not logging of &quot;terminate&quot; connectisno is a bug. Please report to
bugzilla so we dont forget it.

&gt;<i> 
</I>&gt;<i> sslproxy_cert_error allow all
</I>&gt;<i> sslproxy_capath /etc/ssl/certs
</I>&gt;<i> sslproxy_flags DONT_VERIFY_PEER 
</I>
The point of TLS is to verify the other endpoint of the connection is
actually who they claim to be. The above config settings are a) not
bothering to even check the claim, and b) silently ignoring whatever
result the security check produces.

* DONT_VERIFY_PEER is a debugging option. Not for use in &quot;production&quot;
systems. It should not even be used in any real operational testing,
only to see if the peer verification failures was the source of an issue.

* sslproxy_cert_error allow all - is pure evil. The directive was only
added so networks could continue to work during transition periods when
a major vulnerability like CRIME/ BREECH / POODLE were discovered and
their library started erroring out on bad bevahiour, but the remote
sites were being laggards.
 Theres a limited number of errors which are safe to ignore, and an even
smaller sub-set of those which are actually needed on any given network.


&gt;<i> sslproxy_options ALL
</I>
&quot;ALL&quot; enables a lot of old features and hacks in OpenSSL (export grade
ciphers and plaintext passwords, woohoo!) that are increasingly found to
cause security vulenrabilities.


&gt;<i> 
</I>&gt;<i> sslcrtd_program /opt/libexec/ssl_crtd -s /opt/var/ssl_db -M 4MB
</I>&gt;<i> sslcrtd_children 5
</I>&gt;<i> 
</I>&gt;<i> http_port 3128 intercept
</I>&gt;<i> https_port 3129 intercept ssl-bump
</I>&gt;<i> cert=/opt/etc/squid/certs/sslsplit_ca_cert.pem
</I>&gt;<i> cafile=/opt/etc/squid/certs/sslsplit_ca_cert.pem
</I>&gt;<i> key=/opt/etc/squid/certs/sslsplit_ca_key.pem
</I>&gt;<i> generate-host-certificates=on dynamic_cert_mem_cache_size=4MB
</I>&gt;<i> sslflags=NO_SESSION_REUSE
</I>&gt;<i> 
</I>&gt;<i> logformat mine %&gt;a %[ui %[un [%tl] &quot;%rm %ru HTTP/%rv&quot; %ssl::&gt;sni %
</I>&gt;<i> ssl::&gt;cert_subject %&gt;Hs %&lt;st %Ss:%Sh %ssl::bump_mode 
</I>&gt;<i> 
</I>&gt;<i> access_log syslog:daemon.info mine
</I>&gt;<i> 
</I>&gt;<i> refresh_pattern -i (cgi-bin|\?)	0	0%	0
</I>&gt;<i> refresh_pattern .		0	20%	4320
</I>&gt;<i> 
</I>&gt;<i> coredump_dir /opt/var
</I>&gt;<i> ##############################
</I>&gt;<i> 
</I>&gt;<i> Thanks all for being patient while I continued to post my learning and
</I>&gt;<i> all my mistakes.  If there's anything that I've missed, or if there's
</I>&gt;<i> another method for trying to accomplish what I've tried to do I'm all
</I>&gt;<i> eyes.
</I>&gt;<i> 
</I>&gt;<i> James
</I>&gt;<i> 
</I>&gt;<i> P.S. Things I'd love to see in Squid some day:
</I>&gt;<i> 
</I>&gt;<i> acl's being AND'd (http_access allow allowed_sites AND localnet)
</I>
That aready exists. The AND is implicit in the order of the ACL checks,
so the &quot;AND &quot; is redundant waste of space in the config file.

eg, your above &quot;allowed_sites AND localnet&quot; rule is configured:
  http_access allow allowed_sites localnet

This is why I keep pointing out how useless rules like &quot;ssl_bump peek
step1 all&quot; are. So you want to peek when &quot;step1&quot;, just peek based on
step1, no need to check if true == true.


&gt;<i> Full on separate http_access, https_access directives
</I>&gt;<i> 
</I>
I consider this every now and again. But HTTPS is not actually a real
thing. It is a TLS connection delivering regular HTTP messages. By the
time the messages are inside Squid they dont have that TLS part any more
than clear text HTTP has TCP headers.


That said, if you want to go fancy you can use the &quot;allof&quot; ACL type.
This ACL type lets you write an entire sub-tree of logical ACL tests and
give it a name. Its not quite the same though.

 acl HTTP proto HTTP
 acl HTTPS proto HTTPS

 acl sites dstdomain ...

 acl sites2 dstdomain ...
 acl site2paths urlpath_regex ...

 acl 443 port 443

 acl plain allof CONNECT 443
 acl plain allof sites
 acl plain allof sites2 site2paths
 acl plain allof localnet

 acl decrypted allof sites
 acl decrypted allof sites2 site2paths
 acl decrypted allof localnet

 http_access allow HTTP plain
 http_access allow HTTPS decrypted
 http_access deny all

Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="003853.html">[squid-users] TOS squid-3.5.0.4
</A></li>
	<LI>Next message (by thread): <A HREF="003798.html">[squid-users] Ssl-bump deep dive (intercept last post and final thoughts)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3796">[ date ]</a>
              <a href="thread.html#3796">[ thread ]</a>
              <a href="subject.html#3796">[ subject ]</a>
              <a href="author.html#3796">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
