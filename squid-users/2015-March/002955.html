<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] load balancing and site failover
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20load%20balancing%20and%20site%20failover&In-Reply-To=%3C5513586D.5020407%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002951.html">
   <LINK REL="Next"  HREF="002958.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] load balancing and site failover</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20load%20balancing%20and%20site%20failover&In-Reply-To=%3C5513586D.5020407%40treenet.co.nz%3E"
       TITLE="[squid-users] load balancing and site failover">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Mar 26 00:53:01 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="002951.html">[squid-users] load balancing and site failover
</A></li>
        <LI>Next message (by thread): <A HREF="002958.html">[squid-users] load balancing and site failover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2955">[ date ]</a>
              <a href="thread.html#2955">[ thread ]</a>
              <a href="subject.html#2955">[ subject ]</a>
              <a href="author.html#2955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 26/03/2015 10:26 a.m., Brendan Kearney wrote:
&gt;<i> On Wed, 2015-03-25 at 15:03 +1300, Amos Jeffries wrote:
</I>&gt;&gt;<i> On 25/03/2015 9:55 a.m., brendan kearney wrote:
</I>&gt;&gt;&gt;<i> Was not sure if bugzilla was used for mailing list issues.  If you would
</I>&gt;&gt;&gt;<i> like me to open one, I will but it looks like the list is working again.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Bugzilla is used, list bugs under the &quot;project services&quot; product.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As for your query...
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Mar 24, 2015 2:25 PM, &quot;Brendan Kearney&quot; wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> On Tue, 2015-03-24 at 10:18 -0400, Brendan Kearney wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> while load balancing is not a requirement in a proxy environment, it
</I>&gt;&gt;&gt;&gt;&gt;<i> does afford a great deal of functionality, scaling and fault tolerance
</I>&gt;&gt;&gt;&gt;&gt;<i> in one.  several if not many on this list probably employ them for their
</I>&gt;&gt;&gt;&gt;&gt;<i> proxies and likely other technologies, but they are not all created
</I>&gt;&gt;&gt;&gt;&gt;<i> equal.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> i recently looked to see if a specific feature was in HAProxy.  i was
</I>&gt;&gt;&gt;&gt;&gt;<i> looking to see if HAProxy could reply to a new connection with a RST
</I>&gt;&gt;&gt;&gt;&gt;<i> packet if no pool member was available.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> the idea behind this is, if all of the proxies are not passing the
</I>&gt;&gt;&gt;&gt;&gt;<i> service check and are marked down by the load balancer, the reply of a
</I>&gt;&gt;&gt;&gt;&gt;<i> RST in the TCP handshake (i.e. SYN -&gt; RST, not SYN -&gt; SYN/ACK -&gt; ACK)
</I>&gt;&gt;&gt;&gt;&gt;<i> tells the browser to failover to the next proxy assigned by the PAC
</I>&gt;&gt;&gt;&gt;&gt;<i> file.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> where i work, we have this configuration working.  the load balancers
</I>&gt;&gt;&gt;&gt;&gt;<i> are configured with the option to send a reset when no proxy is
</I>&gt;&gt;&gt;&gt;&gt;<i> available in the pool.  the PAC file assigns all 4 of the proxy VIPs in
</I>&gt;&gt;&gt;&gt;&gt;<i> a specific order based on which proxy VIP is assigned as the primary.
</I>&gt;&gt;&gt;&gt;&gt;<i> In every case, if the primary VIP does not have an available pool
</I>&gt;&gt;&gt;&gt;&gt;<i> member, the browser fails over to the next in the list.  failover would
</I>&gt;&gt;&gt;&gt;&gt;<i> happen again, if the secondary VIP replies with a RST during the
</I>&gt;&gt;&gt;&gt;&gt;<i> connection establishing.  the process repeats until a TCP connection
</I>&gt;&gt;&gt;&gt;&gt;<i> establishes or all proxies assigned have been exhausted.  the browser
</I>&gt;&gt;&gt;&gt;&gt;<i> will use the proxy VIP that it successfully connects to, for the
</I>&gt;&gt;&gt;&gt;&gt;<i> duration of the session.  once the browser is closed and reopened, the
</I>&gt;&gt;&gt;&gt;&gt;<i> evaluation of the PAC file occurs again, and the process starts anew.
</I>&gt;&gt;&gt;&gt;&gt;<i> plug-ins such as Proxy Selector are the exception to this, and can be
</I>&gt;&gt;&gt;&gt;&gt;<i> used to reevaluate a PAC file by selecting it for use.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> we have used this configuration several times, when we found an ISP link
</I>&gt;&gt;&gt;&gt;&gt;<i> was flapping or some other issue more global in nature than just the
</I>&gt;&gt;&gt;&gt;&gt;<i> proxies was affecting our egress and internet access.  i can attest to
</I>&gt;&gt;&gt;&gt;&gt;<i> the solution as working and elegantly handling site wide failures.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> being that the solutions where i work are proprietary commercial
</I>&gt;&gt;&gt;&gt;&gt;<i> products, i wanted to find an open source product that does this.  i
</I>&gt;&gt;&gt;&gt;&gt;<i> have been a long time user of HAProxy, and have recommended it for
</I>&gt;&gt;&gt;&gt;&gt;<i> others here, but sadly they cannot perform this function.  per their
</I>&gt;&gt;&gt;&gt;&gt;<i> mailing list, they use the network stack of the OS for connection
</I>&gt;&gt;&gt;&gt;&gt;<i> establishment and cannot cause a RST to be sent to the client during a
</I>&gt;&gt;&gt;&gt;&gt;<i> TCP handshake if no pool member is available.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> they suggested an external helper that manipulates IPTables rules based
</I>&gt;&gt;&gt;&gt;&gt;<i> on a pool member being available.  they do not feel that a feature like
</I>&gt;&gt;&gt;&gt;&gt;<i> this belongs in a layer 4/7 reverse proxy application.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> They are right. HTTP != TCP.
</I>&gt;<i> i didnt confuse that detail.  it was unknown to me that HAProxy could
</I>&gt;<i> not tie layer 7 status to layer 3/4 actions.  the decisions they made
</I>&gt;<i> and how they architected the app is why they cannot do this, not that it
</I>&gt;<i> is technically impossible to do it.  i may be spoiled because i work
</I>&gt;<i> with equipment that can do this for me.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In particular TCP depends on routers having a full routing map of the
</I>&gt;&gt;<i> entire Internet (provided by BGP) and deciding the best upstream hop
</I>&gt;&gt;<i> based on that global info. Clients have one (and only one) upstream
</I>&gt;&gt;<i> router for each server they want to connect to.
</I>&gt;<i> i will contest this.  my router does not need a full BGP map to route
</I>&gt;<i> traffic locally on my LAN or remotely out its WAN interface.  hell, it
</I>&gt;<i> does not even run BGP, and i can still get to the intarwebs, no problem.
</I>&gt;<i> it too, only has one upstream router / default route.
</I>
Then your router has more in common with proxy than usual. Its operating
with a next-hop packet relay model (OSPF? MPLS?) rather than an
end-to-end model (BGP with RIB/FIB).

&gt;&gt;<i>
</I>&gt;&gt;<i> In HTTP each proxy (aka router) performs independent upstream connection
</I>&gt;&gt;<i> attempts, failover, and verifies it worked before responding to the
</I>&gt;&gt;<i> client with a final response. Each proxy only has enough detail to check
</I>&gt;&gt;<i> its upstream(s). Each proxy can connect to any server (subject to ACLs).
</I>&gt;<i> how are you comparing a HTTP proxy (a layer 7 application) to a router
</I>&gt;<i> (a layer 3 device)?  routers route traffic and proxies proxy traffic.
</I>
while, routers proxy TCP packets and proxies route HTTP messages.

Its the behaviour abstraction I'm talking about here.
[if you dont want to dive into theory skip to the end of this mail]

The algorithms each are capable of are the same despite differences in
details of layer and what designed mechanisms are optimal for their
protocol.
DNS recursive resolvers are also a type of caching proxy, and SMTP email
servers too. Of the surviving &quot;old&quot; protocols only FTP seems not to have
proxies as integral part of the design.


&gt;<i> very different functions.  routers dont look past a certain point in the
</I>&gt;<i> headers in order to make decisions on where to send the traffic.
</I>
Same for proxies. I'm sure you're aware that Squid dont look into HTTP
payloads same as routers dont look into TCP payloads.

&gt;<i> proxies look all the way to the end of the headers and sometimes into
</I>&gt;<i> the payload, too.
</I>
No proxies dont look into payloads. Content filters do that bit instead
of the proxy.
Just like routers can be enhanced by DPI systems doing payload
inspection at their level.

In both systems the DPI / content filter is where they cross over into
firewall activity.

&gt;<i>  proxies are more akin to a protocol specific
</I>&gt;<i> firewall.
</I>
You have no firewall ability built into your router?

&gt;<i>  proxies also dont send the incoming traffic out an interface.
</I>
layer-3/4 interface is equivalent to layer-5/7 socket in abstract.

&gt;<i> they terminate the client session, and initiate a new session on behalf
</I>&gt;<i> of the client.
</I>
not necessarily, that is the architectural difference between HTTP and
TCP. SOCKS proxies and TCP have much more in common in architectural design.

What the proxies do is terminate the *TCP* session. Obviously all
non-TCP protocols will do that.
The HTTP layer is more inline with UDP here than TCP. Although at the
layer just above HTTP there is the &quot;browsing session&quot; concept
implemented with cookies/auth etc which is retained across both TCP
layer connections. For cases where TCP-level sessions need to be
emulated there is connection pinning in the proxy.


&gt;<i>  simply because the proxy can elect how to send a request
</I>&gt;<i> it is making on behalf of a client, does not make a proxy a router.
</I>
The names are terminology for the activity performed. TCP routers
normally do not re-selecting the destination endpoint, just the path.
The proxy selects the actual endpoint destination.

What you can configure each to do crosses over and you can specifically
configure a proxy to become a router, and vice versa. Doing it though
screws with their normal and optimal behavour. Router becomes like a
proxy by turning on NAT - and we probably both know the hell that
causes. Making a proxy do strictly router behaviour has a similar range
of nasty side effects.

Yes each one (proxy vs router) is designed to work at different levels,
in different ways. But how you use them determines what they do.

In particular this is the difference which you request is asking us to
provide a way to disable. Making the proxy return TCP RST if a
particular endpoint is not available - despite other endpoints
potentially being usable.
 Making the proxy behave like a router.


&gt;<i>  the
</I>&gt;<i> fact that one connection is terminated and a new one is initiated rules
</I>&gt;<i> out a proxy from being any kind of router, in my opinion.
</I>
That rules out all devices containing NAT functionality or LB software
from being routers.

&gt;<i>  even with SSL
</I>&gt;<i> or the CONNECT Method, the connection is still made by the proxy to the
</I>&gt;<i> remote server.  the client never makes a connection to the remote
</I>&gt;<i> server, therefore the traffic was not routed.  it was proxied.
</I>
By definition CONNECT method is not a proxy. In particular it is the
request that the proxy stop being a HTTP proxy and become a tunnel / TCP
relay.
It is roughly equivalent to a router sending packets down a tunnel / VPN
or SOCKS interface (the proxy is the outgoing end of the tunnel/VPN).



&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> my search for a load balancer solution went through ipvsadm, balance and
</I>&gt;&gt;&gt;&gt;&gt;<i> haproxy before i selected haproxy.  haproxy was more feature rich than
</I>&gt;&gt;&gt;&gt;&gt;<i> balance, and easier to implement than ipvsadm.  do any other list
</I>&gt;&gt;&gt;&gt;&gt;<i> members have a need for such a feature from their load balancers?  do
</I>&gt;&gt;&gt;&gt;&gt;<i> any other list members have site failover solutions that have been
</I>&gt;&gt;&gt;&gt;&gt;<i> tested or used and would consider sharing their design and/or pain
</I>&gt;&gt;&gt;&gt;&gt;<i> points?  i am not looking for secret sauce or confidential info, but
</I>&gt;&gt;&gt;&gt;&gt;<i> more high level architecture decisions and such.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I havent tested it but this should do what you are asking:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  acl err http_status 500-505 408
</I>&gt;&gt;<i>  deny_info TCP_RESET err
</I>&gt;&gt;<i>  http_reply_access deny err
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It replaces the response from Squid with a TCP RST packet.
</I>&gt;<i> this is useful in the case that the proxy is alive and well, but cannot
</I>&gt;<i> get to the internet.  in my example, the ISP issue would seem to be
</I>&gt;<i> covered, though i am not sure how the actual implementation would go.
</I>&gt;<i> the client has a TCP session established with the load balancer, which
</I>&gt;<i> gets the full SYN -&gt; SYN/ACK -&gt; ACK treatement.  the load balancer would
</I>&gt;<i> get the SYN -&gt; RST from the proxy, and presumably sends the RST back to
</I>&gt;<i> the client.  While this does seem to hold up logically, the
</I>&gt;<i> implementation may have nuances that have to be dealt with.  Does the
</I>&gt;<i> RST in the middle of an established TCP session cause the browser to
</I>&gt;<i> failover to the next proxy assigned?  i would have to test that out.
</I>
Nod.

&gt;<i> 
</I>&gt;<i> now, what about the case where the proxies are not alive and well behind
</I>&gt;<i> the load balancer, and they are not able to reply with a RST?  This is
</I>&gt;<i> the scenario that i would want the load balancer to be able to manage.
</I>&gt;<i> this is where tying a layer 7 status to a layer 3/4 action on the load
</I>&gt;<i> balancer becomes relevant.  then, the ability for the load balancer to
</I>&gt;<i> do this negates the need to manage this in the proxy layer, and removes
</I>&gt;<i> any nuances that may be encountered with the implementation.
</I>

That is a normal TCP error case. Same things happen if there is any
network level outage, or packets destined to a non-existent IP range. It
depends on the LB software what will be done about it.

Amos


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="002951.html">[squid-users] load balancing and site failover
</A></li>
	<LI>Next message (by thread): <A HREF="002958.html">[squid-users] load balancing and site failover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2955">[ date ]</a>
              <a href="thread.html#2955">[ thread ]</a>
              <a href="subject.html#2955">[ subject ]</a>
              <a href="author.html#2955">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
