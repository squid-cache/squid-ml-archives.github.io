<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] load balancing and site failover
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20load%20balancing%20and%20site%20failover&In-Reply-To=%3C1427408551.30756.33.camel%40desktop.bpk2.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002955.html">
   <LINK REL="Next"  HREF="002924.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] load balancing and site failover</H1>
    <B>Brendan Kearney</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20load%20balancing%20and%20site%20failover&In-Reply-To=%3C1427408551.30756.33.camel%40desktop.bpk2.com%3E"
       TITLE="[squid-users] load balancing and site failover">bpk678 at gmail.com
       </A><BR>
    <I>Thu Mar 26 22:22:31 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="002955.html">[squid-users] load balancing and site failover
</A></li>
        <LI>Next message (by thread): <A HREF="002924.html">[squid-users] I am seeing the following in my cache.log
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2958">[ date ]</a>
              <a href="thread.html#2958">[ thread ]</a>
              <a href="subject.html#2958">[ subject ]</a>
              <a href="author.html#2958">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 2015-03-26 at 13:53 +1300, Amos Jeffries wrote:
&gt;<i> On 26/03/2015 10:26 a.m., Brendan Kearney wrote:
</I>&gt;<i> &gt; On Wed, 2015-03-25 at 15:03 +1300, Amos Jeffries wrote:
</I>&gt;<i> &gt;&gt; On 25/03/2015 9:55 a.m., brendan kearney wrote:
</I>&gt;<i> &gt;&gt;&gt; Was not sure if bugzilla was used for mailing list issues.  If you would
</I>&gt;<i> &gt;&gt;&gt; like me to open one, I will but it looks like the list is working again.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Bugzilla is used, list bugs under the &quot;project services&quot; product.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; As for your query...
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; On Mar 24, 2015 2:25 PM, &quot;Brendan Kearney&quot; wrote:
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; On Tue, 2015-03-24 at 10:18 -0400, Brendan Kearney wrote:
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; while load balancing is not a requirement in a proxy environment, it
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; does afford a great deal of functionality, scaling and fault tolerance
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; in one.  several if not many on this list probably employ them for their
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; proxies and likely other technologies, but they are not all created
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; equal.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; i recently looked to see if a specific feature was in HAProxy.  i was
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; looking to see if HAProxy could reply to a new connection with a RST
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; packet if no pool member was available.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; the idea behind this is, if all of the proxies are not passing the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; service check and are marked down by the load balancer, the reply of a
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; RST in the TCP handshake (i.e. SYN -&gt; RST, not SYN -&gt; SYN/ACK -&gt; ACK)
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; tells the browser to failover to the next proxy assigned by the PAC
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; file.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; where i work, we have this configuration working.  the load balancers
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; are configured with the option to send a reset when no proxy is
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; available in the pool.  the PAC file assigns all 4 of the proxy VIPs in
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; a specific order based on which proxy VIP is assigned as the primary.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; In every case, if the primary VIP does not have an available pool
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; member, the browser fails over to the next in the list.  failover would
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; happen again, if the secondary VIP replies with a RST during the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; connection establishing.  the process repeats until a TCP connection
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; establishes or all proxies assigned have been exhausted.  the browser
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; will use the proxy VIP that it successfully connects to, for the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; duration of the session.  once the browser is closed and reopened, the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; evaluation of the PAC file occurs again, and the process starts anew.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; plug-ins such as Proxy Selector are the exception to this, and can be
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; used to reevaluate a PAC file by selecting it for use.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; we have used this configuration several times, when we found an ISP link
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; was flapping or some other issue more global in nature than just the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; proxies was affecting our egress and internet access.  i can attest to
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; the solution as working and elegantly handling site wide failures.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; being that the solutions where i work are proprietary commercial
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; products, i wanted to find an open source product that does this.  i
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; have been a long time user of HAProxy, and have recommended it for
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; others here, but sadly they cannot perform this function.  per their
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; mailing list, they use the network stack of the OS for connection
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; establishment and cannot cause a RST to be sent to the client during a
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; TCP handshake if no pool member is available.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; they suggested an external helper that manipulates IPTables rules based
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; on a pool member being available.  they do not feel that a feature like
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; this belongs in a layer 4/7 reverse proxy application.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; They are right. HTTP != TCP.
</I>&gt;<i> &gt; i didnt confuse that detail.  it was unknown to me that HAProxy could
</I>&gt;<i> &gt; not tie layer 7 status to layer 3/4 actions.  the decisions they made
</I>&gt;<i> &gt; and how they architected the app is why they cannot do this, not that it
</I>&gt;<i> &gt; is technically impossible to do it.  i may be spoiled because i work
</I>&gt;<i> &gt; with equipment that can do this for me.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; In particular TCP depends on routers having a full routing map of the
</I>&gt;<i> &gt;&gt; entire Internet (provided by BGP) and deciding the best upstream hop
</I>&gt;<i> &gt;&gt; based on that global info. Clients have one (and only one) upstream
</I>&gt;<i> &gt;&gt; router for each server they want to connect to.
</I>&gt;<i> &gt; i will contest this.  my router does not need a full BGP map to route
</I>&gt;<i> &gt; traffic locally on my LAN or remotely out its WAN interface.  hell, it
</I>&gt;<i> &gt; does not even run BGP, and i can still get to the intarwebs, no problem.
</I>&gt;<i> &gt; it too, only has one upstream router / default route.
</I>&gt;<i> 
</I>&gt;<i> Then your router has more in common with proxy than usual. Its operating
</I>&gt;<i> with a next-hop packet relay model (OSPF? MPLS?) rather than an
</I>&gt;<i> end-to-end model (BGP with RIB/FIB).
</I>DOCSIS 2 -&gt; ethernet on the WAN side and locally connected on the LAN
side. :D  oh, and a static route pointing a /24 for vpn traffic to a
specific device.
&gt;<i> 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; In HTTP each proxy (aka router) performs independent upstream connection
</I>&gt;<i> &gt;&gt; attempts, failover, and verifies it worked before responding to the
</I>&gt;<i> &gt;&gt; client with a final response. Each proxy only has enough detail to check
</I>&gt;<i> &gt;&gt; its upstream(s). Each proxy can connect to any server (subject to ACLs).
</I>&gt;<i> &gt; how are you comparing a HTTP proxy (a layer 7 application) to a router
</I>&gt;<i> &gt; (a layer 3 device)?  routers route traffic and proxies proxy traffic.
</I>&gt;<i> 
</I>&gt;<i> while, routers proxy TCP packets and proxies route HTTP messages.
</I>&gt;<i> 
</I>&gt;<i> Its the behaviour abstraction I'm talking about here.
</I>&gt;<i> [if you dont want to dive into theory skip to the end of this mail]
</I>&gt;<i> 
</I>&gt;<i> The algorithms each are capable of are the same despite differences in
</I>&gt;<i> details of layer and what designed mechanisms are optimal for their
</I>&gt;<i> protocol.
</I>&gt;<i> DNS recursive resolvers are also a type of caching proxy, and SMTP email
</I>&gt;<i> servers too. Of the surviving &quot;old&quot; protocols only FTP seems not to have
</I>&gt;<i> proxies as integral part of the design.
</I>recursive DNS queries, yes i can see that as being proxied.  SMTP gets a
bit gray.  MUA -&gt; MRA -&gt; MTA, store and forward, ehh.  you can make a
convincing argument for or against, but the &quot;on behalf of&quot; piece is
there.  FTP and the PORT command (and subsequent bounce attack) could be
considered a proxied connection, but i dont think that was an intended
design.
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; very different functions.  routers dont look past a certain point in the
</I>&gt;<i> &gt; headers in order to make decisions on where to send the traffic.
</I>&gt;<i> 
</I>&gt;<i> Same for proxies. I'm sure you're aware that Squid dont look into HTTP
</I>&gt;<i> payloads same as routers dont look into TCP payloads.
</I>&gt;<i> 
</I>&gt;<i> &gt; proxies look all the way to the end of the headers and sometimes into
</I>&gt;<i> &gt; the payload, too.
</I>&gt;<i> 
</I>&gt;<i> No proxies dont look into payloads. Content filters do that bit instead
</I>&gt;<i> of the proxy.
</I>&gt;<i> Just like routers can be enhanced by DPI systems doing payload
</I>&gt;<i> inspection at their level.
</I>&gt;<i> 
</I>&gt;<i> In both systems the DPI / content filter is where they cross over into
</I>&gt;<i> firewall activity.
</I>i sometimes forget that i have two technologies bolted together on a
&quot;proxy appliance&quot; and that is why i misstated that.  yes, proxies dont
inspect payload.  content inspection systems do that.
&gt;<i> 
</I>&gt;<i> &gt;  proxies are more akin to a protocol specific
</I>&gt;<i> &gt; firewall.
</I>&gt;<i> 
</I>&gt;<i> You have no firewall ability built into your router?
</I>from a puritanical perspective, no.  routing decisions are based on
layer 3 info.  ports are layer 4 info.  a true, layer 3 only router
would not make a good firewall at all.  that is not to say you cannot
enforce a security posture with a router, as part of an overall
strategy.
&gt;<i> 
</I>&gt;<i> &gt;  proxies also dont send the incoming traffic out an interface.
</I>&gt;<i> 
</I>&gt;<i> layer-3/4 interface is equivalent to layer-5/7 socket in abstract.
</I>your missing the point.  routers dont accept an incoming connection, and
initiate a separate outgoing connection, in order to facilitate the
end-to-end conversation.  proxies do.
&gt;<i> 
</I>&gt;<i> &gt; they terminate the client session, and initiate a new session on behalf
</I>&gt;<i> &gt; of the client.
</I>&gt;<i> 
</I>&gt;<i> not necessarily, that is the architectural difference between HTTP and
</I>&gt;<i> TCP. SOCKS proxies and TCP have much more in common in architectural design.
</I>&gt;<i> 
</I>&gt;<i> What the proxies do is terminate the *TCP* session. Obviously all
</I>&gt;<i> non-TCP protocols will do that.
</I>&gt;<i> The HTTP layer is more inline with UDP here than TCP. Although at the
</I>&gt;<i> layer just above HTTP there is the &quot;browsing session&quot; concept
</I>&gt;<i> implemented with cookies/auth etc which is retained across both TCP
</I>&gt;<i> layer connections. For cases where TCP-level sessions need to be
</I>&gt;<i> emulated there is connection pinning in the proxy.
</I>socks proxies are a different animal outside the scope of what i
intended to discuss.

http can be considered almost stateless, like udp, but it is still a
connection oriented protocol.  the sessions are generally short and
chatty.  these qualities are why CDNs work and can use anycast for load
distribution.
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt;  simply because the proxy can elect how to send a request
</I>&gt;<i> &gt; it is making on behalf of a client, does not make a proxy a router.
</I>&gt;<i> 
</I>&gt;<i> The names are terminology for the activity performed. TCP routers
</I>&gt;<i> normally do not re-selecting the destination endpoint, just the path.
</I>&gt;<i> The proxy selects the actual endpoint destination.
</I>&gt;<i> 
</I>&gt;<i> What you can configure each to do crosses over and you can specifically
</I>&gt;<i> configure a proxy to become a router, and vice versa. Doing it though
</I>&gt;<i> screws with their normal and optimal behavour. Router becomes like a
</I>&gt;<i> proxy by turning on NAT - and we probably both know the hell that
</I>&gt;<i> causes. Making a proxy do strictly router behaviour has a similar range
</I>&gt;<i> of nasty side effects.
</I>um, no.  NAT does not cause a connection to be proxied.  NAT is a header
rewrite operation, and the connection is from endpoint to endpoint.  it
is not proxied, where the router terminates the incoming connection and
initiates a new outgoing connection to facilitate the the conversation.
&gt;<i> 
</I>&gt;<i> Yes each one (proxy vs router) is designed to work at different levels,
</I>&gt;<i> in different ways. But how you use them determines what they do.
</I>&gt;<i> 
</I>&gt;<i> In particular this is the difference which you request is asking us to
</I>&gt;<i> provide a way to disable. Making the proxy return TCP RST if a
</I>&gt;<i> particular endpoint is not available - despite other endpoints
</I>&gt;<i> potentially being usable.
</I>&gt;<i>  Making the proxy behave like a router.
</I>i am looking for the load balancer to return the RST.  i asked what
others here may be doing in that space, if any are doing something.  you
provided an example of how to send a RST from a proxy when a proxy
cannot fulfill the request.
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt;  the
</I>&gt;<i> &gt; fact that one connection is terminated and a new one is initiated rules
</I>&gt;<i> &gt; out a proxy from being any kind of router, in my opinion.
</I>&gt;<i> 
</I>&gt;<i> That rules out all devices containing NAT functionality or LB software
</I>&gt;<i> from being routers.
</I>no, again NAT does not result in a terminated incoming connection and a
new outgoing connection.  Load balancing does do this as it is TCP
proxying of connections.  in many cases load balancers that do TCP
proxying are intelligent and aware of TCP based protocols such as SMTP,
LDAP, HTTP, etc.  it is this intelligence that i was hoping could be
tied to the TCP proxying piece, so as to reply with the RST on the
frontend when no backend server is available.
&gt;<i> 
</I>&gt;<i> &gt;  even with SSL
</I>&gt;<i> &gt; or the CONNECT Method, the connection is still made by the proxy to the
</I>&gt;<i> &gt; remote server.  the client never makes a connection to the remote
</I>&gt;<i> &gt; server, therefore the traffic was not routed.  it was proxied.
</I>&gt;<i> 
</I>&gt;<i> By definition CONNECT method is not a proxy. In particular it is the
</I>&gt;<i> request that the proxy stop being a HTTP proxy and become a tunnel / TCP
</I>&gt;<i> relay.
</I>even the CONNECT Method results in one incoming connection being
terminated, and new outgoing connection being initiated.  that is
proxying.
&gt;<i> It is roughly equivalent to a router sending packets down a tunnel / VPN
</I>&gt;<i> or SOCKS interface (the proxy is the outgoing end of the tunnel/VPN).
</I>no it isnt, because the router is not making the connection.  its
facilitating the connection. again no in and out connections.  the
endpoint sending the SYN is what is seen on the other end of the VPN as
making the connection.  while the packet may or may not be NAT'ed, the
connection is endpoint to endpoint.
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; my search for a load balancer solution went through ipvsadm, balance and
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; haproxy before i selected haproxy.  haproxy was more feature rich than
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; balance, and easier to implement than ipvsadm.  do any other list
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; members have a need for such a feature from their load balancers?  do
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; any other list members have site failover solutions that have been
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; tested or used and would consider sharing their design and/or pain
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; points?  i am not looking for secret sauce or confidential info, but
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; more high level architecture decisions and such.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I havent tested it but this should do what you are asking:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;  acl err http_status 500-505 408
</I>&gt;<i> &gt;&gt;  deny_info TCP_RESET err
</I>&gt;<i> &gt;&gt;  http_reply_access deny err
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; It replaces the response from Squid with a TCP RST packet.
</I>&gt;<i> &gt; this is useful in the case that the proxy is alive and well, but cannot
</I>&gt;<i> &gt; get to the internet.  in my example, the ISP issue would seem to be
</I>&gt;<i> &gt; covered, though i am not sure how the actual implementation would go.
</I>&gt;<i> &gt; the client has a TCP session established with the load balancer, which
</I>&gt;<i> &gt; gets the full SYN -&gt; SYN/ACK -&gt; ACK treatement.  the load balancer would
</I>&gt;<i> &gt; get the SYN -&gt; RST from the proxy, and presumably sends the RST back to
</I>&gt;<i> &gt; the client.  While this does seem to hold up logically, the
</I>&gt;<i> &gt; implementation may have nuances that have to be dealt with.  Does the
</I>&gt;<i> &gt; RST in the middle of an established TCP session cause the browser to
</I>&gt;<i> &gt; failover to the next proxy assigned?  i would have to test that out.
</I>&gt;<i> 
</I>&gt;<i> Nod.
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; now, what about the case where the proxies are not alive and well behind
</I>&gt;<i> &gt; the load balancer, and they are not able to reply with a RST?  This is
</I>&gt;<i> &gt; the scenario that i would want the load balancer to be able to manage.
</I>&gt;<i> &gt; this is where tying a layer 7 status to a layer 3/4 action on the load
</I>&gt;<i> &gt; balancer becomes relevant.  then, the ability for the load balancer to
</I>&gt;<i> &gt; do this negates the need to manage this in the proxy layer, and removes
</I>&gt;<i> &gt; any nuances that may be encountered with the implementation.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> That is a normal TCP error case. Same things happen if there is any
</I>&gt;<i> network level outage, or packets destined to a non-existent IP range. It
</I>&gt;<i> depends on the LB software what will be done about it.
</I>&gt;<i> 
</I>&gt;<i> Amos
</I>&gt;<i> 
</I>



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="002955.html">[squid-users] load balancing and site failover
</A></li>
	<LI>Next message (by thread): <A HREF="002924.html">[squid-users] I am seeing the following in my cache.log
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2958">[ date ]</a>
              <a href="thread.html#2958">[ thread ]</a>
              <a href="subject.html#2958">[ subject ]</a>
              <a href="author.html#2958">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
