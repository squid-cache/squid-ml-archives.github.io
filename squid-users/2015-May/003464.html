<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Youtube redirection loop?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Youtube%20redirection%20loop%3F&In-Reply-To=%3C5548946D.4080107%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003444.html">
   <LINK REL="Next"  HREF="003508.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Youtube redirection loop?</H1>
    <B>Yuri Voinov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Youtube%20redirection%20loop%3F&In-Reply-To=%3C5548946D.4080107%40gmail.com%3E"
       TITLE="[squid-users] Youtube redirection loop?">yvoinov at gmail.com
       </A><BR>
    <I>Tue May  5 09:59:09 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="003444.html">[squid-users] Youtube redirection loop?
</A></li>
        <LI>Next message (by thread): <A HREF="003508.html">[squid-users] Youtube redirection loop?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3464">[ date ]</a>
              <a href="thread.html#3464">[ thread ]</a>
              <a href="subject.html#3464">[ subject ]</a>
              <a href="author.html#3464">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

05.05.15 4:07, HackXBack &#1087;&#1080;&#1096;&#1077;&#1090;:
&gt;<i> Okay Sir,
</I>&gt;<i> this is the solution
</I>&gt;<i>
</I>&gt;<i> 1st: put this conf in your squid.conf
</I>&gt;<i>
</I>&gt;<i> ####for looping 302 on youtube
</I>&gt;<i> acl text-html rep_mime_type text/html
</I>&gt;<i> acl http302 http_status 302
</I>&gt;<i> store_miss deny text-html
</I>&gt;<i> store_miss deny http302
</I>&gt;<i> send_hit deny text-html
</I>&gt;<i> send_hit deny http302
</I>This works on 3.5.x and above only. store_* directives absent in 3.4.x 
series.
&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 2nd: use this patch:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --- src/client_side_request.cc  2014-03-09 06:40:56.000000000 -0300
</I>&gt;<i> +++ src/client_side_request.cc  2014-04-21 02:53:11.277155130 -0300
</I>&gt;<i> @@ -545,6 +545,16 @@
</I>&gt;<i>               }
</I>&gt;<i>               debugs(85, 3, HERE &lt;&lt; &quot;validate IP &quot; &lt;&lt; clientConn-&gt;local &lt;&lt; &quot;
</I>&gt;<i> non-match from Host: IP &quot; &lt;&lt; ia-&gt;in_addrs[i]);
</I>&gt;<i>           }
</I>&gt;<i> +
</I>&gt;<i> +        if (true) {
</I>&gt;<i> +            unsigned short port = clientConn-&gt;local.port();
</I>&gt;<i> +            debugs(85, 3, HERE &lt;&lt; &quot;[anti-forgery] Host-non-matched remote
</I>&gt;<i> IP (&quot; &lt;&lt; clientConn-&gt;local &lt;&lt; &quot;) was replaced with the first Host resolved
</I>&gt;<i> IP (&quot; &lt;&lt; ia-&gt;in_addrs[0] &lt;&lt; &quot;:&quot; &lt;&lt; clientConn-&gt;local.port() &lt;&lt; &quot;)&quot;);
</I>&gt;<i> +            clientConn-&gt;local = ia-&gt;in_addrs[0];
</I>&gt;<i> +            clientConn-&gt;local.port(port);
</I>&gt;<i> +            http-&gt;request-&gt;flags.hostVerified = true;
</I>&gt;<i> +            http-&gt;doCallouts();
</I>&gt;<i> +            return;
</I>&gt;<i> +        }
</I>&gt;<i>       }
</I>&gt;<i>       debugs(85, 3, HERE &lt;&lt; &quot;FAIL: validate IP &quot; &lt;&lt; clientConn-&gt;local &lt;&lt; &quot;
</I>&gt;<i> possible from Host:&quot;);
</I>&gt;<i>       hostHeaderVerifyFailed(&quot;local IP&quot;, &quot;any domain IP&quot;);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --- src/Server.cc
</I>&gt;<i> +++ src/Server.cc
</I>&gt;<i> @@ -31,6 +31,7 @@
</I>&gt;<i>    */
</I>&gt;<i>   
</I>&gt;<i>   #include &quot;squid.h&quot;
</I>&gt;<i> +#include &quot;acl/FilledChecklist.h&quot;
</I>&gt;<i>   #include &quot;acl/Gadgets.h&quot;
</I>&gt;<i>   #include &quot;base/TextException.h&quot;
</I>&gt;<i>   #include &quot;comm/Connection.h&quot;
</I>&gt;<i> @@ -174,6 +175,8 @@
</I>&gt;<i>       // give entry the reply because haveParsedReplyHeaders() expects it
</I>&gt;<i> there
</I>&gt;<i>       entry-&gt;replaceHttpReply(theFinalReply, false); // but do not write yet
</I>&gt;<i>       haveParsedReplyHeaders(); // update the entry/reply (e.g., set
</I>&gt;<i> timestamps)
</I>&gt;<i> +    if (EBIT_TEST(entry-&gt;flags, ENTRY_CACHABLE) &amp;&amp; blockCaching())
</I>&gt;<i> +        entry-&gt;release();
</I>&gt;<i>       entry-&gt;startWriting(); // write the updated entry to store
</I>&gt;<i>   
</I>&gt;<i>       return theFinalReply;
</I>&gt;<i> @@ -533,6 +536,24 @@
</I>&gt;<i>       currentOffset = partial ? theFinalReply-&gt;content_range-&gt;spec.offset :
</I>&gt;<i> 0;
</I>&gt;<i>   }
</I>&gt;<i>   
</I>&gt;<i> +/// whether to prevent caching of an otherwise cachable response
</I>&gt;<i> +bool
</I>&gt;<i> +ServerStateData::blockCaching()
</I>&gt;<i> +{
</I>&gt;<i> +    if (const Acl::Tree *acl = Config.accessList.storeMiss) {
</I>&gt;<i> +        // This relatively expensive check is not in
</I>&gt;<i> StoreEntry::checkCachable:
</I>&gt;<i> +        // That method lacks HttpRequest and may be called too many times.
</I>&gt;<i> +        ACLFilledChecklist ch(acl, originalRequest(), NULL);
</I>&gt;<i> +        ch.reply = const_cast&lt;HttpReply*&gt;(entry-&gt;getReply()); //
</I>&gt;<i> ACLFilledChecklist API bug
</I>&gt;<i> +        HTTPMSGLOCK(ch.reply);
</I>&gt;<i> +        if (ch.fastCheck() != ACCESS_ALLOWED) { // when in doubt, block
</I>&gt;<i> +            debugs(20, 3, &quot;store_miss prohibits caching&quot;);
</I>&gt;<i> +            return true;
</I>&gt;<i> +        }
</I>&gt;<i> +    }
</I>&gt;<i> +    return false;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>   HttpRequest *
</I>&gt;<i>   ServerStateData::originalRequest()
</I>&gt;<i>   {
</I>&gt;<i> --- src/Server.h
</I>&gt;<i> +++ src/Server.h
</I>&gt;<i> @@ -131,6 +131,8 @@
</I>&gt;<i>       /// Entry-dependent callbacks use this check to quit if the entry went
</I>&gt;<i> bad
</I>&gt;<i>       bool abortOnBadEntry(const char *abortReason);
</I>&gt;<i>   
</I>&gt;<i> +    bool blockCaching();
</I>&gt;<i> +
</I>&gt;<i>   #if USE_ADAPTATION
</I>&gt;<i>       void startAdaptation(const Adaptation::ServiceGroupPointer &amp;group,
</I>&gt;<i> HttpRequest *cause);
</I>&gt;<i>       void adaptVirginReplyBody(const char *buf, ssize_t len);
</I>&gt;<i> --- src/SquidConfig.h
</I>&gt;<i> +++ src/SquidConfig.h
</I>&gt;<i> @@ -375,6 +375,8 @@
</I>&gt;<i>           acl_access *AlwaysDirect;
</I>&gt;<i>           acl_access *ASlists;
</I>&gt;<i>           acl_access *noCache;
</I>&gt;<i> +        acl_access *sendHit;
</I>&gt;<i> +        acl_access *storeMiss;
</I>&gt;<i>           acl_access *stats_collection;
</I>&gt;<i>   #if SQUID_SNMP
</I>&gt;<i>   
</I>&gt;<i> --- src/cf.data.pre
</I>&gt;<i> +++ src/cf.data.pre
</I>&gt;<i> @@ -4843,18 +4843,97 @@
</I>&gt;<i>   NAME: cache no_cache
</I>&gt;<i>   TYPE: acl_access
</I>&gt;<i>   DEFAULT: none
</I>&gt;<i> -DEFAULT_DOC: Allow caching, unless rules exist in squid.conf.
</I>&gt;<i> +DEFAULT_DOC: By default, this directive is unused and has no effect.
</I>&gt;<i>   LOC: Config.accessList.noCache
</I>&gt;<i>   DOC_START
</I>&gt;<i> -	A list of ACL elements which, if matched and denied, cause the request to
</I>&gt;<i> -	not be satisfied from the cache and the reply to not be cached.
</I>&gt;<i> -	In other words, use this to force certain objects to never be cached.
</I>&gt;<i> -
</I>&gt;<i> -	You must use the words 'allow' or 'deny' to indicate whether items
</I>&gt;<i> -	matching the ACL should be allowed or denied into the cache.
</I>&gt;<i> +	Requests denied by this directive will not be served from the cache
</I>&gt;<i> +	and their responses will not be stored in the cache. This directive
</I>&gt;<i> +	has no effect on other transactions and on already cached responses.
</I>&gt;<i>   
</I>&gt;<i>   	This clause supports both fast and slow acl types.
</I>&gt;<i>   	See <A HREF="http://wiki.squid-cache.org/SquidFaq/SquidAcl">http://wiki.squid-cache.org/SquidFaq/SquidAcl</A> for details.
</I>&gt;<i> +
</I>&gt;<i> +	This and the two other similar caching directives listed below are
</I>&gt;<i> +	checked at different transaction processing stages, have different
</I>&gt;<i> +	access to response information, affect different cache operations,
</I>&gt;<i> +	and differ in slow ACLs support:
</I>&gt;<i> +
</I>&gt;<i> +	* cache: Checked before Squid makes a hit/miss determination.
</I>&gt;<i> +		No access to reply information!
</I>&gt;<i> +		Denies both serving a hit and storing a miss.
</I>&gt;<i> +		Supports both fast and slow ACLs.
</I>&gt;<i> +	* send_hit: Checked after a hit was detected.
</I>&gt;<i> +		Has access to reply (hit) information.
</I>&gt;<i> +		Denies serving a hit only.
</I>&gt;<i> +		Supports fast ACLs only.
</I>&gt;<i> +	* store_miss: Checked before storing a cachable miss.
</I>&gt;<i> +		Has access to reply (miss) information.
</I>&gt;<i> +		Denies storing a miss only.
</I>&gt;<i> +		Supports fast ACLs only.
</I>&gt;<i> +
</I>&gt;<i> +	If you are not sure which of the three directives to use, apply the
</I>&gt;<i> +	following decision logic:
</I>&gt;<i> +
</I>&gt;<i> +	* If your ACL(s) are of slow type _and_ need response info, redesign.
</I>&gt;<i> +	  Squid does not support that particular combination at this time.
</I>&gt;<i> +        Otherwise:
</I>&gt;<i> +	* If your directive ACL(s) are of slow type, use &quot;cache&quot;; and/or
</I>&gt;<i> +	* if your directive ACL(s) need no response info, use &quot;cache&quot;.
</I>&gt;<i> +        Otherwise:
</I>&gt;<i> +	* If you do not want the response cached, use store_miss; and/or
</I>&gt;<i> +	* if you do not want a hit on a cached response, use send_hit.
</I>&gt;<i> +DOC_END
</I>&gt;<i> +
</I>&gt;<i> +NAME: send_hit
</I>&gt;<i> +TYPE: acl_access
</I>&gt;<i> +DEFAULT: none
</I>&gt;<i> +DEFAULT_DOC: By default, this directive is unused and has no effect.
</I>&gt;<i> +LOC: Config.accessList.sendHit
</I>&gt;<i> +DOC_START
</I>&gt;<i> +	Responses denied by this directive will not be served from the cache
</I>&gt;<i> +	(but may still be cached, see store_miss). This directive has no
</I>&gt;<i> +	effect on the responses it allows and on the cached objects.
</I>&gt;<i> +
</I>&gt;<i> +	Please see the &quot;cache&quot; directive for a summary of differences among
</I>&gt;<i> +	store_miss, send_hit, and cache directives.
</I>&gt;<i> +
</I>&gt;<i> +	Unlike the &quot;cache&quot; directive, send_hit only supports fast acl
</I>&gt;<i> +	types.  See <A HREF="http://wiki.squid-cache.org/SquidFaq/SquidAcl">http://wiki.squid-cache.org/SquidFaq/SquidAcl</A> for details.
</I>&gt;<i> +
</I>&gt;<i> +	For example:
</I>&gt;<i> +
</I>&gt;<i> +		# apply custom Store ID mapping to some URLs
</I>&gt;<i> +		acl MapMe dstdomain .c.example.com
</I>&gt;<i> +		store_id_program ...
</I>&gt;<i> +		store_id_access allow MapMe
</I>&gt;<i> +
</I>&gt;<i> +		# but prevent caching of special responses
</I>&gt;<i> +		# such as 302 redirects that cause StoreID loops
</I>&gt;<i> +		acl Ordinary http_status 200-299
</I>&gt;<i> +		store_miss deny MapMe !Ordinary
</I>&gt;<i> +
</I>&gt;<i> +		# and do not serve any previously stored special responses
</I>&gt;<i> +		# from the cache (in case they were already cached before
</I>&gt;<i> +		# the above store_miss rule was in effect).
</I>&gt;<i> +		send_hit deny MapMe !Ordinary
</I>&gt;<i> +DOC_END
</I>&gt;<i> +
</I>&gt;<i> +NAME: store_miss
</I>&gt;<i> +TYPE: acl_access
</I>&gt;<i> +DEFAULT: none
</I>&gt;<i> +DEFAULT_DOC: By default, this directive is unused and has no effect.
</I>&gt;<i> +LOC: Config.accessList.storeMiss
</I>&gt;<i> +DOC_START
</I>&gt;<i> +	Responses denied by this directive will not be cached (but may still
</I>&gt;<i> +	be served from the cache, see send_hit). This directive has no
</I>&gt;<i> +	effect on the responses it allows and on the already cached responses.
</I>&gt;<i> +
</I>&gt;<i> +	Please see the &quot;cache&quot; directive for a summary of differences among
</I>&gt;<i> +	store_miss, send_hit, and cache directives. See the
</I>&gt;<i> +	send_hit directive for a usage example.
</I>&gt;<i> +
</I>&gt;<i> +	Unlike the &quot;cache&quot; directive, store_miss only supports fast acl
</I>&gt;<i> +	types.  See <A HREF="http://wiki.squid-cache.org/SquidFaq/SquidAcl">http://wiki.squid-cache.org/SquidFaq/SquidAcl</A> for details.
</I>&gt;<i>   DOC_END
</I>&gt;<i>   
</I>&gt;<i>   NAME: max_stale
</I>&gt;<i> --- src/client_side_reply.cc
</I>&gt;<i> +++ src/client_side_reply.cc
</I>&gt;<i> @@ -545,6 +545,11 @@
</I>&gt;<i>          ) {
</I>&gt;<i>           http-&gt;logType = LOG_TCP_NEGATIVE_HIT;
</I>&gt;<i>           sendMoreData(result);
</I>&gt;<i> +    } else if (blockedHit()) {
</I>&gt;<i> +        debugs(88, 5, &quot;send_hit forces a MISS&quot;);
</I>&gt;<i> +        http-&gt;logType = LOG_TCP_MISS;
</I>&gt;<i> +        processMiss();
</I>&gt;<i> +        return;
</I>&gt;<i>       } else if (!http-&gt;flags.internal &amp;&amp; refreshCheckHTTP(e, r)) {
</I>&gt;<i>           debugs(88, 5, &quot;clientCacheHit: in refreshCheck() block&quot;);
</I>&gt;<i>           /*
</I>&gt;<i> @@ -773,6 +778,30 @@
</I>&gt;<i>       }
</I>&gt;<i>   }
</I>&gt;<i>   
</I>&gt;<i> +/// whether squid.conf send_hit prevents us from serving this hit
</I>&gt;<i> +bool
</I>&gt;<i> +clientReplyContext::blockedHit() const
</I>&gt;<i> +{
</I>&gt;<i> +    if (!Config.accessList.sendHit)
</I>&gt;<i> +        return false; // hits are not blocked by default
</I>&gt;<i> +
</I>&gt;<i> +    if (http-&gt;flags.internal)
</I>&gt;<i> +        return false; // internal content &quot;hits&quot; cannot be blocked
</I>&gt;<i> +
</I>&gt;<i> +    if (const HttpReply *rep = http-&gt;storeEntry()-&gt;getReply()) {
</I>&gt;<i> +        std::auto_ptr&lt;ACLFilledChecklist&gt;
</I>&gt;<i> chl(clientAclChecklistCreate(Config.accessList.sendHit, http));
</I>&gt;<i> +        chl-&gt;reply = const_cast&lt;HttpReply*&gt;(rep); // ACLChecklist API bug
</I>&gt;<i> +        HTTPMSGLOCK(chl-&gt;reply);
</I>&gt;<i> +        return chl-&gt;fastCheck() != ACCESS_ALLOWED; // when in doubt, block
</I>&gt;<i> +    }
</I>&gt;<i> +
</I>&gt;<i> +    // This does not happen, I hope, because we are called from CacheHit,
</I>&gt;<i> which
</I>&gt;<i> +    // is called via a storeClientCopy() callback, and store should
</I>&gt;<i> initialize
</I>&gt;<i> +    // the reply before calling that callback.
</I>&gt;<i> +    debugs(88, 3, &quot;Missing reply!&quot;);
</I>&gt;<i> +    return false;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>   void
</I>&gt;<i>   clientReplyContext::purgeRequestFindObjectToPurge()
</I>&gt;<i>   {
</I>&gt;<i> --- src/client_side_reply.h
</I>&gt;<i> +++ src/client_side_reply.h
</I>&gt;<i> @@ -140,6 +140,7 @@
</I>&gt;<i>       void triggerInitialStoreRead();
</I>&gt;<i>       void sendClientOldEntry();
</I>&gt;<i>       void purgeAllCached();
</I>&gt;<i> +    bool blockedHit() const;
</I>&gt;<i>   
</I>&gt;<i>       void sendBodyTooLargeError();
</I>&gt;<i>       void sendPreconditionFailedError();
</I>This is also not solution. One of most biggest traffic source must have 
native solution in proxy. Not a crutch.
&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> View this message in context: <A HREF="http://squid-web-proxy-cache.1019090.n4.nabble.com/Youtube-redirection-loop-tp4671084p4671103.html">http://squid-web-proxy-cache.1019090.n4.nabble.com/Youtube-redirection-loop-tp4671084p4671103.html</A>
</I>&gt;<i> Sent from the Squid - Users mailing list archive at Nabble.com.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>
Again. I want simple thing: to limit selected mime-types caching from 
selected domains. Point.
On my opinion, this will completely solve YT caching problem without any 
crutches/patches.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="003444.html">[squid-users] Youtube redirection loop?
</A></li>
	<LI>Next message (by thread): <A HREF="003508.html">[squid-users] Youtube redirection loop?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3464">[ date ]</a>
              <a href="thread.html#3464">[ thread ]</a>
              <a href="subject.html#3464">[ subject ]</a>
              <a href="author.html#3464">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
