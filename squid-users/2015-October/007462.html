<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Inconsistent accessing of the cache, craigslist.org images, wacky stuff.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Inconsistent%20accessing%20of%20the%20cache%2C%0A%20craigslist.org%20images%2C%20wacky%20stuff.&In-Reply-To=%3C563338E5.8010603%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007459.html">
   <LINK REL="Next"  HREF="007374.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Inconsistent accessing of the cache, craigslist.org images, wacky stuff.</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Inconsistent%20accessing%20of%20the%20cache%2C%0A%20craigslist.org%20images%2C%20wacky%20stuff.&In-Reply-To=%3C563338E5.8010603%40treenet.co.nz%3E"
       TITLE="[squid-users] Inconsistent accessing of the cache, craigslist.org images, wacky stuff.">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Oct 30 09:31:17 UTC 2015</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="007459.html">[squid-users] Inconsistent accessing of the cache, craigslist.org images, wacky stuff.
</A></li>
        <LI>Next message (by thread): <A HREF="007374.html">[squid-users] Inconsistent accessing of the cache,	craigslist.org images, wacky stuff.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7462">[ date ]</a>
              <a href="thread.html#7462">[ thread ]</a>
              <a href="subject.html#7462">[ subject ]</a>
              <a href="author.html#7462">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 30/10/2015 4:09 p.m., Jester Purtteman wrote:
&gt;<i> 
</I>&gt;<i> We've got a couple thoughts going at once here, so let me condense it
</I>&gt;<i> a bit.  First, yes, this is coming in over a satellite and that is
</I>&gt;<i> part of the bugger.  Nothing like 560 ms to bring a connection to a
</I>&gt;<i> halt.  Part of my plan is exactly as you say, optimize the links by
</I>&gt;<i> setting huge tcp_windows and all the rest so that I can get full
</I>&gt;<i> bandwidth.  The other part of the story (and I could just be
</I>&gt;<i> misunderstanding this too) is that it appears that if I have say, 3
</I>&gt;<i> or 4 clients connect for a file over the course of the period of the
</I>&gt;<i> download, if any one of them (or maybe just the last one, again,
</I>&gt;<i> insufficient testing so I don't know the exactly course of events
</I>&gt;<i> here) ends up requesting an IP different than what is looked up, it
</I>&gt;<i> appeared to drop the file.
</I>
If this is a big problem you can try &quot;collapsed_forwarding on&quot;.

It has a few annoying bugs of its own still. One of which is that it
could slow down collapsed requests even more if the response turns out
to be non-cacheable or unusable for that client. But it would resolve
the situation above. YMMV.

&gt;<i> 
</I>&gt;&gt;<i> I think a worse problem is if the DNS TTL is shorter than a client
</I>&gt;&gt;<i> connections TCP connected time. Then requests arriving after the
</I>&gt;&gt;<i> DNS TTL expired would no longer match the initial dst-IP.
</I>&gt;<i> 
</I>&gt;<i> That is what I think I was seeing:  if by that you mean, clients A,
</I>&gt;<i> B, and C all request a large file (few hundred MB), it downloads but
</I>&gt;<i> takes more than 300 seconds (which has become a pretty common TTL,
</I>&gt;<i> when did that happen?), and then D requests it too, but the DNS
</I>&gt;<i> updates while its coming in and suddenly gets flagged as a host
</I>&gt;<i> forgery and is no longer cacheable.  I could be wrong, so I need to
</I>&gt;<i> experiment, but I think that&#8217;s what I am seeing.
</I>&gt;<i> 
</I>&gt;<i> My crazy solution is, I have a server on a fast connection on which I
</I>&gt;<i> setup a cache there with a pretty big minimum and maximum file size
</I>&gt;<i> (say, 10 MB minimum object size, 8,000MB maximum) and set it up as a
</I>&gt;<i> parent cache to the cache out at the slow end of the universe, which
</I>&gt;<i> is a transparent proxy.  The transparent proxy then uses the parent
</I>&gt;<i> proxy to request the files, and when the files happen to be very big,
</I>&gt;<i> I set up the connection to do a pre-cache (because a 100 MB file is a
</I>&gt;<i> piece of cake for a 100 mbps connection) and it stores it, because
</I>&gt;<i> the time to download was trivial compared to the DNS TTL.  I set the
</I>&gt;<i> cache up no the slow end to cache more aggressively, but the point is
</I>&gt;<i> that once the cache down south has the file, the cache up north is
</I>&gt;<i> requesting the file from a system much more optimized to pull big
</I>&gt;<i> files over, and that improves the odds that the DNS has not updated
</I>&gt;<i> before the transfer completes.
</I>&gt;<i> 
</I>&gt;<i> I'm not convinced my idea is valid, so I'll have to ponder it a bit,
</I>&gt;<i> but I'm going to give it a shot and let you know if it makes a
</I>&gt;<i> difference.  Bottom line is, it is a pretty nasty work around, and
</I>&gt;<i> there is probably a better solution if someone that knows C out there
</I>&gt;<i> worth beans is into it.  I don't think there are ANY answers that
</I>&gt;<i> don't involve setting up your own DNS, but after configuring BIND in
</I>&gt;<i> about 7 minutes last night, I am thinking that&#8217;s not a big issue.
</I>&gt;<i> The obvious answers I can think of are (1) to maintain a short table
</I>&gt;<i> of IPs associated with a specific domain request until all transfers
</I>&gt;<i> referring back to it have passed and rewrite the DNS resolution calls
</I>&gt;<i> to refer to that table or (2) tag the requested IP and resolved IP.
</I>
Unfortunately in a busy proxy very popular domains stay popular and have
outstanding requests almost all the time. If they have a short outage or
migrate to other IPs (like the cloud and CDN services causing this
grief) then the proxy is left sending new requests to dead servers and
the clients see a lot of extra unnecessary breakage.

&gt;<i> 
</I>&gt;<i> The last line of C I wrote was in the 90s, but I'll dig in and see if
</I>&gt;<i> I can find the right place to start making a mess :).
</I>&gt;<i> 
</I>
Of my ideas the simplest to put together would be to tie the intercepted
connection to the single Host header value that got verified.

To work on that you need to edit src/client_side_request.cc, look for
the hostVerify methods. When a verify passes add the confirmed hostname
to the ConnStateData object (src/client_side.h), and use that stored
value to accept as verified the furture requests have the same Host
value as seen before, instead of re-doing DNS lookups on the 2nd, 3rd
etc requests.


&gt;<i> In any event, you and Eliezer have helped me get farther since
</I>&gt;<i> Tuesday night than I had since August, Thank you both!
</I>&gt;<i> 
</I>
Welcome, thats what we are here for. :-)

Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="007459.html">[squid-users] Inconsistent accessing of the cache, craigslist.org images, wacky stuff.
</A></li>
	<LI>Next message (by thread): <A HREF="007374.html">[squid-users] Inconsistent accessing of the cache,	craigslist.org images, wacky stuff.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7462">[ date ]</a>
              <a href="thread.html#7462">[ thread ]</a>
              <a href="subject.html#7462">[ subject ]</a>
              <a href="author.html#7462">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
