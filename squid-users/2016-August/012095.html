<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] dynamic group using URI as group name on external acl with ext_ldap_group_acl
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20dynamic%20group%20using%20URI%20as%20group%20name%20on%20external%0A%20acl%20with%20ext_ldap_group_acl&In-Reply-To=%3C458f56ba-1312-73f7-0951-d62d74090a67%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012092.html">
   <LINK REL="Next"  HREF="012101.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] dynamic group using URI as group name on external acl with ext_ldap_group_acl</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20dynamic%20group%20using%20URI%20as%20group%20name%20on%20external%0A%20acl%20with%20ext_ldap_group_acl&In-Reply-To=%3C458f56ba-1312-73f7-0951-d62d74090a67%40treenet.co.nz%3E"
       TITLE="[squid-users] dynamic group using URI as group name on external acl with ext_ldap_group_acl">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Aug 22 14:49:26 UTC 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="012092.html">[squid-users] dynamic group using URI as group name on external acl	with ext_ldap_group_acl
</A></li>
        <LI>Next message (by thread): <A HREF="012101.html">[squid-users] dynamic group using URI as group name on external acl with ext_ldap_group_acl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12095">[ date ]</a>
              <a href="thread.html#12095">[ thread ]</a>
              <a href="subject.html#12095">[ subject ]</a>
              <a href="author.html#12095">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 22/08/2016 10:54 a.m., Diogenes S. Jesus wrote:
&gt;<i> Hi everyone.
</I>&gt;<i> 
</I>&gt;<i> I've the following use case to be accomplished using ACL:
</I>&gt;<i> 
</I>&gt;<i> - Allow any authenticated user who is member of a group named after the URI
</I>&gt;<i> 
</I>&gt;<i> To construct this I've built the following squid.conf (snippet):
</I>&gt;<i> 
</I>&gt;<i> ---------
</I>&gt;<i> auth_param negotiate program /usr/lib/squid3/negotiate_kerberos_auth -d -r
</I>&gt;<i> auth_param negotiate children 10
</I>&gt;<i> auth_param negotiate keep_alive on
</I>&gt;<i> 
</I>&gt;<i> external_acl_type ldap_HTTP %LOGIN %URI
</I>&gt;<i> /usr/lib/squid/ext_ldap_group_acl -D &quot;cn=admin,dc=example,dc=com&quot; -w
</I>&gt;<i> test -R -b &quot;ou=authorization,dc=example,dc=com&quot; -B
</I>&gt;<i> &quot;ou=people,dc=example,dc=com&quot; -f
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(cn=%g)(member=uid=%u,ou=people,dc=example,dc=com))'
</I>&gt;<i> -h ldap01.example.com -d
</I>

Please be aware that the %URI format does not perform any type of shell
or LDAP escaping to protect this helper lookup against shell-injection
attacks.

It is possible that a remote client can end a URL with ')' followed by
any LDAP commands they like and have that executed by your helper.

If you want to do things like this safely please upgrade to Squid-4
where the logformat codes are available. Those codes provide
customizable escaping and quoting styles so you can set one that
protects LDAP against these attacks to be ued on the URI field value
sent by Squid.


&gt;<i> 
</I>&gt;<i> acl allow_HTTP_ACL external ldap_HTTP &quot;&quot;
</I>&gt;<i> 
</I>&gt;<i> http_access deny !allow_HTTP_ACL all
</I>&gt;<i> http_access allow allow_HTTP_ACL
</I>&gt;<i> http_access deny all
</I>&gt;<i> ---------
</I>&gt;<i> 
</I>&gt;<i> I call it a &quot;dynamic&quot; acl, because the value of the group is the
</I>&gt;<i> actual URI
</I>
Whereas everyone else calls it dynamic because the ACL test is highly
variable (aka dynamic) based on whatever the custom helper logic is.


&gt;<i> (the search filter will expand like:
</I>&gt;<i> cn=&lt;URI&gt;,ou=authorization,dc=example,dc=com). For that
</I>&gt;<i> &quot;allow_HTTP_ACL&quot; passes &quot;&quot; to ldap_HTTP.
</I>&gt;<i> 
</I>&gt;<i> This is working, however that's not documented. I was wondering how
</I>&gt;<i> this works, so I debugged.
</I>&gt;<i> 
</I>&gt;<i> I found out the %&lt;template filter var&gt; expands as following for the
</I>&gt;<i> following search filter:
</I>&gt;<i> -f '(&amp;(objectclass=groupOfNames)(&lt;template_filter_reference&gt;=%&lt;template_filter&gt;)(member=uid=%u,ou=people,dc=example,dc=com))'
</I>&gt;<i> 
</I>...
&gt;<i> 
</I>&gt;<i> 4) '(&amp;(objectclass=groupOfNames)(test=%test)(member=uid=%u,ou=people,dc=example,dc=com))':
</I>&gt;<i> ERROR: Unknown filter template string %t
</I>&gt;<i> ext_ldap_group_acl: ERROR: Failed to construct LDAP search filter.
</I>&gt;<i> filter=&quot;(&amp;(objectclass=groupOfNames)(test=?,?U&quot;, user=&quot;john_doe&quot;,
</I>&gt;<i> group=&quot;<A HREF="http://web.example.com/">http://web.example.com/</A>&quot;
</I>&gt;<i> ERROR: Unknown filter template string %t
</I>&gt;<i> ext_ldap_group_acl: ERROR: Failed to construct LDAP search filter.
</I>&gt;<i> filter=&quot;(&amp;(objectclass=groupOfNames)(test=?,?U&quot;, user=&quot;john_doe&quot;,
</I>&gt;<i> group=&quot;GET&quot;
</I>&gt;<i> ERROR: Unknown filter template string %t
</I>&gt;<i> ext_ldap_group_acl: ERROR: Failed to construct LDAP search filter.
</I>&gt;<i> filter=&quot;(&amp;(objectclass=groupOfNames)(test=?,?U&quot;, user=&quot;john_doe&quot;,
</I>&gt;<i> group=&quot;80&quot;
</I>&gt;<i> 
</I>&gt;<i> 5) '(&amp;(objectclass=groupOfNames)(v=%v)(member=uid=%u,ou=people,dc=example,dc=com))':
</I>&gt;<i> ext_ldap_group_acl.cc(718): pid=26314 :group filter
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(v=john_doe)(member=uid=john_doe,ou=people,dc=example,dc=com))',
</I>&gt;<i> searchbase 'ou=authorization,dc=example,dc=com'
</I>&gt;<i> ext_ldap_group_acl.cc(718): pid=26314 :group filter
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(v=john_doe)(member=uid=john_doe,ou=people,dc=example,dc=com))',
</I>&gt;<i> searchbase 'ou=authorization,dc=example,dc=com'
</I>&gt;<i> ext_ldap_group_acl.cc(718): pid=26314 :group filter
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(v=john_doe)(member=uid=john_doe,ou=people,dc=example,dc=com))',
</I>&gt;<i> searchbase 'ou=authorization,dc=example,dc=com'
</I>&gt;<i> 
</I>

I dont think you quite grok which part of these outputs is the garbage
(uninitialized memory dump), and which part is the incomplete prefix of
the filter string.

Notice the above 'garbage' outputs start with:
 filter=&quot;(&amp;(objectclass=groupOfNames)(test=

then obvious garbage:
 ?,?U&quot;, user=&quot;john_doe&quot;, group=&quot;GET&quot;

Its not always obvious. As in case #6:


&gt;<i> 
</I>&gt;<i> 6) '(&amp;(objectclass=groupOfNames)(g=%g)(member=uid=%u,ou=people,dc=example,dc=com))':
</I>&gt;<i> ext_ldap_group_acl.cc(718): pid=26408 :group filter
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(g=<A HREF="http://web.example.com/">http://web.example.com/</A>)(member=uid=john_doe,ou=people,dc=example,dc=com))',
</I>&gt;<i> searchbase 'ou=authorization,dc=example,dc=com'
</I>&gt;<i> ext_ldap_group_acl.cc(718): pid=26408 :group filter
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(g=GET)(member=uid=john_doe,ou=people,dc=example,dc=com))',
</I>&gt;<i> searchbase 'ou=authorization,dc=example,dc=com'
</I>&gt;<i> ext_ldap_group_acl.cc(718): pid=26408 :group filter
</I>&gt;<i> '(&amp;(objectclass=groupOfNames)(g=80)(member=uid=john_doe,ou=people,dc=example,dc=com))',
</I>&gt;<i> searchbase 'ou=authorization,dc=example,dc=com'
</I>
What is happening is that the helper expects the %LOGIN field to be
followed by a list of space-separated 'words'. Each 'word' is a group
name to be checked against the users account memberships. So the list of
words is looked up individually until one matches or none left to check.

So somehow the HTTP request URL/URI is the whole string:
 &quot;GET <A HREF="http://web.example.com/">http://web.example.com/</A> 80&quot;

-&gt; very odd. It is not even a valid HTTP request-line. Looks more like
some outdated Squid-1.1 URL re-write helper is mangling the URL. But the
order is slightly wrong even for that (GET would be after the actual URL).


Anyhow, that resuls in the ACL group helper receiving:
 john_does GET <A HREF="http://web.example.com/">http://web.example.com/</A> 80

Meaning,
 username: &quot;john_doe&quot;
 group #1: &quot;GET&quot;
 group #2: &quot;<A HREF="http://web.example.com/">http://web.example.com/</A>&quot;
 group #3: &quot;80&quot;


&gt;<i> 
</I>&gt;<i> This is all pretty much happening here
</I>&gt;<i> [<A HREF="https://github.com/squid-cache/squid/blob/master/helpers/external_acl/LDAP_group/ext_ldap_group_acl.cc#L638">https://github.com/squid-cache/squid/blob/master/helpers/external_acl/LDAP_group/ext_ldap_group_acl.cc#L638</A>]
</I>&gt;<i> 
</I>&gt;<i> So conclusions:
</I>&gt;<i> - %v and %u both map to &quot;user&quot;, which is expected (historical reasons
</I>&gt;<i> &amp; compatibility)
</I>
As documented.

&gt;<i> - %g and %a both map to &quot;group&quot;, which is expected (historical reasons
</I>&gt;<i> &amp; compatibility)
</I>
As documented.

&gt;<i> - any other template filter (%b, %c, %test, etc) is trash (only %a,
</I>&gt;<i> %u, %g, %v won't yield error)
</I>
Nod. The helper autor(s) reserve other %-code to be defined with any
arbitrary meaning at any time. So there is simply no documented
behaviour for them.
 A you found v and a have old meanings that are still supported, though
deprecated so removed from the documentation intentionally to prevent
future use.


&gt;<i> - when &quot;&quot; is passed to the acl (&quot;acl &lt;ACL_name&gt; external ldap_HTTP
</I>&gt;<i> &quot;&quot;), the helper will attempt all FORMAT values, mapping then to
</I>&gt;<i> &quot;group&quot; (%a or %g)
</I>
It should mean Squid loads a file with undefined name (\0) and sends
that files content as the list of group names. Each line in the file
being a group name.


&gt;<i> 
</I>&gt;<i> Although I can move on with this for now, I would be actually more
</I>&gt;<i> relieved if I could use:
</I>&gt;<i> acl allow_HTTP_ACL external ldap_HTTP
</I>&gt;<i> &lt;a_var_which_is_available_here_representing_URI&gt;
</I>&gt;<i>  instead of
</I>&gt;<i> acl allow_HTTP_ACL external ldap_HTTP &quot;&quot;  + non-documented behavior of
</I>&gt;<i> ext_ldap_group_acl
</I>
Dont specify anything at all in that position. The %URI field you
defined to be sent to the helper should be formatted in the place it
expects to find a group name &quot;word&quot; as mentioned above.

Just use:
 acl allow_HTTP_ACL external ldap_HTTP


Amos


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="012092.html">[squid-users] dynamic group using URI as group name on external acl	with ext_ldap_group_acl
</A></li>
	<LI>Next message (by thread): <A HREF="012101.html">[squid-users] dynamic group using URI as group name on external acl with ext_ldap_group_acl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12095">[ date ]</a>
              <a href="thread.html#12095">[ thread ]</a>
              <a href="subject.html#12095">[ subject ]</a>
              <a href="author.html#12095">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
