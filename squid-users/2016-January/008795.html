<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] https full url
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20https%20full%20url&In-Reply-To=%3C569AC77B.1030904%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008794.html">
   <LINK REL="Next"  HREF="008800.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] https full url</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20https%20full%20url&In-Reply-To=%3C569AC77B.1030904%40measurement-factory.com%3E"
       TITLE="[squid-users] https full url">rousskov at measurement-factory.com
       </A><BR>
    <I>Sat Jan 16 22:43:07 UTC 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="008794.html">[squid-users] https full url
</A></li>
        <LI>Next message (by thread): <A HREF="008800.html">[squid-users] https full url
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8795">[ date ]</a>
              <a href="thread.html#8795">[ thread ]</a>
              <a href="subject.html#8795">[ subject ]</a>
              <a href="author.html#8795">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 01/16/2016 10:16 AM, xxiao8 wrote:

&gt;<i> I understand the step1/2/3 for sslbump and Squid extracts the domain
</I>&gt;<i> name at various steps(SNI, client hello, server hello,etc) and there is
</I>&gt;<i> no guarantee which step will get what I want.
</I>
The stages I was talking about are not directly related to SslBump
steps. They are a higher-level concept.


&gt;<i> Assuming the ssl is fully bumped(not spliced), that means their http
</I>&gt;<i> request-line(the full URL) and http header(e.g. referer) are now
</I>&gt;<i> available in clear text inside Squid,
</I>
Yes, a &quot;bumped&quot; HTTPS transaction is very similar to a plain text HTTP
transaction inside Squid. Most of the confusion usually happens on the
way to that blissful stage, not during that stage.


&gt;<i> my question is that, can Squid now
</I>&gt;<i> &quot;extract&quot; them and let me use them via directives, just like I use
</I>&gt;<i> url_regex/urlpath_regex/referer_regex when http mode is used.
</I>
Yes. The vast majority of Squid code does not know that the transaction
was bumped.


&gt;<i> I tested external_acl_type and the URI/PATH were empty for _bumped_ ssl
</I>&gt;<i> traffic too.
</I>
That means you have not tested what you think you have tested. To use an
analogy: If the test tells us that 2+2=5, then there is something wrong
with the test itself, not arithmetic.

I do not know what is wrong with your test, but I suspect that you are
looking at stage #2 info while thinking that you are looking at stage #4
info. This is just a guess though!


&gt;<i> Basically I'm trying to see how to get the http-header info from a
</I>&gt;<i> bumped ssl connection and use them directly inside squid.conf(including
</I>&gt;<i> external acl), otherwise icap/ecap is unavoidable for bumped ssl http
</I>&gt;<i> header analysis.
</I>
There is nothing special about eCAP/ICAP as far as access to transaction
meta information. eCAP/ICAP services can access the same transaction
meta data as Squid ACLs can. You think that eCAP/ICAP services can
access more info than ACLs, but that is not true.

eCAP and ICAP services have certain advantages over ACLs (e.g., they
have access to message bodies), but those advantages are unrelated to
this thread AFAICT.


Alex.


&gt;<i> On 01/16/2016 10:06 AM, Alex Rousskov wrote:
</I>&gt;&gt;<i> On 01/15/2016 07:52 PM, xxiao8 wrote:
</I>&gt;&gt;&gt;<i> Just found out ssl::server_name_regex that should cover url_regex, for
</I>&gt;&gt;&gt;<i> urlpath_regex and referer_regex I think I can not get them for
</I>&gt;&gt;&gt;<i> https/sslbump, to get them an icap/ecap has to be used to read the
</I>&gt;&gt;&gt;<i> decrypted content at the moment, will squid plan to provide directives
</I>&gt;&gt;&gt;<i> similar to urlpath_regex/refere_regex for-sslbump in the future?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Your understanding of how HTTPS transactions work still does not match
</I>&gt;&gt;<i> the reality, resulting in confusion about applicability of various Squid
</I>&gt;&gt;<i> features, especially ACLs.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> One way to improve your understanding of reality is to stop thinking
</I>&gt;&gt;<i> about HTTPS transaction as a single request/response pair. *Roughly
</I>&gt;&gt;<i> speaking*, an HTTPS transaction is a sequence of several stages:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. TCP connection establishment.
</I>&gt;&gt;<i> 2. CONNECT transaction(s) that are HTTP transactions with limited info.
</I>&gt;&gt;<i> 3. SSL connection establishment (and bumping).
</I>&gt;&gt;<i> 4. Bumped HTTPS transaction(s) treated as regular HTTP transactions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Most HTTP-focused ACLs like url_regex are meant for regular HTTP
</I>&gt;&gt;<i> transactions (stage #4). They are of limited use for CONNECT
</I>&gt;&gt;<i> transactions (stage #2) and usually do not work during stages #1 and #3.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ICAP/eCAP adaptation may be applied during stage #2 (with limited
</I>&gt;&gt;<i> information) and stage #4.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The statement &quot;referer_regex does not work for https/sslbump&quot; is neither
</I>&gt;&gt;<i> true nor false. Thus, you are getting conflicting responses and are
</I>&gt;&gt;<i> likely to create poorly working configurations until you realize that
</I>&gt;&gt;<i> &quot;referer_regex&quot; works well at stage #4 but may also be applied at stage
</I>&gt;&gt;<i> #2 where it does not work well (not enough information in the CONNECT
</I>&gt;&gt;<i> requests) or at stages #1 and #3 where it should not be used at all.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ACL is just a &quot;named condition&quot; or a &quot;function&quot;. You can type an ACL
</I>&gt;&gt;<i> name X in any squid.conf directives that use ACLs. That does not mean
</I>&gt;&gt;<i> that ACL X works with all directives at all times. Someday, Squid or
</I>&gt;&gt;<i> some squid.conf lint tool would warn about ACLs used in wrong places.
</I>&gt;&gt;<i> For now, you have to understand what stage-dependent information the
</I>&gt;&gt;<i> directive has access to and avoid ACLs that require information
</I>&gt;&gt;<i> unavailable to the directive at the current processing stage.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Good luck,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Alex.
</I>&gt;&gt;<i> P.S. For intercepted connections, CONNECT transactions in stage #2 are
</I>&gt;&gt;<i> faked by Squid. For forward-proxied connections, they are real.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="008794.html">[squid-users] https full url
</A></li>
	<LI>Next message (by thread): <A HREF="008800.html">[squid-users] https full url
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8795">[ date ]</a>
              <a href="thread.html#8795">[ thread ]</a>
              <a href="subject.html#8795">[ subject ]</a>
              <a href="author.html#8795">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
