<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20url_rewrite_program%20shows%20IP%20addresses%20instead%20of%0A%20domain%20name%20when%20rewriting%20SSL/HTTPS&In-Reply-To=%3Cba73f4f2-ca07-bbf9-5ca6-a18ebf4009cd%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011492.html">
   <LINK REL="Next"  HREF="011509.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20url_rewrite_program%20shows%20IP%20addresses%20instead%20of%0A%20domain%20name%20when%20rewriting%20SSL/HTTPS&In-Reply-To=%3Cba73f4f2-ca07-bbf9-5ca6-a18ebf4009cd%40treenet.co.nz%3E"
       TITLE="[squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Jul 10 08:42:53 UTC 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="011492.html">[squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS
</A></li>
        <LI>Next message (by thread): <A HREF="011509.html">[squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11493">[ date ]</a>
              <a href="thread.html#11493">[ thread ]</a>
              <a href="subject.html#11493">[ subject ]</a>
              <a href="author.html#11493">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/07/2016 8:13 p.m., Moataz Elmasry wrote:
&gt;<i> Hi Amos,
</I>&gt;<i> 
</I>&gt;<i> Thanks I really learnt alot from your previous email.
</I>&gt;<i> 
</I>&gt;<i> going on..
</I>&gt;<i> 
</I>&gt;<i> On Fri, Jul 8, 2016 at 1:18 PM, Amos Jeffries &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid3 at treenet.co.nz</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> On 8/07/2016 10:20 p.m., Moataz Elmasry wrote:
</I>&gt;&gt;&gt;<i> Hi Amos,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Do you know any of those 'exceptional' redirectors that can handle https?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I know they exist, some of my clients wrote and use some. But I can't
</I>&gt;&gt;<i> point you to any if thats what you are asking.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I can say though there r two things that can reliably be done with a
</I>&gt;&gt;<i> CONNECT request by a URL-rewriter;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1) return ERR, explicitly telling Squid not to re-write those tunnels.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This trades helper complexity for simpler squid.conf ACLs. Both simply
</I>&gt;&gt;<i> telling Squid not to re-write.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2) re-write the URI from domain:port to be IP:port.
</I>&gt;&gt;<i>
</I>&gt;<i> Funny thing is when I'm getting the URL in the redirect.bash, I'm not
</I>&gt;<i> getting an IP. I probed and logged in many fields as described in the
</I>&gt;<i> logformat page, and I usually get either the IP or the DNS inside
</I>&gt;<i> redirect.bash but not both
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If the IP it gets re-written to is the one the client was going to, this
</I>&gt;&gt;<i> is in effect telling Squid not to do DNS lookup when figuring out where
</I>&gt;&gt;<i> to send it. That can be useful when you don't want Squid to use
</I>&gt;&gt;<i> alternative IPs it might find via DNS.
</I>&gt;&gt;<i>  (NP: This wont affect the host verify checking as it happens too late.
</I>&gt;&gt;<i> This is actually just a fancy way to enforce the ORIGINAL_DST pass-thru
</I>&gt;&gt;<i> behaviour based on more complex things than host-verify detects)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Ok. So let's ignore the redirection for now and just try to whitelist
</I>&gt;&gt;<i> some
</I>&gt;&gt;&gt;<i> https urls and deny anything else.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Now I'm trying to peek and bump the connection, just to obtain the
</I>&gt;&gt;&gt;<i> servername without causing much harm, but the https sites are now either
</I>&gt;&gt;&gt;<i> loading infinitely, or loading successfully, where they should have been
</I>&gt;&gt;&gt;<i> blacklisted, assuming the https unwrapping happened successfully. Could
</I>&gt;&gt;<i> you
</I>&gt;&gt;&gt;<i> please have a look and tell me what's wrong with the following
</I>&gt;&gt;&gt;<i> configuration? BTW after playing with ssl_bump I realized that I didn't
</I>&gt;&gt;&gt;<i> really understand the steps(1,2,3) as well as when to peek/bump/stare
</I>&gt;&gt;&gt;<i> etc... . The squid.conf contains some comments and questions
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> squid.conf
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &quot;
</I>&gt;&gt;&gt;<i> acl http_sites dstdomain play.google.com mydomain.com
</I>&gt;&gt;&gt;<i> acl https_sites ssl::server_name play.google.com mydomain.com
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> #match any url where the servername in the SNI is not empty
</I>&gt;&gt;&gt;<i> acl haveServerName ssl::server_name_regex .
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> http_access allow http_sites
</I>&gt;&gt;&gt;<i> http_access allow https_sites #My expectation is that this rule is
</I>&gt;&gt;<i> matched
</I>&gt;&gt;&gt;<i> when the https connection has been unwrapped
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On HTTP traffic the &quot;http_sites&quot; ACL will match the URL domain.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On HTTPS traffic without (or before finding) the SNI neither ACL will
</I>&gt;&gt;<i> match. Because URL is a raw-IP at that stage.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On HTTPS traffic with SNI the &quot;http_sites&quot; ACL will match. Because the
</I>&gt;&gt;<i> SNI got copied to the request URI.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The &quot;https_sites&quot; ACL will only be reached on traffic where the SNI does
</I>&gt;&gt;<i> *not* contain the values its looking for. This test will always be a
</I>&gt;&gt;<i> non-match / false.
</I>&gt;&gt;<i>
</I>&gt;<i> Ouch, I now see in the docs that ssl::server_name is suitable for usage
</I>&gt;<i> within ssl_bump. So this is the only use case I suppose.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> sslcrtd_program /lib/squid/ssl_crtd -s /var/lib/ssl_db -M 4MB
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> http_access deny all
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> http_port 3127
</I>&gt;&gt;&gt;<i> http_port 3128 intercept
</I>&gt;&gt;&gt;<i> https_port 3129 cert=/etc/squid/ssl/example.com.cert
</I>&gt;&gt;&gt;<i> key=/etc/squid/ssl/example.com.private ssl-bump intercept
</I>&gt;&gt;&gt;<i> generate-host-certificates=on  version=1
</I>&gt;&gt;&gt;<i> options=NO_SSLv2,NO_SSLv3,SINGLE_DH_USE capath=/etc/ssl/certs/
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> sslproxy_cert_error allow all
</I>&gt;&gt;&gt;<i> sslproxy_flags DONT_VERIFY_PEER
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> acl step1 at_step SslBump1
</I>&gt;&gt;&gt;<i> acl step2 at_step SslBump2
</I>&gt;&gt;&gt;<i> acl step3 at_step SslBump3
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ssl_bump peek step1  #Is this equivelant to &quot;ssl_bump peek step1 all ???&quot;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes. &quot;all&quot; is a test that always produces match / true.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The &quot;ssl_bump peek step1 all&quot; means:
</I>&gt;&gt;<i>  If (at_step == SslBump1 and true == true) then do peeking.
</I>&gt;&gt;<i>  else ...
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ssl_bump bump haveServerName !https_sites
</I>&gt;&gt;&gt;<i> #What about connections that didn't provide sni yet? Do they get to have
</I>&gt;&gt;&gt;<i> own definition for step2?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For those:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  &quot;haveServerName&quot; being a regex &quot;.&quot; pattern will match the raw-IP in the
</I>&gt;&gt;<i> CONNECT request, the SNI value, or any subjectAltName in the server
</I>&gt;&gt;<i> certificate. One of those three will always exist and have a value that
</I>&gt;&gt;<i> '.' is matched against. Basically it can't fail - therefore you can
</I>&gt;&gt;<i> consider it just a complicated (and slow / CPU draining) way of checking
</I>&gt;&gt;<i> &quot;all&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AND
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  &quot;https_sites&quot; produces false. The &quot;!&quot; turns that false into true.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So that line matches and &quot;bump&quot; action is done at step 2.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Bump being a final action means there is no step 3 for those requests.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> NOTE:  Side effects of bump at step 2 (aka client-first bumping) is that
</I>&gt;&gt;<i> certificate Squid generates will be generated ONLY from squid.conf
</I>&gt;&gt;<i> settings and clientHello details.
</I>&gt;&gt;<i>  No server involvement, thus a very high chance that the server TLS
</I>&gt;&gt;<i> connection requirements and what Squid offers the client to use will
</I>&gt;&gt;<i> conflict or introduce downgrade attack vulnerabilities into these
</I>&gt;&gt;<i> connections.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  Whether that is okay is a grey area with disagreement possibilities on
</I>&gt;&gt;<i> all sides.
</I>&gt;&gt;<i>  * On the one hand you are probably configuring good security for the
</I>&gt;&gt;<i> client connection even when the server connection has worse TLS.
</I>&gt;&gt;<i>  * On the two hand you are potentially configuring something worse than
</I>&gt;&gt;<i> some servers.
</I>&gt;&gt;<i>  * On the third hand you are definitely fooling the client into thinking
</I>&gt;&gt;<i> it has different security level than the server connection can provide,
</I>&gt;&gt;<i> or vice-versa for the server knowledge about the client connection. Its
</I>&gt;&gt;<i> risky, and you can expect problems.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> #Is this equivelant to &quot;ssl_bump  bump step2 haveServerName
</I>&gt;&gt;<i> !https_sites&quot; ??
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes it is.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> #Can I use step2 with some other acl?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Er. You can use any ACL that has available data for the time and
</I>&gt;&gt;<i> position at which it is tested.
</I>&gt;&gt;<i>  In other words I would not suggest using ACLs that check HTTP response
</I>&gt;&gt;<i> headers at the ssl_bump checking time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> At step 2 of SSL-Bumping process you have client TCP connection details,
</I>&gt;&gt;<i> TLS clientHello details and initial extensions like SNI (well the ones
</I>&gt;&gt;<i> that have been implemented - SNI being the only useful one AFAIK).
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ssl_bump splice all
</I>&gt;&gt;&gt;<i> #Is this now step3 for all?what about those urls who didn't have a match
</I>&gt;&gt;<i> in
</I>&gt;&gt;&gt;<i> step2. Is this step2 for some and step3 for others?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Any step2 traffic which fails the &quot;!https_sites&quot; test will match this.
</I>&gt;&gt;<i> Which means there is no step3 for those requests.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you have been paying attention you will have noticed that all traffic
</I>&gt;&gt;<i> passing the &quot;!https_sites&quot; has been bumped, and all traffic failing that
</I>&gt;&gt;<i> same test has been spliced.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ==&gt; Therefore, zero traffic reaches step 3.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Many thanks for the detailed clarification, this really helps ALOT!!!!
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My advice on this as a general rule-of-thumb is to splice at step 1 or 2
</I>&gt;&gt;<i> if you can. That solves a lot of possible problems with the splicing.
</I>&gt;&gt;<i> And to bump only at step 3 where the mimic feature can avoid a lot of
</I>&gt;&gt;<i> other problems with the bumping.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You will still encounter some problems though (guaranteed). Don't forget
</I>&gt;&gt;<i> that TLS is specifically designed to prevent 'bumping' from being done
</I>&gt;&gt;<i> on its connections. The fact that we can offer the feature at all for
</I>&gt;&gt;<i> generic use is a terrible statement about the Internets bad lack of
</I>&gt;&gt;<i> security.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cheers.
</I>&gt;&gt;<i> Amos
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> Ok. new try.  The following are common configurations:
</I>&gt;<i> &quot;
</I>&gt;<i> 
</I>&gt;<i> acl http_sites dstdomain play.google.com mydomain.com
</I>&gt;<i> acl https_sites ssl::server_name play.google.com mydomain.com
</I>&gt;<i> 
</I>&gt;<i> http_access allow http_sites
</I>&gt;<i> 
</I>&gt;<i> sslcrtd_program /lib/squid/ssl_crtd -s /var/lib/ssl_db -M 4MB
</I>&gt;<i> http_access deny all
</I>&gt;<i> 
</I>&gt;<i> http_port 3127
</I>&gt;<i> http_port 3128 intercept
</I>&gt;<i> https_port 3129 cert=/etc/squid/ssl/example.com.cert
</I>&gt;<i> key=/etc/squid/ssl/example.com.private ssl-bump intercept
</I>&gt;<i> generate-host-certificates=on  version=1
</I>&gt;<i> options=NO_SSLv2,NO_SSLv3,SINGLE_DH_USE capath=/etc/ssl/certs/
</I>&gt;<i> 
</I>&gt;<i> sslproxy_cert_error allow all
</I>&gt;<i> sslproxy_flags DONT_VERIFY_PEER
</I>&gt;<i> 
</I>&gt;<i> acl step1 at_step SslBump1
</I>&gt;<i> acl step2 at_step SslBump2
</I>&gt;<i> acl step3 at_step SslBump3
</I>&gt;<i> 
</I>&gt;<i> url_rewrite_program /bin/bash -c -l /etc/squid/redirect.bash
</I>&gt;<i> url_rewrite_extras &quot;%&gt;a/%&gt;A %&lt;A la=%la:%lp la2=%&lt;a/%&lt;a  la3=%&lt;la:%&lt;lp %un
</I>&gt;<i> %&gt;rm myip=%la myport=%lp  ru=%ru ru2=%&gt;ru ru3=%&lt;ru rd=%&gt;rd rd2=%&lt;rd h=%&gt;h
</I>&gt;<i> ssl1=%ssl::bump_mode ssl2=%ssl::&gt;sni ssl3=%ssl::&gt;cert_subject
</I>&gt;<i> ssl4=%ssl::&gt;cert_issuer  rp1=%rp rp2=%&gt;rp rp3=%&lt;rp h1=%&gt;h h2=%&gt;ha&quot;
</I>&gt;<i> logformat squid &quot;%&gt;a/%&gt;A %&lt;A la=%la:%lp la2=%&lt;a/%&lt;a  la3=%&lt;la:%&lt;lp  %un
</I>&gt;<i> %&gt;rm myip=%la myport=%lp  ru=%ru ru2=%&gt;ru ru3=%&lt;ru rd=%&gt;rd rd2=%&lt;rd h=%&gt;h
</I>&gt;<i> ssl1=%ssl::bump_mode ssl2=%ssl::&gt;sni ssl3=%ssl::&gt;cert_subject
</I>&gt;<i> ssl4=%ssl::&gt;cert_issuer  rp1=%rp rp2=%&gt;rp rp3=%&lt;rp h1=%&gt;h h2=%&gt;ha&quot;
</I>&gt;<i> url_rewrite_access allow all
</I>&gt;<i> &quot;
</I>&gt;<i> 
</I>&gt;<i> Using
</I>&gt;<i> 
</I>&gt;<i> &quot;ssl_bump splice step1 all
</I>&gt;<i> ssl_bump bump step3 all&quot;
</I>&gt;<i> 
</I>&gt;<i> Nothing is blocked. And I don't see any urls, nor sni info neither in
</I>&gt;<i> access.log nor in my redirect.log.Only IPs.  I'm trying many https sites.
</I>
Because &quot;all&quot; traffic got spliced at step1. Nothing go to the step3 bumping.

Sorry if my general rule-of-thumb description was not clear. I meant
those RoT to be used as a preference for what stage to do splice or bump
- for the things you want them respectively to apply to.
 You still need other ACLs defining what traffic the action is to be
applied on.


&gt;<i> 
</I>&gt;<i> Using
</I>&gt;<i> &quot;ssl_bump splice step2 all
</I>&gt;<i> ssl_bump bump step3 all&quot;
</I>&gt;<i> 
</I>
Splice still happens to &quot;all&quot; traffic.

&gt;<i> Same result.
</I>&gt;<i> 
</I>&gt;<i> Using
</I>&gt;<i> &quot;
</I>&gt;<i> ssl_bump peek step1 all
</I>&gt;<i> ssl_bump splice step2  all
</I>&gt;<i> ssl_bump bump step3 all
</I>&gt;<i> &quot;
</I>&gt;<i> 
</I>&gt;<i> I can see URLs in the access.log and redirect.log but no IP's. Further I'm
</I>&gt;<i> getting the header forgery warning in the logs, and all pages start
</I>&gt;<i> loading, but never finish. Maybe this is something related to the nat rules
</I>&gt;<i> in the iptables?
</I>
No.

peek is  non-final action, grabbing the SNI and clientHello details. It
only stops the current step's ACL evaluation. ssl_bump gets re-evaluated
for future step's.

splice and bump are both &quot;final&quot; actions. SSL-Bumping process in its
entirety stops and does the action chosen. It does not continue to do
any other ssl_bump things once one of them is reached.

In the above peek happens to all traffic, then splice happens to all
traffic.

&gt;<i> 
</I>&gt;<i> For info, I'm using the simplest bash redirector for now. Here's the code
</I>&gt;<i> while true;
</I>&gt;<i> do
</I>&gt;<i>     read input;
</I>&gt;<i>     echo &quot;input=${input}&quot;  &gt;&gt;/var/log/squid/redirects.log 2&gt;&amp;1
</I>&gt;<i>     old_url=$(echo ${input} | awk '{print $1}')
</I>&gt;<i>     echo &quot;${old_url}&quot;
</I>&gt;<i>     [[ $? != 0 ]] &amp;&amp; exit -1
</I>&gt;<i>     continue
</I>&gt;<i> done
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I'll try squid4 next week, maybe the result will be better
</I>
It won't be much better, the problem so far is in the ssl_bump ACL design.

Amos


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="011492.html">[squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS
</A></li>
	<LI>Next message (by thread): <A HREF="011509.html">[squid-users] url_rewrite_program shows IP addresses instead of domain name when rewriting SSL/HTTPS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11493">[ date ]</a>
              <a href="thread.html#11493">[ thread ]</a>
              <a href="subject.html#11493">[ subject ]</a>
              <a href="author.html#11493">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
