<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] gzip deflate
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20gzip%20deflate&In-Reply-To=%3C56EABB9C.3030609%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009819.html">
   <LINK REL="Next"  HREF="009854.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] gzip deflate</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20gzip%20deflate&In-Reply-To=%3C56EABB9C.3030609%40treenet.co.nz%3E"
       TITLE="[squid-users] gzip deflate">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Mar 17 14:13:48 UTC 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="009819.html">[squid-users] gzip deflate
</A></li>
        <LI>Next message (by thread): <A HREF="009854.html">[squid-users] gzip deflate
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9822">[ date ]</a>
              <a href="thread.html#9822">[ thread ]</a>
              <a href="subject.html#9822">[ subject ]</a>
              <a href="author.html#9822">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 17/03/2016 10:56 p.m., joe wrote:
&gt;<i> Alex Rousskov wrote
</I>&gt;&gt;<i> On 03/16/2016 02:21 AM, joe wrote:
</I>&gt;&gt;&gt;<i> You need to direct messages to the service(s) using adaptation_access
</I>&gt;&gt;&gt;<i> directives:
</I>&gt;&gt;&gt;<i> isn't faster if we use gzip library instead that will minimize the
</I>&gt;&gt;&gt;<i> redirect
</I>&gt;&gt;&gt;<i> ms..direct decompress
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Virtually everything would be faster if done directly in Squid. The
</I>&gt;&gt;<i> processing speed is not the primary acceptance criteria, or we would
</I>&gt;&gt;<i> never have ICAP, eCAP, URL rewriters, authentication helpers, SSL
</I>&gt;&gt;<i> certificate validators, and other &quot;helpers&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Compressing and uncompressing content on-the-fly is a lot more difficult
</I>&gt;&gt;<i> than adding a couple of zlib function calls. It probably also requires
</I>&gt;&gt;<i> several configuration/tuning options to accommodate various deployment
</I>&gt;&gt;<i> environments. To make it worth implementing inside Squid, decompression
</I>&gt;&gt;<i> has to be a very frequent feature request OR it has to be nearly
</I>&gt;&gt;<i> impossible to do well outside of Squid (while still being reasonably
</I>&gt;&gt;<i> popular). AFAICT, neither is true but please submit a more detailed
</I>&gt;&gt;<i> proposal if I am wrong.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thank you,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Alex.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> it will be start for the future technologies  squid-gzip-deflate
</I>&gt;<i> Content-Encoding can be hook the code to decomp... insted of using ecap
</I>&gt;<i> 
</I>
Squid is a proxy. Proxies are supposed to participate in
Transfer-Encoding, not Content-Encoding. Only user agents and origin
servers are supposed to participate in Content-Encoding.

The future technology we are trying to aim Squid at is HTTP/2. In h2
Transfer-Encoding takes the form of DATA frames which are compressed
individually as a unit independent of other DATA frames in the same
stream. This is *much* easier to code than HTTP/1.x stream compression.
 But we need to get h2 implemented first.


&gt;<i> 
</I>&gt;<i> yes there is a lot of work to have it fuly working but its start to the
</I>&gt;<i> develop....to continue working on it
</I>&gt;<i> there is lots a free snipe code arount and not hard to use it it fit in
</I>&gt;<i> recent squid code
</I>&gt;<i> 
</I>
The first problem with all the code below is that it uses std::string.
Squid does not use std::string for I/O buffered content.

Translating the content from StoreIOBuffer type into std::string, then
compressing into another std::string, then copying back into
StoreIOBuffer for delivery is ~60% slower than normal Squid delivery.


The second problem is that it assumes the data is all known before
compress/decompress starts.

HTTP traffic is not all arriving in one block. Squid may receive the
content asynchronously in chunks as small as 1 single byte per I/O
cycle. Any codec needs to be able to cope with that variable and
streamed flow of data without resorting to errors.



&gt;<i> just a sample code to adapt can be start of the work
</I>&gt;<i> #include &lt;string&gt;
</I>&gt;<i> #include &lt;sstream&gt;
</I>&gt;<i> #include &lt;stdexcept&gt;
</I>&gt;<i> #include &lt;string.h&gt;
</I>&gt;<i> #include &quot;zlib.h&quot;
</I>&gt;<i> 
</I>&gt;<i> using std::string;
</I>&gt;<i> using std::stringstream;
</I>&gt;<i> 
</I>&gt;<i> // Found these here
</I>&gt;<i> <A HREF="http://mail-archives.apache.org/mod_mbox/trafficserver-dev/201110.mbox/%3CCACJPjhYf=+br1W39vyazP=ix">http://mail-archives.apache.org/mod_mbox/trafficserver-dev/201110.mbox/%3CCACJPjhYf=+br1W39vyazP=ix</A>
</I>&gt;<i> //<A HREF="https://lists.squid-cache.org/listinfo/squid-users">eQZ-4Gh9-U6TtiEdReG3S4ZZng at mail.gmail.com</A>%3E
</I>&gt;<i> #define MOD_GZIP_ZLIB_WINDOWSIZE 15
</I>&gt;<i> /** Decompress an STL string using zlib and return the original data. */
</I>&gt;<i> std::string decompress_deflate(const std::string&amp; str)
</I>&gt;<i> {
</I>&gt;<i>     z_stream zst;                        // z_stream is zlib's control
</I>&gt;<i> structure
</I>&gt;<i>     memset(&amp;zst, 0, sizeof(zst));
</I>&gt;<i> 
</I>&gt;<i>     if (inflateInit(&amp;zst) != Z_OK)
</I>&gt;<i>     debugs(98,1, &quot;inflateInit failed while decompressing.&quot;);
</I>&gt;<i>     zst.next_in = (Bytef*)str.data();
</I>&gt;<i>     zst.avail_in = str.size();
</I>&gt;<i>     int ret;
</I>&gt;<i>     char outbuffer[32768];
</I>&gt;<i>     std::string outstring;
</I>&gt;<i> 
</I>&gt;<i>     // get the decompressed bytes blockwise using repeated calls to inflate
</I>&gt;<i>     do {
</I>&gt;<i>         zst.next_out = reinterpret_cast&lt;Bytef*&gt;(outbuffer);
</I>&gt;<i>         zst.avail_out = sizeof(outbuffer);
</I>&gt;<i>         ret = inflate(&amp;zst, 0);
</I>&gt;<i>         if (outstring.size() &lt; zst.total_out) {
</I>&gt;<i>             outstring.append(outbuffer,
</I>&gt;<i>                              zst.total_out - outstring.size());
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i>     } while (ret == Z_OK);
</I>&gt;<i> 
</I>&gt;<i>     inflateEnd(&amp;zst);
</I>&gt;<i> 
</I>&gt;<i>     if (ret != Z_STREAM_END) {          // an error occurred that was not
</I>&gt;<i> EOF
</I>&gt;<i>         std::ostringstream oss;
</I>&gt;<i> 		 debugs(98,2, oss &lt;&lt; &quot;Exception during deflate decompression: (&quot; &lt;&lt; ret &lt;&lt;
</I>&gt;<i> &quot;) &quot; &lt;&lt; zst.msg);
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i>     return outstring;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> std::string decompress_gzip(const std::string&amp; str)
</I>&gt;<i> {
</I>&gt;<i>     z_stream zst;                        // z_stream is zlib's control
</I>&gt;<i> structure
</I>&gt;<i>     memset(&amp;zst, 0, sizeof(zst));
</I>&gt;<i>     if (inflateInit2(&amp;zst, MOD_GZIP_ZLIB_WINDOWSIZE + 16) != Z_OK)
</I>&gt;<i> 	    debugs(98,1, &quot;error failed while decompressing.&quot;);
</I>&gt;<i>     zst.next_in = (Bytef*)str.data();
</I>&gt;<i>     zst.avail_in = str.size();
</I>&gt;<i>     int ret;
</I>&gt;<i>     char outbuffer[32768];
</I>&gt;<i>     std::string outstring;
</I>&gt;<i> 
</I>&gt;<i>     // get the decompressed bytes blockwise using repeated calls to inflate
</I>&gt;<i>     do {
</I>&gt;<i>         zst.next_out = reinterpret_cast&lt;Bytef*&gt;(outbuffer);
</I>&gt;<i>         zst.avail_out = sizeof(outbuffer);
</I>&gt;<i>         ret = inflate(&amp;zst, 0);
</I>&gt;<i> 
</I>&gt;<i>         if (outstring.size() &lt; zst.total_out) {
</I>&gt;<i>             outstring.append(outbuffer, zst.total_out - outstring.size());
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i>     } while (ret == Z_OK);
</I>&gt;<i> 
</I>&gt;<i>     inflateEnd(&amp;zst);
</I>&gt;<i> 
</I>&gt;<i>     if (ret != Z_STREAM_END) {          // an error occurred that was not
</I>&gt;<i> EOF
</I>&gt;<i>         std::ostringstream oss;
</I>&gt;<i> 		debugs(98,2, oss &lt;&lt; &quot;Exception during zlib decompression: (&quot; &lt;&lt; ret &lt;&lt; &quot;)
</I>&gt;<i> &quot; &lt;&lt; zst.msg);	
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i>     return outstring;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> =========
</I>&gt;<i>  i know squid its hard coded to work with but its a start nothing essay but
</I>&gt;<i> it will be step to the future better then waiting for apps in the web to
</I>&gt;<i> become fully compressed and like the most preferred that then ecap  
</I>&gt;<i> 
</I>
We are not saying its hard to use the library. We are saying that to get
this project happening you first have to design how something like the
above is going to fit into Squid.

Doing the planning/design work will show you how the gzip code will
actually have to be written.


I have done a lot of the design and preparation work for adding TE:gzip.
But its not quite finished yet. The plan was to hook a TeGzipDecoder
object into the TeChunkedParser, so that each block of data to be
de-chunked was then decompressed, with the result being added to the
output I/O buffer.

Amos


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="009819.html">[squid-users] gzip deflate
</A></li>
	<LI>Next message (by thread): <A HREF="009854.html">[squid-users] gzip deflate
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9822">[ date ]</a>
              <a href="thread.html#9822">[ thread ]</a>
              <a href="subject.html#9822">[ subject ]</a>
              <a href="author.html#9822">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
