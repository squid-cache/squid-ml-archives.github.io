<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] TCP_MISS/304 question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20TCP_MISS/304%20question&In-Reply-To=%3Ccd77384e-0216-ab71-f9fb-109dc6b36f4e%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013041.html">
   <LINK REL="Next"  HREF="013050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] TCP_MISS/304 question</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20TCP_MISS/304%20question&In-Reply-To=%3Ccd77384e-0216-ab71-f9fb-109dc6b36f4e%40treenet.co.nz%3E"
       TITLE="[squid-users] TCP_MISS/304 question">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Oct 14 12:07:21 UTC 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="013041.html">[squid-users] TCP_MISS/304 question
</A></li>
        <LI>Next message (by thread): <A HREF="013050.html">[squid-users] TCP_MISS/304 question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13042">[ date ]</a>
              <a href="thread.html#13042">[ thread ]</a>
              <a href="subject.html#13042">[ subject ]</a>
              <a href="author.html#13042">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 14/10/2016 10:44 a.m., Yuri Voinov wrote:
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 14.10.2016 2:48, Alex Rousskov &#1087;&#1080;&#1096;&#1077;&#1090;:
</I>&gt;&gt;<i> On 10/13/2016 01:44 PM, Yuri Voinov wrote:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> However, this is nothing more than word games, Alex.
</I>&gt;<i> 
</I>&gt;&gt;<i> ... unless the definition of a hit affects your billing or your
</I>&gt;&gt;<i> interpretation of Squid documentation or the developer interpretation of
</I>&gt;&gt;<i> the code. Definitions matter! You yourself have seen their importance
</I>&gt;&gt;<i> when you showed your excellent byte hit ratio results but folks were
</I>&gt;&gt;<i> looking at the ordinary document hit ratio numbers instead.
</I>&gt;<i> Sure. But difference with TCP_HIT itself and byte hit is obvious.
</I>&gt;<i> 
</I>
Even that is not so obvious as it appears at first. Since 3.5.22 it is
possible that the proxy finds an item in its cache that needs to be
revalidated. When asked the server responds with a 304 that contains
info far older than the proxy found (maybe from a more up-to-date server
IP).
In this situation Squid discards the outdated server response and
deliveres its content. That should be marked as TCP_HIT under the
current tagging system.

This case and others involving the (thankfully rare) If-Unmodified-Since
header are why I am trying to work out a better tagging scheme that will
be less confusing and more descriptive for the operations.


&gt;<i> 
</I>&gt;&gt;&gt;<i> The question is -
</I>&gt;&gt;&gt;<i> can we more or less significant differences from known what hit proxy
</I>&gt;&gt;&gt;<i> code level and / or transactions which, obviously, on the proxy level,
</I>&gt;&gt;&gt;<i> we can see in its entirety.
</I>&gt;<i> 
</I>&gt;&gt;<i> Sorry, I do not understand the question.
</I>&gt;<i> I want to say that on the proxy level, seeing the transaction as a
</I>&gt;<i> whole, we are able to differentiate hit or his likeness from all other
</I>&gt;<i> transactions. We see the whole session in its entirety. We see repeated
</I>&gt;<i> queries of the same client to the same resource. Accordingly, we can
</I>&gt;<i> quite clearly be judged by the behavior of the header from the client or
</I>&gt;<i> server that is happening. Correctly?
</I>&gt;<i> 
</I>
HTTP/1.0 was simple. HIT and MISS were easily known and matched what you
have learnt to expect.

HTTP/1.1 adds 2x time-based If-*Since headers, 2x ETag based If-*Match
headrs, and one extendable If: header - each of which has a 200 or 304
response. With a client cache, proxy cache and upstream cache each
having one of the content-vs-nothing states.

The result is that the log line describes one of the 3*(2^5) = 96
different transaction cases which could occur.

My math there is assuming the that each header adds only a binary
condition (X, or not X). If they add trinary (X, not-X, ignore) then its
2^2*(3^4) = 972 cases, which seems a bit much to me.


&gt;<i> Specifically, in this particular case. Proxy IMS settings is enabled:
</I>&gt;<i> 
</I>&gt;<i> refresh_all_ims on
</I>&gt;<i> reload_into_ims on
</I>&gt;<i> 
</I>
These are converting CC:no-cache or CC:max-age=0 client headers into IMS
(If-Modified-Since) revalidations against the server. All they do is
convert the Squid&lt;-&gt;server transaction into a revalidation.

The client should still get a /200 object even though the server side
used revalidation. It is a bug for Squid to respond to those client
requests with /304 unless the client *also* sent If-* headers along with
the CC reload/refresh header.


&gt;<i> On web-page level we have: periodically reload/refresh directive, which
</I>&gt;<i> is forces to check (after initially store in shared cache) freshness of
</I>&gt;<i> content.
</I>&gt;<i> 
</I>
These reload/refresh coming from the client are supposed to only happen
when a user identifies breakage in the web page and manually forces it
to happen (refresh button in the browser). Bots can use them, but should
not need to.

So when HTTP is working properly they should almost never happen (client
never sees breakage).

If you find them happening a lot it is a sign of breakage.


&gt;<i> In this situation (and I've checked this web-page elements stored in
</I>&gt;<i> cache) TCP_MISS/304 means TCP_REFRESH_UNMODIFIED.
</I>&gt;<i> 
</I>&gt;<i> So, this is HIT exactly.
</I>
No &quot;exactly&quot; about it.

If it was *exactly* a HIT that would mean the cached response was a 304
message. Not some object the 304 was about, but the actual 304 status
line + mime headers.

Which also would be logged as as TCP_HIT/304. Identical to the different
case where a normal cache object being HIT on generated a new 304 to the
client.

&gt;<i> 
</I>&gt;<i> I'm not saying - literally. And in fact. Correctly?
</I>
With 96 permutations of cases there may be the odd mistake. But where
Squid has a tag code for one case that case is usually tagged correctly.
So the TCP_MISS/304 is definitely *not* a TCP_REFRESH_UNMODIFIED - but
it also may not be strictly a MISS either.

It is entirely possible that a TCP_MISS/304 is a real TCP_MISS/304. MISS
on the proxy cache and 304 from upstream server.

The REFRESH MODIFIED/UNMODIFIED tags are give to the time-based
If-*-Since headers. The ETag based ones are not tagged the same because
'(un)modified' is not applicable. So this TCP_MISS/304 may be one of the
ETag revalidations on proxy content that we dont have a special code for
yet.

&gt;<i> 
</I>&gt;&gt;&gt;&gt;<i> Unfortunately, there are too many definitions of a &quot;hit&quot;.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> There is no many definitions of hit. We are talking about the caching
</I>&gt;&gt;&gt;<i> proxy, which is basically no different from all the other caches, and
</I>&gt;&gt;&gt;<i> subject to the same rules.
</I>&gt;<i> 
</I>&gt;&gt;<i> You are oversimplifying a complex subject matter. If Squid delivers a
</I>&gt;&gt;<i> single response comprising 1000 bytes from the cache and 10 bytes from
</I>&gt;&gt;<i> the origin server, is that a hit or a miss? If Squid delivers the entire
</I>&gt;&gt;<i> response from the cache but spends 10 minutes talking to the origin
</I>&gt;&gt;<i> server about that object first, is that a hit or a miss? Different
</I>&gt;&gt;<i> people will give you different answers to those questions.
</I>&gt;<i> 10 minutes a bit above TCP timeout and will be aborted, I think. So,
</I>&gt;<i> Squid's write TCP_MISS_ABORTED in access.log. :)
</I>&gt;<i> 
</I>
Or TCP_HIT_ABORTED or TCP_REFRESH_ABORTED or TCP_CLIENT_REFRESH_ABORTED :-(

the distiniction is in the headers and your definition of HIT/MISS.


&gt;<i> 
</I>&gt;&gt;<i> We have [poorly defined] byte hits, document hits, revalidation hits,
</I>&gt;&gt;<i> stale hits, partial hits, etc., etc.
</I>&gt;<i> What yes - yes. The documentation is the problem.
</I>&gt;<i> 
</I>
Partially. Documentation issue is caused in part by the worse problem of
cases overlapping and currently not being grouped together very well.

I am working on the fix for that. But it is gong very slowly because it
has to touch so much code in areas that I'm not very familiar with yet.
Plus the definitions issue Alex talked about, agreeing on how to define
each tag as it is created leads to long discussions like this one.

&gt;<i> 
</I>&gt;&gt;&gt;<i> If the first access does not find an object in the cache, it requests
</I>&gt;&gt;&gt;<i> from the network,
</I>&gt;<i> 
</I>&gt;&gt;<i> yes
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> saves in the cache,
</I>&gt;<i> 
</I>&gt;&gt;<i> or does not
</I>&gt;<i> Yes. May be or may be not. But in this case we are:
</I>&gt;<i> 1) Know about transaction history and we know the object(s) in cache.
</I>&gt;<i> 2) Proxy can easy check it, right? Just swap in object from disk in
</I>&gt;<i> memory. If this success, object in cache, so we can qualify it as HIT.
</I>&gt;<i> Otherwise, exactly MISS.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> and re-treatment or gets a hit,
</I>&gt;<i> 
</I>&gt;&gt;<i> or does not
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> &quot;the object is not changed.&quot; Dot.
</I>&gt;<i> 
</I>&gt;&gt;<i> or the Squid-cached object did not change but the client-cached object
</I>&gt;&gt;<i> did. Or vice versa.
</I>&gt;<i> Client-cached object gives from Squid. They (ideally) must not be the
</I>&gt;<i> different. Client cache and squid's cache operates like chain, one is
</I>&gt;<i> source for another.
</I>
Within HTTP that is true. But clients are not restricted to HTTP as
sources for their cache contents. So we cannot draw such a distinctive
line in the definition of what is happening for a random line selected
out of somebodies access.log.

All we can say is what sub-group of those 96 cases has happened to cause
those tag values to appear. For exact knowledge (or to say what that
means in terms of byte counts) one needs to see the HTTP headers, at
least the client ones and preferrrably the full 11,2 trace data
containing both client and server messages.


&gt;<i> 
</I>&gt;&gt;&gt;<i> If the time in the cache
</I>&gt;&gt;&gt;<i> object lifetime expires, or a lifetime on the server timed out - the
</I>&gt;&gt;&gt;<i> object is requested again and a miss is recorded.
</I>&gt;<i> 
</I>&gt;&gt;<i> * Yes, if you define a miss as &quot;contact with the origin server&quot;.
</I>&gt;<i> I want to add: &quot;contact with the origin server for get content&quot;. Not for
</I>&gt;<i> revalidation purposes. If revalidation returns &quot;Object not changed&quot; -
</I>&gt;<i> this is positive and must be qualified as HIT IMO.
</I>
Even this definition is tricky. For revalidations using the
If-Unmodified-Since header the server (or squid) is instructed to
deliver a 200+object when the &quot;Object not changed&quot; state happens.

That is usually where TCP_REFRESH_UNMODIFIED/200 come from.

&gt;<i> 
</I>&gt;&gt;<i> * No, if contact with the origin server is OK for a hit as long as the
</I>&gt;&gt;<i> server does not send the response _body_ back to Squid.
</I>&gt;<i> .... when revalidation true - i.e. object in shared cache not stale,
</I>&gt;<i> this is HIT. We're not interested in client browser's cache state. Only
</I>&gt;<i> shared cache matters.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> if
</I>&gt;&gt;&gt;<i> the proxy responds to the client &quot;has not changed&quot;, it means, in fact,
</I>&gt;&gt;&gt;<i> that the client has a copy of the object
</I>&gt;<i> 
</I>&gt;&gt;<i> Yes.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> and a copy of the proxy object,
</I>&gt;<i> 
</I>&gt;&gt;<i> The copy in the proxy cache may be different from the copy in the client
</I>&gt;&gt;<i> cache or may not exist at all.
</I>&gt;<i> Yes. If object not exists in proxy - this is proxy MISS. If client cache
</I>&gt;<i> not contains object - client go to proxy and asks it about object. Found
</I>&gt;<i> - excellent, for client this is MISS, for proxy - HIT. If proxy also not
</I>&gt;<i> contains object - it will be MISS-MISS and loading object from origin.
</I>&gt;<i> 
</I>
This is where the ETag based If-*Match headers get in the way of a
definition. The proxy could easily have what appears to be a useful
response to the URL, but be told only to send it if *not* matching a set
of ETag values. Or the opposite.

I guess what I (we?) am trying to get across is that defining the entire
Internet in black-and-white terms of HIT vs MISS is wrong for HTTP/1.1
traffic. Within 1.1 traffic REFRESH is the norm, and HIT/MISS on local
proxy cache is only a minor subset of what is going on - even for
transactions logged as TCP_HIT or TCP_MISS.


Squid [read: &quot;the changes we are making to Squid-3/4&quot;] is trying to
minimize bandwidth on both server and client connections. Sometimes only
one connection can be reduced, many times both can be.

What any particular sysadmin sees in regards to client or server
bandwidth used by Squid varies a lot. Usually by how much Squid HTTP/1.1
feature support matches the relevant client or server feature support.


&gt;<i> 
</I>&gt;&gt;&gt;<i> the proxy and responds to the client, performing REFRESH that the object
</I>&gt;&gt;&gt;<i> did not change. What is this, if not hit?
</I>&gt;<i> 
</I>&gt;&gt;<i> Assuming the proxy asked the origin server whether the object in the
</I>&gt;&gt;<i> client (or the proxy, depending on the circumstances) cache is fresh,
</I>&gt;&gt;<i> for many, it is
</I>&gt;<i> 
</I>&gt;&gt;<i> * a [document] miss (because there was a potentially very slow contact
</I>&gt;&gt;<i> with the origin server) or
</I>&gt;&gt;<i> * a [byte] hit (because the response body came from the Squid cache and
</I>&gt;&gt;<i> not from the origin server).
</I>&gt;<i> 
</I>&gt;&gt;<i> Resisting the existence of different valid hit definitions is futile
</I>&gt;&gt;<i> IMO. State what _your_ definition is (be as precise as possible; this
</I>&gt;&gt;<i> may require several iterations) and then you may ask whether a
</I>&gt;&gt;<i> particular transaction is a hit.
</I>&gt;<i> 
</I>&gt;&gt;<i> Alex.
</I>&gt;<i> I agree that there are a number of boundary cases. However, in most
</I>&gt;<i> cases we are dealing with a relatively simple chain, which should be
</I>&gt;<i> considered and, in my opinion. How is it to be regarded revalidation
</I>&gt;<i> facilities and its results? If revalidation confirms that the object is
</I>&gt;<i> not stale and not expired - it's a hit, is not it?
</I>&gt;<i> 
</I>&gt;<i> If revalidation fails - object stale/expired - everything is clear and
</I>&gt;<i> there is nothing to discuss. Definitely miss.
</I>
Revalidation does not &quot;fail&quot;. It happens or it does not. The result is
always a fresh object when it happens.

In order to cram the 96 revalidation states down into the overly simple
HIT vs MISS terminology you are implicitly using the byte-HIT
definition. Where size of updating headers-only vs updating payload body
is different.
 So your definition only means HIT = low bytes, MISS = many bytes.


&gt;<i> 
</I>&gt;<i> Well, let's say we do not know and can not know about the object in the
</I>&gt;<i> client cache. Assume also that we do not want to check - whether this
</I>&gt;<i> object is in the cache proxy. Let us assume that we do not want to spend
</I>&gt;<i> resources to figure out what happened to the object in the future, in
</I>&gt;<i> client's browser, or on proxy's disk cache. Ok. Is, in this case, would
</I>&gt;<i> not be more correct to write in log TCP_NONE/304?
</I>
No. Knowing zero about the client object is one of the 96 cases. (no
revalidation headers present). It looks like this:

 GET /foo HTTP/1.1
 Host: example.com

The response to this has to always involve a &quot;/200&quot;. So your /304 is not
possible.
The remainder of the tags are decided by whether Squid has cached
content and needs to revalidate it. That will determine whether
HIT/MISS/REFRESH_* is logged.

Both REFRESH and MISS will involve a server, but different ways and
different amounts of bandwidth used.

Which brings us to your description of the squid cache...

&gt;<i> 
</I>&gt;<i> In this case, we're talking directly - &quot;We do not know, hit it or not.
</I>&gt;<i> We only know that the object has not changed since the last
</I>&gt;<i> request/revalidation. We do not want to know, and you can interpret it
</I>&gt;<i> any way you like&quot;.
</I>
That would be a TCP_HIT/200. Maximum possible to-client bandwidth
expenditure. Zero server bandwidth expenditure.

However, by using the condition &quot;We only know that the object has not
changed&quot; you have defined this use-case as a situation where
revalidation is not performed. That alone makes it irrelevant to this
discussion about revalidations.


&gt;<i> 
</I>&gt;<i>  It would be more correct, it seems to me, than just to say -
</I>&gt;<i> &quot;TCP_MISS/304 - This is a cache miss, whatever it was not really.&quot;
</I>&gt;<i> 
</I>
This status code does not describe that.

It describes a cache MISS which when the server response was stored
allowed Squid to optimize away the bandwidth to the client and send only
a 304 response.

OR, it describes a MISS where Squid relayed conditional If-* headers to
the server. So the server responded with a 304 Squid had to relay on to
the client (without adding to its cache).

Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="013041.html">[squid-users] TCP_MISS/304 question
</A></li>
	<LI>Next message (by thread): <A HREF="013050.html">[squid-users] TCP_MISS/304 question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13042">[ date ]</a>
              <a href="thread.html#13042">[ thread ]</a>
              <a href="subject.html#13042">[ subject ]</a>
              <a href="author.html#13042">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
