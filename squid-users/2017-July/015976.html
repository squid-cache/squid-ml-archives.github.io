<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] What would be the maximum ufs\aufs cache_dir objects?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20What%20would%20be%20the%20maximum%20ufs%5Caufs%20cache_dir%0A%20objects%3F&In-Reply-To=%3Ce0bcf3db-4da7-cb6e-8ae6-969e092d57e0%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015943.html">
   <LINK REL="Next"  HREF="016030.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] What would be the maximum ufs\aufs cache_dir objects?</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20What%20would%20be%20the%20maximum%20ufs%5Caufs%20cache_dir%0A%20objects%3F&In-Reply-To=%3Ce0bcf3db-4da7-cb6e-8ae6-969e092d57e0%40treenet.co.nz%3E"
       TITLE="[squid-users] What would be the maximum ufs\aufs cache_dir objects?">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Jul 19 13:38:27 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="015943.html">[squid-users] What would be the maximum ufs\aufs cache_dir	objects?
</A></li>
        <LI>Next message (by thread): <A HREF="016030.html">[squid-users] What would be the maximum ufs\aufs cache_dir	objects?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15976">[ date ]</a>
              <a href="thread.html#15976">[ thread ]</a>
              <a href="subject.html#15976">[ subject ]</a>
              <a href="author.html#15976">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 18/07/17 05:34, Eliezer Croitoru wrote:
&gt;<i> So basically from I understand the limit of the AUFS\UFS cache_dir is at:
</I>&gt;<i> 16,777,215 Objects.
</I>&gt;<i> So for a very loaded system it might be pretty &quot;small&quot;.
</I>&gt;<i> 
</I>&gt;<i> I have asked since:
</I>&gt;<i> I have seen the mongodb ecap adapter that stores chunks and I didn't liked it.
</I>&gt;<i> In the other way I wrote a cache_dir in GoLang which I am using for the windows updates caching proxy and for now it's surpassing the AUFS\UFS limits.
</I>&gt;<i> 
</I>&gt;<i> Based on the success of the Windows Updates Cache proxy which strives to cache only public objects, I was thinking about writing something similar for a more global usage.
</I>&gt;<i> The basic constrain on what would be cached is only If the object has Cache-Control &quot;public&quot;.
</I>
You would end up with only a small sub-set of HTTP every being cached.

CC:public's main reason for existence is to re-enable cacheability of 
responses that contain security credentials - which is prevented by 
default as a security fail-safe.

I know a fair number of servers still send it when they should not. But 
that is declining as content gets absorbed by CDN who take more care 
with their bandwidth expenditure.



&gt;<i> The first step would be an ICAP service (respmod) which will log requests and response and will decide what GET results are worthy of later fetch.
</I>&gt;<i> Squid currently does things on-the-fly while the client transaction is fetched by the client.
</I>
What things are you speaking about here?

How do you define &quot;later&quot;? is that 1 nanosecond or 64 years?
  and what makes 1 nanosecond difference in request timing for a 6GB 
object any less costly than 1 second?

Most of what Squid does and the timing of it have good reasons behind 
them. Not saying change is bad, but to make real improvements instead of 
re-inventing some long lost wheel design one has to know those reasons 
to avoid them becoming problems.
  eg. the often laughed at square wheel is a real and useful design for 
some circumstances. And their lesser bretheren cogwheels and the like 
are an age proven design in rail history for places where roundness 
actively inhibits movement.


&gt;<i> For an effective cache I believe we can compromise on another approach which relays or statistics.
</I>&gt;<i> The first rule is: Not everything worth caching!!!
</I>&gt;<i> Then after understanding and configuring this we can move on to fetch *Public* only objects when they get a high repeated downloads.
</I>&gt;<i> This is actually how google cache and other similar cache systems work.
</I>&gt;<i> They first let traffic reach the &quot;DB&quot; or &quot;DATASTORE&quot; if it's the first time seen.
</I>
FYI: that is the model Squid is trying to move away from - because it 
slows down traffic processing. As far as I'm aware G has a farm of 
servers to throw at any task - unlike most sysadmin trying to stand up a 
cache.


&gt;<i> Then after more the a specific threshold they object is being fetched by the cache system without any connection to the transaction which the clients consume.
</I>
Introducing the slow-loris attack.

It has several variants:
1) client sends a request, very , very, ... very slowly. many thousands 
of bots all do this at once, or building up over time.
   -&gt; an unwary server gets crushed under the weight of open TCP 
sockets, and its normal clients get pushed out into DoS.

2) client sends a request. then ACK's delivery, very, very, ... very slowly.
   -&gt; an unwary server gets crushed under the weight of open TCP 
sockets, and its normal clients get pushed out into DoS. AND suffers for 
each byte of bandwidth it spent fetching content for that client.

3) both of the above.

The slower a server is at detecting this attack the more damage can be 
done. This is magnified by whatever amount of resource expenditure the 
server goes to before detection can kick in - RAM, disk I/O, CPU time, 
TCP sockets, and of most relevant here: upstream bandwidth.

Also, Loris and clients on old tech like 6K modems or worse are 
indistinguishable.

To help resolve this problem Squid does the _opposite_ to what you 
propose above. It makes the client delivery and the server fetch align 
to avoid mistakes detecting these attacks and disconnecting legitimate 
clients.
  The read_ahead_gap directive configures the threshold amount of server 
fetch which can be done at full server-connection speed before slowing 
down to client speed. The various I/O timeouts can be tuned to what a 
sysadmin knows about their clients expected I/O capabilities.


&gt;<i> It might not be the most effective caching &quot;method&quot; for specific very loaded systems or specific big files and *very* high cost up-stream connections but for many it will be fine.
</I>&gt;<i> And the actual logic and implementation can be each of couple algorithms like LRU as the default and couple others as an option.
</I>&gt;<i> 
</I>&gt;<i> I believe that this logic will be good for specific systems and will remove all sort of weird store\cache_dir limitations.
</I>
Which weird limitations are you referring to?

The limits you started this thread about are caused directly by the size 
of a specific integer representation and the mathematical properties 
inherent in a hashing algorithm.

Those types of limit can be eliminated or changed in the relevant code 
without redesigning how HTTP protocol caching behaves.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="015943.html">[squid-users] What would be the maximum ufs\aufs cache_dir	objects?
</A></li>
	<LI>Next message (by thread): <A HREF="016030.html">[squid-users] What would be the maximum ufs\aufs cache_dir	objects?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15976">[ date ]</a>
              <a href="thread.html#15976">[ thread ]</a>
              <a href="subject.html#15976">[ subject ]</a>
              <a href="author.html#15976">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
