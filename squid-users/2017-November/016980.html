<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] block user agent
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20block%20user%20agent&In-Reply-To=%3C45c9ef41-5134-4df0-b46b-25dc0035eff1%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016977.html">
   <LINK REL="Next"  HREF="016994.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] block user agent</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20block%20user%20agent&In-Reply-To=%3C45c9ef41-5134-4df0-b46b-25dc0035eff1%40treenet.co.nz%3E"
       TITLE="[squid-users] block user agent">squid3 at treenet.co.nz
       </A><BR>
    <I>Mon Nov 20 13:51:44 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="016977.html">[squid-users] block user agent
</A></li>
        <LI>Next message (by thread): <A HREF="016994.html">[squid-users] block user agent
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16980">[ date ]</a>
              <a href="thread.html#16980">[ thread ]</a>
              <a href="subject.html#16980">[ subject ]</a>
              <a href="author.html#16980">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 20/11/17 21:45, Vieri wrote:
&gt;<i> ________________________________
</I>&gt;<i> From: Alex Rousskov
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You may be conflating two very different goals:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    A) Understanding why Squid does X.
</I>&gt;&gt;<i>    B) Configuring Squid to do what you want.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My response was focused on the former. Once you understand, you can
</I>&gt;&gt;<i> probably accomplish the latter on your own.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> You are absolutely right. I'd like to uderstand how Squid *access rules work.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> To put it bluntly, http_access and http_reply_access rules are processed one after another as they appear in squid.conf. It &quot;exits&quot; the sequence (ie. stops going through each http_*access rule) as soon as it hits a match.
</I>&gt;<i> 
</I>
Not quite. The lines which start with the same directive name are 
executed that way. Each directive has a different timing within the 
transaction lifetime.


  http_access allow foo
  http_reply_access deny foo
  http_access allow bar

Is the same as

  http_access allow foo
  http_access allow bar

  http_reply_access deny foo


http_access lines are checked on a client HTTP request arriving. 
http_reply_access on a server HTTP reply arriving.


&gt;<i> 
</I>&gt;<i> The http_*access rules take on ACLs which can be AND'ed if the conditions are in one line, or OR'ed if they are on seperate lines.
</I>
That is binary, access control lines are trinary logic with short-cuts.

&gt;<i> eg.
</I>&gt;<i> http_access allow goodAgents !baddomains (AND)
</I>&gt;<i> #--
</I>&gt;<i> http_access allow goodAgents
</I>&gt;<i> http_access deny baddomains (OR)
</I>
You also have to take action into account.

For this:

   http_access allow goodAgents !baddomains (AND)

  If the first line matches the allow happens.
  otherwise deny happens

ie. goodAgents are only allowed to non-baddomains. All non-goodAgents 
are denied to everything.


For this:

   http_access allow goodAgents
   http_access deny baddomains (OR)

  If the first line matches the allow happens,
  If the second matches deny happens,
  otherwise allow happens.

ie. goodAgents are allowed to do anything. All non-goodAgents are denied 
only to baddomains.


&gt;<i> 
</I>&gt;&gt;&gt;<i> My goal is to deny all client traffic from browsers that DO NOT have
</I>&gt;&gt;&gt;<i> a specific user-agent string. So this is a negated statement.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There is no need to use negation for that. If the goodAgents ACL matches
</I>&gt;&gt;<i> requests with &quot;specific user-agent string&quot;, then you can do this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    http_access allow goodAgents
</I>&gt;&gt;<i>    http_access deny all
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As you can see, there is no ACL negation or negative ACLs.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I understand your example, but unfortunately, I was looking for something else. It's my mistake because I started this thread with basic, stripped-down examples without giving details on what I need to achieve. I wasn't doing ACL negation just for kicks. It's because I need to integrate it into a broader setup.
</I>&gt;<i> 
</I>&gt;<i> Your example &quot;works&quot;, but Squid will match &quot;goodAgent&quot; in your first line, and exit without going on. I require to apply other rules afterwards. In other words, my intention was to first filter based on the UA string, and block all except eg. MyAllowedUAstring. From then on, I need to apply the rest of my rules.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> clientAccessCheckDone: The request CONNECT 89.16.167.134:443 is DENIED; last ACL checked: allowed_useragent
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As you can see, your CONNECT request was denied (because it lacks the
</I>&gt;&gt;<i> User-Agent header). The rest does not matter much (for now), but Squid
</I>&gt;&gt;<i> bumps the connection to serve the error page in response to the first
</I>&gt;&gt;<i> bumped HTTP request (regardless of what that first bumped HTTP request
</I>&gt;&gt;<i> looks like).
</I>&gt;<i> 
</I>&gt;<i> So... What is the security implication of allowing all CONNECT messages to port 443?
</I>&gt;<i> 
</I>
Allowing them all the way through Squid is bad. But that is not what is 
needed here. ssl_bump rules get applied after the CONNECT is accepted 
*in* for proxy processing and they decide what happens to the tunneled 
data based on what is found there.
  If bumping is decided the TLS gets removed and the messages inside 
individually go through the http_access process.


...
&gt;<i> I'd greatly appreciate your input on this.
</I>&gt;<i> 
</I>&gt;<i> Hoping to understand Squid logic someday.
</I>
To speed that up enable debug_options 28,3.

I second Alex's recommendation about removing the &quot;denied_&quot; and 
&quot;allowed_&quot; bits of your ACL names. It will make what is going on a LOT 
clearer to see and understand.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="016977.html">[squid-users] block user agent
</A></li>
	<LI>Next message (by thread): <A HREF="016994.html">[squid-users] block user agent
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16980">[ date ]</a>
              <a href="thread.html#16980">[ thread ]</a>
              <a href="subject.html#16980">[ subject ]</a>
              <a href="author.html#16980">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
