<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] parent peer timeout (Amos Jeffries)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20parent%20peer%20timeout%20%28Amos%20Jeffries%29&In-Reply-To=%3C1979722988.35930395.1511280017168.JavaMail.zimbra%40vera.com.uy%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016993.html">
   <LINK REL="Next"  HREF="016999.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] parent peer timeout (Amos Jeffries)</H1>
    <B>Ignacio Freyre</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20parent%20peer%20timeout%20%28Amos%20Jeffries%29&In-Reply-To=%3C1979722988.35930395.1511280017168.JavaMail.zimbra%40vera.com.uy%3E"
       TITLE="[squid-users] parent peer timeout (Amos Jeffries)">nachofw at adinet.com.uy
       </A><BR>
    <I>Tue Nov 21 16:00:17 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="016993.html">[squid-users] open 256 port
</A></li>
        <LI>Next message (by thread): <A HREF="016999.html">[squid-users] parent peer timeout (Amos Jeffries)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16996">[ date ]</a>
              <a href="thread.html#16996">[ thread ]</a>
              <a href="subject.html#16996">[ subject ]</a>
              <a href="author.html#16996">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Amos, thanks for taking the time to analize this.

&gt;<i>Are you actually terminating the peer, or just simulating it some other way?
</I>My method of testing is shutting down the service on the parent &quot;192.168.1.1&quot; with &quot;/etc/init.d/squid stop&quot;, whith this in place there are no remaining active connections, and no new ones are being established, all I see is tcp RST responses.
It seems there is a TCP timer that is not configurable, because of the time it takes to notice the dead peer:
&gt;<i> 2017/11/20 22:55:02| Ready to serve requests.
</I>&gt;<i> 2017/11/20 22:55:03| storeLateRelease: released 0 objects
</I>&gt;<i> 2017/11/20 22:56:55| TCP connection to 192.168.1.1/3128 failed
</I>&gt;<i> 2017/11/20 22:56:55| TCP connection to 192.168.1.1/3128 failed
</I>&gt;<i> 2017/11/20 22:56:55| Detected DEAD Parent: 192.168.1.1
</I>My objective is to configure dead peer detection based only in TCP connection, can this be achieved?

Do I need to allow a specific type of traffic with &quot;cache_peer_access&quot; statements so dead peer detection happens?, if I comment those lines, dead peer detection works, but I need to enable it so i can filter what traffic those parent peers accept.


regards,
ignacio



On 21/11/17 14:09, Ignacio Freyre wrote:
&gt;<i> Hi guys, i have a simple configuration that i'm testing with 2 parent proxys for a specific domain, if parent proxy 192.168.1.1 fails, failover to 192.168.1.2 proxy.
</I>&gt;<i> I have a couple of questions:
</I>&gt;<i> 1)Having configured &quot;connect-timeout=3&quot; and &quot;connect-fail-limit=2&quot;, failover takes about 2 minutes, how can I reduce failover time?
</I>
Are you actually terminating the peer, or just simulating it some other way?

The behaviour you are seeing is what will happen for the particular 
error you cause to happen. I suspect you are only simulating a firewall 
rule table overload (ie firewall suddenly stops allowing *new* 
connections) instead of actual peer machine disconnect or shutdown.

The connect-timeout=3 is to make *new* TCP connections signal failure if 
the SYN+ACK takes more than 3 seconds to return. Otherwise it is a 
successful connect.

Added to that Squid is HTTP/1.1 software these days. Which means it uses 
multiplexing and pipeline features to reduce new TCP connections being 
needed at all. So that type of network failure may have zero effect on 
the proxy&lt;-&gt;peer communications. Exactly as intended by the HTTP/1.1 design.


&gt;<i> 2)If I enable cache_peer_access statements, failover never happens because the peers dont get detected as dead
</I>

You disabled the features used as primary methods of detecting dead 
peers (no-query no-digest).

Additionally restricting traffic with cache_peer_access removes 
additional hints from HTTP and TCP traffic.


It is hard to say how those two things are impacting your proxies peer 
selection logic, since it is also complicated by the things mentioned 
above about #1.


&gt;<i> 
</I>&gt;<i> #CONFIGURATION START
</I>&gt;<i> #hostname
</I>&gt;<i> visible_hostname testing
</I>&gt;<i> 
</I>&gt;<i> #parent proxy's
</I>&gt;<i> cache_peer 192.168.1.1 parent 3128 0 no-query no-digest connect-timeout=3 connect-fail-limit=2
</I>&gt;<i> cache_peer 192.168.1.2 parent 3128 0 no-query no-digest connect-timeout=3 connect-fail-limit=2
</I>&gt;<i> 
</I>&gt;<i> #send traffic to peers
</I>&gt;<i> acl foo_url url_regex site\.domain\.com
</I>&gt;<i> never_direct allow foo_url
</I>
regex is the second slowest ACL type around, generally to match domain 
use dstdomain ACL type.


&gt;<i> 
</I>&gt;<i> #peer access
</I>&gt;<i> cache_peer_access 192.168.1.1 deny !foo_url
</I>&gt;<i> cache_peer_access 192.168.1.2 deny !foo_url
</I>&gt;<i> 
</I>&gt;<i> #allow all for testing purposes
</I>&gt;<i> http_access allow all
</I>&gt;<i> 
</I>
Not a good idea even for testing purposes. If there is a problem with 
your intended http_access rules that needs solving before anything else 
can be properly investigated since what is allowed to be handled by the 
proxy impacts on what can happen for outbound attempts.


&gt;<i> # Squid normally listens to port 3128
</I>&gt;<i> http_port 3128
</I>&gt;<i> 
</I>&gt;<i> # Leave coredumps in the first cache dir
</I>&gt;<i> coredump_dir /var/spool/squid
</I>&gt;<i> 
</I>&gt;<i> # Add any of your own refresh_pattern entries above these.
</I>&gt;<i> refresh_pattern ^ftp:           1440    20%     10080
</I>&gt;<i> refresh_pattern ^gopher:        1440    0%      1440
</I>&gt;<i> refresh_pattern -i (/cgi-bin/|\?) 0     0%      0
</I>&gt;<i> refresh_pattern .               0       20%     4320
</I>&gt;<i> #CONFIGURATION END
</I>&gt;<i> 
</I>&gt;<i> LOGS that I see when peer is detected as dead
</I>&gt;<i> 2017/11/20 22:55:02| Ready to serve requests.
</I>&gt;<i> 2017/11/20 22:55:03| storeLateRelease: released 0 objects
</I>&gt;<i> 2017/11/20 22:56:55| TCP connection to 192.168.1.1/3128 failed
</I>&gt;<i> 2017/11/20 22:56:55| TCP connection to 192.168.1.1/3128 failed
</I>&gt;<i> 2017/11/20 22:56:55| Detected DEAD Parent: 192.168.1.1
</I>&gt;<i> 
</I>
Configure &quot;debug_options 28,3&quot; to see the peer selection results.


Amos


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="016993.html">[squid-users] open 256 port
</A></li>
	<LI>Next message (by thread): <A HREF="016999.html">[squid-users] parent peer timeout (Amos Jeffries)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16996">[ date ]</a>
              <a href="thread.html#16996">[ thread ]</a>
              <a href="subject.html#16996">[ subject ]</a>
              <a href="author.html#16996">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
