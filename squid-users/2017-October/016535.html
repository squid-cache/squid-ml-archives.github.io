<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Cache digest vs ICP
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Cache%20digest%20vs%20ICP&In-Reply-To=%3Ceadf68b1-4ae2-f41a-ae24-d6cc82dcf7ca%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016533.html">
   <LINK REL="Next"  HREF="016534.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Cache digest vs ICP</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Cache%20digest%20vs%20ICP&In-Reply-To=%3Ceadf68b1-4ae2-f41a-ae24-d6cc82dcf7ca%40measurement-factory.com%3E"
       TITLE="[squid-users] Cache digest vs ICP">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Oct  2 16:36:58 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="016533.html">[squid-users] Cache digest vs ICP
</A></li>
        <LI>Next message (by thread): <A HREF="016534.html">[squid-users] tuning squid memory (aka avoiding the reaper)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16535">[ date ]</a>
              <a href="thread.html#16535">[ thread ]</a>
              <a href="subject.html#16535">[ subject ]</a>
              <a href="author.html#16535">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 10/02/2017 08:28 AM, Veiko Kukk wrote:

&gt;<i> I found it in the book by Duane Wessels
</I>&gt;<i> Quoting: During each invocation of the rebuild function, Squid adds some
</I>&gt;<i> percentage of the cache to the digest. Squid doesn't process user
</I>&gt;<i> requests while this function runs.
</I>
The quoted statement is correct: Digesting a (configurable) percentage
of cache index is a blocking action -- Squid does not process anything
else while that action runs. As we discussed earlier, digesting the
whole cache index is not blocking. This is similar to how one network
read is blocking but receiving the entire response body is not blocking.



&gt;<i>     Cache Digests are not SMP aware (but should be). You may be able to work
</I>&gt;<i>     around that limitation using SMP macros, but I have not tested that. I
</I>&gt;<i>     do not remember whether a worker that is not configured to generate a
</I>&gt;<i>     digest will still look it up in the cache when a peer asks for it.
</I>&gt;<i>     Hopefully, the worker will do that lookup.
</I>&gt;<i> 
</I>&gt;<i> That sounds very interesting. Could you point me to sample configuration?
</I>
I am not aware of any sample configurations that restrict digest
generation to a single worker, but that does not mean they do not exist.
SMP macros in general are described in the beginning of
squid.conf.documented.



&gt;<i> How frequently are cache digests refreshed from
</I>&gt;<i> siblings? 
</I>
The short answer is &quot;a new peer digest is fetched PeerDigestReqMinGap
seconds after its earlier cached version has expired&quot;. I believe the
details are covered by the discussion below and the following FAQ entry:
<A HREF="https://wiki.squid-cache.org/SquidFaq/CacheDigests#How_are_Cache_Digests_transferred_between_peers.3F">https://wiki.squid-cache.org/SquidFaq/CacheDigests#How_are_Cache_Digests_transferred_between_peers.3F</A>



&gt;<i> It seems to me that it takes quite a lot time and i have not
</I>&gt;<i> found anything in documentation that could help enfroce digest
</I>&gt;<i> refreshing. 
</I>
digest_rebuild_period controls how often the local digest is refreshed.
Bugs notwithstanding, the local digest expiration (and the Expires field
in digest HTTP response) should be set accordingly.


&gt;<i> In test system, i've set 'digest_rebuild_period 60 second'.
</I>
Squid has several hard-coded rate limits for digest fetches:

* refresh a given peer digest no more than once in 5 minutes:

  /* min interval for requesting digests from a given peer */
  static const time_t PeerDigestReqMinGap = 5 * 60;   /* seconds */

* and request a digest no more frequently than once per minute:

  /* min interval for requesting digests (cumulative request stream) */
  static const time_t GlobDigestReqMinGap = 1 * 60;   /* seconds */


Notes for your future tests, if any:

* If you are running an SMP Squid, then please repeat the test without
SMP. Make sure non-SMP configuration works before you try to configure
SMP Squid (which will probably require lowering digest_rewrite_period as
well so that all workers can see the newly generated digest on disk).

* A 60 second refresh feels too aggressive to me. Any
digest_rebuild_period longer than digest generation should work in
theory, but I would be worried about various hard-coded hack interfering
with such a small value as 60 seconds. I recommend starting with 5
minute or longer periods. A longer regeneration period would also go
nicely with PeerDigestReqMinGap discussed above.


&gt;<i> With clean cache and running test downloads sibling1 very quickly
</I>&gt;<i> updates it's cache digest:
</I>&gt;<i> 
</I>&gt;<i> Local Digest:
</I>&gt;<i> store digest: size: 10492 bytes
</I>&gt;<i> entries: count: 415 capacity: 16787 util: 2%
</I>&gt;<i> deletion attempts: 0
</I>&gt;<i> bits: per entry: 5 on: 1648 capacity: 83936 util: 2%
</I>&gt;<i> bit-seq: count: 3224 avg.len: 26.03
</I>&gt;<i> added: 415 rejected: 0 ( 0.00 %) del-ed: 0
</I>&gt;<i> collisions: on add: 0.00 % on rej: -1.00 %
</I>&gt;<i> 
</I>&gt;<i> I've waited at least 20 minutes, several times ran downloads agains
</I>&gt;<i> sibling2 (clean cache too) and sibling2 (192.168.1.52) still shows old,
</I>&gt;<i> almost empty cache digest for sibling1(192.168.1.51):
</I>
Please note that if the old digest1 was generated before you changed
digest_rebuild_period for sibling1, then its old cached version will
still have that old expiration date. I am _not_ saying that is what
happens in your specific test, but please keep this caveat in mind.

Also, the 192.168.1.51 digest shown below is not &quot;almost empty&quot; -- the
stats below show that it has 55% of its bits turned on, with all 51
expected entries digested. AFAICT, that digest is full.


&gt;<i> Peer Digests:
</I>&gt;<i> no guess stats for all peers available
</I>&gt;<i> 
</I>&gt;<i> Per-peer statistics:
</I>&gt;<i> 
</I>&gt;<i> peer digest from 192.168.1.51
</I>&gt;<i> no guess stats for 192.168.1.51 available
</I>&gt;<i> 
</I>&gt;<i> event          timestamp    secs from now    secs from init
</I>&gt;<i> initialized    1506952649    -1602              +0
</I>&gt;<i> needed         1506953341     -910            +692
</I>&gt;<i> requested      1506953341     -910            +692
</I>&gt;<i> received       1506953341     -910            +692
</I>&gt;<i> next_check     1506956584    +2333           +3935
</I>
&gt;<i> peer digest state: needed: yes, usable: yes, requested:&#160; no
</I>
&gt;<i> last retry delay: 0 secs
</I>&gt;<i> last request response time: 0 secs
</I>&gt;<i> last request result: success
</I>
&gt;<i> peer digest traffic:
</I>&gt;<i> requests sent: 1, volume: 0 KB
</I>&gt;<i> replies recv:&#160; 1, volume: 0 KB
</I>&gt;<i> 
</I>&gt;<i> peer digest structure:
</I>&gt;<i> 192.168.1.51 digest: size: 32 bytes
</I>&gt;<i> entries: count: 51 capacity: 51 util: 100%
</I>&gt;<i> deletion attempts: 0
</I>&gt;<i> bits: per entry: 5 on: 142 capacity: 256 util: 55%
</I>&gt;<i> bit-seq: count: 131 avg.len: 1.95
</I>
If I am reading the above sibling2 stats correctly, then sibling2
downloaded and cached a tiny 32-byte digest1 910 seconds ago and will
refresh the cached copy in 2333 seconds. That next check will come
(3935-692)/60 = (2333+910)/60 = 54 minutes after digest1 birth. You
should be able to correlate that with digest1 generation stats reported
by 192.168.1.51 at the time when this digest was generated.


HTH,

Alex.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="016533.html">[squid-users] Cache digest vs ICP
</A></li>
	<LI>Next message (by thread): <A HREF="016534.html">[squid-users] tuning squid memory (aka avoiding the reaper)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16535">[ date ]</a>
              <a href="thread.html#16535">[ thread ]</a>
              <a href="subject.html#16535">[ subject ]</a>
              <a href="author.html#16535">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
