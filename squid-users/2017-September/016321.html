<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Http write cache
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Http%20write%20cache&In-Reply-To=%3CAM5PR0901MB08985F32EA7A50667C617C48E1680%40AM5PR0901MB0898.eurprd09.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016319.html">
   <LINK REL="Next"  HREF="016323.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Http write cache</H1>
    <B>Olivier MARCHETTA</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Http%20write%20cache&In-Reply-To=%3CAM5PR0901MB08985F32EA7A50667C617C48E1680%40AM5PR0901MB0898.eurprd09.prod.outlook.com%3E"
       TITLE="[squid-users] Http write cache">olivier.marchetta at outlook.com
       </A><BR>
    <I>Mon Sep 11 12:50:08 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="016319.html">[squid-users] Http write cache
</A></li>
        <LI>Next message (by thread): <A HREF="016323.html">[squid-users] Need assistance debugging Squid error: ssl_ctrd	helpers crashing too quickly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16321">[ date ]</a>
              <a href="thread.html#16321">[ thread ]</a>
              <a href="subject.html#16321">[ subject ]</a>
              <a href="author.html#16321">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thank you Amos for this enlightenment.
I really do appreciate your help.
I will stay with the reverse proxy configuration for our POC.
We need more to cache the libraries data reads than the writes at the moment.
And the next version of OneDrive client should help with the asynchronous writes.
Still, it will download from the Cloud so Squid is necessary in all cases.

Thank you.
Regards,
Olivier MARCHETTA


-----Original Message-----
From: squid-users [mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users-bounces at lists.squid-cache.org</A>] On Behalf Of Amos Jeffries
Sent: Sunday, September 10, 2017 6:25 PM
To: <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
Subject: Re: [squid-users] Http write cache

On 10/09/17 21:14, Olivier MARCHETTA wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;&gt;<i> Origin servers can sometimes respond to requests with payload (&quot;uploads&quot;) before the request has fully arrived, but any subsequent network issues are guaranteed to result in data loss - so the practice is discouraged.
</I>&gt;<i> 
</I>&gt;<i> If I understand, when it's a download (GET), Squid will replace the payload with the object in cache, if fresh.
</I>
Nod. This is possible because two identical requests

&gt;<i> But the HTTP control messages are still coming from the Origin server.
</I>
Not necessarily. There are no &quot;control messages&quot; as such in HTTP. The cache controls are delivered along with the cached payload to indicate what can be done with it. Synchronous server contact (aka revalidation) to deliver responses is only required if those controls say so.


&gt;<i> In case of an upload (PUT), it won't accelerate to use the Squid 
</I>&gt;<i> cache, because the client has to wait for the Origin server's response of the payload transfer (or request).
</I>
Yes. Squid has never seen the request before, so has no idea what response will appear as a result.

&gt;<i> 
</I>&gt;<i> The only option to make uploads faster is if the Origin server is aware that the client is using a reverse proxy cache and respond to the upload request before the full payload transfer.
</I>&gt;<i> 
</I>
Close, bit not quite. The server does not need to know about the proxy, it just has to know the upload payload is &quot;pointless waste of bandwidth&quot; 
  (where data loss don't matter) and deliver its response early.

For example; this is usually seen with NTLM authentication, where uploads without credentials are denied early. Because the upload has to be repeated in full with the right credentials and all the bytes from the first attempt can be dropped in-transit by the proxy.


&gt;<i> Tell me if I'm wrong, but I think that I understand now.
</I>&gt;<i> Meaning that if I want to &quot;bufferize&quot; the writes it has to happen with another protocol before the WebDAV connection to Sharepoint Online.
</I>&gt;<i> 
</I>
The &quot;other protocol&quot; is WebDAV as far as I know. HTTP is just about delivery of some request and its corresponding response. How WebDAV transfers use HTTP messaging, and which parts of HTTP and WebDAV the client and server implement may or may not support the behaviour you want.


You are then colliding with the definition differences between &quot;cache&quot; 
and &quot;buffer&quot;. Caches store *past* data for the purpose of reducing current/future server work, buffers store *current* data awaiting delivery.
  An upload is normally not something seen previously, so not cacheable.

Proxies and the network itself *do* buffer data along the way. But that in no way adds any asynchronous properties to HTTP. The client still has to wait for the HTTP response to be delivered back to it before it can consider the HTTP part of that transaction over - the &quot;transaction&quot; in this context may or may not be the full WebDAV upload+processing on the server.

HTTP has some mechanisms that can help improve upload behaviour and avoid pointless bandwidth delivery. Notably the Expect:100-continue and Range features and 201/202 status codes. WebDAV extensions to HTTP add various other things I'm not very familiar with.
  Between them they can signal to the client a server is a) contactable before data gets delivered, b) deliver it in small chunks to minimize loss, and c) that any given part has completed arrival and awaiting some state (ie full object arrival) and/or some async processing.


BUT, as should be obvious these are all application-logic level things (ie WebDAV) and require explicit support by both the endpoint applications on server and client for that logic to take place. The async properties arise from how things are done *between* HTTP transactions. The interactions are separate synchronous request+response message pairs as far as Squid and any HTTP infrastructure is concerned.

Amos
_______________________________________________
squid-users mailing list
<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
<A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="016319.html">[squid-users] Http write cache
</A></li>
	<LI>Next message (by thread): <A HREF="016323.html">[squid-users] Need assistance debugging Squid error: ssl_ctrd	helpers crashing too quickly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16321">[ date ]</a>
              <a href="thread.html#16321">[ thread ]</a>
              <a href="subject.html#16321">[ subject ]</a>
              <a href="author.html#16321">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
