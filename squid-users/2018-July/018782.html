<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] server persistent connections and cache
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20server%20persistent%20connections%20and%20cache&In-Reply-To=%3C3d11195e-fcd3-f617-cd09-d67b4a23dcfa%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018780.html">
   <LINK REL="Next"  HREF="018784.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] server persistent connections and cache</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20server%20persistent%20connections%20and%20cache&In-Reply-To=%3C3d11195e-fcd3-f617-cd09-d67b4a23dcfa%40treenet.co.nz%3E"
       TITLE="[squid-users] server persistent connections and cache">squid3 at treenet.co.nz
       </A><BR>
    <I>Fri Jul 27 03:15:22 UTC 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="018780.html">[squid-users] server persistent connections and cache
</A></li>
        <LI>Next message (by thread): <A HREF="018784.html">[squid-users] server persistent connections and cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18782">[ date ]</a>
              <a href="thread.html#18782">[ thread ]</a>
              <a href="subject.html#18782">[ subject ]</a>
              <a href="author.html#18782">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 27/07/18 13:31, Alex Rousskov wrote:
&gt;<i> On 07/26/2018 05:47 PM, Vishali Somaskanthan wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> By re-use I meant to say that the server-connection S (TCP + SSL) is
</I>&gt;&gt;<i> re-used across 2 client connections (C1 and C2), from the same client
</I>&gt;&gt;<i> one after the other is torn down. I, presume that
</I>&gt;&gt;<i> &#8220;/server_persistent_connection on/&#8221; allows for such a use-case.
</I>&gt;<i> 
</I>&gt;<i> server_persistent_connection controls whether a single Squid-to-server
</I>&gt;<i> connection can carry more than one request. It does not (or should not)
</I>&gt;<i> control re-pinning.
</I>&gt;<i> 
</I>
Also, pinned connections should never be added to the persistent pool
after pinning. Doing so is a bug IMO. See the sequence at the end of
this mail.

&gt;<i> 
</I>&gt;&gt;<i> Is my
</I>&gt;&gt;<i> understanding that Pinning means binding C1 to S and then if C1 is
</I>&gt;&gt;<i> closed, we unpin and then later if C2 is created, we can pin it again to S?
</I>&gt;<i> 
</I>&gt;<i> IIRC, a lot of code assumes that pinning ties C1 and S connection
</I>&gt;<i> lifetimes together. I do not know whether all code assumes that. I do
</I>&gt;<i> not know whether there is consensus that &quot;same lifetimes&quot; is the correct
</I>&gt;<i> approach for all pinned connections.
</I>&gt;<i> 
</I>
Correct (Alex). Pinning to us/Squid means the two connections have done
something stateful - which means shared fate is required from that point
onwards to avoid nasties outside Squid screwing with that statefulness.

Today I work to:
* If one dies they both do.
* A pinned server connection must not be usable by any other client
*after* being pinned.
* A connection not pinned may only be used by *one* client at a time.

There may be old code which does not check pinned state when it should
or makes wrong assumptions about a pinned connection usability. Please
fix as and when found.


&gt;<i> 
</I>&gt;&gt;<i> There is some confusion in my understanding this statement &#8211; &#8220;pinning
</I>&gt;&gt;<i> _all_ SslBump connections is easier&#160;than pinning some of them&#8221;, because
</I>&gt;&gt;<i> I see different behaviors when I bump at Step 1 (case 1) vs bump at Step
</I>&gt;&gt;<i> 2 (case 2).
</I>&gt;<i> 
</I>&gt;<i> Just because something is easier in retrospect, does not mean it was
</I>&gt;<i> easy or even clear to the developers writing bits and pieces of that
</I>&gt;<i> code. There are a lot of inconsistencies (and bugs) that we are slowly
</I>&gt;<i> weeding out.
</I>&gt;<i> 
</I>
Sending the client handshake to a server makes the TLS end-to-end
stateful between the client&lt;-&gt;server. So *that* is the first point at
which pinning is required by Squid.

Peeking at step1 alone does not add statefulness to the client
connection being peeked.

Peeking at step2 requires client data sent to the server. So pinning is
required.

Bumping at step1 does not involve any server information. So no pinning
required. The client is talking to *Squid* over TLS independent of how
the response is fetched.

Bumping at step2 or step3 the client is talking to the specific server
over TLS.

Splice at any time requires tunneling data both ways. So pinning is
required in all cases.

Stare AFAIK does send *some* client state (filtered) to the server so
pinning is probably always required here - but may not be depending on
what the filtering was.


&gt;<i> 
</I>&gt;&gt;<i> Case 1: We see that no pinning happens i.e. pinConnection() is not
</I>&gt;&gt;<i> called at all. C1-&gt;S gets established, C1 is closed and then C2 re-uses S
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Case 2: We see that pinning happens i.e. httpsPeeked() calls
</I>&gt;&gt;<i> pinConnection(). Here, C1-&gt;S gets established. Closing C1 from the
</I>&gt;&gt;<i> client brings down S. Later, opening C2 opens a new server-connection S.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Is this the expected behavior?
</I>&gt;<i> 
</I>&gt;<i> The code just happens to work this way (evidently). It is not something
</I>&gt;<i> I would rely on until the matter is discussed and settled.
</I>&gt;<i> 
</I>

I think the described behaviour of C2 using S after C1 has pinned the
connection is a bug.

* S should not be pooled as persistent until the client which triggered
its TCP open has finished with it (eg after the TLS handshake completes).

* Once the handshake begins sending client data, whichever client was
opening it should pin it.

* The sequence of the above two should result in S being pinned before
it is ever considered for the persistence pool. Which should cause it to
be excluded from the servers pool.

So IMO when these things are working properly, C2 server selection
should never even see that S exists let alone be able to use it.

Amos


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="018780.html">[squid-users] server persistent connections and cache
</A></li>
	<LI>Next message (by thread): <A HREF="018784.html">[squid-users] server persistent connections and cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18782">[ date ]</a>
              <a href="thread.html#18782">[ thread ]</a>
              <a href="subject.html#18782">[ subject ]</a>
              <a href="author.html#18782">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
