<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] server persistent connections and cache
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20server%20persistent%20connections%20and%20cache&In-Reply-To=%3Cb2c42ae3-0578-a246-2f08-88c787c5fdcd%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018786.html">
   <LINK REL="Next"  HREF="018801.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] server persistent connections and cache</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20server%20persistent%20connections%20and%20cache&In-Reply-To=%3Cb2c42ae3-0578-a246-2f08-88c787c5fdcd%40measurement-factory.com%3E"
       TITLE="[squid-users] server persistent connections and cache">rousskov at measurement-factory.com
       </A><BR>
    <I>Fri Jul 27 15:57:37 UTC 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="018786.html">[squid-users] server persistent connections and cache
</A></li>
        <LI>Next message (by thread): <A HREF="018801.html">[squid-users] server persistent connections and cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18787">[ date ]</a>
              <a href="thread.html#18787">[ thread ]</a>
              <a href="subject.html#18787">[ subject ]</a>
              <a href="author.html#18787">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>[There is a potentially useful reframing of the question at the end if
you want to skip the details...]

On 07/26/2018 11:11 PM, Amos Jeffries wrote:
&gt;<i> On 27/07/18 16:18, Alex Rousskov wrote:
</I>
&gt;&gt;<i> one could argue that Squid should honor a
</I>&gt;&gt;<i> (higher level) client and server assumption that they are talking to
</I>&gt;&gt;<i> each other (at HTTP+ level).
</I>
&gt;<i> Configuring persistence on/off is the way to control that, not pinning.
</I>
I disagree. Persistence is about a single connection. Pinning is about
the relationship between two connections. Honoring tunneling
expectations can be about pinning, but it is not about persistence.
Naturally, there is no pinning without persistence, but that is
irrelevant for designing how to support tunneling expectations.


&gt;&gt;<i> We will probably break fewer transactions
</I>&gt;&gt;<i> that way. With that idea in mind, the &quot;first point&quot; becomes establishing
</I>&gt;&gt;<i> a TCP tunnel with the server, even if no client Hello pieces are forwarded.
</I>
&gt;<i> HTTP(S) being stateless, at that level any endpoint relying on implicit
</I>&gt;<i> state is non-compliant and buggy.
</I>
What is known as HTTP statelessness is irrelevant here: HTTP CONNECT
tunnel itself is a &quot;state&quot;; agents have the right to rely on that state.
That state is not a state that relates to HTTP messages so there is no
contradiction with HTTP stateless principles. From HTTP point of view,
there are no HTTP messages inside that tunnel. The tunnel is a monolith
at HTTP level. Not treating it as such will break some HTTP-compliant
agents.

Same for intercepted TLS/TCP connections -- the preservation of those
TLS and TCP connections is something an HTTP-compliant agent can
legitimately rely on.


&gt;<i> It is *nice* not to result in visible errors, but not a requirement we
</I>&gt;<i> should stick to at cost of proper behaviour.
</I>
The open question is how to define what is &quot;proper&quot;. Any behavior will
have pros and cons associated with it. You cannot declare lack of
pinning a &quot;proper behavior&quot; just because most agents do not require
pinning. The decision is more complex than that because there are more
variables involved.


&gt;<i> The client accepted proof that Squid *was* that origin (false or not)
</I>&gt;<i> order to reach said higher levels.
</I>
I disagree that being content with Squid certificate (TLS level)
constitutes acceptance of an intermediary that can switch from one
server to another at will (higher level).


&gt;<i> Pinning at a later time due to higher
</I>&gt;<i> level stateful situation is not relevant to the bumping code actions and
</I>&gt;<i> not something we need to consider at the present C2 use of S after C1
</I>&gt;<i> should have pinned it.
</I>
Agreed. I do not think that contradicts what I was (and am) saying. The
question here is whether &quot;C1 should have pinned S&quot; after bumping C1 at
step1.


&gt;<i> &quot;after C1 has pinned&quot; - if no pinning happens at all the whole
</I>&gt;<i> statement is irrelevant.
</I>
Correct. The question is whether C1 should pin S after bumping at step1.
Today, no such pinning happens, but it could be argued that this is a
bug. It is a complicated question with many variables and no obvious
answers.


&gt;<i> What I'm most confused about here is why S is closed when C1 dies with
</I>&gt;<i> non-pinning.  _unless_ there is pinning between them they should not be
</I>&gt;<i> that closely fate sharing.
</I>&gt;<i> 
</I>&gt;<i> Is the HTTPS message on both C1 and S saying &quot;Connection: close&quot; perhapse?
</I>
or perhaps some kind of still-linked FwdState/Client abort if C1 was not
closed properly/orderly.



&gt;<i> Off-topic; TLS has connections that do not use handshakes at all, which
</I>&gt;<i> are becoming more common in TLS/1.3. So I believe such a feature may be
</I>&gt;<i> coming one day, but irrelevant right now.
</I>
IIRC, all TLS versions, including v1.3, start a TLS connection with a
handshake. The scope/meaning of that handshake varies across versions,
but there is always some handshake.


&gt;&gt;<i> The open question is whether S should be pinned in the case where C1 is
</I>&gt;&gt;<i> bumped at step1 (i.e., &quot;Case 1&quot; in Vishali's email).
</I>
&gt;<i> IMO in *that* specific case S should not be pinned. Because pinning
</I>&gt;<i> would prevent the very reasonable actions of handling server failures by
</I>&gt;<i> opening new Sn connections to finish incomplete responses to the client,
</I>&gt;<i> or retaining a server connection for the quick_abort features.
</I>
IMO in that specific case S should be pinned by default because pinning
will break fewer transactions and any breakage would be easier to
triage/explain. That default may also be more &quot;secure&quot; because without
pinning, C1 can start requesting content from other servers, possibly
violating admin expectations that rely on vetting C1 based on TLS-level
information such as SNI).

What do we do now for intercepted HTTP clients -- are they allowed to
request content from a server they were _not_ going to when intercepted?



&gt;<i> Squid should instead be ensuring that the server handshake at TLS level
</I>&gt;<i> matches what it would have used for C2 clean handshake. I may have
</I>&gt;<i> missed it, but that is not yet being done (just TCP equivalence, not TLS).
</I>
If we do not honor the tunneling semantics (i.e., do not pin S1), then I
see no reason to ensure that S1 and S2 handshakes match. S2 can even go
to a different server.


The same question can be formulated in a more general way, which may be
useful when comparing what Squid already does across different
configurations/scenarios: Which of the following should be &quot;pinned&quot;?

0. Nothing (free to switch to a different origin server).
1. Destination server name (free to switch to a different IP).
2. Destination IP:port (free to reestablish or reuse a connection).
3. Destination connection (free to serve cache hits).
4. Destination (no freedom at all; like regular tunnels today).

For Case1, Squid probably uses #0 or #1 pinning today. We need to decide
whether Squid should use #2 or #3 instead.

For Case2, Squid uses #3 pinning today AFAICT.

#4 is probably best addressed using the serve_hit directive.


Alex.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="018786.html">[squid-users] server persistent connections and cache
</A></li>
	<LI>Next message (by thread): <A HREF="018801.html">[squid-users] server persistent connections and cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18787">[ date ]</a>
              <a href="thread.html#18787">[ thread ]</a>
              <a href="subject.html#18787">[ subject ]</a>
              <a href="author.html#18787">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
