<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] tcp_outgoing_address and HTTPS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20tcp_outgoing_address%20and%20HTTPS&In-Reply-To=%3C856483c6-3a0d-b75c-81ce-ec471aa8d18f%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017870.html">
   <LINK REL="Next"  HREF="017879.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] tcp_outgoing_address and HTTPS</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20tcp_outgoing_address%20and%20HTTPS&In-Reply-To=%3C856483c6-3a0d-b75c-81ce-ec471aa8d18f%40treenet.co.nz%3E"
       TITLE="[squid-users] tcp_outgoing_address and HTTPS">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Mar 20 13:55:38 UTC 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="017870.html">[squid-users] tcp_outgoing_address and HTTPS
</A></li>
        <LI>Next message (by thread): <A HREF="017879.html">[squid-users] [squid-dev]  tcp_outgoing_address and HTTPS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17874">[ date ]</a>
              <a href="thread.html#17874">[ thread ]</a>
              <a href="subject.html#17874">[ subject ]</a>
              <a href="author.html#17874">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 21/03/18 00:11, Michael Pro wrote:
&gt;<i> squid-5 master branch, not have  personal/private repository changes,
</I>&gt;<i> not use  cache_peer's ability, (if it's matters - not use transparent
</I>&gt;<i> proxying ability).
</I>&gt;<i> 
</I>&gt;<i> We have a set of rules (ACL's with url regex) for content, depending
</I>&gt;<i> on which we make a decision for the outgoing address, for example,
</I>&gt;<i> from 10.10.1.xx to 10.10.6.xx
</I>&gt;<i> -----log 1part {{{ -----
</I>&gt;<i> Acl.cc(151) matches: checked: tcp_outgoing_address 10.10.5.11 = 1
</I>&gt;<i> Checklist.cc(63) markFinished: 0x7fffffffe2b8 answer ALLOWED for match
</I>&gt;<i> FilledChecklist.cc(67) ~ACLFilledChecklist: ACLFilledChecklist
</I>&gt;<i> destroyed 0x7fffffffe2b8
</I>&gt;<i> Checklist.cc(197) ~ACLChecklist: ACLChecklist::~ACLChecklist:
</I>&gt;<i> destroyed 0x7fffffffe2b8
</I>&gt;<i> peer_select.cc(1026) handlePath: PeerSelector3438 found
</I>&gt;<i> local=10.10.5.11 remote=17.253.37.204:80 HIER_DIRECT flags=1,
</I>&gt;<i> destination #2 for <A HREF="http://iosapps.itunes.apple.com/...xxx...ipa">http://iosapps.itunes.apple.com/...xxx...ipa</A>
</I>&gt;<i> ...
</I>&gt;<i> peer_select.cc(1002) interestedInitiator: PeerSelector3438
</I>&gt;<i> peer_select.cc(112) ~PeerSelector: <A HREF="http://iosapps.itunes.apple.com/...xxx...ipa">http://iosapps.itunes.apple.com/...xxx...ipa</A>
</I>&gt;<i> store.cc(464) unlock: peerSelect unlocking key
</I>&gt;<i> 60080000000000001C0E000001000000 e:=p2IWV/0x815c09500*3
</I>&gt;<i> AsyncCallQueue.cc(55) fireNext: entering AsyncJob::start()
</I>&gt;<i> AsyncCall.cc(38) make: make call AsyncJob::start [call195753]
</I>&gt;<i> AsyncJob.cc(123) callStart: Comm::ConnOpener status in: [ job10909]
</I>&gt;<i> comm.cc(348) comm_openex: comm_openex: Attempt open socket for: 10.10.5.11
</I>&gt;<i> comm.cc(391) comm_openex: comm_openex: Opened socket local=10.10.5.11
</I>&gt;<i> remote=[::] FD 114 flags=1 : family=2, type=1, protocol=6
</I>&gt;<i> -----log 1part }}} -----
</I>&gt;<i> In the case of normal traffic (http), everything works fine, as shuld.
</I>&gt;<i> 
</I>
The difference to be aware of is that there is zero security on this
type of HTTP. So while it is better not to play with destinations, and
Squid default is to go where the client wanted - it is permitted to go
elsewhere if a better source is found.


&gt;<i> In the case of HTTPS with traffic analysis (ssl_bump) we have such a picture:
</I>&gt;<i> -----log 2part {{{ ------
</I>&gt;<i> Acl.cc(151) matches: checked: tcp_outgoing_address 10.10.5.120 = 1
</I>&gt;<i> Checklist.cc(63) markFinished: 0x7fffffffe2b8 answer ALLOWED for match
</I>&gt;<i> FilledChecklist.cc(67) ~ACLFilledChecklist: ACLFilledChecklist
</I>&gt;<i> destroyed 0x7fffffffe2b8
</I>&gt;<i> Checklist.cc(197) ~ACLChecklist: ACLChecklist::~ACLChecklist:
</I>&gt;<i> destroyed 0x7fffffffe2b8
</I>&gt;<i> peer_select.cc(1026) handlePath: PeerSelector569 found
</I>&gt;<i> local=10.10.5.120 remote=23.16.9.11:443 PINNED flags=1, destination #1
</I>&gt;<i> for <A HREF="https://some.https.com/...xxx...zip">https://some.https.com/...xxx...zip</A>
</I>
What PINNED means to Squid is that the client TCP connection is tied up
with some details related to some specific TCP server connection.

In this case the TLS crypto used during the bumping process took crypto
details from the client connection and gave them to the server, then
from the server and gave them to the client. Resulting in a forced
end-to-end relationship between the clinet and server for all traffic
over both those connections.
 The only thing Squid can do is to server some content from cache as
normal HITs, or if you specifically configure ICAP/eCAP service they can
modify the messages as they flow. Delivering the traffic to another
server is not permissable because the HTTP messages can (and often are)
tied to the TLS crypto details as well in ways that are not visible to
Squid.

For example; it is becoming very popular for the endpoints to crypto
sign messages or embed a hash signature which can only be verified valid
using details the server and client exchanged up front. No other server
would be able to send valid values and the client breaks if it is wrong.
 This kind of thing survives even when SSL-Bump'ing because of Squid
pinning, but does add the restrictions you found.


&gt;<i> 
</I>&gt;<i> I understand that without analyzing the traffic and not knowing the
</I>&gt;<i> final goal for the beginning, we can not manage the process further.
</I>&gt;<i> Question: how can we break the established channel (unpinn it) along
</I>&gt;<i> the old route and establish a new channel along the new route, when we
</I>&gt;<i> already know how.
</I>
There are three possibilities that I am aware of - in no particular order:

1) An ICAP service can do whatever it pleases with requests it receives.
We hold no responsibility for anything happening there and I publicly
advise against playing with the crypto that way - the above issues are
the least of the problems to be faced.


2) It is technically possible to make Squid open a CONNECT tunnel
through an HTTP peer proxy to the origin instead of going there
directly. The only thing preventing this is nobody writing the necessary
code.

It has been on my (and many others) wishlist for a long while but still
nobody has been able to work on it. Any assistance towards getting that
coded is very, very welcome.


3) The client-first type of bumping does not involve any server crypto.
This is *highly* unsafe and often encounters problems like the ICAP
approach and for all the same reasons.

BUT that said, if you are sufficiently in control of the traffic to be
sure of its safety then Squid can do it by simply using the bump action
at &quot;step 1&quot; of the SSL-Bump process - rather than the recommended step 2
or 3.

We have err'ed on the side of security with these things so it may not
work right now. But it is not technically required to pin for this
specific type of bumped connection - so the case could be made that it
is a bug to fix if Squid does force pinning on that traffic.

Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="017870.html">[squid-users] tcp_outgoing_address and HTTPS
</A></li>
	<LI>Next message (by thread): <A HREF="017879.html">[squid-users] [squid-dev]  tcp_outgoing_address and HTTPS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17874">[ date ]</a>
              <a href="thread.html#17874">[ thread ]</a>
              <a href="subject.html#17874">[ subject ]</a>
              <a href="author.html#17874">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
