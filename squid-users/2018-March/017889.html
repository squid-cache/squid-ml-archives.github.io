<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] tcp_outgoing_address and HTTPS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20tcp_outgoing_address%20and%20HTTPS&In-Reply-To=%3C93bd1722-4575-13fe-e168-dd8f6dca8aed%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017888.html">
   <LINK REL="Next"  HREF="017877.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] tcp_outgoing_address and HTTPS</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20tcp_outgoing_address%20and%20HTTPS&In-Reply-To=%3C93bd1722-4575-13fe-e168-dd8f6dca8aed%40treenet.co.nz%3E"
       TITLE="[squid-users] tcp_outgoing_address and HTTPS">squid3 at treenet.co.nz
       </A><BR>
    <I>Wed Mar 21 05:48:13 UTC 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="017888.html">[squid-users] tcp_outgoing_address and HTTPS
</A></li>
        <LI>Next message (by thread): <A HREF="017877.html">[squid-users] SSLBump, system requirements ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17889">[ date ]</a>
              <a href="thread.html#17889">[ thread ]</a>
              <a href="subject.html#17889">[ subject ]</a>
              <a href="author.html#17889">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 21/03/18 08:12, Michael Pro wrote:
&gt;<i> Totally agree with you, and at the same time - do not agree. But,
</I>&gt;<i> consider the following situation. There is <A HREF="https://site.net/">https://site.net/</A> where
</I>&gt;<i> there is 1.jpg and 2.jpg. If I download from this site 1.jpg from the
</I>&gt;<i> address 1.1.1.1 and 2.jpg from the address 2.2.2.2.
</I>
There is no such concept as &quot;site&quot; in TLS. It is a point-to-point protocol.
The client opened a single connection and sent two requests to what it
perceives to be a *single* server. If the interception proxy were not
there the content would have been served by that same server anyway.
There is no loss for the proxy to mimic the exact behaviour of the real
client.
 Also the responses have to be served to the client sequentially. So
there is little gain from fetching them any way but sequentially, AND
going to all the trouble of multiple TCP + TLS handshakes adds CPU + RAM
+ socket + time costs to the transaction. So it is a net negative to do
as proposed.


&gt;<i> Even more. There
</I>&gt;<i> are situations when you need to release a certain connection to the
</I>&gt;<i> Internet through a single provider (for example, mobile), but you need
</I>&gt;<i> to download the largest file that is never physically downloaded by
</I>&gt;<i> this connection. On another no way. Squid theoretically these are
</I>&gt;<i> several computers (by the number of incoming connections) and, what
</I>&gt;<i> prevents us as different computers from using different outgoing
</I>&gt;<i> interfaces even for the same origin address?
</I>
The machine-specific TLS crypto keys. In RSA it was possible to copy
these keys between machines (but considered very bad practice). In DH
and ECDH new secret keys are generated for every individual TLS
handshake. They cannot be shared. Once those keys are started being used
the data inside (particular signed items) is locked to them.

To stop an HTTPS transfer mid-delivery requires the proxy to abort both
client and server TLS (and TCP) connections. Which is what the pinning does.

&gt;<i> 
</I>&gt;<i> I'm not saying that you need to push the unbroken.
</I>
That sentence does not compute for me.

&gt;<i> Look at the problem
</I>&gt;<i> from the other side.
</I>&gt;<i> 
</I>&gt;<i> For example, in Chrome, I set up a proxy 1.1.1.1 and download
</I>&gt;<i> <A HREF="https://site.net/1.jpg.">https://site.net/1.jpg.</A> At the same time in Mozilla I set up a proxy
</I>&gt;<i> 2.2.2.2 and download <A HREF="https://site.net/2.jpg.">https://site.net/2.jpg.</A> What's the difference if
</I>&gt;<i> you set up the same one squid?
</I>
The differences are:
1) Squid is not a browser.
2) Squid is not the TLS &quot;end-client&quot;.
2) Squid is not the TLS origin server.
3) different TLS sessions
4) different client TLS security keys
5) different server TLS security keys

Overall there is a 3-way TLS &quot;origin&quot;:

  Chrome + 1.1.1.1:port + the specific IP:443 address of &quot;site.net&quot; that
Chrome chose to connect to.

  Mozilla + 2.2.2.2:port + the specific IP:443 address of &quot;site.net&quot;
that Mozilla chose to connect to.


&gt;<i> acl 1s-jpg url_regex ...1.jpg
</I>&gt;<i> acl 2s-jpg url_regex ... 2.jpg
</I>&gt;<i> tcp_outgoing_address 1.1.1.1 1s-jpg
</I>&gt;<i> tcp_outgoing_address 2.2.2.2 2s-jpg
</I>&gt;<i> 
</I>&gt;<i> Where is the entrance here?
</I>
Please explain this word &quot;entrance&quot; as you mean it?

1.1.1.1 does not hold the dynamically created TLS state inside 2.2.2.2.

2.2.2.2 does not hold the dynamically created TLS state inside 1.1.1.1.

Squid does not hold the TLS state inside the client.

What Squid can do is deliver content in its cache (if caching is
permitted by the origin who generated it). Or deliver the encrypted
traffic to the origin server the client accepted TLS handshake with.


You are perhapse still thinking in traditional caching terms where Squid
is a client independent of the Browser and where TCP connections can be
freely disconnected and rewritten per HTTP request. In plain-text HTTP
that would be true.

When intercepting TLS / HTTPS that is false. The true end-client /
Browser is maintaining client-to-origin state in its TLS properties. For
*precisely* and intentionally the purpose of preventing exactly this
type of traffic rewriting by a proxy.


IF, and *only* if, the client is using &quot;TLS explicit&quot; as defined by TLS
to the proxy and sending regular HTTP requests over that secured
connection can the proxy do its own origin-server choosing freely. Some
people have been calling that type of setup &quot;HTTPS&quot;, but really the
existence of proxy choice makes it a lot different from traditional
HTTPS on port 443.


&gt;<i> 
</I>&gt;<i> Why do we try to shove it into one hole, if we can divide it into
</I>&gt;<i> separate processes. It may even need some new key or ACL to determine
</I>&gt;<i> that for these connections to create always new tunnels (TLS, ssl,
</I>&gt;<i> certs, ...)
</I>&gt;<i> acl separate_this CreateNewTunnelForNewLink
</I>
When ability to generate CONNECTs is added that should not be necessary.
Whether the cache_peer can handle the CONNECT attempt will automatically
determine whether a tunnel is possible as an alternative to
DIRECT/PINNED connection.

Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="017888.html">[squid-users] tcp_outgoing_address and HTTPS
</A></li>
	<LI>Next message (by thread): <A HREF="017877.html">[squid-users] SSLBump, system requirements ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17889">[ date ]</a>
              <a href="thread.html#17889">[ thread ]</a>
              <a href="subject.html#17889">[ subject ]</a>
              <a href="author.html#17889">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
