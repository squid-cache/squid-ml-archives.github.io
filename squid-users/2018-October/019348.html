<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Uncomplete Negotiate negotiation with Kerberos
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Uncomplete%20Negotiate%20negotiation%20with%20Kerberos&In-Reply-To=%3C32111d2d-7548-9ef8-67f2-5de9be61e474%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019345.html">
   <LINK REL="Next"  HREF="019354.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Uncomplete Negotiate negotiation with Kerberos</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Uncomplete%20Negotiate%20negotiation%20with%20Kerberos&In-Reply-To=%3C32111d2d-7548-9ef8-67f2-5de9be61e474%40treenet.co.nz%3E"
       TITLE="[squid-users] Uncomplete Negotiate negotiation with Kerberos">squid3 at treenet.co.nz
       </A><BR>
    <I>Tue Oct  2 22:11:12 UTC 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="019345.html">[squid-users] Uncomplete Negotiate negotiation with Kerberos
</A></li>
        <LI>Next message (by thread): <A HREF="019354.html">[squid-users] Uncomplete Negotiate negotiation with Kerberos
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19348">[ date ]</a>
              <a href="thread.html#19348">[ thread ]</a>
              <a href="subject.html#19348">[ subject ]</a>
              <a href="author.html#19348">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 3/10/18 3:29 AM, Emmanuel Coirier wrote:
&gt;<i> Hi Amos and others,
</I>&gt;<i> 
</I>&gt;<i> Thanks for your response, but I'm afraid I'm not sure to have understood everything...
</I>&gt;<i> 
</I>&gt;&gt;<i> De : squid-users [mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users-bounces at lists.squid-cache.org</A>] De la part 
</I>&gt;&gt;<i> de Amos Jeffries
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> When a browser wants to connect to some random HTTP website, it sends a GET 
</I>&gt;<i> ...
</I>&gt;&gt;<i> to be used.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That is not true. RFC 4559 section 4
</I>&gt;&gt;<i> (&lt;<A HREF="https://tools.ietf.org/html/rfc4559#section-4">https://tools.ietf.org/html/rfc4559#section-4</A>&gt;) defines how Negotiate scheme 
</I>&gt;&gt;<i> operates in HTTP.
</I>&gt;<i> 
</I>&gt;<i> Ok
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> The problem is that it enables some potentially Man in the Middle 
</I>&gt;&gt;&gt;<i> attack (since any malicious proxy where the traffic is diverted could 
</I>&gt;&gt;&gt;<i> then answers back without the client knowing it talks to a malicious 
</I>&gt;&gt;&gt;<i> proxy)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Quite the opposite. The MITM issue you point out is part of the fundamental 
</I>&gt;&gt;<i> design of the Negotiate scheme and exists for both Squid-3 and Squid-4 
</I>&gt;&gt;<i> behaviours.
</I>&gt;<i> 
</I>&gt;<i> Are you telling me that the Negotiate scheme is fundamentally flawed ?
</I>
No more so than any other authentication scheme. If we assume there is
an MITM on the channel, it can as easily relay the tokens as see them.
The security in Negotiate comes from making an MITM not be able to know
anything about what secrets they hold, nor use those opaque secrets on
other connections.


&gt;<i>  
</I>&gt;&gt;<i> Having the client use a token provided in-channel from the proxy enables an MITM 
</I>&gt;&gt;<i> observing that channel to inject changes giving itself control over what the 
</I>&gt;&gt;<i> client does in future authentication. This extra control point is prohibited by 
</I>&gt;<i> 
</I>&gt;<i> I don't understand this point. If we hypothesize that the proxy sends the tokens (including the last one) generated by the service gssapi back to the client (whatever the means), we can think that the gssapi tokens going from service to client are authenticated and encrypted.
</I>
Sorry, I was a bit tired when I wrote that and thinking only of the
Negotiate/Kerberos exchange myself.

There *MAY* be tokens going from proxy to client (eg in Negotiate/NTLM),
but they do so by extending the handshake with extra challenge messages
containing *-Authenticate headers. Not via *-Authentication-Info.


&gt;<i> 
</I>&gt;<i> With Kerberos, it is possible since the client previously sends a service ticket which contains a random session key encrypted with the service key.
</I>
The client sends such ticket to the proxy, the proxy sends it to the DC.
The DC tells the proxy (&quot;OK allow&quot; or &quot;no deny&quot;). The HTTP part of
Kerberos is over with the client delivering its token to the proxy.

This lack of to-and-fro with tokens in messages is what makes
Negotiate/Kerberos significantly faster than either NTLM or Negotiate/NTLM.


&gt;<i> The service can use this session key to authentify its response to the client.
</I>&gt;<i> 
</I>
Responses are messages. Negotiate does not authenticate any message.

The *TCP connection* is what is being authenticated by Negotiate.

A hypothetical MITM is free to alter any message contents within that
connection, so long as it can replay the Negotiate ticket which gives it
permission to open a TCP connection to the proxy.


&gt;<i> So it is harder for a MITM to fake this last gssapi token, especially if the client wait for it. So I don't see how a MITM could exploit this last token.
</I>&gt;<i> 
</I>
What I have been trying to say is that there is no such &quot;last GSSAPI
token&quot; in Kerberos. You are thinking of Negotiate/NTLM contexts here.

And *-Info is informational extra data, not part of the authentication
exchange process.


&gt;<i> Clearly, the http body response could be altered, but it can also be altered in the current situation.
</I>&gt;<i> 
</I>
As can tokens in the HTTP headers. With the same 'but'.


&gt;<i> Or, is it right that a client cannot trust any form of service authentication based on Negotiate since it is fundamentally flawed ? And thus this last token has no use ?
</I>&gt;<i> 
</I>
All the tokens in Negotiate and context exchange is done with
*-Authenticate headers. Not *-Authentication-Info.

There *may* be context exchange that uses reply headers depending on the
specific context. Or there may not be. That has not changed in Squid AFAIK.


&gt;&gt;<i> the Squid-4 behaviour, and has never been a formal part of Negotiate scheme as 
</I>&gt;&gt;<i> you can see from the RFC 4559 texts.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The design of Negotiate/Kerberos has both client and proxy independently contact 
</I>&gt;&gt;<i> the DC to respectively generate and verify the tokens. All token operations are 
</I>&gt;<i> 
</I>&gt;<i> In my undestanding and experiments of Kerberos, the service (here Squid and more precisely its negotiate_kerberos_auth) doesn't contact anything, but only trusts the admin provided keytab (which is just the service key). This service key decrypts a service ticket provided by the client, and if this ticket is fine, the client is authenticated. But it doesn't imply any communication with some KDC (Heimdal for my case) or DC (Or is Microsft Kerberos implementation working differently ?). This has been tested with a KDC shut off when surfing once the service ticket was retrieved.
</I>&gt;<i> 
</I>
If that were the case there would be no need for auth_param helpers to
be configured. Squid passes tokens to the helper which handles all
contact and validation with the DC.

Once a token is validated it becomes *the* token for that TCP
connection. Any change to the token terminates that connection.


&gt;<i> The client contacts the KDC from time to time to get a service ticket, but it's far less than for each TCP connection.
</I>&gt;<i> 
</I>
That is up to the client and DC settings. So far as Squid is concerned
every new TCP connection needs to be separately authenticated.
The helper informs the proxy what user label to log for that token/ticket.


&gt;&gt;<i> performed by the DC itself and contain secrets only the DC knows. The flow of 
</I>&gt;&gt;<i> tokens is exclusively from client to proxy as proof that the client is already 
</I>&gt;&gt;<i> authenticated with the DC. The proxy / server response is intentionally lacking 
</I>&gt;&gt;<i> to starve any MITM of information it might use to reliably affect changes to the 
</I>&gt;&gt;<i> client tokens.
</I>&gt;<i> 
</I>&gt;<i> This is the point I don't understand. Could you tell me more ?
</I>&gt;<i> 
</I>
That is about the best description I can come up with right now. It is
basic PKI key exchange, using separate side channels to the DC instead
of in-channel (HTTP) key/ticket negotiation.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="019345.html">[squid-users] Uncomplete Negotiate negotiation with Kerberos
</A></li>
	<LI>Next message (by thread): <A HREF="019354.html">[squid-users] Uncomplete Negotiate negotiation with Kerberos
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19348">[ date ]</a>
              <a href="thread.html#19348">[ thread ]</a>
              <a href="subject.html#19348">[ subject ]</a>
              <a href="author.html#19348">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
