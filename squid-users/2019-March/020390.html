<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Non-transparent proxy with cache_peer and ssl_bump
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Non-transparent%20proxy%20with%20cache_peer%20and%20ssl_bump&In-Reply-To=%3Cfab68442-7a7d-ef01-be52-8326a74a885f%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020387.html">
   <LINK REL="Next"  HREF="020391.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Non-transparent proxy with cache_peer and ssl_bump</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Non-transparent%20proxy%20with%20cache_peer%20and%20ssl_bump&In-Reply-To=%3Cfab68442-7a7d-ef01-be52-8326a74a885f%40treenet.co.nz%3E"
       TITLE="[squid-users] Non-transparent proxy with cache_peer and ssl_bump">squid3 at treenet.co.nz
       </A><BR>
    <I>Thu Mar 21 03:22:21 UTC 2019</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="020387.html">[squid-users] Non-transparent proxy with cache_peer and ssl_bump
</A></li>
        <LI>Next message (by thread): <A HREF="020391.html">[squid-users] Non-transparent proxy with cache_peer and ssl_bump
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20390">[ date ]</a>
              <a href="thread.html#20390">[ thread ]</a>
              <a href="subject.html#20390">[ subject ]</a>
              <a href="author.html#20390">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 21/03/19 10:58 am, Alex Rousskov wrote:
&gt;<i> On 3/20/19 3:23 PM, Yosi Greenfield wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> ssl_bump splice step3 NoBump
</I>&gt;&gt;<i> ssl_bump bump step3
</I>&gt;<i> 
</I>&gt;&gt;<i> cache_peer proxy2.ourserver.com ... ssl
</I>&gt;<i> 
</I>&gt;<i> Forwarding most SslBump-related connections to cache_peers is still
</I>&gt;<i> unsupported by official Squids, including Squid v3 and v4. Measurement
</I>&gt;<i> Factory code that implements this feature is being officially reviewed
</I>&gt;<i> at <A HREF="https://github.com/squid-cache/squid/pull/380/">https://github.com/squid-cache/squid/pull/380/</A>
</I>&gt;<i> 
</I>&gt;<i> If you can test the above-referenced code, please do.
</I>&gt;<i> 
</I>&gt;<i> However, even if the above-referenced changes are officially accepted
</I>&gt;<i> (into v5), they will not allow you to do &quot;TLS inside TLS&quot; -- you will
</I>&gt;<i> not be able to forward most SslBump-related connections to HTTPS proxies
</I>&gt;<i> (i.e. your &quot;cache_peer ssl&quot;).
</I>&gt;<i> 
</I>&gt;<i> Fortunately, forwarding to HTTPS proxies is not critical in most use
</I>&gt;<i> cases -- one layer of TLS encryption is often enough. Unfortunately, you
</I>&gt;<i> will expose CONNECT requests between Squid1 and Squid2 until we add that
</I>&gt;<i> support or perhaps [controversially] allow bumped traffic to be sent to
</I>&gt;<i> HTTPS proxies without additional encryption. I am not aware of anybody
</I>&gt;<i> working on either right now.
</I>&gt;<i> 
</I>

Er, sending the bumped <A HREF="https://">https://</A> requests to a cache_peer with 'ssl' does
work, though not advised. It is equivalent to the client-first type
SSL-Bumping which has a lot of nasty security side effects.


What is broken here is that squid2 config has http_port receiving the
TLS connections from squid1. So when the plain-text response arrives
from squid2 instead of a TLS server handshake squid1 produces that
negotiate error.



Yosi:

The quick-fix is to add an https_port line to you squid2 and make the
squid1 cache_peer line point at that port instead of 3130.
 Be aware the cert= parameter on squid2 https_port will be used by
squid1 to bump *all* traffic you send through that cache_peer link -
thus causing those nasty client-first problems.

OR, to avoid the client-first effects do not use cache_peer at all. Let
the squid1 traffic go 'direct' and use interception to divert that port
443 traffic into squid2. YMMV on whether this works.

OR, use the experimental PR code Alex referenced for your squid1 and
remove the 'ssl' options from the cache_peer.



Also, please remove DONT_VERIFY_PEER. It hides important problems from
*you* while sill letting them cause major issues to clients. It is not
even useful for debugging because of that hiding.

Also, &quot;sslproxy_cert_error allow all&quot; is a similarly bad idea. There are
*some* errors which you may need to allow, but not everything. Use this
directive with great care. Look into every error that shows up. Properly
fix as many as you can first. Only after that hide the ones which are
still necessary to ignore.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="020387.html">[squid-users] Non-transparent proxy with cache_peer and ssl_bump
</A></li>
	<LI>Next message (by thread): <A HREF="020391.html">[squid-users] Non-transparent proxy with cache_peer and ssl_bump
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20390">[ date ]</a>
              <a href="thread.html#20390">[ thread ]</a>
              <a href="subject.html#20390">[ subject ]</a>
              <a href="author.html#20390">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
