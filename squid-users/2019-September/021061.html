<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Protecting squid against ddos attacks
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Protecting%20squid%20against%20ddos%20attacks&In-Reply-To=%3C835c4d02-4246-8c65-f9ce-cf91c7dd9e92%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="021056.html">
   <LINK REL="Next"  HREF="021069.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Protecting squid against ddos attacks</H1>
    <B>Amos Jeffries</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Protecting%20squid%20against%20ddos%20attacks&In-Reply-To=%3C835c4d02-4246-8c65-f9ce-cf91c7dd9e92%40treenet.co.nz%3E"
       TITLE="[squid-users] Protecting squid against ddos attacks">squid3 at treenet.co.nz
       </A><BR>
    <I>Sat Sep 21 00:19:18 UTC 2019</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="021056.html">[squid-users] Protecting squid against ddos attacks
</A></li>
        <LI>Next message (by thread): <A HREF="021069.html">[squid-users] Protecting squid against ddos attacks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21061">[ date ]</a>
              <a href="thread.html#21061">[ thread ]</a>
              <a href="subject.html#21061">[ subject ]</a>
              <a href="author.html#21061">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 21/09/19 1:03 am, Chirayu Patel wrote:
&gt;<i> --&gt; I have installed squid in a wifi access point which will in many
</I>&gt;<i> cases behave as an edge gateway as well.. So basically it itself is the
</I>&gt;<i> firewall. There is nothing in front to protect it.
</I>&gt;<i> --&gt; There are 4 ports that are opened.. If someone decides to do a DDOS
</I>&gt;<i> attack on them, what options do I have to protect against them.
</I>

Pretty much the exact opposite of what you have this proxy configured to
be doing.

Right now you have it setup to allow all traffic *from* anywhere *to*
anywhere, with no controls, no logging, and no report to any backend
where the traffic originated.


Squid default configuration comes with some DoS protections as
recommended config, some are built-in and always working.

&gt;<i> This is my squid config file :
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------
</I>&gt;<i> http_port 3129 intercept
</I>&gt;<i> https_port 3131 intercept ssl-bump cert=/etc/ray/certificates/myCA.pem \
</I>&gt;<i> &#160; &#160; generate-host-certificates=off dynamic_cert_mem_cache_size=2MB
</I>&gt;<i> ## For Captive Portal &#160; &#160;
</I>&gt;<i> http_port 3132 intercept
</I>&gt;<i> https_port 3133 intercept ssl-bump cert=/etc/ray/certificates/myCA.pem \
</I>&gt;<i> &#160; &#160; generate-host-certificates=off dynamic_cert_mem_cache_size=1MB
</I>&gt;<i> 
</I>
That comment &quot;For Captive Portal&quot; is out of place. Interception *is*
captive portal, so all your ports above are captive portal ports.

Usually you would only need one port of each type. Including the
forward-proxy port (3128 with no mode flag, which you are missing).

For DoS and DDoS protection, having more ports receiving traffic does
help by allowing more TCP port numbers to be available for use. But you
need firewall rules to spread the traffic load across those ports. See
the &quot;Frontend Alternative 1&quot; section of
 &lt;<A HREF="https://wiki.squid-cache.org/ConfigExamples/ExtremeCarpFrontend">https://wiki.squid-cache.org/ConfigExamples/ExtremeCarpFrontend</A>&gt;

For the best DDoS protection Squid can offer you would have a
multi-machine setup like that config page is part of. The particular
Squid you have right now though can gain from just having the port load
balancing part. You can extend the backend part on other machines later
if you want / need.


&gt;<i> 
</I>&gt;<i> # TLS/SSL bumping definitions
</I>&gt;<i> acl tls_s1_connect at_step SslBump1
</I>&gt;<i> acl tls_s2_client_hello at_step SslBump2
</I>&gt;<i> acl tls_s3_server_hello at_step SslBump3
</I>&gt;<i> 
</I>
Unusued ACLs still consume memory. Not much, but still thats memory.


&gt;<i> # TLS/SSL bumping steps
</I>&gt;<i> ssl_bump peek tls_s1_connect all # peek at TLS/SSL connect data
</I>
The &quot;all&quot; on the above line is unnecessary and a waste of CPU cycles on
ever next connection. Remove it.

&gt;<i> ssl_bump splice all # splice: no active bumping
</I>&gt;<i> on_unsupported_protocol tunnel all
</I>
The tunnel action causes Squid to setup a server connection. That costs
2x TCP ports, 2x FDs, client I/O, server I/O, CPU cycles to perform all
the I/O, and memory for all the state and I/O buffers

While this may give you good service for weird client traffic. If your
DDoS risk is high, it may be better to use &quot;respond&quot; instead and an ACL
with &quot;deny_info TCP_RESET attached&quot;.


&gt;<i> 
</I>&gt;<i> pinger_enable off
</I>&gt;<i> digest_generation off
</I>&gt;<i> netdb_filename none
</I>&gt;<i> ipcache_size 128
</I>
ipcache being larger will help your high-traffic periods by helping
reduce delays on traffic you let through the proxy.

DDoS can reduce that benefit. But that is only a *visual* effect, there
is no more resource consumption than the DDoS would cause with a smaller
ipcache size.

So reducing this cache size only slows your normal peak traffic at times
when it needs fastest service. That is a tradeoff against your AP
machines memory available.


&gt;<i> fqdncache_size 128
</I>
Large fqdncache for intercept proxies helps retain valid Host header
records longer and reduce delays receiving new messages. So larger here
is better protection, against both normal traffic problems and DDoS.


&gt;<i> via off
</I>&gt;<i> forwarded_for transparent
</I>&gt;<i> httpd_suppress_version_string on
</I>&gt;<i> cache deny all
</I>&gt;<i> cache_mem 0 MB
</I>
Using memory to store objects recently used gives 100x speed increase
(aka DoS handling capacity).

This though is a tradeoff with the memory you have available. Whether
that speed gain is nanoseconds, milliseconds or whole seconds depends on
your network speeds.

FYI: The model of a frontend LB with backend cache machine (like that
CARP setup earlier) is designed to reduce that speed difference so both
the resource consumption and speed gain cache gives is primarily
happening at the backends - which are very close in the network so
minimal extra delay for the frontend LB.


&gt;<i> memory_pools off
</I>
Only if you have to. The memory usage patterns of high-traffic software
like Squid is quite different from what most OS malloc are optimized
for. The memory pools in Squid are optimized to reduce that to a number
of larger more consistently sized allocations.

Without these pools memory allocation cycles add a bit of speed
reduction to the proxy, and worse can easily lead to memory
fragmentation issues. Normal traffic speeds these effects are not easily
noticed, but under DoS or DDoS conditions they can drag the entire
machine to a crawl if not a complete halt on low-memory systems (like
yours?).


&gt;<i> shutdown_lifetime 0 seconds
</I>&gt;<i> 
</I>&gt;<i> #logfile_daemon /dev/null
</I>&gt;<i> access_log none
</I>
A bit part of DoS or DDoS protection is identifying the attack as it
starts. That requires the information about what traffic is happening to
go somewhere for processing.

Even if you have something else doing deep packet inspection I would
enable logs. Use one of the network logging modules to send them to
another machine if necessary for processing.


&gt;<i> 
</I>&gt;<i> #acl good_url dstdomain .yahoo.com &lt;<A HREF="http://yahoo.com">http://yahoo.com</A>&gt;
</I>&gt;<i> http_access allow all
</I>&gt;<i> 
</I>
See the &quot;default config&quot; section of
&lt;<A HREF="https://wiki.squid-cache.org/Squid-3.5">https://wiki.squid-cache.org/Squid-3.5</A>&gt;. The default rules are
primarily DoS protections these days, with some other nasty attacks
(potentially leading to DDoS indirectly) as well.

You need those rules, and you need a clear policy on what traffic you
allow through the proxy (from where, to where). Once you have that in
place you can reasonably consider what DoS/DDoS risk is left to deal
with. So long as your policy and rule is &quot;http_access allow all&quot; you can
be DoS'ed by a single 38 byte HTTP request message - at least the proxy
killed completely, possibly the whole machine.
 (FYI the other protection against this attack is the Via header, which
you have disabled).


&gt;<i> url_rewrite_program /tmp/squid/urlcat_server_start.sh
</I>&gt;<i> #url_rewrite_bypass on
</I>&gt;<i> url_rewrite_children 1 startup=1 idle=1 concurrency=30 queue-size=10000
</I>&gt;<i> on-persistent-overload=ERR
</I>
Having only one helper may be a source of problems under any conditions.
The ERR will help, but ideally you don't want to reach that state.

Consider whether the thing this helper is doing can be done by ACLs and
deny_info instead. That would avoid all the helper delays or I/O
resource needs, and any clients getting those ERR error pages.


&gt;<i> #url_rewrite_access allow all
</I>&gt;<i> #url_rewrite_extras &quot;%&gt;a/%&gt;A %un %&gt;rm bump_mode=%ssl::bump_mode
</I>&gt;<i> sni=\&quot;%ssl::&gt;sni\&quot; referer=\&quot;%{Referer}&gt;h\&quot;&quot;
</I>&gt;<i> url_rewrite_extras &quot;%&gt;a %lp %ssl::&gt;sni&quot;
</I>&gt;<i> 
</I>&gt;<i> max_filedesc 5120
</I>
This is the most direct measure of how large a DoS has to be to kill
your traffic. The smaller it is the fewer connections the DoS needs to open.

There is a tradeoff though between the memory each of these needs to
allocate (~500 bytes just to exist, up to 256KB when in use) vs the
memory your machine has available.

The reduction of that &quot;in use&quot; time also matters as one might expect.
Which is where the cache_mem speedup comes in, to answer repeat queries
(eg those seen in a classical DoS) at orders of magnitude higher speed
than the backend network can provide the same answer.


&gt;<i> coredump_dir /tmp
</I>&gt;<i> client_lifetime 30 minutes
</I>&gt;<i> read_ahead_gap 8 KB
</I>&gt;<i> 
</I>

Additional to all the above, you can setup a &quot;deny_info TCP_RESET ...&quot;
for any ACLs which does a deny action in your rules. That will prevent
Squid generating an error page and consuming bandwidth to deliver it
when that ACL blocks access.

There is a tradeoff between annoying clients who no longer know why
their connection ended, but under DoS or DDoS it is a huge bandwidth saver.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="021056.html">[squid-users] Protecting squid against ddos attacks
</A></li>
	<LI>Next message (by thread): <A HREF="021069.html">[squid-users] Protecting squid against ddos attacks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21061">[ date ]</a>
              <a href="thread.html#21061">[ thread ]</a>
              <a href="subject.html#21061">[ subject ]</a>
              <a href="author.html#21061">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
