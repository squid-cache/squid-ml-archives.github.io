<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Switch cache peer Parent server for every 30 minutes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Switch%20cache%20peer%20Parent%20server%20for%20every%2030%0A%20minutes&In-Reply-To=%3C02466514-dd1a-95ae-ff54-ac0f37664945%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022243.html">
   <LINK REL="Next"  HREF="022253.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Switch cache peer Parent server for every 30 minutes</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Switch%20cache%20peer%20Parent%20server%20for%20every%2030%0A%20minutes&In-Reply-To=%3C02466514-dd1a-95ae-ff54-ac0f37664945%40measurement-factory.com%3E"
       TITLE="[squid-users] Switch cache peer Parent server for every 30 minutes">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Jun 15 13:44:57 UTC 2020</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="022243.html">[squid-users] Switch cache peer Parent server for every 30	minutes
</A></li>
        <LI>Next message (by thread): <A HREF="022253.html">[squid-users] Switch cache peer Parent server for every 30	minutes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22244">[ date ]</a>
              <a href="thread.html#22244">[ thread ]</a>
              <a href="subject.html#22244">[ subject ]</a>
              <a href="author.html#22244">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 6/15/20 3:26 AM, Prem Chand wrote:

&gt;<i> I stopped the peerA(purposefully)&#160; and noticed that requests are failing
</I>&gt;<i> for the time slots that are going through peerA. I used
</I>&gt;<i> &quot;connect-fail-limit&quot; in cache_peer&#160; but it's not working. Is there any
</I>&gt;<i> way we can address this issue using the same solution considering how to
</I>&gt;<i> handle the requests if any of the parent&#160; peer goes down?
</I>
I am not sure, but I think it should be possible to always give Squid
three peers to use, in the right order. There is no peer selection
algorithm that will do that automatically, but I suspect that a clever
combination of annotate_transaction and &quot;note&quot; ACLs in cache_peer_access
rules can be used to force a particular cache peer selection order.

<A HREF="https://wiki.squid-cache.org/Features/LoadBalance#Go_through_a_peer">https://wiki.squid-cache.org/Features/LoadBalance#Go_through_a_peer</A>

The trick is to place one &quot;best&quot; peer into the first group (your rules
already do that!), but then stop banning peers so that the other two
peers are added to the &quot;All Alive Parents&quot; group (your rules currently
deny those two peers from being considered). It may be possible to stop
banning peers while the peer selection code is running its second pass
by changing request annotation.

I am sorry that I do not have enough time to sketch an example.

Alex.



&gt;<i> On Fri, Jun 12, 2020 at 6:47 PM Alex Rousskov wrote:
</I>&gt;<i> 
</I>&gt;<i>     On 6/11/20 11:52 PM, Prem Chand wrote:
</I>&gt;<i> 
</I>&gt;<i>     &gt; It's working as expected. I tried to allow only specific domains
</I>&gt;<i>     during
</I>&gt;<i>     &gt; the time by adding below acl but I'm getting HTTP status code 503
</I>&gt;<i> 
</I>&gt;<i>     &gt; acl usePeerB time 00:30-00:59
</I>&gt;<i>     &gt; acl usePeerB time 02:00-02:29
</I>&gt;<i>     &gt; acl alloweddomains dstdomain google.com &lt;<A HREF="http://google.com">http://google.com</A>&gt;
</I>&gt;<i>     facebook.com &lt;<A HREF="http://facebook.com">http://facebook.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i>     &gt; cache_peer_access peerA allow usePeerA allowedomains
</I>&gt;<i>     &gt; cache_peer_access peerB allow usePeerB allowedomains
</I>&gt;<i>     &gt; cache_peer_access peerC allow !usePeerA !userPeerB alloweddomains
</I>&gt;<i> 
</I>&gt;<i>     Assuming there are no other cache peers, the above rules leave no
</I>&gt;<i>     forwarding path for a request to a banned domain. If you want to ban
</I>&gt;<i>     such requests, http_access instead of cache_peer_access.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     HTH,
</I>&gt;<i> 
</I>&gt;<i>     Alex.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     &gt; On Thu, Jun 11, 2020 at 4:54 AM Alex Rousskov wrote:
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;On 6/10/20 12:20 PM, Antony Stone wrote:
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; On Wednesday 10 June 2020 at 18:11:03, Prem Chand wrote:
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt; Hi Alex,
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt; Thanks for responding to my issue&#160; . I didn't get how the math
</I>&gt;<i>     &gt;&#160; &#160; &#160;was done(why
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt; it's multiplied by 2) to get 16 slots if possible could you
</I>&gt;<i>     &gt;&#160; &#160; &#160;please elaborate
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt; with an example.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; I believe what Alex meant was:
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; You want 30 minute timeslots for each of 3 peers, which is 48
</I>&gt;<i>     &gt;&#160; &#160; &#160;half-hour
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; timeslots throughout the day.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; However, you only need to define 48/3 of these for peer A, and
</I>&gt;<i>     &gt;&#160; &#160; &#160;48/3 of them for
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; peer B, and then let peer C deal with anything not already
</I>&gt;<i>     handled
</I>&gt;<i>     &gt;&#160; &#160; &#160;(so it
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; doesn't need its own definitions).
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; 48/3 = 16, therefore you define 16 half-hour periods when
</I>&gt;<i>     you want
</I>&gt;<i>     &gt;&#160; &#160; &#160;peer A to do
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; the work, 16 half-hour periods for peer B, and then just say
</I>&gt;<i>     &quot;peer
</I>&gt;<i>     &gt;&#160; &#160; &#160;C, handle
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt; anything left over&quot;.
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;Thank you, Antony! Here is an untested sketch:
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; acl usePeerA time 00:00-00:29
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; acl usePeerA time 01:30-01:59
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; ... a total of 16 ORed lines for the first peer ...
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; ... each line matches a unique 30 minute period ...
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; acl usePeerB time 00:30-00:59
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; acl usePeerB time 02:00-02:29
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; ... a total of 16 ORed lines for the second peer ...
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; ... each line matches a unique 30 minute period ...
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; # and now match peer to its time slots
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; cache_peer_access peerA allow usePeerA
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; cache_peer_access peerB allow usePeerB
</I>&gt;<i>     &gt;&#160; &#160; &#160;&#160; cache_peer_access peerC allow !usePeerA !userPeerB
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;The above may need further adjustments and polishing. For
</I>&gt;<i>     example, I am
</I>&gt;<i>     &gt;&#160; &#160; &#160;not sure how Squid will round these time values. The above
</I>&gt;<i>     assumes that
</I>&gt;<i>     &gt;&#160; &#160; &#160;00:29 limit includes all 60 seconds up to (but excluding)
</I>&gt;<i>     00:30:00.
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;HTH,
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;Alex.
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt; On Wed, Jun 10, 2020 at 7:12 PM Alex Rousskov wrote:
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; On 6/10/20 6:09 AM, Prem Chand wrote:
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;&gt; My squid cache peer has 3 parent IP&#8217;s configured. I need to
</I>&gt;<i>     &gt;&#160; &#160; &#160;send HTTPS
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;&gt; requests to the first parent IP for 30 minutes and after
</I>&gt;<i>     to the 2nd
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;&gt; parent IP for 30 minutes and then to 3rd IP for 30
</I>&gt;<i>     minutes and this
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;&gt; switching needs to happen continuously .Could you please
</I>&gt;<i>     let us
</I>&gt;<i>     &gt;&#160; &#160; &#160;know
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;&gt; how I can achieve this?
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; If you are OK with hard-coded usage time slots for each
</I>&gt;<i>     peer, then I
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; would use two[1] &quot;time&quot; ACLs and cache_peer_access rules.
</I>&gt;<i>     Look for
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; &quot;aclname time&quot; in squid.conf.documented. You will have to
</I>&gt;<i>     generate a
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; list of (24*2/3=16) staggered time slots for each of the two
</I>&gt;<i>     &gt;&#160; &#160; &#160;ACLs, but
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; it should work. This may be the simplest solution.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; [1] You need two ACLs for three peers because the third peer
</I>&gt;<i>     &gt;&#160; &#160; &#160;should get
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; the requests that the first two peers were not allowed to get.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; ----
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; With a modern Squid, you could also implement this using a
</I>&gt;<i>     more
</I>&gt;<i>     &gt;&#160; &#160; &#160;flexible
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; (and more expensive, on several layers!) architecture with
</I>&gt;<i>     two ACLs:
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; 1. An external ACL that returns the right cache peer name
</I>&gt;<i>     to use
</I>&gt;<i>     &gt;&#160; &#160; &#160;via a
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; keyword=value annotation API. This always-matching ACL
</I>&gt;<i>     should be
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; attached to http_access or a similar directive that supports
</I>&gt;<i>     &gt;&#160; &#160; &#160;slow ACLs.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; Its goal is to annotate the request. You will need to write a
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; script/program that will compute the right annotations
</I>&gt;<i>     based on
</I>&gt;<i>     &gt;&#160; &#160; &#160;time or
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; some other factors. This is where the flexibility of this
</I>&gt;<i>     &gt;&#160; &#160; &#160;solution is
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; coming from.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; 2. A &quot;note&quot; ACL attached to cache_peer_access directives,
</I>&gt;<i>     allowing
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; access to peer X if the external ACL in item 1 returned
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; use_cache_peer_=X. The &quot;note&quot; ACL is a fast ACL and,
</I>&gt;<i>     hence, can be
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; reliably used with cache_peer_access.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; If you already have another external ACL, you may be able to
</I>&gt;<i>     &gt;&#160; &#160; &#160;piggyback
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; annotations in item 1 to whatever that ACL is already doing.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; For more information, search for &quot;keyword=value&quot; and &quot;acl
</I>&gt;<i>     &gt;&#160; &#160; &#160;aclname note&quot;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; in your squid.conf.documented and see
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160;
</I>&gt;<i>     &#160;<A HREF="https://wiki.squid-cache.org/Features/AddonHelpers#Access_Control_.28ACL.">https://wiki.squid-cache.org/Features/AddonHelpers#Access_Control_.28ACL.</A>
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; 29
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; HTH,
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt;
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;&gt;&gt; Alex.
</I>&gt;<i>     &gt;&#160; &#160; &#160;&gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt;
</I>&gt;<i>     &gt; --
</I>&gt;<i>     &gt; prem
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -- 
</I>&gt;<i> prem
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="022243.html">[squid-users] Switch cache peer Parent server for every 30	minutes
</A></li>
	<LI>Next message (by thread): <A HREF="022253.html">[squid-users] Switch cache peer Parent server for every 30	minutes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22244">[ date ]</a>
              <a href="thread.html#22244">[ thread ]</a>
              <a href="subject.html#22244">[ subject ]</a>
              <a href="author.html#22244">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
