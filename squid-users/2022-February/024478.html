<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] external helper development
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20external%20helper%20development&In-Reply-To=%3Cc3f005e5-0365-aaac-1532-fda5a2cc913e%40articatech.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024473.html">
   <LINK REL="Next"  HREF="024481.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] external helper development</H1>
    <B>David Touzeau</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20external%20helper%20development&In-Reply-To=%3Cc3f005e5-0365-aaac-1532-fda5a2cc913e%40articatech.com%3E"
       TITLE="[squid-users] external helper development">david at articatech.com
       </A><BR>
    <I>Fri Feb  4 14:28:38 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="024473.html">[squid-users] external helper development
</A></li>
        <LI>Next message (by thread): <A HREF="024481.html">[squid-users] external helper development
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24478">[ date ]</a>
              <a href="thread.html#24478">[ thread ]</a>
              <a href="subject.html#24478">[ subject ]</a>
              <a href="author.html#24478">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Elizer,

Thanks for all this advice and indeed your arguments are valid between 
opening a socket, sending data, receiving data and closing the socket 
unlike direct access to a regex or a memory entry even if the 
calculation has already been done.

But what surprises me the most is that we have produced a python plugin 
in thread which I provide you a code below.
The php code is like your mentioned example ( No thread, just a loop and 
output OK )

Results are after 6k requests, squid freeze and no surf can be made as 
with PHP code we can up to 10K requests and squid is happy
really, we did not understand why python is so low.

Here a python code using threads

#!/usr/bin/env python
import os
import sys
import time
import signal
import locale
import traceback
import threading
import select
import traceback as tb

class ClienThread():

 &#160;&#160;&#160; def __init__(self):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = False
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._cache = {}

 &#160;&#160;&#160; def exit(self):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = True

 &#160;&#160;&#160; def stdout(self, lineToSend):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.write(lineToSend)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.flush()

 &#160;&#160;&#160;&#160;&#160;&#160;&#160; except IOError as e:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if e.errno==32:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Error Broken PIPE!&quot;
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; except:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # other execpt
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass

 &#160;&#160;&#160; def run(self):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; while not self._exiting:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if sys.stdin in select.select([sys.stdin], [], [], 0.5)[0]:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = sys.stdin.readline()
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LenOfline=len(line)

 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if LenOfline==0:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting=True
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break

 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if line[-1] == '\n':line = line[:-1]
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel = None
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; options = line.split()

 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if options[0].isdigit(): channel = options.pop(0)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except IndexError:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;0 OK first=ERROR\n&quot;)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; continue

 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Processing here

 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;%s OK\n&quot; % channel)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;%s ERROR first=ERROR\n&quot; % channel)




class Main(object):
 &#160;&#160;&#160; def __init__(self):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads = []
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = False
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._reload = False
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._config = &quot;&quot;

 &#160;&#160;&#160;&#160;&#160;&#160;&#160; for sig, action in (
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGINT, self.shutdown),
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGQUIT, self.shutdown),
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGTERM, self.shutdown),
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGHUP, lambda s, f: setattr(self, '_reload', True)),
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGPIPE, signal.SIG_IGN),
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; ):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; signal.signal(sig, action)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except AttributeError:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass



 &#160;&#160;&#160; def shutdown(self, sig = None, frame = None):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = True
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stop_threads()

 &#160;&#160;&#160; def start_threads(self):

 &#160;&#160;&#160;&#160;&#160;&#160;&#160; sThread = ClienThread()
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; t = threading.Thread(target = sThread.run)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; t.start()
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads.append((sThread, t))



 &#160;&#160;&#160; def stop_threads(self):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; for p, t in self._threads:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; p.exit()
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; for p, t in self._threads:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; t.join(timeout = 1.0)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads = []

 &#160;&#160;&#160; def run(self):
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;&quot;&quot; main loop &quot;&quot;&quot;
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = 0
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; self.start_threads()
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; return ret


if __name__ == '__main__':
 &#160;&#160;&#160; # set C locale
 &#160;&#160;&#160; locale.setlocale(locale.LC_ALL, 'C')
 &#160;&#160;&#160; os.environ['LANG'] = 'C'
 &#160;&#160;&#160; ret = 0
 &#160;&#160;&#160; try:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; main = Main()
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = main.run()
 &#160;&#160;&#160; except SystemExit:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
 &#160;&#160;&#160; except KeyboardInterrupt:
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = 4
 &#160;&#160;&#160; except:
 &#160;&#160;&#160; sys.exit(ret)

Le 04/02/2022 &#224; 07:06, Eliezer Croitoru a &#233;crit&#160;:
&gt;<i>
</I>&gt;<i> And about the cache of each helpers, the cost of a cache on a single 
</I>&gt;<i> helper is not much in terms of memory comparing to some network access.
</I>&gt;<i>
</I>&gt;<i> Again it&#8217;s possible to test and verify this on a loaded system to get 
</I>&gt;<i> results. The delay itself can be seen from squid side in the cache 
</I>&gt;<i> manager statistics.
</I>&gt;<i>
</I>&gt;<i> You can also try to compare the next ruby helper:
</I>&gt;<i>
</I>&gt;<i> <A HREF="https://wiki.squid-cache.org/EliezerCroitoru/SessionHelper">https://wiki.squid-cache.org/EliezerCroitoru/SessionHelper</A>
</I>&gt;<i>
</I>&gt;<i> About a shared &#8220;base&#8221; which allows helpers to avoid computation of the 
</I>&gt;<i> query&#8230;. It&#8217;s a good argument, however it depends what is the cost of
</I>&gt;<i> pulling from the cache compared to calculating the answer.
</I>&gt;<i>
</I>&gt;<i> A very simple string comparison or regex matching would probably be 
</I>&gt;<i> faster than reaching a shared storage in many cases.
</I>&gt;<i>
</I>&gt;<i> Also take into account the &#8220;concurrency&#8221; support from the helper side.
</I>&gt;<i>
</I>&gt;<i> A helper that supports parallel processing of requests/lines can do 
</I>&gt;<i> better then many single helpers in more than once use case.
</I>&gt;<i>
</I>&gt;<i> In any case I would suggest to enable requests concurrency from squid 
</I>&gt;<i> side since the STDIN buffer will emulate some level of concurrency
</I>&gt;<i> by itself and will allow squid to keep going forward faster.
</I>&gt;<i>
</I>&gt;<i> Just to mention that SquidGuard have used a single helper cache for a 
</I>&gt;<i> very long time, ie every single SquidGuard helper has it&#8217;s own copy of 
</I>&gt;<i> the whole
</I>&gt;<i>
</I>&gt;<i> configuration and database files in memory.
</I>&gt;<i>
</I>&gt;<i> And again, if you do have any option to implement a server service 
</I>&gt;<i> model and that the helpers will contact this main service you will be 
</I>&gt;<i> able to implement
</I>&gt;<i> much faster internal in-memory cache compared to a redis/memcahe/other 
</I>&gt;<i> external daemon(need to be tested).
</I>&gt;<i>
</I>&gt;<i> A good example for this is ufdbguard which has helpers that are 
</I>&gt;<i> clients of the main service which does the whole heavy lifting and 
</I>&gt;<i> also holds
</I>&gt;<i> one copy of the DB.
</I>&gt;<i>
</I>&gt;<i> I have implemented SquidBlocker this way and have seen that it 
</I>&gt;<i> out-performs any other service I have tried until now.
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20220204/faa83ea0/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20220204/faa83ea0/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="024473.html">[squid-users] external helper development
</A></li>
	<LI>Next message (by thread): <A HREF="024481.html">[squid-users] external helper development
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24478">[ date ]</a>
              <a href="thread.html#24478">[ thread ]</a>
              <a href="subject.html#24478">[ subject ]</a>
              <a href="author.html#24478">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
