<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] external helper development
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20external%20helper%20development&In-Reply-To=%3Cf44c5bab-cd76-dda2-96eb-88f3c7462f4e%40articatech.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024484.html">
   <LINK REL="Next"  HREF="024486.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] external helper development</H1>
    <B>David Touzeau</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20external%20helper%20development&In-Reply-To=%3Cf44c5bab-cd76-dda2-96eb-88f3c7462f4e%40articatech.com%3E"
       TITLE="[squid-users] external helper development">david at articatech.com
       </A><BR>
    <I>Mon Feb  7 00:41:58 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="024484.html">[squid-users] external helper development
</A></li>
        <LI>Next message (by thread): <A HREF="024486.html">[squid-users] external helper development
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24485">[ date ]</a>
              <a href="thread.html#24485">[ thread ]</a>
              <a href="subject.html#24485">[ subject ]</a>
              <a href="author.html#24485">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry&#160; Elizer

It was a mistake... No, your code is clean..
Impressive for the first shot
Many thanks for your example, we will run our stress tool to see the 
difference...

Just a question

Why did you send 500 milliseconds of sleep in the handle_stdoud ? Is it 
for let squid closing the pipe ?



Le 06/02/2022 &#224; 11:46, Eliezer Croitoru a &#233;crit&#160;:
&gt;<i>
</I>&gt;<i> Hey David,
</I>&gt;<i>
</I>&gt;<i> Not a fully completed helper but it seems to works pretty nice and 
</I>&gt;<i> might be better then what exist already:
</I>&gt;<i>
</I>&gt;<i> <A HREF="https://gist.githubusercontent.com/elico/03938e3a796c53f7c925872bade78195/raw/21ff1bbc0cf3d91719db27d9d027652e8bd3de4e/threaded-helper-example.py">https://gist.githubusercontent.com/elico/03938e3a796c53f7c925872bade78195/raw/21ff1bbc0cf3d91719db27d9d027652e8bd3de4e/threaded-helper-example.py</A>
</I>&gt;<i>
</I>&gt;<i> #!/usr/bin/env python
</I>&gt;<i>
</I>&gt;<i> import sys
</I>&gt;<i>
</I>&gt;<i> import time
</I>&gt;<i>
</I>&gt;<i> import urllib.request
</I>&gt;<i>
</I>&gt;<i> import signal
</I>&gt;<i>
</I>&gt;<i> import threading
</I>&gt;<i>
</I>&gt;<i> #set debug mode for True or False
</I>&gt;<i>
</I>&gt;<i> debug = False
</I>&gt;<i>
</I>&gt;<i> #debug = True
</I>&gt;<i>
</I>&gt;<i> queue = []
</I>&gt;<i>
</I>&gt;<i> threads = []
</I>&gt;<i>
</I>&gt;<i> RUNNING = True
</I>&gt;<i>
</I>&gt;<i> quit = 0
</I>&gt;<i>
</I>&gt;<i> rand_api_url = &quot;<A HREF="https://cloud1.ngtech.co.il/api/test.php">https://cloud1.ngtech.co.il/api/test.php</A>&quot;
</I>&gt;<i>
</I>&gt;<i> def sig_handler(signum, frame):
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; sys.stderr.write(&quot;Signal is received:&quot; + str(signum) + &quot;\n&quot;)
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; global quit
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; quit = 1
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; global RUNNING
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; RUNNING=False
</I>&gt;<i>
</I>&gt;<i> def handle_line(line):
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; if not RUNNING:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; if not line:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; arr = line.split()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; response = urllib.request.urlopen( rand_api_url )
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; response_text = response.read()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; queue.append(arr[0] + &quot; &quot; + response_text.decode(&quot;utf-8&quot;))
</I>&gt;<i>
</I>&gt;<i> def handle_stdout(n):
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; while RUNNING:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while len(queue) &gt; 0:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; item = queue.pop(0)
</I>&gt;<i>
</I>&gt;<i> sys.stdout.write(item)
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.flush()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; time.sleep(0.5)
</I>&gt;<i>
</I>&gt;<i> def handle_stdin(n):
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; while RUNNING:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = sys.stdin.readline()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if not line:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = line.strip()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; thread = threading.Thread(target=handle_line, args=(line,))
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; thread.start()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; threads.append(thread)
</I>&gt;<i>
</I>&gt;<i> signal.signal(signal.SIGUSR1, sig_handler)
</I>&gt;<i>
</I>&gt;<i> signal.signal(signal.SIGUSR2, sig_handler)
</I>&gt;<i>
</I>&gt;<i> signal.signal(signal.SIGALRM, sig_handler)
</I>&gt;<i>
</I>&gt;<i> signal.signal(signal.SIGINT, sig_handler)
</I>&gt;<i>
</I>&gt;<i> signal.signal(signal.SIGQUIT, sig_handler)
</I>&gt;<i>
</I>&gt;<i> signal.signal(signal.SIGTERM, sig_handler)
</I>&gt;<i>
</I>&gt;<i> stdout_thread = threading.Thread(target=handle_stdout, args=(1,))
</I>&gt;<i>
</I>&gt;<i> stdout_thread.start()
</I>&gt;<i>
</I>&gt;<i> threads.append(stdout_thread)
</I>&gt;<i>
</I>&gt;<i> stdin_thread = threading.Thread(target=handle_stdin, args=(2,))
</I>&gt;<i>
</I>&gt;<i> stdin_thread.start()
</I>&gt;<i>
</I>&gt;<i> threads.append(stdin_thread)
</I>&gt;<i>
</I>&gt;<i> while(RUNNING):
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; time.sleep(3)
</I>&gt;<i>
</I>&gt;<i> print(&quot;Not RUNNING&quot;)
</I>&gt;<i>
</I>&gt;<i> for thread in threads:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; thread.join()
</I>&gt;<i>
</I>&gt;<i> print(&quot;All threads stopped.&quot;)
</I>&gt;<i>
</I>&gt;<i> ## END
</I>&gt;<i>
</I>&gt;<i> Eliezer
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> Eliezer Croitoru
</I>&gt;<i>
</I>&gt;<i> NgTech, Tech Support
</I>&gt;<i>
</I>&gt;<i> Mobile: +972-5-28704261
</I>&gt;<i>
</I>&gt;<i> Email: <A HREF="https://lists.squid-cache.org/listinfo/squid-users">ngtech1ltd at gmail.com</A>
</I>&gt;<i>
</I>&gt;<i> *From:*squid-users &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users-bounces at lists.squid-cache.org</A>&gt; *On 
</I>&gt;<i> Behalf Of *David Touzeau
</I>&gt;<i> *Sent:* Friday, February 4, 2022 16:29
</I>&gt;<i> *To:* <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> *Subject:* Re: [squid-users] external helper development
</I>&gt;<i>
</I>&gt;<i> Elizer,
</I>&gt;<i>
</I>&gt;<i> Thanks for all this advice and indeed your arguments are valid between 
</I>&gt;<i> opening a socket, sending data, receiving data and closing the socket 
</I>&gt;<i> unlike direct access to a regex or a memory entry even if the 
</I>&gt;<i> calculation has already been done.
</I>&gt;<i>
</I>&gt;<i> But what surprises me the most is that we have produced a python 
</I>&gt;<i> plugin in thread which I provide you a code below.
</I>&gt;<i> The php code is like your mentioned example ( No thread, just a loop 
</I>&gt;<i> and output OK )
</I>&gt;<i>
</I>&gt;<i> Results are after 6k requests, squid freeze and no surf can be made as 
</I>&gt;<i> with PHP code we can up to 10K requests and squid is happy
</I>&gt;<i> really, we did not understand why python is so low.
</I>&gt;<i>
</I>&gt;<i> Here a python code using threads
</I>&gt;<i>
</I>&gt;<i> #!/usr/bin/env python
</I>&gt;<i> import os
</I>&gt;<i> import sys
</I>&gt;<i> import time
</I>&gt;<i> import signal
</I>&gt;<i> import locale
</I>&gt;<i> import traceback
</I>&gt;<i> import threading
</I>&gt;<i> import select
</I>&gt;<i> import traceback as tb
</I>&gt;<i>
</I>&gt;<i> class ClienThread():
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def __init__(self):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = False
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._cache = {}
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def exit(self):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = True
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def stdout(self, lineToSend):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.write(lineToSend)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.flush()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; except IOError as e:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if e.errno==32:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Error Broken PIPE!&quot;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; except:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # other execpt
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def run(self):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; while not self._exiting:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if sys.stdin in select.select([sys.stdin], [], [], 0.5)[0]:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = sys.stdin.readline()
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LenOfline=len(line)
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if LenOfline==0:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting=True
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if line[-1] == '\n':line = line[:-1]
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel = None
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; options = line.split()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if options[0].isdigit(): channel = options.pop(0)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except IndexError:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;0 OK first=ERROR\n&quot;)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; continue
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Processing here
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;%s OK\n&quot; % channel)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;%s ERROR first=ERROR\n&quot; % channel)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class Main(object):
</I>&gt;<i> &#160;&#160;&#160; def __init__(self):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads = []
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = False
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._reload = False
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._config = &quot;&quot;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; for sig, action in (
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGINT, self.shutdown),
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGQUIT, self.shutdown),
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGTERM, self.shutdown),
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGHUP, lambda s, f: setattr(self, '_reload', True)),
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGPIPE, signal.SIG_IGN),
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; ):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; signal.signal(sig, action)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except AttributeError:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def shutdown(self, sig = None, frame = None):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = True
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stop_threads()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def start_threads(self):
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; sThread = ClienThread()
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; t = threading.Thread(target = sThread.run)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; t.start()
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads.append((sThread, t))
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def stop_threads(self):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; for p, t in self._threads:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; p.exit()
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; for p, t in self._threads:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; t.join(timeout =&#160; 1.0)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads = []
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; def run(self):
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;&quot;&quot; main loop &quot;&quot;&quot;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = 0
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; self.start_threads()
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; return ret
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> if __name__ == '__main__':
</I>&gt;<i> &#160;&#160;&#160; # set C locale
</I>&gt;<i> &#160;&#160;&#160; locale.setlocale(locale.LC_ALL, 'C')
</I>&gt;<i> &#160;&#160;&#160; os.environ['LANG'] = 'C'
</I>&gt;<i> &#160;&#160;&#160; ret = 0
</I>&gt;<i> &#160;&#160;&#160; try:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; main = Main()
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = main.run()
</I>&gt;<i> &#160;&#160;&#160; except SystemExit:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i> &#160;&#160;&#160; except KeyboardInterrupt:
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = 4
</I>&gt;<i> &#160;&#160;&#160; except:
</I>&gt;<i> &#160;&#160;&#160; sys.exit(ret)
</I>&gt;<i>
</I>&gt;<i> Le 04/02/2022 &#224; 07:06, Eliezer Croitoru a &#233;crit&#160;:
</I>&gt;<i>
</I>&gt;<i>     And about the cache of each helpers, the cost of a cache on a
</I>&gt;<i>     single helper is not much in terms of memory comparing to some
</I>&gt;<i>     network access.
</I>&gt;<i>
</I>&gt;<i>     Again it&#8217;s possible to test and verify this on a loaded system to
</I>&gt;<i>     get results. The delay itself can be seen from squid side in the
</I>&gt;<i>     cache manager statistics.
</I>&gt;<i>
</I>&gt;<i>     You can also try to compare the next ruby helper:
</I>&gt;<i>
</I>&gt;<i>     <A HREF="https://wiki.squid-cache.org/EliezerCroitoru/SessionHelper">https://wiki.squid-cache.org/EliezerCroitoru/SessionHelper</A>
</I>&gt;<i>
</I>&gt;<i>     About a shared &#8220;base&#8221; which allows helpers to avoid computation of
</I>&gt;<i>     the query&#8230;. It&#8217;s a good argument, however it depends what is the
</I>&gt;<i>     cost of
</I>&gt;<i>     pulling from the cache compared to calculating the answer.
</I>&gt;<i>
</I>&gt;<i>     A very simple string comparison or regex matching would probably
</I>&gt;<i>     be faster than reaching a shared storage in many cases.
</I>&gt;<i>
</I>&gt;<i>     Also take into account the &#8220;concurrency&#8221; support from the helper side.
</I>&gt;<i>
</I>&gt;<i>     A helper that supports parallel processing of requests/lines can
</I>&gt;<i>     do better then many single helpers in more than once use case.
</I>&gt;<i>
</I>&gt;<i>     In any case I would suggest to enable requests concurrency from
</I>&gt;<i>     squid side since the STDIN buffer will emulate some level of
</I>&gt;<i>     concurrency
</I>&gt;<i>     by itself and will allow squid to keep going forward faster.
</I>&gt;<i>
</I>&gt;<i>     Just to mention that SquidGuard have used a single helper cache
</I>&gt;<i>     for a very long time, ie every single SquidGuard helper has it&#8217;s
</I>&gt;<i>     own copy of the whole
</I>&gt;<i>
</I>&gt;<i>     configuration and database files in memory.
</I>&gt;<i>
</I>&gt;<i>     And again, if you do have any option to implement a server service
</I>&gt;<i>     model and that the helpers will contact this main service you will
</I>&gt;<i>     be able to implement
</I>&gt;<i>     much faster internal in-memory cache compared to a
</I>&gt;<i>     redis/memcahe/other external daemon(need to be tested).
</I>&gt;<i>
</I>&gt;<i>     A good example for this is ufdbguard which has helpers that are
</I>&gt;<i>     clients of the main service which does the whole heavy lifting and
</I>&gt;<i>     also holds
</I>&gt;<i>     one copy of the DB.
</I>&gt;<i>
</I>&gt;<i>     I have implemented SquidBlocker this way and have seen that it
</I>&gt;<i>     out-performs any other service I have tried until now.
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20220207/9646d2ab/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20220207/9646d2ab/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="024484.html">[squid-users] external helper development
</A></li>
	<LI>Next message (by thread): <A HREF="024486.html">[squid-users] external helper development
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24485">[ date ]</a>
              <a href="thread.html#24485">[ thread ]</a>
              <a href="subject.html#24485">[ subject ]</a>
              <a href="author.html#24485">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
