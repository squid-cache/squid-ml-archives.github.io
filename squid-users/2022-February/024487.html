<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] external helper development
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20external%20helper%20development&In-Reply-To=%3Cd9fa09d4-8a3a-10fd-601c-d7b0ce22ea2c%40articatech.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024486.html">
   <LINK REL="Next"  HREF="024466.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] external helper development</H1>
    <B>David Touzeau</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20external%20helper%20development&In-Reply-To=%3Cd9fa09d4-8a3a-10fd-601c-d7b0ce22ea2c%40articatech.com%3E"
       TITLE="[squid-users] external helper development">david at articatech.com
       </A><BR>
    <I>Tue Feb  8 00:36:44 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="024486.html">[squid-users] external helper development
</A></li>
        <LI>Next message (by thread): <A HREF="024466.html">[squid-users] [ext] Re: Absolute upper limit for filedescriptors in squid-6?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24487">[ date ]</a>
              <a href="thread.html#24487">[ thread ]</a>
              <a href="subject.html#24487">[ subject ]</a>
              <a href="author.html#24487">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You are the best,
We will launch a benchmark to see the diff

Le 07/02/2022 &#224; 16:14, Eliezer Croitoru a &#233;crit&#160;:
&gt;<i>
</I>&gt;<i> Hey David,
</I>&gt;<i>
</I>&gt;<i> Since the handle_stdout runs in it&#8217;s own thread it&#8217;s sole purpose is 
</I>&gt;<i> to send results to stdout.
</I>&gt;<i>
</I>&gt;<i> If I will run the next code in a simple software without the 0.5 sleep 
</I>&gt;<i> time:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160; while RUNNING:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while len(queue) &gt; 0:
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; item = queue.pop(0)
</I>&gt;<i>
</I>&gt;<i> sys.stdout.write(item)
</I>&gt;<i>
</I>&gt;<i> sys.stdout.flush()
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; time.sleep(0.5)
</I>&gt;<i>
</I>&gt;<i> what will happen is that the software will run with 100% CPU looping 
</I>&gt;<i> over and over on the size of the queue
</I>&gt;<i> while sometimes it will spit some data to stdout.
</I>&gt;<i>
</I>&gt;<i> Adding a small delay with 0.5 secs will allow some &#8220;idle&#8221; time for the 
</I>&gt;<i> cpu in the loop preventing it from consuming
</I>&gt;<i> all the CPU time.
</I>&gt;<i>
</I>&gt;<i> It&#8217;s a very old technique and there are others which are more 
</I>&gt;<i> efficient but it&#8217;s enough to demonstrate that a simple
</I>&gt;<i> threaded helper is much better then any PHP code that was not meant to 
</I>&gt;<i> be running as a STDIN/OUT daemon/helper software.
</I>&gt;<i>
</I>&gt;<i> All The Bests,
</I>&gt;<i>
</I>&gt;<i> Eliezer
</I>&gt;<i>
</I>&gt;<i> ----
</I>&gt;<i>
</I>&gt;<i> Eliezer Croitoru
</I>&gt;<i>
</I>&gt;<i> NgTech, Tech Support
</I>&gt;<i>
</I>&gt;<i> Mobile: +972-5-28704261
</I>&gt;<i>
</I>&gt;<i> Email: <A HREF="https://lists.squid-cache.org/listinfo/squid-users">ngtech1ltd at gmail.com</A>
</I>&gt;<i>
</I>&gt;<i> *From:*David Touzeau &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">david at articatech.com</A>&gt;
</I>&gt;<i> *Sent:* Monday, February 7, 2022 02:42
</I>&gt;<i> *To:* Eliezer Croitoru &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">ngtech1ltd at gmail.com</A>&gt;; 
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> *Subject:* Re: [squid-users] external helper development
</I>&gt;<i>
</I>&gt;<i> Sorry Elizer
</I>&gt;<i>
</I>&gt;<i> It was a mistake... No, your code is clean..
</I>&gt;<i> Impressive for the first shot
</I>&gt;<i> Many thanks for your example, we will run our stress tool to see the 
</I>&gt;<i> difference...
</I>&gt;<i>
</I>&gt;<i> Just a question
</I>&gt;<i>
</I>&gt;<i> Why did you send 500 milliseconds of sleep in the handle_stdoud ? Is 
</I>&gt;<i> it for let squid closing the pipe ?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Le 06/02/2022 &#224; 11:46, Eliezer Croitoru a &#233;crit&#160;:
</I>&gt;<i>
</I>&gt;<i>     Hey David,
</I>&gt;<i>
</I>&gt;<i>     Not a fully completed helper but it seems to works pretty nice and
</I>&gt;<i>     might be better then what exist already:
</I>&gt;<i>
</I>&gt;<i>     <A HREF="https://gist.githubusercontent.com/elico/03938e3a796c53f7c925872bade78195/raw/21ff1bbc0cf3d91719db27d9d027652e8bd3de4e/threaded-helper-example.py">https://gist.githubusercontent.com/elico/03938e3a796c53f7c925872bade78195/raw/21ff1bbc0cf3d91719db27d9d027652e8bd3de4e/threaded-helper-example.py</A>
</I>&gt;<i>
</I>&gt;<i>     #!/usr/bin/env python
</I>&gt;<i>
</I>&gt;<i>     import sys
</I>&gt;<i>
</I>&gt;<i>     import time
</I>&gt;<i>
</I>&gt;<i>     import urllib.request
</I>&gt;<i>
</I>&gt;<i>     import signal
</I>&gt;<i>
</I>&gt;<i>     import threading
</I>&gt;<i>
</I>&gt;<i>     #set debug mode for True or False
</I>&gt;<i>
</I>&gt;<i>     debug = False
</I>&gt;<i>
</I>&gt;<i>     #debug = True
</I>&gt;<i>
</I>&gt;<i>     queue = []
</I>&gt;<i>
</I>&gt;<i>     threads = []
</I>&gt;<i>
</I>&gt;<i>     RUNNING = True
</I>&gt;<i>
</I>&gt;<i>     quit = 0
</I>&gt;<i>
</I>&gt;<i>     rand_api_url = &quot;<A HREF="https://cloud1.ngtech.co.il/api/test.php">https://cloud1.ngtech.co.il/api/test.php</A>&quot;
</I>&gt;<i>     &lt;<A HREF="https://cloud1.ngtech.co.il/api/test.php">https://cloud1.ngtech.co.il/api/test.php</A>&gt;
</I>&gt;<i>
</I>&gt;<i>     def sig_handler(signum, frame):
</I>&gt;<i>
</I>&gt;<i>     sys.stderr.write(&quot;Signal is received:&quot; + str(signum) + &quot;\n&quot;)
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; global quit
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; quit = 1
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; global RUNNING
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; RUNNING=False
</I>&gt;<i>
</I>&gt;<i>     def handle_line(line):
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; if not RUNNING:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; if not line:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; arr = line.split()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; response = urllib.request.urlopen( rand_api_url )
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; response_text = response.read()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; queue.append(arr[0] + &quot; &quot; + response_text.decode(&quot;utf-8&quot;))
</I>&gt;<i>
</I>&gt;<i>     def handle_stdout(n):
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160; while RUNNING:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while len(queue) &gt; 0:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; item = queue.pop(0)
</I>&gt;<i>
</I>&gt;<i>     sys.stdout.write(item)
</I>&gt;<i>
</I>&gt;<i>     sys.stdout.flush()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; time.sleep(0.5)
</I>&gt;<i>
</I>&gt;<i>     def handle_stdin(n):
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; while RUNNING:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = sys.stdin.readline()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if not line:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if quit &gt; 0:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = line.strip()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; thread = threading.Thread(target=handle_line, args=(line,))
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; thread.start()
</I>&gt;<i>
</I>&gt;<i>     threads.append(thread)
</I>&gt;<i>
</I>&gt;<i>     signal.signal(signal.SIGUSR1, sig_handler)
</I>&gt;<i>
</I>&gt;<i>     signal.signal(signal.SIGUSR2, sig_handler)
</I>&gt;<i>
</I>&gt;<i>     signal.signal(signal.SIGALRM, sig_handler)
</I>&gt;<i>
</I>&gt;<i>     signal.signal(signal.SIGINT, sig_handler)
</I>&gt;<i>
</I>&gt;<i>     signal.signal(signal.SIGQUIT, sig_handler)
</I>&gt;<i>
</I>&gt;<i>     signal.signal(signal.SIGTERM, sig_handler)
</I>&gt;<i>
</I>&gt;<i>     stdout_thread = threading.Thread(target=handle_stdout, args=(1,))
</I>&gt;<i>
</I>&gt;<i>     stdout_thread.start()
</I>&gt;<i>
</I>&gt;<i>     threads.append(stdout_thread)
</I>&gt;<i>
</I>&gt;<i>     stdin_thread = threading.Thread(target=handle_stdin, args=(2,))
</I>&gt;<i>
</I>&gt;<i>     stdin_thread.start()
</I>&gt;<i>
</I>&gt;<i>     threads.append(stdin_thread)
</I>&gt;<i>
</I>&gt;<i>     while(RUNNING):
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; time.sleep(3)
</I>&gt;<i>
</I>&gt;<i>     print(&quot;Not RUNNING&quot;)
</I>&gt;<i>
</I>&gt;<i>     for thread in threads:
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; thread.join()
</I>&gt;<i>
</I>&gt;<i>     print(&quot;All threads stopped.&quot;)
</I>&gt;<i>
</I>&gt;<i>     ## END
</I>&gt;<i>
</I>&gt;<i>     Eliezer
</I>&gt;<i>
</I>&gt;<i>     ----
</I>&gt;<i>
</I>&gt;<i>     Eliezer Croitoru
</I>&gt;<i>
</I>&gt;<i>     NgTech, Tech Support
</I>&gt;<i>
</I>&gt;<i>     Mobile: +972-5-28704261
</I>&gt;<i>
</I>&gt;<i>     Email: <A HREF="https://lists.squid-cache.org/listinfo/squid-users">ngtech1ltd at gmail.com</A>
</I>&gt;<i>
</I>&gt;<i>     *From:*squid-users &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users-bounces at lists.squid-cache.org</A>&gt;
</I>&gt;<i>     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users-bounces at lists.squid-cache.org</A>&gt; *On Behalf Of
</I>&gt;<i>     *David Touzeau
</I>&gt;<i>     *Sent:* Friday, February 4, 2022 16:29
</I>&gt;<i>     *To:* <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i>     *Subject:* Re: [squid-users] external helper development
</I>&gt;<i>
</I>&gt;<i>     Elizer,
</I>&gt;<i>
</I>&gt;<i>     Thanks for all this advice and indeed your arguments are valid
</I>&gt;<i>     between opening a socket, sending data, receiving data and closing
</I>&gt;<i>     the socket unlike direct access to a regex or a memory entry even
</I>&gt;<i>     if the calculation has already been done.
</I>&gt;<i>
</I>&gt;<i>     But what surprises me the most is that we have produced a python
</I>&gt;<i>     plugin in thread which I provide you a code below.
</I>&gt;<i>     The php code is like your mentioned example ( No thread, just a
</I>&gt;<i>     loop and output OK )
</I>&gt;<i>
</I>&gt;<i>     Results are after 6k requests, squid freeze and no surf can be
</I>&gt;<i>     made as with PHP code we can up to 10K requests and squid is happy
</I>&gt;<i>     really, we did not understand why python is so low.
</I>&gt;<i>
</I>&gt;<i>     Here a python code using threads
</I>&gt;<i>
</I>&gt;<i>     #!/usr/bin/env python
</I>&gt;<i>     import os
</I>&gt;<i>     import sys
</I>&gt;<i>     import time
</I>&gt;<i>     import signal
</I>&gt;<i>     import locale
</I>&gt;<i>     import traceback
</I>&gt;<i>     import threading
</I>&gt;<i>     import select
</I>&gt;<i>     import traceback as tb
</I>&gt;<i>
</I>&gt;<i>     class ClienThread():
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def __init__(self):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = False
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._cache = {}
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def exit(self):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = True
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def stdout(self, lineToSend):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.write(lineToSend)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.stdout.flush()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; except IOError as e:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if e.errno==32:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Error Broken PIPE!&quot;
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; except:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # other execpt
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def run(self):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; while not self._exiting:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if sys.stdin in select.select([sys.stdin], [], [],
</I>&gt;<i>     0.5)[0]:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; line = sys.stdin.readline()
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LenOfline=len(line)
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if LenOfline==0:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting=True
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if line[-1] == '\n':line = line[:-1]
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel = None
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; options = line.split()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if options[0].isdigit(): channel = options.pop(0)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except IndexError:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;0 OK first=ERROR\n&quot;)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; continue
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Processing here
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;%s OK\n&quot; % channel)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stdout(&quot;%s ERROR first=ERROR\n&quot; % channel)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     class Main(object):
</I>&gt;<i>     &#160;&#160;&#160; def __init__(self):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads = []
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = False
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._reload = False
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._config = &quot;&quot;
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; for sig, action in (
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGINT, self.shutdown),
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGQUIT, self.shutdown),
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGTERM, self.shutdown),
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGHUP, lambda s, f: setattr(self, '_reload',
</I>&gt;<i>     True)),
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (signal.SIGPIPE, signal.SIG_IGN),
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; ):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; signal.signal(sig, action)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; except AttributeError:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def shutdown(self, sig = None, frame = None):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._exiting = True
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self.stop_threads()
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def start_threads(self):
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; sThread = ClienThread()
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; t = threading.Thread(target = sThread.run)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; t.start()
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads.append((sThread, t))
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def stop_threads(self):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; for p, t in self._threads:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; p.exit()
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; for p, t in self._threads:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; t.join(timeout =&#160; 1.0)
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self._threads = []
</I>&gt;<i>
</I>&gt;<i>     &#160;&#160;&#160; def run(self):
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;&quot;&quot; main loop &quot;&quot;&quot;
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = 0
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; self.start_threads()
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; return ret
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     if __name__ == '__main__':
</I>&gt;<i>     &#160;&#160;&#160; # set C locale
</I>&gt;<i>     &#160;&#160;&#160; locale.setlocale(locale.LC_ALL, 'C')
</I>&gt;<i>     &#160;&#160;&#160; os.environ['LANG'] = 'C'
</I>&gt;<i>     &#160;&#160;&#160; ret = 0
</I>&gt;<i>     &#160;&#160;&#160; try:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; main = Main()
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = main.run()
</I>&gt;<i>     &#160;&#160;&#160; except SystemExit:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; pass
</I>&gt;<i>     &#160;&#160;&#160; except KeyboardInterrupt:
</I>&gt;<i>     &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = 4
</I>&gt;<i>     &#160;&#160;&#160; except:
</I>&gt;<i>     &#160;&#160;&#160; sys.exit(ret)
</I>&gt;<i>
</I>&gt;<i>     Le 04/02/2022 &#224; 07:06, Eliezer Croitoru a &#233;crit&#160;:
</I>&gt;<i>
</I>&gt;<i>         And about the cache of each helpers, the cost of a cache on a
</I>&gt;<i>         single helper is not much in terms of memory comparing to some
</I>&gt;<i>         network access.
</I>&gt;<i>
</I>&gt;<i>         Again it&#8217;s possible to test and verify this on a loaded system
</I>&gt;<i>         to get results. The delay itself can be seen from squid side
</I>&gt;<i>         in the cache manager statistics.
</I>&gt;<i>
</I>&gt;<i>         You can also try to compare the next ruby helper:
</I>&gt;<i>
</I>&gt;<i>         <A HREF="https://wiki.squid-cache.org/EliezerCroitoru/SessionHelper">https://wiki.squid-cache.org/EliezerCroitoru/SessionHelper</A>
</I>&gt;<i>
</I>&gt;<i>         About a shared &#8220;base&#8221; which allows helpers to avoid
</I>&gt;<i>         computation of the query&#8230;. It&#8217;s a good argument, however it
</I>&gt;<i>         depends what is the cost of
</I>&gt;<i>         pulling from the cache compared to calculating the answer.
</I>&gt;<i>
</I>&gt;<i>         A very simple string comparison or regex matching would
</I>&gt;<i>         probably be faster than reaching a shared storage in many cases.
</I>&gt;<i>
</I>&gt;<i>         Also take into account the &#8220;concurrency&#8221; support from the
</I>&gt;<i>         helper side.
</I>&gt;<i>
</I>&gt;<i>         A helper that supports parallel processing of requests/lines
</I>&gt;<i>         can do better then many single helpers in more than once use case.
</I>&gt;<i>
</I>&gt;<i>         In any case I would suggest to enable requests concurrency
</I>&gt;<i>         from squid side since the STDIN buffer will emulate some level
</I>&gt;<i>         of concurrency
</I>&gt;<i>         by itself and will allow squid to keep going forward faster.
</I>&gt;<i>
</I>&gt;<i>         Just to mention that SquidGuard have used a single helper
</I>&gt;<i>         cache for a very long time, ie every single SquidGuard helper
</I>&gt;<i>         has it&#8217;s own copy of the whole
</I>&gt;<i>
</I>&gt;<i>         configuration and database files in memory.
</I>&gt;<i>
</I>&gt;<i>         And again, if you do have any option to implement a server
</I>&gt;<i>         service model and that the helpers will contact this main
</I>&gt;<i>         service you will be able to implement
</I>&gt;<i>         much faster internal in-memory cache compared to a
</I>&gt;<i>         redis/memcahe/other external daemon(need to be tested).
</I>&gt;<i>
</I>&gt;<i>         A good example for this is ufdbguard which has helpers that
</I>&gt;<i>         are clients of the main service which does the whole heavy
</I>&gt;<i>         lifting and also holds
</I>&gt;<i>         one copy of the DB.
</I>&gt;<i>
</I>&gt;<i>         I have implemented SquidBlocker this way and have seen that it
</I>&gt;<i>         out-performs any other service I have tried until now.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20220208/5541f8d5/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20220208/5541f8d5/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="024486.html">[squid-users] external helper development
</A></li>
	<LI>Next message (by thread): <A HREF="024466.html">[squid-users] [ext] Re: Absolute upper limit for filedescriptors in squid-6?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24487">[ date ]</a>
              <a href="thread.html#24487">[ thread ]</a>
              <a href="subject.html#24487">[ subject ]</a>
              <a href="author.html#24487">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
