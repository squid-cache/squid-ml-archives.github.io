<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] External helper consumes too many DB connections
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20External%20helper%20consumes%20too%20many%20DB%20connections&In-Reply-To=%3CCAGCa14oeahSp4sboS%3DBSwFYij-1UseToz6HeXJEm1tszVs-Rtw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024491.html">
   <LINK REL="Next"  HREF="024493.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] External helper consumes too many DB connections</H1>
    <B>roee klinger</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20External%20helper%20consumes%20too%20many%20DB%20connections&In-Reply-To=%3CCAGCa14oeahSp4sboS%3DBSwFYij-1UseToz6HeXJEm1tszVs-Rtw%40mail.gmail.com%3E"
       TITLE="[squid-users] External helper consumes too many DB connections">roeeklinger60 at gmail.com
       </A><BR>
    <I>Tue Feb  8 16:08:33 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="024491.html">[squid-users] External helper consumes too many DB connections
</A></li>
        <LI>Next message (by thread): <A HREF="024493.html">[squid-users] External helper consumes too many DB connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24492">[ date ]</a>
              <a href="thread.html#24492">[ thread ]</a>
              <a href="subject.html#24492">[ subject ]</a>
              <a href="author.html#24492">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>
</I>&gt;<i> You have at least two basic options:
</I>

A. Enhance Squid to let SMP workers share helpers. I assume that you
&gt;<i> have C SMP workers and N helpers per worker, with C and N significantly
</I>&gt;<i> greater than 1. Instead of having N helpers per worker and C*N helpers
</I>&gt;<i> total, you will have just one concurrent helper per worker and C helpers
</I>&gt;<i> total. This will be a significant, generally useful improvement that
</I>&gt;<i> should be officially accepted if implemented well. This enhancement
</I>&gt;<i> requires serious Squid code modifications in a neglected error-prone
</I>&gt;<i> area, but it is certainly doable -- Squid already shares rock diskers
</I>&gt;<i> across workers, for example.
</I>

B. Convert your helper from a database client program to an Aggregator
&gt;<i> client program (and write the Aggregator). Depending on your needs and
</I>&gt;<i> skill, you can use TCP or Unix Domain Sockets (UDS) for
</I>&gt;<i> helper-Aggregator communication. The Aggregator may look very similar to
</I>&gt;<i> the current helper, except it will not use stdin/stdout for
</I>&gt;<i> receiving/sending helper queries/responses. This option also requires
</I>&gt;<i> development, but it is much simpler than option A.
</I>

Thank you, Alex, I will keep these in mind.

I thought about the following approach:

1. Have only one python helper, this helper fetches the data every minute
from the main DB.
2. This helper has concurrency set for it.
3. The helper then spawns child processes using multithreading, each
process responds to std/stdout and reads the data from the main process
which spawned it.

What do you think about taking this route?

It will require no extra DBs and no tweaks to Squid, but maybe I am missing
something,

Best regards,
Roee

On Tue, Feb 8, 2022 at 5:12 PM Alex Rousskov &lt;
<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt; wrote:

&gt;<i> On 2/8/22 09:50, roee klinger wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; Alex: If there are a lot more requests than your users/TTLs should
</I>&gt;<i> &gt;       generate, then you may be able to decrease db load by figuring out
</I>&gt;<i> &gt;       where the extra requests are coming from.
</I>&gt;<i>
</I>&gt;<i> &gt; actually, I don't think it matters much now that I think about it
</I>&gt;<i> &gt; again, since as per my requirements, I need to reload the cache every
</I>&gt;<i> &gt; 60 seconds, which means that even if it is perfect, MariaDB will
</I>&gt;<i> &gt; still get a high load. I think the second approach will be better
</I>&gt;<i> &gt; suited.
</I>&gt;<i>
</I>&gt;<i> Your call. Wiping out the entire authentication cache every 60 seconds
</I>&gt;<i> feels odd, but I do not know enough about your environment to judge.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; Alex: aggregating helper-db connections (helpers can be written to
</I>&gt;<i> &gt;       talk through a central connection aggregator)
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> &gt; That sounds like exactly what I am looking for, how would one go about
</I>&gt;<i> &gt; doing this?
</I>&gt;<i>
</I>&gt;<i> You have at least two basic options:
</I>&gt;<i>
</I>&gt;<i> A. Enhance Squid to let SMP workers share helpers. I assume that you
</I>&gt;<i> have C SMP workers and N helpers per worker, with C and N significantly
</I>&gt;<i> greater than 1. Instead of having N helpers per worker and C*N helpers
</I>&gt;<i> total, you will have just one concurrent helper per worker and C helpers
</I>&gt;<i> total. This will be a significant, generally useful improvement that
</I>&gt;<i> should be officially accepted if implemented well. This enhancement
</I>&gt;<i> requires serious Squid code modifications in a neglected error-prone
</I>&gt;<i> area, but it is certainly doable -- Squid already shares rock diskers
</I>&gt;<i> across workers, for example.
</I>&gt;<i>
</I>&gt;<i> B. Convert your helper from a database client program to an Aggregator
</I>&gt;<i> client program (and write the Aggregator). Depending on your needs and
</I>&gt;<i> skill, you can use TCP or Unix Domain Sockets (UDS) for
</I>&gt;<i> helper-Aggregator communication. The Aggregator may look very similar to
</I>&gt;<i> the current helper, except it will not use stdin/stdout for
</I>&gt;<i> receiving/sending helper queries/responses. This option also requires
</I>&gt;<i> development, but it is much simpler than option A.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; On Tue, Feb 8, 2022 at 4:41 PM Alex Rousskov wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     On 2/8/22 09:13, roee klinger wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;      &gt; I am running multiple instances of Squid in a K8S environment,
</I>&gt;<i> each
</I>&gt;<i> &gt;      &gt; Squid instance has a helper that authenticates users based on
</I>&gt;<i> their
</I>&gt;<i> &gt;      &gt; username and password, the scripts are written in Python.
</I>&gt;<i> &gt;      &gt;
</I>&gt;<i> &gt;      &gt; I have been facing an issue, that when under load, the helpers
</I>&gt;<i> (even
</I>&gt;<i> &gt;      &gt; with 3600 sec TTL) swamp the MariaDB instance, causing it to
</I>&gt;<i> &gt;     reach 100%
</I>&gt;<i> &gt;      &gt; CPU, basically I believe because each helper opens up its own
</I>&gt;<i> &gt;     connection
</I>&gt;<i> &gt;      &gt; to MariaDB, which ends up as a lot of connections.
</I>&gt;<i> &gt;      &gt;
</I>&gt;<i> &gt;      &gt; My initial idea was to create a Redis DB next to each Squid
</I>&gt;<i> &gt;     instance and
</I>&gt;<i> &gt;      &gt; connect each Squid to its own dedicated Redis. I will sync Redis
</I>&gt;<i> &gt;     with
</I>&gt;<i> &gt;      &gt; MariaDB every minute, thus decreasing the connections count from
</I>&gt;<i> &gt;     a few
</I>&gt;<i> &gt;      &gt; 100s to just 1 every minute. This will also improve speeds since
</I>&gt;<i> &gt;     Redis
</I>&gt;<i> &gt;      &gt; is much faster than MariaDB.
</I>&gt;<i> &gt;      &gt;
</I>&gt;<i> &gt;      &gt; The problem is, however, that there will still be many
</I>&gt;<i> &gt;     connections from
</I>&gt;<i> &gt;      &gt; Squid to Redis, and I probably that will consume a lot of DB
</I>&gt;<i> &gt;     resources
</I>&gt;<i> &gt;      &gt; as well, which I don't actually know how to optimize, since it
</I>&gt;<i> seems
</I>&gt;<i> &gt;      &gt; that Squid opens many processes, and there is no way to get them
</I>&gt;<i> &gt;     to talk
</I>&gt;<i> &gt;      &gt; to each other (expect TTL values, which seems not to help in my
</I>&gt;<i> &gt;     case,
</I>&gt;<i> &gt;      &gt; which I also don't understand why that is).
</I>&gt;<i> &gt;      &gt;
</I>&gt;<i> &gt;      &gt; What is the best practice to handle this? considering I have the
</I>&gt;<i> &gt;      &gt; following requirements:
</I>&gt;<i> &gt;      &gt;
</I>&gt;<i> &gt;      &gt;     1. Fast
</I>&gt;<i> &gt;      &gt;     2. Refresh data every minute
</I>&gt;<i> &gt;      &gt;     3. Consume as least amount of DB resources as possible
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     I would start from the beginning: Does the aggregate number of
</I>&gt;<i> database
</I>&gt;<i> &gt;     requests match your expectations? In other words, do you see lots of
</I>&gt;<i> &gt;     database requests that should not be there given your user access
</I>&gt;<i> &gt;     patterns and authentication TTLs? In yet other words, are there many
</I>&gt;<i> &gt;     repeated authentication accesses that should have been authentication
</I>&gt;<i> &gt;     cache hits?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     If there are a lot more requests than your users/TTLs should
</I>&gt;<i> generate,
</I>&gt;<i> &gt;     then you may be able to decrease db load by figuring out where the
</I>&gt;<i> &gt;     extra
</I>&gt;<i> &gt;     requests are coming from. For example, it is possible that your
</I>&gt;<i> &gt;     authentication cache key includes some noise that renders caching
</I>&gt;<i> &gt;     ineffective (e.g., see comments about key_extras in
</I>&gt;<i> &gt;     squid.conf.documented). Or maybe you need a bigger authentication
</I>&gt;<i> cache.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     If the total stream of authentication requests during peak hours is
</I>&gt;<i> &gt;     reasonable, with few unwarranted cache misses, then you can start
</I>&gt;<i> &gt;     working on aggregating helper-db connections (helpers can be written
</I>&gt;<i> to
</I>&gt;<i> &gt;     talk through a central connection aggregator) and/or adding database
</I>&gt;<i> &gt;     power (e.g., by introducing additional databases running on
</I>&gt;<i> previously
</I>&gt;<i> &gt;     unused hardware -- just like your MariaDB idea).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     Cheers,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     Alex.
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20220208/ff590a25/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20220208/ff590a25/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="024491.html">[squid-users] External helper consumes too many DB connections
</A></li>
	<LI>Next message (by thread): <A HREF="024493.html">[squid-users] External helper consumes too many DB connections
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24492">[ date ]</a>
              <a href="thread.html#24492">[ thread ]</a>
              <a href="subject.html#24492">[ subject ]</a>
              <a href="author.html#24492">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
