<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] FW: Encrypted browser-Squid connection errors
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20FW%3A%20Encrypted%20browser-Squid%20connection%20errors&In-Reply-To=%3C19fa29f8ddf517b0e38d73a7e6b0ca55%40treenet.co.nz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025329.html">
   <LINK REL="Next"  HREF="025362.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] FW: Encrypted browser-Squid connection errors</H1>
    <B>squid3 at treenet.co.nz</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20FW%3A%20Encrypted%20browser-Squid%20connection%20errors&In-Reply-To=%3C19fa29f8ddf517b0e38d73a7e6b0ca55%40treenet.co.nz%3E"
       TITLE="[squid-users] FW: Encrypted browser-Squid connection errors">squid3 at treenet.co.nz
       </A><BR>
    <I>Sun Oct 30 12:59:00 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025329.html">[squid-users] FW: Encrypted browser-Squid connection errors
</A></li>
        <LI>Next message (by thread): <A HREF="025362.html">[squid-users] FW: Encrypted browser-Squid connection errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25359">[ date ]</a>
              <a href="thread.html#25359">[ thread ]</a>
              <a href="subject.html#25359">[ subject ]</a>
              <a href="author.html#25359">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 2022-10-23 06:10, Grant Taylor wrote:
&gt;<i> On 10/21/22 11:30 PM, Amos Jeffries wrote:
</I>&gt;&gt;<i> Not just convention. AFAICT was formally registered with W3C, before 
</I>&gt;&gt;<i> everyone went to using IETF for registrations.
</I>&gt;<i> 
</I>&gt;<i> Please elaborate on what was formally registered.  I've only seen 3128 
</I>&gt;<i> / 3129 be the default for Squid (and a few things emulating squid).  
</I>&gt;<i> Other proxies of the time, namely Netscape's and Microsoft's 
</I>&gt;<i> counterparts, tended to use 8080.
</I>&gt;<i> 
</I>&gt;<i> I'd genuinely like to learn more about and understand the history / 
</I>&gt;<i> etymology / genesis of the 3128 / 3129.
</I>
Duane W. would be the best one to ask about the details.

What I know is that some 10-12 years ago I discovered an message by 
Duane mentioning that W3C had (given or accepted) port 3128 for Squid 
use. I've checked the squid-cache archives and not seeing the message.

Right now it looks like the W3C changed their systems and only track the 
standards documents. So I cannot reference their (outdated?) protocol 
registry :-{ . Also checked the squid-cache archives and not finding it 
email history. Sorry.


&gt;<i> 
</I>&gt;&gt;<i> FYI, discussion started ~30 years ago.
</I>&gt;<i> 
</I>&gt;<i> ACK
</I>&gt;<i> 
</I>&gt;&gt;<i> The problem:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> For bandwidth savings HTTP/1.0 defined different URL syntax for origin 
</I>&gt;&gt;<i> and relay/proxy requests. The form sent to an origin server lacks any 
</I>&gt;&gt;<i> information about the authority. That was expected to be known 
</I>&gt;&gt;<i> out-of-band by the origin itself.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> HTTP/1.1 has attempted several different mechanisms to fix this over 
</I>&gt;&gt;<i> the years. None of them has been universally accepted, so the problem 
</I>&gt;&gt;<i> remains. The best we have is mandatory Host header which most (but 
</I>&gt;&gt;<i> sadly not all) clients and servers use.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> HTTP/2 cements that design with mandatory &quot;:authority&quot; pseudo-header 
</I>&gt;&gt;<i> field. So the problem is &quot;fixed&quot;for native HTTP/2+ traffic. But until 
</I>&gt;&gt;<i> HTTP/1.0 and broken HTTP/1.1 clients are all gone the issue will still 
</I>&gt;&gt;<i> crop up.
</I>&gt;<i> 
</I>&gt;<i> I'm not entirely sure what you mean by &quot;the authority&quot;.  I'm taking it 
</I>&gt;<i> to mean the identity of the service that you are wanting content from. 
</I>&gt;<i> The Host: header comment with HTTP/1.1 is what makes me think this.
</I>&gt;<i> 
</I>
I mean &quot;authority&quot; as used by HTTP specification, which refers to 
<A HREF="https://www.rfc-editor.org/rfc/rfc3986#section-3.2">https://www.rfc-editor.org/rfc/rfc3986#section-3.2</A>


&gt;<i> My understanding is that neither HTTP/0.9 nor HTTP/1.0 had a Host: 
</I>&gt;<i> header and that it was assumed that the IP address you were connecting 
</I>&gt;<i> to conveyed the server that you were wanting to connect to.
</I>
Yes exactly. That is the source of the problem, perpetuated by the need 
to retain on-wire byte/octet backward compatibility until HTTP/2 changed 
to binary format.

Consider what the proxy has to do when (not if) the IP:port being 
connected to are that proxy's (eg localhost:80) and the URL is only a 
path (&quot;/&quot;) on an origin server somewhere else. Does the &quot;GET / HTTP/1.0&quot; 
mean &quot;<A HREF="http://example.com/">http://example.com/</A>&quot; or &quot;<A HREF="http://example.net/">http://example.net/</A>&quot; ?


&gt;<i> 
</I>&gt;&gt;<i> More importantly the proxy hostname:port the client is opening TCP 
</I>&gt;&gt;<i> connections to may be different from the authority-info specified in 
</I>&gt;&gt;<i> the HTTP request message (or lack thereof).
</I>&gt;<i> 
</I>&gt;<i> My working understanding of what the authority is seems to still work 
</I>&gt;<i> with this.
</I>&gt;<i> 
</I>
The key point is that the proxy host:port and the origin host:port are 
two different authority and only the origin may be passed along in the 
URL (or URL+Host header). When the client uses port 80 and 443 thinking 
they are origin services it is *required* (per 
<A HREF="https://www.rfc-editor.org/rfc/rfc9112.html#name-origin-form">https://www.rfc-editor.org/rfc/rfc9112.html#name-origin-form</A>) to omit 
the real origins info. Enter problems.


&gt;&gt;<i> This crosses security boundaries and involves out-of-band information 
</I>&gt;&gt;<i> sources at all three endpoints involved in the transaction for the 
</I>&gt;&gt;<i> message semantics and protocol negotiations to work properly.
</I>&gt;<i> 
</I>&gt;<i> I feel like the nature of web traffic tends to frequently, but not 
</I>&gt;<i> always, cross security / administrative boundaries.  As such, I don't 
</I>&gt;<i> think that existence of proxies in the communications path alters 
</I>&gt;<i> things much.
</I>&gt;<i> 
</I>&gt;<i> Please elaborate on what out-of-band information you are describing. 
</I>&gt;<i> The most predominant thing that comes to mind, particularly with 
</I>&gt;<i> HTTP/1.1 and HTTP/2 is name resolution -- ostensibly DNS -- to identify 
</I>&gt;<i> the IP address to connect to.
</I>&gt;<i> 
</I>
I refer to all the many ways the clients may be explicitly or implicitly 
configured to be aware that it is talking to a proxy - such that it 
explicitly avoids sending the problematic origin-form URLs.


&gt;&gt;<i> What that text does not say is that when they are omitted by the 
</I>&gt;&gt;<i> **user** they are taken from configuration settings in the OS:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>  &#160;* the environment variable name provides:
</I>&gt;&gt;<i>  &#160;&#160;&#160; - the protocol name (&quot;http&quot; or &quot;HTTPS&quot;, aka plain-text or 
</I>&gt;&gt;<i> encrypted)
</I>&gt;&gt;<i>  &#160;&#160;&#160; - the expected protocol syntax/semantics (&quot;proxy&quot; aka 
</I>&gt;&gt;<i> forward-proxy)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i>  &#160;* the machine /etc/services configuration provides the default port 
</I>&gt;&gt;<i> for the named protocol.
</I>&gt;<i> 
</I>&gt;<i> Ergo the use of /default/ values when values are not specified.
</I>
The defaults though are tuned for origin server (or reverse-proxy) 
direct contact.
No Browser I know supports 
&quot;http-<A HREF="alt://proxy.example.com?http://origin.example.net/index.html">alt://proxy.example.com?http://origin.example.net/index.html</A>&quot; 
URLs.


&gt;<i> 
</I>&gt;<i> I feel like this in a round about way supports my stance that the 
</I>&gt;<i> default ports are perfectly fine to use.
</I>&gt;<i> 
</I>
... &quot;at your own risk&quot; they technically might be. So long as you only 
receive one of the three types of syntax there - port 80/443 being 
officially registered for origin / reverse-proxy syntax.


&gt;&gt;<i> Attempting to use a reverse-proxy or origin server such a 
</I>&gt;&gt;<i> configuration may work for some messages, but **will** fail due to 
</I>&gt;&gt;<i> syntax or semantic errors on others.
</I>&gt;<i> 
</I>&gt;<i> I question the veracity of that statement.
</I>

It is based on experience. Squid used to be a lot more lenient and tried 
for decades to do the syntax auto-detection. The path from that to 
separate ports is littered with CVEs. Most notably the curse that keeps 
on giving: CVE-2009-0801, which is just the trigger issue for a whole 
nest of bad side effects.


Amos

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025329.html">[squid-users] FW: Encrypted browser-Squid connection errors
</A></li>
	<LI>Next message (by thread): <A HREF="025362.html">[squid-users] FW: Encrypted browser-Squid connection errors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25359">[ date ]</a>
              <a href="thread.html#25359">[ thread ]</a>
              <a href="subject.html#25359">[ subject ]</a>
              <a href="author.html#25359">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
