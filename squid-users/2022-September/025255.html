<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Use ICP RTT with HTTPS request
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Use%20ICP%20RTT%20with%20HTTPS%20request&In-Reply-To=%3C80b149d8-87fc-8055-2314-ef36e10277f0%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025254.html">
   <LINK REL="Next"  HREF="025260.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Use ICP RTT with HTTPS request</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Use%20ICP%20RTT%20with%20HTTPS%20request&In-Reply-To=%3C80b149d8-87fc-8055-2314-ef36e10277f0%40measurement-factory.com%3E"
       TITLE="[squid-users] Use ICP RTT with HTTPS request">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Sep 26 13:25:58 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025254.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
        <LI>Next message (by thread): <A HREF="025260.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25255">[ date ]</a>
              <a href="thread.html#25255">[ thread ]</a>
              <a href="subject.html#25255">[ subject ]</a>
              <a href="author.html#25255">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 9/26/22 05:51, Th&#233;o BARRAGUE wrote:

&gt;<i>  entry is null so peerGetSomeNeighbor is never called
</I>
I did not check all the details, but it looks like Squid ICMP code 
(ab)uses StoreEntry-linked metadata. Basic CONNECT tunnels lack 
StoreEntry because they are not reading/writing data from/to Store. The 
combination is essentially a Squid bug -- basic CONNECT tunnels cannot 
use ICMP features.

Most likely, the correct long-term solution here is to remove StoreEntry 
use from ICMP code -- I bet that code does not have a genuine need for 
Store access and should store its essential metadata elsewhere. That 
proper solution will require non-trivial development. For a possibly 
simpler workaround, one could consider creating a temporary StoreEntry 
object for ICMP use (instead of disabling ICMP for entry-less use cases).

<A HREF="https://wiki.squid-cache.org/SquidFaq/AboutSquid#How_to_add_a_new_Squid_feature.2C_enhance.2C_of_fix_something.3F">https://wiki.squid-cache.org/SquidFaq/AboutSquid#How_to_add_a_new_Squid_feature.2C_enhance.2C_of_fix_something.3F</A>


HTH,

Alex.

&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(163) peerSelect: CONNECT
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(472) peerSelectFoo:
</I>&gt;<i>     CONNECT api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(485) peerSelectFoo:
</I>&gt;<i>     peerSelectFoo: direct&#160;= DIRECT_UNKNOWN (never_direct to be checked)
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x5653abfc4b68 checking slow rules
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896'&#160;found
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked: all&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     never_direct#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     never_direct&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x5653abfc4b68 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(163) checkCallback:
</I>&gt;<i>     ACLChecklist::checkCallback: 0x5653abfc4b68 answer=ALLOWED
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(195)
</I>&gt;<i>     peerCheckNeverDirectDone: peerCheckNeverDirectDone: ALLOWED
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(201)
</I>&gt;<i>     peerCheckNeverDirectDone: direct&#160;= DIRECT_NO (never_direct allow)
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(472) peerSelectFoo:
</I>&gt;<i>     CONNECT api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(712)
</I>&gt;<i>     peerGetSomeParent: CONNECT api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.381| 15,3| neighbors.cc(332)
</I>&gt;<i>     getRoundRobinParent: returning NULL
</I>&gt;<i>     2022/09/26 09:07:52.381| 15,3| neighbors.cc(382)
</I>&gt;<i>     getWeightedRoundRobinParent: getWeightedRoundRobinParent: returning NULL
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x7ffd6220f030 checking fast rules
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896'&#160;found
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked: all&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x7ffd6220f030 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.381| 15,3| neighbors.cc(294) getFirstUpParent:
</I>&gt;<i>     getFirstUpParent: returning 10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(978) peerAddFwdServer:
</I>&gt;<i>     adding FIRSTUP_PARENT/10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x7ffd6220f0d0 checking fast rules
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896'&#160;found
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked: all&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x7ffd6220f0d0 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,3| peer_select.cc(971) peerAddFwdServer:
</I>&gt;<i>     skipping ANY_OLD_PARENT/10.26.8.10; have FIRSTUP_PARENT/10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x7ffd6220f0d0 checking fast rules
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896'&#160;found
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked: all&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc01#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc01&#160;= 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x7ffd6220f0d0 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,3| peer_select.cc(978) peerAddFwdServer:
</I>&gt;<i>     adding ANY_OLD_PARENT/127.0.0.1
</I>&gt;<i>     2022/09/26 09:07:52.382| 15,3| neighbors.cc(472) getDefaultParent:
</I>&gt;<i>     getDefaultParent: returning NULL
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(295)
</I>&gt;<i>     peerSelectDnsPaths: Find IP destination for: api.gouv.fr:443' via
</I>&gt;<i>     10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(295)
</I>&gt;<i>     peerSelectDnsPaths: Find IP destination for: api.gouv.fr:443'&#160;via
</I>&gt;<i>     127.0.0.1
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(316)
</I>&gt;<i>     peerSelectDnsPaths: Found sources for 'api.gouv.fr:443'
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(317)
</I>&gt;<i>     peerSelectDnsPaths: always_direct&#160;= DENIED
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(318)
</I>&gt;<i>     peerSelectDnsPaths: never_direct&#160;= ALLOWED
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(328)
</I>&gt;<i>     peerSelectDnsPaths: cache_peer&#160;= local=0.0.0.0
</I>&gt;<i>     remote=10.26.8.10:3129 flags=1
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(328)
</I>&gt;<i>     peerSelectDnsPaths: cache_peer&#160;= local=0.0.0.0 remote=127.0.0.1:3129
</I>&gt;<i>     flags=1
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(331)
</I>&gt;<i>     peerSelectDnsPaths: timedout&#160;= 0
</I>&gt;<i>     2022/09/26 09:07:52.382| 26,3| tunnel.cc(1249)
</I>&gt;<i>     tunnelPeerSelectComplete: paths=2, p[0]={local=0.0.0.0
</I>&gt;<i>     remote=10.26.8.10:3129 flags=1}, serverDest[0]={local=0.0.0.0
</I>&gt;<i>     remote=10.26.8.10:3129 flags=1}
</I>&gt;<i>     2022/09/26 09:07:52.382| 17,3| FwdState.cc(1369)
</I>&gt;<i>     GetMarkingsToServer: from 0.0.0.0 netfilter mark 0
</I>&gt;<i>     2022/09/26 09:07:52.382| 26,3| AsyncCall.cc(25) AsyncCall: The
</I>&gt;<i>     AsyncCall tunnelConnectDone constructed, this=0x5653abf924a0 [call164]
</I>&gt;<i>     2022/09/26 09:07:52.382| 5,3| ConnOpener.cc(43) ConnOpener: will
</I>&gt;<i>     connect to local=0.0.0.0 remote=10.26.8.10:3129 flags=1 with 30 timeout
</I>&gt;<i>     2022/09/26 09:07:52.382| 50,3| comm.cc(350) comm_openex:
</I>&gt;<i>     comm_openex: Attempt open socket for: 0.0.0.0
</I>&gt;<i>     2022/09/26 09:07:52.382| 50,3| comm.cc(393) comm_openex:
</I>&gt;<i>     comm_openex: Opened socket local=0.0.0.0 remote=[::] FD 14 flags=1 :
</I>&gt;<i>     family=2, type=1, protocol=6
</I>&gt;<i>     2022/09/26 09:07:52.382| 51,3| fd.cc(198) fd_open: fd_open() FD 14
</I>&gt;<i>     api.gouv.fr:443
</I>&gt;<i>     2022/09/26 09:07:52.382| 5,3| ConnOpener.cc(291) createFd:
</I>&gt;<i>     local=0.0.0.0 remote=10.26.8.10:3129 flags=1 will timeout in 30
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCall.cc(92) ScheduleCall:
</I>&gt;<i>     ConnOpener.cc(139) will call
</I>&gt;<i>     tunnelConnectDone(local=10.25.8.10:58500 remote=10.26.8.10:3129 FD
</I>&gt;<i>     14 flags=1, data=0x5653abfa3598) [call164]
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCallQueue.cc(55) fireNext:
</I>&gt;<i>     entering tunnelConnectDone(local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, data=0x5653abfa3598)
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCall.cc(37) make: make call
</I>&gt;<i>     tunnelConnectDone [call164]
</I>&gt;<i>     2022/09/26 09:07:52.393| 14,3| Address.cc(382) lookupHostIP: Given
</I>&gt;<i>     Non-IP 'api.gouv.fr': Name or service not known
</I>&gt;<i>     2022/09/26 09:07:52.393| 38,3| net_db.cc(355) netdbSendPing:
</I>&gt;<i>     netdbSendPing: pinging api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.393| 37,2| IcmpSquid.cc(59) SendEcho: &#160;Socket
</I>&gt;<i>     Closed. Aborted send to 10.26.8.10, opcode 3, len 10
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| tunnel.cc(1163)
</I>&gt;<i>     tunnelRelayConnectRequest: local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, tunnelState=0x5653abfa3598
</I>&gt;<i>     2022/09/26 09:07:52.393| 22,3| refresh.cc(648) getMaxAge: getMaxAge:
</I>&gt;<i>     'api.gouv.fr:443'
</I>&gt;<i>     2022/09/26 09:07:52.393| 11,2| tunnel.cc(1177)
</I>&gt;<i>     tunnelRelayConnectRequest: Tunnel Server REQUEST:
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1:
</I>&gt;<i>     ----------
</I>&gt;<i>     CONNECT api.gouv.fr:443 HTTP/1.1
</I>&gt;<i>     User-Agent: curl/7.52.1
</I>&gt;<i>     Host: api.gouv.fr:443
</I>&gt;<i>     X-Forwarded-For: unknown
</I>&gt;<i>     Cache-Control: max-age=259200
</I>&gt;<i>     Connection: close
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     ----------
</I>&gt;<i>     2022/09/26 09:07:52.393| 5,3| comm.cc(559) commSetConnTimeout:
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1 timeout 900
</I>&gt;<i>     2022/09/26 09:07:52.393| 5,3| comm.cc(559) commSetConnTimeout:
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1 timeout 900
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCallQueue.cc(57) fireNext:
</I>&gt;<i>     leaving tunnelConnectDone(local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, data=0x5653abfa3598)
</I>&gt;<i>     2022/09/26 09:07:52.393| 5,3| IoCallback.cc(116) finish: called for
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1 (0, 0)
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| tunnel.cc(929)
</I>&gt;<i>     tunnelConnectReqWriteDone: local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, flag=0
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It seems /peerGetSomeParent/ is called and this method never issue an ICP :
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     staticvoid
</I>&gt;<i>     peerGetSomeParent(ps_state * ps)
</I>&gt;<i>     {
</I>&gt;<i>      &#160; &#160; CachePeer *p;
</I>&gt;<i>      &#160; &#160; HttpRequest *request = ps-&gt;request;
</I>&gt;<i>      &#160; &#160; hier_code code = HIER_NONE;
</I>&gt;<i>     debugs(44, 3, request-&gt;method&#160;&lt;&lt; ' '&#160;&lt;&lt; request-&gt;url.host());
</I>&gt;<i>     if&#160;(ps-&gt;direct&#160;== DIRECT_YES)
</I>&gt;<i>     return;
</I>&gt;<i>     if&#160;((p = peerSourceHashSelectParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = SOURCEHASH_PARENT;
</I>&gt;<i>     #if&#160;USE_AUTH
</I>&gt;<i>      &#160; &#160; } elseif&#160;((p = peerUserHashSelectParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = USERHASH_PARENT;
</I>&gt;<i>     #endif
</I>&gt;<i>      &#160; &#160; } elseif&#160;((p = carpSelectParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = CARP;
</I>&gt;<i>      &#160; &#160; } elseif&#160;((p = getRoundRobinParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = ROUNDROBIN_PARENT;
</I>&gt;<i>      &#160; &#160; } elseif&#160;((p = getWeightedRoundRobinParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = ROUNDROBIN_PARENT;
</I>&gt;<i>      &#160; &#160; } elseif&#160;((p = getFirstUpParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = FIRSTUP_PARENT;
</I>&gt;<i>      &#160; &#160; } elseif&#160;((p = getDefaultParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; code = DEFAULT_PARENT;
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(code != HIER_NONE) {
</I>&gt;<i>     peerAddFwdServer(ps, p, code);
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Instead of /peerGetSomeNeighbor/ :
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     /**
</I>&gt;<i>      &#160;* peerGetSomeNeighbor
</I>&gt;<i>      &#160;*
</I>&gt;<i>      &#160;* Selects a neighbor (parent or sibling) based on one of the
</I>&gt;<i>      &#160;* following methods:
</I>&gt;<i>      &#160;* &#160; &#160; &#160;Cache Digests
</I>&gt;<i>      &#160;* &#160; &#160; &#160;CARP
</I>&gt;<i>      &#160;* &#160; &#160; &#160;ICMP Netdb RTT estimates
</I>&gt;<i>      &#160;* &#160; &#160; &#160;ICP/HTCP queries
</I>&gt;<i>      &#160;*/
</I>&gt;<i>     staticvoid
</I>&gt;<i>     peerGetSomeNeighbor(ps_state * ps)
</I>&gt;<i>     {
</I>&gt;<i>      &#160; &#160; StoreEntry *entry = ps-&gt;entry;
</I>&gt;<i>      &#160; &#160; HttpRequest *request = ps-&gt;request;
</I>&gt;<i>      &#160; &#160; CachePeer *p;
</I>&gt;<i>      &#160; &#160; hier_code code = HIER_NONE;
</I>&gt;<i>     assert(entry-&gt;ping_status&#160;== PING_NONE);
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(ps-&gt;direct&#160;== DIRECT_YES) {
</I>&gt;<i>     entry-&gt;ping_status&#160;= PING_DONE;
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     #if&#160;USE_CACHE_DIGESTS
</I>&gt;<i>     if&#160;((p = neighborsDigestSelect(request))) {
</I>&gt;<i>     if&#160;(neighborType(p, request-&gt;url) == PEER_PARENT)
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; code = CD_PARENT_HIT;
</I>&gt;<i>     else
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; code = CD_SIBLING_HIT;
</I>&gt;<i>      &#160; &#160; } else
</I>&gt;<i>     #endif
</I>&gt;<i>     if&#160;((p = netdbClosestParent(request))) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; code = CLOSEST_PARENT;
</I>&gt;<i>      &#160; &#160; &#160; &#160; } elseif&#160;(peerSelectIcpPing(request, ps-&gt;direct, entry)) {
</I>&gt;<i>     debugs(44, 3, &quot;peerSelect: Doing ICP pings&quot;);
</I>&gt;<i>     ps-&gt;ping.start&#160;= current_time;
</I>&gt;<i>     ps-&gt;ping.n_sent&#160;= neighborsUdpPing(request,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;entry,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;peerHandlePingReply,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ps,
</I>&gt;<i>                                                   
</I>&gt;<i>      &#160;&amp;ps-&gt;ping.n_replies_expected,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&amp;ps-&gt;ping.timeout);
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(ps-&gt;ping.n_sent&#160;== 0)
</I>&gt;<i>     debugs(44, DBG_CRITICAL, &quot;WARNING: neighborsUdpPing returned 0&quot;);
</I>&gt;<i>     debugs(44, 3, &quot;peerSelect: &quot;&#160;&lt;&lt; ps-&gt;ping.n_replies_expected&#160;&lt;&lt;
</I>&gt;<i>     &quot; ICP replies expected, RTT &quot;&#160;&lt;&lt; ps-&gt;ping.timeout&#160;&lt;&lt;
</I>&gt;<i>     &quot; msec&quot;);
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(ps-&gt;ping.n_replies_expected&#160;&gt; 0) {
</I>&gt;<i>     entry-&gt;ping_status&#160;= PING_WAITING;
</I>&gt;<i>     eventAdd(&quot;peerPingTimeout&quot;,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;peerPingTimeout,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ps,
</I>&gt;<i>     0.001&#160;* ps-&gt;ping.timeout,
</I>&gt;<i>     0);
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i>      &#160; &#160; &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(code != HIER_NONE) {
</I>&gt;<i>     assert(p);
</I>&gt;<i>     peerAddFwdServer(ps, p, code);
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     entry-&gt;ping_status&#160;= PING_DONE;
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> These functions are called from /peerSelectFoo/&#160;:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     staticvoid
</I>&gt;<i>     peerSelectFoo(ps_state * ps)
</I>&gt;<i>     {
</I>&gt;<i>     if&#160;(!cbdataReferenceValid(ps-&gt;callback_data)) {
</I>&gt;<i>     debugs(44, 3, &quot;Aborting peer selection. Parent Job went away.&quot;);
</I>&gt;<i>     delete&#160;ps;
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i>      &#160; &#160; StoreEntry *entry = ps-&gt;entry;
</I>&gt;<i>      &#160; &#160; HttpRequest *request = ps-&gt;request;
</I>&gt;<i>     debugs(44, 3, request-&gt;method&#160;&lt;&lt; ' '&#160;&lt;&lt; request-&gt;url.host());
</I>&gt;<i>      &#160; &#160; /** If we don't know whether DIRECT is permitted ... */
</I>&gt;<i>     if&#160;(ps-&gt;direct&#160;== DIRECT_UNKNOWN) {
</I>&gt;<i>     if&#160;(ps-&gt;always_direct&#160;== ACCESS_DUNNO) {
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (always_direct to be checked)&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; /** check always_direct; */
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; ACLFilledChecklist *ch =
</I>&gt;<i>     newACLFilledChecklist(Config.accessList.AlwaysDirect, request, NULL);
</I>&gt;<i>     ch-&gt;al&#160;= ps-&gt;al;
</I>&gt;<i>     ps-&gt;acl_checklist&#160;= ch;
</I>&gt;<i>     ps-&gt;acl_checklist-&gt;nonBlockingCheck(peerCheckAlwaysDirectDone, ps);
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; &#160; &#160; } elseif&#160;(ps-&gt;never_direct&#160;== ACCESS_DUNNO) {
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (never_direct to be checked)&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; /** check never_direct; */
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; ACLFilledChecklist *ch =
</I>&gt;<i>     newACLFilledChecklist(Config.accessList.NeverDirect, request, NULL);
</I>&gt;<i>     ch-&gt;al&#160;= ps-&gt;al;
</I>&gt;<i>     ps-&gt;acl_checklist&#160;= ch;
</I>&gt;<i>     ps-&gt;acl_checklist-&gt;nonBlockingCheck(peerCheckNeverDirectDone, ps);
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; &#160; &#160; } elseif&#160;(request-&gt;flags.noDirect) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; /** if we are accelerating, direct is not an option. */
</I>&gt;<i>     ps-&gt;direct&#160;= DIRECT_NO;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (forced non-direct)&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; } elseif&#160;(request-&gt;flags.loopDetected) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; /** if we are in a forwarding-loop, direct is not an
</I>&gt;<i>     option. */
</I>&gt;<i>     ps-&gt;direct&#160;= DIRECT_YES;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (forwarding loop detected)&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; } elseif&#160;(peerCheckNetdbDirect(ps)) {
</I>&gt;<i>     ps-&gt;direct&#160;= DIRECT_YES;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (checkNetdbDirect)&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; } else&#160;{
</I>&gt;<i>     ps-&gt;direct&#160;= DIRECT_MAYBE;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (default)&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot;&#160;&lt;&lt; DirectStr[ps-&gt;direct]);
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(!entry || entry-&gt;ping_status&#160;== PING_NONE)
</I>&gt;<i>     peerSelectPinned(ps);
</I>&gt;<i>     if&#160;(entry == NULL) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; (void) 0;
</I>&gt;<i>      &#160; &#160; } elseif&#160;(entry-&gt;ping_status&#160;== PING_NONE) {
</I>&gt;<i>     peerGetSomeNeighbor(ps);
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(entry-&gt;ping_status&#160;== PING_WAITING)
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; } elseif&#160;(entry-&gt;ping_status&#160;== PING_WAITING) {
</I>&gt;<i>     peerGetSomeNeighborReplies(ps);
</I>&gt;<i>     entry-&gt;ping_status&#160;= PING_DONE;
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     switch&#160;(ps-&gt;direct) {
</I>&gt;<i> 
</I>&gt;<i>     case&#160;DIRECT_YES:
</I>&gt;<i>     peerGetSomeDirect(ps);
</I>&gt;<i>     break;
</I>&gt;<i> 
</I>&gt;<i>     case&#160;DIRECT_NO:
</I>&gt;<i>     peerGetSomeParent(ps);
</I>&gt;<i>     peerGetAllParents(ps);
</I>&gt;<i>     break;
</I>&gt;<i> 
</I>&gt;<i>     default:
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(Config.onoff.prefer_direct)
</I>&gt;<i>     peerGetSomeDirect(ps);
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(request-&gt;flags.hierarchical&#160;||
</I>&gt;<i>     !Config.onoff.nonhierarchical_direct) {
</I>&gt;<i>     peerGetSomeParent(ps);
</I>&gt;<i>     peerGetAllParents(ps);
</I>&gt;<i>      &#160; &#160; &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(!Config.onoff.prefer_direct)
</I>&gt;<i>     peerGetSomeDirect(ps);
</I>&gt;<i> 
</I>&gt;<i>     break;
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i>      &#160; &#160; // resolve the possible peers
</I>&gt;<i>     peerSelectDnsPaths(ps);
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /entry/ is /null/&#160;so /peerGetSomeNeighbor/&#160;is never called :
</I>&gt;<i> 
</I>&gt;<i> if&#160;(entry == NULL) {
</I>&gt;<i>  &#160; &#160; &#160; &#160; (void) 0;
</I>&gt;<i>  &#160; &#160; } elseif&#160;(entry-&gt;ping_status&#160;== PING_NONE) {
</I>&gt;<i> peerGetSomeNeighbor(ps);
</I>&gt;<i> 
</I>&gt;<i> if&#160;(entry-&gt;ping_status&#160;== PING_WAITING)
</I>&gt;<i> return;
</I>&gt;<i>  &#160; &#160; } elseif&#160;(entry-&gt;ping_status&#160;== PING_WAITING) {
</I>&gt;<i> peerGetSomeNeighborReplies(ps);
</I>&gt;<i> entry-&gt;ping_status&#160;= PING_DONE;
</I>&gt;<i>  &#160; &#160; }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Because of /tunnelStart/&#160;method :
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     void
</I>&gt;<i>     tunnelStart(ClientHttpRequest * http)
</I>&gt;<i>     {
</I>&gt;<i>     debugs(26, 3, HERE);
</I>&gt;<i>      &#160; &#160; /* Create state structure. */
</I>&gt;<i>      &#160; &#160; TunnelStateData *tunnelState = NULL;
</I>&gt;<i>      &#160; &#160; ErrorState *err = NULL;
</I>&gt;<i>      &#160; &#160; HttpRequest *request = http-&gt;request;
</I>&gt;<i>     char&#160;*url = http-&gt;uri;
</I>&gt;<i> 
</I>&gt;<i>      &#160; &#160; /*
</I>&gt;<i>      &#160; &#160; &#160;* client_addr.isNoAddr() &#160;indicates this is an &quot;internal&quot; request
</I>&gt;<i>      &#160; &#160; &#160;* from peer_digest.c, asn.c, netdb.c, etc and should always
</I>&gt;<i>      &#160; &#160; &#160;* be allowed. &#160;yuck, I know.
</I>&gt;<i>      &#160; &#160; &#160;*/
</I>&gt;<i> 
</I>&gt;<i>     if&#160;(Config.accessList.miss&#160;&amp;&amp; !request-&gt;client_addr.isNoAddr()) {
</I>&gt;<i>      &#160; &#160; &#160; &#160; /*
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160;* Check if this host is allowed to fetch MISSES from us
</I>&gt;<i>     (miss_access)
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160;* default is to allow.
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160;*/
</I>&gt;<i>      &#160; &#160; &#160; &#160; ACLFilledChecklist ch(Config.accessList.miss, request, NULL);
</I>&gt;<i>     ch.al&#160;= http-&gt;al;
</I>&gt;<i>     ch.src_addr&#160;= request-&gt;client_addr;
</I>&gt;<i>     ch.my_addr&#160;= request-&gt;my_addr;
</I>&gt;<i>     ch.syncAle(request, http-&gt;log_uri);
</I>&gt;<i>     if&#160;(ch.fastCheck().denied()) {
</I>&gt;<i>     debugs(26, 4, HERE &lt;&lt; &quot;MISS access forbidden.&quot;);
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; err = newErrorState(ERR_FORWARDING_DENIED,
</I>&gt;<i>     Http::scForbidden, request);
</I>&gt;<i>     http-&gt;al-&gt;http.code&#160;= Http::scForbidden;
</I>&gt;<i>     errorSend(http-&gt;getConn()-&gt;clientConnection, err);
</I>&gt;<i>     return;
</I>&gt;<i>      &#160; &#160; &#160; &#160; }
</I>&gt;<i>      &#160; &#160; }
</I>&gt;<i>     debugs(26, 3, request-&gt;method&#160;&lt;&lt; ' '&#160;&lt;&lt; url &lt;&lt; ' '&#160;&lt;&lt;
</I>&gt;<i>     request-&gt;http_ver);
</I>&gt;<i>      &#160; &#160; ++statCounter.server.all.requests;
</I>&gt;<i>      &#160; &#160; ++statCounter.server.other.requests;
</I>&gt;<i> 
</I>&gt;<i>      &#160; &#160; tunnelState = newTunnelStateData(http);
</I>&gt;<i>     #if&#160;USE_DELAY_POOLS
</I>&gt;<i>      &#160; &#160; //server.setDelayId called from tunnelConnectDone after server
</I>&gt;<i>     side connection established
</I>&gt;<i>     #endif
</I>&gt;<i> 
</I>&gt;<i>     peerSelect(&amp;(tunnelState-&gt;serverDestinations), request, http-&gt;al,
</I>&gt;<i>     NULL,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;tunnelPeerSelectComplete,
</I>&gt;<i>      &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;tunnelState);
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Any ideas ?
</I>&gt;<i> 
</I>&gt;<i> Regards,
</I>&gt;<i> Th&#233;o BARRAGU&#201;
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025254.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
	<LI>Next message (by thread): <A HREF="025260.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25255">[ date ]</a>
              <a href="thread.html#25255">[ thread ]</a>
              <a href="subject.html#25255">[ subject ]</a>
              <a href="author.html#25255">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
