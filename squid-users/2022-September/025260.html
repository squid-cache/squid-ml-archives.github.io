<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Use ICP RTT with HTTPS request
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Use%20ICP%20RTT%20with%20HTTPS%20request&In-Reply-To=%3CPAYP264MB4127A3E55A31C4D5305CCFCAA3559%40PAYP264MB4127.FRAP264.PROD.OUTLOOK.COM%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025255.html">
   <LINK REL="Next"  HREF="025266.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Use ICP RTT with HTTPS request</H1>
    <B>Th&#233;o BARRAGUE</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Use%20ICP%20RTT%20with%20HTTPS%20request&In-Reply-To=%3CPAYP264MB4127A3E55A31C4D5305CCFCAA3559%40PAYP264MB4127.FRAP264.PROD.OUTLOOK.COM%3E"
       TITLE="[squid-users] Use ICP RTT with HTTPS request">Theo.BARRAGUE.ext at boursorama.fr
       </A><BR>
    <I>Tue Sep 27 11:38:22 UTC 2022</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025255.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
        <LI>Next message (by thread): <A HREF="025266.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25260">[ date ]</a>
              <a href="thread.html#25260">[ thread ]</a>
              <a href="subject.html#25260">[ subject ]</a>
              <a href="author.html#25260">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I will take a look, thank's for help &#128578;

Regards,
Th&#233;o BARRAGU&#201;

________________________________
From: Alex Rousskov &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt;
Sent: Monday, September 26, 2022 3:25 PM
To: Th&#233;o BARRAGUE &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">Theo.BARRAGUE.ext at boursorama.fr</A>&gt;; <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A> &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>&gt;
Cc: Olivier HANESSE &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">Olivier.HANESSE at boursorama.fr</A>&gt;
Subject: Re: [squid-users] Use ICP RTT with HTTPS request

On 9/26/22 05:51, Th&#233;o BARRAGUE wrote:

&gt;<i>  entry is null so peerGetSomeNeighbor is never called
</I>
I did not check all the details, but it looks like Squid ICMP code
(ab)uses StoreEntry-linked metadata. Basic CONNECT tunnels lack
StoreEntry because they are not reading/writing data from/to Store. The
combination is essentially a Squid bug -- basic CONNECT tunnels cannot
use ICMP features.

Most likely, the correct long-term solution here is to remove StoreEntry
use from ICMP code -- I bet that code does not have a genuine need for
Store access and should store its essential metadata elsewhere. That
proper solution will require non-trivial development. For a possibly
simpler workaround, one could consider creating a temporary StoreEntry
object for ICMP use (instead of disabling ICMP for entry-less use cases).

<A HREF="https://wiki.squid-cache.org/SquidFaq/AboutSquid#How_to_add_a_new_Squid_feature.2C_enhance.2C_of_fix_something.3F">https://wiki.squid-cache.org/SquidFaq/AboutSquid#How_to_add_a_new_Squid_feature.2C_enhance.2C_of_fix_something.3F</A>


HTH,

Alex.

&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(163) peerSelect: CONNECT
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(472) peerSelectFoo:
</I>&gt;<i>     CONNECT api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(485) peerSelectFoo:
</I>&gt;<i>     peerSelectFoo: direct = DIRECT_UNKNOWN (never_direct to be checked)
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x5653abfc4b68 checking slow rules
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896' found
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked: all = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     never_direct#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     never_direct = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x5653abfc4b68 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(163) checkCallback:
</I>&gt;<i>     ACLChecklist::checkCallback: 0x5653abfc4b68 answer=ALLOWED
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(195)
</I>&gt;<i>     peerCheckNeverDirectDone: peerCheckNeverDirectDone: ALLOWED
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(201)
</I>&gt;<i>     peerCheckNeverDirectDone: direct = DIRECT_NO (never_direct allow)
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(472) peerSelectFoo:
</I>&gt;<i>     CONNECT api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(712)
</I>&gt;<i>     peerGetSomeParent: CONNECT api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.381| 15,3| neighbors.cc(332)
</I>&gt;<i>     getRoundRobinParent: returning NULL
</I>&gt;<i>     2022/09/26 09:07:52.381| 15,3| neighbors.cc(382)
</I>&gt;<i>     getWeightedRoundRobinParent: getWeightedRoundRobinParent: returning NULL
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x7ffd6220f030 checking fast rules
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896' found
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked: all = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02 = 1
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x7ffd6220f030 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.381| 15,3| neighbors.cc(294) getFirstUpParent:
</I>&gt;<i>     getFirstUpParent: returning 10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.381| 44,3| peer_select.cc(978) peerAddFwdServer:
</I>&gt;<i>     adding FIRSTUP_PARENT/10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x7ffd6220f0d0 checking fast rules
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896' found
</I>&gt;<i>     2022/09/26 09:07:52.381| 28,3| Acl.cc(151) matches: checked: all = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc02 = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x7ffd6220f0d0 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,3| peer_select.cc(971) peerAddFwdServer:
</I>&gt;<i>     skipping ANY_OLD_PARENT/10.26.8.10; have FIRSTUP_PARENT/10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Checklist.cc(70) preCheck:
</I>&gt;<i>     0x7ffd6220f0d0 checking fast rules
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Ip.cc(538) match: aclIpMatchIp:
</I>&gt;<i>     '10.25.41.21:34896' found
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked: all = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc01#1 = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Acl.cc(151) matches: checked:
</I>&gt;<i>     peer_access squid-2.inf-proxy03-d01.dc01 = 1
</I>&gt;<i>     2022/09/26 09:07:52.382| 28,3| Checklist.cc(63) markFinished:
</I>&gt;<i>     0x7ffd6220f0d0 answer ALLOWED for match
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,3| peer_select.cc(978) peerAddFwdServer:
</I>&gt;<i>     adding ANY_OLD_PARENT/127.0.0.1
</I>&gt;<i>     2022/09/26 09:07:52.382| 15,3| neighbors.cc(472) getDefaultParent:
</I>&gt;<i>     getDefaultParent: returning NULL
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(295)
</I>&gt;<i>     peerSelectDnsPaths: Find IP destination for: api.gouv.fr:443' via
</I>&gt;<i>     10.26.8.10
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(295)
</I>&gt;<i>     peerSelectDnsPaths: Find IP destination for: api.gouv.fr:443' via
</I>&gt;<i>     127.0.0.1
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(316)
</I>&gt;<i>     peerSelectDnsPaths: Found sources for 'api.gouv.fr:443'
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(317)
</I>&gt;<i>     peerSelectDnsPaths: always_direct = DENIED
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(318)
</I>&gt;<i>     peerSelectDnsPaths: never_direct = ALLOWED
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(328)
</I>&gt;<i>     peerSelectDnsPaths: cache_peer = local=0.0.0.0
</I>&gt;<i>     remote=10.26.8.10:3129 flags=1
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(328)
</I>&gt;<i>     peerSelectDnsPaths: cache_peer = local=0.0.0.0 remote=127.0.0.1:3129
</I>&gt;<i>     flags=1
</I>&gt;<i>     2022/09/26 09:07:52.382| 44,2| peer_select.cc(331)
</I>&gt;<i>     peerSelectDnsPaths: timedout = 0
</I>&gt;<i>     2022/09/26 09:07:52.382| 26,3| tunnel.cc(1249)
</I>&gt;<i>     tunnelPeerSelectComplete: paths=2, p[0]={local=0.0.0.0
</I>&gt;<i>     remote=10.26.8.10:3129 flags=1}, serverDest[0]={local=0.0.0.0
</I>&gt;<i>     remote=10.26.8.10:3129 flags=1}
</I>&gt;<i>     2022/09/26 09:07:52.382| 17,3| FwdState.cc(1369)
</I>&gt;<i>     GetMarkingsToServer: from 0.0.0.0 netfilter mark 0
</I>&gt;<i>     2022/09/26 09:07:52.382| 26,3| AsyncCall.cc(25) AsyncCall: The
</I>&gt;<i>     AsyncCall tunnelConnectDone constructed, this=0x5653abf924a0 [call164]
</I>&gt;<i>     2022/09/26 09:07:52.382| 5,3| ConnOpener.cc(43) ConnOpener: will
</I>&gt;<i>     connect to local=0.0.0.0 remote=10.26.8.10:3129 flags=1 with 30 timeout
</I>&gt;<i>     2022/09/26 09:07:52.382| 50,3| comm.cc(350) comm_openex:
</I>&gt;<i>     comm_openex: Attempt open socket for: 0.0.0.0
</I>&gt;<i>     2022/09/26 09:07:52.382| 50,3| comm.cc(393) comm_openex:
</I>&gt;<i>     comm_openex: Opened socket local=0.0.0.0 remote=[::] FD 14 flags=1 :
</I>&gt;<i>     family=2, type=1, protocol=6
</I>&gt;<i>     2022/09/26 09:07:52.382| 51,3| fd.cc(198) fd_open: fd_open() FD 14
</I>&gt;<i>     api.gouv.fr:443
</I>&gt;<i>     2022/09/26 09:07:52.382| 5,3| ConnOpener.cc(291) createFd:
</I>&gt;<i>     local=0.0.0.0 remote=10.26.8.10:3129 flags=1 will timeout in 30
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCall.cc(92) ScheduleCall:
</I>&gt;<i>     ConnOpener.cc(139) will call
</I>&gt;<i>     tunnelConnectDone(local=10.25.8.10:58500 remote=10.26.8.10:3129 FD
</I>&gt;<i>     14 flags=1, data=0x5653abfa3598) [call164]
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCallQueue.cc(55) fireNext:
</I>&gt;<i>     entering tunnelConnectDone(local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, data=0x5653abfa3598)
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCall.cc(37) make: make call
</I>&gt;<i>     tunnelConnectDone [call164]
</I>&gt;<i>     2022/09/26 09:07:52.393| 14,3| Address.cc(382) lookupHostIP: Given
</I>&gt;<i>     Non-IP 'api.gouv.fr': Name or service not known
</I>&gt;<i>     2022/09/26 09:07:52.393| 38,3| net_db.cc(355) netdbSendPing:
</I>&gt;<i>     netdbSendPing: pinging api.gouv.fr
</I>&gt;<i>     2022/09/26 09:07:52.393| 37,2| IcmpSquid.cc(59) SendEcho:  Socket
</I>&gt;<i>     Closed. Aborted send to 10.26.8.10, opcode 3, len 10
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| tunnel.cc(1163)
</I>&gt;<i>     tunnelRelayConnectRequest: local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, tunnelState=0x5653abfa3598
</I>&gt;<i>     2022/09/26 09:07:52.393| 22,3| refresh.cc(648) getMaxAge: getMaxAge:
</I>&gt;<i>     'api.gouv.fr:443'
</I>&gt;<i>     2022/09/26 09:07:52.393| 11,2| tunnel.cc(1177)
</I>&gt;<i>     tunnelRelayConnectRequest: Tunnel Server REQUEST:
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1:
</I>&gt;<i>     ----------
</I>&gt;<i>     CONNECT api.gouv.fr:443 HTTP/1.1
</I>&gt;<i>     User-Agent: curl/7.52.1
</I>&gt;<i>     Host: api.gouv.fr:443
</I>&gt;<i>     X-Forwarded-For: unknown
</I>&gt;<i>     Cache-Control: max-age=259200
</I>&gt;<i>     Connection: close
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     ----------
</I>&gt;<i>     2022/09/26 09:07:52.393| 5,3| comm.cc(559) commSetConnTimeout:
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1 timeout 900
</I>&gt;<i>     2022/09/26 09:07:52.393| 5,3| comm.cc(559) commSetConnTimeout:
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1 timeout 900
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| AsyncCallQueue.cc(57) fireNext:
</I>&gt;<i>     leaving tunnelConnectDone(local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, data=0x5653abfa3598)
</I>&gt;<i>     2022/09/26 09:07:52.393| 5,3| IoCallback.cc(116) finish: called for
</I>&gt;<i>     local=10.25.8.10:58500 remote=10.26.8.10:3129 FD 14 flags=1 (0, 0)
</I>&gt;<i>     2022/09/26 09:07:52.393| 26,3| tunnel.cc(929)
</I>&gt;<i>     tunnelConnectReqWriteDone: local=10.25.8.10:58500
</I>&gt;<i>     remote=10.26.8.10:3129 FD 14 flags=1, flag=0
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It seems /peerGetSomeParent/ is called and this method never issue an ICP :
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     staticvoid
</I>&gt;<i>     peerGetSomeParent(ps_state * ps)
</I>&gt;<i>     {
</I>&gt;<i>          CachePeer *p;
</I>&gt;<i>          HttpRequest *request = ps-&gt;request;
</I>&gt;<i>          hier_code code = HIER_NONE;
</I>&gt;<i>     debugs(44, 3, request-&gt;method &lt;&lt; ' ' &lt;&lt; request-&gt;url.host());
</I>&gt;<i>     if (ps-&gt;direct == DIRECT_YES)
</I>&gt;<i>     return;
</I>&gt;<i>     if ((p = peerSourceHashSelectParent(request))) {
</I>&gt;<i>              code = SOURCEHASH_PARENT;
</I>&gt;<i>     #if USE_AUTH
</I>&gt;<i>          } elseif ((p = peerUserHashSelectParent(request))) {
</I>&gt;<i>              code = USERHASH_PARENT;
</I>&gt;<i>     #endif
</I>&gt;<i>          } elseif ((p = carpSelectParent(request))) {
</I>&gt;<i>              code = CARP;
</I>&gt;<i>          } elseif ((p = getRoundRobinParent(request))) {
</I>&gt;<i>              code = ROUNDROBIN_PARENT;
</I>&gt;<i>          } elseif ((p = getWeightedRoundRobinParent(request))) {
</I>&gt;<i>              code = ROUNDROBIN_PARENT;
</I>&gt;<i>          } elseif ((p = getFirstUpParent(request))) {
</I>&gt;<i>              code = FIRSTUP_PARENT;
</I>&gt;<i>          } elseif ((p = getDefaultParent(request))) {
</I>&gt;<i>              code = DEFAULT_PARENT;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>     if (code != HIER_NONE) {
</I>&gt;<i>     peerAddFwdServer(ps, p, code);
</I>&gt;<i>          }
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Instead of /peerGetSomeNeighbor/ :
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     /**
</I>&gt;<i>       * peerGetSomeNeighbor
</I>&gt;<i>       *
</I>&gt;<i>       * Selects a neighbor (parent or sibling) based on one of the
</I>&gt;<i>       * following methods:
</I>&gt;<i>       *      Cache Digests
</I>&gt;<i>       *      CARP
</I>&gt;<i>       *      ICMP Netdb RTT estimates
</I>&gt;<i>       *      ICP/HTCP queries
</I>&gt;<i>       */
</I>&gt;<i>     staticvoid
</I>&gt;<i>     peerGetSomeNeighbor(ps_state * ps)
</I>&gt;<i>     {
</I>&gt;<i>          StoreEntry *entry = ps-&gt;entry;
</I>&gt;<i>          HttpRequest *request = ps-&gt;request;
</I>&gt;<i>          CachePeer *p;
</I>&gt;<i>          hier_code code = HIER_NONE;
</I>&gt;<i>     assert(entry-&gt;ping_status == PING_NONE);
</I>&gt;<i>
</I>&gt;<i>     if (ps-&gt;direct == DIRECT_YES) {
</I>&gt;<i>     entry-&gt;ping_status = PING_DONE;
</I>&gt;<i>     return;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>     #if USE_CACHE_DIGESTS
</I>&gt;<i>     if ((p = neighborsDigestSelect(request))) {
</I>&gt;<i>     if (neighborType(p, request-&gt;url) == PEER_PARENT)
</I>&gt;<i>                  code = CD_PARENT_HIT;
</I>&gt;<i>     else
</I>&gt;<i>                  code = CD_SIBLING_HIT;
</I>&gt;<i>          } else
</I>&gt;<i>     #endif
</I>&gt;<i>     if ((p = netdbClosestParent(request))) {
</I>&gt;<i>                  code = CLOSEST_PARENT;
</I>&gt;<i>              } elseif (peerSelectIcpPing(request, ps-&gt;direct, entry)) {
</I>&gt;<i>     debugs(44, 3, &quot;peerSelect: Doing ICP pings&quot;);
</I>&gt;<i>     ps-&gt;ping.start = current_time;
</I>&gt;<i>     ps-&gt;ping.n_sent = neighborsUdpPing(request,
</I>&gt;<i>                                                     entry,
</I>&gt;<i>                                                     peerHandlePingReply,
</I>&gt;<i>                                                     ps,
</I>&gt;<i>
</I>&gt;<i>       &amp;ps-&gt;ping.n_replies_expected,
</I>&gt;<i>                                                     &amp;ps-&gt;ping.timeout);
</I>&gt;<i>
</I>&gt;<i>     if (ps-&gt;ping.n_sent == 0)
</I>&gt;<i>     debugs(44, DBG_CRITICAL, &quot;WARNING: neighborsUdpPing returned 0&quot;);
</I>&gt;<i>     debugs(44, 3, &quot;peerSelect: &quot; &lt;&lt; ps-&gt;ping.n_replies_expected &lt;&lt;
</I>&gt;<i>     &quot; ICP replies expected, RTT &quot; &lt;&lt; ps-&gt;ping.timeout &lt;&lt;
</I>&gt;<i>     &quot; msec&quot;);
</I>&gt;<i>
</I>&gt;<i>     if (ps-&gt;ping.n_replies_expected &gt; 0) {
</I>&gt;<i>     entry-&gt;ping_status = PING_WAITING;
</I>&gt;<i>     eventAdd(&quot;peerPingTimeout&quot;,
</I>&gt;<i>                               peerPingTimeout,
</I>&gt;<i>                               ps,
</I>&gt;<i>     0.001 * ps-&gt;ping.timeout,
</I>&gt;<i>     0);
</I>&gt;<i>     return;
</I>&gt;<i>                  }
</I>&gt;<i>              }
</I>&gt;<i>
</I>&gt;<i>     if (code != HIER_NONE) {
</I>&gt;<i>     assert(p);
</I>&gt;<i>     peerAddFwdServer(ps, p, code);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>     entry-&gt;ping_status = PING_DONE;
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> These functions are called from /peerSelectFoo/ :
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     staticvoid
</I>&gt;<i>     peerSelectFoo(ps_state * ps)
</I>&gt;<i>     {
</I>&gt;<i>     if (!cbdataReferenceValid(ps-&gt;callback_data)) {
</I>&gt;<i>     debugs(44, 3, &quot;Aborting peer selection. Parent Job went away.&quot;);
</I>&gt;<i>     delete ps;
</I>&gt;<i>     return;
</I>&gt;<i>          }
</I>&gt;<i>          StoreEntry *entry = ps-&gt;entry;
</I>&gt;<i>          HttpRequest *request = ps-&gt;request;
</I>&gt;<i>     debugs(44, 3, request-&gt;method &lt;&lt; ' ' &lt;&lt; request-&gt;url.host());
</I>&gt;<i>          /** If we don't know whether DIRECT is permitted ... */
</I>&gt;<i>     if (ps-&gt;direct == DIRECT_UNKNOWN) {
</I>&gt;<i>     if (ps-&gt;always_direct == ACCESS_DUNNO) {
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (always_direct to be checked)&quot;);
</I>&gt;<i>                  /** check always_direct; */
</I>&gt;<i>                  ACLFilledChecklist *ch =
</I>&gt;<i>     newACLFilledChecklist(Config.accessList.AlwaysDirect, request, NULL);
</I>&gt;<i>     ch-&gt;al = ps-&gt;al;
</I>&gt;<i>     ps-&gt;acl_checklist = ch;
</I>&gt;<i>     ps-&gt;acl_checklist-&gt;nonBlockingCheck(peerCheckAlwaysDirectDone, ps);
</I>&gt;<i>     return;
</I>&gt;<i>              } elseif (ps-&gt;never_direct == ACCESS_DUNNO) {
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (never_direct to be checked)&quot;);
</I>&gt;<i>                  /** check never_direct; */
</I>&gt;<i>                  ACLFilledChecklist *ch =
</I>&gt;<i>     newACLFilledChecklist(Config.accessList.NeverDirect, request, NULL);
</I>&gt;<i>     ch-&gt;al = ps-&gt;al;
</I>&gt;<i>     ps-&gt;acl_checklist = ch;
</I>&gt;<i>     ps-&gt;acl_checklist-&gt;nonBlockingCheck(peerCheckNeverDirectDone, ps);
</I>&gt;<i>     return;
</I>&gt;<i>              } elseif (request-&gt;flags.noDirect) {
</I>&gt;<i>                  /** if we are accelerating, direct is not an option. */
</I>&gt;<i>     ps-&gt;direct = DIRECT_NO;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (forced non-direct)&quot;);
</I>&gt;<i>              } elseif (request-&gt;flags.loopDetected) {
</I>&gt;<i>                  /** if we are in a forwarding-loop, direct is not an
</I>&gt;<i>     option. */
</I>&gt;<i>     ps-&gt;direct = DIRECT_YES;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (forwarding loop detected)&quot;);
</I>&gt;<i>              } elseif (peerCheckNetdbDirect(ps)) {
</I>&gt;<i>     ps-&gt;direct = DIRECT_YES;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (checkNetdbDirect)&quot;);
</I>&gt;<i>              } else {
</I>&gt;<i>     ps-&gt;direct = DIRECT_MAYBE;
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct] &lt;&lt;
</I>&gt;<i>     &quot; (default)&quot;);
</I>&gt;<i>              }
</I>&gt;<i>
</I>&gt;<i>     debugs(44, 3, &quot;peerSelectFoo: direct = &quot; &lt;&lt; DirectStr[ps-&gt;direct]);
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>     if (!entry || entry-&gt;ping_status == PING_NONE)
</I>&gt;<i>     peerSelectPinned(ps);
</I>&gt;<i>     if (entry == NULL) {
</I>&gt;<i>              (void) 0;
</I>&gt;<i>          } elseif (entry-&gt;ping_status == PING_NONE) {
</I>&gt;<i>     peerGetSomeNeighbor(ps);
</I>&gt;<i>
</I>&gt;<i>     if (entry-&gt;ping_status == PING_WAITING)
</I>&gt;<i>     return;
</I>&gt;<i>          } elseif (entry-&gt;ping_status == PING_WAITING) {
</I>&gt;<i>     peerGetSomeNeighborReplies(ps);
</I>&gt;<i>     entry-&gt;ping_status = PING_DONE;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>     switch (ps-&gt;direct) {
</I>&gt;<i>
</I>&gt;<i>     case DIRECT_YES:
</I>&gt;<i>     peerGetSomeDirect(ps);
</I>&gt;<i>     break;
</I>&gt;<i>
</I>&gt;<i>     case DIRECT_NO:
</I>&gt;<i>     peerGetSomeParent(ps);
</I>&gt;<i>     peerGetAllParents(ps);
</I>&gt;<i>     break;
</I>&gt;<i>
</I>&gt;<i>     default:
</I>&gt;<i>
</I>&gt;<i>     if (Config.onoff.prefer_direct)
</I>&gt;<i>     peerGetSomeDirect(ps);
</I>&gt;<i>
</I>&gt;<i>     if (request-&gt;flags.hierarchical ||
</I>&gt;<i>     !Config.onoff.nonhierarchical_direct) {
</I>&gt;<i>     peerGetSomeParent(ps);
</I>&gt;<i>     peerGetAllParents(ps);
</I>&gt;<i>              }
</I>&gt;<i>
</I>&gt;<i>     if (!Config.onoff.prefer_direct)
</I>&gt;<i>     peerGetSomeDirect(ps);
</I>&gt;<i>
</I>&gt;<i>     break;
</I>&gt;<i>          }
</I>&gt;<i>
</I>&gt;<i>          // resolve the possible peers
</I>&gt;<i>     peerSelectDnsPaths(ps);
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /entry/ is /null/ so /peerGetSomeNeighbor/ is never called :
</I>&gt;<i>
</I>&gt;<i> if (entry == NULL) {
</I>&gt;<i>          (void) 0;
</I>&gt;<i>      } elseif (entry-&gt;ping_status == PING_NONE) {
</I>&gt;<i> peerGetSomeNeighbor(ps);
</I>&gt;<i>
</I>&gt;<i> if (entry-&gt;ping_status == PING_WAITING)
</I>&gt;<i> return;
</I>&gt;<i>      } elseif (entry-&gt;ping_status == PING_WAITING) {
</I>&gt;<i> peerGetSomeNeighborReplies(ps);
</I>&gt;<i> entry-&gt;ping_status = PING_DONE;
</I>&gt;<i>      }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Because of /tunnelStart/ method :
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     void
</I>&gt;<i>     tunnelStart(ClientHttpRequest * http)
</I>&gt;<i>     {
</I>&gt;<i>     debugs(26, 3, HERE);
</I>&gt;<i>          /* Create state structure. */
</I>&gt;<i>          TunnelStateData *tunnelState = NULL;
</I>&gt;<i>          ErrorState *err = NULL;
</I>&gt;<i>          HttpRequest *request = http-&gt;request;
</I>&gt;<i>     char *url = http-&gt;uri;
</I>&gt;<i>
</I>&gt;<i>          /*
</I>&gt;<i>           * client_addr.isNoAddr()  indicates this is an &quot;internal&quot; request
</I>&gt;<i>           * from peer_digest.c, asn.c, netdb.c, etc and should always
</I>&gt;<i>           * be allowed.  yuck, I know.
</I>&gt;<i>           */
</I>&gt;<i>
</I>&gt;<i>     if (Config.accessList.miss &amp;&amp; !request-&gt;client_addr.isNoAddr()) {
</I>&gt;<i>              /*
</I>&gt;<i>               * Check if this host is allowed to fetch MISSES from us
</I>&gt;<i>     (miss_access)
</I>&gt;<i>               * default is to allow.
</I>&gt;<i>               */
</I>&gt;<i>              ACLFilledChecklist ch(Config.accessList.miss, request, NULL);
</I>&gt;<i>     ch.al = http-&gt;al;
</I>&gt;<i>     ch.src_addr = request-&gt;client_addr;
</I>&gt;<i>     ch.my_addr = request-&gt;my_addr;
</I>&gt;<i>     ch.syncAle(request, http-&gt;log_uri);
</I>&gt;<i>     if (ch.fastCheck().denied()) {
</I>&gt;<i>     debugs(26, 4, HERE &lt;&lt; &quot;MISS access forbidden.&quot;);
</I>&gt;<i>                  err = newErrorState(ERR_FORWARDING_DENIED,
</I>&gt;<i>     Http::scForbidden, request);
</I>&gt;<i>     http-&gt;al-&gt;http.code = Http::scForbidden;
</I>&gt;<i>     errorSend(http-&gt;getConn()-&gt;clientConnection, err);
</I>&gt;<i>     return;
</I>&gt;<i>              }
</I>&gt;<i>          }
</I>&gt;<i>     debugs(26, 3, request-&gt;method &lt;&lt; ' ' &lt;&lt; url &lt;&lt; ' ' &lt;&lt;
</I>&gt;<i>     request-&gt;http_ver);
</I>&gt;<i>          ++statCounter.server.all.requests;
</I>&gt;<i>          ++statCounter.server.other.requests;
</I>&gt;<i>
</I>&gt;<i>          tunnelState = newTunnelStateData(http);
</I>&gt;<i>     #if USE_DELAY_POOLS
</I>&gt;<i>          //server.setDelayId called from tunnelConnectDone after server
</I>&gt;<i>     side connection established
</I>&gt;<i>     #endif
</I>&gt;<i>
</I>&gt;<i>     peerSelect(&amp;(tunnelState-&gt;serverDestinations), request, http-&gt;al,
</I>&gt;<i>     NULL,
</I>&gt;<i>                     tunnelPeerSelectComplete,
</I>&gt;<i>                     tunnelState);
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Any ideas ?
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Th&#233;o BARRAGU&#201;
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20220927/fee3ba0f/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20220927/fee3ba0f/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025255.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
	<LI>Next message (by thread): <A HREF="025266.html">[squid-users] Use ICP RTT with HTTPS request
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25260">[ date ]</a>
              <a href="thread.html#25260">[ thread ]</a>
              <a href="subject.html#25260">[ subject ]</a>
              <a href="author.html#25260">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
