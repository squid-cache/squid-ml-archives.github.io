<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] cache_peer_access by dynamic ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20cache_peer_access%20by%20dynamic%20ACL&In-Reply-To=%3C5a11ceaa-c3f4-4a80-3ac4-9df3c8be3c3e%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025784.html">
   <LINK REL="Next"  HREF="025789.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] cache_peer_access by dynamic ACL</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20cache_peer_access%20by%20dynamic%20ACL&In-Reply-To=%3C5a11ceaa-c3f4-4a80-3ac4-9df3c8be3c3e%40measurement-factory.com%3E"
       TITLE="[squid-users] cache_peer_access by dynamic ACL">rousskov at measurement-factory.com
       </A><BR>
    <I>Wed Apr 19 18:39:45 UTC 2023</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025784.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
        <LI>Next message (by thread): <A HREF="025789.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25788">[ date ]</a>
              <a href="thread.html#25788">[ thread ]</a>
              <a href="subject.html#25788">[ subject ]</a>
              <a href="author.html#25788">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 4/19/23 13:30, Alexey&#1103;&#1088; Gruzdov wrote:

&gt;<i> cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1
</I>
&gt;<i> external_acl_type ext_proxy_g1_type %LOGIN %DST /usr/local/bin/g1.py
</I>
&gt;<i> acl&#160;proxy_g1_ext_acl&#160;ext_proxy_g1_type
</I>
OK. I assume that /usr/local/bin/g1.py will only match users that should 
go to cache_peer called peerG1.


&gt;<i> acl&#160;proxy_g1_ext_acl_mark&#160; annotate_transaction proxy=g1
</I>
Please note that the name of this annotate_transaction ACL -- 
&quot;proxy_g1_ext_acl_mark&quot; -- implies a relationship to the external ACL 
named &quot;proxy_g1_ext_acl&quot;, but there is no such relationship. Squid does 
not care about ACL names, but this naming problem may indicate a 
misunderstanding. To follow your naming scheme, this ACL should be 
called something like &quot;proxy_g1_mark_acl&quot; or &quot;mark_for_proxy_g1_acl&quot;.


&gt;<i> acl proxy_peerG1_acl&#160;note proxy g1
</I>
OK. FWIW, a more consistent ACL name would have been 
&quot;proxy_g1_marked_acl&quot; or &quot;marked_for_proxy_g1_acl&quot;. Again, Squid does 
not really care about these names, so use whatever you think is 
consistent/meaningful/etc.


&gt;<i> http_access deny proxy_g1_ext_acl !all
</I>
This line has no (positive) effect. Squid will evaluate the external 
ACL, but since the rule, as a whole, will never match due to &quot;!all&quot;, and 
since the external ACL has no (relevant) side effects, you can just 
delete this line from your configuration.

Needless to say, if you delete this line, then proxy_g1_ext_acl will be 
unused, which should tell you that this configuration is not doing what 
you want. See below for a fix recommendation.


&gt;<i> http_access deny proxy_g1_ext_acl_mark !all
</I>
This line will mark _all_ transactions. You only want to mark 
transactions that also matched proxy_g1_ext_acl. That &quot;b only if a&quot; 
logic is accomplished by using _both_ ACLs in the same rule:

   http_access deny proxy_g1_ext_acl proxy_g1_ext_acl_mark !all

With the above http_access rule (instead of the earlier two), Squid will 
evaluate the external ACL, and, if it matches, Squid will also evaluate 
the annotation-setting ACL. The whole rule will then be rejected due to 
&quot;!all&quot;, but not until it annotates the transaction (if the external ACL 
matches). Again, in this sketch, we are using this rule for its 
annotation side effect only.


&gt;<i> And this works like I need now....
</I>
AFAICT, if the tests indicate that this configuration works, then the 
tests are broken. IMHO, you should fix the tests (while you have a 
broken configuration that can be used to test the tests) before 
proceeding with the configuration fix.


HTH,

Alex.
P.S. Please keep this email thread on squid-users instead of responding 
to me personally.




&gt;<i> &#1089;&#1088;, 19 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 21:01, Alexey&#1103;&#1088; Gruzdov:
</I>&gt;<i> 
</I>&gt;<i>     so, ok&#160; - Lets limit just to one cache peer and one single ACL (just
</I>&gt;<i>     to understand the logic):
</I>&gt;<i> 
</I>&gt;<i>      &#160;cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1
</I>&gt;<i> 
</I>&gt;<i>      &#160;external_acl_type ext_proxy_g1_type %LOGIN %DST
</I>&gt;<i>     /usr/local/bin/g1.py&#160; &#160;(this will answer &quot;OK&quot;&#160; or &quot;ERR&quot;, depends if
</I>&gt;<i>     user consists in DB)
</I>&gt;<i> 
</I>&gt;<i>      &#160;acl&#160;proxy_g1_ext_acl&#160; ext_proxy_g1_type&#160;annotate_transaction
</I>&gt;<i>     proxy=g1&#160; &#160;(If I right understood here is a key point of how to add
</I>&gt;<i>     the tag to transaction related with user)
</I>&gt;<i>      &#160;acl proxy_peerG1_acl&#160;note proxy g1&#160; (here we create the ACL based
</I>&gt;<i>     on the tag and this is fast ACL yet and we should to use it in
</I>&gt;<i>     cache_peer_access)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     http_access deny proxy_g1_ext_acl !all
</I>&gt;<i>     ......&lt;others http access rules&gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     cache_peer_access peerG1 allow proxy_peerG1_acl
</I>&gt;<i>     cache_peer_access peerG1 deny all
</I>&gt;<i> 
</I>&gt;<i>     Is that correct ?
</I>&gt;<i> 
</I>&gt;<i>     &#1074;&#1090;, 18 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 23:44, Alex Rousskov
</I>&gt;<i>     &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>
</I>&gt;<i>     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt;&gt;:
</I>&gt;<i> 
</I>&gt;<i>         On 4/18/23 11:41, Alexey&#1103;&#1088; Gruzdov wrote:
</I>&gt;<i> 
</I>&gt;<i>          &gt; Could you explain me how the annotation transaction works and
</I>&gt;<i>         how it
</I>&gt;<i>          &gt; related to acl that I could to use with cache_peers
</I>&gt;<i> 
</I>&gt;<i>         Transactions have a (possibly empty) set of name=value annotations.
</I>&gt;<i> 
</I>&gt;<i>         During Squid configuration time, Squid parses all ACL
</I>&gt;<i>         declarations in
</I>&gt;<i>         your configuration file. When Squid parses an
</I>&gt;<i>         annotation_transaction ACL
</I>&gt;<i>         declaration, Squid remembers what transaction annotation to add
</I>&gt;<i>         in the
</I>&gt;<i>         future, [every time] when that ACL is evaluated (e.g., used in
</I>&gt;<i>         http_access rule that Squid reaches during transaction processing).
</I>&gt;<i> 
</I>&gt;<i>         When evaluated, an &quot;annotation_transaction&quot; ACL simply adds the
</I>&gt;<i>         previously configured annotation to the current transaction and
</I>&gt;<i>         returns
</I>&gt;<i>         a &quot;yes, this transaction matches&quot; result.
</I>&gt;<i> 
</I>&gt;<i>         When evaluated, a &quot;note&quot; ACL returns a &quot;yes, this transaction
</I>&gt;<i>         matches&quot;
</I>&gt;<i>         result if and only if the current transaction already has the
</I>&gt;<i>         matching
</I>&gt;<i>         annotation. This ACL does not modify the set of transaction
</I>&gt;<i>         annotations.
</I>&gt;<i> 
</I>&gt;<i>         The combination of annotate_transaction and note ACLs allows you to
</I>&gt;<i>         annotate a transaction at one time and check previously set
</I>&gt;<i>         transaction
</I>&gt;<i>         annotations at another time. The timing and meaning of those
</I>&gt;<i>         annotations
</I>&gt;<i>         are up to you.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>          &gt; ok! Lets look to my case example:
</I>&gt;<i> 
</I>&gt;<i>          &gt; cache_peer peerG1.com parent 40001 0 no-query no-digest
</I>&gt;<i>         name=peerG1&#160;round-robin
</I>&gt;<i> 
</I>&gt;<i>          &gt; cache_peer_access&#160; peerG1 allow proxy_peerG1_acl
</I>&gt;<i>          &gt; cache_peer_access&#160; peerG1 allow proxy_all_acl
</I>&gt;<i>          &gt; cache_peer_access&#160; peerG1 deny all
</I>&gt;<i> 
</I>&gt;<i>          &gt; acl proxy_peerG1_acl&#160; proxy_auth&#160; &quot;../users.peerG1.txt&quot;
</I>&gt;<i>          &gt; acl proxy_all_acl&#160; proxy_auth&#160; &quot;../users.all.txt&quot;
</I>&gt;<i> 
</I>&gt;<i>         [ I added the missing &quot;acl &quot; directive to the above ACL
</I>&gt;<i>         declarations and
</I>&gt;<i>         stripped rules for two out of three cache_peers ]
</I>&gt;<i> 
</I>&gt;<i>         As you know, the above cache_peer_access configuration is not
</I>&gt;<i>         supported
</I>&gt;<i>         because it uses &quot;slow&quot; proxy_auth ACLs in cache_peer_access
</I>&gt;<i>         directives
</I>&gt;<i>         that only support &quot;fast&quot; ACLs. It does not matter (to me),
</I>&gt;<i>         whether the
</I>&gt;<i>         above appears to &quot;work&quot; in some environments. YMMV.
</I>&gt;<i> 
</I>&gt;<i>         To fix this problem, we can use http_access rules to essentially
</I>&gt;<i>         remember proxy_auth evaluation results (at http_access
</I>&gt;<i>         evaluation time)
</I>&gt;<i>         as transaction annotations. Here is an untested sketch that
</I>&gt;<i>         omits other
</I>&gt;<i>         (important but irrelevant here) http_access rules and assumes
</I>&gt;<i>         that these
</I>&gt;<i>         sketched http_access rules _are_ evaluated:
</I>&gt;<i> 
</I>&gt;<i>          &#160; &#160;# if proxy_peerG1_acl matches, evaluate mark_for_peerG1
</I>&gt;<i>          &#160; &#160;http_access deny proxy_peerG1_acl mark_for_peerG1 !all
</I>&gt;<i> 
</I>&gt;<i>          &#160; &#160;# if proxy_all_acl matches, evaluate mark_for_all_peers
</I>&gt;<i>          &#160; &#160;http_access deny proxy_all_acl mark_for_all_peers !all
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>         Now we can use those remembered proxy_... acl evaluation results
</I>&gt;<i>         (i.e.
</I>&gt;<i>         we can check for the matching annotations) in cache_peer_access
</I>&gt;<i>         rules:
</I>&gt;<i> 
</I>&gt;<i>          &#160; &#160;cache_peer_access peerG1 allow marked_for_peerG1
</I>&gt;<i>          &#160; &#160;cache_peer_access peerG1 allow marked_for_all_peers
</I>&gt;<i>          &#160; &#160;cache_peer_access peerG1 deny all
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>         where the new ACLs mentioned above are declared along these lines:
</I>&gt;<i> 
</I>&gt;<i>          &#160; &#160;acl mark_for_peerG1 annotate_transaction for_peer_=G1
</I>&gt;<i>          &#160; &#160;acl mark_for_all_peers annotate_transaction for_all_peers_=true
</I>&gt;<i> 
</I>&gt;<i>          &#160; &#160;acl marked_for_peerG1 note for_peer_ G1
</I>&gt;<i>          &#160; &#160;acl marked_for_all_peers note for_all_peers_ true
</I>&gt;<i> 
</I>&gt;<i>         This can probably be simplified further by using for_peer_=ALL
</I>&gt;<i>         instead
</I>&gt;<i>         of for_all_peers_=true annotation, but I wanted to preserve the
</I>&gt;<i>         symmetry
</I>&gt;<i>         with your original configuration.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>          &gt; And these all works like I need, But - once I am changing a
</I>&gt;<i>         list of
</I>&gt;<i>          &gt; users (add or remove) - I need to use &quot;squid -k
</I>&gt;<i>         reconfigure&quot;...... but
</I>&gt;<i>          &gt; of course better to go without this reconfigure
</I>&gt;<i> 
</I>&gt;<i>         One can avoid reconfiguration using an external ACL script that
</I>&gt;<i>         gives
</I>&gt;<i>         Squid the right for_peer_=... annotations (instead of using
</I>&gt;<i>         &quot;constant&quot;
</I>&gt;<i>         or &quot;hard-coded&quot; annotate_transaction ACLs to store the same
</I>&gt;<i>         annotations).
</I>&gt;<i> 
</I>&gt;<i>         However, it may be better to make the above sketch to work
</I>&gt;<i>         _before_ you
</I>&gt;<i>         replace mark_for_peerG1 ACLs/rules with an external
</I>&gt;<i>         mark_for_the_right_peer ACL.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>         HTH,
</I>&gt;<i> 
</I>&gt;<i>         Alex.
</I>&gt;<i>         P.S. This thread continues the discussion started at
</I>&gt;<i>         <A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>
</I>&gt;<i>         &lt;<A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>&gt;
</I>&gt;<i> 
</I>&gt;<i>         _______________________________________________
</I>&gt;<i>         squid-users mailing list
</I>&gt;<i>         <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i>         &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>&gt;
</I>&gt;<i>         <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>&gt;<i>         &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     -- 
</I>&gt;<i>     &#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i>     &#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i>     +79043828661
</I>&gt;<i>     620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075; &#160;2022
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -- 
</I>&gt;<i> &#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i> &#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i> +79043828661
</I>&gt;<i> 620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075; &#160;2022
</I>&gt;<i> 
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025784.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
	<LI>Next message (by thread): <A HREF="025789.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25788">[ date ]</a>
              <a href="thread.html#25788">[ thread ]</a>
              <a href="subject.html#25788">[ subject ]</a>
              <a href="author.html#25788">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
