<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] cache_peer_access by dynamic ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20cache_peer_access%20by%20dynamic%20ACL&In-Reply-To=%3CCAFqyDwBsFU80tc5TsAuG109o9XGuMP7dXZ4rSnvuX4Js6CiHWg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025788.html">
   <LINK REL="Next"  HREF="025790.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] cache_peer_access by dynamic ACL</H1>
    <B>Alexey&#1103;&#1088; Gruzdov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20cache_peer_access%20by%20dynamic%20ACL&In-Reply-To=%3CCAFqyDwBsFU80tc5TsAuG109o9XGuMP7dXZ4rSnvuX4Js6CiHWg%40mail.gmail.com%3E"
       TITLE="[squid-users] cache_peer_access by dynamic ACL">my.shellac at gmail.com
       </A><BR>
    <I>Thu Apr 20 08:23:49 UTC 2023</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025788.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
        <LI>Next message (by thread): <A HREF="025790.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25789">[ date ]</a>
              <a href="thread.html#25789">[ thread ]</a>
              <a href="subject.html#25789">[ subject ]</a>
              <a href="author.html#25789">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thank you!  so ok.

I configured like:

cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1

external_acl_type ext_proxy_g1_type %LOGIN %DST /usr/local/bin/g1.py

acl proxy_g1_ext_mark_acl  ext_proxy_g1_type

acl proxy_g1_ext_marked_acl  annotate_transaction proxy=g1

acl proxy_peerG1_acl note proxy g1

http_access deny proxy_g1_ext_mark_acl  proxy_g1_ext_marked_acl !all   (
looks like this rule making the main magic of all,  )
.....
others http_access rules

And this above works.
BUT
I am worried about why this my external script for ACL  type loads the one
of core of CPU to 100%.....??? ( I used three of workers in config, but I
can see a six process called like my external helper script, looks like
squid runs x2 process for external ACL )


Because if I will put the one more group of users (that must to use another
cache_peer ) - I will need to create one more external script that will
making to check an existed users from an other DB table


&#1089;&#1088;, 19 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 22:39, Alex Rousskov &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>
&gt;:<i>
</I>
&gt;<i> On 4/19/23 13:30, Alexey&#1103;&#1088; Gruzdov wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1
</I>&gt;<i>
</I>&gt;<i> &gt; external_acl_type ext_proxy_g1_type %LOGIN %DST /usr/local/bin/g1.py
</I>&gt;<i>
</I>&gt;<i> &gt; acl proxy_g1_ext_acl ext_proxy_g1_type
</I>&gt;<i>
</I>&gt;<i> OK. I assume that /usr/local/bin/g1.py will only match users that should
</I>&gt;<i> go to cache_peer called peerG1.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; acl proxy_g1_ext_acl_mark  annotate_transaction proxy=g1
</I>&gt;<i>
</I>&gt;<i> Please note that the name of this annotate_transaction ACL --
</I>&gt;<i> &quot;proxy_g1_ext_acl_mark&quot; -- implies a relationship to the external ACL
</I>&gt;<i> named &quot;proxy_g1_ext_acl&quot;, but there is no such relationship. Squid does
</I>&gt;<i> not care about ACL names, but this naming problem may indicate a
</I>&gt;<i> misunderstanding. To follow your naming scheme, this ACL should be
</I>&gt;<i> called something like &quot;proxy_g1_mark_acl&quot; or &quot;mark_for_proxy_g1_acl&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; acl proxy_peerG1_acl note proxy g1
</I>&gt;<i>
</I>&gt;<i> OK. FWIW, a more consistent ACL name would have been
</I>&gt;<i> &quot;proxy_g1_marked_acl&quot; or &quot;marked_for_proxy_g1_acl&quot;. Again, Squid does
</I>&gt;<i> not really care about these names, so use whatever you think is
</I>&gt;<i> consistent/meaningful/etc.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; http_access deny proxy_g1_ext_acl !all
</I>&gt;<i>
</I>&gt;<i> This line has no (positive) effect. Squid will evaluate the external
</I>&gt;<i> ACL, but since the rule, as a whole, will never match due to &quot;!all&quot;, and
</I>&gt;<i> since the external ACL has no (relevant) side effects, you can just
</I>&gt;<i> delete this line from your configuration.
</I>&gt;<i>
</I>&gt;<i> Needless to say, if you delete this line, then proxy_g1_ext_acl will be
</I>&gt;<i> unused, which should tell you that this configuration is not doing what
</I>&gt;<i> you want. See below for a fix recommendation.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; http_access deny proxy_g1_ext_acl_mark !all
</I>&gt;<i>
</I>&gt;<i> This line will mark _all_ transactions. You only want to mark
</I>&gt;<i> transactions that also matched proxy_g1_ext_acl. That &quot;b only if a&quot;
</I>&gt;<i> logic is accomplished by using _both_ ACLs in the same rule:
</I>&gt;<i>
</I>&gt;<i>    http_access deny proxy_g1_ext_acl proxy_g1_ext_acl_mark !all
</I>&gt;<i>
</I>&gt;<i> With the above http_access rule (instead of the earlier two), Squid will
</I>&gt;<i> evaluate the external ACL, and, if it matches, Squid will also evaluate
</I>&gt;<i> the annotation-setting ACL. The whole rule will then be rejected due to
</I>&gt;<i> &quot;!all&quot;, but not until it annotates the transaction (if the external ACL
</I>&gt;<i> matches). Again, in this sketch, we are using this rule for its
</I>&gt;<i> annotation side effect only.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; And this works like I need now....
</I>&gt;<i>
</I>&gt;<i> AFAICT, if the tests indicate that this configuration works, then the
</I>&gt;<i> tests are broken. IMHO, you should fix the tests (while you have a
</I>&gt;<i> broken configuration that can be used to test the tests) before
</I>&gt;<i> proceeding with the configuration fix.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i> P.S. Please keep this email thread on squid-users instead of responding
</I>&gt;<i> to me personally.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; &#1089;&#1088;, 19 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 21:01, Alexey&#1103;&#1088; Gruzdov:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     so, ok  - Lets limit just to one cache peer and one single ACL (just
</I>&gt;<i> &gt;     to understand the logic):
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       external_acl_type ext_proxy_g1_type %LOGIN %DST
</I>&gt;<i> &gt;     /usr/local/bin/g1.py   (this will answer &quot;OK&quot;  or &quot;ERR&quot;, depends if
</I>&gt;<i> &gt;     user consists in DB)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;       acl proxy_g1_ext_acl  ext_proxy_g1_type annotate_transaction
</I>&gt;<i> &gt;     proxy=g1   (If I right understood here is a key point of how to add
</I>&gt;<i> &gt;     the tag to transaction related with user)
</I>&gt;<i> &gt;       acl proxy_peerG1_acl note proxy g1  (here we create the ACL based
</I>&gt;<i> &gt;     on the tag and this is fast ACL yet and we should to use it in
</I>&gt;<i> &gt;     cache_peer_access)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     http_access deny proxy_g1_ext_acl !all
</I>&gt;<i> &gt;     ......&lt;others http access rules&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     cache_peer_access peerG1 allow proxy_peerG1_acl
</I>&gt;<i> &gt;     cache_peer_access peerG1 deny all
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     Is that correct ?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     &#1074;&#1090;, 18 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 23:44, Alex Rousskov
</I>&gt;<i> &gt;     &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>
</I>&gt;<i> &gt;     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt;&gt;:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         On 4/18/23 11:41, Alexey&#1103;&#1088; Gruzdov wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          &gt; Could you explain me how the annotation transaction works and
</I>&gt;<i> &gt;         how it
</I>&gt;<i> &gt;          &gt; related to acl that I could to use with cache_peers
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         Transactions have a (possibly empty) set of name=value
</I>&gt;<i> annotations.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         During Squid configuration time, Squid parses all ACL
</I>&gt;<i> &gt;         declarations in
</I>&gt;<i> &gt;         your configuration file. When Squid parses an
</I>&gt;<i> &gt;         annotation_transaction ACL
</I>&gt;<i> &gt;         declaration, Squid remembers what transaction annotation to add
</I>&gt;<i> &gt;         in the
</I>&gt;<i> &gt;         future, [every time] when that ACL is evaluated (e.g., used in
</I>&gt;<i> &gt;         http_access rule that Squid reaches during transaction
</I>&gt;<i> processing).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         When evaluated, an &quot;annotation_transaction&quot; ACL simply adds the
</I>&gt;<i> &gt;         previously configured annotation to the current transaction and
</I>&gt;<i> &gt;         returns
</I>&gt;<i> &gt;         a &quot;yes, this transaction matches&quot; result.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         When evaluated, a &quot;note&quot; ACL returns a &quot;yes, this transaction
</I>&gt;<i> &gt;         matches&quot;
</I>&gt;<i> &gt;         result if and only if the current transaction already has the
</I>&gt;<i> &gt;         matching
</I>&gt;<i> &gt;         annotation. This ACL does not modify the set of transaction
</I>&gt;<i> &gt;         annotations.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         The combination of annotate_transaction and note ACLs allows you
</I>&gt;<i> to
</I>&gt;<i> &gt;         annotate a transaction at one time and check previously set
</I>&gt;<i> &gt;         transaction
</I>&gt;<i> &gt;         annotations at another time. The timing and meaning of those
</I>&gt;<i> &gt;         annotations
</I>&gt;<i> &gt;         are up to you.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          &gt; ok! Lets look to my case example:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          &gt; cache_peer peerG1.com parent 40001 0 no-query no-digest
</I>&gt;<i> &gt;         name=peerG1 round-robin
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          &gt; cache_peer_access  peerG1 allow proxy_peerG1_acl
</I>&gt;<i> &gt;          &gt; cache_peer_access  peerG1 allow proxy_all_acl
</I>&gt;<i> &gt;          &gt; cache_peer_access  peerG1 deny all
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          &gt; acl proxy_peerG1_acl  proxy_auth  &quot;../users.peerG1.txt&quot;
</I>&gt;<i> &gt;          &gt; acl proxy_all_acl  proxy_auth  &quot;../users.all.txt&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         [ I added the missing &quot;acl &quot; directive to the above ACL
</I>&gt;<i> &gt;         declarations and
</I>&gt;<i> &gt;         stripped rules for two out of three cache_peers ]
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         As you know, the above cache_peer_access configuration is not
</I>&gt;<i> &gt;         supported
</I>&gt;<i> &gt;         because it uses &quot;slow&quot; proxy_auth ACLs in cache_peer_access
</I>&gt;<i> &gt;         directives
</I>&gt;<i> &gt;         that only support &quot;fast&quot; ACLs. It does not matter (to me),
</I>&gt;<i> &gt;         whether the
</I>&gt;<i> &gt;         above appears to &quot;work&quot; in some environments. YMMV.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         To fix this problem, we can use http_access rules to essentially
</I>&gt;<i> &gt;         remember proxy_auth evaluation results (at http_access
</I>&gt;<i> &gt;         evaluation time)
</I>&gt;<i> &gt;         as transaction annotations. Here is an untested sketch that
</I>&gt;<i> &gt;         omits other
</I>&gt;<i> &gt;         (important but irrelevant here) http_access rules and assumes
</I>&gt;<i> &gt;         that these
</I>&gt;<i> &gt;         sketched http_access rules _are_ evaluated:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;             # if proxy_peerG1_acl matches, evaluate mark_for_peerG1
</I>&gt;<i> &gt;             http_access deny proxy_peerG1_acl mark_for_peerG1 !all
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;             # if proxy_all_acl matches, evaluate mark_for_all_peers
</I>&gt;<i> &gt;             http_access deny proxy_all_acl mark_for_all_peers !all
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         Now we can use those remembered proxy_... acl evaluation results
</I>&gt;<i> &gt;         (i.e.
</I>&gt;<i> &gt;         we can check for the matching annotations) in cache_peer_access
</I>&gt;<i> &gt;         rules:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;             cache_peer_access peerG1 allow marked_for_peerG1
</I>&gt;<i> &gt;             cache_peer_access peerG1 allow marked_for_all_peers
</I>&gt;<i> &gt;             cache_peer_access peerG1 deny all
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         where the new ACLs mentioned above are declared along these
</I>&gt;<i> lines:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;             acl mark_for_peerG1 annotate_transaction for_peer_=G1
</I>&gt;<i> &gt;             acl mark_for_all_peers annotate_transaction
</I>&gt;<i> for_all_peers_=true
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;             acl marked_for_peerG1 note for_peer_ G1
</I>&gt;<i> &gt;             acl marked_for_all_peers note for_all_peers_ true
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         This can probably be simplified further by using for_peer_=ALL
</I>&gt;<i> &gt;         instead
</I>&gt;<i> &gt;         of for_all_peers_=true annotation, but I wanted to preserve the
</I>&gt;<i> &gt;         symmetry
</I>&gt;<i> &gt;         with your original configuration.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;          &gt; And these all works like I need, But - once I am changing a
</I>&gt;<i> &gt;         list of
</I>&gt;<i> &gt;          &gt; users (add or remove) - I need to use &quot;squid -k
</I>&gt;<i> &gt;         reconfigure&quot;...... but
</I>&gt;<i> &gt;          &gt; of course better to go without this reconfigure
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         One can avoid reconfiguration using an external ACL script that
</I>&gt;<i> &gt;         gives
</I>&gt;<i> &gt;         Squid the right for_peer_=... annotations (instead of using
</I>&gt;<i> &gt;         &quot;constant&quot;
</I>&gt;<i> &gt;         or &quot;hard-coded&quot; annotate_transaction ACLs to store the same
</I>&gt;<i> &gt;         annotations).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         However, it may be better to make the above sketch to work
</I>&gt;<i> &gt;         _before_ you
</I>&gt;<i> &gt;         replace mark_for_peerG1 ACLs/rules with an external
</I>&gt;<i> &gt;         mark_for_the_right_peer ACL.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         HTH,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         Alex.
</I>&gt;<i> &gt;         P.S. This thread continues the discussion started at
</I>&gt;<i> &gt;         <A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>
</I>&gt;<i> &gt;         &lt;<A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;         _______________________________________________
</I>&gt;<i> &gt;         squid-users mailing list
</I>&gt;<i> &gt;         <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> &gt;         &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>&gt;
</I>&gt;<i> &gt;         <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>&gt;<i> &gt;         &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     --
</I>&gt;<i> &gt;     &#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i> &gt;     &#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i> &gt;     +79043828661
</I>&gt;<i> &gt;     620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075;  2022
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; &#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i> &gt; &#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i> &gt; +79043828661
</I>&gt;<i> &gt; 620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075;  2022
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>
-- 
&#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
&#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
+79043828661
620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075;  2022
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.squid-cache.org/pipermail/squid-users/attachments/20230420/fffacc33/attachment.htm">http://lists.squid-cache.org/pipermail/squid-users/attachments/20230420/fffacc33/attachment.htm</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025788.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
	<LI>Next message (by thread): <A HREF="025790.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25789">[ date ]</a>
              <a href="thread.html#25789">[ thread ]</a>
              <a href="subject.html#25789">[ subject ]</a>
              <a href="author.html#25789">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
