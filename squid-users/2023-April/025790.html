<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] cache_peer_access by dynamic ACL
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20cache_peer_access%20by%20dynamic%20ACL&In-Reply-To=%3C4e3df8c9-52a7-1afd-b3d3-6971cdae75fb%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025789.html">
   <LINK REL="Next"  HREF="025791.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] cache_peer_access by dynamic ACL</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20cache_peer_access%20by%20dynamic%20ACL&In-Reply-To=%3C4e3df8c9-52a7-1afd-b3d3-6971cdae75fb%40measurement-factory.com%3E"
       TITLE="[squid-users] cache_peer_access by dynamic ACL">rousskov at measurement-factory.com
       </A><BR>
    <I>Thu Apr 20 13:21:37 UTC 2023</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025789.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
        <LI>Next message (by thread): <A HREF="025791.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25790">[ date ]</a>
              <a href="thread.html#25790">[ thread ]</a>
              <a href="subject.html#25790">[ subject ]</a>
              <a href="author.html#25790">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 4/20/23 04:23, Alexey&#1103;&#1088; Gruzdov wrote:

&gt;<i> cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1
</I>&gt;<i> 
</I>&gt;<i> external_acl_type ext_proxy_g1_type %LOGIN %DST /usr/local/bin/g1.py
</I>&gt;<i> 
</I>&gt;<i> acl&#160;proxy_g1_ext_mark_acl&#160; ext_proxy_g1_type
</I>&gt;<i> 
</I>&gt;<i> acl&#160;proxy_g1_ext_marked_acl&#160; annotate_transaction proxy=g1
</I>&gt;<i> 
</I>&gt;<i> acl proxy_peerG1_acl&#160;note proxy g1
</I>&gt;<i> 
</I>&gt;<i> http_access deny proxy_g1_ext_mark_acl&#160;&#160;proxy_g1_ext_marked_acl&#160;!all
</I>&gt;<i> .....
</I>&gt;<i> others http_access rules
</I>&gt;<i> 
</I>&gt;<i> And this above works.
</I>
Glad to hear that. ( If others are going to use the above as a guiding 
example, I would recommend naming these ACLs very differently, but that 
is not important to Squid. )


&gt;<i> BUT
</I>&gt;<i> I am worried&#160;about why this my external script for ACL&#160; type loads the 
</I>&gt;<i> one of core of CPU to 100%.....??? 
</I>
External ACL caching aside, the script will be contacted once for every 
Squid transaction. Does your script CPU usage go down to zero when there 
is no traffic? If not, then there is a bug in the script itself.

If you use the script from the command line, without Squid, does it 
consume a lot of CPU and/or take a lot of time per fake query? You can 
adjust the script to log the real query (when the script is used by 
Squid), so that you can easily replicate that query when running the 
script without Squid...

The cache key in your case is (the expansion of) &quot;%LOGIN %DST&quot;. It is 
enabled by default IIRC. Look for &quot;cache&quot; related options at
<A HREF="http://www.squid-cache.org/Doc/config/external_acl_type/">http://www.squid-cache.org/Doc/config/external_acl_type/</A>


&gt;<i> ( I used three of workers in config, 
</I>&gt;<i> but I can see a six process called like my external helper script, looks 
</I>&gt;<i> like squid runs x2 process for external ACL )
</I>
See external_acl_type children-* options:
<A HREF="http://www.squid-cache.org/Doc/config/external_acl_type/">http://www.squid-cache.org/Doc/config/external_acl_type/</A>

In most environments, I recommend setting all three of them to the same 
value. Please note that these options are not SMP-aware (yet), so Squid 
will _not_ divide their values by the number of workers and give each 
worker as many children as you state in squid.conf.


&gt;<i> Because if I will put the one more group of users (that must to use 
</I>&gt;<i> another cache_peer ) - I will need to create one more external script 
</I>&gt;<i> that will making to check an existed users from an other&#160;DB table
</I>
Once you get the basic setup above working for one group to your 
satisfaction, I would recommend migrating from (one script and one 
matching annotate_transaction ACL) per group to a single script for all 
groups. That single external ACL script will send the right 
annotation(s) to Squid.


HTH,

Alex.


&gt;<i> &#1089;&#1088;, 19 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 22:39, Alex Rousskov:
</I>&gt;<i> 
</I>&gt;<i>     On 4/19/23 13:30, Alexey&#1103;&#1088; Gruzdov wrote:
</I>&gt;<i> 
</I>&gt;<i>      &gt; cache_peer peerG1.com parent 40001 0 no-query no-digest name=peerG1
</I>&gt;<i> 
</I>&gt;<i>      &gt; external_acl_type ext_proxy_g1_type %LOGIN %DST /usr/local/bin/g1.py
</I>&gt;<i> 
</I>&gt;<i>      &gt; acl&#160;proxy_g1_ext_acl&#160;ext_proxy_g1_type
</I>&gt;<i> 
</I>&gt;<i>     OK. I assume that /usr/local/bin/g1.py will only match users that
</I>&gt;<i>     should
</I>&gt;<i>     go to cache_peer called peerG1.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      &gt; acl&#160;proxy_g1_ext_acl_mark&#160; annotate_transaction proxy=g1
</I>&gt;<i> 
</I>&gt;<i>     Please note that the name of this annotate_transaction ACL --
</I>&gt;<i>     &quot;proxy_g1_ext_acl_mark&quot; -- implies a relationship to the external ACL
</I>&gt;<i>     named &quot;proxy_g1_ext_acl&quot;, but there is no such relationship. Squid does
</I>&gt;<i>     not care about ACL names, but this naming problem may indicate a
</I>&gt;<i>     misunderstanding. To follow your naming scheme, this ACL should be
</I>&gt;<i>     called something like &quot;proxy_g1_mark_acl&quot; or &quot;mark_for_proxy_g1_acl&quot;.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      &gt; acl proxy_peerG1_acl&#160;note proxy g1
</I>&gt;<i> 
</I>&gt;<i>     OK. FWIW, a more consistent ACL name would have been
</I>&gt;<i>     &quot;proxy_g1_marked_acl&quot; or &quot;marked_for_proxy_g1_acl&quot;. Again, Squid does
</I>&gt;<i>     not really care about these names, so use whatever you think is
</I>&gt;<i>     consistent/meaningful/etc.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      &gt; http_access deny proxy_g1_ext_acl !all
</I>&gt;<i> 
</I>&gt;<i>     This line has no (positive) effect. Squid will evaluate the external
</I>&gt;<i>     ACL, but since the rule, as a whole, will never match due to &quot;!all&quot;,
</I>&gt;<i>     and
</I>&gt;<i>     since the external ACL has no (relevant) side effects, you can just
</I>&gt;<i>     delete this line from your configuration.
</I>&gt;<i> 
</I>&gt;<i>     Needless to say, if you delete this line, then proxy_g1_ext_acl will be
</I>&gt;<i>     unused, which should tell you that this configuration is not doing what
</I>&gt;<i>     you want. See below for a fix recommendation.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      &gt; http_access deny proxy_g1_ext_acl_mark !all
</I>&gt;<i> 
</I>&gt;<i>     This line will mark _all_ transactions. You only want to mark
</I>&gt;<i>     transactions that also matched proxy_g1_ext_acl. That &quot;b only if a&quot;
</I>&gt;<i>     logic is accomplished by using _both_ ACLs in the same rule:
</I>&gt;<i> 
</I>&gt;<i>      &#160; &#160;http_access deny proxy_g1_ext_acl proxy_g1_ext_acl_mark !all
</I>&gt;<i> 
</I>&gt;<i>     With the above http_access rule (instead of the earlier two), Squid
</I>&gt;<i>     will
</I>&gt;<i>     evaluate the external ACL, and, if it matches, Squid will also evaluate
</I>&gt;<i>     the annotation-setting ACL. The whole rule will then be rejected due to
</I>&gt;<i>     &quot;!all&quot;, but not until it annotates the transaction (if the external ACL
</I>&gt;<i>     matches). Again, in this sketch, we are using this rule for its
</I>&gt;<i>     annotation side effect only.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      &gt; And this works like I need now....
</I>&gt;<i> 
</I>&gt;<i>     AFAICT, if the tests indicate that this configuration works, then the
</I>&gt;<i>     tests are broken. IMHO, you should fix the tests (while you have a
</I>&gt;<i>     broken configuration that can be used to test the tests) before
</I>&gt;<i>     proceeding with the configuration fix.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>     HTH,
</I>&gt;<i> 
</I>&gt;<i>     Alex.
</I>&gt;<i>     P.S. Please keep this email thread on squid-users instead of responding
</I>&gt;<i>     to me personally.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>      &gt; &#1089;&#1088;, 19 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 21:01, Alexey&#1103;&#1088; Gruzdov:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;so, ok&#160; - Lets limit just to one cache peer and one single
</I>&gt;<i>     ACL (just
</I>&gt;<i>      &gt;&#160; &#160; &#160;to understand the logic):
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160;cache_peer peerG1.com parent 40001 0 no-query no-digest
</I>&gt;<i>     name=peerG1
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160;external_acl_type ext_proxy_g1_type %LOGIN %DST
</I>&gt;<i>      &gt;&#160; &#160; &#160;/usr/local/bin/g1.py&#160; &#160;(this will answer &quot;OK&quot;&#160; or &quot;ERR&quot;,
</I>&gt;<i>     depends if
</I>&gt;<i>      &gt;&#160; &#160; &#160;user consists in DB)
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160;acl&#160;proxy_g1_ext_acl&#160; ext_proxy_g1_type&#160;annotate_transaction
</I>&gt;<i>      &gt;&#160; &#160; &#160;proxy=g1&#160; &#160;(If I right understood here is a key point of how
</I>&gt;<i>     to add
</I>&gt;<i>      &gt;&#160; &#160; &#160;the tag to transaction related with user)
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160;acl proxy_peerG1_acl&#160;note proxy g1&#160; (here we create the ACL
</I>&gt;<i>     based
</I>&gt;<i>      &gt;&#160; &#160; &#160;on the tag and this is fast ACL yet and we should to use it in
</I>&gt;<i>      &gt;&#160; &#160; &#160;cache_peer_access)
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;http_access deny proxy_g1_ext_acl !all
</I>&gt;<i>      &gt;&#160; &#160; &#160;......&lt;others http access rules&gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;cache_peer_access peerG1 allow proxy_peerG1_acl
</I>&gt;<i>      &gt;&#160; &#160; &#160;cache_peer_access peerG1 deny all
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;Is that correct ?
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;&#1074;&#1090;, 18 &#1072;&#1087;&#1088;. 2023&#8239;&#1075;. &#1074; 23:44, Alex Rousskov
</I>&gt;<i>      &gt;&#160; &#160; &#160;&lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>
</I>&gt;<i>     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;&lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>
</I>&gt;<i>     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt;&gt;&gt;:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;On 4/18/23 11:41, Alexey&#1103;&#1088; Gruzdov wrote:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; Could you explain me how the annotation transaction
</I>&gt;<i>     works and
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;how it
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; related to acl that I could to use with cache_peers
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;Transactions have a (possibly empty) set of name=value
</I>&gt;<i>     annotations.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;During Squid configuration time, Squid parses all ACL
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;declarations in
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;your configuration file. When Squid parses an
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotation_transaction ACL
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;declaration, Squid remembers what transaction annotation
</I>&gt;<i>     to add
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;in the
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;future, [every time] when that ACL is evaluated (e.g.,
</I>&gt;<i>     used in
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;http_access rule that Squid reaches during transaction
</I>&gt;<i>     processing).
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;When evaluated, an &quot;annotation_transaction&quot; ACL simply
</I>&gt;<i>     adds the
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;previously configured annotation to the current
</I>&gt;<i>     transaction and
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;returns
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;a &quot;yes, this transaction matches&quot; result.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;When evaluated, a &quot;note&quot; ACL returns a &quot;yes, this transaction
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;matches&quot;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;result if and only if the current transaction already has the
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;matching
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotation. This ACL does not modify the set of transaction
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotations.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;The combination of annotate_transaction and note ACLs
</I>&gt;<i>     allows you to
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotate a transaction at one time and check previously set
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;transaction
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotations at another time. The timing and meaning of those
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotations
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;are up to you.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; ok! Lets look to my case example:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; cache_peer peerG1.com parent 40001 0 no-query no-digest
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;name=peerG1&#160;round-robin
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; cache_peer_access&#160; peerG1 allow proxy_peerG1_acl
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; cache_peer_access&#160; peerG1 allow proxy_all_acl
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; cache_peer_access&#160; peerG1 deny all
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; acl proxy_peerG1_acl&#160; proxy_auth&#160; &quot;../users.peerG1.txt&quot;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; acl proxy_all_acl&#160; proxy_auth&#160; &quot;../users.all.txt&quot;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;[ I added the missing &quot;acl &quot; directive to the above ACL
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;declarations and
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;stripped rules for two out of three cache_peers ]
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;As you know, the above cache_peer_access configuration is not
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;supported
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;because it uses &quot;slow&quot; proxy_auth ACLs in cache_peer_access
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;directives
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;that only support &quot;fast&quot; ACLs. It does not matter (to me),
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;whether the
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;above appears to &quot;work&quot; in some environments. YMMV.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;To fix this problem, we can use http_access rules to
</I>&gt;<i>     essentially
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;remember proxy_auth evaluation results (at http_access
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;evaluation time)
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;as transaction annotations. Here is an untested sketch that
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;omits other
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;(important but irrelevant here) http_access rules and assumes
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;that these
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;sketched http_access rules _are_ evaluated:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;# if proxy_peerG1_acl matches, evaluate mark_for_peerG1
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;http_access deny proxy_peerG1_acl mark_for_peerG1 !all
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;# if proxy_all_acl matches, evaluate mark_for_all_peers
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;http_access deny proxy_all_acl mark_for_all_peers !all
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;Now we can use those remembered proxy_... acl evaluation
</I>&gt;<i>     results
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;(i.e.
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;we can check for the matching annotations) in
</I>&gt;<i>     cache_peer_access
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;rules:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;cache_peer_access peerG1 allow marked_for_peerG1
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;cache_peer_access peerG1 allow marked_for_all_peers
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;cache_peer_access peerG1 deny all
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;where the new ACLs mentioned above are declared along
</I>&gt;<i>     these lines:
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;acl mark_for_peerG1 annotate_transaction for_peer_=G1
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;acl mark_for_all_peers annotate_transaction
</I>&gt;<i>     for_all_peers_=true
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;acl marked_for_peerG1 note for_peer_ G1
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &#160; &#160;acl marked_for_all_peers note for_all_peers_ true
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;This can probably be simplified further by using
</I>&gt;<i>     for_peer_=ALL
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;instead
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;of for_all_peers_=true annotation, but I wanted to
</I>&gt;<i>     preserve the
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;symmetry
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;with your original configuration.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; And these all works like I need, But - once I am
</I>&gt;<i>     changing a
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;list of
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; users (add or remove) - I need to use &quot;squid -k
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;reconfigure&quot;...... but
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160; &gt; of course better to go without this reconfigure
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;One can avoid reconfiguration using an external ACL
</I>&gt;<i>     script that
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;gives
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;Squid the right for_peer_=... annotations (instead of using
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;&quot;constant&quot;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;or &quot;hard-coded&quot; annotate_transaction ACLs to store the same
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;annotations).
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;However, it may be better to make the above sketch to work
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;_before_ you
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;replace mark_for_peerG1 ACLs/rules with an external
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;mark_for_the_right_peer ACL.
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;HTH,
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;Alex.
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;P.S. This thread continues the discussion started at
</I>&gt;<i>      &gt; <A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>
</I>&gt;<i>     &lt;<A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>&gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;&lt;<A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>
</I>&gt;<i>     &lt;<A HREF="https://bugs.squid-cache.org/show_bug.cgi?id=5268">https://bugs.squid-cache.org/show_bug.cgi?id=5268</A>&gt;&gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;_______________________________________________
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;squid-users mailing list
</I>&gt;<i>      &gt; <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i>     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>&gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;&lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i>     &lt;mailto:<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>&gt;&gt;
</I>&gt;<i>      &gt; <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>&gt;<i>     &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>&gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160; &#160; &#160;&lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>&gt;<i>     &lt;<A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>&gt;&gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;&#160; &#160; &#160;--
</I>&gt;<i>      &gt;&#160; &#160; &#160;&#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i>      &gt;&#160; &#160; &#160;&#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i>      &gt;&#160; &#160; &#160;+79043828661
</I>&gt;<i>      &gt;&#160; &#160; &#160;620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075; &#160;2022
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt;
</I>&gt;<i>      &gt; --
</I>&gt;<i>      &gt; &#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i>      &gt; &#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i>      &gt; +79043828661
</I>&gt;<i>      &gt; 620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075; &#160;2022
</I>&gt;<i>      &gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> -- 
</I>&gt;<i> &#1057; &#1091;&#1074;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; &#1082; &#1042;&#1072;&#1084;
</I>&gt;<i> &#1040;&#1083;&#1077;&#1082;&#1089;&#1077;&#1081;
</I>&gt;<i> +79043828661
</I>&gt;<i> 620000 &#1075;.&#1045;&#1082;&#1072;&#1090;&#1077;&#1088;&#1080;&#1085;&#1073;&#1091;&#1088;&#1075; &#160;2022
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025789.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
	<LI>Next message (by thread): <A HREF="025791.html">[squid-users] cache_peer_access by dynamic ACL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25790">[ date ]</a>
              <a href="thread.html#25790">[ thread ]</a>
              <a href="subject.html#25790">[ subject ]</a>
              <a href="author.html#25790">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
