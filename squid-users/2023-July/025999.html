<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Stack overflow with large IP lists
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Stack%20overflow%20with%20large%20IP%20lists&In-Reply-To=%3C3d2c22de-b39c-8b46-9163-5bbf52fb3cc1%40web.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025994.html">
   <LINK REL="Next"  HREF="026000.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Stack overflow with large IP lists</H1>
    <B>magri at web.de</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Stack%20overflow%20with%20large%20IP%20lists&In-Reply-To=%3C3d2c22de-b39c-8b46-9163-5bbf52fb3cc1%40web.de%3E"
       TITLE="[squid-users] Stack overflow with large IP lists">magri at web.de
       </A><BR>
    <I>Fri Jul 28 14:51:02 UTC 2023</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025994.html">[squid-users] Stack overflow with large IP lists
</A></li>
        <LI>Next message (by thread): <A HREF="026000.html">[squid-users] Stack overflow with large IP lists
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25999">[ date ]</a>
              <a href="thread.html#25999">[ thread ]</a>
              <a href="subject.html#25999">[ subject ]</a>
              <a href="author.html#25999">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Alex,

visit and walk should share the same problem, but they don't seem to be
used for acls, except for dumping.

Regardless I did a complete rewrite of my patch to remove all recursive
calls in SplayNode. See GitHub Pull Request #1431.

For our large number of IP addresses and clients (request/s) a different
storage type should indeed be better suited to avoid the overhead of
permanent tree rebalancing.


Cheers,
Martin

Am 26.07.23 um 18:22 schrieb Alex Rousskov:
&gt;<i> On 7/26/23 11:25, <A HREF="https://lists.squid-cache.org/listinfo/squid-users">magri at web.de</A> wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> I've attached a patch that modifies the destroy method of SplayNode
</I>&gt;&gt;<i> to avoid recursive calls of destroy in single child nodes by moving
</I>&gt;&gt;<i> the subtrees of the child to the parent node before destroying the
</I>&gt;&gt;<i> child non recursively.
</I>&gt;<i>
</I>&gt;<i> Hi Martin,
</I>&gt;<i>
</I>&gt;<i>  &#160;&#160;&#160; Thanks a lot for sharing your well-documented fix! Would you be
</I>&gt;<i> willing to post it as a GitHub Pull Request? If you do, then the
</I>&gt;<i> following questions can be discussed on GitHub instead:
</I>&gt;<i>
</I>&gt;<i> * The patch reduces recursion during tree destruction. Squid splay tree
</I>&gt;<i> implementation contains other recursive operations (e.g., visit()).
</I>&gt;<i> Would not those other operations suffer from the same problem if left
</I>&gt;<i> untouched? (And, if they are immune, then why not mimic their wonderful
</I>&gt;<i> code to destroy the tree as well?!)
</I>&gt;<i>
</I>&gt;<i> * The proposed patch still destroys one child recursively (when both
</I>&gt;<i> children are present). That feels like an incomplete solution that will
</I>&gt;<i> still hit stack limits on some trees. I do understand that you are
</I>&gt;<i> addressing a specific case of an idle Squid with a freshly configured
</I>&gt;<i> degenerate tree, but there ought to be other cases that lead to similar
</I>&gt;<i> results as well (accidentally or with a malicious actor help). Have you
</I>&gt;<i> considered removing recursion completely instead (by using more heap
</I>&gt;<i> memory as needed)?
</I>&gt;<i>
</I>&gt;<i> * I am curious whether your specific use case (going beyond splay tree
</I>&gt;<i> destruction) be better addressed by a different storage type than splay
</I>&gt;<i> trees. For example, have you considered whether using a IP
</I>&gt;<i> address-friendly hash would be faster for, say, one million IP addresses?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Alex.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 7/26/23 11:25, <A HREF="https://lists.squid-cache.org/listinfo/squid-users">magri at web.de</A> wrote:
</I>&gt;&gt;<i> Hi squid community,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> we experience segfaults with squid 6.1 (and also older versions) during
</I>&gt;&gt;<i> &quot;squid -k reconfigure&quot; on several linux systems, caused by a stack
</I>&gt;&gt;<i> overflow.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The circumstances are rather special:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - we have a huge dst ip blacklist (&gt; 300.000 enties)
</I>&gt;&gt;<i> - this original list is sorted (by raw ip value)
</I>&gt;&gt;<i> - the proxy is a hot standby system so there are no client requests
</I>&gt;&gt;<i> &#160;&#160; between start of squid and reconfigure
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We could trace the cause of the segfault to the destroy-method of
</I>&gt;&gt;<i> SplayNode (in include/splay.h):
</I>&gt;&gt;<i> - destroy of the top node is run on every reconfigure
</I>&gt;&gt;<i> - destroy is recursive, so the function calls stack on the stack :-)
</I>&gt;&gt;<i> &#160;&#160; up to the depth of the splay tree
</I>&gt;&gt;<i> - the insertion of an ordered ip list into the splay tree creates a
</I>&gt;&gt;<i> &#160;&#160; degenerate splay tree (each node has only a left child) with a depth
</I>&gt;&gt;<i> &#160;&#160; of the number of ip entries in the list
</I>&gt;&gt;<i> - due to the inactivity of the proxy there is no rebalancing of the
</I>&gt;&gt;<i> &#160;&#160; tree through find calls
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On amd64 every stack frame needs 32 byte. So the regular linux stack of
</I>&gt;&gt;<i> 8 MB can hold about ~262.000 stack frames. On other architectures
</I>&gt;&gt;<i> the limit is reached even faster (s390x: 160 bytes per stack frame -&gt;
</I>&gt;&gt;<i> 52.000 frames).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We tried to increase the stack size via ulimits and systemd, but though
</I>&gt;&gt;<i> the squid master process got the increased limits, the kid-processes are
</I>&gt;&gt;<i> always spawned with a soft limit of 8 MB and crash on reaching it.
</I>&gt;&gt;<i> Only forcing a new soft limit via prlimit on an already running kid
</I>&gt;&gt;<i> could avoid the crash.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I've attached a patch that modifies the destroy method of SplayNode to
</I>&gt;&gt;<i> avoid recursive calls of destroy in single child nodes by moving the
</I>&gt;&gt;<i> subtrees of the child to the parent node before destroying the child non
</I>&gt;&gt;<i> recursively.
</I>&gt;&gt;<i> With this patch we could no longer reproduce the segfaults, even with a
</I>&gt;&gt;<i> list of 10.000.000 ordered ips.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Any ideas, comments, better solutions?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks in advance for any advice.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> best regards
</I>&gt;&gt;<i> &#160;&#160;Martin
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> squid-users mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="http://lists.squid-cache.org/listinfo/squid-users">http://lists.squid-cache.org/listinfo/squid-users</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025994.html">[squid-users] Stack overflow with large IP lists
</A></li>
	<LI>Next message (by thread): <A HREF="026000.html">[squid-users] Stack overflow with large IP lists
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25999">[ date ]</a>
              <a href="thread.html#25999">[ thread ]</a>
              <a href="subject.html#25999">[ subject ]</a>
              <a href="author.html#25999">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
