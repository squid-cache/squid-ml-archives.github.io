<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] [ext] Re: ftp related crash in squid-6.0.0-20220905-r9358e99f9
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20%5Bext%5D%20Re%3A%20ftp%20related%20crash%20in%0A%20squid-6.0.0-20220905-r9358e99f9&In-Reply-To=%3CZJC%2BGNWAQfikbDUc%40charite.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025877.html">
   <LINK REL="Next"  HREF="025879.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] [ext] Re: ftp related crash in squid-6.0.0-20220905-r9358e99f9</H1>
    <B>Ralf Hildebrandt</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20%5Bext%5D%20Re%3A%20ftp%20related%20crash%20in%0A%20squid-6.0.0-20220905-r9358e99f9&In-Reply-To=%3CZJC%2BGNWAQfikbDUc%40charite.de%3E"
       TITLE="[squid-users] [ext] Re: ftp related crash in squid-6.0.0-20220905-r9358e99f9">Ralf.Hildebrandt at charite.de
       </A><BR>
    <I>Mon Jun 19 20:44:08 UTC 2023</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="025877.html">[squid-users] ftp related crash in squid-6.0.0-20220905-r9358e99f9
</A></li>
        <LI>Next message (by thread): <A HREF="025879.html">[squid-users] [ext] Re: ftp related crash in squid-6.0.0-20220905-r9358e99f9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25878">[ date ]</a>
              <a href="thread.html#25878">[ thread ]</a>
              <a href="subject.html#25878">[ subject ]</a>
              <a href="author.html#25878">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I hope I got it all cut&amp;pasted

&gt;<i>     frame 3
</I>#3  0x000055555570e9c2 in FwdState::completed (this=<A HREF="https://lists.squid-cache.org/listinfo/squid-users">this at entry</A>=0x55556c0a4748) at FwdState.cc:299
299            assert(!storedWholeReply_);

&gt;<i>     print this
</I>$1 = (FwdState * const) 0x55556c0a4748

$2 = {
  &lt;Lock&gt; = {
    _vptr.Lock = 0x555555b6c3b8 &lt;vtable for FwdState+88&gt;,
    count_ = 2
  }, 
  &lt;PeerSelectionInitiator&gt; = {
    &lt;CbdataParent&gt; = {
      _vptr.CbdataParent = 0x555555b6c378 &lt;vtable for FwdState+24&gt;
    }, 
    members of PeerSelectionInitiator:
    subscribed = false
  }, 
  members of FwdState:
  entry = 0x55555e31aaf0,
  request = 0x55562827ab90,
  al = {
    p_ = 0x5555b6ecaec0
  },
  self = {
    p_ = 0x55556c0a4748
  },
  err = 0x0,
  clientConn = {
    p_ = 0x5555dafd6ea0
  },
  start_t = 1687188676,
  n_tries = 1,
  flags = {
    connected_okay = true,
    dont_retry = false,
    forward_completed = true,
    destinationsFound = true
  },
  transportWait = {
    &lt;JobWaitBase&gt; = {
      job_ = {
        cbc = 0x0,
        lock = 0x0
      },
      callback_ = {
        p_ = 0x0
      }
    }, 
    members of JobWait&lt;HappyConnOpener&gt;:
    typedJob_ = {
      cbc = 0x55566ccd1888,
      lock = 0x55566ccd1888
    }
  },
  encryptionWait = {
    &lt;JobWaitBase&gt; = {
      job_ = {
        cbc = 0x0,
        lock = 0x0
      },
      callback_ = {
        p_ = 0x0
      }
    }, 
    members of JobWait&lt;Security::PeerConnector&gt;:
    typedJob_ = {
      cbc = 0x0,
      lock = 0x0
    }
  },
  peerWait = {
    &lt;JobWaitBase&gt; = {
      job_ = {
        cbc = 0x0,
        lock = 0x0
      },
      callback_ = {
        p_ = 0x0
      }
    }, 
    members of JobWait&lt;Http::Tunneler&gt;:
    typedJob_ = {
      cbc = 0x0,
      lock = 0x0
    }
  },
  waitingForDispatched = false,
  destinations = {
    p_ = 0x555654304b50
  },
  serverConn = {
    p_ = 0x0
  },
  destinationReceipt = {
    connection_ = {
      p_ = 0x0
    },
    position_ = 18446744073709551615
  },
  closeHandler = {
    p_ = 0x0
  },
  pconnRace = FwdState::raceImpossible,
  storedWholeReply_ = 0x555555a94350 &quot;ftpReadTransferDone code 226 or 250&quot;
}

&gt;<i> print *entry
</I>
$3 = {
  &lt;hash_link&gt; = {
    key = 0x55556bfa3d50,
    next = 0x5555b6b68468
  }, 
  &lt;Packable&gt; = {
    _vptr.Packable = 0x555555b6ec50 &lt;vtable for StoreEntry+16&gt;
  }, 
  members of StoreEntry:
  mem_obj = 0x55559cd62ca0,
  repl = {
    data = 0x0
  },
  timestamp = -1,
  lastref = 1687188676,
  expires = -1,
  lastModified_ = -1,
  swap_file_sz = 0,
  refcount = 1,
  flags = 1216,
  swap_filen = -1,
  swap_dirn = -1,
  mem_status = NOT_IN_MEMORY,
  ping_status = PING_DONE,
  store_status = STORE_PENDING,
  swap_status = SWAPOUT_NONE,
  cachedESITree = {
    p_ = 0x0
  },
  lock_count = 3,
  shareableWhenPrivate = false,
  deferredProducer = {
    p_ = 0x0
  }
}

&gt;<i> print *entry-&gt;mem_obj
</I>
$4 = {
  appliedUpdates = false,
  method = {
    theMethod = Http::METHOD_GET,
    theImage = {
      id = {
        value = 99694914
      },
      store_ = {
        p_ = 0x555555cb57d0
      },
      off_ = 0,
      len_ = 0
    }
  },
  data_hdr = {
    inmem_hi = 0,
    nodes = {
      head = 0x0,
      elements = 0
    }
  },
  inmem_lo = 0,
  clients = {
    head = 0x55555acdbe30,
    tail = 0x55555acdbe30
  },
  nclients = 1,
  swapout = {
    queue_offset = 0,
    sio = {
      p_ = 0x0
    },
    decision = MemObject::SwapOut::swNeedsCheck
  },
  xitTable = {
    index = -1,
    io = Store::ioUndecided
  },
  memCache = {
    index = -1,
    offset = 0,
    io = Store::ioUndecided
  },
  request = {
    p_ = 0x55562827ab90
  },
  start_ping = {
    tv_sec = 0,
    tv_usec = 0
  },
  ping_reply_callback = 0x0,
  ircb_data = 0x0,
  abortCallback = {
    p_ = 0x5556543f35b0
  },
  repl = {
    data = 0x0
  },
  id = 105121620,
  object_sz = -1,
  swap_hdr_sz = 0,
  vary_headers = {
    id = {
      value = 99694915
    },
    store_ = {
      p_ = 0x555555cb57d0
    },
    off_ = 0,
    len_ = 0
  },
  reply_ = {
    p_ = 0x55563217e040
  },
  updatedReply_ = {
    p_ = 0x0
  },
  storeId_ = {
    size_ = 40,
    len_ = 35,
    buf_ = 0x5555df5d7a50 &quot;<A HREF="ftp://ftp.nimblestorage.com/upload/">ftp://ftp.nimblestorage.com/upload/</A>&quot;
  },
  logUri_ = {
    size_ = 40,
    len_ = 35,
    buf_ = 0x5555e78446a0 &quot;<A HREF="ftp://ftp.nimblestorage.com/upload/">ftp://ftp.nimblestorage.com/upload/</A>&quot;
  },
  deferredReads = {
    deferredReads = {
      head = {
        p_ = 0x0
      },
      tail = {
        p_ = 0x0
      },
      length = 0
    }
  }
}

&gt;<i> frame 10
</I>#10 0x00005555558816f6 in Ftp::Gateway::handleControlReply (this=0x5555662702c8) at FtpGateway.cc:1176
1176	    FTP_SM_FUNCS[state] (this);

&gt;<i> print this
</I>$5 = (Ftp::Gateway * const) 0x5555662702c8

&gt;<i> print *this
</I>$6 = {
  &lt;Ftp::Client&gt; = {
    &lt;Client&gt; = {
      &lt;Adaptation::Initiator&gt; = {
        &lt;AsyncJob&gt; = {
          &lt;CbdataParent&gt; = {
            _vptr.CbdataParent = 0x555555b78ec8 &lt;vtable for Ftp::Gateway+520&gt;
          }, 
          members of AsyncJob:
          id = {
            value = 201681648
          },
          stopReason = 0x0,
          typeName = 0x555555a9355f &quot;FtpStateData&quot;,
          inCall = {
            p_ = 0x5555ff888600
          },
          started_ = true,
          swanSang_ = false
        }, 
        members of Adaptation::Initiator:
        _vptr.Initiator = 0x555555b78cd8 &lt;vtable for Ftp::Gateway+24&gt;
      }, 
      &lt;BodyProducer&gt; = {
        members of BodyProducer:
        _vptr.BodyProducer = 0x555555b78e18 &lt;vtable for Ftp::Gateway+344&gt;
      }, 
      &lt;BodyConsumer&gt; = {
        members of BodyConsumer:
        _vptr.BodyConsumer = 0x555555b78e50 &lt;vtable for Ftp::Gateway+400&gt;
      }, 
      members of Client:
      completed = true,
      currentOffset = 0,
      responseBodyBuffer = 0x0,
      entry = 0x55555e31aaf0,
      fwd = {
        p_ = 0x55556c0a4748
      },
      request = {
        p_ = 0x55562827ab90
      },
      requestBodySource = {
        p_ = 0x0
      },
      requestSender = {
        p_ = 0x0
      },
      virginBodyDestination = {
        p_ = 0x0
      },
      adaptedHeadSource = {
        cbc = 0x0,
        lock = 0x0
      },
      adaptedBodySource = {
        p_ = 0x0
      },
      adaptationAccessCheckPending = false,
      startedAdaptation = false,
      receivedWholeAdaptedReply = false,
      receivedWholeRequestBody = false,
      doneWithFwd = 0x555555a92a12 &quot;completeForwarding()&quot;,
      theVirginReply = 0x0,
      theFinalReply = 0x0
    }, 
    members of Ftp::Client:
    ctrl = {
      &lt;Ftp::Channel&gt; = {
        conn = {
          p_ = 0x0
        },
        listenConn = {
          p_ = 0x0
        },
        closer = {
          p_ = 0x0
        }
      }, 
      members of Ftp::CtrlChannel:
      buf = 0x5556084e8f30 &quot;221 Goodbye.\r\nsend OK.\r\ntory listing.\r\n226 Directory send OK.\r\n####\r\n220-Welcome to the HPE NimbleStorage FTP Server.\r\n220-\r\n220-Please prepend files to be uploaded with your case number\r\n220-so that &quot;...,
      size = 4096,
      offset = 0,
      message = 0x5555b1cb8b80,
      last_command = 0x5555a99543f0 &quot;QUIT\r\n&quot;,
      last_reply = 0x5555bb4e65a0 &quot;Goodbye.&quot;,
      replycode = 221
    },
    data = {
      &lt;Ftp::Channel&gt; = {
        conn = {
          p_ = 0x0
        },
        listenConn = {
          p_ = 0x0
        },
        closer = {
          p_ = 0x0
        }
      }, 
      members of Ftp::DataChannel:
      readBuf = 0x55555e493418,
      host = 0x5555bb42a4e0 &quot;198.54.168.47&quot;,
      port = 6892,
      read_pending = false
    },
    ftp_state_t = Ftp::Client::BEGIN,
    state = 18,
    old_request = 0x0,
    old_reply = 0x0,
    dataConnWait = {
      &lt;JobWaitBase&gt; = {
        job_ = {
          cbc = 0x0,
          lock = 0x0
        },
        callback_ = {
          p_ = 0x0
        }
      }, 
      members of JobWait&lt;Comm::ConnOpener&gt;:
      typedJob_ = {
        cbc = 0x55557d0ec1b8,
        lock = 0x55557d0ec1b8
      }
    },
    shortenReadTimeout = false
  }, 
  members of Ftp::Gateway:
  user = &quot;anonymous&quot;, '\000' &lt;repeats 8182 times&gt;,
  password = &quot;Squid@&quot;, '\000' &lt;repeats 8185 times&gt;,
  password_url = 0,
  reply_hdr = 0x0,
  reply_hdr_state = 0,
  clean_url = {
    size_ = 0,
    len_ = 0,
    buf_ = 0x0
  },
  title_url = {
    size_ = 40,
    len_ = 35,
    buf_ = 0x5555d58c86b0 &quot;<A HREF="ftp://ftp.nimblestorage.com/upload/">ftp://ftp.nimblestorage.com/upload/</A>&quot;
  },
  base_href = {
    size_ = 40,
    len_ = 36,
    buf_ = 0x55559dd8c4f0 &quot;<A HREF="ftp://ftp.nimblestorage.com/upload//">ftp://ftp.nimblestorage.com/upload//</A>&quot;
  },
  conn_att = 0,
  login_att = 0,
  mdtm = -1,
  theSize = -1,
  pathcomps = 0x0,
  filepath = 0x0,
  dirpath = 0x5555e4136d90 &quot;upload&quot;,
  restart_offset = 0,
  proxy_host = 0x0,
  list_width = 0,
  cwd_message = {
    size_ = 40,
    len_ = 36,
    buf_ = 0x5555c4d14f00 &quot;\n250 Directory successfully changed.&quot;
  },
  old_filepath = 0x0,
  typecode = 0 '\000',
  listing = {
    &lt;Packable&gt; = {
      _vptr.Packable = 0x555555b6cab0 &lt;vtable for MemBuf+16&gt;
    }, 
    members of MemBuf:
    buf = 0x5555cc7050c0 &quot;&quot;,
    size = 0,
    max_capacity = 2097152000,
    capacity = 2048,
    stolen = 0
  },
  flags = {
    pasv_supported = true,
    epsv_all_sent = false,
    pasv_only = false,
    pasv_failed = false,
    authenticated = false,
    tried_auth_anonymous = true,
    tried_auth_nopass = false,
    isdir = true,
    skip_whitespace = false,
    rest_supported = true,
    http_header_sent = false,
    tried_nlst = false,
    need_base_href = false,
    dir_slash = false,
    root_dir = false,
    no_dotdot = false,
    binary = false,
    try_slash_hack = false,
    put = false,
    put_mkdir = false,
    listformat_unknown = false,
    listing = true,
    completed_forwarding = true
  }
}

-- 
Ralf Hildebrandt
Charit&#233; - Universit&#228;tsmedizin Berlin
Gesch&#228;ftsbereich IT | Abteilung Netzwerk

Campus Benjamin Franklin (CBF)
Haus I | 1. OG | Raum 105
Hindenburgdamm 30 | D-12203 Berlin

Tel. +49 30 450 570 155
<A HREF="https://lists.squid-cache.org/listinfo/squid-users">ralf.hildebrandt at charite.de</A>
<A HREF="https://www.charite.de">https://www.charite.de</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="025877.html">[squid-users] ftp related crash in squid-6.0.0-20220905-r9358e99f9
</A></li>
	<LI>Next message (by thread): <A HREF="025879.html">[squid-users] [ext] Re: ftp related crash in squid-6.0.0-20220905-r9358e99f9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25878">[ date ]</a>
              <a href="thread.html#25878">[ thread ]</a>
              <a href="subject.html#25878">[ subject ]</a>
              <a href="author.html#25878">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
