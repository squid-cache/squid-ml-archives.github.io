<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] 6.x gives frequent connection to peer failed - spurious?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%206.x%20gives%20frequent%20connection%20to%20peer%20failed%20-%0A%20spurious%3F&In-Reply-To=%3CCAARumMnQZEFAAsxzzsXuf7Of4L%2B60dGQigrz04aEkenj-u4sSg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026392.html">
   <LINK REL="Next"  HREF="026395.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] 6.x gives frequent connection to peer failed - spurious?</H1>
    <B>Tommy Brunn</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%206.x%20gives%20frequent%20connection%20to%20peer%20failed%20-%0A%20spurious%3F&In-Reply-To=%3CCAARumMnQZEFAAsxzzsXuf7Of4L%2B60dGQigrz04aEkenj-u4sSg%40mail.gmail.com%3E"
       TITLE="[squid-users] 6.x gives frequent connection to peer failed - spurious?">tommy.brunn at klarna.com
       </A><BR>
    <I>Mon Jan 29 13:48:06 UTC 2024</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="026392.html">[squid-users] Security advisories are not accessible
</A></li>
        <LI>Next message (by thread): <A HREF="026395.html">[squid-users] FATAL: getpwnam failed to find userid for effective user 'squid'
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26393">[ date ]</a>
              <a href="thread.html#26393">[ thread ]</a>
              <a href="subject.html#26393">[ subject ]</a>
              <a href="author.html#26393">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thank you for sharing your patch to work around this issue. We deploy
Squid in a very similar configuration to what you describe, and we
recently had a problem where a destination was down, causing the peer
squid to be marked as dead even though the peer Squid was just fine
and it was just the upstream destination that was unavailable. The
proposed `cache_peer_fault` directive sounds like it would be a
perfect fit for our case, but in the absence of such a directive we'll
be applying a similar patch to what you shared.

On Wed, Nov 22, 2023 at 11:15&#8239;AM Stephen Borrill &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid at borrill.org.uk</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> On 21/11/2023 15:55, Alex Rousskov wrote:
</I>&gt;<i> &gt; On 2023-11-21 08:38, Stephen Borrill wrote:
</I>&gt;<i> &gt;&gt; On 15/11/2023 21:55, Alex Rousskov wrote:
</I>&gt;<i> &gt;&gt;&gt; On 2023-11-10 05:46, Stephen Borrill wrote:
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; With 6.x (currently 6.5) there are very frequent (every 10 seconds
</I>&gt;<i> &gt;&gt;&gt;&gt; or so) messages like:
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43 kid1| ERROR: Connection to 127.0.0.1:8123 failed
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; why is this logged as a connection failure
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; The current error wording is too assuming and, in your case,
</I>&gt;<i> &gt;&gt;&gt; evidently misleading. The phrase &quot;Connection to X failed&quot; should be
</I>&gt;<i> &gt;&gt;&gt; changed to something more general like &quot;Cannot contact cache_peer X&quot;
</I>&gt;<i> &gt;&gt;&gt; or &quot;Cannot communicate with cache_peer X&quot;.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; CachePeer::countFailure() patches welcome.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; But the point is that it _can_ communicate with the peer, but the peer
</I>&gt;<i> &gt;&gt; itself can't service the request. The peer returning 503 shouldn't be
</I>&gt;<i> &gt;&gt; logged as a connection failure
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; My bad. I missed the fact that the described DNS error happens at a
</I>&gt;<i> &gt; _peer_ Squid. Sorry.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Currently, Squid v6 treats most CONNECT-to-peer errors as a sign of a
</I>&gt;<i> &gt; broken peer. In 2022, 4xx errors were excluded from that set[1]. At that
</I>&gt;<i> &gt; time, we also proposed to make that decision configurable using a new
</I>&gt;<i> &gt; cache_peer_fault directive[2], but the new directive was blocked as an
</I>&gt;<i> &gt; &quot;overkill&quot;[3], so we hard-coded 4xx exclusion instead.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Going forward, you have several options, including these two:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. Convince others that Squid should treat all 503 CONNECT errors from
</I>&gt;<i> &gt; peers as it already treats all 4xx errors. Hard-code that new logic.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 2. Convince others that cache_peer_fault or a similar directive is a
</I>&gt;<i> &gt; good idea rather than an overkill. Resurrect its implementation[2].
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; [1]
</I>&gt;<i> &gt; <A HREF="https://github.com/squid-cache/squid/commit/022dbabd89249f839d1861aa87c1ab9e1a008a47">https://github.com/squid-cache/squid/commit/022dbabd89249f839d1861aa87c1ab9e1a008a47</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; [2]
</I>&gt;<i> &gt; <A HREF="https://github.com/squid-cache/squid/commit/25431f18f2f5e796b8704c85fc51f93b6cc2a73d">https://github.com/squid-cache/squid/commit/25431f18f2f5e796b8704c85fc51f93b6cc2a73d</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; [3] <A HREF="https://github.com/squid-cache/squid/pull/1166#issuecomment-1295806530">https://github.com/squid-cache/squid/pull/1166#issuecomment-1295806530</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 2) seems sensible. Especially in the case where you have a single
</I>&gt;<i> cache_peer and cannot go direct. No benefit to marking it as dead.
</I>&gt;<i>
</I>&gt;<i> However, I'm currently running with 1) as per below and this stops the
</I>&gt;<i> non-existent domains counting against the peer (which surely opens it to
</I>&gt;<i> a DoS attack):
</I>&gt;<i>
</I>&gt;<i> --- src/CachePeer.cc.orig       2023-11-22 08:30:17.524266325 +0000
</I>&gt;<i> +++ src/CachePeer.cc    2023-11-22 08:31:05.394052184 +0000
</I>&gt;<i> @@ -71,7 +71,7 @@
</I>&gt;<i>   void
</I>&gt;<i>   CachePeer::noteFailure(const Http::StatusCode code)
</I>&gt;<i>   {
</I>&gt;<i> -    if (Http::Is4xx(code))
</I>&gt;<i> +    if (Http::Is4xx(code) || code == Http::scServiceUnavailable)
</I>&gt;<i>           return; // this failure is not our fault
</I>&gt;<i>
</I>&gt;<i>       countFailure();
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;&gt;&gt;  &gt; do I need to worry about it beyond it filing up the logs needlessly?
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; In short, &quot;yes&quot;.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; I cannot accurately assess your specific needs, but, in most
</I>&gt;<i> &gt;&gt;&gt; environments, one should indeed worry that their cache_peer server
</I>&gt;<i> &gt;&gt;&gt; names cannot be reliably resolved because failed resolution attempts
</I>&gt;<i> &gt;&gt;&gt; waste Squid resources and increase transaction response time.
</I>&gt;<i> &gt;&gt;&gt; Moreover, if these failures are frequent enough (relative to peer
</I>&gt;<i> &gt;&gt;&gt; usage attempts), the affected cache_peer will be marked as DEAD (as
</I>&gt;<i> &gt;&gt;&gt; you have mentioned):
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;  &gt; 2023/11/09 08:55:22 kid1| Detected DEAD Parent: 127.0.0.1:8123
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Problem seems to be easily reproducible:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; 1# env https_proxy=<A HREF="http://127.0.0.1:8084">http://127.0.0.1:8084</A> curl <A HREF="https://www.invalid.domain/">https://www.invalid.domain/</A>
</I>&gt;<i> &gt;&gt; curl: (56) CONNECT tunnel failed, response 503
</I>&gt;<i> &gt;&gt; 2# grep invalid /usr/local/squid/logs/access.log|tail -1
</I>&gt;<i> &gt;&gt; 1700573429.015      4 127.0.0.1:8084 TCP_TUNNEL/503 0 CONNECT
</I>&gt;<i> &gt;&gt; www.invalid.domain:443 - FIRSTUP_PARENT/127.0.0.1:8123 -
</I>&gt;<i> &gt;&gt; 3# date -r 1700573429 '+%Y/%m/%d %H:%M:%S'
</I>&gt;<i> &gt;&gt; 2023/11/21 13:30:29
</I>&gt;<i> &gt;&gt; 4# grep '2023/11/21 13:30:29' /usr/local/squid/logs/cache.log
</I>&gt;<i> &gt;&gt; 2023/11/21 13:30:29 kid1| ERROR: Connection to 127.0.0.1:8123 failed
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; With 4.x there were no such messages.
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; By comparing to the peer squid logs, these seems to tally with DNS
</I>&gt;<i> &gt;&gt;&gt;&gt; failures:
</I>&gt;<i> &gt;&gt;&gt;&gt; peer_select.cc(479) resolveSelected: PeerSelector1688 found all 0
</I>&gt;<i> &gt;&gt;&gt;&gt; destinations for bugzilla.tucasi.com:443
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; Full ALL,2 log at the time of the reported connection failure:
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 5,2| TcpAcceptor.cc(214) doAccept: New
</I>&gt;<i> &gt;&gt;&gt;&gt; connection on FD 17
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 5,2| TcpAcceptor.cc(316) acceptNext:
</I>&gt;<i> &gt;&gt;&gt;&gt; connection on conn3 local=127.0.0.1:8123 remote=[::] FD 17 flags=9
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 11,2| client_side.cc(1332)
</I>&gt;<i> &gt;&gt;&gt;&gt; parseHttpRequest: HTTP Client conn13206 local=127.0.0.1:8123
</I>&gt;<i> &gt;&gt;&gt;&gt; remote=127.0.0.1:57843 FD 147 flags=1
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 11,2| client_side.cc(1336)
</I>&gt;<i> &gt;&gt;&gt;&gt; parseHttpRequest: HTTP Client REQUEST:
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 85,2| client_side_request.cc(707)
</I>&gt;<i> &gt;&gt;&gt;&gt; clientAccessCheckDone: The request CONNECT bugzilla.tucasi.com:443
</I>&gt;<i> &gt;&gt;&gt;&gt; is ALLOWED; last ACL checked: localhost
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 85,2| client_side_request.cc(683)
</I>&gt;<i> &gt;&gt;&gt;&gt; clientAccessCheck2: No adapted_http_access configuration. default:
</I>&gt;<i> &gt;&gt;&gt;&gt; ALLOW
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 85,2| client_side_request.cc(707)
</I>&gt;<i> &gt;&gt;&gt;&gt; clientAccessCheckDone: The request CONNECT bugzilla.tucasi.com:443
</I>&gt;<i> &gt;&gt;&gt;&gt; is ALLOWED; last ACL checked: localhost
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.162 kid1| 44,2| peer_select.cc(460)
</I>&gt;<i> &gt;&gt;&gt;&gt; resolveSelected: Find IP destination for: bugzilla.tucasi.com:443'
</I>&gt;<i> &gt;&gt;&gt;&gt; via bugzilla.tucasi.com
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.163 kid1| 44,2| peer_select.cc(479)
</I>&gt;<i> &gt;&gt;&gt;&gt; resolveSelected: PeerSelector1526 found all 0 destinations for
</I>&gt;<i> &gt;&gt;&gt;&gt; bugzilla.tucasi.com:443
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.163 kid1| 44,2| peer_select.cc(480)
</I>&gt;<i> &gt;&gt;&gt;&gt; resolveSelected:    always_direct = ALLOWED
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.163 kid1| 44,2| peer_select.cc(481)
</I>&gt;<i> &gt;&gt;&gt;&gt; resolveSelected:     never_direct = DENIED
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.163 kid1| 44,2| peer_select.cc(482)
</I>&gt;<i> &gt;&gt;&gt;&gt; resolveSelected:         timedout = 0
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.163 kid1| 4,2| errorpage.cc(1397) buildBody: No
</I>&gt;<i> &gt;&gt;&gt;&gt; existing error page language negotiated for ERR_DNS_FAIL. Using
</I>&gt;<i> &gt;&gt;&gt;&gt; default error file.
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/10 10:25:43.163 kid1| 33,2| client_side.cc(617) swanSong:
</I>&gt;<i> &gt;&gt;&gt;&gt; conn13206 local=127.0.0.1:8123 remote=127.0.0.1:57843 flags=1
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; If my analysis is correct why is this logged as a connection failure
</I>&gt;<i> &gt;&gt;&gt;&gt; and do I need to worry about it beyond it filing up the logs
</I>&gt;<i> &gt;&gt;&gt;&gt; needlessly?
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; My concern is that this could lead to the parent being incorrectly
</I>&gt;<i> &gt;&gt;&gt;&gt; declared DEAD thus impacting other traffic:
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; 2023/11/09 08:55:22 kid1| Detected DEAD Parent: 127.0.0.1:8123
</I>&gt;<i> &gt;&gt;&gt;&gt;      current master transaction: master4581234
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> squid-users mailing list
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">https://lists.squid-cache.org/listinfo/squid-users</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="026392.html">[squid-users] Security advisories are not accessible
</A></li>
	<LI>Next message (by thread): <A HREF="026395.html">[squid-users] FATAL: getpwnam failed to find userid for effective user 'squid'
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26393">[ date ]</a>
              <a href="thread.html#26393">[ thread ]</a>
              <a href="subject.html#26393">[ subject ]</a>
              <a href="author.html#26393">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
