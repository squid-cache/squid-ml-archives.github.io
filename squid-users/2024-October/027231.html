<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [squid-users] Help regarding access controls for TLS connections
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Help%20regarding%20access%20controls%20for%20TLS%20connections&In-Reply-To=%3C4a203e80-bfd3-46d9-8d39-2719691b14da%40measurement-factory.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027230.html">
   <LINK REL="Next"  HREF="027228.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[squid-users] Help regarding access controls for TLS connections</H1>
    <B>Alex Rousskov</B> 
    <A HREF="mailto:squid-users%40lists.squid-cache.org?Subject=Re%3A%20%5Bsquid-users%5D%20Help%20regarding%20access%20controls%20for%20TLS%20connections&In-Reply-To=%3C4a203e80-bfd3-46d9-8d39-2719691b14da%40measurement-factory.com%3E"
       TITLE="[squid-users] Help regarding access controls for TLS connections">rousskov at measurement-factory.com
       </A><BR>
    <I>Mon Oct 28 16:05:28 UTC 2024</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="027230.html">[squid-users] Help regarding access controls for TLS connections
</A></li>
        <LI>Next message (by thread): <A HREF="027228.html">[squid-users] Rocky Linux 9 and other EL9 RPMs release
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27231">[ date ]</a>
              <a href="thread.html#27231">[ thread ]</a>
              <a href="subject.html#27231">[ subject ]</a>
              <a href="author.html#27231">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 2024-10-28 11:47, Erik Schulz wrote:

&gt;<i> I realized later that I was applying 'localnet' rules before the
</I>&gt;<i> dstdomain rules, which was the cause of the unauthorized dns lookup.
</I>&gt;<i> By rearranging the rules, such that `dstdomain -n` rules are tested
</I>&gt;<i> first, there is no dns lookup.
</I>
Glad you are making progress!


&gt;<i> Well, I do see a reverse dns lookup for
</I>&gt;<i> the client's ip, that I can't explain, but even if that is the case,
</I>&gt;<i> it would require client IP spoofing. But I don't understand why the
</I>&gt;<i> reverse lookup happens. I'm only testing `src`, not `srcdomain`.
</I>
Check access_log (including its default in your Squid build). Some of 
the logformat %codes require reverse DNS lookups (e.g., %&lt;A). Same for 
icap_log and some other logs, but they are not enabled by default IIRC.

If logs are not to blame directly, check whether your Squid code has the 
equivalent of the following commit (available in v6+ but not in v5 
AFAICT): 
<A HREF="https://github.com/squid-cache/squid/commit/a8c7a1107de9d9365dfe10749821f74aeedac777">https://github.com/squid-cache/squid/commit/a8c7a1107de9d9365dfe10749821f74aeedac777</A>


If you want to preclude Squid from making prohibited DNS queries, the 
safest bet may be in configuring Squid to use a DNS resolver (running on 
the same box as Squid) that does not make prohibited DNS queries.  And 
whenever that resolver receives a prohibited DNS query, investigate what 
triggered it -- there may be more bugs in Squid that result in unwanted 
DNS queries. Belt and suspenders...


HTH,

Alex.


&gt;<i> ----
</I>&gt;<i> # deny if not authenticated
</I>&gt;<i> auth_param basic program /usr/lib/squid/basic_ncsa_auth /etc/squid/passwd
</I>&gt;<i> acl authenticated proxy_auth REQUIRED
</I>&gt;<i> http_access deny !authenticated
</I>&gt;<i> 
</I>&gt;<i> # deny if not allowed domains
</I>&gt;<i> acl user_user2 proxy_auth user2
</I>&gt;<i> acl allowed_domains2 dstdomain -n .example.com
</I>&gt;<i> http_access deny user_user2 !allowed_domains2
</I>&gt;<i> 
</I>&gt;<i> # deny public ip
</I>&gt;<i> acl localnet_src src 0.0.0.1-0.255.255.255
</I>&gt;<i> acl localnet_src src 10.0.0.0/8
</I>&gt;<i> acl localnet_src src 100.64.0.0/10
</I>&gt;<i> acl localnet_src src 169.254.0.0/16
</I>&gt;<i> acl localnet_src src 172.16.0.0/12
</I>&gt;<i> acl localnet_src src 192.168.0.0/16
</I>&gt;<i> acl localnet_src src fc00::/7
</I>&gt;<i> acl localnet_src src fe80::/10
</I>&gt;<i> http_access deny !localnet_src
</I>&gt;<i> 
</I>&gt;<i> # deny local destination (resolved hostname)
</I>&gt;<i> acl localnet_dst dst 0.0.0.1-0.255.255.255
</I>&gt;<i> acl localnet_dst dst 10.0.0.0/8
</I>&gt;<i> acl localnet_dst dst 100.64.0.0/10
</I>&gt;<i> acl localnet_dst dst 169.254.0.0/16
</I>&gt;<i> acl localnet_dst dst 172.16.0.0/12
</I>&gt;<i> acl localnet_dst dst 192.168.0.0/16
</I>&gt;<i> acl localnet_dst dst fc00::/7
</I>&gt;<i> acl localnet_dst dst fe80::/10
</I>&gt;<i> http_access deny localnet_dst
</I>&gt;<i> 
</I>&gt;<i> acl Safe_ports port 80
</I>&gt;<i> acl Safe_ports port 443
</I>&gt;<i> http_access deny !Safe_ports
</I>&gt;<i> 
</I>&gt;<i> cache deny all
</I>&gt;<i> 
</I>&gt;<i> http_access allow
</I>&gt;<i> ----
</I>&gt;<i> 
</I>&gt;<i> Regarding what DNS egress attack is:
</I>&gt;<i> The use of a forward proxy (&quot;egress controller&quot;) is to prevent
</I>&gt;<i> unauthorized egress, i.e. leaking any data, including TLS or CA
</I>&gt;<i> private keys, which can be relatively few bytes.
</I>&gt;<i> Unauthorized DNS egress is low bandwidth, but that doesn't matter.
</I>&gt;<i> Here is a ChatGPT explanation of what a DNS egress attack is:
</I>&gt;<i> ---
</I>&gt;<i> A DNS egress attack exploits DNS queries to stealthily extract
</I>&gt;<i> sensitive information from within a network. Here&#8217;s how it operates
</I>&gt;<i> and why it&#8217;s effective:
</I>&gt;<i> - DNS as a Covert Channel: DNS requests are typically unfiltered and
</I>&gt;<i> allowed through most firewalls. Attackers use DNS requests to
</I>&gt;<i> exfiltrate data by embedding information in DNS queries, which often
</I>&gt;<i> bypasses traditional egress filters.
</I>&gt;<i> - Steganography in DNS Requests: Attackers encode sensitive
</I>&gt;<i> information (like passwords or encryption keys) into DNS request
</I>&gt;<i> subdomains. For example, a query like data1234.attacker.com can encode
</I>&gt;<i> data (data1234) before resolving to the attacker-controlled domain.
</I>&gt;<i> - Recursive Resolver Complicity: Since DNS queries are recursively
</I>&gt;<i> resolved, intermediate DNS resolvers help propagate the data-laden
</I>&gt;<i> requests to the final DNS server controlled by the attacker. This adds
</I>&gt;<i> complexity to tracking and blocking the egress path.
</I>&gt;<i> - Low Detectability: Normal DNS queries blend into typical network
</I>&gt;<i> traffic, making these attacks hard to detect, especially if small
</I>&gt;<i> amounts of data are exfiltrated over time.
</I>&gt;<i> - Mitigation Gaps: Most firewalls overlook the payload within DNS
</I>&gt;<i> queries, focusing instead on blocking IPs or domains, which doesn't
</I>&gt;<i> stop the encoding of sensitive data in the DNS request itself.
</I>&gt;<i> - DNS data egress attacks are potent because they exploit a
</I>&gt;<i> foundational internet protocol for covert data transmission. Solutions
</I>&gt;<i> demand vigilant DNS traffic analysis and strict egress filtering
</I>&gt;<i> policies.
</I>&gt;<i> ---
</I>&gt;<i> 
</I>&gt;<i> On Mon, Oct 28, 2024 at 12:14&#8239;AM Alex Rousskov
</I>&gt;<i> &lt;<A HREF="https://lists.squid-cache.org/listinfo/squid-users">rousskov at measurement-factory.com</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 2024-10-25 18:18, Erik Schulz wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I would like to use squid as an egress proxy, to prevent unauthorized egress.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Let's say that the only allowed egress is 'example.com'.
</I>&gt;&gt;&gt;<i> I can define acl along the lines of:
</I>&gt;&gt;&gt;<i> ```
</I>&gt;&gt;&gt;<i> acl allowed_domains ssl::server_name .example.com
</I>&gt;&gt;&gt;<i> http_access allow allowed_domains
</I>&gt;&gt;&gt;<i> ```
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But can someone help me understand what actually happens?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A lot of thing happens, including: After parsing received HTTP(S) or FTP
</I>&gt;&gt;<i> request, Squid checks http_access rules and either allows or denies the
</I>&gt;&gt;<i> request. For HTTPS requests that are subject to ssl_bump rules, that
</I>&gt;&gt;<i> processing happens multiple times, at various SslBump steps, as detailed
</I>&gt;&gt;<i> at <A HREF="https://wiki.squid-cache.org/Features/SslPeekAndSplice">https://wiki.squid-cache.org/Features/SslPeekAndSplice</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> N.B. http_access check is a part of &quot;Callout Sequence&quot; referenced on the
</I>&gt;&gt;<i> above page in step1 and step2. There are some bugs in the current Squid
</I>&gt;&gt;<i> implementation of that document, but it is still a useful starting point.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I want to avoid any DNS egress attack.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> How do you define &quot;DNS egress attack&quot;? To the extent possible, please
</I>&gt;&gt;<i> answer in terms of what Squid should or should not do with traffic Squid
</I>&gt;&gt;<i> receives.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The client does not have DNS access.
</I>&gt;&gt;&gt;<i> Am I correct that the client can use HTTPS_PROXY without DNS, such
</I>&gt;&gt;&gt;<i> that the proxy will perform the DNS lookup?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you do not control the client, then you should assume that it can
</I>&gt;&gt;<i> send any request to/through Squid. This includes sending an HTTPS
</I>&gt;&gt;<i> requests without using DNS. Whether the proxy receiving the request is
</I>&gt;&gt;<i> going to perform a DNS lookup is a separate question. Many factors
</I>&gt;&gt;<i> affect that proxy decision.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Can you help me understand how the acl checks the server_name?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You already know how server_name documentation answers this question. It
</I>&gt;&gt;<i> is not clear to me what undocumented aspects you want to know about.
</I>&gt;&gt;<i> Could you please clarify by asking a more specific question?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In order to connect to the server, it must perform a DNS lookup, which
</I>&gt;&gt;&gt;<i> causes a leak.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sorry, I am not sure what &quot;it&quot; is in this context, but, as you probably
</I>&gt;&gt;<i> already know from the same docs, &quot;Unlike dstdomain, [ssl::server_name]
</I>&gt;&gt;<i> ACL does not perform DNS lookups.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If Squid needs to connect to server X, and X is a domain name, Squid
</I>&gt;&gt;<i> will (in most cases) attempt to resolve X to get server IP address(es),
</I>&gt;&gt;<i> but that attempt happens before and/or after Sqiud evaluates
</I>&gt;&gt;<i> ssl::server_name ACL.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So the ACL must validate the server_name without a DNS lookup, and
</I>&gt;&gt;&gt;<i> since the server IP is therefore unknown, without connecting to the
</I>&gt;&gt;&gt;<i> server or verifying against its certificate.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> During server_name ACL evaluation, Squid does not attempt to connection
</I>&gt;&gt;<i> to any other server or service. The ACL match/mismatch decision is made
</I>&gt;&gt;<i> by comparing various strings using either domain comparison function
</I>&gt;&gt;<i> (for server_name) or regex evaluation (for server_name_regex).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The server IP address may or may not be known at ssl::server_name
</I>&gt;&gt;<i> evaluation time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'm assuming the hostname is known in the CONNECT phase of the request?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Assuming that CONNECT request has arrived at http_port, the answer
</I>&gt;&gt;<i> depends on many factors, possibly including:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * whether the client supplied a hostname in CONNECT request headers;
</I>&gt;&gt;<i> * whether the client supplied a hostname in TLS SNI field;
</I>&gt;&gt;<i> * whether the CONNECT request is subject to ssl_bump rules;
</I>&gt;&gt;<i> * whether Squid is opening a tunnel to an origin server or cache_peer
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Is it possible to check against the connect hostname only?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Without SslBump, &quot;dstdomain -n&quot; would probably do that. With SslBump,
</I>&gt;&gt;<i> &quot;dstdomain -n&quot; would probably do that during SslBump step1 (and step2 if
</I>&gt;&gt;<i> client does not supply TLS SNI). All this needs careful testing though;
</I>&gt;&gt;<i> there are many configuration parameters and request specifics at play here!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The docs say that
</I>&gt;&gt;&gt;&gt;<i> &quot;The ACL computes server name(s) using such information sources as CONNECT request URI, TLS client SNI, and TLS server certificate subject (CN and SubjectAltName). The computed server name(s) usually change with each SslBump step&quot;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I find this concerning, because I assume the client could perform a
</I>&gt;&gt;&gt;<i> request with an IP, and a forged SNI name that passes the acl.
</I>&gt;&gt;&gt;<i> So I would like to only allow requests that declare FQDN hostname, and
</I>&gt;&gt;&gt;<i> reject IP hostnames.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You probably can use dstdomain_reject to reject IP-based hostnames, but
</I>&gt;&gt;<i> it may not be easy to do it reliably using regular expressions because
</I>&gt;&gt;<i> IP addresses come in many forms. Squid is probably missing an
</I>&gt;&gt;<i> &quot;dst_is_ip&quot; or similar ACL(s) to make such checks reliable.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> And, only perform validation against the CONNECT request URI.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> See above regarding using &quot;dstdomain -n&quot; for this.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> HTH,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Alex.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> squid-users mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">squid-users at lists.squid-cache.org</A>
</I>&gt;&gt;<i> <A HREF="https://lists.squid-cache.org/listinfo/squid-users">https://lists.squid-cache.org/listinfo/squid-users</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="027230.html">[squid-users] Help regarding access controls for TLS connections
</A></li>
	<LI>Next message (by thread): <A HREF="027228.html">[squid-users] Rocky Linux 9 and other EL9 RPMs release
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27231">[ date ]</a>
              <a href="thread.html#27231">[ thread ]</a>
              <a href="subject.html#27231">[ subject ]</a>
              <a href="author.html#27231">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.squid-cache.org/listinfo/squid-users">More information about the squid-users
mailing list</a><br>
</body></html>
