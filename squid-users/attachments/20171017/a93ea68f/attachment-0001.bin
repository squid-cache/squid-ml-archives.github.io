const http = require('http'), mUrl = require('url');
const kPort = 8001;
const kData = 'koeoit eieioos nncmc[pwwaa[[w mnkkkdg',
  kBuffer = new Buffer(4096),
  kEtag = '"jieeuutnxo"';
const header = {
    'Content-Type': 'text/plain',
    'Vary': 'Accept-Encoding',
    'Last-Modified': 'Fri, 10 Mar 2017 10:18:12 GMT',
    'Etag': '',
    'Cache-Control': 'max-age=31536000',
    // 对于 HTTP 1.1 客户端，node.js 会自动生成'Transfer-Encoding': 'chunked' 和 'Connection': 'keep-alive' 这两个头，
    // 但对 1.0 不会。ab（Apache HTTP server benchmarking tool）是 1.0 的。
    // 对于 http 1.0 的客户端，由于不支持 Transfer-Encoding: chunked 所以响应里必须有 Content-length 才能使用 keep-alive。
    // squid 不会自动生成 Content-length，也就是说，如果上游服务器的响应采用 chunked，而客户端是 1.0 的，则客户端连接不可能使用使用 keep-alive。
    // 'Transfer-Encoding': 'chunked',
    'Connection': 'keep-alive',
    'Content-Length': 0,
};
var varData = null;

function onRequest(req, res) {
  const pUrl = mUrl.parse(req.url);
  const len = Number.parseInt(pUrl.pathname.slice(1)) || kBuffer.length;
  header.Etag = '"' + len + '"'
  header['Content-Length'] = '' + len;
  res.writeHead(200, header);
  if (req.method == 'HEAD') {
    res.end();
    return;
  }
  let remain = len, sErr;
  const step = err => {
    if (err || sErr) {
      return;
    }
    if(remain > 0) {
      const wb = remain > kBuffer.length ? kBuffer : kBuffer.slice(0, remain);
      remain -= kBuffer.length;
      res.write(wb, step);
    } else {
      res.end();
    }
  }
  res.on('error', err => {
    console.log('Error:' + req.url + ' , ', err);
    sErr = err;
  });
  step();
}

kBuffer.fill(kData);

const server = http.createServer()
  .on('request', onRequest)
  .listen(kPort);
  
console.log('listening ' + kPort);
