--- a/src/ssl/crtd_message.cc
+++ b/src/ssl/crtd_message.cc
@@ -206,7 +206,7 @@
     i = map.find(Ssl::CrtdMessage::param_Sign);
     if (i != map.end()) {
         if ((certProperties.signAlgorithm = Ssl::certSignAlgorithmId(i->second.c_str())) == Ssl::algSignEnd) {
-            error = "Wrong signing algoritm: ";
+            error = "Wrong signing algorithm: ";
             error += i->second;
             return false;
         }
--- a/CREDITS
+++ b/CREDITS
@@ -1631,7 +1631,7 @@
  * (C) 2000 Antonino Iannella, Stellar-X Pty Ltd
  * Released under GPL, see COPYING-2.0 for details.

- * Released under GNU Public License
+ * Released under GNU General Public License
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
--- a/compat/getaddrinfo.cc
+++ b/compat/getaddrinfo.cc
@@ -8,7 +8,7 @@

 /*
  *  Shamelessly duplicated from the fetchmail public sources
- *  for use by the Squid Project under GNU Public License.
+ *  for use by the Squid Project under GNU General Public License.
  *
  * Update/Maintenance History:
  *
--- a/compat/getaddrinfo.h
+++ b/compat/getaddrinfo.h
@@ -11,7 +11,7 @@

 /*
  *  Shamelessly duplicated from the fetchmail public sources
- *  for use by the Squid Project under GNU Public License.
+ *  for use by the Squid Project under GNU General Public License.
  *
  * Update/Maintenance History:
  *
--- a/compat/getnameinfo.cc
+++ b/compat/getnameinfo.cc
@@ -8,7 +8,7 @@

 /*
  *  Shamelessly duplicated from the fetchmail public sources
- *  for use by the Squid Project under GNU Public License.
+ *  for use by the Squid Project under GNU General Public License.
  *
  * Update/Maintenance History:
  *
--- a/compat/strnstr.cc
+++ b/compat/strnstr.cc
@@ -11,7 +11,7 @@

 /*
  *  Shamelessly duplicated from the FreeBSD public sources
- *  for use by the Squid Project under GNU Public License.
+ *  for use by the Squid Project under GNU General Public License.
  *
  * Update/Maintenance History:
  *
--- a/compat/xstrto.cc
+++ b/compat/xstrto.cc
@@ -11,7 +11,7 @@

 /*
  *  Shamelessly duplicated from the netfilter iptables sources
- *  for use by the Squid Project under GNU Public License.
+ *  for use by the Squid Project under GNU General Public License.
  *
  * Reason for use as explained by Luciano Coelho:
  * "I found that there is a bug in strtoul (and strtoull for
--- a/src/auth/basic/SMB_LM/msntauth.cc
+++ b/src/auth/basic/SMB_LM/msntauth.cc
@@ -21,7 +21,7 @@
  * Bill Welliver 1999
  * Duane Wessels 2000 (wessels@squid-cache.org)
  *
- * Released under GNU Public License
+ * Released under GNU General Public License
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
--- a/src/cf.data.pre
+++ b/src/cf.data.pre
@@ -3455,7 +3455,7 @@
                concurrency=

        The number of requests each certificate validator helper can handle in
-       parallel. A value of 0 indicates the certficate validator does not
+       parallel. A value of 0 indicates the certificate validator does not
        support concurrency. Defaults to 1.

        When this directive is set to a value >= 1 then the protocol
--- a/src/security/ServerOptions.cc
+++ b/src/security/ServerOptions.cc
@@ -217,7 +217,7 @@
         if (certs.size() > 1) {
             // NOTE: calling SSL_CTX_use_certificate() repeatedly _replaces_ the previous cert details.
             //       so we cannot use it and support multiple server certificates with OpenSSL.
-            debugs(83, DBG_CRITICAL, "ERROR: OpenSSL does not support multiple server certificates. Ignoring addional cert= parameters.");
+            debugs(83, DBG_CRITICAL, "ERROR: OpenSSL does not support multiple server certificates. Ignoring additional cert= parameters.");
         }

         const auto &keys = certs.front();
--- a/src/security/cert_generators/file/certificate_db.cc
+++ b/src/security/cert_generators/file/certificate_db.cc
@@ -537,7 +537,7 @@
     subSize(filename);
     int ret = remove(filename.c_str());
     if (ret < 0 && errno != ENOENT)
-        throw std::runtime_error("Failed to remove certficate file " + filename + " from db");
+        throw std::runtime_error("Failed to remove certificate file " + filename + " from db");
 }

 bool Ssl::CertificateDb::deleteInvalidCertificate() {
--- a/src/ssl/support.cc
+++ b/src/ssl/support.cc
@@ -365,7 +365,7 @@
                 filledCheck->serverCert.reset();
             }
             // If the certificate validator is used then we need to allow all errors and
-            // pass them to certficate validator for more processing
+            // pass them to certificate validator for more processing
             else if (Ssl::TheConfig.ssl_crt_validator) {
                 ok = 1;
             }
--- a/src/client_side.cc
+++ b/src/client_side.cc
@@ -2655,7 +2655,7 @@
             if (reply.result != Helper::Okay) {
                 debugs(33, 5, "Certificate for " << tlsConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply_message.getBody());
             } else {
-                debugs(33, 5, "Certificate for " << tlsConnectHostOrIp << " was successfully recieved from ssl_crtd");
+                debugs(33, 5, "Certificate for " << tlsConnectHostOrIp << " was successfully received from ssl_crtd");
                 if (sslServerBump && (sslServerBump->act.step1 == Ssl::bumpPeek || sslServerBump->act.step1 == Ssl::bumpStare)) {
                     doPeekAndSpliceStep();
                     auto ssl = fd_table[clientConnection->fd].ssl.get();